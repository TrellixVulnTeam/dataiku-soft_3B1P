(function(){
    'use strict';

    var services = angular.module('dataiku.services');

    services.factory('Diagnostics', function ($timeout, DataikuAPI, WT1, MessengerUtils) {
        function getLatest(success) {
            DataikuAPI.admin.diagnostics.getLatest().success(success);
        }
        function downLoadLatest () {
            var url = "/dip/api/admin/diagnostics/get-results";
            diagnosisDownloader.attr('src', url);
            $('body').append(diagnosisDownloader);
        }
        var diagnosisDownloader = $('<iframe>').attr('id', 'diagnosis-downloader');

        return {
            getLatest: getLatest, // only fetches metadata
            downLoadLatest: downLoadLatest
        };
    });

    services.factory('Logs', function(DataikuAPI) {

        function download(logFileName) {
            var url = "/dip/api/admin/logs/get-files?name=";
            if (logFileName) {
                url += logFileName;
            }
            logsDownloader.attr('src', url);
            $('body').append(logsDownloader);
        }

        function downloadDesignCodeEnv(envLang, envName, logName) {
            var url = "/dip/api/code-envs/design/stream-log?envLang=" + envLang + "&envName=" + encodeURIComponent(envName) + "&logName=" + encodeURIComponent(logName);
            logsDownloader.attr('src', url);
            $('body').append(logsDownloader);
        }

        function downloadAutomationCodeEnv(envLang, envName, logName) {
            var url = "/dip/api/code-envs/automation/stream-log?envLang=" + envLang + "&envName=" + encodeURIComponent(envName) + "&logName=" + encodeURIComponent(logName);
            logsDownloader.attr('src', url);
            $('body').append(logsDownloader);
        }

        function downloadCluster(clusterId, logName) {
            var url = "/dip/api/clusters/stream-log?clusterId=" + encodeURIComponent(clusterId) + "&logName=" + encodeURIComponent(logName);
            logsDownloader.attr('src', url);
            $('body').append(logsDownloader);
        }

        function downloadAll() {
            download(null)
        }

        function list() {
            return DataikuAPI.admin.logs.list();
        }

        function cat(logFileName) {
            return DataikuAPI.admin.logs.get(logFileName);
        }

        var logsDownloader = $('<iframe>').attr('id', 'logs-downloader');

        return {
            list: list,
            cat: cat,
            download: download,
            downloadAll: downloadAll,
            downloadDesignCodeEnv: downloadDesignCodeEnv,
            downloadAutomationCodeEnv: downloadAutomationCodeEnv,
            downloadCluster: downloadCluster
        };
    });
})();
(function () {
'use strict';

var app = angular.module('dataiku.admin', []);


app.controller("AdminGeneralSettingsController", function ($scope, $state, $stateParams, $timeout, $q, DataikuAPI, WT1, ActivityIndicator, TopNav, CodeMirrorSettingService, TaggingService, FutureProgressModal, Dialogs, $rootScope, $filter, GlobalProjectActions) {


    if ($state.is('admin.general')) {
        $state.go('admin.general.themes');
    }

    $scope.httpMethods = ['GET', 'POST', 'OPTIONS', 'PUT', 'DELETE', 'HEAD'];

    $scope.virtualWebAppBackendSettingsModes = [{id:"USE_DEFAULT", label:"Run as local processes"}, {id:"EXPLICIT", label:"Run in container"}];
    
	if ($stateParams.uiState && uiStates.indexOf($stateParams.uiState) > -1) {
		$scope.uiState.active = $stateParams.uiState;
	}

    $scope.globalVariables = {}
    TopNav.setLocation(TopNav.DSS_HOME, "administration");

    $scope.alationRegister = {
    }

    DataikuAPI.security.listUsers().success(function(data) {
        $scope.allUsers = data;
    }).error(setErrorInScope.bind($scope));

	var savedGeneralSettings, savedGlobalVariables, savedChannels;
    $scope.dirtySettings = function () {
        return !angular.equals($scope.generalSettings, savedGeneralSettings) ||
            !angular.equals($scope.globalVariables.asJSON, savedGlobalVariables) ||
            !angular.equals($scope.channels, savedChannels);
    };
    
    function allowedTransitionsFn(data) {
        return (data.toState && data.fromState && data.toState.name.startsWith('admin.general') && data.fromState.name.startsWith('admin.general'));
    }
    checkChangesBeforeLeaving($scope, $scope.dirtySettings, null, allowedTransitionsFn);


    $scope.load = function () {

    	var promises = [];
    	promises.push(DataikuAPI.admin.getGeneralSettings());
    	promises.push(DataikuAPI.admin.getGlobalVariables());
    	promises.push(DataikuAPI.admin.integrationChannels.list());
    	promises.push(DataikuAPI.admin.getThemes());

    	$scope.promises = $q.all(promises).then(
			function (values) {
				//general settigns
				$scope.generalSettings = values[0].data;
	            savedGeneralSettings = angular.copy($scope.generalSettings);
	            //global variables
	            $scope.globalVariables.asJSON = JSON.stringify(values[1].data, null, 2);
	            savedGlobalVariables = angular.copy($scope.globalVariables.asJSON);
	            //messaging channels
	            $scope.channels = values[2].data;
	            savedChannels = angular.copy($scope.channels);
	            //themes
	            $scope.themes = values[3].data;

                // fixup customFieldsPluginComponentOrder
                $scope.generalSettings.customFieldsPluginComponentOrder = $scope.generalSettings.customFieldsPluginComponentOrder
                    .filter(ref1 => $scope.appConfig.customFieldsPluginComponentRefs.find(ref2 => ref2.pluginId == ref1.pluginId && ref2.componentId == ref1.componentId));
                for (let i = 0; i < $scope.appConfig.customFieldsPluginComponentRefs.length; i++) {
                    const ref1 = $scope.appConfig.customFieldsPluginComponentRefs[i];
                    const existingRef = $scope.generalSettings.customFieldsPluginComponentOrder.find(ref2 => ref2.pluginId == ref1.pluginId && ref2.componentId == ref1.componentId);
                    if (!existingRef) {
                        $scope.generalSettings.customFieldsPluginComponentOrder.push(ref1);
                    }
                }
                // fixup customPolicyHooksPluginComponentOrder
                $scope.generalSettings.customPolicyHooksPluginComponentOrder = $scope.generalSettings.customPolicyHooksPluginComponentOrder
                    .filter(ref1 => $scope.appConfig.customPolicyHooksPluginComponentRefs.find(ref2 => ref2.pluginId == ref1.pluginId && ref2.componentId == ref1.componentId));
                for (let i = 0; i < $scope.appConfig.customPolicyHooksPluginComponentRefs.length; i++) {
                    const ref1 = $scope.appConfig.customPolicyHooksPluginComponentRefs[i];
                    const existingRef = $scope.generalSettings.customPolicyHooksPluginComponentOrder.find(ref2 => ref2.pluginId == ref1.pluginId && ref2.componentId == ref1.componentId);
                    if (!existingRef) {
                        $scope.generalSettings.customPolicyHooksPluginComponentOrder.push(ref1);
                    }
                }
	    	},
	    	function (errors) {
	    		setErrorInScope.bind($scope);
	    	}
    	);
    };

    $scope.$watchCollection("channels", function (nv) {
        if (nv) {
            $scope.mailChannels = $scope.channels.filter(function (channel) {
                return ["smtp", "aws-ses-mail"].includes(channel.type);
            });
            if ($scope.generalSettings && $scope.mailChannels.map(c => c.id).indexOf($scope.generalSettings.notifications.emailChannelId) < 0) {
                $scope.generalSettings.notifications.emailChannelId = void 0;
            }
        }
    });

    $scope.load();

    $scope.autofillStudioUrl = function() {
        $scope.generalSettings.studioExternalUrl = urlWithProtocolAndHost();
    };

    function removeEmptyGitConfigurationOptions() {
        $scope.generalSettings.git.enforcedConfigurationRules.forEach((configRule) => {
            configRule.gitConfigurationOptions = configRule.gitConfigurationOptions.filter(option => !option.$invalid);
        });
    }

    $scope.invalidTabs = new Set();

    $scope.$on("$stateChangeStart", function(event, toState, toParams, fromState) {
        // We do not set 'Resource control' tab as invalid to avoid weird UI behavior. For this tab, a ng-model is not
        // changed if the new input value is not valid. Hence if a user exits the 'Resource control' tab with some
        // invalid fields and then switch back to it, the fields will no longer be invalid, which can be confusing.
        if ($scope.adminGeneralIndexForm.$invalid && fromState.name !== 'admin.general.limits') {
            $scope.invalidTabs.add(fromState.name);
        }
        $timeout(function() {
            $scope.invalidTabs.delete(toState.name);
        });
    });

    $scope.isAdminGeneralIndexFormInvalid = function() {
        return $scope.adminGeneralIndexForm.$invalid || $scope.invalidTabs.size;
    }

    function fetchGlobalTagsIfChanged() {
        if (!angular.equals($scope.generalSettings.globalTagsCategories, savedGeneralSettings.globalTagsCategories)) {
            TaggingService.fetchGlobalTags(true);
        }
    }

    function checkForDuplicateNames (list, type) {
        let names = [];

        list.forEach(function(element) {
            if (!element.name) {
                throw({message: "Found empty " + type + " name"});
            }
            if (names.includes(element.name)) {
                throw({message: "Found duplicate " + type + " names: " + element.name});
            }
            names.push(element.name);
        });
    }

	$scope.saveGeneralSettings = function () {
		return DataikuAPI.admin.saveGeneralSettings($scope.generalSettings).success(function (data) {
		    fetchGlobalTagsIfChanged();
            savedGeneralSettings = angular.copy($scope.generalSettings);
        }).error(setErrorInScope.bind($scope));
    };

    $scope.updateGlobalTags = function() {
        if (angular.equals($scope.generalSettings.globalTagsCategories, savedGeneralSettings.globalTagsCategories)) return;
        let updatedGlobalTagsMap = {};
        let update = false;
        const toDelete = ['isEdited', 'isNew', 'originalTagName', 'removeUsage'];
        //Map the global tags with their original- and updated name to update the tag on object across the instance
        $scope.generalSettings.globalTagsCategories.forEach(function(category, index) {
            category.globalTags.forEach(function(tag, idx) {
                let originalCategoryName = savedGeneralSettings.globalTagsCategories[index] && savedGeneralSettings.globalTagsCategories[index].name;
                if (originalCategoryName && (tag.originalTagName || originalCategoryName != category.name)) {
                    let oldGlobalTagName = `${originalCategoryName}:${tag.originalTagName || tag.name}`
                    updatedGlobalTagsMap[oldGlobalTagName] = {color: tag.color, updatedTagName: `${category.name}:${tag.name}`, globalTagsCategory: category.name, removeUsage: tag.removeUsage};
                    update = true;
                }
                var it = $scope.generalSettings.globalTagsCategories[index].globalTags[idx];
                toDelete.forEach(k => delete it[k]);
            });
            delete category.isNew;
        });
        if (update) DataikuAPI.admin.globalTags.updateGlobalTags(updatedGlobalTagsMap);
        return updatedGlobalTagsMap;
    };

    $scope.invalidateConfigCache = function() {
        var options = {type: 'text'};
        $scope.cacheInvalidationError = {};
        Dialogs.prompt($scope, "Invalidate cache", "Path to invalidate", "", options)
               .then(function(path) {
                   DataikuAPI.admin.invalidateConfigCache(path).error(setErrorInScope.bind($scope.cacheInvalidationError));
                });
    };

    /**
    *   Save the generalSettings, global variables and integrations channels and perform all checks prior to that
    *   Needs to return a promise and shouldn't just return, as cmd+s serves a fallback to force save
    */
    $scope.save = function () {
        try {
            removeEmptyGitConfigurationOptions();

            checkForDuplicateNames($scope.generalSettings.containerSettings.executionConfigs, "container configuration");
            checkForDuplicateNames($scope.generalSettings.sparkSettings.executionConfigs, "Spark configuration");
            checkForDuplicateNames($scope.generalSettings.globalTagsCategories, "global category");

            var updatedGlobalTagsMap = $scope.updateGlobalTags();

            var gv = JSON.parse($scope.globalVariables.asJSON || '{}');
            return $scope.saveGeneralSettings().then(function () {
            	return DataikuAPI.admin.integrationChannels.saveAll($scope.channels).success(function (data) {
                    $scope.channels = data;
                    savedChannels = angular.copy(data);
                    return DataikuAPI.admin.saveGlobalVariables(gv).success(function (data) {
                        savedGlobalVariables = angular.copy($scope.globalVariables.asJSON);
                        $scope.$broadcast('generalSettingsSaved', updatedGlobalTagsMap);
                        if ($scope.isAdminGeneralIndexFormInvalid()) {
                            const allInvalidTabs = Array.from($scope.invalidTabs).map(tab => $state.get(tab).pageTitle());
                            if ($scope.adminGeneralIndexForm.$invalid) {
                                allInvalidTabs.push($state.current.pageTitle());
                            }
                            const warningMessage = "Saved with some invalid fields in tab" +
                                ($scope.invalidTabs.size + $scope.adminGeneralIndexForm.$invalid > 1 ? "s '" : " '") +
                                allInvalidTabs.join("', '") + "'";
                            ActivityIndicator.warning(warningMessage);
                        } else {
                            ActivityIndicator.success("Saved!");
                        }
                        // special cases: flags that need to be in appConfig for the corresponding options to be available
                        // in the frontend: impalaEnabled, etc
                        // note : settings are not sent back from the backend, but that's fine because they are saved as is
                        $scope.appConfig.impalaEnabled = $scope.generalSettings.impalaSettings.enabled && $scope.appConfig.hadoopEnabled;
                        $scope.appConfig.pluginDevExplicitCommit = $scope.generalSettings.pluginDevExplicitCommit;
                        $scope.appConfig.npsSurveyEnabled = $scope.generalSettings.npsSurveyEnabled;
                        $scope.appConfig.nodeName = $scope.generalSettings.nodeName;
                        $scope.appConfig.helpIntegrationEnabled = $scope.generalSettings.helpIntegrationEnabled;
                        $scope.appConfig.projectStatusList = $scope.generalSettings.projectStatusList;
                        $scope.appConfig.homeMessages = $scope.generalSettings.homeMessages;
                        $scope.appConfig.apiDeployerStages = $scope.generalSettings.apiDeployerServerSettings.stages;
                        $scope.appConfig.studioForgotPasswordUrl = $scope.generalSettings.studioForgotPasswordUrl;
                    }).error(setErrorInScope.bind($scope));
            	}).error(setErrorInScope.bind($scope));
            }).catch(setErrorInScope.bind($scope));
        } catch (err) {
            ActivityIndicator.error("Invalid format: "+err.message);
        }
    };

    $scope.registerAlationOpener = function(){
        $scope.save().then(function(){
            DataikuAPI.connections.registerAlationOpener($scope.alationRegister.alationAPIToken).success(function(){
                ActivityIndicator.success("Alation registration done")
            }).error(setErrorInScope.bind($scope));
        })
    }

    DataikuAPI.connections.getNames('SQL')
        .success(function (data) { $scope.sqlConnections = data; })
        .error(setErrorInScope.bind($scope));

    $scope.lambdaDevServerPoll = function () {
        DataikuAPI.lambda.devServer.getStatus().success(function (data) {
            $scope.lambdaDevServerStatus = data;
        });
    };
    $scope.lambdaDevServerPoll();

    $scope.lambdaDevServerStop = function () {
        DataikuAPI.lambda.devServer.stop().success(function (data) {
            $scope.lambdaDevServerStatus = data;
        });
    };

	$scope.testLdapSettings = function () {
        $scope.ldapTesting = true;
        $scope.ldapTestResult = null;
		DataikuAPI.admin.testLdapSettings($scope.generalSettings.ldapSettings).success(function (data) {
            $scope.ldapTestResult = data;
        }).error(setErrorInScope.bind($scope));
        $scope.ldapTesting = false;
    };

    $scope.testLdapGetUserDetails = function (userName) {
        $scope.ldapTesting = true;
        $scope.ldapTestUserDetails = null;
		DataikuAPI.admin.testLdapGetUserDetails({
            settings:$scope.generalSettings.ldapSettings,
            username:userName
        }).success(function (data) {
            $scope.ldapTestUserDetails = data;
        }).error(
            setErrorInScope.bind($scope)
        ).finally(
            $scope.ldapTesting = false
        );
	};

    $scope.addGroupProfile = function () {
        var groupProfiles = $scope.generalSettings.ldapSettings.groupProfiles

        if (!groupProfiles || !$.isArray(groupProfiles)) {
            $scope.generalSettings.ldapSettings.groupProfiles = []
        }
        $scope.generalSettings.ldapSettings.groupProfiles.push({key: '', value: $scope.generalSettings.ldapSettings.userProfile});
    };

    $scope.deleteGroupProfile = function (index) {
        $scope.generalSettings.ldapSettings.groupProfiles.splice(index, 1)
    };

    $scope.getChannelTypeLabel = function (type) {
        if (!type) {
            return "Unknown";
        } else if (type === 'msft-teams') {
            return "Microsoft Teams";
        } else if (type === 'aws-ses-mail') {
            return "Mail (via Amazon SES)";
        } else if (type === 'smtp') {
            return "Mail (SMTP)";
        } else {
            return type.charAt(0).toUpperCase() + type.slice(1);
        }
    };

	$scope.addChannel = function (type) {
	    var definition = {
            type : type,
            configuration : {
                sessionProperties: []
            },
            $creation : true //flag to allow id edition only on creation
        };
        if (type === 'slack' || type === 'webhook' || type === 'twilio' || type === 'msft-teams') {
            definition.configuration.useProxy = true;
        }
        if (type === 'slack') {
            definition.configuration.mode = 'WEBHOOK';
        }
		$scope.channels.push(definition)
	};

	$scope.removeChannel = function (channel) {
		var index = $scope.channels.indexOf(channel);
        if (index >= 0) {
            $scope.channels.splice(index, 1);
        }
	};

    DataikuAPI.admin.clusters.listAccessible('HADOOP').success(function(data){
        $scope.clusters = [{id:null, name:'No override'}].concat(data);
    }).error(setErrorInScope.bind($scope));

    DataikuAPI.admin.clusters.listAccessible('KUBERNETES').success(function(data){
        $scope.k8sClusters = [{id:null, name:'No override'}].concat(data);
    }).error(setErrorInScope.bind($scope));

    $scope.DEPLOYER_MODES = [
        ["DISABLED", "Disabled"],
        ["LOCAL", "Local"],
        ["REMOTE", "Remote"]
    ]
    $scope.DEPLOYER_MODES_DESCRIPTIONS = [
        "Disable ability to publish models and projects on the Deployer",
        "Use this DSS instance as Deployer",
        "Publish models and projects on a remote Deployer"
    ]


    $scope.pushBaseImages = function(){
        if($scope.dirtySettings()) {
            $scope.save().then($scope.pushBaseImages_NoCheckDirty());
        } else {
            $scope.pushBaseImages_NoCheckDirty();
        }
    }

    $scope.pushBaseImages_NoCheckDirty = function(){
        DataikuAPI.admin.containerExec.pushBaseImages().success(function(data) {
            // FutureProgressModal.show($scope, data, "Pushing base images");
            FutureProgressModal.show($scope, data, "Pushing base images").then(function(result){
                if (result) { // undefined in case of abort
                    Dialogs.infoMessagesDisplayOnly($scope, "Push result", result.messages, result.futureLog);
                }
            })
        }).error(setErrorInScope.bind($scope));
    }

    $scope.hideDatasetTypesOptions = (() => {
        const datasetName = $filter('datasetTypeToName');
        const rawDatasetsTiles = GlobalProjectActions.getAllDatasetByTilesNoFilter(); // call without scope is valid because we won't use the clickCallbacks fields.
        const res = [];
        rawDatasetsTiles.forEach(tile => {
            const allTypes = tile.types.concat(tile.types2 || [])
            allTypes.forEach(type => {
                if(type === undefined) return; // ignore the ones hidden by feature-flags.
                res.push({
                    tile: tile.title,
                    value: type.type,
                    displayName: type.label !== undefined ? type.label : datasetName(type.type),
                });
            });
        });

        // this is a special case, the 'search_and_import' behaviour doesn't exist in the new dataset page.
        res.push({
            tile: 'Import existing',
            value: 'search_and_import',
            displayName: 'Search and import\u2026',
        });
        return res;
    })();

});


app.controller("AdminVariablesController", function ($scope, $state, $stateParams, DataikuAPI, WT1, TopNav) {
    TopNav.setLocation(TopNav.DSS_HOME, "administration");
    $scope.executeVariablesUpdate = function () {
        $scope.save().then(function () {
            DataikuAPI.admin.executeVariablesUpdate().success(function () {
                $state.transitionTo( $state.current, angular.copy($stateParams), { reload: true, inherit: true, notify: true } );
            }).error(setErrorInScope.bind($scope));
        });
    }
});


app.controller("AdminThemeController", function ($scope, $rootScope, TopNav) {
    TopNav.setLocation(TopNav.DSS_HOME, "administration");

    $scope.getThemeThumbnailUrl = function (theme) {
        var uri = $scope.getThemeUri(theme);
        return uri + theme.thumbnail;
    };

    $scope.setCurrentTheme = function (theme) {
        // saving theme content in app config
    	if (theme) {
    		$scope.generalSettings.themeId = theme.id;
    	} else {
    		delete $scope.generalSettings.themeId;
    	}
        $scope.saveGeneralSettings().then(function () {
            // visualy setting theme
        	$rootScope.appConfig.theme = theme;
        	$scope.setTheme(theme);
        }).catch(setErrorInScope.bind($scope));
    };

    $scope.removeHomeMessage = function (homeMessage) {
		var index = $scope.generalSettings.homeMessages.indexOf(homeMessage);
    	if (index != -1) {
    		$scope.generalSettings.homeMessages.splice(index, 1);
    	}
    };
});


app.controller("DeleteGlobalCategoryModalController", function ($scope, $rootScope, $controller) {

    function remove(index) {
        let items = $scope.generalSettings.globalTagsCategories[index].globalTags;
        items.forEach(function(item) {
            item.originalTagName = item.name;
            item.name = "";
            item.removeUsage = true;
        });
        $scope.updateGlobalTags();
        deleteKeep(index);
    };

    function deleteKeep(index) {
        $scope.generalSettings.globalTagsCategories.splice(index, 1);
        // setTimeout : when the form was invalid but is valid after deleting the category
        // give time to update or it will fail on checkFormValidity
        setTimeout(() => $scope.save());
    };

    function reassign(index, reassignTo) {
        if (reassignTo === undefined) return;
        $scope.generalSettings.globalTagsCategories[index].name = $scope.generalSettings.globalTagsCategories[reassignTo].name;
        $scope.updateGlobalTags();
        const tagsName = $scope.generalSettings.globalTagsCategories[reassignTo].globalTags.map(it => it.name);
        var mergedGlobalTags = angular.copy($scope.generalSettings.globalTagsCategories[reassignTo].globalTags);
        $scope.generalSettings.globalTagsCategories[index].globalTags.forEach(function(tag) {
            if (!tagsName.includes(tag.name)){
                mergedGlobalTags.push(tag);
            }
        });
        $scope.generalSettings.globalTagsCategories[reassignTo].globalTags = mergedGlobalTags;
        deleteKeep(index);
    }

    $scope.doDeleteGlobalCategory = function() {
        switch ($scope.deletionMode) {
            case 'remove':
                remove($scope.index);
                break;
            case 'reassign':
                reassign($scope.index, $scope.reassignTo);
                break;
            case 'keep':
                deleteKeep($scope.index);
                break;
        }
        $scope.dismiss();
    };

});

app.controller("MergeGlobalTagsModalController", function ($scope, $rootScope, $controller) {

    $scope.doMergeTags = function() {
        $scope.items.forEach(function(item) {
            item.originalTagName = item.name;
            item.name = $scope.outputTag.name;
            item.color = $scope.outputTag.color;
        });
        if (!$scope.generalSettings.globalTagsCategories[$scope.index].globalTags.find(it => (it.originalTagName || it.name) === $scope.outputTag.name)) {
            $scope.items.shift();
        }
        $scope.updateGlobalTags();
        let indexes = $scope.items.map(it => it.$idx);
        $scope.generalSettings.globalTagsCategories[$scope.index].globalTags = $scope.generalSettings.globalTagsCategories[$scope.index].globalTags.filter((it, index) => !indexes.includes(index));
        $scope.save();
        $scope.dismiss();
    }
});

app.controller("DeleteGlobalTagsModalController", function ($scope, $rootScope) {

    function remove(items) {
        items.forEach(function(item) {
            item.originalTagName = item.name;
            item.name = "";
            item.removeUsage = true;
        });
        $scope.updateGlobalTags();
        deleteKeep(items);
    };

    function deleteKeep(items) {
        let indexes = items.map(it => it.$idx);
        $scope.generalSettings.globalTagsCategories[$scope.index].globalTags = $scope.generalSettings.globalTagsCategories[$scope.index].globalTags.filter((it, index) => !indexes.includes(index));
        // setTimeout : when the form was invalid but is valid after deleting the tag(s)
        // give time to update or it will fail on checkFormValidity
        setTimeout(() => $scope.save());
    };

    function reassign(items, reassignTo) {
        if (reassignTo === undefined) return;
        items.forEach(function(item) {
            item.originalTagName = item.name;
            item.name = reassignTo;
        });
        $scope.updateGlobalTags();
        deleteKeep(items);
    }

    $scope.doDeleteGlobalTags = function() {
        switch ($scope.deletionMode) {
            case 'remove':
                remove($scope.items);
                break;
            case 'reassign':
                reassign($scope.items, $scope.reassignTo);
                break;
            case 'keep':
                deleteKeep($scope.items);
                break;
        }
        $scope.dismiss();
    };
});

app.controller("GlobalTagsController", function ($scope, $element, $timeout, TaggingService, CreateModalFromTemplate, TAGGABLE_TYPES, DataikuAPI) {
    $scope.taggableTypes = [ // Must be kept in sync with ITaggingService.TaggableType
        'PROJECT',
        'ANALYSIS',
        'SAVED_MODEL',
        'DATASET',
        'RECIPE',
        'MANAGED_FOLDER',
        'STREAMING_ENDPOINT',
        'FLOW_ZONE',
        'SQL_NOTEBOOK',
        'JUPYTER_NOTEBOOK',
        'STATISTICS_WORKSHEET',
        'SCENARIO',
        'DASHBOARD',
        'INSIGHT',
        'ARTICLE',
        'WEB_APP',
        'REPORT',
        'LAMBDA_SERVICE'
    ];

    $scope.computeItemTemplate = function() {
        return {name: '', color: TaggingService.getDefaultColor(Math.random().toString(36).slice(2)), isNew: true};
    };

    $scope.addCategory = function() {
        $scope.generalSettings.globalTagsCategories.push({name: '', globalTags: [], appliesTo: $scope.taggableTypes, isNew: true});
        //focus new category name
        $timeout(function() {
            const focusable = $element.find('input[ng-model="category.name"]').last();
            if (focusable) {
                focusable.focus()
            }
        });
    };

    $scope.calcGlobalTagUsage = function() {
        DataikuAPI.catalog.search("", {scope:['dss'], _type:['ALL']}, true).then((data) => {
            $scope.tagUsageMap = data.data.aggregations["tag.raw"].agg.buckets.reduce(function(map, obj) {
                map[obj.key] = obj.doc_count;
                return map;
            }, {});
        });
    };
    $scope.calcGlobalTagUsage();

    $scope.$on('generalSettingsSaved', $scope.calcGlobalTagUsage);

    $scope.getGlobalTagUsage = function(category, item) {
        if (!$scope.tagUsageMap) return 0;
        let tagName = item.originalTagName || item.name;
        return $scope.tagUsageMap[`${category}:${tagName}`];
    };

    $scope.linkToCatalog = function(category, item) {
        const tagName = item.originalTagName || item.name;
        const globalTagName = (`${category}:${tagName}`).replace(/\\/g,'%5C').replace(/\//g,'~2F').replace(/&/g, '%5C&');
        return `/catalog/search/scope=all&tag.raw=${globalTagName}`;
    };

    $scope.updateItem = function(category, originalTagName, item) {
        if (!item.isEdited) {
            item.isEdited = true;
            item.originalTagName = originalTagName;
        }
    }

    $scope.mergeTags = function(index, items) {
        CreateModalFromTemplate("/templates/global-tags/merge-global-tags-modal.html", $scope, "MergeGlobalTagsModalController", function(modalScope) {
            modalScope.index = index;
            modalScope.items = items;

            modalScope.outputTag = angular.copy(items[0]);
        });
    };

    $scope.deleteGlobalCategory = function(index, categoryName) {
        if ($scope.generalSettings.globalTagsCategories[index].isNew) {
            $scope.generalSettings.globalTagsCategories.splice(index, 1);
            return;
        }
        CreateModalFromTemplate("/templates/global-tags/delete-global-category-modal.html", $scope, "DeleteGlobalCategoryModalController", function(modalScope) {
            modalScope.deletionMode = "remove";
            modalScope.index = index;
            modalScope.categoryName = categoryName;
            modalScope.assignableCategoryList = $scope.generalSettings.globalTagsCategories.filter(cat => cat.name != categoryName).map((cat, idx) => idx >= index ? idx + 1 : idx);
        });
    };

    $scope.deleteGlobalTags = function(index, items) {
        CreateModalFromTemplate("/templates/global-tags/delete-global-tags-modal.html", $scope, "DeleteGlobalTagsModalController", function(modalScope) {
            modalScope.modalTitle = `Delete global tag${items.length > 1 ? 's' : ''}`;
            modalScope.deletionMode = "remove";
            modalScope.index = index;
            modalScope.items = items;
            modalScope.assignableTagsList = $scope.generalSettings.globalTagsCategories[index].globalTags.filter(it => !items.includes(it)).map(it => it.name);
        });
    };
});

app.controller("ProjectStatusController", function ($scope, $rootScope, TopNav, DKUConstants, TaggingService) {
    $scope.defaultTagColor = TaggingService.getDefaultColor;

    $scope.newStatus = {
        name: '',
        defaultColor: TaggingService.getDefaultColor('')
    };

    //Isolating the archived status so that it does not get deleted nor reorder
    $scope.projectStatusList = [];
    $scope.promises.then(function (values) {
        $scope.projectStatusList = angular.copy($scope.generalSettings.projectStatusList);
        var archivedStatusIndex =  $scope.projectStatusList.findIndex(function (status) {
            return status.name ==  DKUConstants.ARCHIVED_PROJECT_STATUS;
        });
        var archivedStatus = archivedStatusIndex > -1 ? $scope.projectStatusList.splice(archivedStatusIndex, 1) : [];

        //On local projectStatusList change recomputing generalSettings.projectStatusList with the archived status at its end
        $scope.$watch('projectStatusList', function () {
            $scope.generalSettings.projectStatusList = $scope.projectStatusList.concat(archivedStatus);
        }, true);
    });
});


app.controller("AdminLicensingController", function ($scope, $state, CreateModalFromTemplate, TopNav, DataikuAPI) {
    TopNav.setLocation(TopNav.DSS_HOME, "administration");
    $scope.$state = $state;

	$scope.enterLicense = function () {
		CreateModalFromTemplate("/templates/admin/enter-license.html", $scope, "EnterLicenseController");
	};

    $scope.getLimits = function () {
        if ($scope.isDSSAdmin()) {
            DataikuAPI.admin.getLimitsStatus().success(function (data) {
                $scope.limits = data;
            }).error(setErrorInScope.bind($scope));
        }
    };

    $scope.getLimits();
});


app.controller("EnterLicenseController", function ($scope, $state, $rootScope, DataikuAPI, Assert, TopNav) {
	TopNav.setLocation(TopNav.DSS_HOME, "administration");
    Assert.inScope($scope, "appConfig");

    $scope.existingKey = {}

    $scope.reloadMe = function () {
        $scope.dismiss();
        location.reload();
    };

    $scope.setLicense = function () {
        DataikuAPI.registration.setOfflineLicense($scope.existingKey.license).success(function (data) {
            $scope.registrationSuccessful = {};
        }).error(setErrorInScope.bind($scope));
    };
});


//Integration channels to report info outside of dss:


app.controller("SMTPChannelController", function ($scope, $state, $stateParams, DataikuAPI) {

});


app.controller("SlackChannelController", function ($scope, $state, $stateParams, DataikuAPI) {

});


app.controller("TeamsChannelController", function ($scope, $state, $stateParams, DataikuAPI) {
    if ($scope.channel.configuration.useProxy === undefined) {
        $scope.channel.configuration.useProxy = false;
    }
});

app.controller("WebhookChannelController", function ($scope, $state, $stateParams, DataikuAPI) {

});


app.controller("ShellChannelController", function ($scope, $state, $stateParams, DataikuAPI, TopNav, CodeMirrorSettingService) {
	TopNav.setLocation(TopNav.DSS_HOME, "administration");
	$scope.channel.configuration.type = $scope.channel.configuration.type || 'COMMAND';
	$scope.editorOptions = CodeMirrorSettingService.get('text/x-sh', {onLoad: function(cm) {$scope.cm = cm;}});

	$scope.shellSenderTypes = [{type:'FILE',name:'Script file'}, {type:'COMMAND',name:'Command'}];

	$scope.getCommandLine = function () {
	    if ( $scope.channel.configuration.type == 'FILE' ) {
	        if ( $scope.channel.configuration.command ) {
	            return "sh -c " + $scope.channel.configuration.command + " script_file";
	        } else {
	            return "sh script_file";
	        }
	    } else {
	        return $scope.channel.configuration.command;
	    }
	};
});


app.controller("DatasetChannelController", function ($scope, $state, $stateParams, DataikuAPI, TopNav) {
	TopNav.setLocation(TopNav.DSS_HOME, "administration");

    DataikuAPI.projects.list().success(function (data) {
        $scope.projectsList = data;
    }).error(setErrorInScope.bind($scope));

    $scope.$watch('channel.configuration.projectKey', function () {
    	if ($scope.channel.configuration.projectKey == null ) return;
        DataikuAPI.datasets.list($scope.channel.configuration.projectKey).success(function (data) {
            $scope.datasetsList = data;
        }).error(setErrorInScope.bind($scope));
    });
});

app.controller("ContainerSettingsController", function($scope, DataikuAPI, Dialogs, Assert, TopNav, FutureProgressModal, CodeMirrorSettingService) {
    TopNav.setLocation(TopNav.DSS_HOME, "administration");
    Assert.inScope($scope, "appConfig");
    Assert.inScope($scope, "addLicInfo");
    Assert.inScope($scope, "generalSettings");

    $scope.codeMirrorSettingService = CodeMirrorSettingService;
    $scope.settings = $scope.generalSettings.containerSettings;

    $scope.getNewContainerConfig = function() {
        return {
            type: 'KUBERNETES',
            usableBy: 'ALL', allowedGroups: [],
            dockerNetwork: 'host',
            dockerResources: [],
            kubernetesResources: {
                memRequestMB: -1, memLimitMB: -1,
                cpuRequest: -1, cpuLimit: -1,
                customRequests: [], customLimits: [],
                hostPathVolumes: []
            },
            properties: []
        };
    };

    DataikuAPI.security.listGroups(false)
        .success(data => {
            if (data) {
                data.sort();
            }
            $scope.allGroups = data;
        })
        .error(setErrorInScope.bind($scope));

    $scope.isBaseImageNameSuspicious = function(baseImage) {
        return /^(?:[\w-_]+\.)+\w+(?::\d+)?\//.test(baseImage);
    };

    $scope.installJupyterSupport = function(){
        DataikuAPI.admin.containerExec.installJupyterSupport().success(function(data) {
            FutureProgressModal.show($scope, data, "(Re)Installing kernels").then(function(result){
                if (result) { // undefined in case of abort
                    Dialogs.infoMessagesDisplayOnly($scope, "Update result", result.messages, result.futureLog);
                }
            })
        }).error(setErrorInScope.bind($scope));
    }

    $scope.removeJupyterSupport = function(){
        DataikuAPI.admin.containerExec.removeJupyterSupport().success(function(data) {
            FutureProgressModal.show($scope, data, "Removing kernels").then(function(result){
                if (result) { // undefined in case of abort
                    Dialogs.infoMessagesDisplayOnly($scope, "Update result", result.messages, result.futureLog);
                }
            })
        }).error(setErrorInScope.bind($scope));
    }

    $scope.applyK8SPolicies = function() {
        DataikuAPI.admin.containerExec.applyK8SPolicies().success(function(data) {
            FutureProgressModal.show($scope, data, "Applying Kubernetes policies").then(function(result){
                if (result) {
                    Dialogs.infoMessagesDisplayOnly($scope, "Policies applied", result, result.futureLog, true);
                }
            });
        }).error(setErrorInScope.bind($scope));
    }
});


app.controller('AdminPersonalHomePagesController', function($scope) {});

})();

(function () {
    'use strict';

    var app = angular.module('dataiku.connections', []);

    /* Base controller used both for ConnectionsList and hive indexing (as a lot of layout and actions are common) */
    app.controller("_ConnectionsListBaseController", function ($scope, TopNav, DataikuAPI, Dialogs, $timeout, $state, ConnectionUtils, CreateModalFromTemplate, FutureProgressModal) {
        $scope.noTags = true;
        $scope.noStar = true;
        $scope.noWatch = true;
        $scope.noDelete = false;
        $scope.canIndexConnections = true;
        $scope.canCreateConnection = $state.is('admin.connections.list');
        $scope.noDelete = !$state.is('admin.connections.list');
        $scope.selection = $.extend({
            filterQuery: {
                userQuery: '',
                tags: [],
                interest: {
                    starred: '',
                },
            },
            filterParams: {
                userQueryTargets: ["name", "type", "tags"],
                propertyRules: {"tag": "tags"}
            },
            orderQuery: "creationTag.lastModifiedOn",
            orderReversed: false,
        }, $scope.selection || {});
        $scope.sortBy = [
            {value: 'name', label: 'Name'},
            {value: 'type', label: 'Type'},
            {value: 'creationTag.lastModifiedOn', label: 'Creation date'}
        ];

        TopNav.setLocation(TopNav.DSS_HOME, "administration");
        let pollPromise;

        function processRunningJobsRequest(data) {
            let doRunningJobsRemain = false;

            $scope.listItems.forEach(conn => {
                if (conn.name in data) {
                    conn.indexingMetadata = data[conn.name];
                    if (conn.indexingMetadata.currentJobId) {
                        doRunningJobsRemain = true;
                    }
                } else if (conn.indexingMetadata && conn.metadata.currentJobId) {
                    delete conn.indexingMetadata.currentJobId;
                }
            });
            return doRunningJobsRemain;
        }

        $scope.pollRunningJobs = function () {
            $timeout.cancel(pollPromise);
            DataikuAPI.admin.connections.listRunningJobs().success(function (data) {
                let doRunningJobsRemain = processRunningJobsRequest(data);
                if (doRunningJobsRemain) {
                    pollPromise = $timeout(() => {
                        $scope.pollRunningJobs();
                    }, 5000);
                }
            });
        }

        $scope.isIndexable = connection => ConnectionUtils.isIndexable(connection);

        $scope.list = function () {
            var func = $state.is('admin.connections.hiveindexing') ? DataikuAPI.admin.connections.listHiveVirtual : DataikuAPI.admin.connections.list;
            func().success(function (data) {
                $scope.connections = data;
                $scope.listItems = $.map(data, function (v, k) {
                    return v;
                });
                $scope.canIndexAllConnections = $scope.listItems.length > 0;
                if ($scope.listItems.find(c => c.indexingMetadata && c.indexingMetadata.currentJobId)) {
                    $scope.pollRunningJobs();
                }
            }).error(setErrorInScope.bind($scope));
        };
        $scope.$on("$destroy", function () {
            pollPromise && $timeout.cancel(pollPromise);
        });

        $scope.$on("indexConnectionEvent", (event, connectionName) => {
            createIndexConnectionsModal([connectionName]);
        });

        $scope.list();

        $scope.deleteSelected = function (name) {
            var selectedConnectionsNames = $scope.selection.selectedObjects.map(function (c) {
                return c.name;
            });
            Dialogs.confirm($scope, 'Connection deletion', 'Are you sure you want to delete this connection ?').then(function () {
                DataikuAPI.admin.connections.delete(selectedConnectionsNames).success(function (data) {
                    $scope.list();
                }).error(setErrorInScope.bind($scope));
            });
        };

        let createIndexConnectionsModal = function (connectionNames) {
            const newScope = $scope.$new();
            newScope.selectedConnections = connectionNames;
            CreateModalFromTemplate("/templates/admin/index-connections-modal.html", newScope, 'IndexConnectionsModalController');
        };

        $scope.indexSelectedConnections = function () {
            createIndexConnectionsModal($scope.selection.selectedObjects.map(function (c) {
                return c.name;
            }));
        };

        $scope.isIndexationRunning = function () {
            return $scope.listItems && $scope.listItems.find(c => {
                    return c && c.indexingMetadata && c.indexingMetadata.currentJobId;
                });
        };

        $scope.abortIndexation = function () {
            DataikuAPI.admin.connections.abortIndexation()
                .success(function (data) {
                    processRunningJobsRequest(data);
                })
                .error(setErrorInScope.bind($scope));
        };

        $scope.indexAllConnections = function () {
            CreateModalFromTemplate("/templates/admin/index-connections-modal.html", $scope, 'IndexConnectionsModalController');
        };

    });

    app.controller("ConnectionsController", function ($scope, $controller, TopNav, DataikuAPI, Dialogs, $timeout, $stateParams, ConnectionUtils, CreateModalFromTemplate) {
        $controller("_ConnectionsListBaseController", { $scope: $scope });
    });

    app.controller("ConnectionsHiveIndexingController", function ($scope, $controller, TopNav, DataikuAPI, Dialogs, $timeout, $stateParams, ConnectionUtils, CreateModalFromTemplate) {
        $controller("_ConnectionsListBaseController", { $scope: $scope });
    });

    app.controller("IndexConnectionsModalController", function ($scope, $state, $stateParams, TopNav, DataikuAPI, $timeout, FutureProgressModal, Dialogs) {
        $scope.indexationMode = 'scan';
        $scope.loading = true;

        DataikuAPI.admin.connections.listProcessableConnections($scope.type, $scope.selectedConnections).success(function (response) {
            $timeout(() => {
                $scope.loading = false;
                $scope.processableConnections = response;
                $scope.$digest();
            })
        }).error(setErrorInScope.bind($scope));

        $scope.canStartIndexation = function () {
            return $scope.processableConnections && (
                    $scope.indexationMode === 'index' && $scope.processableConnections.indexableConnections.length ||
                    $scope.indexationMode === 'scan' && $scope.processableConnections.scannableConnections.length
                );
        };
        $scope.startIndexation = function () {
            let indexationFunction;
            let connectionsToProcess;

            if ($scope.indexationMode === 'index') {
                indexationFunction = DataikuAPI.admin.connections.index;
                connectionsToProcess = $scope.processableConnections.indexableConnections;
            } else if ($scope.indexationMode === 'scan') {
                indexationFunction = DataikuAPI.admin.connections.scan;
                connectionsToProcess = $scope.processableConnections.scannableConnections;
            }

            indexationFunction(connectionsToProcess).success(function (data) { // NOSONAR: OK this call is indeed a method call.
                var parentScope = $scope.$parent.$parent;
                $scope.pollRunningJobs();
                FutureProgressModal.show(parentScope, data, "Indexing", newScope => newScope.tellToCloseWindow = true).then(function(result){
                    if (result) {
                        Dialogs.infoMessagesDisplayOnly(parentScope, "Indexing result", result);
                    }
                });
                $scope.dismiss();
            }).error(setErrorInScope.bind($scope));
        };
    });

    app.controller("ConnectionController", function ($scope, $rootScope, $state, $stateParams, Assert, TopNav, DataikuAPI) {

        TopNav.setLocation(TopNav.DSS_HOME, "administration");

        $scope.connectionParamsForm = {};

        // Angular guys do not want to support the validation of an Angular input inside an AngularJS form, so handling validity through booleans.
        // See https://github.com/angular/angular/issues/9213.
        $scope.areAdvancedPropertiesInvalid = false;
        $scope.areAdvancedConnectionPropertiesInvalid = false;

        $scope.setAdvancedPropertiesValidity = function(isValid) {
            $scope.areAdvancedPropertiesInvalid = !isValid;
        }

        $scope.setAdvancedConnectionPropertiesValidity = function(isValid) {
            $scope.areAdvancedConnectionPropertiesInvalid = !isValid;
        }

        $scope.isConnectionParamsFormInvalid = function() {
            return $scope.connectionParamsForm.$invalid || $scope.areAdvancedPropertiesInvalid || $scope.areAdvancedConnectionPropertiesInvalid;
        }

        DataikuAPI.admin.connections.list().success(function (data) {
            $scope.connections = data;
        }).error(setErrorInScope.bind($scope));

        DataikuAPI.security.listGroups(false).success(function (data) {
            if (data) {
                data.sort();
            }
            $scope.allGroups = data;
        });

        function $canHaveProxy(connectionType) {
            return $scope.appConfig.hasGlobalProxy &&
                ['ElasticSearch', 'HTTP', 'FTP', 'EC2', 'GCS', 'Twitter', 'BigQuery'].indexOf(connectionType) >= 0;
        }

        $scope.isFsProviderizable = function (t) {
            return ['Filesystem', 'FTP', 'SSH', 'HDFS', 'Azure', 'GCS', 'EC2'].indexOf(t) >= 0;
        };

        Assert.trueish($stateParams.connectionName || $stateParams.type, "no $stateParams.connectionName and no $stateParams.type");
        if ($stateParams.connectionName) {
            $scope.creation = false;
            DataikuAPI.admin.connections.get($stateParams.connectionName).success(function (data) {
                savedConnection = angular.copy(data);
                $scope.connection = data;
                $scope.connection.$canHaveProxy = $canHaveProxy(data.type);
                $scope.loadDone = true;
            }).error(setErrorInScope.bind($scope));
        } else if ($stateParams.type) {
            $scope.creation = true;
            savedConnection = null;
            $scope.connection = {
                "type": $stateParams.type,
                "params": {
                    namingRule: {}
                },
                "credentialsMode": "GLOBAL",
                "allowWrite": true, "allowManagedDatasets": true,
                "allowMirror": ($stateParams.type == "Vertica" || $stateParams.type == "ElasticSearch"),
                "usableBy": "ALL",
                "$canHaveProxy": $canHaveProxy($stateParams.type),
                "useGlobalProxy": $stateParams.type == 'ElasticSearch' ? false : $canHaveProxy($stateParams.type)
            };

            /* Per connection defaults */
            if ($scope.connection.type == "BigQuery") {
                $scope.connection.params.properties = [
                    { "name": "Timeout", "value": 180, "secret": false }
                ]
                $scope.connection.params.credentialsMode = "KEYPAIR";
                $scope.connection.params.driverMode = "CUSTOM";
            } else if ($scope.connection.type == "Redshift") {
                $scope.connection.params.driverMode = "MANAGED_LEGACY_POSTGRESQL";
                $scope.connection.params.redshiftAuthenticationMode = "USER_PASSWORD";
            } else if ($scope.connection.type == "Greenplum") {
                $scope.connection.params.driverMode = "MANAGED_LEGACY_POSTGRESQL";
            } else if ($scope.connection.type == "PostgreSQL") {
                $scope.connection.params.driverMode = "MANAGED";
            } else if ($scope.connection.type == "Snowflake") {
                $scope.connection.params.driverMode = "MANAGED";
            } else if ($scope.connection.type == "Teradata") {
                $scope.connection.params.properties = [
                    { "name": "CHARSET", "value": "UTF8", "secret": false }
                ]
            } else if ($scope.connection.type == "SSH") {
                $scope.connection.params.port = 22;
            } else if ($scope.connection.type == "HDFS") {
                $scope.connection.params.hiveSynchronizationMode = 'KEEP_IN_SYNC';
            } else if ($scope.connection.type == "EC2") {
                $scope.connection.params.credentialsMode = "KEYPAIR";
            } else if ($scope.connection.type == "Synapse") {
                // The first option is here to keep compatibility with SQLServer. It should not be used.
                $scope.connection.params.azureDWH = true;
                $scope.connection.params.autocommitMode = true;
            } else if ($scope.connection.type == "GCS") {
                $scope.connection.params.credentialsMode = "KEYPAIR";
            }

            $scope.connection.allowManagedFolders = $scope.isFsProviderizable($scope.connection.type);
            $scope.loadDone = true;
        }
        $scope.customFieldsMap = $rootScope.appConfig.customFieldsMap["CONNECTION"];

        $scope.isConnectionNameUnique = function (v) {
            if (v == null) return true;
            if ($scope.connections == null) return true;
            return !$scope.connections.hasOwnProperty(v);
        };

        $scope.isConnectionNameValid = function () {
            return $scope.connection && $scope.connection.name && $scope.connection.name.length;
        };

        var savedConnection;
        $scope.connectionDirty = function () {
            return !angular.equals($scope.connection, savedConnection);
        };

        $scope.saveConnection = function () {
            if ($scope.isConnectionParamsFormInvalid()) {
                return;
            }
            DataikuAPI.admin.connections.save($scope.connection).success(function (data) {
                savedConnection = angular.copy($scope.connection);
                $state.transitionTo("admin.connections.edit", {connectionName: $scope.connection.name});
            }).error(setErrorInScope.bind($scope));
        };

        $scope.$watch('connection.allowWrite', function (a) {
            if (!a && $scope.connection) {
                $scope.connection.allowManagedDatasets = false;
                $scope.connection.allowManagedFolders = false;
            }
        });
    });

    app.controller("SQLConnectionController", function ($scope, $controller, DataikuAPI, $timeout, $rootScope, TopNav) {
        TopNav.setLocation(TopNav.DSS_HOME, "administration");

        if (!$scope.connection.params.properties) {
            $scope.connection.params.properties = [];
        }

        if ($scope.creation) {
            $scope.connection.params.namingRule.tableNameDatasetNamePrefix = "${projectKey}_";
        }

        if (!$scope.connection.params.dkuProperties) {
            $scope.connection.params.dkuProperties = [];
        }

        $scope.warnings = {
            noVariableInTable: false,
        };

        if (!$scope.connection.customBasicConnectionCredentialProviderParams) {
            $scope.connection.customBasicConnectionCredentialProviderParams = [];
        }

        $scope.checkForHttpInHostUrl = (host) => host && (host.startsWith('http://') || host.startsWith('https://'));

        $scope.$watch("connection.params", function (nv, ov) {
            $scope.warnings.noVariableInTable = false;
            // Snowflake doesn't support global Oauth yet ch63879
            if ($scope.connection.type=="Snowflake" && nv.authType=="OAUTH2_APP") {
                $scope.connection.credentialsMode = "PER_USER";
            }

            if (!nv) return;
            if (!$scope.connection.allowManagedDatasets) return;

            if ((!nv.namingRule.tableNameDatasetNamePrefix || nv.namingRule.tableNameDatasetNamePrefix.indexOf("${") == -1) &&
                (!nv.namingRule.tableNameDatasetNameSuffix || nv.namingRule.tableNameDatasetNameSuffix.indexOf("${") == -1) &&
                (!nv.namingRule.schemaName || nv.namingRule.schemaName.indexOf("${") == -1)) {
                $scope.warnings.noVariableInTable = true;
            }
        }, true);
        $scope.$watch("connection.credentialsMode", function (nv, ov) {
            // Snowflake doesn't support global Oauth yet ch63879
            if ($scope.connection.type=="Snowflake" && nv=="GLOBAL") {
                $scope.connection.params.authType = "PASSWORD";
            }
        });


        $scope.uiState = {};

        $scope.testConnection = function () {
            if (!$scope.connectionParamsForm || $scope.connectionParamsForm.$valid) {
                DataikuAPI.admin.connections.testSQL($scope.connection, null).success(function (data) {
                    $scope.testResult = data;
                }).error(setErrorInScope.bind($scope));
            }
        };

        $scope.$watch("connection", function (nv, ov) {
            if (nv != null) {
                if (!$scope.connection.params.properties) {
                    $scope.connection.params.properties = [];
                }
            }
        });

        $scope.warnAboutSearchPath = function () {
            if ($scope.connection.params.schemaSearchPath) {
                if ($scope.connection.params.namingRule.schemaName) {
                    return false;
                }
                if ($scope.connection.params.schemaSearchPath.indexOf(',public,') > 0) { // NOSONAR: OK to ignore 0 index.
                    return false;
                }
                if ($scope.connection.params.schemaSearchPath.endsWith(',public')) {
                    return false;
                }
                if ($scope.connection.params.schemaSearchPath.startsWith('public,')) {
                    return false;
                }
                if ($scope.connection.params.schemaSearchPath == 'public') {
                    return false;
                }
                return true;
            } else {
                // no schema search path => don't care
                return false;
            }
        };

         $scope.dialects = [
            {"value":"","label":"Default"},
            {"value":"MySQLDialect","label":"MySQL < 8.0"},
            {"value":"MySQL8Dialect","label":"MySQL >=8.0"},
            {"value":"PostgreSQLDialect","label":"PostgreSQL"},
            {"value":"OracleSQLDialect","label":"Oracle"},
            {"value":"SQLServerSQLDialect","label":"SQL Server"},
            {"value":"SynapseSQLDialect","label":"Azure Synapse"},
            {"value":"GreenplumSQLDialect","label":"Greenplum < 5.0"},
            {"value":"Greenplum5SQLDialect","label":"Greenplum >= 5.0"},
            {"value":"TeradataSQLDialect","label":"Teradata"},
            {"value":"VerticaSQLDialect","label":"Vertica"},
            {"value":"RedshiftSQLDialect","label":"Redshift"},
            {"value":"SybaseIQSQLDialect","label":"Sybase IQ"},
            {"value":"AsterDataSQLDialect","label":"Aster Data"},
            {"value":"NetezzaSQLDialect","label":"IBM Netezza"},
            {"value":"BigQuerySQLDialect","label":"Google BigQuery"},
            {"value":"SAPHANASQLDialect","label":"SAP HANA"},
            {"value":"ExasolSQLDialect","label":"Exasol"},
            {"value":"SnowflakeSQLDialect","label":"Snowflake"},
            {"value":"DB2SQLDialect","label":"IBM DB2"},
            {"value":"H2SQLDialect","label":"H2"},
            {"value":"ImpalaSQLDialect","label":"Impala"},
            {"value":"HiveSQLDialect","label":"Hive"},
            {"value":"PrestoSQLDialect","label":"Presto / Athena"},
            {"value":"SparkSQLDialect","label":"SparkSQL (via JDBC)"}
        ];
        if ($rootScope.featureFlagEnabled("kdbplus")) {
            $scope.dialects.push({"value":"KDBSQLDialect","label":"KDB+"});
        }
        $rootScope.appConfig.customDialects.forEach(function(d) {
            $scope.dialects.push({"value":d.dialectType, "label":d.desc.meta.label || d.id})
        });
    });

    app.controller("PostgreSQLConnectionController", function ($scope, $controller, DataikuAPI) {
        $controller('SQLConnectionController', {$scope: $scope});

        $scope.testConnection = function () {
            if (!$scope.connectionParamsForm || $scope.connectionParamsForm.$valid) {
                $scope.testing = true;
                DataikuAPI.admin.connections.testPostgreSQL($scope.connection).success(function (data) {
                    $scope.testing = false;
                    $scope.testResult = data;
                }).error(function (a, b, c) {
                    $scope.testing = false;
                    setErrorInScope.bind($scope)(a, b, c)
                });
            }
        }
    });

    app.controller("FilesystemConnectionController", function ($scope, $controller, TopNav) {
        TopNav.setLocation(TopNav.DSS_HOME, "administration");

        $scope.notTestable = true;

        if (!$scope.connection.params.dkuProperties) {
            $scope.connection.params.dkuProperties = [];
        }
    });

    app.controller("HDFSConnectionController", function ($scope, $controller, TopNav, $stateParams, DataikuAPI, FutureProgressModal, Dialogs) {
        TopNav.setLocation(TopNav.DSS_HOME, "administration");

        $scope.isExtraHadoopConfigurationInvalid = false;

        $scope.setExtraHadoopConfigurationValidity = function(isValid) {
            $scope.isExtraHadoopConfigurationInvalid = !isValid;
        }

        // Overriding Connection Common
        $scope.isConnectionParamsFormInvalid = function() {
            return $scope.connectionParamsForm.$invalid || $scope.isExtraHadoopConfigurationInvalid || $scope.areAdvancedConnectionPropertiesInvalid;
        }

        $scope.notTestable = true;

        if ($scope.creation) {
            $scope.connection.params.namingRule.hdfsPathDatasetNamePrefix = "${projectKey}/";
            $scope.connection.params.namingRule.tableNameDatasetNamePrefix = "${projectKey}_";
        }

        if (!$scope.connection.customBasicConnectionCredentialProviderParams) {
            $scope.connection.customBasicConnectionCredentialProviderParams = [];
        }

        if (!$scope.connection.params.dkuProperties) {
            $scope.connection.params.dkuProperties = [];
        }

        $scope.warnings = {
            noVariableInPath: false,
            noVariableInHive: false,
        };

        $scope.$watch("connection.params", function (nv, ov) {
            $scope.warnings.noVariableInPath = false;
            $scope.warnings.noVariableInHive = false;

            if (!nv) return;
            if (!$scope.connection.allowManagedDatasets) return;


            if ((!nv.namingRule.hdfsPathDatasetNamePrefix || nv.namingRule.hdfsPathDatasetNamePrefix.indexOf("${") == -1) &&
                (!nv.namingRule.hdfsPathDatasetNameSuffix || nv.namingRule.hdfsPathDatasetNameSuffix.indexOf("${") == -1)) {
                $scope.warnings.noVariableInPath = true;
            }

            if ((!nv.namingRule.tableNameDatasetNamePrefix || nv.namingRule.tableNameDatasetNamePrefix.indexOf("${") == -1) &&
                (!nv.namingRule.tableNameDatasetNameSuffix || nv.namingRule.tableNameDatasetNameSuffix.indexOf("${") == -1) &&
                (!nv.namingRule.hiveDatabaseName || nv.namingRule.hiveDatabaseName.indexOf("${") == -1)) {
                $scope.warnings.noVariableInHive = true;
            }
        }, true);

        $scope.resyncPermissions = function () {
            DataikuAPI.admin.connections.hdfs.resyncPermissions($stateParams.connectionName).success(function (data) {
                FutureProgressModal.show($scope, data, "Permissions update").then(function (result) {
                    Dialogs.infoMessagesDisplayOnly($scope, "Update result", result);
                })
            }).error(setErrorInScope.bind($scope));
        }

        $scope.resyncRootPermissions = function () {
            DataikuAPI.admin.connections.hdfs.resyncRootPermissions($stateParams.connectionName).success(function (data) {
                FutureProgressModal.show($scope, data, "Permissions update");
            }).error(setErrorInScope.bind($scope));
        }

        DataikuAPI.projects.list().success(function (data) {
            $scope.projectsList = data;
            if (data.length) {
                $scope.massImportTargetProjectKey = data[0].projectKey;
                $scope.massImportTargetProjectName = data[0].name;
            }
            $scope.$watch("massImportTargetProjectKey", function () {
                var filteredProjects = $scope.projectsList.filter(function (project) {
                    return project.projectKey == $scope.massImportTargetProjectKey;
                });
                if (filteredProjects && filteredProjects.length) {
                    $scope.massImportTargetProjectName = filteredProjects[0].name;
                } else {
                    $scope.massImportTargetProjectName = null;
                }
            })

        }).error(setErrorInScope.bind($scope));
    });


    app.controller("EC2ConnectionController", function ($scope, $controller, DataikuAPI, TopNav) {
        TopNav.setLocation(TopNav.DSS_HOME, "administration");

        $scope.testConnection = function () {
            if (!$scope.connectionParamsForm || $scope.connectionParamsForm.$valid) {
                $scope.testing = true;
                DataikuAPI.admin.connections.testEC2($scope.connection).success(function (data) {
                    $scope.testing = false;
                    $scope.testResult = data;
                }).error(function (a, b, c) {
                    $scope.testing = false;
                    setErrorInScope.bind($scope)(a, b, c)
                });
            }
        }

        if ($scope.creation) {
            $scope.connection.params["defaultManagedPath"] = "/dataiku";
        }
        if (!$scope.connection.params["hdfsInterface"]) {
            $scope.connection.params["hdfsInterface"] = "S3A";  // Default value
        }
        if (!$scope.connection.params.customAWSCredentialsProviderParams) {
            $scope.connection.params.customAWSCredentialsProviderParams = [];
        }
        if (!$scope.connection.customBasicConnectionCredentialProviderParams) {
            $scope.connection.customBasicConnectionCredentialProviderParams = [];
        }
        if (!$scope.connection.params.dkuProperties) {
            $scope.connection.params.dkuProperties = [];
        }
    });

    app.controller("GCSConnectionController", function ($scope, $controller, DataikuAPI, TopNav) {
        TopNav.setLocation(TopNav.DSS_HOME, "administration");

        $scope.testConnection = function () {
            if (!$scope.connectionParamsForm || $scope.connectionParamsForm.$valid) {
                $scope.testing = true;
                DataikuAPI.admin.connections.testGCS($scope.connection).success(function (data) {
                    $scope.testing = false;
                    $scope.testResult = data;
                }).error(function (a, b, c) {
                    $scope.testing = false;
                    setErrorInScope.bind($scope)(a, b, c)
                });
            }
        }

        if ($scope.creation) {
            $scope.connection.params["defaultManagedPath"] = "/dataiku";
        }

        if (!$scope.connection.params.dkuProperties) {
            $scope.connection.params.dkuProperties = [];
        }
    });

    app.controller("AzureConnectionController", function ($scope, $controller, DataikuAPI, TopNav) {
        TopNav.setLocation(TopNav.DSS_HOME, "administration");

        $scope.testConnection = function () {
            if (!$scope.connectionParamsForm || $scope.connectionParamsForm.$valid) {
                $scope.testing = true;
                DataikuAPI.admin.connections.testAzure($scope.connection).success(function (data) {
                    $scope.testing = false;
                    $scope.testResult = data;
                }).error(function (a, b, c) {
                    $scope.testing = false;
                    setErrorInScope.bind($scope)(a, b, c)
                });
            }
        }

        if ($scope.creation) {
            $scope.connection.params["defaultManagedPath"] = "/dataiku";
            $scope.connection.params["defaultManagedContainer"] = "dataiku";
            $scope.connection.params["useSSL"] = true;
            $scope.connection.params["authType"] = "SHARED_KEY";
        }

        if (!$scope.connection.params.dkuProperties) {
            $scope.connection.params.dkuProperties = [];
        }
    });


    app.controller("ElasticSearchConnectionController", function ($scope, $controller, DataikuAPI, TopNav) {
        TopNav.setLocation(TopNav.DSS_HOME, "administration");

        if ($scope.creation) {
            $scope.connection.params["host"] = "localhost";
            $scope.connection.params["port"] = 9200;
            $scope.connection.params["dialect"] = 'ES_LE_2';
            $scope.connection.params["connectionLimit"] = 8;
        }

        $scope.checkForHttpInHostUrl = (host) => host && (host.startsWith('http://') || host.startsWith('https://'));

        $scope.testConnection = function () {
            if (!$scope.connectionParamsForm || $scope.connectionParamsForm.$valid) {
                DataikuAPI.admin.connections.testElasticSearch($scope.connection, null).success(function (data) {
                    if (data.dialect && data.dialect !== $scope.connection.params.dialect) {
                        $scope.connection.params.dialect = data.dialect;
                        data.dialectChanged = true;
                    }
                    $scope.testResult = data;
                }).error(setErrorInScope.bind($scope));
            }
        };
    });

    app.controller("TwitterConnectionController", function ($scope, $controller, DataikuAPI, TopNav) {
        TopNav.setLocation(TopNav.DSS_HOME, "administration");

        $scope.connection.allowWrite = false;
        $scope.connection.allowManagedDatasets = false;
        $scope.connection.allowMirror = false;

        $scope.testConnection = function () {
            $scope.testing = true;
            DataikuAPI.admin.connections.testTwitter($scope.connection).success(function (data) {
                $scope.testResult = data;
            }).error(setErrorInScope.bind($scope))
                ["finally"](function () {
                $scope.testing = false;
            });
        }

        $scope.clearForm = function () {
            $scope.connection.params.api_key = "";
            $scope.connection.params.api_secret = "";
            $scope.connection.params.token_key = "";
            $scope.connection.params.token_secret = "";
            $scope.verified = false;
        }

        DataikuAPI.connections.getTwitterConfig().success(function (data) {
            var activeConnection = data.connection;
            $scope.isActive = ($scope.connection.name === activeConnection);
            $scope.isRunning = (data.running.length > 0);
        }).error(function () {
            setErrorInScope.bind($scope);
            $scope.isActive = false;
        });

        $scope.setActiveConnection = function (name) {
            DataikuAPI.admin.connections.setActiveTwitterConnection(name).success(function () {
                $scope.isActive = true;
            }).error(setErrorInScope.bind($scope));
        }

        DataikuAPI.connections.getNames('Twitter').success(function (data) {
            $scope.displaySetActive = (data.length > 1);
        }).error(setErrorInScope.bind($scope));
    });

    app.controller("KafkaConnectionController", function ($scope, $controller, DataikuAPI, TopNav, CodeMirrorSettingService) {
        TopNav.setLocation(TopNav.DSS_HOME, "administration");
        
        $scope.codeMirrorSettingService = CodeMirrorSettingService;
        
        $scope.securityModes = [
                                        {id:'NONE', label:'No security protocol'},
                                        {id:'KERBEROS', label:'Kerberos'},
                                        {id:'SASL', label:'Generic Sasl'},
                                        {id:'CUSTOM', label:'Custom (using properties)'}
                                    ];

        $scope.testConnection = function () {
            $scope.testing = true;
            $scope.testResult = null;
            DataikuAPI.admin.connections.testKafka($scope.connection).success(function (data) {
                $scope.testResult = data;
            }).error(
                setErrorInScope.bind($scope)
            ).finally(function () {
                $scope.testing = false;
            });
        };
        
        $scope.testKsql = function() {
            $scope.testingKsql = true;
            $scope.testKsqlResult = null;
            DataikuAPI.admin.connections.testKsql($scope.connection).success(function (data) {
                $scope.testKsqlResult = data;
            }).error(
                setErrorInScope.bind($scope)
            ).finally(function () {
                $scope.testingKsql = false;
            });
        };
    });

    app.controller("SQSConnectionController", function ($scope, DataikuAPI, TopNav) {
        TopNav.setLocation(TopNav.DSS_HOME, "administration");
        
        $scope.testConnection = function () {
            $scope.testing = true;
            $scope.testResult = null;
            DataikuAPI.admin.connections.testSQS($scope.connection).success(function (data) {
                $scope.testResult = data;
            }).error(
                setErrorInScope.bind($scope)
            ).finally(function () {
                $scope.testing = false;
            });
        }
    });


    app.controller("MongoDBConnectionController", function ($scope, $controller, DataikuAPI, TopNav) {
        TopNav.setLocation(TopNav.DSS_HOME, "administration");

        $scope.checkForHttpInHostUrl = (host) => host && (host.startsWith('http://') || host.startsWith('https://'));

        if ($scope.creation) {
            $scope.connection.params["useURI"] = false;
            $scope.connection.params["uri"] = "mongodb://HOST:27017/DB";
        }

        var sequenceId = 0;
        $scope.testConnection = function () {
            if (!$scope.connectionParamsForm || $scope.connectionParamsForm.$valid) {
                $scope.testing = true;
                $scope.testResult = null;
                DataikuAPI.admin.connections.testMongoDB($scope.connection, ++sequenceId).success(function (data) {
                    if (data.sequenceId != sequenceId) {
                        // Too late! Another call was triggered
                        return;
                    }
                    $scope.testing = false;
                    $scope.testResult = data;
                }).error(setErrorInScope.bind($scope));
            }
        };

        // TODO - test on arrival - connection form not valid soon enough ???
    });

    app.controller("DynamoDBConnectionController", function ($scope, $controller, DataikuAPI, TopNav) {
        TopNav.setLocation(TopNav.DSS_HOME, "administration");
        
        if ($scope.creation) {
            $scope.connection.params["regionOrEndpoint"] = "eu-west-3";
            $scope.connection.params["mode"] = "WEBSERVICE";
            $scope.connection.params["port"] = 8000;
            $scope.connection.params["hostname"] = "localhost";
            $scope.connection.params["rwCapacityMode"] = "ON_DEMAND";
            $scope.connection.params["readCapacity"] = 1;
            $scope.connection.params["writeCapacity"] = 1;
        }
        var sequenceId = 0;
        $scope.testConnection = function () {
            if (!$scope.connectionParamsForm || $scope.connectionParamsForm.$valid) {
                $scope.testing = true;
                $scope.testResult = null;
                DataikuAPI.admin.connections.testDynamoDB($scope.connection, ++sequenceId).success(function (data) {
                    if (data.sequenceId != sequenceId) {
                        // Too late! Another call was triggered
                        return;
                    }
                    $scope.testing = false;
                    $scope.testResult = data;
                }).error(setErrorInScope.bind($scope));
            }
        };
     });


    app.controller("CassandraConnectionController", function ($scope, $controller, DataikuAPI, TopNav) {
        TopNav.setLocation(TopNav.DSS_HOME, "administration");

        addDatasetUniquenessCheck($scope, DataikuAPI);

        $scope.checkForHttpInHostsUrl = (hosts) => hosts && hosts.split(',').some(host => host.startsWith('http://') || host.startsWith('https://'));

        $scope.testConnection = function () {
            if (!$scope.connectionParamsForm || $scope.connectionParamsForm.$valid) {
                $scope.testing = true;
                $scope.testResult = null;
                DataikuAPI.admin.connections.testCassandra($scope.connection).success(function (data) {
                    $scope.testing = false;
                    $scope.testResult = data;
                }).error(setErrorInScope.bind($scope));
            }
        };

        if (!$scope.connection.customBasicConnectionCredentialProviderParams) {
            $scope.connection.customBasicConnectionCredentialProviderParams = [];
        }

        // TODO - test on arrival
    });

    app.controller("FTPConnectionController", function ($scope, $controller, DataikuAPI, TopNav) {
        TopNav.setLocation(TopNav.DSS_HOME, "administration");

        if ($scope.creation) {
            $scope.connection.params.passive = true;
            $scope.connection.allowManagedDatasets = false;
        }
        $scope.connection.allowMirror = false;

        $scope.notTestable = true;

        if (!$scope.connection.params.dkuProperties) {
            $scope.connection.params.dkuProperties = [];
        }
    });

    app.controller("SSHConnectionController", function ($scope, $controller, DataikuAPI, TopNav) {
        TopNav.setLocation(TopNav.DSS_HOME, "administration");

        $scope.connection.allowMirror = false;
        $scope.notTestable = true;

        if ($scope.creation) {
            $scope.connection.allowManagedDatasets = false;
            $scope.connection.params["usePublicKey"] = false;
        }

        if (!$scope.connection.params.dkuProperties) {
            $scope.connection.params.dkuProperties = [];
        }
    });

}());

(function(){
'use strict';

var app = angular.module('dataiku.admin.security', []);

app.controller("AdminSecurityController", function(){
});


app.directive("projectGrantItem", function(){
    return {
        template : '<div>'+
                    '<div class="grant-wrapper"><div ng-show="grant.item.readProjectContent" class="grant readProjectContent">RC</div></div>'+
                    '<div class="grant-wrapper"><div ng-show="grant.item.writeProjectContent" class="grant writeProjectContent">WC</div></div>'+
                    '<div class="grant-wrapper"><div ng-show="grant.item.runScenarios" class="grant runScenarios">RS</div></div>'+
                    '<div class="grant-wrapper"><div ng-show="grant.item.readDashboards" class="grant readDashboards">RD</div></div>'+
                    '<div class="grant-wrapper"><div ng-show="grant.item.writeDashboards" class="grant writeDashboards">WD</div></div>'+
                    '<div class="grant-wrapper"><div ng-show="grant.item.moderateDashboards" class="grant moderateDashboards">MD</div></div>'+
                    '<div class="grant-wrapper"><div ng-show="grant.item.manageDashboardAuthorizations" class="grant manageDashboardAuthorizations">DA</div></div>'+
                    '<div class="grant-wrapper"><div ng-show="grant.item.manageExposedElements" class="grant manageExposedElements">EE</div></div>'+
                    '<div class="grant-wrapper"><div ng-show="grant.item.manageAdditionalDashboardUsers" class="grant manageAdditionalDashboardUsers">AU</div></div>'+
                    '<div class="grant-wrapper"><div ng-show="grant.item.executeApp" class="grant executeApp">EA</div></div>'+
                    '<div class="grant-wrapper"><div ng-show="grant.item.admin" class="grant admin">A</div></div>' +
                    '<div class="grant-wrapper"><div class="grant"></div></div>'+
                    '</div>',
        scope : {
            grant : '='
        }
    }
});


app.directive("authorizationMatrixTable", function(){
    return {
        scope : true,
        link : function($scope) {
            $scope.hover = {
                col : null
            }
        }
    }
});


app.controller("AdminSecurityAuthorizationMatrixController", function($scope, $state, $stateParams, DataikuAPI, TopNav) {
	TopNav.setLocation(TopNav.DSS_HOME, "administration");

    function range(n) {
        return Array.apply(null, Array(n)).map(function(_, i) {return i;});
    }

	DataikuAPI.security.getAuthorizationMatrix().success(function(data){
        $scope.authorizationMatrix = data;
        data.perUser.$pageSize = Math.round(2000 / data.perUser.users.length);
        data.perGroup.$pageSize = Math.round(2000 / data.perGroup.groups.length);
        data.perUser.$pages = range(Math.ceil(data.perUser.projectsGrants.length/data.perUser.$pageSize));
        data.perGroup.$pages = range(Math.ceil(data.perGroup.projectsGrants.length/data.perGroup.$pageSize));
        data.perUser.$offset = 0;
        data.perGroup.$offset = 0;
    }).error(setErrorInScope.bind($scope));

    $scope.uiState = $scope.uiState || {};
    $scope.uiState.showPermissionsBy = $scope.uiState.showPermissionsBy || "USERS";
});


app.controller("UsersController", function($scope, $state, $stateParams, DataikuAPI, $route, $modal, $q, Dialogs, TopNav, Logger, CreateModalFromTemplate) {
    function arrayToHtmlList(a) {
        return a.map(e => `<li>${e}</li>`).join('');
    }

    function usersToHtml(users) {
        return users.map(u => `${u.login}: ${u.displayName}`);
    }

	TopNav.setLocation(TopNav.DSS_HOME, "administration");
	$scope.refreshList = function() {
        DataikuAPI.admin.users.list().success(function(data) {
            $scope.users = data;
        }).error(setErrorInScope.bind($scope));
    };

    $scope.canDoDisableEnableMassAction = function (selectedUsers, activate) {
        return selectedUsers.some(u => u.enabled !== activate);
    };

    $scope.activateDeactivateUsers = function (users, activate) {
        event.preventDefault();
        if (!$scope.canDoDisableEnableMassAction(users, activate)) {
            return;
        }
        users = users.filter(u => u.enabled !== activate);

        const title = `Confirm user${users.length > 1 ? 's' : ''} ${activate ? 'activation' : 'deactivation'}`;
        const loginsText = arrayToHtmlList(usersToHtml(users));
        const text = `Are you sure you want to ${activate ? 'enable' : 'disable'} the following user${users.length > 1 ? 's' : ''}<ul>${loginsText}</ul>`;
        const logins = users.map(u => u.login);

        if (activate) {
            Dialogs.confirmPositive($scope, title, text).then(() => {
                DataikuAPI.admin.users.enableOrDisable(logins, true).success(() => {
                    $scope.refreshList();
                }).error(setErrorInScope.bind($scope));
            });
        } else {
            DataikuAPI.admin.users.prepareDisable(logins).success(data => {
                Dialogs.confirmInfoMessages($scope, title, data, text, false).then(() => {
                    DataikuAPI.admin.users.enableOrDisable(logins, false).success(() => {
                        $scope.refreshList();
                    }).error(setErrorInScope.bind($scope));
                });
            }).error(setErrorInScope.bind($scope));
        }
    };

    $scope.deleteUsers = function(selectedUsers) {
        const loginsText = arrayToHtmlList(usersToHtml(selectedUsers));
        const text = `Are you sure you want to delete the following users<ul>${loginsText}</ul>`;

        const logins = selectedUsers.map(u => u.login);
        DataikuAPI.admin.users.prepareDelete(logins).success(function(data) {
            Dialogs.confirmInfoMessages($scope, 'Confirm users deletion', data, text, false).then(function() {
                DataikuAPI.admin.users.delete(logins).success(function(data) {
                    $scope.refreshList();
                }).error(setErrorInScope.bind($scope));
            });
        }).error(setErrorInScope.bind($scope));
    };

    $scope.deleteUser = function(user) {
        DataikuAPI.admin.users.prepareDelete([user.login]).success(function(data) {
            Dialogs.confirmInfoMessages($scope, 'Confirm user deletion', data, 'Are you sure you want to delete user '+user.login + '?', false).then(function() {
                DataikuAPI.admin.users.delete([user.login]).success(function(data) {
                    $scope.refreshList();
                }).error(setErrorInScope.bind($scope));
            });
        }).error(setErrorInScope.bind($scope));
    };

    $scope.openAssignUsersToGroupModal = function(users, groups) {
        CreateModalFromTemplate("/templates/admin/security/assign-users-groups-modal.html", $scope, null, function(newScope) {
            newScope.users = users;
            const newGroups = {};

            groups.forEach(group => {
                const empty = ! users.some(u => u.groups.includes(group));
                const full = users.every(u => u.groups.includes(group));
                newGroups[group] = {
                    name: group,
                    selected: full,
                    originallyAssigned: !empty,
                    indeterminate: !empty && !full
                };
            });

            newScope.groups = newGroups;

            let newAssignedGroups = {};
            newScope.assignGroup = function(group) {
                if (!group.selected && group.originallyAssigned) {
                    newAssignedGroups[group.name] = false;
                } else if (group.selected && !group.originallyAssigned) {
                    newAssignedGroups[group.name] = true;
                } else if (group.selected && group.indeterminate) {
                    newAssignedGroups[group.name] = true;
                } else {
                    delete newAssignedGroups[group.name];
                }
            };

            newScope.wereGroupsChanged = function() {
                return Object.keys(newAssignedGroups).length > 0;
            };


            newScope.assignGroups = function(users) {
                const groupsToAdd = Object.keys(newAssignedGroups).filter(k => newAssignedGroups[k]);
                const groupsToRemove = Object.keys(newAssignedGroups).filter(k => ! newAssignedGroups[k]);


                const loginsText = arrayToHtmlList(usersToHtml(users));
                let text = `The following users <ul>${loginsText}</ul>`;
                if (groupsToAdd.length > 0) {
                    const groupsToAddText = arrayToHtmlList(groupsToAdd);
                    text += `will be added to groups <ul>${groupsToAddText}</ul>`;
                }
                if (groupsToRemove.length > 0) {
                    const groupsToRemoveText = arrayToHtmlList(groupsToRemove);
                    text += `will be removed from groups <ul>${groupsToRemoveText}</ul>`;
                }

                const logins = users.map(u => u.login);
                DataikuAPI.admin.users.prepareAssignUsersGroups(logins, groupsToAdd, groupsToRemove).success(function(data) {
                    Dialogs.confirmInfoMessages($scope, 'Confirm reassigning users to groups', data, text, false).then(function() {
                        newScope.dismiss();  // close first modal
                        Logger.info("Adding users", logins, "to group", groupsToAdd, " and removing from groups", groupsToRemove);
                        DataikuAPI.admin.users.assignUsersGroups(logins, groupsToAdd, groupsToRemove).success(function(data) {
                            $scope.refreshList();
                        }).error(setErrorInScope.bind($scope));
                    });
                }).error(setErrorInScope.bind($scope));
            };
        });
    };

    $scope.refreshList();

    DataikuAPI.security.listGroups(false).success(function(data) {
        if (data) {
            data.sort();
        }
        $scope.groups = data;
    }).error(setErrorInScope.bind($scope));
});


app.controller("UserController", function($scope, $state, $stateParams, DataikuAPI, $route, TopNav, Dialogs) {
	TopNav.setLocation(TopNav.DSS_HOME, "administration");
    let savedUser;
    $scope.user = {
            groups: [],
            login:'',
            sourceType: 'LOCAL',
            displayName:'',
            userProfile : 'DATA_SCIENTIST',
            //codeAllowed : true,
            password:''
    };
    if ($scope.appConfig && $scope.appConfig.licensing && $scope.appConfig.licensing.userProfiles) {
        $scope.user.userProfile = $scope.appConfig.licensing.userProfiles[0];
    }

    if ($stateParams.login) {
        $scope.creation = false;
        DataikuAPI.security.listGroups(true).success(function(data) {
            if (data) {
                data.sort();
            }
            $scope.allGroups = data;
            DataikuAPI.admin.users.get($stateParams.login).success(function(data) {
                $scope.user = data;
                savedUser = angular.copy(data);
            }).error(setErrorInScope.bind($scope));
        }).error(setErrorInScope.bind($scope));

    } else {
        $scope.creation = true;
        DataikuAPI.security.listGroups(true).success(function(data) {
            if (data) {
                data.sort();
            }
            $scope.allGroups = data;
        }).error(setErrorInScope.bind($scope));
    }

    $scope.prepareSaveUser = function() {
        if ($scope.creation) {
            $scope.saveUser();
        } else {
            DataikuAPI.admin.users.prepareUpdate($scope.user).success(function(data) {
                Dialogs.confirmInfoMessages($scope,
                    'Confirm user edition', data, 'Are you sure you want to edit user '+$scope.user.login + '?', true
                ).then($scope.saveUser);
            }).error(setErrorInScope.bind($scope));
        }
    };

    $scope.saveUser = function() {
        if ($scope.creation) {
            DataikuAPI.admin.users.create($scope.user).success(function(data) {
                $state.go("admin.security.users.list");
            }).error(setErrorInScope.bind($scope));
        } else {
            DataikuAPI.admin.users.update($scope.user).success(function(data) {
                $state.go("admin.security.users.list");
            }).error(setErrorInScope.bind($scope));
        }
    };

    $scope.userIsDirty = function() {
        return !angular.equals(savedUser, $scope.user);
    };

    var getGeneralSettings = function() {
    	DataikuAPI.admin.getGeneralSettings().success(function(gs) {
            $scope.generalSettings = gs;
    	}).error(setErrorInScope.bind($scope));
    }

    $scope.$watch('user', function() {
        if (! $scope.user.adminProperties) {
            $scope.user.adminProperties = {};
        }
        if (! $scope.user.userProperties) {
            $scope.user.userProperties = {};
        }
    });
    // Init
    getGeneralSettings();
});


app.controller("GroupsController", function($scope, $state, $stateParams, DataikuAPI, $route, $modal, $q, Dialogs, TopNav) {
	TopNav.setLocation(TopNav.DSS_HOME, "administration");
    // Populate UI
    var loadGroups = function() {
        DataikuAPI.security.listGroupsFull().success(function(groups) {
            DataikuAPI.security.listUsers().success(function(users) {
                for(var groupIdx in groups) {
                    var group = groups[groupIdx];
                    group.userCount = 0;
                    for(var userIdx in users) {
                        var userDesc = users[userIdx];
                        for(var userGroupIdx in userDesc.groups) {
                            var userGroup = userDesc.groups[userGroupIdx];
                            if(userGroup == group.name) {
                                group.userCount++;
                            }
                        }
                    }
                }
                $scope.groups = groups;
            }).error(setErrorInScope.bind($scope));
        }).error(setErrorInScope.bind($scope));
    };

    // Delete a group
    $scope.deleteGroup = function(group) {
        DataikuAPI.security.prepareDeleteGroup(group.name).success(function(data) {
            Dialogs.confirmInfoMessages($scope, 'Delete group', data, 'Are you sure you want to delete group "' + group.name + '" ?', false).then(function () {
                DataikuAPI.security.deleteGroup(group.name).success(function (data) {
                    loadGroups();
                }).error(setErrorInScope.bind($scope));
            });
        }).error(setErrorInScope.bind($scope));
    };

    // Init
    loadGroups();
});


app.controller("GroupController",function($scope, $state, $stateParams, DataikuAPI, $route, TopNav, Dialogs) {
    TopNav.setLocation(TopNav.DSS_HOME, "administration");
    let savedGroup;
    if ($stateParams.name) {
        $scope.creation = false;
        DataikuAPI.security.getGroup($stateParams.name).success(function(data) {
            $scope.group = data;
            savedGroup = angular.copy(data);
        }).error(setErrorInScope.bind($scope));
    } else {
        $scope.creation = true;
        $scope.group = {
            sourceType: 'LOCAL',
            mayWriteSafeCode : true,
            mayWriteInRootProjectFolder: true,
            mayCreateActiveWebContent: true
        };
    }

    $scope.prepareSaveGroup = function() {
        if ($scope.creation) {
            $scope.saveGroup();
        } else {
            DataikuAPI.security.prepareUpdateGroup($scope.group).success(function(data) {
                Dialogs.confirmInfoMessages($scope, 'Confirm user edition', data, 'Are you sure you want to edit group '+$scope.group.name + '?', true)
                    .then($scope.saveGroup);
            }).error(setErrorInScope.bind($scope));
        }
    };

    // Create or update a group
    $scope.saveGroup = function() {
        if ($scope.creation) {
            DataikuAPI.security.createGroup($scope.group).success(function(data) {
                $state.go("admin.security.groups.list");
            }).error(setErrorInScope.bind($scope));
        } else {
            DataikuAPI.security.updateGroup($scope.group).success(function(data) {
                $state.go("admin.security.groups.list");
            }).error(setErrorInScope.bind($scope));
        }
    };

    $scope.groupIsDirty = function() {
        return !angular.equals(savedGroup, $scope.group);
    };

    var getGeneralSettings = function() {
        DataikuAPI.admin.getGeneralSettings().success(function(gs) {
            $scope.generalSettings = gs;
        }).error(setErrorInScope.bind($scope));
    }

    // Init
    getGeneralSettings();
});

app.directive("globalPermissionsEditor", function() {
    return {
        scope: {
            'permissions': '='
        },
        templateUrl: '/templates/admin/security/global-permissions-editor.html',
        link: function($scope) {
            $scope.$watch("permissions", function(nv, ov) {
                if (!nv) return;
                /* Handle implied permissions */
                nv.$mayCreateProjectsFromMacrosDisabled = false;
                nv.$mayCreateProjectsFromTemplatesDisabled = false;

                if (nv.mayCreateProjects || nv.admin) {
                    nv.$mayCreateProjectsFromMacrosDisabled = true;
                    nv.$mayCreateProjectsFromTemplatesDisabled = true;
                }
            }, true);
        }
    }
});

app.controller("AdminSecurityAuditBufferController",function($scope, $state, $stateParams, DataikuAPI, $route, TopNav, Dialogs) {
    TopNav.setLocation(TopNav.DSS_HOME, "administration");

    $scope.uiState = {
        includeAllCalls: false
    }

    $scope.refreshList = function(){
        DataikuAPI.security.getAuditBuffer($scope.uiState.includeAllCalls).success(function(data) {
            $scope.auditBuffer = data;
        }).error(setErrorInScope.bind($scope));
    }

    $scope.refreshList();
});

app.filter('auditBufferEventDetails', function() {
    return function(obj) {
        var sa = []
        Object.keys(obj).forEach(function(x) {
            if (x != "callPath" && x != "msgType" && x != "authSource" && x != "authUser"
                && x != "clientIP" && x != "originalIP") {
                sa.push(x + ": " + obj[x]);
            }
        });
        return sa.join(", ");
    };
});


app.controller("GlobalPublicAPIKeysController", function ($scope, $state, DataikuAPI, CreateModalFromTemplate, Dialogs, TopNav) {
    TopNav.setLocation(TopNav.DSS_HOME, "administration");
    $scope.refreshApiKeysList = function () {
        DataikuAPI.admin.publicApi.listGlobalKeys().success(function (data) {
            $scope.apiKeys = data;
        }).error(setErrorInScope.bind($scope));
    };

    $scope.refreshApiKeysList();

    $scope.deleteGlobalKey = function (key) {
        Dialogs.confirm($scope, "Remove API key", "Are you sure you want to remove this API key?").then(function () {
            DataikuAPI.admin.publicApi.deleteGlobalKey(key).success(function (data) {
                $scope.refreshApiKeysList();
            }).error(setErrorInScope.bind($scope));
        });
    };

    $scope.viewQRCode = function (key) {
        CreateModalFromTemplate("/templates/admin/security/api-key-qrcode-modal.html", $scope, null, function (newScope) {
            newScope.apiKeyQRCode = JSON.stringify({
                k : key.key,
                u : $scope.appConfig.dssExternalURL
            });
        });
    };
});


app.controller("EditGlobalPublicAPIKeyController", function ($scope, $state, DataikuAPI, TopNav, $stateParams) {
    TopNav.setLocation(TopNav.DSS_HOME, "administration");
    if ($stateParams.id) {
        $scope.creation = false;
        DataikuAPI.admin.publicApi.getGlobalKey($stateParams.id).success(function(data) {
            $scope.apiKey = data;
        }).error(setErrorInScope.bind($scope));
    } else {
        var sampleProjectsPrivileges = {
            '__YOUR__PROJECTEY__' : {
                admin: false,
                readProjectContent: true,
                writeProjectContent: false,
                exportDatasetsData: true,
                readDashboards: true,
                writeDashboard: false,
                moderateDashboards: false,
                runScenarios: false,
                manageDashboardAuthorizations: false,
                manageExposedElements: false,
                manageAdditionalDashboardUsers: false,
                executeApp: false
            }
        };

        var sampleProjectFoldersPrivileges = {
            '__YOUR__PROJECT_FOLDER_ID__': {
                admin: false,
                writeContents: false,
                read: true
            }
        };

        $scope.creation = true;
        $scope.apiKey = {
            label : "New key",
            globalPermissions : {admin: true},
            projects : sampleProjectsPrivileges,
            projectFolders: sampleProjectFoldersPrivileges
        };
    }

    $scope.create = function () {
        DataikuAPI.admin.publicApi.createGlobalKey($scope.apiKey).success(function (data) {
            $state.go("admin.security.globalapi.list");
        }).error(setErrorInScope.bind($scope));
    };

    $scope.save = function () {
        DataikuAPI.admin.publicApi.saveGlobalKey($scope.apiKey).success(function (data) {
            $state.go("admin.security.globalapi.list");
        }).error(setErrorInScope.bind($scope));
    };
});

app.controller("AdminPersonalPublicAPIKeysController", function ($scope, $state, DataikuAPI, CreateModalFromTemplate, Dialogs, TopNav) {
    TopNav.setLocation(TopNav.DSS_HOME, "administration");
    $scope.refreshApiKeysList = function () {
        DataikuAPI.admin.publicApi.listPersonalKeys().success(function (data) {
            $scope.apiKeys = data;
        }).error(setErrorInScope.bind($scope));
    };

    $scope.refreshApiKeysList();

    $scope.deletePersonalAPIKey = function (key) {
        Dialogs.confirm($scope, "Remove API key", "Are you sure you want to remove this personal API key?").then(function () {
            DataikuAPI.admin.publicApi.deletePersonalKey(key).success(function (data) {
                $scope.refreshApiKeysList();
            }).error(setErrorInScope.bind($scope));
        });
    };

    $scope.viewQRCode = function (key) {
        CreateModalFromTemplate("/templates/admin/security/api-key-qrcode-modal.html", $scope, null, function (newScope) {
            newScope.apiKeyQRCode = JSON.stringify({
                k : key.key,
                u : $scope.appConfig.dssExternalURL
            });
        });
    };
});

})();

(function(){
'use strict';


var app = angular.module('dataiku.admin.maintenance', []);


app.constant("TAIL_STATUS", {
    DEBUG: 0,
    INFO: 1,
    WARNING: 2,
    ERROR: 3
});


app.controller("AdminScheduledTasksController", function($scope, $rootScope, $state, DataikuAPI, ActivityIndicator, TopNav){
	TopNav.setLocation(TopNav.DSS_HOME, "administration");
	$scope.refresh = function() {
        DataikuAPI.admin.scheduledTasks.getStatus().success(function(data){
            $scope.status = data;
        }).error(setErrorInScope.bind($scope));
    };

    $scope.fireTask = function(task){
        DataikuAPI.admin.scheduledTasks.fire(task.jobGroup, task.jobName).success(function(data){
            ActivityIndicator.success("Task fired");
            $scope.refresh();
        }).error(setErrorInScope.bind($scope));
    };

    $scope.refresh();
});


app.controller("AdminMaintenanceInfoController", function($scope, DataikuAPI, TopNav) {
    TopNav.setLocation(TopNav.DSS_HOME, "administration");

    DataikuAPI.admin.getInstanceInfo().success(function(data){
        $scope.data = data;
    });
});


app.controller("AdminLogsController", function($scope, $state, $rootScope, $window, $timeout,
               Logs, Diagnostics, DataikuAPI, ActivityIndicator, TopNav, TAIL_STATUS) {
    TopNav.setLocation(TopNav.DSS_HOME, "administration");
    //save JS data to file
    var saveData = (function () {
        var a = document.createElement("a");
        a.style.display = "none";
        document.body.appendChild(a);
        return function (data, fileName) {
            var blob = new Blob([data], {type: "octet/stream"}),
                url = window.URL.createObjectURL(blob);
            a.href = url;
            a.download = fileName;
            a.click();

            //give Firefox time...
            setTimeout(function(){
                window.URL.revokeObjectURL(url);
            }, 1000);
        };
    }());

    $scope.uiState = {
        active:  'logs',
        dState: null
    };

    $scope.TAIL_STATUS = TAIL_STATUS;

    $scope.loadLogsList = function() {
        $scope.uiState.loadingLogsList = true;
        Logs.list().success(function(data) {
            $scope.uiState.loadingLogsList = false;
            $scope.logs = data;
        });
    };

    $scope.loadLog = function(log) {
        $scope.uiState.currentLog = log;
        $scope.uiState.loadingLog = log;
        Logs.cat(log.name).success(function(data) {
            $scope.uiState.loadingLog = null;
            $scope.logData = data;
            $scope.logDataHTML = smartLogTailToHTML(data.tail, false);
            $timeout(function(){
                var content = $('.log-container .scrollable')[0];
                content.scrollTop = content.scrollHeight;
            })
        });
    };

    $scope.reloadLog = function() {
        if ($scope.uiState.currentLog) {
            $scope.loadLog($scope.uiState.currentLog);
        }
    };

    $scope.downloadExtract = function() {
        var text = $scope.logData.tail.lines.join('\n');
        var filename = 'extractof_'+$scope.uiState.currentLog.name;
        saveData(text, filename);
    };

    $scope.downloadCurrentLogFile = function() {
        if ($scope.uiState.currentLog) {
            Logs.download($scope.uiState.currentLog.name);
        }
    };


    $scope.downloadBackendLog = function() {
        Logs.download("backend.log");
    };


    $scope.downloadAllLogFiles = function() {
        Logs.downloadAll();
    };
    $scope.loadLogsList();

});

app.controller("AdminDiagnosticsController", function($scope, $state, $rootScope, $window, $timeout,
               Logs, Diagnostics, DataikuAPI, ActivityIndicator, TopNav, TAIL_STATUS, FutureProgressModal) {

    $scope.now = new Date().getTime()

    $scope.options = {
        includeConfigDir: true,
        includeIOVM: true,
        includeBackendStacks: true,
        includeDockerImagesListing: true,
        includeFullLogs: false,
        includeFullDataDirListing: true
    };

    $scope.getLatestDiagnosis = function () {
        Diagnostics.getLatest(function(data) {
            if (data.exists) {
                $scope.latestDiagnosis = data;
            }
        });
    }

    $scope.downloadLatestDiagnosis = function () {
        Diagnostics.downLoadLatest();
    }

    $scope.runDiagnosis = function() {
        DataikuAPI.admin.diagnostics.run($scope.options).success(function(data) {
            FutureProgressModal.show($scope, data, "Running diagnosis...", null, 'static', false, true).then(function(result) {
                if (result) {
                    $scope.downloadLatestDiagnosis();
                }
                $scope.getLatestDiagnosis();
                    
            })
        }).error(setErrorInScope.bind($scope));
    }

    $scope.getLatestDiagnosis();
});

})();
(function() {
'use strict';

const app = angular.module('dataiku.admin.codeenvs.common', []);

app.directive('codeEnvLogs', function($stateParams) {
    return {
        restrict : 'A',
        templateUrl : '/templates/admin/code-envs/common/code-env-logs.html',
        replace : true,
        scope : {
                envLang  : '=',
                envName  : '=',
                logs : '=',
                getLog : '&',
                downloadLog : '&'
        },
        link : function($scope, element, attrs) {
            $scope.uiState = {
                    logsQuery : ''
                };

            $scope.currentLogName = null;
            $scope.currentLog = null;
            $scope.fetchLog = function(logName) {
                $scope.getLog()($scope.envLang, $stateParams.envName, logName).success(function(data) {
                    $scope.currentLogName = logName;
                    $scope.currentLog = data;
                }).error(setErrorInScope.bind($scope));
            };
            $scope.streamLog = function(logName) {
                $scope.downloadLog()($scope.envLang, $stateParams.envName, logName);
            };
        }
    };
});

app.directive('codeEnvSecurityPermissions', function(DataikuAPI, $rootScope, PermissionsService) {
    return {
        restrict : 'A',
        templateUrl : '/templates/admin/code-envs/common/security-permissions.html',
        replace : true,
        scope : {
                codeEnv  : '='
        },
        link : function($scope, element, attrs) {
            $scope.appConfig = $rootScope.appConfig;
            $scope.ui = {};

            function makeNewPerm(){
                $scope.newPerm = {
                    update: true,
                    delete: true,
                    use: true
                }
            }
            makeNewPerm();

            const fixupPermissions = function() {
                if (!$scope.codeEnv) return;
                /* Handle implied permissions */
                $scope.codeEnv.permissions.forEach(function(p) {
                    p.$updateDisabled = false;
                    p.$manageUsersDisabled = false;
                    p.$useDisabled = false;
                    
                    if ($scope.codeEnv.usableByAll) {
                        p.$useDisabled = true;
                    }
                    if (p.update) {
                        p.$useDisabled = true;
                    }
                    if (p.manageUsers) {
                        p.$useDisabled = true;
                        p.$updateDisabled = true;
                    }
                });
            };
            
            DataikuAPI.security.listGroups(false).success(function(allGroups) {
                if (allGroups) {
                    allGroups.sort();
                }
                $scope.allGroups = allGroups;
                DataikuAPI.security.listUsers().success(function(data) {
                    $scope.allUsers = data;
                }).error(setErrorInScope.bind($scope));
                $scope.unassignedGroups = PermissionsService.buildUnassignedGroups($scope.codeEnv, $scope.allGroups);
            }).error(setErrorInScope.bind($scope));

            $scope.$watch("codeEnv.owner", function() {
                $scope.ui.ownerLogin = $scope.codeEnv.owner;
            });
            
            $scope.addPermission = function() {
                $scope.codeEnv.permissions.push($scope.newPerm);
                makeNewPerm();
            };

            $scope.$watch("codeEnv.usableByAll", function(nv, ov) {
                fixupPermissions();
            })
            $scope.$watch("codeEnv.permissions", function(nv, ov) {
                if (!nv) return;
                $scope.unassignedGroups = PermissionsService.buildUnassignedGroups($scope.codeEnv, $scope.allGroups);
                fixupPermissions();
            }, true)
            $scope.$watch("codeEnv.permissions", function(nv, ov) {
                if (!nv) return;
                $scope.unassignedGroups = PermissionsService.buildUnassignedGroups($scope.codeEnv, $scope.allGroups);
                fixupPermissions();
            }, false)
            $scope.unassignedGroups = PermissionsService.buildUnassignedGroups($scope.codeEnv, $scope.allGroups);
            fixupPermissions();

            // Ownership mgmt
            $scope.$watch("ui.ownerLogin", function() {
                PermissionsService.transferOwnership($scope, ($scope.codeEnv || {}).desc, "code env");
            });
        
        
        }
    };
});

app.directive('codeEnvContainers', function (DataikuAPI, $rootScope) {
    return {
        restrict: 'A',
        templateUrl: '/templates/admin/code-envs/common/code-env-containers.html',
        replace: true,
        scope: {
            codeEnv: '='
        },
        link: function ($scope, element, attrs) {
            $scope.appConfig = $rootScope.appConfig;
            $scope.addLicInfo = $rootScope.addLicInfo;

            let _mode = "NONE";
            if ($scope.codeEnv.allContainerConfs) {
                _mode = "ALL"
            } else if (!$scope.codeEnv.allContainerConfs && $scope.codeEnv.containerConfs.length !== 0) {
                _mode = "ALLOWED";
            }
            let _sparkMode = "NONE";
            if ($scope.codeEnv.allSparkKubernetesConfs) {
                _sparkMode = "ALL";
            } else if (!$scope.codeEnv.allSparkKubernetesConfs && $scope.codeEnv.sparkKubernetesConfs.length !== 0) {
                _sparkMode = "ALLOWED";
            }

            $scope.containerSelection = function (newMode) {
                if (!arguments.length) {
                    return _mode;
                }

                _mode = newMode;

                switch (newMode) {
                    case "NONE":
                        $scope.codeEnv.allContainerConfs = false;
                        $scope.codeEnv.containerConfs = [];
                        break;
                    case "ALLOWED":
                        $scope.codeEnv.allContainerConfs = false;
                        break;
                    case "ALL":
                        $scope.codeEnv.allContainerConfs = true;
                        break;
                }
            };
            $scope.sparkKubernetesSelection = function (newMode) {
                if (!arguments.length) {
                    return _sparkMode;
                }

                _sparkMode = newMode;

                switch (newMode) {
                    case "NONE":
                        $scope.codeEnv.allSparkKubernetesConfs = false;
                        $scope.codeEnv.sparkKubernetesConfs = [];
                        break;
                    case "ALLOWED":
                        $scope.codeEnv.allSparkKubernetesConfs = false;
                        break;
                    case "ALL":
                        $scope.codeEnv.allSparkKubernetesConfs = true;
                        break;
                }
            };

            $scope.removeOutdatedContainerConfs = function() {
                $scope.codeEnv.containerConfs = $scope.codeEnv.containerConfs.filter(o => $scope.outdatedContainerConfs.indexOf(o) === -1);
            };

            $scope.removeOutdatedSparkKubernetesConfs = function() {
                $scope.codeEnv.sparkKubernetesConfs = $scope.codeEnv.sparkKubernetesConfs.filter(o => $scope.outdatedSparkKubernetesConfs.indexOf(o) === -1);
            };

            DataikuAPI.containers.listNames()
                .success(data => {
                    $scope.containerNames = data;
                    $scope.outdatedContainerConfs = $scope.codeEnv.containerConfs.filter(o => $scope.containerNames.indexOf(o) === -1)

                    $scope.$watch("containerNames && codeEnv.containerConfs", function(nv, ov) {
                        $scope.outdatedContainerConfs = $scope.codeEnv.containerConfs.filter(o => $scope.containerNames.indexOf(o) === -1)
                    });
                })
                .error(setErrorInScope.bind($scope));
            DataikuAPI.containers.listSparkNames()
                .success(data => {
                    $scope.sparkKubernetesNames = data;
                    $scope.outdatedSparkKubernetesConfs = $scope.codeEnv.sparkKubernetesConfs.filter(o => $scope.sparkKubernetesNames.indexOf(o) === -1)

                    $scope.$watch("sparkKubernetesNames && codeEnv.sparkKubernetesConfs", function(nv, ov) {
                        $scope.outdatedSparkKubernetesConfs = $scope.codeEnv.sparkKubernetesConfs.filter(o => $scope.sparkKubernetesNames.indexOf(o) === -1)
                    });
                })
                .error(setErrorInScope.bind($scope));
        }
    };
});

}());

(function() {
'use strict';

var app = angular.module('dataiku.admin.codeenvs.design', []);

app.controller("AdminCodeEnvsDesignController", function($scope, TopNav, DataikuAPI, Dialogs, FutureProgressModal, CreateModalFromTemplate, ActivityIndicator) {
    $scope.openDeleteEnvModal = function(envLang, envName){
        var newScope = $scope.$new();
        newScope.envLang = envLang;
        newScope.envName = envName;
        // modal appears when usages are ready
        DataikuAPI.admin.codeenvs.design.listUsages(newScope.envLang, newScope.envName).success(function(data){
            newScope.usagesList = data;
            // group by type / project
            newScope.usageByType = {};
            newScope.usageByProject = {};
            newScope.usagesList.forEach(function(usage) {
                if (usage.envUsage) {
                    newScope.usageByType[usage.envUsage] = newScope.usageByType[usage.envUsage] || [];
                    newScope.usageByType[usage.envUsage].push(usage);
                }
                if (usage.projectKey) {
                    newScope.usageByProject[usage.projectKey] = newScope.usageByProject[usage.projectKey] || [];
                    newScope.usageByProject[usage.projectKey].push(usage);
                }
            });
            CreateModalFromTemplate("/templates/admin/code-envs/common/delete-env-modal.html", newScope, "AdminCodeEnvsDesignDeleteController");
        }).error(setErrorInScope.bind(newScope));
    }
    $scope.isExportable = function(codeEnv) {
        return codeEnv && ['PLUGIN_MANAGED', 'PLUGIN_NON_MANAGED'].indexOf(codeEnv.deploymentMode) < 0;
    };
    $scope.exportEnv = function(envLang, envName) {
        ActivityIndicator.success("Exporting code env ...");
        downloadURL(DataikuAPI.admin.codeenvs.design.getExportURL(envLang, envName));
    };

    $scope.getEnvDiagnostic = function(envLang, envName) {
        ActivityIndicator.success("Generating code env diagnostic ...");
        downloadURL(DataikuAPI.admin.codeenvs.design.getDiagnosticURL(envLang, envName));
    };

    $scope.canCreateCodeEnv = function() {
        return $scope.appConfig.admin || $scope.appConfig.globalPermissions.mayCreateCodeEnvs || $scope.appConfig.globalPermissions.mayManageCodeEnvs;
    };
});

app.controller("AdminCodeEnvsDesignListController", function($scope, $controller, TopNav, DataikuAPI, Dialogs, CreateModalFromTemplate, $state) {
    $controller("AdminCodeEnvsDesignController", {$scope:$scope});
	TopNav.setLocation(TopNav.DSS_HOME, "administration");
    $scope.refreshList = function() {
        return DataikuAPI.admin.codeenvs.design.list().success(function(data) {
            $scope.codeEnvs = data;
        }).error(setErrorInScope.bind($scope));
    };
    $scope.refreshList();

    $scope.openNewPythonEnvModal = function(){
        CreateModalFromTemplate("/templates/admin/code-envs/design/new-python-env-modal.html", $scope, "AdminCodeEnvsDesignNewPythonController")
    }
    $scope.openNewREnvModal = function(){
        CreateModalFromTemplate("/templates/admin/code-envs/design/new-R-env-modal.html", $scope, "AdminCodeEnvsDesignNewRController")
    }
    $scope.openImportEnvModal = function(){
        CreateModalFromTemplate("/templates/admin/code-envs/design/import-env-modal.html", $scope, "AdminCodeEnvsDesignImportController")
    }
    $scope.actionAfterDeletion = function() {
        $scope.refreshList();
    };
    $scope.goToEditIfExists = function(envName) {
        const env = $scope.codeEnvs.find(e => e.envName === envName);
        if(env && env.envLang === 'R') {
            $state.go("admin.codeenvs-design.r-edit", { envName });
        } else if(env && env.envLang === 'PYTHON'){
            $state.go("admin.codeenvs-design.python-edit", { envName });
        }
    };
});

app.controller("AdminCodeEnvsDesignDeleteController", function($scope, TopNav, DataikuAPI, Dialogs, FutureProgressModal, $q) {
    $scope.delete = function() {
        var parentScope = $scope.$parent;
        DataikuAPI.admin.codeenvs.design.delete($scope.envLang, $scope.envName).success(function(data){
            $scope.dismiss();
            FutureProgressModal.show(parentScope, data, "Env deletion").then(function(result){
                const infoModalClosed = result
                    ? Dialogs.infoMessagesDisplayOnly(parentScope, "Deletion result", result.messages, result.futureLog)
                    : $q.resolve();
                infoModalClosed.then(() => $scope.actionAfterDeletion());
            });
        }).error(setErrorInScope.bind($scope));

    };
});

app.controller("AdminCodeEnvsDesignNewPythonController", function($scope, TopNav, DataikuAPI, Dialogs, FutureProgressModal, $q) {

    $scope.newEnv = {
        deploymentMode: "DESIGN_MANAGED",
        pythonInterpreter: "PYTHON36",
        conda: false,
        installCorePackages: true,
        // corePackagesSet : "PANDAS10", // let the backend decide
        installJupyterSupport: true
    }

    $scope.deploymentModes = [
        ["DESIGN_MANAGED", "Managed by DSS (recommended)"],
        ["DESIGN_NON_MANAGED", "Non-managed path"],
        ["EXTERNAL_CONDA_NAMED", "Named external Conda env"]
    ]

    $scope.$watch("newEnv.conda", function(nv) {
        if (nv === true) {
            $scope.pythonInterpreters = [
                ["PYTHON27", "Python 2.7"],
                //["PYTHON34", "Python 3.4"],
                ["PYTHON35", "Python 3.5"],
                ["PYTHON36", "Python 3.6"],
                ["PYTHON37", "Python 3.7"],
            ]
        } else if (nv === false) {
            $scope.pythonInterpreters = [
                ["PYTHON27", "Python 2.7 (from PATH)"],
                //["PYTHON34", "Python 3.4 (from PATH)"],
                ["PYTHON35", "Python 3.5 (from PATH)"],
                ["PYTHON36", "Python 3.6 (from PATH)"],
                ["PYTHON37", "Python 3.7 (from PATH)"],
                ["CUSTOM", "Custom (lookup in PATH)"]
            ]
        }
    });

    $scope.create = function(){
        var parentScope = $scope.$parent.$parent;
        DataikuAPI.admin.codeenvs.design.create("PYTHON", $scope.newEnv).success(function(data){
            $scope.dismiss();
            FutureProgressModal.show(parentScope, data, "Env creation", undefined, 'static', false).then(function(result){
                const modalClosed = result
                    ? Dialogs.infoMessagesDisplayOnly(parentScope, "Creation result", result.messages, result.futureLog, undefined, 'static', false)
                    : $q.resolve();

                const refreshed = parentScope.refreshList();

                $q.all([modalClosed, refreshed]).then(() => {
                    parentScope.goToEditIfExists(result && result.envName);
                });
            });
        }).error(setErrorInScope.bind($scope));
    }
});

app.controller("AdminCodeEnvsDesignNewRController", function($scope, TopNav, DataikuAPI, Dialogs, FutureProgressModal, $q) {

    $scope.newEnv = {
        deploymentMode: "DESIGN_MANAGED",
        conda: false,
        installCorePackages: true,
        installJupyterSupport: true
    }

    $scope.deploymentModes = [
        ["DESIGN_MANAGED", "Managed by DSS (recommended)"],
        ["DESIGN_NON_MANAGED", "Non-managed path"],
        ["EXTERNAL_CONDA_NAMED", "Named external Conda env"]
    ]

    $scope.create = function(){
        var parentScope = $scope.$parent.$parent;
        DataikuAPI.admin.codeenvs.design.create("R", $scope.newEnv).success(function(data){
            $scope.dismiss();
            FutureProgressModal.show(parentScope, data, "Env creation", undefined, 'static', false).then(function(result){
                const modalClosed = result
                    ? Dialogs.infoMessagesDisplayOnly(parentScope, "Creation result", result.messages, result.futureLog, undefined, 'static', false)
                    : $q.resolve();

                const refreshed = parentScope.refreshList();

                $q.all([modalClosed, refreshed]).then(() => {
                    parentScope.goToEditIfExists(result && result.envName);
                });
            });
        }).error(setErrorInScope.bind($scope));
    }
});


app.controller("AdminCodeEnvsDesignImportController", function($scope, $state, $stateParams, Assert, TopNav, DataikuAPI, FutureProgressModal, Dialogs, Logs, $q) {
    $scope.newEnv = {}

    $scope.import = function() {
        Assert.trueish($scope.newEnv.file, "No code env file");

        const parentScope = $scope.$parent.$parent;
        DataikuAPI.admin.codeenvs.design.import($scope.newEnv.file).then(function(data) {
            $scope.dismiss();
            FutureProgressModal.show(parentScope, JSON.parse(data), "Env import").then(function(result) {
                const modalClosed = result
                    ? Dialogs.infoMessagesDisplayOnly(parentScope, "Creation result", result.messages, result.futureLog, undefined, 'static', false)
                    : $q.resolve();

                const refreshed = parentScope.refreshList();

                $q.all([modalClosed, refreshed]).then(() => {
                    parentScope.goToEditIfExists(result && result.envName);
                });
            });
        }, function(payload) {
            setErrorInScope.bind($scope)(JSON.parse(payload.response), payload.status, function(h) {return payload.getResponseHeader(h)});
        });
    }
});


app.controller("_AdminCodeEnvsDesignEditController", function($scope, $controller, $state, $stateParams, TopNav, DataikuAPI, FutureProgressModal, Dialogs, Logs, CreateModalFromTemplate, $timeout, $q, ActivityIndicator) {
    $controller("AdminCodeEnvsDesignController", {$scope:$scope});
    TopNav.setLocation(TopNav.DSS_HOME, "administration");

    $scope.uiState = {
        performChangesOnSave: true,
        upgradeAllPackages: true,
        active : 'info'
    }

    $scope.getSingleVersion = function(codeEnv) {
        return null;
    };

    $scope.actionAfterDeletion = function() {
        $state.go("admin.codeenvs-design.list");
    };

    $scope.canBeUpdated = function() {
        return $scope.codeEnv && $scope.codeEnv.canUpdateCodeEnv && ['DESIGN_MANAGED', 'PLUGIN_MANAGED', 'AUTOMATION_SINGLE', 'AUTOMATION_VERSIONED'].indexOf($scope.codeEnv.deploymentMode) >= 0;
    };

    var makeCurrentDesc = function(desc) {
        return {
                yarnPythonBin: angular.copy(desc.yarnPythonBin),
                yarnRBin: angular.copy(desc.yarnRBin),
                owner: angular.copy(desc.owner),
                installJupyterSupport : desc.installJupyterSupport,
                installCorePackages : desc.installCorePackages,
                corePackagesSet : desc.corePackagesSet,
                envSettings : angular.copy(desc.envSettings)
            };
    };
    var makeCurrentSpec = function(spec) {
        return {
                specPackageList: angular.copy(spec.specPackageList),
                desc: makeCurrentDesc(spec.desc),
                specCondaEnvironment: angular.copy(spec.specCondaEnvironment),
                permissions: angular.copy(spec.permissions),
                usableByAll: spec.usableByAll,
                allContainerConfs: angular.copy(spec.allContainerConfs),
                containerConfs: angular.copy(spec.containerConfs),
                allSparkKubernetesConfs: angular.copy(spec.allSparkKubernetesConfs),
                sparkKubernetesConfs: angular.copy(spec.sparkKubernetesConfs)
            };
    };


    /** Gets the set of package names mentioned in a code env listing */
    function getPackageNames(listStr) {
        let ret = new Set();
        for (let line of listStr.split("\n")) {
            // Ignore packages that are not clean package names
            if (line.indexOf("-e") >= 0 || line.indexOf("git+") >= 0 || line.indexOf("ssh") >= 0) continue;

            const chunks = line.split(/[\s>=<,\[\]]+/);
            const packageName = chunks[0].trim().replaceAll('"',"");
            if (packageName.length > 0) {
                ret.add(packageName.toLowerCase());
            }
        }
        return ret;
    }

    function intersection(setA, setB) {
        let intersection = new Set();
        for (let elt of setB) {
            if (setA.has(elt)) {
                intersection.add(elt)
            }
        }
        return intersection;
    }

    function difference(setA, setB) {
        let difference = new Set();
        for (let elt of setA) {
            if (!setB.has(elt)) {
                difference.add(elt)
            }
        }
        return difference;
    }

    function getPackagesThatAreBothRequiredAndInstalled(spec, actual) {
        if (!spec || !actual) {
            return new Set();
        }
        return intersection(getPackageNames(spec), getPackageNames(actual));
    }

    function getPackagesThatAreRequired(codeEnv, packageSystem) {
        let spec = null;
        let mandatory = null;
        if (packageSystem == 'pip') {
            spec = codeEnv.specPackageList;
            mandatory = codeEnv.mandatoryPackageList;
        } else if (packageSystem == 'conda') {
            spec = codeEnv.specCondaEnvironment;
            mandatory = codeEnv.mandatoryCondaEnvironment;
        }
        if (!spec) return new Set();
        let packages = getPackageNames(spec);
        if (mandatory) {
            getPackageNames(mandatory).forEach(p => packages.add(p));
        }
        return packages;
    }

    $scope.getPackagesThatWereRequiredAndInstalledButAreNotRequiredAnymore = function(packageSystem){
        if (!$scope.codeEnv || !$scope.previousPackagesSetForRemovalWarning[packageSystem]) return [];

        const newSet = getPackagesThatAreRequired($scope.codeEnv, packageSystem);

        return [...difference($scope.previousPackagesSetForRemovalWarning[packageSystem], newSet)];
    }

    $scope.specIsDirty = function() {
        if (!$scope.codeEnv) return false;
        var currentSpec = makeCurrentSpec($scope.codeEnv);
        return !angular.equals(currentSpec, $scope.previousSpec);
    };
    checkChangesBeforeLeaving($scope, $scope.specIsDirty);

    $scope.previousSpec = {
    }
    $scope.previousPackagesSetForRemovalWarning = {'pip': new Set(), 'conda': new Set()};

    var listLogs = function(){
        DataikuAPI.admin.codeenvs.design.listLogs($scope.envLang, $stateParams.envName).success(function(data) {
            $scope.logs = data;
        }).error(setErrorInScope.bind($scope));
    };

    var refreshEnv = function(){
        DataikuAPI.admin.codeenvs.design.get($scope.envLang, $stateParams.envName).success(function(data) {
            $scope.codeEnv = data;
            $scope.previousSpec = makeCurrentSpec(data);
            $scope.previousPackagesSetForRemovalWarning['pip'] = getPackagesThatAreBothRequiredAndInstalled(data.specPackageList, data.actualPackageList);
            $scope.previousPackagesSetForRemovalWarning['conda'] = getPackagesThatAreBothRequiredAndInstalled(data.specCondaEnvironment, data.actualCondaEnvironment);
        }).error(setErrorInScope.bind($scope));
        listLogs();
    }

    refreshEnv();

    $scope.updateEnv = function(upgradeAllPackages){
        var updateSettings = {
            upgradeAllPackages: upgradeAllPackages,
            forceRebuildEnv: $scope.uiState.forceRebuildEnv
        }
        DataikuAPI.admin.codeenvs.design.update($scope.envLang, $stateParams.envName, updateSettings).success(function(data) {
            FutureProgressModal.show($scope, data, "Env update").then(function(result){
                if (result) { // undefined in case of abort
                    Dialogs.infoMessagesDisplayOnly($scope, "Update result", result.messages, result.futureLog);
                }
                refreshEnv();
            })
        }).error(setErrorInScope.bind($scope));
    }

    $scope.saveAndMaybePerformChanges = function(performChangesOnSave){
        DataikuAPI.admin.codeenvs.design.save($scope.envLang, $stateParams.envName, $scope.codeEnv).success(function(data) {
            refreshEnv();
            if (performChangesOnSave) {
                $scope.updateEnv();
            }
        }).error(setErrorInScope.bind($scope));
    }

    $scope.fetchNonManagedEnvDetails = function(){
        DataikuAPI.admin.codeenvs.design.fetchNonManagedEnvDetails($scope.envLang, $stateParams.envName).success(function(data) {
            $scope.nonManagedEnvDetails = data;
        }).error(setErrorInScope.bind($scope));
    }

    $scope.installJupyterSupport = function(){
        DataikuAPI.admin.codeenvs.design.installJupyterSupport($scope.envLang, $stateParams.envName).success(function(data) {
            FutureProgressModal.show($scope, data, "Env update").then(function(result){
                if (result) { // undefined in case of abort
                    Dialogs.infoMessagesDisplayOnly($scope, "Update result", result.messages, result.futureLog);
                }
                refreshEnv();
            })
        }).error(setErrorInScope.bind($scope));
    }

    $scope.removeJupyterSupport = function(){
        DataikuAPI.admin.codeenvs.design.removeJupyterSupport($scope.envLang, $stateParams.envName).success(function(data) {
            FutureProgressModal.show($scope, data, "Env update").then(function(result){
                if (result) { // undefined in case of abort
                    Dialogs.infoMessagesDisplayOnly($scope, "Update result", result.messages, result.futureLog);
                }
                refreshEnv();
            })
        }).error(setErrorInScope.bind($scope));
    }

    $scope.setRemoteSparkSupport = function(remoteKernelType, active) {
        DataikuAPI.admin.codeenvs.setRemoteSparkSupport($scope.envLang, $stateParams.envName, remoteKernelType, active).success(function(data) {
            ActivityIndicator.success("Operation successful");
        }).error(setErrorInScope.bind($scope));
    }

    $scope.specPackageListEditorOptionsPip = $scope.codeMirrorSettingService.get("text/plain", {onLoad: function(cm){$scope.codeMirrorPip = cm;}});
    $scope.specPackageListEditorOptionsConda = $scope.codeMirrorSettingService.get("text/plain", {onLoad: function(cm){$scope.codeMirrorConda = cm;}});


    function insertCode(codeToInsert, type) {
        let cm;
        if (type === 'pip') {
            cm = $scope.codeMirrorPip;
        } else {
            cm = $scope.codeMirrorConda;
        }
        //timeout to make sure of an angular safe apply
        $timeout(function() {
            cm.replaceSelection(codeToInsert, "end");
        });

        cm.focus();
    }

    $scope.openPipRequirementsEditHelp = function() {
        Dialogs.ackMarkdown($scope, "Pip requirements", 
            "Specify the packages you want:\n\n"+
            "* one row per package\n"+
            "* each row is a PIP package specification ( [link](https://setuptools.readthedocs.io/en/latest/pkg_resources.html#requirement-objects) )\n"+
            "\n"+
            "Examples of package specifications:\n\n"+
            "* pandas==0.20.3\n"+
            "* numpy>=0.19");
    }

    $scope.openPyCondaSpecEditHelp = function() {
        Dialogs.ackMarkdown($scope, "Conda packages", 
            "Specify the packages you want:\n\n"+
            "* one row per package\n"+
            "* each row is a Conda package match specification ( [link](https://conda.io/docs/user-guide/tasks/build-packages/package-spec.html#package-match-specifications) )\n"+
            "\n"+
            "Examples of package specifications:\n\n"+
            "* pandas=0.20.3\n"+
            "* numpy>=0.19");
    }

    $scope.openRCondaSpecEditHelp = function() {
        Dialogs.ackMarkdown($scope, "Conda packages", 
            "Specify the packages you want:\n\n"+
            "* one row per package\n"+
            "* each row is a Conda package match specification ( [link](https://conda.io/docs/user-guide/tasks/build-packages/package-spec.html#package-match-specifications) )\n"+
            "\n"+
            "Examples of package specifications:\n\n"+
            "* r-irkernel>=0.7");
    }

    $scope.openCRANEditHelp = function() {
        Dialogs.ackMarkdown($scope, "R packages", 
            "Specify the packages you want:\n\n"+
            "* one row per package\n"+
            "* each row is a pair of package name and minimal package version (optional)\n"+
            "\n"+
            "The version is only a minimal version. It is not supported to specify an explicity version.\n\n"+
            "Examples of package specifications:\n\n"+
            "* RJSONIO,0.13\n"+
            "* dplyr,");
    }

    $scope.insertAdditionalPackages = function(type) {

        let deferred = $q.defer();
        let newScope = $scope.$new();

        // For "DOCTOR_DL_GPU_CUDA100" "DOCTOR_DL_CPU", keras >=2.3.0 requires keras-preprocessing>=1.0.5.
        // Currently, it installs version 1.1.2, which breaks the `keras.preprocessing.image.load_img` 
        // API by only accepting path, whereas we send file-like objects. 
        // Therefore we restrist to using version 1.1.0.
        const packageListTypes = [
            ["DOCTOR", "Visual Machine Learning (scikit-learn, XGBoost)"],
            ["DOCTOR_BAYESIAN_SKOPT", "Visual Machine Learning with Bayesian search (scikit-learn, XGBoost, scikit-optimize)"],
            ["DOCTOR_DL_CPU", "Visual Deep Learning: Keras, Tensorflow (CPU)"],
            ["DOCTOR_DL_GPU_CUDA100", "Visual Deep Learning: Keras, Tensorflow (GPU with CUDA 10.0 and cuDNN 7)"],
            ["DOCTOR_DL_GPU_CUDA9", "Visual Deep Learning: Keras, Tensorflow (GPU with CUDA 9 and cuDNN 7)"],
            ["STREAMING", "Native access to streams (Kafka, HTTP SSE)"]
        ];

        const doctorPackagesPip = "scikit-learn>=0.20,<0.21\n" +
                                  "scipy>=1.2,<1.3\n" +
                                  "xgboost==0.82\n" +
                                  "statsmodels>=0.10,<0.11\n" +
                                  "jinja2>=2.10,<2.11\n" +
                                  "flask>=1.0,<1.1\n" +
                                  "cloudpickle>=1.3,<1.6\n";

        const doctorDLPackagesPipWithoutTF = "scikit-learn>=0.20,<0.21\n" +
                                     "scipy>=1.2,<1.3\n" +
                                     "statsmodels>=0.10,<0.11\n" +
                                     "jinja2>=2.10,<2.11\n" +
                                     "flask>=1.0,<1.1\n" +
                                     "h5py==2.10.0\n" +
                                     "pillow==6.2.2\n" +
                                     "cloudpickle>=1.3,<1.6\n";

        const packageListPipValues = {
            DOCTOR: doctorPackagesPip,
            DOCTOR_BAYESIAN_SKOPT: "scikit-optimize>=0.7,<0.8\n" + doctorPackagesPip,
            DOCTOR_DL_CPU: "tensorflow==1.15.0\nkeras==2.3.1\nkeras-preprocessing==1.1.0\n" + doctorDLPackagesPipWithoutTF,
            DOCTOR_DL_GPU_CUDA100: "tensorflow-gpu==1.15.0\nkeras==2.3.1\nkeras-preprocessing==1.1.0\n" + doctorDLPackagesPipWithoutTF,
            DOCTOR_DL_GPU_CUDA9: "tensorflow-gpu==1.8.0\nkeras==2.1.5\n" + doctorDLPackagesPipWithoutTF,
            STREAMING: "pykafka==2.8.0\nsseclient==0.0.26"
        };

        const doctorPackagesConda = "scikit-learn>=0.20,<0.21\n" +
                                    "scipy>=1.2,<1.3\n" +
                                    "xgboost==0.82\n" +
                                    "statsmodels>=0.10,<0.11\n" +
                                    "jinja2>=2.10,<2.11\n" +
                                    "flask>=1.0,<1.1\n" +
                                    "cloudpickle>=1.3,<1.6\n";

        const doctorDLPackagesCondaWithoutTF = "scikit-learn>=0.20,<0.21\n" +
                                       "scipy>=1.2,<1.3\n" +
                                       "statsmodels>=0.10,<0.11\n" +
                                       "jinja2>=2.10,<2.11\n" +
                                       "flask>=1.0,<1.1\n" +
                                       "h5py==2.10.0\n" +
                                       "pillow==6.2.2\n" +
                                       "cloudpickle>=1.3,<1.6\n";

        const packageListCondaValues = {
            DOCTOR: doctorPackagesConda,
            DOCTOR_BAYESIAN_SKOPT: "scikit-optimize>=0.7,<0.8\n" + doctorPackagesConda,
            DOCTOR_DL_CPU: "tensorflow==1.15.0\nkeras==2.3.1\nkeras-preprocessing==1.1.0\n" + doctorDLPackagesCondaWithoutTF,
            DOCTOR_DL_GPU_CUDA100: "tensorflow-gpu==1.15.0\nkeras==2.3.1\nkeras-preprocessing==1.1.0\n" + doctorDLPackagesPipWithoutTF,
            DOCTOR_DL_GPU_CUDA9: "tensorflow-gpu==1.8.0\nkeras==2.1.5\n" + doctorDLPackagesCondaWithoutTF,
            STREAMING: "pykafka >=2.8.0,<2.9\nsseclient >=0.0.26,<0.1"
        };

        newScope.packageListTypes = packageListTypes;
        if (type === "pip") {
            newScope.packageListValues = packageListPipValues;
        } else {
            newScope.packageListValues = packageListCondaValues;
        }

        newScope.selectedPackages = newScope.packageListTypes[0][0];

        newScope.insertReadOnlyOptions = $scope.codeMirrorSettingService.get('text/plain');
        newScope.insertReadOnlyOptions["readOnly"]= "nocursor";
        newScope.insertReadOnlyOptions["lineNumbers"]= false;
        newScope.insertReadOnlyOptions["foldGutter"]= false;

        CreateModalFromTemplate("/templates/admin/code-envs/design/add-additional-packages-modal.html",
            newScope,
            null,
            function(scope) {
                scope.acceptedDeffered = deferred;

                scope.insertPackages = function() {
                    scope.acceptedDeffered.resolve(scope.packageListValues[scope.selectedPackages]);
                    scope.dismiss();
                };
            }
        );
        deferred.promise.then(function(inputCode) {
            insertCode(inputCode, type);
        });
    };

    $scope.getLog = DataikuAPI.admin.codeenvs.design.getLog;
    $scope.downloadLog = Logs.downloadDesignCodeEnv;
});

app.controller("AdminCodeEnvsDesignPythonEditController", function($scope, $controller,$state, $stateParams, TopNav, DataikuAPI, FutureProgressModal, Dialogs) {
    $scope.envLang = "PYTHON";
    $controller("_AdminCodeEnvsDesignEditController", {$scope:$scope});
});

app.controller("AdminCodeEnvsDesignREditController", function($scope, $controller,$state, $stateParams, TopNav, DataikuAPI, FutureProgressModal, Dialogs) {
    $scope.envLang = "R";
    $controller("_AdminCodeEnvsDesignEditController", {$scope:$scope});
});

}());

(function() {
'use strict';

var app = angular.module('dataiku.admin.codeenvs.automation', []);


app.controller("AdminCodeEnvsAutomationController", function($scope, TopNav, DataikuAPI, Dialogs, FutureProgressModal, CreateModalFromTemplate, ActivityIndicator) {
    $scope.openDeleteEnvModal = function(envLang, envName){
        var newScope = $scope.$new();
        newScope.envLang = envLang;
        newScope.envName = envName;
        // modal appears when usages are ready
        DataikuAPI.admin.codeenvs.automation.listUsages(newScope.envLang, newScope.envName).success(function(data){
            newScope.usagesList = data;
            // group by type / project
            newScope.usageByType = {};
            newScope.usageByProject = {};
            newScope.usagesList.forEach(function(usage) {
                if (usage.envUsage) {
                    newScope.usageByType[usage.envUsage] = newScope.usageByType[usage.envUsage] || [];
                    newScope.usageByType[usage.envUsage].push(usage);
                }
                if (usage.projectKey) {
                    newScope.usageByProject[usage.projectKey] = newScope.usageByProject[usage.projectKey] || [];
                    newScope.usageByProject[usage.projectKey].push(usage);
                }
            });
            CreateModalFromTemplate("/templates/admin/code-envs/common/delete-env-modal.html", newScope, "AdminCodeEnvsAutomationDeleteController")
        }).error(setErrorInScope.bind($scope));
    }

    $scope.canCreateCodeEnv = function() {
        return $scope.appConfig.admin || $scope.appConfig.globalPermissions.mayCreateCodeEnvs || $scope.appConfig.globalPermissions.mayManageCodeEnvs;
    };

    $scope.getEnvDiagnostic = function(envLang, envName) {
        ActivityIndicator.success("Generating code env diagnostic ...");
        downloadURL(DataikuAPI.admin.codeenvs.automation.getDiagnosticURL(envLang, envName));
    };
});

app.controller("AdminCodeEnvsAutomationListController", function($scope, $controller, TopNav, DataikuAPI, Dialogs, CreateModalFromTemplate, $state) {
    $controller("AdminCodeEnvsAutomationController", {$scope:$scope});
	TopNav.setLocation(TopNav.DSS_HOME, "administration");

	var buildKernelSpecField = function(env) {
        if (env.currentVersion) {
            env.kernelSpecName = env.currentVersion.kernelSpecName;
        } else if (env.noVersion) {
            env.kernelSpecName = env.noVersion.kernelSpecName;
        } else if (env.versions) {
            var names = [];
            env.versions.forEach(function(ver) {
                angular.forEach(ver.kernelSpecNames, function(v, k) {names.push(k);});
            });
            env.kernelSpecName = names.join(', ');
        }
	};
    $scope.refreshList = function() {
        return DataikuAPI.admin.codeenvs.automation.list().success(function(data) {
            $scope.codeEnvs = data;
            $scope.codeEnvs.forEach(function(env) {buildKernelSpecField(env);});
        }).error(setErrorInScope.bind($scope));
    };
    $scope.refreshList();

    const YOU_DONT_REALLY_WANT_TO_CREATE =
            "Manually creating code envs in automation nodes is <strong>not recommended</strong>. The recommended way to manage " +
            "code envs in automation is to let bundle preload take care of it: simply preload and activate bundles " + 
            "and the required code envs will be automatically managed.<br /><strong>Manually created code envs may not be entirely "+
            "functional</strong>.";

    const YOU_DONT_REALLY_WANT_TO_IMPORT =
            "Manually importing code envs in automation nodes is <strong>not recommended</strong>. The recommended way to manage " +
            "code envs in automation is to let bundle preload take care of it: simply preload and activate bundles " + 
            "and the required code envs will be automatically managed.<br /><strong>Manually imported code envs may not be entirely "+
            "functional</strong>.";

    $scope.openNewPythonEnvModal = function(){
        Dialogs.confirm($scope, "Really create a new Python env?", YOU_DONT_REALLY_WANT_TO_CREATE).then(function(){
            CreateModalFromTemplate("/templates/admin/code-envs/automation/new-python-env-modal.html", $scope, "AdminCodeEnvsAutomationNewPythonController")
        });
    }
    $scope.openNewREnvModal = function(){
        Dialogs.confirm($scope, "Really create a new R env?", YOU_DONT_REALLY_WANT_TO_CREATE).then(function(){
            CreateModalFromTemplate("/templates/admin/code-envs/automation/new-R-env-modal.html", $scope, "AdminCodeEnvsAutomationNewRController")
        });
    }
    $scope.openImportEnvModal = function(){
        Dialogs.confirm($scope, "Really import a code env?", YOU_DONT_REALLY_WANT_TO_IMPORT).then(function(){
            CreateModalFromTemplate("/templates/admin/code-envs/automation/import-env-modal.html", $scope, "AdminCodeEnvsAutomationImportController")
        });
    }
    $scope.actionAfterDeletion = function() {
        $scope.refreshList();
    };
    $scope.goToEditIfExists = function(envName) {
        const env = $scope.codeEnvs.find(e => e.envName === envName);
        if(env && env.envLang === 'R') {
            $state.go("admin.codeenvs-automation.r-edit", { envName });
        } else if(env && env.envLang === 'PYTHON'){
            $state.go("admin.codeenvs-automation.python-edit", { envName });
        }
    };
});

app.controller("AdminCodeEnvsAutomationDeleteController", function($scope, TopNav, DataikuAPI, Dialogs, FutureProgressModal, $q) {
    $scope.delete = function() {
        var parentScope = $scope.$parent;
        DataikuAPI.admin.codeenvs.automation.delete($scope.envLang, $scope.envName).success(function(data){
            $scope.dismiss();
            FutureProgressModal.show(parentScope, data, "Env deletion").then(function(result){
                const infoModalClosed = result
                    ? Dialogs.infoMessagesDisplayOnly(parentScope, "Deletion result", result.messages, result.futureLog)
                    : $q.resolve();
                infoModalClosed.then(() => $scope.actionAfterDeletion());
            });
        }).error(setErrorInScope.bind($scope));

    };
});

app.controller("AdminCodeEnvsAutomationNewPythonController", function($scope, TopNav, DataikuAPI, Dialogs, FutureProgressModal, $q) {
    $scope.newEnv = {
            deploymentMode: "AUTOMATION_SINGLE",
            pythonInterpreter: "PYTHON36",
            conda: false,
            installCorePackages: true,
            // corePackagesSet : "PANDAS10", // let the backend decide
            installJupyterSupport: true
    };

    $scope.deploymentModes = [
                              ["AUTOMATION_VERSIONED", "Managed and versioned (recommended)"],
                              ["AUTOMATION_SINGLE", "Managed, non versioned"],
                              ["AUTOMATION_NON_MANAGED_PATH", "Externally-managed"],
                              ["EXTERNAL_CONDA_NAMED", "Named external Conda env"]
                          ];

    $scope.$watch("newEnv.conda", function(nv) {
        if (nv === true) {
            $scope.pythonInterpreters = [
                ["PYTHON27", "Python 2.7"],
                // ["PYTHON34", "Python 3.4"],
                ["PYTHON35", "Python 3.5"],
                ["PYTHON36", "Python 3.6"],
                ["PYTHON37", "Python 3.7"],
            ]
        } else if (nv === false) {
            $scope.pythonInterpreters = [
                ["PYTHON27", "Python 2.7 (from PATH)"],
                // ["PYTHON34", "Python 3.4 (from PATH)"],
                ["PYTHON35", "Python 3.5 (from PATH)"],
                ["PYTHON36", "Python 3.6 (from PATH)"],
                ["PYTHON37", "Python 3.7 (from PATH)"],
                ["CUSTOM", "Custom (lookup in PATH)"]
            ]
        }
    });

    $scope.create = function(){
        var parentScope = $scope.$parent.$parent;
        DataikuAPI.admin.codeenvs.automation.create("PYTHON", $scope.newEnv).success(function(data){
            $scope.dismiss();
            FutureProgressModal.show(parentScope, data, "Env creation").then(function(result){
                const modalClosed = result
                    ? Dialogs.infoMessagesDisplayOnly(parentScope, "Creation result", result.messages, result.futureLog, undefined, 'static', false)
                    : $q.resolve();

                const refreshed = parentScope.refreshList();

                $q.all([modalClosed, refreshed]).then(() => {
                    parentScope.goToEditIfExists(result && result.envName);
                });
            });
        }).error(setErrorInScope.bind($scope));
    }
});

app.controller("AdminCodeEnvsAutomationNewRController", function($scope, TopNav, DataikuAPI, Dialogs, FutureProgressModal, $q) {
    $scope.newEnv = {
            deploymentMode: "AUTOMATION_SINGLE",
            conda: false,
            installCorePackages: true,
            installJupyterSupport: true
        };

    $scope.deploymentModes = [
                              ["AUTOMATION_VERSIONED", "Managed and versioned (recommended)"], // versioned is only created/modified by bundles
                              ["AUTOMATION_SINGLE", "Managed, non versioned"],
                              ["AUTOMATION_NON_MANAGED_PATH", "Externally-managed"],
                              ["EXTERNAL_CONDA_NAMED", "Named external Conda env"]
                          ];

    $scope.create = function(){
        var parentScope = $scope.$parent.$parent;
        DataikuAPI.admin.codeenvs.automation.create("R", $scope.newEnv).success(function(data){
            $scope.dismiss();
            FutureProgressModal.show(parentScope, data, "Env creation").then(function(result){
                const modalClosed = result
                    ? Dialogs.infoMessagesDisplayOnly(parentScope, "Creation result", result.messages, result.futureLog, undefined, 'static', false)
                    : $q.resolve();

                const refreshed = parentScope.refreshList();

                $q.all([modalClosed, refreshed]).then(() => {
                    parentScope.goToEditIfExists(result && result.envName);
                });
            });
        }).error(setErrorInScope.bind($scope));
    }
});

app.controller("AdminCodeEnvsAutomationImportController", function($scope, $state, $stateParams, Assert, TopNav, DataikuAPI, FutureProgressModal, Dialogs, Logs, $q) {
    $scope.newEnv = {}

    $scope.import = function() {
        Assert.trueish($scope.newEnv.file, "No code env file");

        const parentScope = $scope.$parent.$parent;
        DataikuAPI.admin.codeenvs.automation.import($scope.newEnv.file).then(function(data) {
            $scope.dismiss();
            FutureProgressModal.show(parentScope, JSON.parse(data), "Env import").then(function(result) {
                const modalClosed = result
                    ? Dialogs.infoMessagesDisplayOnly(parentScope, "Creation result", result.messages, result.futureLog, undefined, 'static', false)
                    : $q.resolve();

                const refreshed = parentScope.refreshList();

                $q.all([modalClosed, refreshed]).then(() => {
                    parentScope.goToEditIfExists(result && result.envName);
                });
            });
        }, function(payload) {
            setErrorInScope.bind($scope)(JSON.parse(payload.response), payload.status, function(h) {return payload.getResponseHeader(h)});
        });
    }
});

app.controller("AdminCodeEnvsAutomationImportVersionController", function($scope, $state, $stateParams, Assert, TopNav, DataikuAPI, FutureProgressModal, Dialogs, Logs) {
    $scope.newEnv = {}

    $scope.import = function() {
        Assert.trueish($scope.newEnv.file, "No code env file");

        const parentScope = $scope.$parent.$parent;
        DataikuAPI.admin.codeenvs.automation.importVersion($scope.newEnv.file, $scope.envLang, $scope.envName).then(function(data) {
            $scope.dismiss();
            FutureProgressModal.show(parentScope, JSON.parse(data), "Env import").then(function(result) {
                if (result) { // undefined in case of abort
                    Dialogs.infoMessagesDisplayOnly(parentScope, "Import result", result.messages, result.futureLog);
                    $scope.addImportedVersion(result.version);
                }
            });
        }, function(payload) {
            setErrorInScope.bind($scope)(JSON.parse(payload.response), payload.status, function(h) {return payload.getResponseHeader(h)});
        });
    }
});

app.controller("_AdminCodeEnvsAutomationEditController", function($scope, $controller, $state, $stateParams, TopNav, DataikuAPI, FutureProgressModal, Dialogs, Logs, CreateModalFromTemplate) {
    $controller("AdminCodeEnvsAutomationController", {$scope:$scope});
    TopNav.setLocation(TopNav.DSS_HOME, "administration");

     $scope.uiState = {
        active : 'info',
        upgradeAllPackages: true
     };

     $scope.actionAfterDeletion = function() {
         $state.go("admin.codeenvs-automation.list");
     };

     $scope.canBeUpdated = function() {
         return $scope.codeEnv && $scope.codeEnv.canUpdateCodeEnv && ['DESIGN_MANAGED', 'PLUGIN_MANAGED', 'AUTOMATION_SINGLE'].indexOf($scope.codeEnv.deploymentMode) >= 0;
     };
     $scope.canVersionBeUpdated = function(versionId) {
         return ['AUTOMATION_VERSIONED'].indexOf($scope.codeEnv.deploymentMode) >= 0 || $scope.canBeUpdated();
     };

     $scope.getSingleVersion = function(codeEnv) {
         if (codeEnv && codeEnv.currentVersion) {
             return codeEnv.currentVersion.versionId;
         } else if (codeEnv && codeEnv.noVersion) {
             return codeEnv.noVersion.versionId;
         } else {
             return null;
         }
     };

     var makeDiffedDesc = function(desc) {
         return {
             yarnPythonBin: desc.yarnPythonBin,
             yarnRBin: desc.yarnRBin,
             allContainerConfs: desc.allContainerConfs,
             containerConfs: desc.containerConfs,
             allSparkKubernetesConfs: desc.allSparkKubernetesConfs,
             sparkKubernetesConfs: desc.sparkKubernetesConfs
         };
     };
     var makeDiffedVersion = function(version) {
         return {
             specCondaEnvironment: version.specCondaEnvironment,
             specPackageList: version.specPackageList,
             desc: makeDiffedDesc(version.desc)
          };
     };
     var makeDiffedSpec = function(codeEnv) {
         var spec = {};
         if (codeEnv) {
             spec.desc = codeEnv.desc;
             spec.externalCondaEnvName = codeEnv.externalCondaEnvName;
             if (codeEnv.currentVersion) {
                 spec.currentVersion = makeDiffedVersion(codeEnv.currentVersion);
             }
             if (codeEnv.noVersion) {
                 spec.noVersion = makeDiffedVersion(codeEnv.noVersion);
             }
             if (codeEnv.versions) {
                 spec.versions = codeEnv.versions.map(function(v) {return makeDiffedVersion(v);});
             }
             spec.permissions = angular.copy(codeEnv.permissions);
             spec.envSettings = angular.copy(codeEnv.envSettings);
             spec.usableByAll = codeEnv.usableByAll;
             spec.owner = codeEnv.owner;
         }
         return spec;
     };

     $scope.specIsDirty = function() {
         if (!$scope.codeEnv) return false;
         var currentSpec = makeDiffedSpec($scope.codeEnv);
         return !angular.equals(currentSpec, $scope.previousSpec);
     };
     $scope.versionSpecIsDirty = function(versionId) {
         if (!$scope.codeEnv) return false;
         var idx = -1;
         $scope.codeEnv.versions.forEach(function(v, i) {if (v.versionId == versionId) {idx = i;}});
         if (idx < 0) {
             return false;
         } else {
             var currentSpec = makeDiffedVersion($scope.codeEnv.versions[idx]);
             return !angular.equals(currentSpec, $scope.previousSpec.versions[idx]);
         }
     };
    checkChangesBeforeLeaving($scope, $scope.specIsDirty);

    $scope.previousSpec = makeDiffedSpec($scope.codeEnv);

    var listLogs = function(){
        DataikuAPI.admin.codeenvs.automation.listLogs($scope.envLang, $stateParams.envName).success(function(data) {
            $scope.logs = data;
        }).error(setErrorInScope.bind($scope));
    };

    var refreshEnv = function(){
        DataikuAPI.admin.codeenvs.automation.get($scope.envLang, $stateParams.envName).success(function(data) {
            $scope.codeEnv = data;
            $scope.previousSpec = makeDiffedSpec($scope.codeEnv);
        }).error(setErrorInScope.bind($scope));
        listLogs();
    }
    var refreshEnvVersion = function(versionId){
        DataikuAPI.admin.codeenvs.automation.getVersion($scope.envLang, $stateParams.envName, versionId).success(function(data) {
            var idx = -1;
            $scope.codeEnv.versions.forEach(function(v, i) {if (v.versionId == versionId) {idx = i;}});
            if (idx >= 0) {
                $scope.codeEnv.versions[idx] = data;
                $scope.previousSpec.versions[idx] = makeDiffedVersion(data);
            }
        }).error(setErrorInScope.bind($scope));
    }
    refreshEnv();

    $scope.fetchNonManagedEnvDetails = function(){
        DataikuAPI.admin.codeenvs.automation.fetchNonManagedEnvDetails($scope.envLang, $stateParams.envName).success(function(data) {
            $scope.nonManagedEnvDetails = data;
        }).error(setErrorInScope.bind($scope));
    }

    $scope.installJupyterSupport = function(versionId){
        DataikuAPI.admin.codeenvs.automation.installJupyterSupport($scope.envLang, $stateParams.envName, versionId).success(function(data) {
            FutureProgressModal.show($scope, data, "Env update").then(function(result){
                if (result) { // undefined in case of abort
                    Dialogs.infoMessagesDisplayOnly($scope, "Update result", result.messages, result.futureLog);
                }
                if (versionId) {
                    refreshEnvVersion(versionId);
                } else {
                    refreshEnv();
                }
            })
        }).error(setErrorInScope.bind($scope));
    }

    $scope.removeJupyterSupport = function(versionId) {
        DataikuAPI.admin.codeenvs.automation.removeJupyterSupport($scope.envLang, $stateParams.envName, versionId).success(function(data) {
            FutureProgressModal.show($scope, data, "Env update").then(function(result){
                if (result) { // undefined in case of abort
                    Dialogs.infoMessagesDisplayOnly($scope, "Update result", result.messages, result.futureLog);
                }
                if (versionId) {
                    refreshEnvVersion(versionId);
                } else {
                    refreshEnv();
                }
            })
        }).error(setErrorInScope.bind($scope));
    }

    $scope.updateEnv = function(upgradeAllPackages, forceRebuildEnv, versionToUpdate) {
        var updateSettings = {
            forceRebuildEnv: forceRebuildEnv,
            versionToUpdate: versionToUpdate
        }
        DataikuAPI.admin.codeenvs.automation.update($scope.envLang, $stateParams.envName, updateSettings).success(function(data) {
            FutureProgressModal.show($scope, data, "Env update").then(function(result){
                if (result) { // undefined in case of abort
                    Dialogs.infoMessagesDisplayOnly($scope, "Update result", result.messages, result.futureLog);
                }
                if (versionToUpdate) {
                    refreshEnvVersion(versionToUpdate);
                } else {
                    refreshEnv();
                }
            })
        }).error(setErrorInScope.bind($scope));
    }

    $scope.saveAndMaybePerformChanges = function(performChangesOnSave){
        DataikuAPI.admin.codeenvs.automation.save($scope.envLang, $stateParams.envName, $scope.codeEnv).success(function(data) {
            refreshEnv();
            if (performChangesOnSave) {
                $scope.updateEnv(false);
            }
        }).error(setErrorInScope.bind($scope));
    }

    $scope.saveVersionAndMaybePerformChanges = function(performChangesOnSave, version){
        DataikuAPI.admin.codeenvs.automation.saveVersion($scope.envLang, $stateParams.envName, version.versionId, version).success(function(data) {
            refreshEnvVersion(version.versionId);
            if (performChangesOnSave) {
                $scope.updateEnv(false, false, version.versionId);
            }
        }).error(setErrorInScope.bind($scope));
    }

    $scope.setContainerConfForAllVersions = function(origVersion) {
        $scope.codeEnv.versions.forEach(function(v) {
            v.desc.allContainerConfs = origVersion.desc.allContainerConfs;
            v.desc.containerConfs = origVersion.desc.containerConfs;
            v.desc.allSparkKubernetesConfs = origVersion.desc.allSparkKubernetesConfs;
            v.desc.sparkKubernetesConfs = origVersion.desc.sparkKubernetesConfs;
        });
    }

    $scope.getLog = DataikuAPI.admin.codeenvs.automation.getLog;
    $scope.downloadLog = Logs.downloadAutomationCodeEnv;

    $scope.openImportEnvVersionModal = function(){
        CreateModalFromTemplate("/templates/admin/code-envs/automation/import-env-version-modal.html", $scope, "AdminCodeEnvsAutomationImportVersionController", function(newScope) {
            newScope.envName = $stateParams.envName;
            newScope.envLang = $scope.envLang;
            newScope.addImportedVersion = function(version) {
                if (version == null) return; // aborted? failed?
                // put new version first (bc it's the most recent)
                $scope.codeEnv.versions.splice(0, 0, version);
                $scope.previousSpec.versions.splice(0, 0, makeDiffedVersion(version));
            };
        });
    }
});

app.controller("AdminCodeEnvsAutomationPythonEditController", function($scope, $controller,$state, $stateParams, TopNav, DataikuAPI, FutureProgressModal, Dialogs) {
    $scope.envLang = "PYTHON";
    $controller("_AdminCodeEnvsAutomationEditController", {$scope:$scope});
});

app.controller("AdminCodeEnvsAutomationREditController", function($scope, $controller,$state, $stateParams, TopNav, DataikuAPI, FutureProgressModal, Dialogs) {
    $scope.envLang = "R";
    $controller("_AdminCodeEnvsAutomationEditController", {$scope:$scope});
});

app.directive('pythonVersion', function(DataikuAPI, $state, $stateParams, $rootScope) {
    return {
        restrict : 'A',
        templateUrl : '/templates/admin/code-envs/automation/python-version.html',
        scope : {
                version : '=pythonVersion',
                updateEnv : '&' ,
                saveVersion : '&' ,
                versionSpecIsDirty : '&',
                installJupyterSupport : '&',
                removeJupyterSupport : '&',
                editable : '=',
                withSaveUpdate : '=',
                canVersionBeUpdated : '&'
        },
        link : function($scope, element, attrs) {
            $scope.appConfig = $rootScope.appConfig;
            $scope.updateVersionEnv = function(updateAllPackages, forceRebuildEnv) {
                $scope.updateEnv()(updateAllPackages, forceRebuildEnv, $scope.version.versionId);
            }
            $scope.saveVersionEnv = function(performChangesOnSave) {
                $scope.saveVersion()(performChangesOnSave, $scope.version);
            }
            $scope.installJupyterSupportVersion = function() {
                $scope.installJupyterSupport()($scope.version.versionId);
            }
            $scope.specIsDirty = function() {
                return $scope.versionSpecIsDirty()($scope.version.versionId);
            }
            $scope.canBeUpdated = function() {
                return $scope.canVersionBeUpdated()($scope.version.versionId);
            }
            $scope.removeJupyterSupportVersion = function() {
                $scope.removeJupyterSupport()($scope.version.versionId);
            }
        }
    };
});

app.directive('rVersion', function(DataikuAPI, $state, $stateParams, $rootScope) {
    return {
        restrict : 'A',
        templateUrl : '/templates/admin/code-envs/automation/R-version.html',
        scope : {
                version : '=rVersion',
                updateEnv : '&',
                saveVersion : '&' ,
                versionSpecIsDirty : '&',
                installJupyterSupport : '&',
                removeJupyterSupport : '&',
                editable : '=',
                withSaveUpdate : '=',
                canVersionBeUpdated : '&'
        },
        link : function($scope, element, attrs) {
            $scope.appConfig = $rootScope.appConfig;
            $scope.updateVersionEnv = function(updateAllPackages, forceRebuildEnv) {
                $scope.updateEnv()(updateAllPackages, forceRebuildEnv, $scope.version.versionId);
            }
            $scope.saveVersionEnv = function(performChangesOnSave) {
                $scope.saveVersion()(performChangesOnSave, $scope.version);
            }
            $scope.installJupyterSupportVersion = function() {
                $scope.installJupyterSupport()($scope.version.versionId);
            }
            $scope.specIsDirty = function() {
                return $scope.versionSpecIsDirty()($scope.version.versionId);
            }
            $scope.canBeUpdated = function() {
                return $scope.canVersionBeUpdated()($scope.version.versionId);
            }
            $scope.removeJupyterSupportVersion = function() {
                $scope.removeJupyterSupport()($scope.version.versionId);
            }
        }
    };
});

app.directive('containerVersion', function(DataikuAPI, $state, $stateParams, $rootScope, $timeout) {
    return {
        restrict : 'A',
        templateUrl : '/templates/admin/code-envs/automation/container-version.html',
        scope : {
            version : '=containerVersion',
            updateEnv : '&' ,
            saveVersion : '&' ,
            versionSpecIsDirty : '&',
            withSaveUpdate : '=',
            canVersionBeUpdated : '&',
            setForAllVersions: '&'
        },
        link : function($scope, element, attrs) {
            $scope.appConfig = $rootScope.appConfig;
            $scope.updateVersionEnv = function(updateAllPackages, forceRebuildEnv) {
                $scope.updateEnv()(updateAllPackages, forceRebuildEnv, $scope.version.versionId);
            }
            $scope.saveVersionEnv = function(performChangesOnSave) {
                $scope.saveVersion()(performChangesOnSave, $scope.version);
            }
            $scope.specIsDirty = function() {
                return $scope.versionSpecIsDirty()($scope.version.versionId);
            }
            $scope.canBeUpdated = function() {
                return $scope.canVersionBeUpdated()($scope.version.versionId);
            }
            $scope.setThisForAllVersions = function() {
                $timeout(function() {
                    $scope.setForAllVersions()($scope.version);
                });
            }
        }
    };
});


}());

(function(){
'use strict';

var app = angular.module('dataiku.admin.monitoring', []);

app.controller("AdminMonitoringSummaryController", function($scope, $rootScope, $state, DataikuAPI, $filter, $anchorScroll, $timeout){
    $scope.refresh = function refresh(){
        DataikuAPI.admin.monitoring.getGlobalUsageSummary().success(function(data){
            $scope.globalSummary = data;
            $scope.globalSummary.datasets.allByTypeArray = $filter("toKVArray")($scope.globalSummary.datasets.allByType);
            $scope.globalSummary.recipes.byTypeArray = $filter("toKVArray")($scope.globalSummary.recipes.byType);
            $timeout(() => $anchorScroll());
        }).error(setErrorInScope.bind($scope));
    }
    $scope.refresh();
});

app.controller("AdminMonitoringWebAppBackendsController", function($scope, $rootScope, $state, DataikuAPI, ActivityIndicator) {
    $scope.refreshList = function(){
        DataikuAPI.webapps.listAllBackendsStates().success(function(data){
            $scope.backends = data;
        }).error(setErrorInScope.bind($scope));
    }

    $scope.stopBackend = function(backend){
        DataikuAPI.webapps.stopBackend({projectKey:backend.projectKey, id:backend.webAppId}).success(function(data){
            ActivityIndicator.success("Backend stopped")
        }).error(setErrorInScope.bind($scope));
    }

    $scope.restartBackend = function(backend){
        DataikuAPI.webapps.restartBackend({projectKey:backend.projectKey, id:backend.webAppId}).success(function(data){
            ActivityIndicator.success("Backend start command sent")
        }).error(setErrorInScope.bind($scope));
    }
    $scope.refreshList();
});

app.controller("AdminMonitoringIntegrationsController", function($scope, DataikuAPI, ActivityIndicator, Dialogs, WT1) {
    $scope.hidePreviewColumn = true;
    $scope.noTags = true;
    $scope.noStar = true;
    $scope.noWatch = true;
    $scope.massDelete = true;
    $scope.massIntegrations = true;
    $scope.noDelete = true;

    $scope.sortBy = [
        { value: 'projectKey', label: 'Project name' },
        { value: 'integrationName', label: 'Integration type' },
        { value: 'integrationActive', label: 'Active' }
    ];
    $scope.selection = $.extend({
        filterQuery: {
            userQuery: '',
            interest: {
                starred: '',
            },
        },
        filterParams: {
            userQueryTargets: ["projectKey", "name", "integrationName", "integrationProperties"],
            propertyRules: { },
        },
        orderQuery: "projectKey",
        orderReversed: false,
    }, $scope.selection || {});
    $scope.sortCookieKey = 'project-integrations';
    $scope.maxItems = 100;

    $scope.list = () => {
        WT1.event("refresh-project-integrations-list");
        DataikuAPI.admin.monitoring.getProjectsIntegrations().success((data) => {
            $scope.integrations = data;
            $scope.listItems = [];
            data.forEach(item => {
                item.integrations.forEach(integration => {
                    $scope.listItems.push({
                        ...integration,
                        integrationName: formatIntegrationName(integration.hook.type),
                        integrationActive: integration.active,
                        integrationDetails: integration.hook.configuration.webhookUrl || undefined,
                        integrationProperties: formatIntegrationProperties(integration),
                        projectKey: item.projectKey
                    });
                });
            });
        }).error(setErrorInScope.bind($scope));
    };
    $scope.list();

    $scope.toggleActive = function(item) {
        WT1.event("integration-save-active");
        DataikuAPI.admin.monitoring.saveProjectIntegration(item.projectKey, item).success(function(data){
            ActivityIndicator.success("Saved");
        }).error(setErrorInScope.bind($scope));
    };

    $scope.deleteIntegration = (item) => {
        WT1.event("integration-delete");
        DataikuAPI.admin.monitoring.deleteProjectIntegration(item.projectKey, item).success(() => {
            ActivityIndicator.success("Saved");
        }).error(setErrorInScope.bind($scope));
    };

    $scope.massDeletion = (items) => {
        if(items.length < 1) return;
        Dialogs.confirm($scope, "Confirm deletion", "Are you sure you want to delete the selected integrations?").then(function() {
            items.forEach((item) => {
                item.active = status;
                $scope.deleteIntegration(item);
                $scope.listItems = $scope.listItems.filter(s => s !== item)
            })
        });
    };

    $scope.allIntegrations = function(objects) {
        if (!objects) return;
        return objects.map(o => o.active).reduce(function(a,b){return a&&b;},true);
    };

    $scope.autoIntegrationsObjects = function(autoIntegrationsStatus, objects) {
        objects.forEach(function(object) {
            if (object.active === autoIntegrationsStatus) return;
            object.active = autoIntegrationsStatus;
            $scope.toggleActive(object);
        })
    };

    const formatIntegrationProperties = (integration) => {
        if(integration.hook.type === "github") {
            return "Repository: " + integration.hook.configuration.repository;
        }

        const labels = [];
        if(integration.hook.configuration.selection.commits)                     { labels.push("Git commits"); }
        if(integration.hook.configuration.selection.discussions)                 { labels.push("Discussions messages"); }
        if(integration.hook.configuration.selection.jobEnds)                     { labels.push("Build jobs ends"); }
        if(integration.hook.configuration.selection.jobStarts)                   { labels.push("Build jobs beginnings"); }
        if(integration.hook.configuration.selection.mlEnds)                      { labels.push("Analysis ML training ends"); }
        if(integration.hook.configuration.selection.mlStarts)                    { labels.push("Analysis ML training beginnings"); }
        if(integration.hook.configuration.selection.scenarioEnds)                { labels.push("Scenario ends"); }
        if(integration.hook.configuration.selection.scenarioStarts)              { labels.push("Scenario starts"); }
        if(integration.hook.configuration.selection.timelineEditionItems)        { labels.push("Objects editions"); }
        if(integration.hook.configuration.selection.timelineItemsExceptEditions) { labels.push("Objects creation / deletion / ..."); }
        if(integration.hook.configuration.selection.watchStar)                   { labels.push("Watch / Star"); }
        return labels.length > 0 ? "Sends on " + labels.join(", ") : "";
    };

    const  formatIntegrationName = (type) => {
        const typeMapping = {
            "msft-teams-project": "Microsoft Teams",
            "github": "Github",
            "slack-project": "Slack"
        };
        return typeMapping[type] || type;
    }
});


app.controller("AdminMonitoringClusterTasksController", function($scope, $rootScope, $state, DataikuAPI, Fn, $filter){

	$scope.uiState = {}

    DataikuAPI.admin.connections.list().success(function(data) {
        var array = $filter("toArray")(data);
        var hasHDFS = array.filter(Fn.compose(Fn.prop("type"), Fn.eq("HDFS"))).length > 0;
        $scope.connections = array.filter(function(x){
            return x.type != "HDFS";
        }).map(function(x){
            return { "name"  :x.name , type  : x.type , "id" : x.name }
        });
        if (hasHDFS) {
            $scope.connections.push({
                "name" : "Hadoop",
                "type" : "Hadoop",
                "id" : "HADOOP"
            })
        }
    }).error(setErrorInScope.bind($scope));

    $scope.fetchData = function fetchData(connectionId){
        DataikuAPI.admin.monitoring.getConnectionTasksHistory(connectionId).success(function(data){
            $scope.connectionData = data;

            data.lastTasks.forEach(function(t) {
                t.elapsedTime = t.endTime - t.startTime;
            })

            $scope.projectData = [];
            data.perProject.forEach(function(p) {
                p.types.forEach(function(t, i){
                    $scope.projectData.push(angular.extend(t, {projectKey : p.project, l : p.types.length}));
                });
            });

            $scope.userData = [];
            data.perUser.forEach(function(p) {
                p.types.forEach(function(t, i){
                    $scope.userData.push(angular.extend(t, {initiator : p.user, l : p.types.length}));
                });
            });

        }).error(setErrorInScope.bind($scope));
    }
});

app.controller("AdminMonitoringBackgroundTasksController", function ($scope, DataikuAPI, $rootScope, Dialogs, ProgressStackMessageBuilder) {
    $rootScope.$emit("futureModalOpen");
    $scope.Math = window.Math; // for the display of the running time
    function isScenarioFuture(future) {
        try {
            return future.payload.action == 'run_scenario';
        } catch (e) {}
        return false;
    }
    $scope.refreshList = function() {
        $scope.running = {scenarios:[], futures:[], jobs:[], notebooks:[]};
        DataikuAPI.running.listAll().success(function(data) {
            $scope.running = data;
            //scenario have normal futures, but we put them in another tab
            $scope.running.scenarios = $scope.running.futures.filter(function(f){return isScenarioFuture(f);});
            $scope.running.futures = $scope.running.futures.filter(function(f){return !isScenarioFuture(f);});
        }).error(setErrorInScope.bind($scope));
    };

    $scope.abortFuture = function(jobId) {
        DataikuAPI.futures.abort(jobId).success(function(data) {
            $scope.refreshList();
        }).error(setErrorInScope.bind($scope));
    };

    $scope.abortNotebook = function(jobId) {
        DataikuAPI.jupyterNotebooks.unload(jobId).success(function(data) {
            $scope.refreshList();
        }).error(setErrorInScope.bind($scope));
    };

    $scope.abortJob = function(projectKey, jobId) {
        DataikuAPI.flow.jobs.abort(projectKey, jobId).success(function(data) {
            $scope.refreshList();
        }).error(setErrorInScope.bind($scope));
    };

    $scope.refreshList();
    $scope.$on('$destroy', function() {
        $rootScope.$emit("futureModalClose");
    });
});


app.controller("AdminMonitoringConnectionDataController", function($scope, $rootScope, $state, DataikuAPI, Fn, $filter, CreateModalFromTemplate, FutureProgressModal, InfoMessagesModal, Dialogs, DatasetsService){

    $scope.uiState = {}

    DataikuAPI.admin.connections.list().success(function(data) {
        var array = $filter("toArray")(data);
        $scope.connections = array.map(function(x){
            return { "name"  :x.name , type  : x.type , "id" : x.name }
        });
    }).error(setErrorInScope.bind($scope));

    $scope.fetchData = function fetchData(connectionId){
        DataikuAPI.admin.monitoring.connectionData.get(connectionId).success(function(data){
            $scope.connectionData = data;
        }).error(setErrorInScope.bind($scope));
    }

    $scope.focusOnProject = function(connectionId, projectKey) {
         DataikuAPI.admin.monitoring.connectionData.getForProject(connectionId, projectKey).success(function(data){
            $scope.projectData = data;
        }).error(setErrorInScope.bind($scope));
    }
    $scope.clearProjectData = function(){
        $scope.projectData = null;
    }

    $scope.updateForProject = function(connectionId, projectKey){
        CreateModalFromTemplate("/templates/admin/monitoring/connection-data-update-confirm.html", $scope, null, function(newScope){
            newScope.settings = {
                computeRecords : false,
                forceRecompute : false
            }
            newScope.go = function(){
                DataikuAPI.admin.monitoring.connectionData.updateForProject(
                    connectionId, projectKey, newScope.settings.computeRecords, newScope.settings.forceRecompute).success(function(data){
                    FutureProgressModal.show($scope, data, "Datasets update").then(function(result){
                        Dialogs.infoMessagesDisplayOnly($scope, "Update result", result);
                        $scope.fetchData(connectionId);
                    })
                    newScope.dismiss();
                });
            }
        });
    }

    $scope.updateSingleDataset = function(connectionId, projectKey, datasetName) {
        CreateModalFromTemplate("/templates/admin/monitoring/connection-data-update-confirm.html", $scope, null, function(newScope){
            newScope.settings = {
                computeRecords : false,
                forceRecompute : false
            }
            newScope.go = function(){
                DataikuAPI.admin.monitoring.connectionData.updateForDataset(
                    projectKey, datasetName, newScope.settings.computeRecords, newScope.settings.forceRecompute).success(function(data){
                    FutureProgressModal.show($scope, data, "Dataset update").then(function(result){
                        InfoMessagesModal.showIfNeeded($scope, result, "Update result");
                        $scope.focusOnProject(connectionId, projectKey);
                    })
                    newScope.dismiss();
                });
            }
        });
    };

    $scope.clearDataset = function(connectionId, projectKey, datasetName) {
        DatasetsService.clear($scope, projectKey, datasetName).then(function() {
            $scope.focusOnProject(connectionId, projectKey);
        });
    };


});


})();
(function() {
'use strict';

const app = angular.module('dataiku.plugins', ['dataiku.filters', 'dataiku.plugindev']);

app.filter('extractGitRefGroup', function() {
    return function(input) {
        return input.split('/', 2)[1] === 'heads' ? "Branch" : "Tag";
    }
});


app.filter('extractGitRefName', function() {
    var namePattern = /(?:.+?\/){2}(.+)$/;
    return function(input) {
        let match;
        if (match = namePattern.exec(input)) {
            return match[1];
        } else {
            return input;
        }
    }
});


app.directive('pluginContributionList', function() {
    return {
        restrict : 'E',
        templateUrl : '/templates/plugins/modals/plugin-contribution-list.html',
        scope : {
            pluginContent : '='
        }
    };
});


app.directive('checkNewPluginIdUnique', function() {
    return {
        require: 'ngModel',
        scope : true,
        link: function(scope, elem, attrs, ngModel) {
            function apply_validation(value) {
                ngModel.$setValidity('uniqueness', true);
                // It is fake, but other check will get it.
                if (value == null || value.length === 0) return value;
                var valid = true;
                if(scope.uniquePluginIds) {
                	valid = scope.uniquePluginIds.indexOf(value) < 0;
                }
                ngModel.$setValidity('uniqueness', valid);
                return value;
            }
            //For DOM -> model validation
            ngModel.$parsers.unshift(apply_validation);

            //For model -> DOM validation
            ngModel.$formatters.unshift(function(value) {
                apply_validation(value);
                return value;
            });
        }
    };
});


app.controller("PluginController", function($scope, $controller, $state, $stateParams, DataikuAPI, CreateModalFromTemplate, SpinnerService, TopNav, Assert, FutureWatcher, WT1) {


    TopNav.setLocation(TopNav.DSS_HOME, 'plugin');

    $scope.pluginsUIState = $scope.pluginsUIState || {};

    $controller("PlugindevCommonController", { $scope: $scope });
    $scope.isInstallingOrUpdatingPlugin = function () {
        return $state.includes('plugin.installation') || $state.includes("plugin.installationfromgit") ||
               $state.includes('plugin.update') || $state.includes('plugin.upload') || $state.includes('plugin.upload.update') ||  $state.includes("plugin.updatefromgit")
    };


    $scope.pluginCanBeUninstalled = function() {
        if (!$scope.pluginData) return false;
        return ($scope.pluginData.installedDesc.origin !== 'BUILTIN')
            && ($scope.pluginData.installedDesc.origin !== 'DEV');
    }
    $scope.pluginCanBeMovedToDev = function() {
        if (!$scope.pluginData) return false;
        return $scope.pluginData.installedDesc.origin != 'BUILTIN';
    };

    $scope.pluginCanBeUpdated = function() {
        if (!$scope.pluginData || !$scope.pluginData.storeDesc) return false;
        return $scope.pluginData.storeDesc.storeFlags.downloadable === true;
    };

    $scope.moveToDev = function() {
        CreateModalFromTemplate("/templates/plugins/modals/move-plugin-to-dev.html", $scope, null, function(modalScope) {
            modalScope.go = function() {
                const pluginId = $scope.pluginData.installedDesc.desc.id;
                SpinnerService.lockOnPromise(DataikuAPI.plugins.moveToDev(pluginId)
                    .success(function (data) {
                        if (!data.success){
                            $scope.installationError = data.installationError;
                        } else {
                            $state.transitionTo('plugindev.definition', {pluginId});
                        }
                    }).error(setErrorInScope.bind($scope)));
            };
        });
    };

    $scope.getPlugin = function() {
        DataikuAPI.plugins.get($stateParams.pluginId).then(
            function (data) {
                $scope.pluginData = data.data;
                $scope.initContentTypeList($scope.pluginData);
            },
            setErrorInScope.bind($scope)
        );
    };

    $scope.previewUninstallPlugin = function() {
        Assert.trueish($scope.pluginData.installedDesc.origin !== 'BUILTIN', "Plugin is BUILTIN");
        Assert.trueish($scope.pluginData.installedDesc.origin !== 'DEV', "Plugin is DEV");
        var handlePluginDeleted = function(pluginId) {
            WT1.event("plugin-delete", { pluginId : pluginId });
            $state.transitionTo('plugins.installed');
        }
        var handlePluginDeletionFailed = function(data, status, headers) {
            $scope.state = "FAILED";
            $scope.failure = {
                message: getErrorDetails(data, status, headers).detailedMessage
            }
        }

        CreateModalFromTemplate("/templates/plugins/modals/uninstall-plugin-confirm.html", $scope, null, function(newScope) {
            const pluginId = $scope.pluginData.installedDesc.desc.id;
            DataikuAPI.plugins.prepareDelete(pluginId).success(function(usageStatistics) {
                newScope.pluginName = $scope.pluginData.installedDesc.desc.meta.label;
                newScope.usageStatistics = usageStatistics;
                newScope.confirmPluginUninstall = function() {
                    DataikuAPI.plugins.delete(pluginId, true).success(function(initialResponse) {
                        if (initialResponse && initialResponse.jobId && !initialResponse.hasResult) {                        
                            FutureWatcher.watchJobId(initialResponse.jobId).success(function() {
                                handlePluginDeleted(pluginId);
                            }).error(handlePluginDeletionFailed);
                        } else {
                            handlePluginDeleted(pluginId);
                        }
                    }).error(handlePluginDeletionFailed);
                }
            });
        });
    };

    $scope.validatePluginEnv = function() {
        $scope.pluginEnvUpToDate = true;
    };

    $scope.invalidatePluginEnv = function() {
        $scope.pluginEnvUpToDate = false;
    };

    if ($scope.isInstallingOrUpdatingPlugin()) {
        $scope.pluginLabel = $stateParams.pluginId;
    }

    if (!$scope.isInstallingOrUpdatingPlugin()) {
        $scope.getPlugin();
    }
});


app.controller("PluginSummaryController", function ($scope, $filter) {

    $scope.filterQuery = { userQuery: '' };
    $scope.filteredContent = {};

    function filterContent(pluginInstallDesc) {
        let filteredContent = {};
        let types = $scope.getComponentsTypeList(pluginInstallDesc);
        types.forEach(function(type) {
            let filteredComponents = $filter('filter')(pluginInstallDesc.content[type], $scope.filterQuery.userQuery);
            if (filteredComponents.length) {
                filteredContent[type] = filteredComponents;
            }
        });
        // Add feature flags as "fake components"
        if (pluginInstallDesc.desc.featureFlags) {
            const matchingFeatureFlag = $filter('filter')(pluginInstallDesc.desc.featureFlags, $scope.filterQuery.userQuery);
            if (matchingFeatureFlag.length > 0) {
                filteredContent['featureFlags'] = $filter('filter')(pluginInstallDesc.desc.featureFlags, $scope.filterQuery.userQuery);
                // Put in the same format as other components for simpler templates
                filteredContent['featureFlags'] = filteredContent['featureFlags'].map(featureFlag => ({ id: featureFlag }));
            }
        }
        return filteredContent;
    }

    function filterContentOnChange() {
        let pluginData = $scope.pluginData;

        if (pluginData && pluginData.installedDesc.content) {
            $scope.filteredContent = filterContent(pluginData.installedDesc);
        } else {
            $scope.filteredContent = {};
        }
    }

    $scope.$watch('pluginData', filterContentOnChange, true);

    $scope.$watch('filterQuery.userQuery', filterContentOnChange, true);

    $scope.getComponentsTypeListFiltered = function() {
        return Object.keys($scope.filteredContent);
    };
});


app.controller("PluginSettingsController", function ($scope, PluginConfigUtils, DataikuAPI, WT1, $stateParams, CreateModalFromTemplate, Dialogs) {

    $scope.pluginsUIState = $scope.pluginsUIState || {};
    $scope.pluginsUIState.settingsPane = $stateParams.selectedTab || 'parameters';

    $scope.hooks = {};

    $scope.setPluginSettings = function (settings) {
        $scope.originalPluginSettings = settings;
        $scope.pluginSettings = angular.copy($scope.originalPluginSettings);
        if ($scope.hooks.settingsSet) {
            $scope.hooks.settingsSet();
        }
    }

    function refreshPluginDesc() {

        if (!$stateParams.pluginId || $scope.installed) {
            return;
        }
        DataikuAPI.plugins.get($stateParams.pluginId, $scope.projectKey).success(function(data) {
            $scope.installed = data.installedDesc;

            if ($scope.installed.desc.params && data.settings.config) {
                PluginConfigUtils.setDefaultValues($scope.installed.desc.params, data.settings.config);
            }
            $scope.setPluginSettings(data.settings);
        }).error(setErrorInScope.bind($scope));
    }

    refreshPluginDesc();

    // Provide a project key to save params at project-level. Defaulty saving at global level
    $scope.savePluginSettings = function(projectKey) {
        DataikuAPI.plugins.saveSettings($scope.pluginData.installedDesc.desc.id, projectKey, $scope.pluginSettings).success(function(data) {

            if (data.error) {
                Dialogs.infoMessagesDisplayOnly($scope, "Update result", data);
            } else {
                // make sure dirtyPluginSettings says it's ok to avoid checkChangesBeforeLeaving complaining
                $scope.originalPluginSettings = angular.copy($scope.pluginSettings);
                $scope.pluginData.settings = $scope.originalPluginSettings;
                WT1.event("plugin-settings-changed", { pluginId : $scope.pluginData.installedDesc.desc.id });
            }
        }).error(setErrorInScope.bind($scope));

    };

    $scope.getParameterSetDesc = function(type) {
        return $scope.installed.customParameterSets.filter(function(parameterSetDesc) {return parameterSetDesc.elementType == type;})[0];
    };

    $scope.getAppTemplateDesc = function(type) {
        return $scope.installed.customAppTemplates.filter(function(appTemplateDesc) {return appTemplateDesc.elementType == type;})[0];
    };

    $scope.deletePreset = function(preset) {
        let index = $scope.pluginSettings.presets.indexOf(preset);
        if (index >= 0) {
            $scope.pluginSettings.presets.splice(index, 1);
        }
    };

    $scope.createPreset = function() {
        CreateModalFromTemplate("/templates/plugins/modals/new-preset.html", $scope, "NewPresetController");
    };

    $scope.dirtyPluginSettings = function() {
        return ($scope.originalPluginSettings !== null && !angular.equals($scope.originalPluginSettings, $scope.pluginSettings));
    };

    $scope.$watch("pluginData", function(nv) {
        if (nv && $scope.pluginData && $scope.pluginData.installedDesc.desc && $scope.pluginData.installedDesc.desc.params) {
            PluginConfigUtils.setDefaultValues($scope.pluginData.installedDesc.desc.params, $scope.pluginData.settings.config);
            $scope.pluginSettings = angular.copy($scope.pluginData.settings);
        }
    });


    $scope.presetsByParameterSet = {};
    $scope.hooks.settingsSet = function() {
        $scope.presetsByParameterSet = {};
        $scope.pluginSettings.parameterSets.forEach(function(parameterSet) {$scope.presetsByParameterSet[parameterSet.name] = [];});
        $scope.pluginSettings.presets.forEach(function(preset) {
            let parameterSet = $scope.pluginSettings.parameterSets.filter(function(parameterSet) {return parameterSet.type == preset.type;})[0];
            if (parameterSet) {
                $scope.presetsByParameterSet[parameterSet.name].push(preset);
            }
        });
    };

    checkChangesBeforeLeaving($scope, $scope.dirtyPluginSettings);
});


app.controller("PluginUsagesController", function ($scope, DataikuAPI, StateUtils) {
    $scope.getUsages = function(projectKey) {
        DataikuAPI.plugins.getUsages($scope.pluginData.installedDesc.desc.id, projectKey).success(function(data) {
            $scope.pluginUsages = data;
            $scope.pluginUsages.columns = ['Kind', 'Component', 'Type', 'Project', 'Object'];
            $scope.pluginUsages.columnWidths = [50, 100, 50, 100, 100];
            $scope.pluginUsages.shownHeight = 10 + 25 * (1 + Math.min(10, $scope.pluginUsages.usages.length));
        }).error(setErrorInScope.bind($scope));
    };

    $scope.computeUsageLink = function(usage) {
        return StateUtils.href.dssObject(usage.objectType.toUpperCase(), usage.objectId, usage.projectKey);
    }
});


app.directive('pluginRequirements', function(DataikuAPI, $rootScope, Dialogs, MonoFuture, WT1) {
    return {
        restrict : 'A',
        templateUrl : '/templates/plugins/plugin-requirements.html',
        scope : {
            pluginDesc: '=',
            settings: '=',
            onValid: '=',
            onInvalid: '='
        },
        link : function($scope, element, attrs) {
            $scope.appConfig = $rootScope.appConfig;

            $scope.checkValidity = function() {
                if (!$scope.onValid && !$scope.onInvalid) {
                    return;
                }

                const codeEnvOk = !$scope.pluginDesc.frontendRequirements.codeEnvLanguage || $scope.settings.codeEnvName !== undefined;
                const pythonDepsOK = $scope.pluginDesc.frontendRequirements.pythonPackages.length === 0 || $scope.pluginDesc.frontendRequirements.pythonInstalled;
                const rDepsOk = $scope.pluginDesc.frontendRequirements.rPackages.length === 0 || $scope.pluginDesc.frontendRequirements.rInstalled;
                const customInstallOk = !$scope.pluginDesc.frontendRequirements.installScriptCommand || $scope.pluginDesc.frontendRequirements.customInstalled;

                if (codeEnvOk && pythonDepsOK && rDepsOk && customInstallOk) {
                    $scope.onValid && $scope.onValid();
                } else {
                    $scope.onInvalid && $scope.onInvalid();
                }
            }

            $scope.useCodeEnv = function(envName) {
                DataikuAPI.plugins.useCodeEnv($scope.pluginDesc.desc.id, envName).success(function(data) {
                    WT1.event("plugin-settings-changed", { pluginId : $scope.pluginId });
                    $scope.settings.codeEnvName = envName;
                    $scope.checkValidity();
                }).error(function() {
                    setErrorInScope.call($scope);
                    $scope.onInvalid && $scope.onInvalid();
                });
            };

            $scope.codeEnvs = [];
            if ($scope.pluginDesc.codeEnvLang) {
                // otherwise none of this is needed
                $scope.listCodeEnvs = function() {
                    DataikuAPI.codeenvs.listForPlugins($scope.pluginDesc.desc.id).success(function(data) {
                        $scope.codeEnvs = data;
                        $scope.checkValidity();
                    }).error(function() {
                        setErrorInScope.call($scope);
                        $scope.onInvalid && $scope.onInvalid();
                    });
                };
                $scope.listCodeEnvs();
            }


            $scope.installingFuture = null;
            function go(type){
                $scope.failure = null;
                $scope.installationLog = null;
                $scope.installationResult = null;
                MonoFuture($scope).wrap(DataikuAPI.plugins.installRequirements)($scope.pluginDesc.desc.id, type).success(function(data) {
                    $scope.state = data.result.success ? "DONE" : "FAILED";
                    WT1.event("plugin-requirement-install", {success : $scope.state, type: type});
                    $scope.installationResult = data.result;
                    $scope.installationLog = data.log;
                    $scope.installingFuture = null;

                    if (data.result.success) {
                        $scope.pluginDesc.frontendRequirements.pythonInstalled = $scope.pluginDesc.frontendRequirements.pythonInstalled || type == 'PYTHON';
                        $scope.pluginDesc.frontendRequirements.rInstalled = $scope.pluginDesc.frontendRequirements.rInstalled || type == 'R';
                        $scope.pluginDesc.frontendRequirements.customInstalled = $scope.pluginDesc.frontendRequirements.customInstalled || type == 'CUSTOM_SCRIPT';
                        $scope.checkValidity();
                    } else {
                        $scope.onInvalid && $scope.onInvalid();
                    }
                }).update(function(data) {
                    $scope.state = "RUNNING";
                    $scope.installingFuture = data;
                    $scope.installationLog = data.log;
                }).error(function (data, status, headers) {
                    $scope.state = "FAILED";
                    if (data.aborted) {
                        $scope.failure = {
                            message: "Aborted"
                        }
                    } else if (data.hasResult) {
                        $scope.installationResult = data.result;
                    } else {
                        $scope.failure = {
                            message: "Unexpected error"
                        }
                    }
                    $scope.installingFuture = null;
                    $scope.onInvalid && $scope.onInvalid();
                });
            }

            $scope.abort = function() {
                $scope.state = "FAILED";
                $scope.failure = {
                    message: "Aborted"
                }
                DataikuAPI.futures.abort($scope.installingFuture.jobId);
                $scope.onInvalid && $scope.onInvalid();
            };

            $scope.installRequirements = function(type) {
                var message = '';
                if ($scope.pluginDesc.frontendRequirements.disclaimer) {
                    message = $scope.pluginDesc.frontendRequirements.disclaimer;
                } else {
                    let envType = '';
                    if (type == 'PYTHON') envType = 'the Python environment on ';
                    if (type == 'R') envType = 'the R environment on ';
                    if (type == 'CUSTOM_SCRIPT') envType = '';
                    message = 'This operation will alter the setup of ' + envType + 'the machine running the DSS server, and cannot be reverted.';
                }
                Dialogs.confirmDisclaimer($scope,'Dependencies installation', 'Are you sure you want to install these dependencies?', message).then(function() {
                    go(type);
                });
            };

            $scope.checkValidity();
        }
    };
});


app.directive('pluginCodeEnv', function(DataikuAPI, Dialogs, WT1, FutureProgressModal, $rootScope) {
    return {
        restrict : 'A',
        templateUrl : '/templates/plugins/modals/plugin-code-env.html',
        scope : {
            pluginDesc : '=',
            settings : '=',
            onValid: '=',
            onInvalid: '='
        },
        link : function($scope, element, attrs) {
            $scope.uiState = {
                state: "DISPLAY"
            }

            $scope.addLicInfo = $rootScope.addLicInfo;

            $scope.newEnv = {
                deploymentMode: 'PLUGIN_MANAGED', pythonInterpreter: 'PYTHON27',
                allContainerConfs: false, containerConfs : [],
                allSparkKubernetesConfs: false, sparkKubernetesConfs : []
            };

            $scope.useCodeEnv = function(envName, nextState) {
                DataikuAPI.plugins.useCodeEnv($scope.pluginDesc.desc.id, envName).success(function(data) {
                    WT1.event("plugin-settings-changed", { pluginId : $scope.pluginDesc.desc.id });
                    $scope.settings.codeEnvName = envName;
                    $scope.uiState.state = nextState || 'DISPLAY';
                    $scope.onValid && $scope.onValid();
                }).error(function() {
                    $scope.onInvalid && $scope.onInvalid();
                    setErrorInScope.call($scope);
                });
            };

            $scope.containerNames = [];
            DataikuAPI.containers.listNames().success(function(data){
                $scope.containerNames = data;
            }).error(function () {
                $scope.onInvalid && $scope.onInvalid();
                setErrorInScope.call($scope);
            });
            $scope.sparkKubernetesNames = [];
            DataikuAPI.containers.listSparkNames().success(function(data){
                $scope.sparkKubernetesNames = data;
            }).error(function () {
                $scope.onInvalid && $scope.onInvalid();
                setErrorInScope.call($scope);
            });

            $scope.codeEnvs = [];
            $scope.listCodeEnvs = function() {
                DataikuAPI.codeenvs.listForPlugins($scope.pluginDesc.desc.id).success(function(data) {
                    $scope.codeEnvs = data;
                    if (!$scope.settings.codeEnvName && $scope.codeEnvs.length) {
                        $scope.uiState.state = "SELECT";
                    } else if (!$scope.settings.codeEnvName) {
                        $scope.uiState.state = "CREATE";
                    }
                }).error(function () {
                    $scope.onInvalid && $scope.onInvalid();
                    setErrorInScope.call($scope);
                });
            };
            $scope.listCodeEnvs();

            $scope.isCurrentSelectedEnvUpToDate = function() {
                if (!$scope.settings.codeEnvName) return true;
                var env = $scope.codeEnvs.filter(function(e) {return e.envName == $scope.settings.codeEnvName;})[0];
                if (env == null) return true;
                return env.isUptodate;
            };

            $scope.codeEnvDeploymentModes = [
                ['PLUGIN_MANAGED', "Managed by DSS (recommended)"],
                ['PLUGIN_NON_MANAGED', "Managed manually"]
            ];
            $scope.possiblePythonInterpreters = [];
            if ($scope.pluginDesc.codeEnvSpec) {
                const codeEnvSpec = $scope.pluginDesc.codeEnvSpec;
                if (!codeEnvSpec.forceConda) {
                    $scope.possiblePythonInterpreters = $scope.possiblePythonInterpreters.concat(['CUSTOM']);
                }
                if (codeEnvSpec.acceptedPythonInterpreters && codeEnvSpec.acceptedPythonInterpreters.length > 0) {
                    $scope.possiblePythonInterpreters = $scope.possiblePythonInterpreters.concat(codeEnvSpec.acceptedPythonInterpreters);
                    $scope.newEnv.pythonInterpreter = codeEnvSpec.acceptedPythonInterpreters[0];
                }
            }
            $scope.buildNewCodeEnv = function(newEnv) {
                DataikuAPI.codeenvs.createForPlugin($scope.pluginDesc.desc.id, newEnv).success(function(data) {
                    FutureProgressModal.show($scope, data, "Environment creation", undefined, 'static', false, true).then(function(result){
                        Dialogs.infoMessagesDisplayOnly($scope, "Creation result", result.messages, result.futureLog, undefined, 'static', false);
                        $scope.listCodeEnvs();
                        if (result.envName) {
                            $scope.useCodeEnv(result.envName);
                            $scope.onValid && $scope.onValid();
                        }
                        if (result.messages.error) {
                            $scope.onInvalid && $scope.onInvalid();
                        }
                    });
                }).error(function () {
                    $scope.onInvalid && $scope.onInvalid();
                    setErrorInScope.call($scope);
                });
            };
            $scope.updateCodeEnv = function(envName) {
                DataikuAPI.codeenvs.updateForPlugin($scope.pluginDesc.desc.id, envName).success(function(data) {
                    FutureProgressModal.show($scope, data, "Environment update").then(function(result){
                        Dialogs.infoMessagesDisplayOnly($scope, "Update result", result.messages, result.futureLog);
                        $scope.listCodeEnvs();
                    });
                }).error(function () {
                    $scope.onInvalid && $scope.onInvalid();
                    setErrorInScope.call($scope);
                });
            };
        }
    };
});


app.controller("PluginsExploreController", function ($rootScope, $scope, $controller, DataikuAPI, $state, Assert, CreateModalFromTemplate, WT1, TopNav, FutureWatcher, FutureProgressModal, Dialogs) {
    $controller("PlugindevCommonController", { $scope: $scope });

    TopNav.setLocation(TopNav.DSS_HOME, 'plugins');

    $scope.pluginsUIState = {
        filteredStorePlugins: {},
        filteredInstalledPlugins: {},
        filteredDevelopmentPlugins: {},
        searchQuery: '',
        storeTags: new Map(),
        storeTagsQuery: [],
        storeInstallationStatusQuery: [],
        installedTags: new Map(),
        installedTagsQuery: [],
        developmentTags: new Map(),
        developmentTagsQuery: [],
        showAllStoreTags: false,
        showAllInstalledTags: false,
        showAllDevelopmentTags: false,
        storeSupportLevelQuery: [],
        installedSupportLevelQuery: [],
        storeInstallationStatusCount: new Map(),
        storeSupportLevelsCount: new Map(),
        installedSupportLevelsCount: new Map()
    };

    $scope.pluginsUIState.supportLevels = [
        {
            value: 'SUPPORTED',
            label: 'Supported',
            icon: 'icon-dku-supported'
        },
        {
            value: 'TIER2_SUPPORT',
            label: 'Tier 2 Support',
            icon: 'icon-dku-half-supported'
        }
    ];

    $scope.uploadedPlugin = {
        isUpdate: false
    };

    $scope.clonePlugin = {
        devMode: false,
        bootstrapMode: "GIT_CLONE",
        path: null,
        customCheckout: true,
    };

    function toggleShowAllTags(tab) {
        $scope.pluginsUIState['showAll' + tab + 'Tags'] = !$scope.pluginsUIState['showAll' + tab + 'Tags'];
    }

    $scope.toggleShowAllStoreTags = toggleShowAllTags.bind(this, 'Store');
    $scope.toggleShowAllInstalledTags = toggleShowAllTags.bind(this, 'Installed');
    $scope.toggleShowAllDevelopmentTags = toggleShowAllTags.bind(this, 'Development');

    /*
     *  Accessible either from the preview installation modal or directly from a plugin card in the store
     */
    $scope.installPlugin = function(pluginToInstall, isUpdate) {

        if ($rootScope.appConfig.admin && pluginToInstall) {

            if (isUpdate === true) {
                $state.transitionTo('plugin.update', {
                    pluginId: pluginToInstall.id
                });
            } else {
                $state.transitionTo('plugin.installation', {
                    pluginId: pluginToInstall.id
                });
            }
            $scope.dismiss && $scope.dismiss();
        }
    };

    $scope.triggerRestart = function() {
        DataikuAPI.plugins.triggerRestart().success(function(data) {
            // 'disconnected' will be shown while the backend restarts
        }).error(function() {
            // this is expected, if the backend dies fast enough and doesn't send the response back
        });
    };

    $scope.getStoreSupportLevelCount = function(supportLevelValue) {
        return $scope.pluginsUIState.storeSupportLevelsCount.get(supportLevelValue) || 0;
    }

    $scope.getInstalledSupportLevelCount = function(supportLevelValue) {
        return $scope.pluginsUIState.installedSupportLevelsCount.get(supportLevelValue) || 0;
    }

    $scope.toggleStoreInstallationStatusFilter = function(installationStatus, event) {
        const installationStatusQuery = $scope.pluginsUIState.storeInstallationStatusQuery;
        const statusPosition = installationStatusQuery.indexOf(installationStatus);

        if (statusPosition > -1) {
            installationStatusQuery.splice(statusPosition, 1);
        } else {
            if (installationStatusQuery.length > 0) {
                installationStatusQuery.splice(0, 1);
                event.preventDefault();
            } else {
                installationStatusQuery.push(installationStatus);
            }
        }
    }

    $scope.isStoreInstallationStatusSelected = function(installationStatus) {
        return $scope.pluginsUIState.storeInstallationStatusQuery.includes(installationStatus);
    }

    $scope.getStoreInstallationStatusCount = function(installationStatus) {
            return $scope.pluginsUIState.storeInstallationStatusCount.get(installationStatus) || 0;
        }


    function toggleSupportFilter(supportLevel, tab) {
        const supportLevelQuery = $scope.pluginsUIState[tab + 'SupportLevelQuery'];
        let supportLevelPosition = supportLevelQuery.indexOf(supportLevel);

        if (supportLevelPosition > -1) {
            supportLevelQuery.splice(supportLevelPosition, 1);
        } else {
            supportLevelQuery.push(supportLevel);
        }
    }

    $scope.toggleStoreSupportFilter = function(supportLevel) {
        toggleSupportFilter(supportLevel, 'store');
    }

    $scope.toggleInstalledSupportFilter = function(supportLevel) {
        toggleSupportFilter(supportLevel, 'installed');
    }

    $scope.isStoreSupportLevelSelected = function (supportName) {
        return $scope.pluginsUIState.storeSupportLevelQuery.includes(supportName);
    }

    $scope.isInstalledSupportLevelSelected = function (supportName) {
        return $scope.pluginsUIState.installedSupportLevelQuery.includes(supportName);
    }

    function toggleTagQuery(tagName, tab) {
        const tagsQuery = $scope.pluginsUIState[tab + 'TagsQuery'];
        const tagPosition = tagsQuery.indexOf(tagName);

        if (tagPosition > -1) {
            tagsQuery.splice(tagPosition, 1);
        } else {
            tagsQuery.push(tagName);
        }
    }

    $scope.toggleStoreTagQuery = function(tagName) {
        toggleTagQuery(tagName, 'store');
    };

    $scope.toggleInstalledTagQuery = function(tagName) {
        toggleTagQuery(tagName, 'installed');
    };

    $scope.toggleDevelopmentTagQuery = function(tagName) {
        toggleTagQuery(tagName, 'development');
    };

    $scope.isStoreTagSelected = function (tagName) {
        return $scope.pluginsUIState.storeTagsQuery.includes(tagName);
    }

    $scope.isInstalledTagSelected = function (tagName) {
        return $scope.pluginsUIState.installedTagsQuery.includes(tagName);
    }

    $scope.isDevelopmentTagSelected = function (tagName) {
        return $scope.pluginsUIState.developmentTagsQuery.includes(tagName);
    }

    $scope.resetStoreInstallationStatusQuery = function() {
        $scope.pluginsUIState.storeInstallationStatusQuery = [];
    }

    function resetTagsQuery(tab) {
        $scope.pluginsUIState[tab + 'TagsQuery'] = [];
    }

    $scope.resetStoreTagsQuery = function() {
        resetTagsQuery('store');
    };

    $scope.resetInstalledTagsQuery = function() {
        resetTagsQuery('installed');
    };

    $scope.resetDevelopmentTagsQuery = function() {
        resetTagsQuery('development');
    };

    function resetSupportLevelQuery(tab) {
        $scope.pluginsUIState[tab + 'SupportLevelQuery'] = [];
    }

    $scope.resetStoreSupportLevelQuery = function() {
        resetSupportLevelQuery('store');
    };

    $scope.resetInstalledSupportLevelQuery = function() {
        resetSupportLevelQuery('installed');
    };

    $scope.resetStoreQuery = function() {
        $scope.resetStoreTagsQuery();
        $scope.resetStoreSupportLevelQuery();
        $scope.pluginsUIState.searchQuery = '';
    };

    $scope.resetInstalledQuery = function() {
        $scope.resetInstalledTagsQuery();
        $scope.resetInstalledSupportLevelQuery();
        $scope.pluginsUIState.searchQuery = '';
    };

    $scope.resetDevelopmentQuery = function() {
        $scope.resetDevelopmentTagsQuery();
        $scope.pluginsUIState.searchQuery = '';
    };

    $scope.reloadAllPlugins = function() {
        Dialogs.confirmSimple($scope, 'Reload all plugins?').then(function() {
            DataikuAPI.plugindev.reloadAll()
                .success(_ => $scope.refreshList())
                .error(setErrorInScope.bind($scope));
        });
    };

    function filterPluginsByInstallationStatus() {
        return function(plugin) {
            const installationStatusList = $scope.pluginsUIState.storeInstallationStatusQuery;
            const hasUserFiltered = installationStatusList && installationStatusList.length > 0;

            // No filter checks: show the plugin.
            if (!hasUserFiltered) {
                return true;
            }

            // Else check if the plugin has one of the checked installation status.
            return installationStatusList.includes(plugin.installed);
        }
    }

    $scope.filterStorePluginsByInstallationStatus = filterPluginsByInstallationStatus.bind(this);

    function filterPluginsBySupportLevel(tab, supportKey) {
        return function(plugin) {
            const supportList = $scope.pluginsUIState[tab + 'SupportLevelQuery'];
            const pluginSupportLevel = resolveValue(plugin, supportKey); // from utils.js
            const hasUserFiltered = supportList && supportList.length > 0;
            const hasSupportLevel = pluginSupportLevel && pluginSupportLevel.length >= 0;

            // No filter checks: show the plugin.
            if (!hasUserFiltered) {
                return true;
            }

            // Plugin has no "support" field (and some support level filters are checked): don't show.
            if (!hasSupportLevel) {
                return false;
            }

            // Else check if the plugin has one of the checked support filter.
            return supportList.includes(pluginSupportLevel);
        };
    }

    $scope.filterStorePluginsBySupportLevel = filterPluginsBySupportLevel.bind(this, 'store', 'storeDesc.meta.supportLevel');
    $scope.filterInstalledPluginsBySupportLevel = filterPluginsBySupportLevel.bind(this, 'installed', 'installedDesc.desc.meta.supportLevel');

    function filterPluginsByTags(tab, tagsKey) {
        return function(plugin) {

            const tagsList = $scope.pluginsUIState[tab + 'TagsQuery'];
            const pluginTags = resolveValue(plugin, tagsKey);
            const hasUserFiltered = tagsList && tagsList.length > 0;
            const hasTags = pluginTags && pluginTags.length > 0;

            // No tags checks : show the plugin
            if (!hasUserFiltered) {
                return true;
            }

            // Plugin has no tag (and some tags are checked) : don't show
            if (!hasTags) {
                return false;
            }

            // Else check if the plugin has one of the checked tags
            let containsATag = false;

            pluginTags.forEach(tag => {
                // Prevent duplicates like "Time series" and "Time Series"
                tag = tag.split(' ').map(word => { return word.charAt(0).toUpperCase() + word.slice(1); }).join(' ');

                if (tagsList.includes(tag)) {
                    containsATag = true;
                }
            });

            return containsATag;
        };
    }

    $scope.filterStorePluginsByTags = filterPluginsByTags.bind(this, 'store', 'storeDesc.meta.tags');
    $scope.filterInstalledPluginsByTags = filterPluginsByTags.bind(this, 'installed', 'installedDesc.desc.meta.tags');
    $scope.filterDevelopmentPluginsByTags = filterPluginsByTags.bind(this, 'development', 'installedDesc.desc.meta.tags');

    $scope.hasNoResultsForStoreQuery = function() {
        const isListEmpty = $scope.pluginsUIState.filteredStorePlugins && $scope.pluginsUIState.filteredStorePlugins.length === 0;
        const hasSearched = $scope.pluginsUIState.searchQuery && $scope.pluginsUIState.searchQuery.length;
        const hasFilteredTags = $scope.pluginsUIState.storeTagsQuery && $scope.pluginsUIState.storeTagsQuery.length;
        const hasFilteredSupport = $scope.pluginsUIState.storeSupportLevelQuery && $scope.pluginsUIState.storeSupportLevelQuery.length;
        const hasFiltered = hasSearched || hasFilteredTags || hasFilteredSupport;

        return isListEmpty && hasFiltered;
    }

    $scope.hasNoResultsForInstalledQuery = function() {
        const isListEmpty = $scope.pluginsUIState.filteredInstalledPlugins && $scope.pluginsUIState.filteredInstalledPlugins.length === 0;
        const hasSearched = $scope.pluginsUIState.searchQuery && $scope.pluginsUIState.searchQuery.length;
        const hasFilteredTags = $scope.pluginsUIState.installedTagsQuery && $scope.pluginsUIState.installedTagsQuery.length;
        const hasFilteredSupport = $scope.pluginsUIState.installedSupportLevelQuery && $scope.pluginsUIState.installedSupportLevelQuery.length;
        const hasFiltered = hasSearched || hasFilteredTags || hasFilteredSupport;

        return isListEmpty && hasFiltered;
    }

    $scope.computePluginOrigin = function(plugin) {
        let origin = '';

        if (plugin.inStore === true) {
            origin = 'Store';
        } else if (plugin.installedDesc.origin) {
            if (plugin.installedDesc.origin === 'INSTALLED') {
                if (plugin.installedDesc.gitState.enabled === true) {
                    origin = 'Git repository';
                } else {
                    origin = 'Uploaded';
                }
            } else if (plugin.installedDesc.origin === 'DEV') {
                origin = 'Local dev';
            } else {
                origin = plugin.installedDesc.origin;
            }
        } else {
            origin = plugin.installedDesc.origin;
        }

        return origin;
    };

    $scope.refreshTags = function() {
        $scope.pluginsUIState.storeTags.clear()
        $scope.pluginsUIState.installedTags.clear()
        $scope.pluginsUIState.developmentTags.clear()
        $scope.pluginsUIState.storeSupportLevelsCount.clear();
        $scope.pluginsUIState.installedSupportLevelsCount.clear();
        $scope.pluginsUIState.storeInstallationStatusCount.clear();

        $scope.pluginsList.plugins.forEach(plugin => {
            if (plugin.storeDesc) {
                if ($scope.pluginsUIState.storeInstallationStatusCount.has(plugin.installed)) {
                    $scope.pluginsUIState.storeInstallationStatusCount.set(plugin.installed, $scope.pluginsUIState.storeInstallationStatusCount.get(plugin.installed) + 1);
                } else {
                    $scope.pluginsUIState.storeInstallationStatusCount.set(plugin.installed, 1);
                }

                const supportLevelValue = plugin.storeDesc.meta && plugin.storeDesc.meta.supportLevel;
                if (supportLevelValue) {
                    if ($scope.pluginsUIState.storeSupportLevelsCount.has(supportLevelValue)) {
                        $scope.pluginsUIState.storeSupportLevelsCount.set(supportLevelValue, $scope.pluginsUIState.storeSupportLevelsCount.get(supportLevelValue) + 1);
                    } else {
                        $scope.pluginsUIState.storeSupportLevelsCount.set(supportLevelValue, 1);
                    }
                }

                plugin.storeDesc.meta && plugin.storeDesc.meta.tags && plugin.storeDesc.meta.tags.forEach(tag => {
                    // Prevent duplicates like "Time series" and "Time Series"
                    tag = tag.split(' ').map(word => { return word.charAt(0).toUpperCase() + word.slice(1); }).join(' ');

                    if ($scope.pluginsUIState.storeTags.has(tag)) {
                        $scope.pluginsUIState.storeTags.set(tag, $scope.pluginsUIState.storeTags.get(tag) + 1);
                    } else {
                        $scope.pluginsUIState.storeTags.set(tag, 1);
                    }
                });
            }

            if (plugin.installedDesc) {

                const supportLevelValue = plugin.installedDesc.desc.meta && plugin.installedDesc.desc.meta.supportLevel;

                if (supportLevelValue) {
                    if ($scope.pluginsUIState.installedSupportLevelsCount.has(supportLevelValue)) {
                        $scope.pluginsUIState.installedSupportLevelsCount.set(supportLevelValue, $scope.pluginsUIState.installedSupportLevelsCount.get(supportLevelValue) + 1);
                    } else {
                        $scope.pluginsUIState.installedSupportLevelsCount.set(supportLevelValue, 1);
                    }
                }

                plugin.installedDesc.desc.meta && plugin.installedDesc.desc.meta.tags && plugin.installedDesc.desc.meta.tags.forEach(tag => {
                    // Prevent duplicates like "Time series" and "Time Series"
                    tag = tag.split(' ').map(word => { return word.charAt(0).toUpperCase() + word.slice(1); }).join(' ');

                    if ($scope.pluginsUIState.installedTags.has(tag)) {
                        $scope.pluginsUIState.installedTags.set(tag, $scope.pluginsUIState.installedTags.get(tag) + 1);
                    } else {
                        $scope.pluginsUIState.installedTags.set(tag, 1);
                    }

                    if (plugin.installedDesc.origin === 'DEV') {
                        if ($scope.pluginsUIState.developmentTags.has(tag)) {
                            $scope.pluginsUIState.developmentTags.set(tag, $scope.pluginsUIState.developmentTags.get(tag) + 1);
                        } else {
                            $scope.pluginsUIState.developmentTags.set(tag, 1);
                        }
                    }
                });
            }
        });

        // Sort by descending quantity
        $scope.pluginsUIState.storeTags = new Map([...$scope.pluginsUIState.storeTags.entries()].sort((a, b) => b[1] - a[1]));
        $scope.pluginsUIState.installedTags = new Map([...$scope.pluginsUIState.installedTags.entries()].sort((a, b) => b[1] - a[1]));
        $scope.pluginsUIState.developmentTags = new Map([...$scope.pluginsUIState.developmentTags.entries()].sort((a, b) => b[1] - a[1]));
    };

    $scope.refreshList = function(forceFetch) {
        if ($scope.pluginsList && forceFetch === false) {
            return;
        }

        DataikuAPI.plugins.list(forceFetch).success(function(data) {
            $scope.pluginsList = data;

            $scope.refreshTags();

            $scope.pluginsUIState.storePluginsCount = 0;
            $scope.pluginsUIState.developedPluginsCount = 0;
            $scope.pluginsUIState.installedPluginsCount = 0;

            $scope.pluginsList.plugins.forEach(plugin => {
                if (plugin.storeDesc) {
                    $scope.pluginsUIState.storePluginsCount++;
                }

                if (plugin.installedDesc) {
                    $scope.pluginsUIState.installedPluginsCount++;
                    if (plugin.installedDesc.origin === 'DEV') {
                        $scope.pluginsUIState.developedPluginsCount++;
                    }
                    if ( (plugin.installedDesc.origin !== 'BUILTIN') && (plugin.installedDesc.origin !== 'DEV') ) {
                        plugin.uninstallable = true;
                    }
                }
                if (plugin.installed && plugin.installedDesc && plugin.storeDesc && plugin.storeDesc.storeFlags.downloadable === true && plugin.storeDesc.storeVersion && plugin.installedDesc.desc.version && plugin.storeDesc.storeVersion > plugin.installedDesc.desc.version) {
                    plugin.updateAvailable = true;
                }
            });

            const supportLevelMap = {SUPPORTED: 2, TIER2_SUPPORT: 1, NOT_SUPPORTED: 0, NONE: -1};
            function rank(plugin) {
                const updateAvailable = plugin.updateAvailable ? 1 : 0;
                const notInstalled = plugin.installed ? 0 : 1;
                const desc = plugin.storeDesc||{};
                const meta = desc.meta||{};
                const supportLevel = supportLevelMap[meta.supportLevel||'NONE'];
                return [updateAvailable, notInstalled, supportLevel];
            }
            $scope.pluginsList.plugins.sort((a,b) => rank(a) > rank(b) ? -1 : 1);
        }).error(setErrorInScope.bind($scope));
    };

    $scope.previewInstallStorePlugin = function(plugin) {
        Assert.trueish(plugin.inStore, "Plugin not in store");
        CreateModalFromTemplate("/templates/plugins/modals/plugin-install-preview.html", $scope, null, function(newScope) {
            newScope.attachDownloadTo = $scope;
            newScope.isUpdate = plugin.installed;
            if (plugin.installed) {
                newScope.installedVersion = plugin.installedDesc.desc.version;
            }
            newScope.uiState = { activeTab: 'details' };
            $scope.initContentTypeList(plugin);
            newScope.storePlugin = plugin.storeDesc;
            newScope.contentTypes = Object.keys(newScope.storePlugin.content);
        });
    };

    $scope.previewUninstallPlugin = function(plugin) {
        Assert.trueish(plugin.installedDesc.origin !== 'BUILTIN', "Plugin is BUILTIN");
        Assert.trueish(plugin.installedDesc.origin !== 'DEV', "Plugin is DEV");

        var handlePluginDeleted = function(pluginId) {
            WT1.event("plugin-delete", { pluginId : pluginId });
            $scope.reload();
        }

        var handlePluginDeletionFailed = function(data, status, headers) {
            WT1.event("plugin-delete", { pluginId : pluginId });
            $scope.reload();
        }


        CreateModalFromTemplate("/templates/plugins/modals/uninstall-plugin-confirm.html", $scope, null, function(newScope) {
            DataikuAPI.plugins.prepareDelete(plugin.id).success(function(usageStatistics) {
                newScope.pluginName = plugin.installedDesc.desc.meta.label;
                newScope.usageStatistics = usageStatistics;
                newScope.confirmPluginUninstall = function() {
                    DataikuAPI.plugins.delete(plugin.id, true).success(function(initialResponse) {
                        if (initialResponse && initialResponse.jobId && !initialResponse.hasResult) {                        
                            FutureWatcher.watchJobId(initialResponse.jobId).success(function() {
                                handlePluginDeleted(plugin.id);
                            }).error(handlePluginDeletionFailed);
                        } else {
                            handlePluginDeleted(plugin.id);
                        }
                    }).error(handlePluginDeletionFailed);
            }
            }).error(setErrorInScope.bind($scope));
    
        });
    };

    $scope.seePluginStoreDetails = function(plugin) {
        Assert.trueish(plugin.inStore, "Plugin not in store");
        $scope.uiState = { activeTab: 'details' };
        const modal = CreateModalFromTemplate("/templates/plugins/modals/plugin-see-details.html", $scope, null, function(newScope) {
            $state.go('plugins.store', Object.assign({}, $state.params, {pluginid: plugin.id}), { notify: false })
            newScope.attachDownloadTo = $scope;
            newScope.isUpdate = plugin.installed;
            if (plugin.installed) {
                newScope.installedVersion = plugin.installedDesc.desc.version;
            }
            $scope.initContentTypeList(plugin);
            $scope.plugin = plugin;
            newScope.storePlugin = plugin.storeDesc;
            newScope.contentTypes = Object.keys(newScope.storePlugin.content);
        });
        modal.catch(() => {
            $state.go('plugins.store', Object.assign({}, $state.params, {pluginid: null}), { notify: false });
        });
    };

    $scope.newZippedPlugin = function() {
        CreateModalFromTemplate('/templates/plugins/modals/new-plugin-from-desktop.html', $scope);
    };

    $scope.newGitPlugin = function() {
        CreateModalFromTemplate('/templates/plugins/modals/new-plugin-from-git.html', $scope);
    };

    $scope.newDevPlugin = function() {
        CreateModalFromTemplate("/templates/plugins/development/new-devplugin.html", $scope);
    };

    $scope.uploadPlugin = function(){
        if ($scope.uploadedPlugin.file && $scope.uploadedPlugin.file != '') {
            let fileName = $scope.uploadedPlugin.file.name;
            if ($scope.uploadedPlugin.isUpdate) {
                $state.transitionTo('plugin.upload.update', {
                    pluginId: fileName,
                    uploadedPluginFile: $scope.uploadedPlugin.file
                });
            } else {
                $state.transitionTo('plugin.upload', {
                    pluginId: fileName,
                    uploadedPluginFile: $scope.uploadedPlugin.file
                });
            }
        }
    };

    $scope.previewPullPlugin = function(plugin) {
        CreateModalFromTemplate("/templates/plugins/modals/plugin-preview-pull.html", $scope, null, function(newScope) {
            newScope.attachDownloadTo = $scope;
            if (plugin.installed) {
                newScope.installedVersion = plugin.installedDesc.desc.version;
            }
            newScope.gitPlugin = angular.copy(plugin.installedDesc);
            newScope.update = () => {
                $state.transitionTo('plugin.updatefromgit', {
                    uri: newScope.gitPlugin.gitState.repository,
                    checkout: newScope.gitPlugin.gitState.checkout,
                    path: newScope.gitPlugin.gitState.path
                });
            }
        });
    };

    $scope.cloneAndCreate = function() {
        if ($scope.clonePlugin.devMode) {
            DataikuAPI.plugindev.create('', $scope.clonePlugin.bootstrapMode, $scope.clonePlugin.uri,
                $scope.clonePlugin.checkout, $scope.clonePlugin.path).success(function(data) {
                FutureProgressModal.show($scope, data, "Creating plugin", undefined, 'static', false, true).then(function(result){
                    if (result) {
                        WT1.event("plugin-dev-create");
                        $scope.goToDevPluginDetails(result.details);
                    }
                });
            }).error(setErrorInScope.bind($scope));
        } else {
            $state.transitionTo("plugin.installationfromgit", {
                uri: $scope.clonePlugin.uri,
                checkout: $scope.clonePlugin.checkout,
                path: $scope.clonePlugin.path
            })
        }
    };

    $scope.reload = function(){
        location.reload();
    };

    $scope.refreshPluginLists = function() {
        $scope.refreshList(true);
    };

    $scope.goToPluginDetails = function (pluginId) {
        $state.transitionTo('plugin.summary', { pluginId: pluginId });
    }

    $scope.goToDevPluginDetails = function (pluginId) {
        $state.transitionTo('plugindev.definition', { pluginId: pluginId });
    }

    $scope.goToDevPluginEditor = function (pluginId) {
        $state.transitionTo('plugindev.editor', { pluginId: pluginId });
    }

    $scope.deletePluginAndReloadPage = function (pluginId) {
        $scope.deletePlugin(pluginId, $scope.reload);
    }

    // shortcut to force the list refresh
    Mousetrap.bind("r l", function() {
        $scope.refreshList(true);
    });

    $scope.$on("$destroy", function() {
        Mousetrap.unbind("r l");
    });

    $scope.refreshList(false);

    if ($state.is('plugins')) {
        $state.transitionTo('plugins.store');
    }
});

app.controller("PluginsStoreController", ($scope, $stateParams) => {
    let unwatchPluginsList = undefined;
    const displayPlugin = (pluginId = $stateParams.pluginid) => {
        const pluginFound = $scope.pluginsList.plugins.find(p => p.id === pluginId);
        if (pluginFound) {
            $scope.seePluginStoreDetails(pluginFound);
        }
    }

    if ($stateParams.pluginid) {
        if ($scope.pluginsList === undefined) {
            unwatchPluginsList = $scope.$watch('pluginsList', newVal => {
                if (!newVal) {
                    return;
                }
                unwatchPluginsList();
                unwatchPluginsList = undefined;
                displayPlugin();
            });
        } else {
            displayPlugin();
        }
    }

    $scope.$on("$destroy", () => {
        if (unwatchPluginsList) {
            unwatchPluginsList();
        }
    });
});

app.controller("PluginPreviewPullController", function($rootScope, $scope, Assert) {
    $scope.error = null;

    $scope.go = function() {

        if (!$rootScope.appConfig.admin) {
            return;
        }

        Assert.trueish($scope.gitPlugin, "Git plugin not ready");

        $state.transitionTo('plugin.updatefromgit', {
            uri: $scope.gitPlugin.gitState.repository,
            checkout: $scope.gitPlugin.gitState.checkout,
            path: $scope.gitPlugin.gitState.path
        });
    };
});

app.controller("PluginInstallationController", function ($scope, DataikuAPI, MonoFuture, Fn, WT1, $state, $stateParams, FutureWatcher, ProgressStackMessageBuilder) {
    $scope.state = "NOT_STARTED";
    $scope.environmentState = 'NOT_STARTED';
    $scope.pluginId = $stateParams.pluginId;
    $scope.isGit = $state.includes("plugin.installationfromgit") || $state.includes("plugin.updatefromgit");
    $scope.isUpdate = $state.includes('plugin.update') || $state.includes('plugin.upload.update') || $state.includes("plugin.updatefromgit");
    $scope.isUploadUpdate = $state.includes('plugin.upload.update');
    $scope.isUpload = $state.includes('plugin.upload') || $scope.isUploadUpdate;
    $scope.isCodeEnvDefined = false;
    let uploadedPluginFile = $stateParams.uploadedPluginFile;

    function go() {
        MonoFuture($scope).wrap(DataikuAPI.plugins.install)($scope.pluginId, $scope.isUpdate).success(function(data) {
            $scope.state = data.result.success ? "DONE" : "FAILED";
            WT1.event("plugin-download", { success : $scope.state });

            if (!data.result.success) {
                $scope.failure = {
                    message: data.result.installationError.detailedMessage,
                    isAlreadyInstalled: data.result.installationError.detailedMessage.includes('already installed')
                }
            } else {
                $scope.pluginDesc = data.result.pluginDesc;
                $scope.$parent.pluginLabel = data.result.pluginDesc.desc.meta.label;
                $scope.pluginSettings = data.result.settings;
                $scope.needsRestart = data.result.needsRestart
                $scope.isCodeEnvDefined = !!($scope.pluginDesc && ($scope.pluginDesc.frontendRequirements.hasDependencies || $scope.pluginDesc.frontendRequirements.codeEnvLanguage));
            }

            $scope.installingFuture = null;
        }).update(function(data) {
            $scope.state = "RUNNING";
            $scope.installingFuture = data;
        }).error(function (data, status, headers) {
            $scope.state = "FAILED";
            if (data.aborted) {
                $scope.failure = {
                    message: "Aborted"
                }
            } else if (data.hasResult) {
                $scope.failure = {
                    message: data.result.errorMessage
                }
            } else {
                $scope.failure = {
                    message: "Unexpected error"
                }
            }
            $scope.installingFuture = null;
        });
    }

    function goFromGit() {
        $scope.state = 'RUNNING';

        var handleCloneInstallationError = function (data, status, headers) {
            $scope.state = "FAILED";
            $scope.failure = {
                message: getErrorDetails(data, status, headers).detailedMessage
            }
        };

        var handleCloneInstallationResult = function (data) {
            const result = data.result;
            WT1.event("plugin-clone", {success: $scope.state});

            if (!result.success) {
                $scope.state = "FAILED";
                $scope.failure = {
                    message: result.installationError.detailedMessage
                }
            } else {
                $scope.state = "DONE";
                $scope.pluginDesc = result.pluginDesc;
                $scope.$parent.pluginLabel = result.pluginDesc.desc.meta.label;
                $scope.pluginSettings = result.settings;
                $scope.needsRestart = result.needsRestart
                $scope.isCodeEnvDefined = !!($scope.pluginDesc && ($scope.pluginDesc.frontendRequirements.hasDependencies || $scope.pluginDesc.frontendRequirements.codeEnvLanguage));
                unregisterPluginIdWatcher();
                $scope.pluginId = result.pluginDesc.desc.id;
            }
        };
        DataikuAPI.plugins.clonePlugin($stateParams.uri, $stateParams.checkout, $stateParams.path, $scope.isUpdate).success(function(data) {
            FutureWatcher.watchJobId(data.jobId)
                .success(handleCloneInstallationResult)
                .update(function (data) {
                    $scope.clonePercentage = ProgressStackMessageBuilder.getPercentage(data.progress);
                    $scope.cloneLabel = ProgressStackMessageBuilder.build(data.progress, true);
                }).error(handleCloneInstallationError);
        }).error(setErrorInScope.bind($scope));
    }

    function upload () {
        $scope.state = 'RUNNING';
        DataikuAPI.plugins.uploadPlugin(uploadedPluginFile, $scope.isUploadUpdate).then(function (data) {
            data = JSON.parse(data);

            $scope.state = data.success ? 'DONE' : 'FAILED';

            WT1.event('plugin-upload', {success : $scope.state });

            if (!data.success) {
                $scope.failure = {
                    message: data.installationError.detailedMessage
                }
            } else {
                $scope.pluginDesc = data.pluginDesc;
                $scope.$parent.pluginLabel = data.pluginDesc.desc.meta.label;
                $scope.pluginSettings = data.settings;
                $scope.needsRestart = data.needsRestart
                $scope.isCodeEnvDefined = !!($scope.pluginDesc && ($scope.pluginDesc.frontendRequirements.hasDependencies || $scope.pluginDesc.frontendRequirements.codeEnvLanguage));
                unregisterPluginIdWatcher();
                $scope.pluginId = data.pluginDesc.desc.id;
            }

        }, function(payload) {
            $scope.state = "FAILED";
            let errorMessage;

            try {
                const parsedResponse = JSON.parse(payload.response);
                errorMessage = parsedResponse.detailedMessage;
            } catch (exception) {
                errorMessage = 'An unknown error ocurred during the file upload.'
            }

            $scope.failure = {
                message: errorMessage
            }
        });
    }

    $scope.abort = function() {
        $scope.state = "FAILED";
        $scope.failure = {
            message: "Aborted"
        }
        DataikuAPI.futures.abort($scope.installingFuture.jobId);
    };

    $scope.skipEnvironmentCreation = function() {
        $scope.state = 'DONE';
        $scope.environmentState = 'SKIPPED';
    }

    $scope.approveEnvironmentCreation = function() {
        $scope.environmentState = 'WAITING_CONFIRMATION';
    }

    $scope.disapproveEnvironmentCreation = function() {
        $scope.environmentState = 'NOT_STARTED';
    }

    $scope.confirmEnvironmentCreation = function() {
        $scope.environmentState = 'DONE';
    }

    $scope.goToPluginPage = function() {
        window.location = $state.href('plugin.summary', { pluginId: $scope.pluginId });
    };

    $scope.$on("$destroy", function(){
        if ($scope.state == "RUNNING") {
            $scope.abort();
        }
    });

    $scope.triggerRestart = function() {
        $state.go('plugin.summary', { pluginId: $scope.pluginId }, { reload: true });
        DataikuAPI.plugins.triggerRestart().success(function(data) {
            // 'disconnected' will be shown while the backend restarts
        }).error(function() {
            // this is expected, if the backend dies fast enough and doesn't send the response back
        });
    };

    let unregisterPluginIdWatcher = $scope.$watch("pluginId", Fn.doIfNv($scope.isGit ? goFromGit : ($scope.isUpload ? upload : go)));
});


app.controller("PluginLearnMoreController", function ($scope) {
    $scope.customDatasets = $scope.appConfig.customDatasets.filter(function(x){
        return x.ownerPluginId == $scope.pluginDesc.id;
    });
    $scope.customRecipes = $scope.appConfig.customCodeRecipes.filter(function(x){
        return x.ownerPluginId == $scope.pluginDesc.id;
    });
});

/* Permissions */
app.directive('pluginPresetSecurityPermissions', function(PermissionsService) {
    return {
        restrict : 'A',
        templateUrl : '/templates/plugins/plugin-preset-security-permissions.html',
        scope : {
            preset  : '='
        },
        link : function($scope, element, attrs) {
            $scope.ui = {};

            $scope.securityPermissionsHooks = {};
            $scope.securityPermissionsHooks.makeNewPerm = function() {
                return {
                    use: false
                };
            };
            $scope.securityPermissionsHooks.fixupPermissionItem = function(p) {
                p.$useDisabled = false;
            };
            $scope.securityPermissionsHooks.fixupWithDefaultPermissionItem = function(p, d) {
                if (d.use || d.$useDisabled) {
                    p.$useDisabled = true;
                }
            };

            $scope.$watch("preset.owner", function() {
                $scope.ui.ownerLogin = $scope.preset.owner;
            });

            // Ownership mgmt
            $scope.$watch("ui.ownerLogin", function() {
                PermissionsService.transferOwnership($scope, $scope.preset, "preset");
            });
        }
    };
});


app.directive('pluginParameterSetSecurityPermissions', function() {
    return {
        restrict : 'A',
        templateUrl : '/templates/admin/plugins/plugin-parameter-set-security-permissions.html',
        scope : {
            parameterSet  : '='
        },
        link : function($scope, element, attrs) {
            $scope.securityPermissionsHooks = {};
            $scope.securityPermissionsHooks.makeNewPerm = function() {
                return {
                    definableAtProjectLevel: false,
                    definableInline: false
                };
            };
            $scope.securityPermissionsHooks.fixupPermissionItem = function(p) {
                p.$definableAtProjectLevelDisabled = false;
                p.$definableInlineDisabled = false;
            };
            $scope.securityPermissionsHooks.fixupWithDefaultPermissionItem = function(p, d) {
                if (d.definableAtProjectLevel || d.$definableAtProjectLevelDisabled) {
                    p.$definableAtProjectLevelDisabled = true;
                }
                if (d.definableInline || d.$definableInlineDisabled) {
                    p.$definableInlineDisabled = true;
                }
            };
        }
    };
});


app.directive('pluginSecurityPermissions', function() {
    return {
        restrict : 'A',
        templateUrl : '/templates/plugins/plugin-security-permissions.html',
        scope : {
            plugin : '='
        },
        link : function($scope, element, attrs) {
            $scope.securityPermissionsHooks = {};
            $scope.securityPermissionsHooks.makeNewPerm = function() {
                return {
                    admin: true
                };
            };
            $scope.securityPermissionsHooks.fixupPermissionItem = function(p) {
                p.$adminDisabled = false;
            };
            $scope.securityPermissionsHooks.fixupWithDefaultPermissionItem = function(p, d) {
                if (d.admin || d.$adminDisabled) {
                    p.$adminDisabled = true;
                }
            };
        }
    };
});


app.directive('securityPermissionsBase', function(DataikuAPI, $rootScope, PermissionsService) {
    return {
        restrict : 'A',
        scope : false,
        link : function($scope, element, attrs) {
            $scope.appConfig = $rootScope.appConfig;

            function makeNewPerm() {
                $scope.newPerm = $scope.securityPermissionsHooks.makeNewPerm();
            }
            const hooksDeregister = $scope.$watch("securityPermissionsHooks", function() {
                if (!$scope.securityPermissionsHooks) return;
                makeNewPerm();
                hooksDeregister();
            }, false);

            const fixupDefaultPermission = function() {
                if (!$scope[attrs.permissionsBearer]) return;
                /* Handle implied permissions */
                $scope.securityPermissionsHooks.fixupPermissionItem($scope[attrs.permissionsBearer].defaultPermission);
            };
            const fixupPermissions = function() {
                if (!$scope[attrs.permissionsBearer] || !$scope.securityPermissionsHooks) return;
                /* Handle implied permissions */
                $scope[attrs.permissionsBearer].permissions.forEach(function(p) {
                    $scope.securityPermissionsHooks.fixupPermissionItem(p);
                    $scope.securityPermissionsHooks.fixupWithDefaultPermissionItem(p, $scope[attrs.permissionsBearer].defaultPermission);
                });
            };

            DataikuAPI.security.listGroups(false).success(function(allGroups) {
                $scope.allGroups = allGroups;
                DataikuAPI.security.listUsers().success(function(data) {
                    $scope.allUsers = data;
                }).error(setErrorInScope.bind($scope));
                $scope.unassignedGroups = PermissionsService.buildUnassignedGroups($scope[attrs.permissionsBearer], $scope.allGroups);
            }).error(setErrorInScope.bind($scope));

            $scope.addPermission = function() {
                $scope[attrs.permissionsBearer].permissions.push($scope.newPerm);
                makeNewPerm();
            };

            $scope.$watch(attrs.permissionsBearer + ".permissions", function(nv, ov) {
                if (!nv) return;
                $scope.unassignedGroups = PermissionsService.buildUnassignedGroups($scope[attrs.permissionsBearer], $scope.allGroups);
                fixupPermissions();
            }, true)
            $scope.$watch(attrs.permissionsBearer + ".permissions", function(nv, ov) {
                if (!nv) return;
                $scope.unassignedGroups = PermissionsService.buildUnassignedGroups($scope[attrs.permissionsBearer], $scope.allGroups);
                fixupPermissions();
            }, false)
            $scope.$watch(attrs.permissionsBearer + ".defaultPermission", function(nv, ov) {
                if (!nv) return;
                fixupDefaultPermission();
                fixupPermissions();
            }, true)
            $scope.$watch(attrs.permissionsBearer + ".defaultPermission", function(nv, ov) {
                if (!nv) return;
                fixupDefaultPermission();
                fixupPermissions();
            }, false)
            $scope.unassignedGroups = PermissionsService.buildUnassignedGroups($scope[attrs.permissionsBearer], $scope.allGroups);
            fixupPermissions();
        }
    };
});


/* Presets */
app.controller("NewPresetController", function($scope) {

    $scope.presetTypes = $scope.pluginSettings.accessibleParameterSetDescs.map(function(p) {
    	return {id:p.elementType, label:(p.desc.meta.label || p.elementType)};
    });
    $scope.newPreset = {type:$scope.presetTypes[0].id, name:'Preset ' + ($scope.pluginSettings.presets.length + 1), permissions : [], visibleByAll : true, usableByAll : false, canAdmin : true, canManage : true};
    $scope.presetNameList = $scope.pluginSettings.presets.map(function(p) {return p.name;});

    $scope.create = function(){
    	$scope.pluginSettings.presets.push($scope.newPreset);
        $scope.dismiss();
    }
});


app.controller("NewPresetInParameterSetController", function($scope) {
    $scope.newPreset = {name:'Preset ' + ($scope.allPresets.length + 1), permissions : [], canAdmin : true, canManage : true};
    $scope.presetNameList = $scope.presets.map(function(p) {return p.name;});

    $scope.create = function() {
        $scope.presets.push($scope.newPreset);
        $scope.allPresets.push($scope.newPreset);
        $scope.dismiss();
    };
});


app.directive('pluginParameterSet', function(CreateModalFromTemplate) {
    return {
        restrict : 'A',
        templateUrl : '/templates/plugins/plugin-parameter-set.html',
        scope : {
            parameterSet : '=',
            parameterSetDesc : '=',
            pluginDesc : '=',
            presets : '=',
            remove : '=',
            allPresets : '='
        },
        link : function($scope, element, attrs) {
            $scope.$watch('allPresets', function() {
                if (!$scope.allPresets) return;
                $scope.presets = $scope.allPresets.filter(function(p) {return p.type == $scope.parameterSet.type;});
            }, true);
            $scope.deletePresetInParameterSet = function(preset) {
                var idxInPlugin = $scope.allPresets.indexOf(preset);
                if (idxInPlugin >= 0) {
                    $scope.allPresets.splice(idxInPlugin, 1);
                }
                var idx = $scope.presets.indexOf(preset);
                if (idx >= 0) {
                    $scope.presets.splice(idx, 1);
                }
            };
            $scope.createPresetInParameterSet = function() {
                CreateModalFromTemplate("/templates/plugins/modals/new-preset.html", $scope, "NewPresetInParameterSetController", function(newScope) {
                    newScope.inParameterSet = true;
                    newScope.newPreset.type = $scope.parameterSet.type;
                });
            };
        }
    };
});


app.directive('pluginPreset', function() {
    return {
        restrict : 'A',
        templateUrl : '/templates/plugins/plugin-preset.html',
        scope : {
            preset : '=',
            parameterSetDesc : '=',
            pluginDesc : '=',
            remove : '='
        },
        link : function($scope) {
        	$scope.$watch('preset', function() {
        		if (!$scope.preset) return;
        		$scope.preset.config = $scope.preset.config || {};
        		$scope.preset.pluginConfig = $scope.preset.pluginConfig || {};
        	});
        }
    };
});

app.directive('pluginAppTemplate', function(DataikuAPI) {
    return {
        restrict : 'A',
        templateUrl : '/templates/plugins/plugin-app-template.html',
        scope : {
            appTemplate : '=',
            appTemplateDesc : '=',
            pluginDesc : '=',
            remove : '='
        },
        link : function($scope, element, attrs) {
    
            $scope.addConnectionRemapping = function(name) {
                $scope.appTemplate.remapping.connections.push({
                    source: name,
                    target: null
                });
            };
            $scope.addCodeEnvRemapping = function(name) {
                $scope.appTemplate.remapping.codeEnvs.push({
                    source: name,
                    target: null
                });
            };
            
            $scope.availableConnections = [];
            DataikuAPI.admin.connections.list().success(function(data) {
                angular.forEach(data, function(c, n) {
                    $scope.availableConnections.push({name:n, type:c.type});
                });
            }).error(setErrorInScope.bind($scope));
            
            $scope.availableCodeEnvs = [{envLang:'PYTHON', envName:'Builtin', builtin:true}, {envLang:'R', envName:'Builtin', builtin:true}];
            DataikuAPI.codeenvs.listNames('PYTHON').success(function(data) {
                data.forEach(function(n) {
                    $scope.availableCodeEnvs.push({envLang:'PYTHON', envName:n, builtin:false});
                });
            }).error(setErrorInScope.bind($scope));
            DataikuAPI.codeenvs.listNames('R').success(function(data) {
                data.forEach(function(n) {
                    $scope.availableCodeEnvs.push({envLang:'R', envName:n, builtin:false});
                });
            }).error(setErrorInScope.bind($scope));
        }
    };
});



})();
(function() {
'use strict';


const app = angular.module('dataiku.admin.clusters', []);

app.controller("ClusterCoreController", function($scope, CreateModalFromTemplate) {
    $scope.openDeleteClusterModal = function(clusterId, actionAfterDeletion) {
        var newScope = $scope.$new();
        newScope.clusterId = clusterId;
        newScope.actionAfterDeletion = actionAfterDeletion || function(){};
        CreateModalFromTemplate("/templates/admin/clusters/delete-cluster-modal.html", newScope, "ClusterDeleteController");
    }

    $scope.getStateDisplayString = function(state) {
        var displayNames = {NONE:'Stopped/Detached', RUNNING:'Running/Attached', STARTING:'Starting/Attaching', STOPPING:'Stopping/Detaching'};
        if (state == null) return null;
        return displayNames[state] || state;
    }
    $scope.getStateDisplayClass = function(state) {
        var classes = {NONE:'text-error', RUNNING:'text-success', STARTING:'text-warning', STOPPING:'text-warning'};
        if (state == null) return null;
        return classes[state];
    }
});

app.controller("ClusterDeleteController", function($scope, Assert, DataikuAPI, FutureProgressModal) {
    $scope.uiState = {stop:true};

    DataikuAPI.admin.clusters.getStatus($scope.clusterId).success(function(data) {
        $scope.clusterStatus = data;
    }).error(setErrorInScope.bind($scope));

    $scope.doesntNeedStop = function() {
        return $scope.clusterStatus && $scope.clusterStatus.clusterType != 'manual' && $scope.clusterStatus.state == 'NONE';
    };
    $scope.mayNeedStop = function() {
        return $scope.clusterStatus && $scope.clusterStatus.clusterType != 'manual' && $scope.clusterStatus.state != 'NONE';
    };

    $scope.delete = function() {
        Assert.inScope($scope, 'clusterStatus');
        if ($scope.mayNeedStop() && $scope.uiState.stop) {
            var parentScope = $scope.$parent;
            DataikuAPI.admin.clusters.stop($scope.clusterId, true).success(function(data){
                $scope.dismiss();
                FutureProgressModal.show(parentScope, data, "Stop cluster", undefined, 'static', 'false').then(function(result){
                    if (result) { // undefined in case of abort
                        $scope.actionAfterDeletion();
                    }
                });
            }).error(setErrorInScope.bind($scope));
        } else {
            DataikuAPI.admin.clusters.delete($scope.clusterId).success(function(data){
                $scope.dismiss();
                $scope.actionAfterDeletion();
            }).error(setErrorInScope.bind($scope));
        }
    };
});

app.controller("ClustersController", function ($scope, $controller, DataikuAPI, CreateModalFromTemplate, TopNav) {
    $controller("ClusterCoreController", {$scope:$scope});

    TopNav.setLocation(TopNav.DSS_HOME, "administration");

    $scope.uiState = {query:null};

    $scope.clusters = [];
    $scope.refreshList = function() {
        DataikuAPI.admin.clusters.list().success(function(data){
            $scope.clusters = data;
        }).error(setErrorInScope.bind($scope));
    };
    $scope.refreshList();

    $scope.createCluster = function() {
        CreateModalFromTemplate("/templates/admin/clusters/new-cluster-modal.html", $scope, "NewClusterController")
    };

    $scope.deleteCluster = function(clusterId) {
        $scope.openDeleteClusterModal(clusterId, $scope.refreshList);
    };
});

app.controller("NewClusterController", function($scope, $rootScope, $state, DataikuAPI) {

    $scope.newCluster = {type:'manual', params: {}};
    $scope.clusterArchitectures = [{id:'HADOOP', label:'Hadoop'}, {id:'KUBERNETES', label:'K8S'}];
    $scope.clusterTypes = [{id:'manual', label:'Non managed', architecture:'MANUAL'}];
    $rootScope.appConfig.customPythonPluginClusters.forEach(function(t) {
        $scope.clusterTypes.push({id:t.clusterType, label:t.desc.meta.label || t.id, architecture:t.desc.architecture || 'HADOOP'})
    });

    $scope.$watch('newCluster.type', function() {
        if ($scope.newCluster.type && $scope.newCluster.type != 'manual') {
            let clusterType = $scope.clusterTypes.filter(function(t) {return $scope.newCluster.type == t.id;})[0];
            $scope.newCluster.architecture = clusterType ? clusterType.architecture : null;
        }
    });
    $scope.create = function(){
        var parentScope = $scope.$parent.$parent;
        DataikuAPI.admin.clusters.create($scope.newCluster).success(function(data){
            $scope.dismiss();
            parentScope.refreshList();
            $state.go("admin.clusters.cluster", {clusterId:data.id});
        }).error(setErrorInScope.bind($scope));
    }
});

app.controller("ClusterController", function($scope, $controller, $stateParams, Assert, DataikuAPI, $state, TopNav, FutureProgressModal, ActivityIndicator, $q, Logs) {
    $controller("ClusterCoreController", {$scope:$scope});

    TopNav.setLocation(TopNav.DSS_HOME, "administration");

    $scope.uiState = {active:'info', logsQuery : ''};

    $scope.cluster = {};
    $scope.origCluster = {};

    $scope.listLogs = function(){
        DataikuAPI.admin.clusters.listLogs($scope.cluster.id).success(function(data) {
            $scope.logs = data;
        }).error(setErrorInScope.bind($scope));
    };

    $scope.refreshItem = function() {
        DataikuAPI.admin.clusters.get($stateParams.clusterId).success(function(data) {
            $scope.cluster = data;
            $scope.origCluster = angular.copy(data);
            $scope.cluster.params = $scope.cluster.params || {};
            $scope.listLogs();
            $scope.refreshStatus();
        }).error(setErrorInScope.bind($scope));
    };
    $scope.refreshItem();

    $scope.refreshStatus = function() {
        if (!$scope.cluster.canUpdateCluster) return;
        DataikuAPI.admin.clusters.getStatus($stateParams.clusterId).success(function(data) {
            $scope.clusterStatus = data;
        }).error(setErrorInScope.bind($scope));
    };

    $scope.clusterIsDirty = function() {
        if (!$scope.cluster || !$scope.origCluster) return false;
        return !angular.equals($scope.cluster, $scope.origCluster);
    };

    checkChangesBeforeLeaving($scope, $scope.clusterIsDirty);

    $scope.saveCluster = function() {
        var deferred = $q.defer();
        if (!$scope.clusterIsDirty()) { // for when it's called with a keystroke or from start button
            deferred.resolve("Saved");
            return deferred.promise;
        }
        DataikuAPI.admin.clusters.save(angular.copy($scope.cluster)).success(function(data) {
            $scope.cluster = data;
            $scope.origCluster = angular.copy(data);
            deferred.resolve("Saved");
        }).error(function (a,b,c) {
            setErrorInScope.bind($scope)(a,b,c);
            deferred.reject("Not saved");
        });
        return deferred.promise;
    };

    $scope.deleteCluster = function() {
        $scope.openDeleteClusterModal($scope.cluster.id, function() {
            $state.go("admin.clusters.list");
        });
    };

    const doStartCluster = function(){
        Assert.inScope($scope, 'cluster');
        return DataikuAPI.admin.clusters.start($scope.cluster.id)
            .then(response => FutureProgressModal.show($scope, response.data, "Start cluster", undefined, 'static', 'false'))
            .then(function(result){
                if (result) { // undefined in case of abort
                    result.canUpdateCluster = $scope.cluster.canUpdateCluster; // keep the fields from the ClusterItem
                    result.canManageUsersCluster = $scope.cluster.canManageUsersCluster; // keep the fields from the ClusterItem
                    $scope.cluster = result;
                    $scope.origCluster = angular.copy(result);
                }
             })
            .catch(setErrorInScope.bind($scope));
    };

    const wrapLongClusterOperationRunning = function(operation) {
        return () => {
            if ($scope.isLongClusterOperationRunning) {
                return;
            }
            $scope.isLongClusterOperationRunning = true;
            operation().finally(() => $scope.isLongClusterOperationRunning = false);
        };
    };

    $scope.startCluster = wrapLongClusterOperationRunning(function(){
        return $scope.saveCluster().then(doStartCluster);
    });

    $scope.stopCluster = wrapLongClusterOperationRunning(function(){
        Assert.inScope($scope, 'cluster');
        return DataikuAPI.admin.clusters.stop($scope.cluster.id, false)
            .then(response => FutureProgressModal.show($scope, response.data, "Stop cluster", undefined, 'static', 'false'))
            .then(function(result){
                if (result) { // undefined in case of abort
                    $scope.refreshItem();
                }
             })
            .catch(setErrorInScope.bind($scope));
    });
    $scope.markStoppedCluster = function(){
        Assert.inScope($scope, 'cluster');

        DataikuAPI.admin.clusters.markStopped($scope.cluster.id).success(function(data){
            $scope.refreshItem();
        }).error(setErrorInScope.bind($scope));
    };

    $scope.currentLogName = null;
    $scope.currentLog = null;
    $scope.fetchLog = function(logName) {
    	DataikuAPI.admin.clusters.getLog($scope.cluster.id, logName).success(function(data) {
            $scope.currentLogName = logName;
            $scope.currentLog = data;
        }).error(setErrorInScope.bind($scope));
    };
    $scope.streamLog = function(logName) {
    	Logs.downloadCluster($scope.cluster.id, logName);
    };

    $scope.downloadClusterDiagnostic = function() {
        ActivityIndicator.success("Preparing cluster diagnosis ...");
        downloadURL(DataikuAPI.admin.clusters.getDiagnosisURL($scope.cluster.id));
    };
});

app.directive('clusterParamsForm', function(Assert, $rootScope, PluginConfigUtils) {
    return {
        restrict: 'A',
        templateUrl: '/templates/admin/clusters/cluster-params-form.html',
        scope: {
            params : '=',
            clusterType : '='
        },
        link: function($scope, element, attrs) {
            $scope.$watch('clusterType', function() {
                if (!$scope.clusterType) return;
                $scope.loadedDesc = $rootScope.appConfig.customPythonPluginClusters.filter(function(x){
                    return x.clusterType == $scope.clusterType;
                })[0];

                Assert.inScope($scope, 'loadedDesc');

                $scope.desc = $scope.loadedDesc.desc;

                // put default values in place
                $scope.params.config = $scope.params.config || {};
                PluginConfigUtils.setDefaultValues($scope.desc.params, $scope.params.config);

                $scope.pluginDesc = $rootScope.appConfig.loadedPlugins.filter(function(x){
                    return x.id == $scope.loadedDesc.ownerPluginId;
                })[0];
            });
        }
    };
});

app.directive('clusterActionsForm', function($rootScope, CreateModalFromTemplate) {
    return {
        restrict: 'A',
        templateUrl: '/templates/admin/clusters/cluster-actions-form.html',
        scope: {
            params : '=',
            clusterId : '=',
            clusterType : '='
        },
        link: function($scope, element, attrs) {
            var refreshClusterActions = function() {
                $scope.clusterActions = [];

                const pluginsById = $rootScope.appConfig.loadedPlugins.reduce(function (map, obj) {
                    map[obj.id] = obj;
                    return map;
                }, {});

                $rootScope.appConfig.customRunnables.forEach(function(runnable) {
                    if (!runnable.desc.macroRoles) return;

                    const plugin = pluginsById[runnable.ownerPluginId];
                    if (!plugin) return; // plugin might have been deleted
                    
                    runnable.desc.macroRoles.forEach(function(macroRole) {
                        if (macroRole.type != 'CLUSTER') return;
                        if (macroRole.limitToSamePlugin) {
                            if (!$scope.loadedDesc || runnable.ownerPluginId != $scope.loadedDesc.ownerPluginId) return;
                        }
                        
                        $scope.clusterActions.push({
                            label: runnable.desc.meta.label || runnable.id,
                            icon: runnable.desc.meta.icon || plugin.icon,
                            roleTarget: macroRole.targetParamsKey || macroRole.targetParamsKeys,
                            runnable: runnable
                        });
                    });
                });

                $scope.showCreateRunnable = function(runnable, targetKey, targetValue) {
                    CreateModalFromTemplate('/templates/macros/runnable-modal.html', $scope, null, function(newScope) {
                        newScope.runnable = runnable;
                        newScope.targetKey = targetKey;
                        newScope.targetValue = targetValue;
                        newScope.cluster = true;
                    });
                };
            };
            $scope.$watch('clusterType', function() {
                if (!$scope.clusterType) return;
                $scope.loadedDesc = $rootScope.appConfig.customPythonPluginClusters.filter(function(x){
                    return x.clusterType == $scope.clusterType;
                })[0];

                refreshClusterActions();
            });
        }
    };
});

app.directive('hadoopClusterSettingsBlock', function($rootScope) {
    return {
        restrict: 'A',
        templateUrl: '/templates/admin/clusters/fragments/hadoop-cluster-settings-block.html',
        scope: {
            settings : '=',
            mask : '=',
            impersonationEnabled : '='
        },
        link: function($scope, element, attrs) {
            $scope.appConfig = $rootScope.appConfig;
            $scope.addLicInfo = $rootScope.addLicInfo;
        }
    };
});

app.directive('hiveClusterSettingsBlock', function($rootScope, CodeMirrorSettingService) {
    return {
        restrict: 'A',
        templateUrl: '/templates/admin/clusters/fragments/hive-cluster-settings-block.html',
        scope: {
            settings : '=',
            hadoopSettings : '=',
            mask : '=',
            impersonationEnabled : '='
        },
        link: function($scope, element, attrs) {
            $scope.appConfig = $rootScope.appConfig;
            $scope.addLicInfo = $rootScope.addLicInfo;
            $scope.codeMirrorSettingService = CodeMirrorSettingService;

            $scope.copyHadoopSettings = function() {
                if (!$scope.settings) return;
                if (!$scope.hadoopSettings) return;

                var hiveProps = $scope.settings.executionConfigsGenericOverrides;
                var hadoopPropsNames = $scope.hadoopSettings.extraConf.map(function(p) {return p.key;});
                // remove existing properties with the names of those we add (avoid duplicates)
                hadoopPropsNames.forEach(function(k) {
                   var indices = hiveProps.map(function(p, i) {return p.key == k ? i : null;}).filter(function(x) {return x != null;});
                   indices.reverse().forEach(function(i) {hiveProps.splice(i, 1);});
                });
                $scope.hadoopSettings.extraConf.forEach(function(p) {
                    var hp = angular.copy(p);
                    hiveProps.push(hp);
                });
                // to make the list's UI refresh
                $scope.settings.executionConfigsGenericOverrides = [].concat(hiveProps)
            };
        }
    };
});

app.directive('impalaClusterSettingsBlock', function($rootScope) {
    return {
        restrict: 'A',
        templateUrl: '/templates/admin/clusters/fragments/impala-cluster-settings-block.html',
        scope: {
            settings : '=',
            mask : '=',
            impersonationEnabled : '='
        },
        link: function($scope, element, attrs) {
            $scope.appConfig = $rootScope.appConfig;
            $scope.addLicInfo = $rootScope.addLicInfo;
        }
    };
});

app.directive('sparkClusterSettingsBlock', function(DataikuAPI, $rootScope, FutureProgressModal, ActivityIndicator) {
    return {
        restrict: 'A',
        templateUrl: '/templates/admin/clusters/fragments/spark-cluster-settings-block.html',
        scope: {
            settings : '=',
            hadoopSettings : '=',
            mask : '=',
            impersonationEnabled : '=',
            clusterId : '='
        },
        link: function($scope, element, attrs) {
            $scope.appConfig = $rootScope.appConfig;
            $scope.addLicInfo = $rootScope.addLicInfo;

            $scope.executionEngines = [
                                       {value:null, label:'No interactive SparkSQL'},
                                       {value:'SPARK_SUBMIT', label:'CLI (spark-submit)'},
                                       {value:'LIVY_SESSION', label:'Livy (interactive session)', disabled:!$scope.appConfig.livyEnabled},
                                       {value:'LIVY_BATCH', label:'Livy (batch)', disabled:!$scope.appConfig.livyEnabled},
                                       {value:'DATABRICKS', label:'Databricks'},
                                      ];

            $scope.copyHadoopSettings = function() {
                if (!$scope.settings) return;
                if (!$scope.hadoopSettings) return;

                var sparkProps = $scope.settings.executionConfigsGenericOverrides;
                var hadoopPropsNames = $scope.hadoopSettings.extraConf.map(function(p) {return p.key;});
                // remove existing properties with the names of those we add (avoid duplicates)
                hadoopPropsNames.forEach(function(k) {
                   var indices = sparkProps.map(function(p, i) {return p.key == 'spark.hadoop.' + k ? i : null;}).filter(function(x) {return x != null;});
                   indices.reverse().forEach(function(i) {sparkProps.splice(i, 1);});
                });
                $scope.hadoopSettings.extraConf.forEach(function(p) {
                    var sp = angular.copy(p);
                    sp.key = 'spark.hadoop.' + p.key;
                    sparkProps.push(sp);
                });
                // to make the list's UI refresh
                $scope.settings.executionConfigsGenericOverrides = [].concat(sparkProps);
            };
            
            $scope.preloadYarnClusterFiles = function(yarnClusterSettings) {
                DataikuAPI.admin.clusters.preloadYarnClusterFiles(yarnClusterSettings).success(function(data){
                    FutureProgressModal.show($scope, data, "Preload files on cluster", undefined, 'static', 'false').then(function(result) {
                    });
                }).error(setErrorInScope.bind($scope));
            };
            
            $scope.testLivy = function(livySettings) {
                $scope.testedSettings = angular.copy(livySettings);
                $scope.livyTestResult = null;
                DataikuAPI.admin.clusters.testLivy($scope.clusterId, livySettings).success(function(data){
                    FutureProgressModal.show($scope, data, "Test Livy", undefined, 'static', 'false').then(function(result) {
                        $scope.livyTestResult = result;
                    });
                }).error(setErrorInScope.bind($scope));
            };
            $scope.sparkVersionsCompatible = function(dssVersion, livyVersion) {
                if (dssVersion == null || dssVersion.length == 0) dssVersion = $rootScope.appConfig.sparkVersion;
                if (dssVersion == null || dssVersion.length == 0) return true;
                if (livyVersion == null || livyVersion.length == 0) return true;
                return dssVersion.substring(0,2) == livyVersion.substring(0,2)
            };
            $scope.shouldUseYarnCluster = function(sparkMaster, deployMode) {
                if (sparkMaster == 'yarn' && deployMode == 'cluster') return true;
                if (sparkMaster == 'yarn-cluster') return true;
                return false;
            };


            $scope.setRemoteSparkJupyterSupport = function(remoteKernelType, active) {
                DataikuAPI.admin.codeenvs.setRemoteSparkSupport("PYTHON", "__BUILTIN__", remoteKernelType, active).success(function(data) {
                    ActivityIndicator.success("Operation successful");
                }).error(setErrorInScope.bind($scope));
            }
        }
    };
});

app.directive('containerClusterSettingsBlock', function(DataikuAPI, WT1, $rootScope, FutureProgressModal, Dialogs, CodeMirrorSettingService) {
    return {
        restrict: 'A',
        templateUrl: '/templates/admin/clusters/fragments/container-cluster-settings-block.html',
        scope: {
            settings : '=',
            mask : '=',
            impersonationEnabled : '=',
            clusterId : '=',
            k8sClusters: '='
        },
        link: function($scope, element, attrs) {
            $scope.appConfig = $rootScope.appConfig;
            $scope.addLicInfo = $rootScope.addLicInfo;
            $scope.codeMirrorSettingService = CodeMirrorSettingService;

            $scope.getNewContainerConfig = function() {
                return {
                    type: 'KUBERNETES',
                    usableBy: 'ALL', allowedGroups: [],
                    dockerResources: [],
                    kubernetesResources: {
                        memRequestMB: -1, memLimitMB: -1,
                        cpuRequest: -1, cpuLimit: -1,
                        customRequests: [], customLimits: [],
                        hostPathVolumes: []
                    },
                    properties: []
                };
            };

            DataikuAPI.security.listGroups(false)
                .success(data => {
                    if (data) {
                        data.sort();
                    }
                    $scope.allGroups = data;
                })
                .error(setErrorInScope.bind($scope));
        
            $scope.isBaseImageNameSuspicious = function(baseImage) {
                return /^(?:[\w-_]+\.)+\w+(?::\d+)?\//.test(baseImage);
            };
            
            var testErrors = {};
            $scope.getTestError = function(config) {
                let s = testErrors[config.name];
                return s != null ? s.fatalAPIError : null;
            };

            $scope.testConf = function(configuration, clusterId) {
                testErrors[configuration.name] = {}; // doesn't need to be a scope for setErrorInScope()
                DataikuAPI.admin.containerExec.testConf(configuration, $scope.clusterId && $scope.clusterId != '__builtin__', clusterId || $scope.clusterId, $scope.settings.executionConfigsGenericOverrides).success(function(data){
                    FutureProgressModal.show($scope, data, "Testing container configuration", undefined, 'static', 'false').then(function(result){
                        if (result) {
                            Dialogs.infoMessagesDisplayOnly($scope, "Container test result", result.messages, result.futureLog);
                        }
                    })
                }).error(setErrorInScope.bind(testErrors[configuration.name]));
                WT1.event('container-conf-test');
            }
            
            $scope.getExtraClusters = function() {
                if (!$scope.k8sClusters) return [];
                return $scope.k8sClusters.filter(function(c) {return (c.id || '__builtin__') != ($scope.clusterId || '__builtin__');});
            };

        }
    };
});

app.directive('clusterSecurityPermissions', function(DataikuAPI, $rootScope, PermissionsService) {
    return {
        restrict : 'A',
        templateUrl : '/templates/admin/clusters/fragments/security-permissions.html',
        replace : true,
        scope : {
                cluster  : '='
        },
        link : function($scope, element, attrs) {
            $scope.appConfig = $rootScope.appConfig;
            $scope.ui = {};

            function makeNewPerm(){
                $scope.newPerm = {
                    update: true,
                    use: true
                }
            }
            makeNewPerm();

            const fixupPermissions = function() {
                if (!$scope.cluster) return;
                /* Handle implied permissions */
                $scope.cluster.permissions.forEach(function(p) {
                    p.$updateDisabled = false;
                    p.$manageUsersDisabled = false;
                    p.$useDisabled = false;

                    if ($scope.cluster.usableByAll) {
                        p.$useDisabled = true;
                    }
                    if (p.update) {
                        p.$useDisabled = true;
                    }
                    if (p.manageUsers) {
                        p.$useDisabled = true;
                        p.$updateDisabled = true;
                    }
                });
            };

            DataikuAPI.security.listGroups(false).success(function(allGroups) {
                if (allGroups) {
                    allGroups.sort();
                }
                $scope.allGroups = allGroups;
                DataikuAPI.security.listUsers().success(function(data) {
                    $scope.allUsers = data;
                }).error(setErrorInScope.bind($scope));
                $scope.unassignedGroups = PermissionsService.buildUnassignedGroups($scope.cluster, $scope.allGroups);
            }).error(setErrorInScope.bind($scope));

            $scope.$watch("cluster.owner", function() {
                $scope.ui.ownerLogin = $scope.cluster.owner;
            });

            $scope.addPermission = function() {
                $scope.cluster.permissions.push($scope.newPerm);
                makeNewPerm();
            };

            $scope.$watch("cluster.usableByAll", function(nv, ov) {
                fixupPermissions();
            })
            $scope.$watch("cluster.permissions", function(nv, ov) {
                if (!nv) return;
                $scope.unassignedGroups = PermissionsService.buildUnassignedGroups($scope.cluster, $scope.allGroups);
                fixupPermissions();
            }, true)
            $scope.$watch("cluster.permissions", function(nv, ov) {
                if (!nv) return;
                $scope.unassignedGroups = PermissionsService.buildUnassignedGroups($scope.cluster, $scope.allGroups);
                fixupPermissions();
            }, false)
            $scope.unassignedGroups = PermissionsService.buildUnassignedGroups($scope.cluster, $scope.allGroups);
            fixupPermissions();

            // Ownership mgmt
            $scope.$watch("ui.ownerLogin", function() {
                PermissionsService.transferOwnership($scope, $scope.cluster, "cluster");
            });


        }
    };
});

})();
(function() {
'use strict';

    const app = angular.module('dataiku.plugindev', ['dataiku.plugindev.git']);


    app.controller('PlugindevCommonController', function($scope, DataikuAPI, $controller, $state, $stateParams, CreateModalFromTemplate, TopNav, FutureWatcher, WT1) {
        TopNav.setLocation(TopNav.DSS_HOME, 'plugin');

        const COMPONENT_IDENTIFIER_PLACEHOLDER = 'use-this-kind-of-case';

        if ($scope.appConfig.pluginDevGitMode === 'PLUGIN') {
            $controller('_PlugindevGitController', {$scope: $scope});
        }

        let regularPyAndJavaDescriptors = [
            { key: "python", label: "Python" },
            { key: "java", label: "Java"}
        ];

        let regularPyOnlyDescriptor = [
            { key: "python", label: "Python" }
        ];

        let regularJavaOnlyDescriptor = [
            { key: "java", label: "Java" }
        ];

        let regularJythonOnlyDescriptor = [
            { key: "jython", label: "Python" }
        ];

        let regularPyAndRDescriptors = [
            { key: "python", label: "Python" },
            { key: "r", label: "R"}
        ];
        let regularGenericOnlyDescriptor = [
            { key : "generic", label: "Generic" }
        ];

        let downloadIframe = $('<iframe>').attr('id', 'plugin-downloader');
        downloadIframe[0].onload = function() {
            // If download failed, notify user.
            if (this.contentDocument.URL !== 'about:blank') {
                CreateModalFromTemplate('/templates/plugins/modals/plugin-download-error.html', $scope);
            }
        };

        function getIdentifierHint(typeName = '') {
            return `Unique identifier for the new ${typeName} type. <br> It should not start with the plugin id and must be unique across the ${typeName} components of this plugin.` ;
        }

        $scope.initContentTypeList = function(pluginData=$scope.pluginData) {
            let codeEnvSpec = pluginData.installedDesc && pluginData.installedDesc.codeEnvSpec;
            $scope.contentTypeList = [
                {
                    name: "Code Env",
                    type: "codeEnv",
                    icon: 'icon-cogs',
                    iconColor: 'universe-color more',
                    disabled: codeEnvSpec != null,
                    disabledReason: "Only one code env can exist in a plugin",
                    description: "Create the code environment associated with this plugin, defining required libraries and their versions.",
                    addDescriptors: regularPyAndRDescriptors,
                    addFuncMap: {
                        python: DataikuAPI.plugindev.addPythonCodeEnv,
                        r: DataikuAPI.plugindev.addRCodeEnv
                    }
                },
                {
                    name: "Dataset",
                    type: "customDatasets",
                    icon: "icon-database",
                    iconColor: "universe-color datasets",
                    description: "Create a new type of dataset. This is generally used to fetch data from an external service, for example using an API",
                    addDescriptors: regularPyAndJavaDescriptors,
                    addFuncMap: {
                        java: DataikuAPI.plugindev.addJavaDataset,
                        python: DataikuAPI.plugindev.addPythonDataset
                    },
                    identifierPlaceholder: (() => COMPONENT_IDENTIFIER_PLACEHOLDER),
                    identifierHint: (() => getIdentifierHint('dataset'))
                },
                 {
                    name: "Recipe",
                    type: "customCodeRecipes",
                    icon: 'icon-FLOW_recipe_empty',
                    iconColor: 'universe-color recipe',
                    disabled: true,
                    disabledReason: "To create a new plugin recipe, you need to create it from an existing code recipe in a project. Go to the advanced tab > Convert to plugin recipe.",
                    description: "Create a new kind of recipe (Python, R, or Scala)"
                },
                {
                    name: "Macro",
                    type: "customRunnables",
                    icon: 'universe-color more',
                    iconColor: 'icon-macro',
                    description: "Create a new kind of runnable piece. Useful to occasionally launch external or maintenance tasks. Macros can also be run in a scenario.",
                    addDescriptors: regularPyAndJavaDescriptors,
                    addFuncMap: {
                        java: DataikuAPI.plugindev.addJavaRunnable,
                        python: DataikuAPI.plugindev.addPythonRunnable
                    },
                    identifierPlaceholder: (() => COMPONENT_IDENTIFIER_PLACEHOLDER),
                    identifierHint: (() => getIdentifierHint('runnable'))
                },
                {
                    name: "Parameter set",
                    type: "customParameterSets",
                    icon: 'icon-indent-right',
                    iconColor: 'universe-color more',
                    description: "Create a definition for presets in this plugin.",
                    addDescriptors : regularGenericOnlyDescriptor,
                    addFuncMap: {
                        generic: DataikuAPI.plugindev.addParameterSet,
                    },
                    identifierPlaceholder: (() => COMPONENT_IDENTIFIER_PLACEHOLDER),
                    identifierHint: (() => getIdentifierHint('parameter set'))
                },
                {
                    name: "Notebook template",
                    type: function(language = '') {
                        if (language.startsWith("scala")) {
                            return "customScalaNotebookTemplates"
                        }
                        if (language.startsWith("r")) {
                            return "customRNotebookTemplates"
                        }
                        return "customPythonNotebookTemplates";
                    },
                    icons: {
                        'customPreBuiltDatasetNotebookTemplates': { icon: 'icon-dku-nav_notebook', iconColor: 'universe-color notebook'},
                        'customRNotebookTemplates': { icon: 'icon-code_r_recipe', iconColor: 'universe-color notebook'},
                        'customRDatasetNotebookTemplates': { icon: 'icon-code_r_recipe', iconColor: 'universe-color notebook'},
                        'customPythonNotebookTemplates': { icon: 'icon-code_python_recipe', iconColor: 'universe-color notebook'},
                        'customPythonDatasetNotebookTemplates': { icon: 'icon-code_python_recipe', iconColor: 'universe-color notebook'},
                        'customScalaNotebookTemplates': { icon: 'icon-code_spark_scala_recipe', iconColor: 'universe-color notebook'},
                        'customScalaDatasetNotebookTemplates': { icon: 'icon-code_spark_scala_recipe', iconColor: 'universe-color notebook'}
                    },
                    description: "Create a new notebook template.",
                    addDescriptors: [
                        { key: "pythonDataset", label: "Python (create from a dataset)" },
                        { key: "pythonStandalone", label: "Python (create from notebooks list, unrelated to a dataset)" },
                        { key: "pythonDatasetPrebuilt", label: "Python (create from a dataset, in 'predefined' list)" },
                        { key: "rDataset", label: "R (create from a dataset)" },
                        { key: "rStandalone", label: "R (create from notebooks list, unrelated to a dataset)" },
                        { key: "rDatasetPrebuilt", label: "R (create from a dataset, in 'predefined' list)" },
                        { key: "scalaDataset", label: "Scala (create from a dataset)" },
                        { key: "scalaStandalone", label: "Scala (create from notebooks list, unrelated to a dataset)" }
                    ],
                    identifierPlaceholder: (() => COMPONENT_IDENTIFIER_PLACEHOLDER),
                    identifierHint: (() => getIdentifierHint('notebook template')),
                    addFuncMap: {
                        pythonDataset: DataikuAPI.plugindev.addNotebookTemplate.bind(this, "dataset", "python", false),
                        pythonStandalone: DataikuAPI.plugindev.addNotebookTemplate.bind(this, "standalone", "python", false),
                        pythonDatasetPrebuilt: DataikuAPI.plugindev.addNotebookTemplate.bind(this, "dataset", "python", true),
                        rDataset: DataikuAPI.plugindev.addNotebookTemplate.bind(this, "dataset", "r", false),
                        rStandalone: DataikuAPI.plugindev.addNotebookTemplate.bind(this, "standalone", "r", false),
                        rDatasetPrebuilt: DataikuAPI.plugindev.addNotebookTemplate.bind(this, "dataset", "r", true),
                        scalaDataset: DataikuAPI.plugindev.addNotebookTemplate.bind(this, "dataset", "scala", false),
                        scalaStandalone: DataikuAPI.plugindev.addNotebookTemplate.bind(this, "standalone", "scala", false)
                    }
                },
                {
                    name: "RMarkdown report template",
                    type: "customRMarkdownReportTemplates",
                    icon: 'icon-DKU_rmd',
                    iconColor: 'universe-color report',
                    description: "Create a new template for RMarkdown reports",
                    addDescriptors : [
                        { key : "rmarkdown", label: "RMarkdown" }
                    ],
                    addFuncMap: {
                        rmarkdown: DataikuAPI.plugindev.addRMarkdownReportTemplate
                    },
                    identifierPlaceholder : (() => COMPONENT_IDENTIFIER_PLACEHOLDER),
                    identifierHint : (() => getIdentifierHint('RMarkdown report template'))
                },
                 {
                    name: "Webapp",
                    type: "customWebApps",
                    icon: 'icon-eye',
                    iconColor: 'universe-color recipe-visual',
                    disabled: true,
                    disabledReason: "To create a new plugin webapp, you need to create it from an existing webapp in a project. Go to the advanced tab > Convert to plugin webapp.",
                    description: "Create a reusable webapp for custom visualization or interactive screen without code for the end user",
                },
                {
                    name: "Webapp template",
                    type: function(language = '') {
                        if (language.startsWith("bokeh")) {
                            return "customBokehWebAppTemplates"
                        }
                        if (language.startsWith("shiny")) {
                            return "customShinyWebAppTemplates"
                        }
                        if (language.startsWith("dash")) {
                            return "customDashWebAppTemplates"
                        }
                        return "customStandardWebAppTemplates";
                    },
                    icons: {
                        'customBokehWebAppTemplates': { icon: 'icon-bokeh', iconColor: 'universe-color recipe-code' },
                        'customDashWebAppTemplates': { icon: 'icon-dash', iconColor: 'universe-color recipe-code' },
                        'customShinyWebAppTemplates': { icon: 'icon-shiny', iconColor: 'universe-color recipe-code' },
                        'customStandardWebAppTemplates': { icon: 'icon-code', iconColor: 'universe-color recipe-code' }
                    },
                    description: "Create a new template for webapps",
                    addDescriptors: [
                        { key : "standard", label: "Standard webapp (JS/HTML/CSS/Python)" },
                        { key : "bokeh", label: "Bokeh webapp (Python)" },
                        { key : "dash", label: "Dash webapp (Python)" },
                        { key : "shiny", label: "Shiny webapp (R)" }
                    ],
                    addFuncMap: {
                        standard: DataikuAPI.plugindev.addStandardWebAppTemplate,
                        bokeh: DataikuAPI.plugindev.addBokehWebAppTemplate,
                        dash: DataikuAPI.plugindev.addDashWebAppTemplate,
                        shiny: DataikuAPI.plugindev.addShinyWebAppTemplate
                    },
                    identifierPlaceholder: (() => COMPONENT_IDENTIFIER_PLACEHOLDER),
                    identifierHint: (() => getIdentifierHint('template for webapps'))
                },
                {
                    name: "Scenario trigger",
                    type: "customPythonTriggers",
                    icon: 'icon-list',
                    iconColor: 'universe-color scenario',
                    description: "Create a new kind of trigger for scenarios",
                    addDescriptors: regularPyOnlyDescriptor,
                    addFuncMap: {
                        python: DataikuAPI.plugindev.addPythonTrigger
                    },
                    identifierPlaceholder: (() => COMPONENT_IDENTIFIER_PLACEHOLDER),
                    identifierHint: (() => getIdentifierHint('trigger'))
                },
                {
                    name: "Scenario step",
                    type: "customPythonSteps",
                    icon: 'icon-step-forward',
                    iconColor: 'universe-color scenario',
                    description: "Create a new kind of step for scenarios",
                    addDescriptors: regularPyOnlyDescriptor,
                    addFuncMap: {
                        python: DataikuAPI.plugindev.addPythonStep
                    },
                    identifierPlaceholder: (() => COMPONENT_IDENTIFIER_PLACEHOLDER),
                    identifierHint: (() => getIdentifierHint('scenario step'))
                },
                {
                    name: "Metrics probe",
                    type: function(language = '') {
                        if (language.startsWith("sql")) {
                            return "customSQLProbes"
                        }
                        return "customPythonProbes";
                    },
                    icons: {
                        'customSQLProbes': { icon: 'icon-subscript', iconColor: 'universe-color datasets' },
                        'customPythonProbes': { icon: 'icon-superscript', iconColor: 'universe-color datasets' }
                    },
                    description: "Create a new kind of probe to compute metrics, that can be applied on datasets",
                    addDescriptors: [
                        { key: "python", label: "Python" },
                        { key: "sql", label: "SQL"}
                    ],
                    addFuncMap: {
                        python: DataikuAPI.plugindev.addPythonProbe,
                        sql: DataikuAPI.plugindev.addSqlProbe
                    },
                    identifierPlaceholder: (() => COMPONENT_IDENTIFIER_PLACEHOLDER),
                    identifierHint: (() => getIdentifierHint('probe'))
                },
                {
                    name: "Check",
                    type: "customPythonChecks",
                    icon: 'icon-ok',
                    iconColor: 'universe-color dataset',
                    description: "Create a new kind of check that can be applied on datasets",
                    addDescriptors: regularPyOnlyDescriptor,
                    addFuncMap: {
                        python: DataikuAPI.plugindev.addPythonCheck,
                    },
                    identifierPlaceholder: (() => COMPONENT_IDENTIFIER_PLACEHOLDER),
                    identifierHint: (() => getIdentifierHint('check'))
                },
                {
                    name: "Exporter",
                    type: "customExporters",
                    icon: 'icon-dku-download',
                    iconColor: 'universe-color datasets',
                    description: "Create a new option to export dataset out of DSS. This can be export to file (that the user can download) or to custom destinations (like an external API). Exporters have only 'write' support. If you want 'read' support, you need to write a format instead",
                    addDescriptors: regularPyAndJavaDescriptors,
                    addFuncMap: {
                        java: DataikuAPI.plugindev.addJavaExporter,
                        python: DataikuAPI.plugindev.addPythonExporter
                    },
                    identifierPlaceholder: (() => COMPONENT_IDENTIFIER_PLACEHOLDER),
                    identifierHint: (() => getIdentifierHint('exporter'))
                },
                {
                    name: "File format",
                    type: "customFormats",
                    icon: 'icon-file',
                    iconColor: 'universe-color datasets',
                    description: "Create a new supported file format, that DSS uses to read and write on all files-based kinds of datasets (Filesystem, HDFS, S3, ...). Write support is optional",
                    addDescriptors: regularPyAndJavaDescriptors,
                    addFuncMap: {
                        java: DataikuAPI.plugindev.addJavaFormat,
                        python: DataikuAPI.plugindev.addPythonFormat
                    },
                    identifierPlaceholder: (() => COMPONENT_IDENTIFIER_PLACEHOLDER),
                    identifierHint: (() => getIdentifierHint('file format'))
                },
                {
                    name: "FS provider",
                    type: "customFileSystemProviders",
                    icon: 'icon-server_file_system_1',
                    iconList: 'universe-color datasets',
                    description: "Create a new kind of files-based system, usable both for dataset (together with a file format) or for managed folders. Examples include cloud storages, file sharing systems, ... Write support is optional.",
                    addDescriptors: regularPyAndJavaDescriptors,
                    addFuncMap: {
                        java: DataikuAPI.plugindev.addJavaFSProvider,
                        python: DataikuAPI.plugindev.addPythonFSProvider
                    },
                    identifierPlaceholder: (() => COMPONENT_IDENTIFIER_PLACEHOLDER),
                    identifierHint: (() => getIdentifierHint('FS provider'))
                },
                {
                    name: "Preparation processor",
                    type: "customJythonProcessors",
                    icon: 'icon-visual_prep_cleanse_recipe',
                    iconColor: 'universe-color recipe-visual',
                    description: "Create a new kind of step for preparation scripts",
                    addDescriptors: regularJythonOnlyDescriptor,
                    addFuncMap: {
                        jython: DataikuAPI.plugindev.addJythonProcessor
                    },
                    identifierPlaceholder: (() => COMPONENT_IDENTIFIER_PLACEHOLDER),
                    identifierHint: (() => getIdentifierHint('processor'))
                },
                {
                    name: "Prediction Algorithm",
                    type: "customPythonPredictionAlgos",
                    icon: 'icon-machine_learning_regression',
                    iconColor: 'universe-color recipe-train',
                    description: "Create a new prediction algorithm",
                    addDescriptors: regularPyOnlyDescriptor,
                    addFuncMap: {
                        python: DataikuAPI.plugindev.addPredictionPythonAlgorithm
                    },
                    identifierPlaceholder: (() => COMPONENT_IDENTIFIER_PLACEHOLDER),
                    identifierHint: (() => getIdentifierHint('prediction algorithm'))
                },
                {
                    name: "Cluster",
                    type: "customPythonClusters",
                    icon: 'icon-sitemap',
                    iconColor: 'universe-color more',
                    description: "(Expert usage) Create a new kind of cluster",
                    addDescriptors: regularPyOnlyDescriptor,
                    addFuncMap: {
                        python: DataikuAPI.plugindev.addPythonCluster
                    },
                    identifierPlaceholder: (() => COMPONENT_IDENTIFIER_PLACEHOLDER),
                    identifierHint: (() => getIdentifierHint('cluster'))
                },
                {
                    name: "Custom Fields",
                    type: "customFields",
                    icon: 'icon-list-ol',
                    iconColor: 'universe-color more',
                    description: "Create new custom fields",
                    addDescriptors : [{key: "json", label: "json"}],
                    addFuncMap: {
                        json: DataikuAPI.plugindev.addCustomFields
                    },
                    identifierPlaceholder : (() => COMPONENT_IDENTIFIER_PLACEHOLDER),
                    identifierHint : (() => getIdentifierHint('custom fields'))
                },
                {
                    name: "Custom Policy Hooks",
                    type: "customPolicyHooks",
                    icon: 'icon-legal',
                    iconColor: 'universe-color more',
                    description: "Create new custom policy hooks",
                    addDescriptors : [{key: "java", label: "Java"}],
                    addFuncMap: {
                        java: DataikuAPI.plugindev.addJavaPolicyHooks
                    },
                    identifierPlaceholder : (() => COMPONENT_IDENTIFIER_PLACEHOLDER),
                    identifierHint : (() => getIdentifierHint('custom policy hooks'))
                },
                {
                    name: "Dataiku Application Template",
                    type: "customAppTemplates",
                    icon: 'icon-tasks',
                    iconColor: 'universe-color more',
                    disabled: true,
                    disabledReason: "To create a new Dataiku application template, you need to create it from an existing application template project.",
                    description: "Create a new Dataiku application template"
                },
                {
                    name: "Exposition",
                    type: "customExpositions",
                    icon: 'icon-external-link',
                    iconColor: 'universe-color more',
                    description: "(Expert usage) Create a new exposition to expose webapps or API services running in containers.",
                    addDescriptors: regularJavaOnlyDescriptor,
                    addFuncMap: {
                        java: DataikuAPI.plugindev.addJavaExposition
                    },
                    identifierPlaceholder: (() => COMPONENT_IDENTIFIER_PLACEHOLDER),
                    identifierHint: (() => getIdentifierHint('exposition'))
                }
            ];
        };

        $scope.getComponentsTypeList = function(pluginInstallDesc) {
            if (!pluginInstallDesc || !pluginInstallDesc.content) {
                return [];
            }
            var componentsTypeList = [];
            Object.keys(pluginInstallDesc.content).forEach(function(contentType) {
                var contentList = pluginInstallDesc.content[contentType];
                if (contentList instanceof Array && contentList.length > 0) {
                    componentsTypeList.push(contentType);
                }
            });
            return componentsTypeList;
        };

        $scope.getComponentIcon = function(componentType, component = {}) {
            if (typeof componentType === 'function') {
                componentType = componentType();
            }

            let componentIcon = component.meta && component.meta.icon;
            let componentIconColor;

            if (componentType === 'customJavaPolicyHooks') {
                componentType = 'customPolicyHooks';
            }

            if (componentType === 'javaPreparationProcessors') {
                componentType = 'customJythonProcessors';
            }

            if (componentType === 'javaFormulaFunctions') {
                return 'universe-color analysis icon-beaker';
            }

            if (componentType === 'tutorials') {
                return 'universe-color more icon-dku-tutorial';
            }

            if (componentType === 'customParameterSets') {
                return 'universe-color more icon-indent-right';
            }

            if (componentType === 'featureFlags') {
                return 'universe-color more icon-dkubird';
            }

            for (let index = 0; index < $scope.contentTypeList.length; index++) {
                let currentType = $scope.contentTypeList[index].type;
                if (typeof currentType === 'function') {
                    let currentTypes = $scope.contentTypeList[index].icons;
                    if (!currentTypes) { continue; }
                    if (currentTypes[componentType]) {
                        componentIcon = componentIcon || currentTypes[componentType].icon;
                        componentIconColor = currentTypes[componentType].iconColor;
                        break;
                    }
                } else {
                    let currentType = $scope.contentTypeList[index].type;
                    if (currentType === componentType) {
                        componentIcon = componentIcon || $scope.contentTypeList[index].icon;
                        componentIconColor = $scope.contentTypeList[index].iconColor;
                        break;
                    }
                }
            }

            return componentIconColor + ' ' + componentIcon;
        };

        $scope.computeNbComponents = function(pluginInstallDesc) {
            if (!pluginInstallDesc || !pluginInstallDesc.content) {
                return 0;
            }
            var nbComponents = 0;
            Object.keys(pluginInstallDesc.content).forEach(function(contentType) {
                var contentList = pluginInstallDesc.content[contentType];
                if (contentList instanceof Array) {
                    nbComponents += contentList.length;
                }
            });
            if (pluginInstallDesc.desc && pluginInstallDesc.desc.featureFlags) {
                nbComponents += pluginInstallDesc.desc.featureFlags.length;
            }
            return nbComponents;
        };

        $scope.getPlugin = function() {
            if ($scope.appConfig.pluginDevGitMode === 'PLUGIN') {
                $scope.getGitFullStatus();
            }

            return DataikuAPI.plugindev.get($stateParams.pluginId).then(
                function (data) {
                    $scope.pluginData = data.data;
                    $scope.initContentTypeList();
                    //updateCodeEnvs();
                },
                setErrorInScope.bind($scope)
            );
        };

        $scope.downloadPlugin = function(pluginId = $stateParams.pluginId) {
            let url = '/dip/api/plugins/dev/download?pluginId=' + pluginId;
            downloadIframe.attr('src', url);
            $('body').append(downloadIframe);
        };

        $scope.deletePlugin = function(pluginId, callback) {
            CreateModalFromTemplate("/templates/plugins/development/delete-plugin-confirm-dialog.html", $scope, null, function(newScope) {

                var handlePluginDeleted = function() {
                    WT1.event("plugin-delete", { pluginId : newScope.pluginName });
                    if (callback === undefined) {
                        $state.transitionTo('plugins.installed');
                    } else {
                        callback();
                    }
                }

                newScope.pluginName = pluginId || $scope.pluginData.installedDesc.desc.id;
                DataikuAPI.plugins.prepareDelete(newScope.pluginName)
                .success(function(usageStatistics) {
                    newScope.usageStatistics = usageStatistics;
                }).error(setErrorInScope.bind($scope));
                newScope.confirmPluginDeletion = function() {
                    DataikuAPI.plugins.delete(newScope.pluginName, true).success(function(initialResponse) {
                        if (initialResponse && initialResponse.jobId && !initialResponse.hasResult) {                        
                            FutureWatcher.watchJobId(initialResponse.jobId)
                            .success(handlePluginDeleted)
                            .error(function(data, status, headers) {
                                setErrorInScope.bind($scope)(data, status, headers);
                            });
                        } else {
                            handlePluginDeleted();
                        }
                    }).error(setErrorInScope.bind($scope));
                }
            });
        };

        $scope.newComponentPopin = function() {
            CreateModalFromTemplate("/templates/plugins/development/new-component-modal.html", $scope, "NewComponentModalController");
        };
    });


    /**
     * @ngdoc directive
     * @name pluginEditCallbacks
     * @description
     *   This directive is composed on the scope above FolderEditController.
     *   It is responsible for setting up the callbacks needed to get/set/list
     *   files in the plugin folder
     */
    app.directive('pluginEditCallbacks', function(DataikuAPI, $stateParams, Dialogs, $state) {
        return {
            scope: false,
            restrict: 'A',
            link: {
                pre : function($scope, $element, attrs) {
                    $scope.folderEditCallbacks = {
                        list: function() {
                            return DataikuAPI.plugindev.listContents($stateParams.pluginId);
                        },
                        get: function(content, sendAnyway) {
                            return DataikuAPI.plugindev.getContent($stateParams.pluginId, content.path, sendAnyway);
                        },
                        previewImageURL: function(content) {
                            return '/dip/api/plugins/dev/preview-image?pluginId=' + $stateParams.pluginId + '&path=' + encodeURIComponent(content.path) + '&contentType=' + encodeURIComponent(content.mimeType);
                        },
                        set: function(content) {
                            return DataikuAPI.plugindev.setContent($stateParams.pluginId, content.path, content.data);
                        },
                        validate: function(contentMap) {
                            return DataikuAPI.plugindev.validate($stateParams.pluginId, contentMap);
                        },
                        setAll: function(contentMap) {
                            return DataikuAPI.plugindev.setContentMultiple($stateParams.pluginId, contentMap);
                        },
                        create: function(path, isFolder) {
                            return DataikuAPI.plugindev.createContent($stateParams.pluginId, path, isFolder);
                        },
                        delete: function(content) {
                            return DataikuAPI.plugindev.deleteContent($stateParams.pluginId, content.path);
                        },
                        decompress: function(content) {
                            return DataikuAPI.plugindev.decompressContent($stateParams.pluginId, content.path);
                        },
                        rename: function(content, newName) {
                            return DataikuAPI.plugindev.renameContent($stateParams.pluginId, content.path, newName);
                        },
                        checkUpload: function(contentPath, paths) {
                            return DataikuAPI.plugindev.checkUploadContent($stateParams.pluginId, contentPath, paths);
                        },
                        upload: function(contentPath, file, callback) {
                            return DataikuAPI.plugindev.uploadContent($stateParams.pluginId, contentPath, file, callback);
                        },
                        move: function(content, to) {
                            return DataikuAPI.plugindev.moveContent($stateParams.pluginId, content.path, (to ? to.path : ''));
                        },
                        copy: function(content) {
                            return DataikuAPI.plugindev.copyContent($stateParams.pluginId, content.path);
                        }
                    };
                    $scope.folderEditSaveWarning = 'You have unsaved changes to a plugin file, are you sure you want to leave?';
                    $scope.description = $stateParams.pluginId;
                    $scope.headerDescription = "Plugin Content"
                    $scope.rootDescription = '[plugin root]';
                    $scope.localStorageId = $stateParams.pluginId;
                }
            }
        };
    });

    app.filter("humanContentType", function() {
        var fromCamelCaseToHuman = function(str) {
            if (str == 'featureFlags') {
                return 'feature';
            }
            var humanStr = "";
            var upperCase = str.match(/[A-Z]/);
            while (upperCase) {
                humanStr += str.substring(0, upperCase.index) + " ";
                str = upperCase[0].toLowerCase() + str.substring(upperCase.index + 1);
                upperCase = str.match(/[A-Z]/);
            }
            humanStr += str;
            return humanStr;
        }

        return function(contentType) {

            let humanContentType;

            humanContentType = fromCamelCaseToHuman(contentType);

            if (contentType == "customRunnables") {
                humanContentType = "Macros";
            }

            humanContentType = humanContentType.replace("custom ", "");
            if (humanContentType === "code recipes") {
                humanContentType = "Recipes";
            }
            if (humanContentType[humanContentType.length - 1] == 's') {
                humanContentType = humanContentType.substring(0, humanContentType.length - 1);
            }
            return humanContentType;
        }
    });

    app.controller("PlugindevCreateController", function($scope, $element, DataikuAPI, _SummaryHelper, Dialogs, $state,
        WT1, TopNav, SpinnerService, FutureProgressModal, StateUtils, PluginsService) {

    	_SummaryHelper.addEditBehaviour($scope, $element);

        $scope.desc = {
            id: '',
            bootstrapMode: 'EMPTY',
            gitRepository: '',
            gitCheckout: '',
            gitPath: ''
        };

        $scope.pattern = PluginsService.namingConvention;

        $scope.bootstrap = function() {
            DataikuAPI.plugindev.create($scope.desc.id, $scope.desc.bootstrapMode,
                $scope.desc.gitRepository, $scope.desc.gitCheckout, $scope.desc.gitPath
            ).success(function(data) {
                FutureProgressModal.show($scope, data, "Creating plugin").then(function(result){
                    if (result) {
                        WT1.event("plugin-dev-create");
                        $scope.dismiss();
                        StateUtils.go.pluginDefinition(result.details);
                    }
                });
            }).error(setErrorInScope.bind($scope));
        };
    });

    app.controller("PlugindevEditionController", function($scope, DataikuAPI, $state, $stateParams, CreateModalFromTemplate, Dialogs, FutureProgressModal, TopNav, $controller, $filter, WT1, $timeout) {
        $controller('PlugindevCommonController', {$scope: $scope});
        $controller('PlugindevDefinitionController', {$scope});

        $scope.uiState = {
            envName : null,
            newEnvDeploymentMode : 'PLUGIN_MANAGED',
            state: $state
        };

        $scope.reloadPlugin = function() {
            return DataikuAPI.plugindev.reload($stateParams.pluginId).then(
                function(data) {
                    $scope.$broadcast("pluginReload");
                    return $scope.getPlugin();
                },
                setErrorInScope.bind($scope)
            );
        };

        $scope.modalCreateBranch = function(wantedBranch) {
            CreateModalFromTemplate("/templates/plugins/development/git/create-branch-modal.html", $scope, "PlugindevCreateBranchController", function(newScope){
                newScope.targetBranchName = wantedBranch || "";
            });
        };

        $scope.createBranchFromCommit = function(commitId) {
            CreateModalFromTemplate("/templates/plugins/development/git/create-branch-modal.html", $scope, "PlugindevCreateBranchController", function (newScope) {
                newScope.targetBranchName = "";
                newScope.commitId = commitId;
            });
        };

        $scope.focusBranchSearchInput = function() {
            $timeout(function() {
                angular.element('#branch-search-input').focus();
            }, 100);
        };

        $scope.reloadPlugin().then(function() {
            if ($scope.customCodeRecipeIdToOpen && $scope.pluginData && $scope.pluginData.installedDesc && $scope.pluginData.installedDesc.customCodeRecipes) {
                $scope.pluginData.installedDesc.customCodeRecipes.forEach(function(customCodeRecipe) {
                    if (customCodeRecipe.id == $scope.customCodeRecipeIdToOpen) {
                        $scope.openPluginContentInEditor(customCodeRecipe, 'customCodeRecipes');
                    }
                });
                $scope.customCodeRecipeIdToOpen = null;
            }
        });
    });

    app.controller("PlugindevDefinitionController", function($scope, DataikuAPI, StateUtils, CreateModalFromTemplate, TopNav, Dialogs, $filter, $stateParams) {
        /* Components */
        $scope.deleteComponent = function(event, content, contentType) {
            let contentName = content.id;
            event.stopPropagation();
            if (contentType) {
                contentType = $filter('humanContentType')(contentType).toLowerCase();
                if (contentType[contentType.length - 1] == 's') {
                    contentType = contentType.substring(0, contentType.length - 1);
                }
                contentName = contentType + " " + contentName;
            }

            var message = 'Are you sure you want to delete ' + contentName + ' ?';
            Dialogs.confirm($scope,'Delete ' + content.id, message).then(function() {
                DataikuAPI.plugindev.deleteContent($scope.pluginData.installedDesc.desc.id, content.folderName).success(function(data) {
                    $scope.reloadPlugin();
                }).error(setErrorInScope.bind($scope));
            });
        };

        $scope.createCodeEnvPopin = function() {
            CreateModalFromTemplate("/templates/plugins/development/code-env-creation-modal.html", $scope, "NewCodeEnvController");
        };

        $scope.removeCodeEnv = function() {
            DataikuAPI.plugindev.removeCodeEnv($scope.pluginData.installedDesc.desc.id).success(function() {
                $scope.reloadPlugin();
            }).error(setErrorInScope.bind($scope));
        }

        const FILE_TO_OPEN_MAP = {
            "customDatasets": "connector.json",
            "customCodeRecipes": "recipe.json",
            "customExporters": function(folderName) {
                if (folderName.startsWith('java')) {
                    return "jexporter.json";
                }
                return "exporter.py";
            },
            "customFormats": function(folderName) {
                if (folderName.startsWith('java')) {
                    return "jformat.json";
                }
                return "format.py";
            },
            "customPythonChecks": "check.py",
            "customPythonProbes": "probe.py",
            "customSQLProbes": "probe.sql",
            "customPythonSteps": "step.py",
            "customPythonClusters": "cluster.py",
            "customPythonTriggers": "trigger.py",
            "customRunnables": function(folderName) {
                if (folderName.startsWith('java')) {
                    return "runnable.json";
                }
                return "runnable.py";
            },
            "customWebApps": "webapp.json",
            "customStandardWebAppTemplates": "app.js",
            "customBokehWebAppTemplates": "backend.py",
            "customDashWebAppTemplates": "backend.py",
            "customShinyWebAppTemplates": "ui.R",
            "customRMarkdownReportTemplates": "script.Rmd",
            "customPythonNotebookTemplates": "notebook.ipynb",
            "customPythonDatasetNotebookTemplates": "notebook.ipynb",
            "customRNotebookTemplates": "notebook.ipynb",
            "customRDatasetNotebookTemplates": "notebook.ipynb",
            "customScalaNotebookTemplates": "notebook.ipynb",
            "customScalaDatasetNotebookTemplates": "notebook.ipynb",
            "customPreBuiltDatasetNotebookTemplates": "notebook.ipynb",
            "customJythonProcessors": "processor.py",
            "customFileSystemProviders": function(folderName) {
                if (folderName.startsWith('java')) {
                    return "fs-provider.json";
                }
                return "fs-provider.py";
            },
            "codeEnv": "desc.json",
            "customPythonPredictionAlgos": "algo.json",
            "customParameterSets": "preset.json",
            "customFields": "custom-fields.json",
            "customJavaPolicyHooks": function(folderName) {
                if (folderName.startsWith('java')) {
                    return "policy-hook.json";
                }
            },
            "customAppTemplates": "app.json",
            "customExpositions": "exposition.json"
        };

        $scope.hasFileToOpen = function(contentType) {
            return !!FILE_TO_OPEN_MAP[contentType];
        };

        $scope.openPluginContentInEditor = function(content, contentType) {
            var fileToOpen = FILE_TO_OPEN_MAP[contentType]
            if (fileToOpen) {
                if (typeof(fileToOpen) === "function") {
                    fileToOpen = fileToOpen(content.folderName);
                }
                fileToOpen = content.folderName + "/" + fileToOpen;
                openContentInEditor(fileToOpen);
            }
        };

        $scope.$on('PLUGIN_DEV_LIST:openCustomRecipeInEditor', function(event, id) {
            $scope.customCodeRecipeIdToOpen = id;
        });

        var openContentInEditor = function(path) {
            StateUtils.go.pluginEditor($stateParams.pluginId, path);
        };

        $scope.openPluginDescInEditor = function() {
            openContentInEditor("plugin.json");
        };

        /*
         * Filtering
         */

        $scope.filterQuery = {userQuery: ''};
        $scope.filteredContent = {};

        function filterContent(pluginInstallDesc) {
            let filteredContent = {};
            let types = $scope.getComponentsTypeList(pluginInstallDesc);
            types.forEach(function(type) {
                let filteredComponents = $filter('filter')(pluginInstallDesc.content[type], $scope.filterQuery.userQuery);
                if (filteredComponents.length) {
                    filteredContent[type] = filteredComponents;
                }
            });
            // Add feature flags as "fake components"
            if (pluginInstallDesc.desc.featureFlags) {
                const matchingFeatureFlag = $filter('filter')(pluginInstallDesc.desc.featureFlags, $scope.filterQuery.userQuery);
                if (matchingFeatureFlag.length > 0) {
                    filteredContent['featureFlags'] = $filter('filter')(pluginInstallDesc.desc.featureFlags, $scope.filterQuery.userQuery);
                    // Put in the same format as other components for simpler templates
                    filteredContent['featureFlags'] = filteredContent['featureFlags'].map(featureFlag => ({ id: featureFlag }));
                }
            }
            return filteredContent;
        }

        function filterContentOnChange() {
            if ($scope.pluginData && $scope.pluginData.installedDesc && $scope.pluginData.installedDesc.content) {
                $scope.filteredContent = filterContent($scope.pluginData.installedDesc);
            } else {
                $scope.filteredContent = {};
            }
        }

        $scope.$watch('pluginData', filterContentOnChange, true);
        $scope.$watch('filterQuery.userQuery', filterContentOnChange, true);

        $scope.getComponentsTypeListFiltered = function() {
            return Object.keys($scope.filteredContent);
        };

        $scope.validatePluginEnv = function() {
            $scope.pluginEnvUpToDate = true;
        }

        $scope.invalidatePluginEnv = function() {
            $scope.pluginEnvUpToDate = false;
        }
    });

    app.controller("PlugindevEditorController", function($scope, $stateParams) {
        $scope.filePath = $stateParams.filePath || '';
    });


    app.controller("PlugindevHistoryController", function($scope, $stateParams, DataikuAPI, $timeout, TopNav) {
        // $timeout here allows us to trigger this API call only once the plugin has been properly reloaded
        $timeout(() => {
            DataikuAPI.plugindev.git.getLog($stateParams.pluginId, null, 33).then(function(resp) {
                $scope.logEntries = resp.data.logEntries;
            }, setErrorInScope.bind($scope));
        });
    });

    function computeDefaultLanguage(contentType, previousLanguage) {
        const noPreviousLanguageDefined = previousLanguage === null;
        const previousLanguageInvalidForNewComponentType = !(previousLanguage in contentType.addFuncMap);
        const useDefaultLanguage = noPreviousLanguageDefined || previousLanguageInvalidForNewComponentType;
        if (useDefaultLanguage) {
            return contentType.addDescriptors[0].key;
        }
        return previousLanguage;
    }

    app.controller("NewComponentModalController", function($scope, $controller, $element, $timeout, $state, WT1, DKUtils,
        PluginsService) {
        $controller('PlugindevCommonController', {$scope});
        $controller('PlugindevDefinitionController', {$scope});

        $scope.pattern = PluginsService.namingConvention;

        $scope.newComponent = {
            contentType: null,
            contentLanguage: null,
            id: '',
            javaClassNameForPlugin: ''
        };

        function resetNewComponentSettings(contentType) {
            $scope.newComponent.contentType = contentType;
            $scope.newComponent.contentLanguage =
                computeDefaultLanguage(contentType, $scope.newComponent.contentLanguage);
            // Keep current id and class name if already chosen
        }

        $scope.selectContentType = function(contentType) {
            if (contentType && contentType.disabled) return; // nice try :)
            resetNewComponentSettings(contentType);
            $timeout(function() {
                $element.find('.language-select').selectpicker('refresh');
            });
        };

        $scope.isJava = function() {
            return $scope.newComponent.contentLanguage === 'java';
        };

        $scope.requiresLanguage = function (contentType) {
            return contentType && !(contentType.addDescriptors.length === 1 && contentType.addDescriptors[0].key === 'generic');
        };

        $scope.create = function() {
            if ($scope.isFormValid()) {
                const addThingFunc = $scope.newComponent.contentType.addFuncMap[$scope.newComponent.contentLanguage];
                addThingFunc($scope.pluginData.installedDesc.desc.id,
                    $scope.newComponent.id,
                    $scope.newComponent.javaClassNameForPlugin
                ).success(function(data) {
                    WT1.event("plugin-dev-add-" + $scope.newComponent.contentType.name + "-" + $scope.newComponent.contentLanguage);
                    $scope.dismiss();
                    $scope.getPlugin().then(function() {
                        let folderName = data.pathToFiles.substring($scope.pluginData.baseFolderPath.length);
                        if (folderName.startsWith("/")) {
                            folderName = folderName.substring(1);
                        }
                        let componentType = $scope.newComponent.contentType.type;
                        if (typeof($scope.newComponent.contentType.type) === "function") {
                            componentType = $scope.newComponent.contentType.type($scope.newComponent.contentLanguage);
                        }
                        if ($state.$current.name == "plugindev.editor") {
                            DKUtils.reloadState();
                        } else {
                            $scope.openPluginContentInEditor({folderName:folderName}, componentType);
                        }
                        $scope.reloadPlugin();
                    });
                }).error(setErrorInScope.bind($scope));
            }
        };

        $scope.isFormValid = function() {
            if (!$scope.newComponent.contentType) return false;
            const hasAddFunc = $scope.newComponent.contentLanguage && $scope.newComponent.contentType.addFuncMap[$scope.newComponent.contentLanguage];
            const hasClassName = !$scope.isJava() || ($scope.newComponent.javaClassNameForPlugin && $scope.newComponent.javaClassNameForPlugin.length > 0);
            return PluginsService.isValidComponentId($scope.newComponent.id, $scope.pluginData.installedDesc.desc.id, $scope.filteredContent[$scope.newComponent.contentType.type] || [])
                && hasAddFunc && hasClassName;
        };
    });

    app.controller("NewCodeEnvController", function($scope, $controller, WT1) {
        $controller('PlugindevCommonController', { $scope: $scope });
        $controller('PlugindevDefinitionController', {$scope});
        $scope.codeEnvData = $scope.contentTypeList.find(contentType => { return contentType.type === 'codeEnv'});
        $scope.uiState = {contentLanguage: computeDefaultLanguage($scope.codeEnvData, null)};

        $scope.create = function() {
            if ($scope.isFormValid()) {
                const addThingFunc = $scope.codeEnvData.addFuncMap[$scope.uiState.contentLanguage];
                addThingFunc($scope.pluginData.installedDesc.desc.id, undefined, undefined, $scope.forceConda).success(function(data) {
                    WT1.event("plugin-dev-create-code-env-" + $scope.uiState.contentLanguage);
                    $scope.dismiss();
                    $scope.getPlugin().then(function() {
                        let folderName = data.pathToFiles.substring($scope.pluginData.baseFolderPath.length);
                        if (folderName.startsWith("/")) {
                            folderName = folderName.substring(1);
                        }
                        $scope.openPluginContentInEditor({folderName:folderName}, 'codeEnv');
                        $scope.reloadPlugin();
                    });
                }).error(setErrorInScope.bind($scope));
            }
        };

        $scope.isFormValid = function() {
            return $scope.uiState.contentLanguage && $scope.codeEnvData && $scope.codeEnvData.addFuncMap[$scope.uiState.contentLanguage];
        };
    });

    /*
     * to add new modules to the existing app, some hacking around angular is needed. And
     * this hacking needs to happen in a config block, so that we have access to the
     * providers.
     * see http://benohead.com/angularjs-requirejs-dynamic-loading-and-pluggable-views/ for
     * explanations.
     */
    app.config(['$controllerProvider', '$compileProvider', '$filterProvider', '$provide', '$injector',
        function ($controllerProvider, $compileProvider, $filterProvider, $provide, $injector) {
            // only offer one granularity: module (no injecting just a controller, for ex)
            app.registerModule = function (moduleName) {
                var module = angular.module(moduleName);

                if (module.requires) {
                    // recurse if needed
                    for (var i = 0; i < module.requires.length; i++) {
                        app.registerModule(module.requires[i]);
                    }
                }

                var providers = {
                        $controllerProvider: $controllerProvider,
                        $compileProvider: $compileProvider,
                        $filterProvider: $filterProvider,
                        $provide: $provide
                    };

                angular.forEach(module._invokeQueue, function(invokeArgs) {
                    var provider = providers[invokeArgs[0]];
                    provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                });
                angular.forEach(module._configBlocks, function (fn) {
                    $injector.invoke(fn);
                });
                angular.forEach(module._runBlocks, function (fn) {
                    $injector.invoke(fn);
                });
            };
        }
    ]);

    app.service('CustomUISetup', function(PluginConfigUtils, DataikuAPI, $q, $stateParams) {
        return {
            setupCallPythonDo : function($scope, errorScope, pluginId, componentId, config, side) {
                // for custom ui: communication with the backend and holding session id
                $scope.uiInteraction = {pluginId:pluginId, componentId:componentId, sessionId:null}
                // This function is called when fetching data for custom forms.
                // See in the documentation: Fetching data for custom forms.
                $scope.callPythonDo = function(payload) {
                    var deferred = $q.defer();
                    DataikuAPI.plugins.callPythonDo($scope.uiInteraction.sessionId, $scope.uiInteraction.pluginId, $scope.uiInteraction.componentId, config, payload, $scope.recipeConfig, $stateParams.projectKey, $stateParams.clusterId, side).success(function(data) {
                        $scope.uiInteraction.sessionId = data.sessionId;
                        deferred.resolve(data.data);
                    }).error(function(data, status, headers, config, statusText, xhrStatus) {
                        setErrorInScope.bind(errorScope)(data, status, headers, config, statusText, xhrStatus);
                        deferred.reject("Failed to get test result for ui");
                    });
                    return deferred.promise;
                };
            }
        };
    });

    app.directive('customTemplateWithCallPythonDo', function(CustomUISetup) {
        return {
            restrict: 'E',
            templateUrl: 'templates/plugins/development/custom-template.html',
            link: function($scope, element, attrs) {
                CustomUISetup.setupCallPythonDo(
                    $scope,
                    $scope.$eval(attrs.errorScope),
                    $scope.$eval(attrs.pluginId),
                    $scope.$eval(attrs.componentId),
                    $scope.$eval(attrs.config),
                    attrs.side
                );
            }
        };
    });

    app.directive('customParamsForm', function(PluginConfigUtils, DataikuAPI, $q, $stateParams, CustomUISetup) {
        return {
            restrict: 'EA',
            scope: {
                pluginDesc: '=',
                componentId: '=',
                desc: '=',
                config: '=',
                columnsPerInputRole: '=', // propagate for form elements (for plugin recipes)
                recipeConfig: '='
            },
            templateUrl: '/templates/plugins/development/custom-form.html',
            link: function($scope, element, attrs) {
                var setupDone = false;
                var updateSetup = function() {
                    if ($scope.desc == null || setupDone) {
                        // nothing to setup, just skip
                    } else {
                        if ($scope.desc.paramsModule) {
                            app.registerModule($scope.desc.paramsModule);
                        }
                        if ($scope.desc.paramsTemplate) {
                            $scope.baseTemplateUrl = "/plugins/" + $scope.pluginDesc.id + "/resource/";
                            $scope.templateUrl = $scope.baseTemplateUrl + $scope.desc.paramsTemplate;
                        }
                        setupDone = true;
                    }
                }
                updateSetup();
                $scope.$watch('desc', updateSetup);
            }
        };
    });

    app.directive('autoconfigForm', function(Debounce) {
        return {
            restrict: 'EA',
            replace: false,
            scope: {
                params: '=',
                pluginId: '=',
                componentId: '=',
                model: '=',
                columnsPerInputRole: '=', // propagate for form elements (for plugin recipes)
                recipeConfig: '=',
                chart: '=',
                side: '@',
                activeDragDrop: '=',
                validity: '=',
                errorScope: '=',
                qaSelectorPrefix: '@?',
                viewMode: '=',
                isList: '='
            },
            templateUrl: '/templates/plugins/development/autoconfig-form.html',
            link: function ($scope) {
                $scope.qaSelectorPrefix = $scope.qaSelectorPrefix || 'data-qa-autoconfig-form-element';
                $scope.getQaSelector = function (paramId) {
                    return `${$scope.qaSelectorPrefix}-${paramId}`;
                };
                $scope.addReloadCustomChoicesCallback = function (reloadCustomChoicesCallback) {
                    if ($scope.reloadFunctions === undefined) {
                        $scope.reloadFunctions = [];
                    }
                    $scope.reloadFunctions.push(reloadCustomChoicesCallback);
                };

                function onModelUpdates() {
                    const isNotInitialization = $scope.hasOwnProperty('reloadFunctions');
                    if (isNotInitialization) {
                        for (const reloadFunction of $scope.reloadFunctions) {
                            reloadFunction();
                        }
                    }
                }
                $scope.$watch('model', Debounce().withDelay(1000, 1000).wrap(onModelUpdates), true)
            }
        };
    });

    function initChartWebAppBar(isLeftBar) {
        return function (scope) {
            var loadedType = null;
            scope.$watch('chart.def.$loadedDesc', function () { // all the other values are set at the same time
                if (!scope.chart || !scope.chart.def) return;
                if (scope.chart.def.$loadedDesc != null && scope.chart.def.$loadedDesc.webappType !== loadedType) {
                    scope.config = scope.chart.def.webAppConfig;
                    if (isLeftBar) {
                        scope.optionsFolds.webapp = true;
                    }

                    loadedType = scope.chart.def.$loadedDesc.webappType;

                    scope.loadedDesc = scope.chart.def.$loadedDesc;
                    scope.pluginChartDesc = scope.chart.def.$pluginChartDesc;
                    scope.pluginDesc = scope.chart.def.$pluginDesc;
                    scope.componentId = scope.chart.def.$loadedDesc.id;

                    const module = isLeftBar ? scope.pluginChartDesc.leftBarModule : scope.pluginChartDesc.topBarModule;
                    if (module) {
                        app.registerModule(module);
                    }
                    const template = isLeftBar ? scope.pluginChartDesc.leftBarTemplate : scope.pluginChartDesc.topBarTemplate;
                    if (template) {
                        scope.baseTemplateUrl = '/plugins/' + scope.pluginDesc.id + '/resource/';
                        scope.templateUrl = scope.baseTemplateUrl + template;
                    } else {
                        scope.baseTemplateUrl = null;
                        scope.templateUrl = null;
                    }
                }
            });
        };
    }

    const initChartLeftBarWebApp = initChartWebAppBar(true);
    const initChartRightBarWebApp = initChartWebAppBar(false);

    app.controller("WebAppChartLeftBarController", function($scope) {
        initChartLeftBarWebApp($scope);
    });

    app.controller("WebAppChartTopBarController", function($scope) {
        initChartRightBarWebApp($scope);
    });

    app.directive('customAdminParamsForm', function(PluginConfigUtils, DataikuAPI, $q, $stateParams) {
        return {
            restrict: 'EA',
            scope: {
                pluginDesc: '=',
                componentId: '=',
                desc: '=',
                config: '=',
                columnsPerInputRole: '=', // propagate for form elements (for plugin recipes)
                recipeConfig: '='
            },
            templateUrl: '/templates/plugins/development/custom-admin-form.html',
            link: function($scope, element, attrs) {
            }
        };
    });

    app.directive('pluginSettingsAlert', function($state) {
        return {
            restrict: 'EA',
            scope: {
                componentType :'@',
                appConfig: '=',
                hasSettings: '=',
                pluginDesc: '='
            },
            templateUrl: '/templates/plugins/development/plugin-settings-alert.html',
            link : function($scope, element, attrs) {
                if ($scope.pluginDesc) {
                    $scope.pluginLink = $scope.pluginDesc.isDev ? "plugindev.settings({pluginId: '" + $scope.pluginDesc.id + "'})" : "plugin.settings({pluginId: '" + $scope.pluginDesc.id + "'})";
                } else {
                    $scope.pluginLink = "plugins.installed";
                }
            }
        };
    });

})();

(function() {
'use strict';

const app = angular.module('dataiku.plugindev.git',  ['dataiku.git']);


app.controller("_PlugindevGitController", function($scope, DataikuAPI, $state, $stateParams, CreateModalFromTemplate,
                                                   Dialogs, FutureProgressModal, DKUtils, $filter, WT1, FullGitSupportService) {
    $scope.getGitFullStatus = function(cb) {
        return FullGitSupportService.getFullStatus($scope,
                    DataikuAPI.plugindev.git.getFullStatus($stateParams.pluginId),
                    cb);
    };

    $scope.modalRemoveRemote = function() {
        const callback = function(remoteName) {
            WT1.event("plugindev-git-remove-remote", {pluginId: $stateParams.pluginId});
            DataikuAPI.plugindev.git.removeRemote($stateParams.pluginId, remoteName).then(function() {
                $scope.getGitFullStatus();
                $scope.getGitBranches();
            }, setErrorInScope.bind($scope));
        };
        FullGitSupportService.removeRemote($scope, callback);
    };

    $scope.getGitBranches = function () {
         return FullGitSupportService.getBranches($scope, DataikuAPI.plugindev.git.listBranches($stateParams.pluginId));
    };

    $scope.filterBranches = function (query) {
        $scope.gitBranchesFiltered = $filter("filter")($scope.gitBranches, query);
    };

    $scope.formatTrackingCount = function(count) {
        return count != null ? count : "-";
    };

    $scope.postSaveCallback = function() {
        // We want to update the tracking count after the save when autocommit is enabled
        if ($scope.appConfig.pluginDevExplicitCommit === false && $scope.appConfig.pluginDevGitMode === 'PLUGIN') {
            $scope.getGitFullStatus();
        }
    };

    $scope.modalFetch = function() {
        WT1.event("plugindev-git-fetch", {pluginId: $stateParams.pluginId});
        FullGitSupportService.fetch($scope, DataikuAPI.plugindev.git.fetch($stateParams.pluginId));
    };

    $scope.modalPull = function() {
        WT1.event("plugindev-git-pull", {pluginId: $stateParams.pluginId});
        FullGitSupportService.pull($scope, DataikuAPI.plugindev.git.pull($stateParams.pluginId));
    };

    $scope.modalPush = function() {
        WT1.event("plugindev-git-push", {pluginId: $stateParams.pluginId});
        FullGitSupportService.push($scope, DataikuAPI.plugindev.git.push($stateParams.pluginId));
    };

    $scope.modalAddOrEditRemote = function() {
        const callback = function(remoteName, newURL) {
            WT1.event("plugindev-git-set-remote", {pluginId: $stateParams.pluginId});
            DataikuAPI.plugindev.git.setRemote($stateParams.pluginId, remoteName, newURL).then(function() {
                $scope.getGitFullStatus();
            }, setErrorInScope.bind($scope));
        };
        FullGitSupportService.editRemote($scope, callback);
    };

    $scope.switchToBranch = function(branchName) {
        WT1.event("plugindev-git-switch-branch", {pluginId: $stateParams.pluginId});
        FullGitSupportService.switchToBranch($scope, DataikuAPI.plugindev.git.switchBranch($stateParams.pluginId, branchName));
    };

    $scope.modalDeleteLocalBranches = function() {
        const callback = function(modalScope, branchesToDelete, deleteOptions) {
            WT1.event("plugindev-git-delete-branches", {pluginId: $stateParams.pluginId});
            DataikuAPI.plugindev.git.deleteBranches($stateParams.pluginId, branchesToDelete, deleteOptions).then(function() {
                $state.reload();
                modalScope.dismiss();
            }, setErrorInScope.bind(modalScope));
        };
        FullGitSupportService.deleteBranches($scope, callback);
    };

    $scope.needsExplicitCommit = function(){
        return $scope.appConfig.pluginDevExplicitCommit;
    };

    $scope.modalCommit = function() {
        CreateModalFromTemplate("/templates/plugins/development/git/commit-modal.html", $scope, "PlugindevCommitController");
    };

    $scope.getResetModes = function() {
        let modes = [];

        if ($scope.appConfig.pluginDevExplicitCommit)
            modes.push('HEAD');

        if ($scope.gitStatus.hasRemoteOrigin && $scope.gitStatus.hasTrackingCount)
            modes.push('UPSTREAM');

        return modes;
    };

    $scope.modalReset = function() {
        CreateModalFromTemplate("/templates/plugins/development/git/reset-modal.html", $scope, "PlugindevResetController");
    };

    $scope.$on('pluginReload',function() {
        $scope.getGitBranches();
    });

    $scope.canChangeRemote = true;
    $scope.canChangeBranch = true;
    $scope.canUpdateContent = true;
});


app.controller("PlugindevCreateBranchController", function($scope, $stateParams, DataikuAPI, $state) {
    $scope.createBranch = function() {
        DataikuAPI.plugindev.git.createBranch($stateParams.pluginId, $scope.targetBranchName, $scope.commitId).then(function() {
            $state.reload();
            $scope.dismiss();
        }, setErrorInScope.bind($scope));
    };
});

app.controller("PlugindevCommitController", function($scope, $stateParams, $filter, DataikuAPI, ActivityIndicator, $timeout, WT1) {
    DataikuAPI.plugindev.git.prepareCommit($stateParams.pluginId).then(function(resp) {
        $scope.preparationData = resp.data;
    }, setErrorInScope.bind($scope));

    $scope.uiState = {
        activeTab: 'message',
        message: ''
    };

    $timeout(() => {
        // Magic happens here: if commitEditorOptions is defined too early, the textarea won't properly autofocus
        $scope.commitEditorOptions = {
            mode : 'text/plain',
            lineNumbers : false,
            matchBrackets : false,
            autofocus: true,
            onLoad : function(cm) {$scope.codeMirror = cm;}
        };
    }, 100);


    $scope.gitCommit = function() {
        WT1.event("plugindev-git-commit", {pluginId: $stateParams.pluginId});
        DataikuAPI.plugindev.git.commit($stateParams.pluginId, $scope.uiState.message).then(function() {
                ActivityIndicator.success('Changes successfully committed.');
                $scope.dismiss();
                $scope.getGitFullStatus();
            },
            setErrorInScope.bind($scope));
    };
});


app.controller("PlugindevResetController", function($scope, $filter, $stateParams, DataikuAPI, ActivityIndicator, Dialogs, $state, WT1) {
    $scope.resetStrategy = $scope.getResetModes()[0];

    $scope.setStrategy = function(strategy) {
        if ($scope.getResetModes().includes(strategy)) {
            $scope.resetStrategy = strategy;
        }
    };

    $scope.gitReset = function() {
        const resetToUpstream = () => DataikuAPI.plugindev.git.resetToUpstream($stateParams.pluginId);
        const resetToHead = () => DataikuAPI.plugindev.git.resetToHead($stateParams.pluginId);
        const resetAPICall = $scope.resetStrategy === 'HEAD' ? resetToHead : resetToUpstream;
        WT1.event("plugindev-git-reset", {pluginId: $stateParams.pluginId, resetStrategy: $scope.resetStrategy});

        resetAPICall().then(function () {
                ActivityIndicator.success('Reset succeeded.');
                $state.reload();
                $scope.dismiss();
            },
            setErrorInScope.bind($scope));
    };
});


app.directive("pluginGitLog", function($controller, DataikuAPI, $stateParams) {
    return {
        templateUrl: "/templates/git/git-log.html",
        scope: {
            logEntries: '=',
            lastStatus: '=',
            objectRevertable: '=',
            objectRef: '=',
            projectRevertable: '=',
            commitRevertable: '=',
            noCommitDiff: '=',
            createBranchFromCommit: '='
        },
        link: function ($scope, element) {
            const pluginGitAPI = {
                getRevisionsDiff: (commitFrom, commitTo) => DataikuAPI.plugindev.git.getRevisionsDiff($stateParams.pluginId, commitFrom, commitTo),
                getCommitDiff: (commitId) => DataikuAPI.plugindev.git.getCommitDiff($stateParams.pluginId, commitId),
                revertObjectToRevision: () => console.warn("`revertObjectToRevision` should not be fired on a plugin"),  // NOSONAR: OK to use console.
                revertProjectToRevision: (hash) => DataikuAPI.plugindev.git.revertPluginToRevision($stateParams.pluginId, hash),
                revertSingleCommit: (hash) => DataikuAPI.plugindev.git.revertSingleCommit($stateParams.pluginId, hash),
                createBranchFromCommit: $scope.createBranchFromCommit
            };

            $controller('_gitLogControllerBase', {$scope: $scope, element: element, DataikuGitAPI: pluginGitAPI,
                                                  objectType: "plugin"});
        }
    }
});


app.directive('branchPopup', function ($stateParams, DataikuAPI,$rootScope,$timeout,CreateModalFromTemplate,Dialogs) {
    return {
        controller: function ($scope) {
        },
        link:function (scope, element, attr) {
        },
        templateUrl: '/templates/plugins/development/git/branch-popup.html"'
    };
});


})();

(function(){
'use strict';

    const app = angular.module('dataiku.folder_edit', []);


    /**
     * @ngdoc directive
     * @name zoneEditCallbacks
     * @description
     *   This directive is composed on the scope above FolderEditController.
     *   It is responsible for setting up the callbacks needed to get/set/list
     *   files in a zone of the admin section.
     */
    app.directive('zoneEditCallbacks', function(DataikuAPI, $stateParams, Dialogs, $state) {
        return {
            scope: false,
            restrict: 'A',
            link: {
                pre: function($scope, $element, attrs) {
                    var zone = attrs.zone;
                    $scope.folderEditCallbacks = {
                        list: function() {
                            return DataikuAPI.admin.folderEdit.listContents(zone);
                        },
                        get: function(content, sendAnyway) {
                            return DataikuAPI.admin.folderEdit.getContent(zone, content.path, sendAnyway);
                        },
                        previewImageURL: function(content) {
                            return '/dip/api/admin/folder-edition/preview-image?type=' + zone + '&path=' + encodeURIComponent(content.path) + '&contentType=' + encodeURIComponent(content.mimeType);
                        },
                        set: function(content) {
                            return DataikuAPI.admin.folderEdit.setContent(zone, content.path, content.data);
                        },
                        // validate: function(contentMap) {
                        //     return DataikuAPI.admin.folderEdit.validate(zone, contentMap);
                        // },
                        setAll: function(contentMap) {
                            return DataikuAPI.admin.folderEdit.setContentMultiple(zone, contentMap);
                        },
                        create: function(path, isFolder) {
                            return DataikuAPI.admin.folderEdit.createContent(zone, path, isFolder);
                        },
                        delete: function(content) {
                            return DataikuAPI.admin.folderEdit.deleteContent(zone, content.path);
                        },
                        decompress: function(content) {
                            return DataikuAPI.admin.folderEdit.decompressContent(zone, content.path);
                        },
                        rename: function(content, newName) {
                            return DataikuAPI.admin.folderEdit.renameContent(zone, content.path, newName);
                        },
                        checkUpload: function(contentPath, paths) {
                            return DataikuAPI.admin.folderEdit.checkUploadContent(zone, contentPath, paths);
                        },
                        upload: function(contentPath, file, callback) {
                            return DataikuAPI.admin.folderEdit.uploadContent(zone, contentPath, file, callback);
                        },
                        move: function(content, to) {
                            return DataikuAPI.admin.folderEdit.moveContent(zone, content.path, (to ? to.path : ''));
                        },
                        copy: function(content) {
                            return DataikuAPI.admin.folderEdit.copyContent(zone, content.path);
                        }
                    };
                    $scope.folderEditSaveWarning = 'You have unsaved changes to a file, are you sure you want to leave?';
                    $scope.rootDescription = attrs.rootDescription || '[' + zone + ']';
                    $scope.description =  $state.includes('libedition.libpython') ? 'lib-python' : $state.includes('libedition.libr') ? 'lib-r' : 'local-static';
                    $scope.headerDescription = $state.includes('libedition.localstatic') ? "Web Resources Content" : "Library Content";
                    $scope.localStorageId = $state.includes('libedition.libpython') ? 'lib-python' : $state.includes('libedition.libr') ? 'lib-r' : 'local-static';
                }
            }
        };
    });

    /**
     * @ngdoc directive
     * @name projectZoneEditCallbacks
     * @description
     *   same as zoneEditCallbacks but for the folders inside a project
     */
    app.directive('projectZoneEditCallbacks', function(DataikuAPI, $stateParams, Dialogs, $state, CreateModalFromTemplate, FutureProgressModal, DKUtils) {
        return {
            scope: false,
            restrict: 'A',
            link: {
                pre: function($scope, $element, attrs) {
                    var zone = attrs.zone;
                    var projectKey = $stateParams.projectKey;
                    $scope.folderEditCallbacks = {
                        list: function() {
                            return DataikuAPI.projects.folderEdit.listContents(projectKey, zone);
                        },
                        get: function(content, sendAnyway) {
                            return DataikuAPI.projects.folderEdit.getContent(projectKey, zone, content.path, sendAnyway);
                        },
                        previewImageURL: function(content) {
                            return '/dip/api/projects/folder-edition/preview-image?projectKey=' + projectKey + '&type=' + zone + '&path=' + encodeURIComponent(content.path) + '&contentType=' + encodeURIComponent(content.mimeType);
                        },
                        set: function(content) {
                            return DataikuAPI.projects.folderEdit.setContent(projectKey, zone, content.path, content.data);
                        },
                        // validate: function(contentMap) {
                        //     return DataikuAPI.projects.folderEdit.validate(projectKey, zone, contentMap);
                        // },
                        setAll: function(contentMap) {
                            return DataikuAPI.projects.folderEdit.setContentMultiple(projectKey, zone, contentMap);
                        },
                        create: function(path, isFolder) {
                            return DataikuAPI.projects.folderEdit.createContent(projectKey, zone, path, isFolder);
                        },
                        delete: function(content) {
                            return DataikuAPI.projects.folderEdit.deleteContent(projectKey, zone, content.path);
                        },
                        decompress: function(content) {
                            return DataikuAPI.projects.folderEdit.decompressContent(projectKey, zone, content.path);
                        },
                        rename: function(content, newName) {
                            return DataikuAPI.projects.folderEdit.renameContent(projectKey, zone, content.path, newName);
                        },
                        checkUpload: function(contentPath, paths) {
                            return DataikuAPI.projects.folderEdit.checkUploadContent(projectKey, zone, contentPath, paths);
                        },
                        upload: function(contentPath, file, callback) {
                            return DataikuAPI.projects.folderEdit.uploadContent(projectKey, zone, contentPath, file, callback);
                        },
                        move: function(content, to) {
                            return DataikuAPI.projects.folderEdit.moveContent(projectKey, zone, content.path, (to ? to.path : ''));
                        },
                        copy: function(content) {
                            return DataikuAPI.projects.folderEdit.copyContent(projectKey, zone, content.path);
                        }
                    };

                    $scope.folderEditSaveWarning = 'You have unsaved changes to a file, are you sure you want to leave?';
                    $scope.description =  "lib";
                    $scope.headerDescription = $state.includes('projects.project.libedition.localstatic') ? "Web Resources Content" : "Library Content"
                    $scope.localStorageId = "lib" + "-" + projectKey;
                }
            }
        };
    });

    /**
     * @ngdoc directive
     * @name projectZoneGitRefCallbacks
     * @description
     *   This directive is composed on the scope above FolderEditController.
     *   It is responsible for setting up the callbacks needed to get/set/list/rm git references.
     */
    app.directive('projectZoneGitRefCallbacks', function(DataikuAPI, $stateParams, WT1) {
        return {
            scope : false,
            restrict : 'A',
            link : {
                pre : function($scope) {
                    $scope.gitRefCallbacks = {
                        set: function (gitRef, gitRefPath, addPythonPath) {
                            WT1.event("project-libs-git-refs-save");
                            return DataikuAPI.git.setProjectGitRef($stateParams.projectKey, gitRef, gitRefPath, addPythonPath);
                        },
                        rm: function (gitRefPath, deleteDirectory) {
                            WT1.event("project-libs-git-refs-rm", {"delete-directory": deleteDirectory});
                            return DataikuAPI.git.rmProjectGitRef($stateParams.projectKey, gitRefPath, deleteDirectory);
                        },
                        pullOne: function (gitRefPath) {
                            WT1.event("project-libs-git-refs-pull-one");
                            return DataikuAPI.git.pullProjectGitRef($stateParams.projectKey, gitRefPath);
                        },
                        pullAll: function () {
                            WT1.event("project-libs-git-refs-pull-all");
                            return DataikuAPI.git.pullProjectGitRefs($stateParams.projectKey);
                        }
                    }
                }
            }
        };
    });

    app.controller('TopLevelFolderEditionController', function($scope, DataikuAPI, $state, $stateParams, CreateModalFromTemplate, TopNav) {
        TopNav.setLocation(TopNav.DSS_HOME, "administration");
        TopNav.setNoItem();

        $scope.pythonEmptyCta = {
            title: "No shared python code on this " + $scope.wl.productLongName + " instance.",
            text: "Create your own libraries or helpers and share them within all the " + $scope.wl.productShortName + " instance. The contents of 'lib-python' are accessible to python recipes and notebooks just like regular python libraries.",
            btnAction: "create",
            btnLabel: "Create your first shared python file"
        }

        $scope.rEmptyCta = {
            title: "No shared R code on this " + $scope.wl.productLongName + " instance.",
            text: "Create your own libraries and share them within all the " + $scope.wl.productShortName + " instance. The contents of 'lib-r' are accessible to R recipes and notebooks just like regular R libraries.",
            btnAction: "create",
            btnLabel: "Create your first shared R file"
        }
    });

    app.controller('TopLevelLocalStaticEditorController', function($scope, DataikuAPI, $state, $stateParams, CreateModalFromTemplate, TopNav, $rootScope) {
        TopNav.setLocation(TopNav.DSS_HOME, "administration");
        TopNav.setNoItem();

        $scope.emptyCta = {
            title: "No static web resources on this " + $scope.wl.productLongName + " instance.",
            text: "Create and upload your static web resources and use them for your webapps within all the " + $scope.wl.productShortName + " instance. Right click on local-static root folder and create or upload your files.",
            btnAction: "upload",
            btnLabel: "Upload your first resource"
        }
    });

    app.controller('ProjectFolderEditionController', function($scope, DataikuAPI, $state, $stateParams, CreateModalFromTemplate, TopNav, $rootScope) {
        TopNav.setLocation(TopNav.TOP_NOTEBOOKS, 'libraries', TopNav.TABS_NONE, null);
        TopNav.setNoItem();

        $scope.projectNoTabsCta = {
            title: "Project shared code",
            text: "Create your own libraries or helpers and share them within the project. These will be available to Python or R recipes and notebooks"
        };
    });

    app.directive('folderContentEditor', function(DataikuAPI, $stateParams, Dialogs, $state, CreateModalFromTemplate, $q,
                                                  $timeout, LocalStorage, $rootScope, openDkuPopin, Logger, CodeMirrorSettingService,
                                                  FutureProgressModal, DKUtils) {
        return {
            scope: true,
            restrict: 'A',
            templateUrl: '/templates/plugins/development/fragments/folder-content-editor.html',
            link: function($scope, $element, attrs) {
                $scope.editorOptions = null;
                $scope.uiState = {
                    foldRoot: false
                };

                /* Attributes with inherited scope */
                $scope.emptyCta = $scope.$eval(attrs.emptyCta);
                $scope.noTabsCta = $scope.$eval(attrs.noTabsCta);
                $scope.canCommit = $scope.$eval(attrs.canCommit);
                $scope.commitFn = $scope[attrs.commitFn];

                const postSaveCallback = () => {
                    if (attrs.postSaveCallback) {
                        $scope[attrs.postSaveCallback]();
                    }
                };
                const initialPath = attrs.initialPath;

                if (initialPath) {
                    $scope.openOnLoad = initialPath;
                }

                /*
                 * Listing plugin content
                 */

                $scope.listContents = function() {
                    return $scope.folderEditCallbacks.list().success(function(data){
                        // save the expanded states
                        var recGetExpandedState = function(content, map) {
                            if (content.children != null) {
                                map[content.path] = content.expanded || false;
                                content.children.forEach(function(subContent) {recGetExpandedState(subContent, map);});
                            }
                        };
                        var oldStates = {};
                        if ($scope.devContents != null ) {
                            $scope.devContents.forEach(function(content) {recGetExpandedState(content, oldStates);});
                        }
                        recGetExpandedState(oldStates);
                        // set the new state of the contents tree
                        $scope.devContents = data;
                        // put the old expanded states back
                        var recSetExpandedState = function(content, map) {
                            if (content.children != null) {
                                content.expanded = map[content.path] || false;
                                content.children.forEach(function(subContent) {recSetExpandedState(subContent, map);});
                            }
                        };
                        if ($scope.devContents != null ) {
                            $scope.devContents.forEach(function(content) {recSetExpandedState(content, oldStates);});
                        }
                        var recSetDepth = function(content, depth) {
                            content.depth = depth;
                            if (content.children != null) {
                                content.children.forEach(function(subContent) {recSetDepth(subContent, depth + 1);});
                            }
                        };
                        if ($scope.devContents != null ) {
                            $scope.devContents.forEach(function(content) {recSetDepth(content, 1);});
                        }

                        if ($scope.gitRefCallbacks) {
                            const recSetGit = function(externalLibs, content, gitSubPath) {
                                if (gitSubPath || content.path in externalLibs.gitReferences) {
                                    content.fromGit = true;
                                }
                                if (externalLibs.pythonPath.includes(content.path)) {
                                    content.inPythonPath = true;
                                }
                                if (externalLibs.rsrcPath.includes(content.path)) {
                                    content.inRSrcPath = true;
                                }
                                if (content.children != null) {
                                    content.children.forEach(subContent => {recSetGit(externalLibs, subContent, content.fromGit);});
                                }
                            };

                            DataikuAPI.git.getProjectExternalLibs($stateParams.projectKey).then(result => {
                                $scope.externalLibs = result.data;
                                $scope.gitReferences = result.data.gitReferences;

                                if ($scope.devContents != null) {
                                    $scope.devContents.forEach(content => {recSetGit($scope.externalLibs, content, false);});
                                }
                            }, setErrorInScope.bind($scope));
                        }
                    }).error(setErrorInScope.bind($scope));
                };
                $scope.listContents().success(function() {
                    openSavedTabs();
                    if ($scope.openOnLoad) {
                        openFileFromExternal($scope.openOnLoad);
                        $scope.openOnLoad = null;
                    }
                });

                $scope.sortFolder = function(content) {
                    content.sort(function(c1, c2) {
                        if (c1.children && !c2.children) {
                            return -1;
                        }
                        if (!c1.children && c2.children) {
                            return 1;
                        }
                        return c1.name > c2.name ? 1 : -1;
                    });
                    return content;
                };

                /*
                 * Opening and closing tabs
                 */

                $scope.originalContentMap = {};
                $scope.editedContentMap = {};
                $scope.activeTabIndex = -1;

                $scope.openFile = function(file) {
                    if (!$scope.canBeDecompressed(file)) {
                        var tabIndex = $scope.addTab(file);
                        $scope.updateActiveTab(tabIndex);
                        if (typeof($scope.unregisterArrowSliderInit) === "function") {
                            $scope.unregisterArrowSliderInit();
                        }
                    }
                }

                $scope.addTab = function(file) {
                    var tabIndex = $scope.tabsList.map(function(f){return f.path}).indexOf(file.path);
                    if (tabIndex == -1) {
                        $scope.tabsList.push(file);
                        tabIndex = $scope.tabsList.length - 1;
                    }
                    return tabIndex;
                };

                $scope.updateActiveTab = function(tabIndex) {
                    if (tabIndex != -1 && tabIndex < $scope.tabsList.length && $scope.tabsList[tabIndex]) {
                        var fileToOpen = $scope.tabsList[tabIndex];
                        //saving scroll position
                        var currentContent = $scope.getCurrentContent();
                        if (currentContent) {
                            saveTabScrollPosition(currentContent.path, $('.CodeMirror-scroll').scrollTop());
                        }
                        //updating tab index
                        $scope.activeTabIndex = tabIndex;
                        saveActiveTab();
                        //scrolling through tabs if necessary
                        $timeout(function() {
                            if ($scope.needSlider()) {
                                slideToTab(fileToOpen.path);
                            }
                        });
                        //replacing editor's content
                        if ($scope.editedContentMap[fileToOpen.path]) {
                            setCurrentContent(fileToOpen);
                        } else {
                            loadAndSetCurrentContent(fileToOpen, true);
                        }
                    }
                }

                var loadAndSetCurrentContent = function(file, sendAnyway) {
                    $scope.folderEditCallbacks.get(file, sendAnyway).success(function(data){
                        $scope.originalContentMap[file.path] = angular.copy(data);
                        $scope.editedContentMap[file.path] = data;
                        setCurrentContent(file);
                    }).error(setErrorInScope.bind($scope));
                };

                var setCurrentContent = function(file) {
                    var mimeType = selectSyntaxicColoration(file.name, file.mimeType);

                    $scope.editorOptions = CodeMirrorSettingService.get(mimeType, {
                        onLoad: function(codeMirror) {
                            $timeout(function() {
                                codeMirror.scrollTo(0, $scope.getTabScrollPosition(file.path));
                            });
                        }
                    });
                };

                var selectSyntaxicColoration = function(fileName, mimeType) {
                    if (mimeType == 'application/sql' ) {
                        return 'text/x-sql'; // codemirror prefers this one
                    }
                    if (fileName.match(/.*\.java$/)) {
                        return 'text/x-java';
                    }
                    return mimeType
                };

                var refreshSyntaxicColoration = function(fileName, mimeType) {
                    $scope.editorOptions.mode = selectSyntaxicColoration(fileName, mimeType);
                };

                var closeContent = function(file) {
                    var tabIndex = $scope.tabsList.map(function(f){return f.path}).indexOf(file.path);
                    if (tabIndex > -1) {
                        $scope.tabsList.splice(tabIndex, 1);
                        if (tabIndex == $scope.activeTabIndex) {
                            $scope.activeTabIndex = -1;
                            if ($scope.tabsList.length > 0) {
                                var newActiveTabIndex = tabIndex > 0 ? tabIndex - 1 : 0;
                                $scope.updateActiveTab(newActiveTabIndex);
                            }
                        } else if (tabIndex < $scope.activeTabIndex) {
                            $scope.activeTabIndex--;
                        }
                    }
                };

                $scope.closeFile = function(file) {
                    if ($scope.isContentDirty(file) && !file.readOnly ) {
                        CreateModalFromTemplate("/templates/plugins/development/fragments/fileclose-prompt.html", $scope, null, function(newScope) {
                            newScope.closeAndSave = function() {
                                var fileToSave = $scope.editedContentMap[file.path];
                                if (fileToSave) {
                                    $scope.saveContent(fileToSave);
                                }
                                closeContent(file);
                                newScope.dismiss();
                            }
                            newScope.close = function() {
                                closeContent(file);
                                newScope.dismiss();
                            }
                        });
                    } else {
                        closeContent(file);
                    }
                };

                $scope.closeOtherFiles = function(file) {
                    var dirtyFiles = [];
                    var fileToClose = [];
                    $scope.tabsList.forEach(function(f) {
                       if (f.path != file.path) {
                           fileToClose.push(f);
                           if ($scope.isContentDirty(f)) {
                               dirtyFiles.push(f);
                           }
                       }
                    });
                    if (dirtyFiles.length > 0) {
                        Dialogs.confirm($scope,'Discard changes','Are you sure you want to discard your changes?').then(function() {
                            $scope.tabsList = [file];
                            $scope.updateActiveTab(0);
                        });
                    } else {
                        $scope.tabsList = [file];
                        $scope.updateActiveTab(0);
                    }
                };

                $scope.$watch('tabsList', function(nv, ov) {
                    if (nv && ov && nv.length < ov.length) {
                        var nvPath = nv.map(function(file) {
                            return file.path;
                        })
                        ov.forEach(function(file) {
                            if (nvPath.indexOf(file.path) == -1) {
                                delete $scope.originalContentMap[file.path];
                                delete $scope.editedContentMap[file.path];
                            }
                        });
                        cleanTabScrollPosition();
                    }
                    $scope.tabsMap = {};
                    if (nv) {
                        nv.forEach(function(file) {
                            $scope.tabsMap[file.path] = file;
                        });
                    }
                    saveTabsList();
                }, true);

                var searchInDevContents = function(filePath) {
                    var pathFolders = [];
                    var searchRecursively = function(folder) {
                        for (var i = 0; i < folder.length; i++) {
                            var child = folder[i];
                            if (child.children && filePath.startsWith(child.path + "/")) {
                                pathFolders.push(child);
                                return searchRecursively(child.children);
                            } else if (child.path == filePath) {
                                pathFolders.push(child);
                                return pathFolders;
                            }
                        }
                        return null;
                    };
                    return searchRecursively($scope.devContents);
                }

                var openFileFromExternal = function(filePath) {
                    var pathFolders = searchInDevContents(filePath);

                    if (pathFolders && pathFolders.length > 0) {
                        var file = pathFolders[pathFolders.length - 1];
                        $scope.openFile(file);
                        pathFolders.forEach(function(f) {
                            f.expanded = true;
                        });
                        $timeout(function() {
                            $scope.focusedFile = file;
                        });
                    }
                };

                $scope.getCurrentContent = function() {
                    if ($scope.activeTabIndex > -1 && $scope.activeTabIndex < $scope.tabsList.length) {
                        var currentFile = $scope.tabsList[$scope.activeTabIndex];
                        return currentFile ? $scope.editedContentMap[currentFile.path] : null;
                    }
                    return null;
                };

                $scope.isContentFromGit = function() {
                    if ($scope.activeTabIndex > -1 && $scope.activeTabIndex < $scope.tabsList.length) {
                        var currentFile = $scope.tabsList[$scope.activeTabIndex];
                        return currentFile ? currentFile.fromGit : false;
                    }
                    return false;
                };

                $scope.isContentDirty = function(file) {
                    var isFileOpen = file && file.path && $scope.originalContentMap[file.path] && $scope.editedContentMap[file.path];
                    return isFileOpen && $scope.originalContentMap[file.path].data != $scope.editedContentMap[file.path].data;
                };

                $scope.hasDirtyContent = function() {
                    if ($scope.tabsList) {
                        for (var i=0; i<$scope.tabsList.length; i++) {
                            var file = $scope.tabsList[i];
                            if ($scope.isContentDirty(file)) {
                                return true;
                            }
                        }
                    }
                    return false;
                };

                /*
                 * Tab and Folder Explorer Menu
                 */

                $scope.focusOnFile = function(filePath) {
                    var pathFolders = searchInDevContents(filePath);
                    if (pathFolders && pathFolders.length > 0) {
                        pathFolders.forEach(function(content) {
                            content.expanded = true;
                        });
                        $timeout(function() {
                            $scope.focusedFile = pathFolders[pathFolders.length - 1];
                        });
                    }
                };

                var slideToTab = function(path) {
                    $scope.$broadcast('slideToId', "#tabs-frame", "#tabs-slider", path);
                };

                $scope.openTabMenu = function(element, $event) {
                    var template = '<ul class="dropdown-menu">'
                    +    '<li><a ng-click="moveContent(element)">Move</a></li>'
                    +    '<li ng-show="canDuplicateContent"><a ng-click="duplicateContent(element)">Duplicate</a></li>'
                    +    '<li><a ng-click="renameContent(element)">Rename</a></li>'
                    +    '<li><a ng-click="closeOtherFiles(element)">Close other tabs</a></li>'
                    +    '<li><a ng-click="deleteContent(element)" style="border-top: 1px #eee solid;">Delete</a></li>'
                    +'</ul>'

                    openRightClickMenu(element, $event, template);
                };

                const gitRefLocalActionsWarning = '<li> <a class="disabled break-hyphens" style="max-width: 190px; font-size: 13px;">' +
                        'Any changes in this directory from the following actions will be lost in the next update from Git' +
                    '</a> </li>';

                $scope.openFileMenu = function (element, $event) {
                    let template = '<ul class="dropdown-menu">';

                    if (element.fromGit) {
                        template += gitRefLocalActionsWarning;
                    }

                    template += '<li><a ng-click="moveContent(element)">Move</a></li>'
                        + '<li ng-show="canDuplicateContent"><a ng-click="duplicateContent(element)">Duplicate</a></li>'
                        + '<li><a ng-click="renameContent(element)">Rename</a></li>'
                        + '<li><a ng-click="deleteContent(element)">Delete</a></li>'
                        + '</ul>';

                    openRightClickMenu(element, $event, template);
                };

                $scope.openFolderMenu = function(element, $event) {
                    const folderLocalActions = '<li><a ng-click="addInElement(element.path, false)">Create file</a></li>'
                        +	'<li><a ng-click="addInElement(element.path, true)">Create folder</a></li>'
                        +	'<li><a ng-click="moveContent(element)">Move</a></li>'
                        +	'<li ng-show="canDuplicateContent"><a ng-click="duplicateContent(element)">Duplicate</a></li>'
                        +	'<li ng-show="!element.fromGit"><a ng-click="renameContent(element)">Rename</a></li>'
                        +	'<li><a ng-click="uploadElement(element.path)">Upload file</a></li>'
                        +   '<li ng-show="!element.fromGit"><a ng-click="deleteContent(element)">Delete</a></li>';

                    let template = '<ul class="dropdown-menu">';

                    if (element.fromGit) {
                        // This folder has been imported through Git references

                        if (element.path in $scope.gitReferences) {
                           template += '<li><a ng-click="gitRefActions.pullModal(element.path)">Update from Git</a></li>'
                               + '<li><a ng-click="gitRefActions.setModal(gitReferences[element.name], element.name)">Edit Git reference</a></li>'
                               + '<li><a ng-click="gitRefActions.untrackModal(element.name)">Untrack Git reference</a></li>'
                               + '<li><a ng-click="gitRefActions.rmModal(element.name)">Delete</a></li>'
                               + '<li class="divider"></li>';
                        }
                        template += gitRefLocalActionsWarning;
                    }

                    template += folderLocalActions + '</ul>';

                    openRightClickMenu(element, $event, template);
                };

                $scope.openRootMenu = function($event) {
                    var template = '<ul class="dropdown-menu">'
                        +	'<li><a ui-sref="profile.my.settings({\'#\':\'code_editor\'})" target="_blank">Customize editor settings</a></li>'
                        +	'<li><a ng-click="listContents(\'\')">Reload local files</a></li>'
                        +'</ul>'

                    openRightClickMenu(null, $event, template);
                };

                $scope.openAddMenu = function($event) {
                    var template = '<ul class="dropdown-menu">'
                        +   '<li><a ng-if="$state.$current.name == \'plugindev.editor\'" ng-click="newComponentPopin()">Create component</a></li>'
                        +   '<li><a ng-click="addInElement(\'\', false)" id="qa_plugindev_folder-file-add-btn">Create file</a></li>'
                        +	'<li><a ng-click="addInElement(\'\', true)">Create folder</a></li>'
                        +	'<li><a ng-click="uploadElement(\'\')">Upload file</a></li>'
                        +'</ul>'

                    openRightClickMenu(null, $event, template);
                };

                $scope.openGitMenu = function($event) {
                    var template = '<ul class="dropdown-menu">'
                        +	'<li ng-show="gitRefCallbacks"><a ng-click="gitRefActions.setModal()">Import from Git</a></li>'
                        +	'<li ng-show="gitRefCallbacks"><a ng-click="gitRefActions.listModal()">Manage references</a></li>'
                        +'</ul>'

                    openRightClickMenu(null, $event, template);
                };

                var openRightClickMenu = function(element, $event, template) {
                    var callback = function(newScope) {
                        newScope.element = element;
                    };
                    openMenu($event, template, callback);
                };

                var openMenu = function($event, template, callback) {
                    function isElsewhere(elt, e) {
                        return $(e.target).parents('.plugindev-tab-menu').length == 0;
                    }
                    var dkuPopinOptions = {
                        template: template,
                        isElsewhere: isElsewhere,
                        callback: callback
                    };
                    openDkuPopin($scope, $event, dkuPopinOptions);
                };

                /*
                 * Tabs persistency
                 */

                var getFolderEditLocalStorage = function() {
                    var allFolderEditLocalStorage = LocalStorage.get("dss.folderedit");
                    if (!allFolderEditLocalStorage) {
                        allFolderEditLocalStorage = {};
                    }
                    var folderEditLocalStorage = allFolderEditLocalStorage[$scope.localStorageId];
                    if (!folderEditLocalStorage) {
                        folderEditLocalStorage = {"tabsList":[]};
                    }
                    if (!folderEditLocalStorage.tabsList) {
                        folderEditLocalStorage.tabsList = [];
                    }
                    return folderEditLocalStorage;
                }

                var setFolderEditLocalStorage = function(folderEditLocalStorage) {
                    var allFolderEditLocalStorage = LocalStorage.get("dss.folderedit");
                    if (!allFolderEditLocalStorage) {
                        allFolderEditLocalStorage = {};
                    }
                    allFolderEditLocalStorage[$scope.localStorageId] = folderEditLocalStorage;
                    LocalStorage.set("dss.folderedit", allFolderEditLocalStorage);
                }

                var saveTabsList = function() {
                    if ($scope.tabsList) {
                        var folderEditLocalStorage = getFolderEditLocalStorage();
                        folderEditLocalStorage.tabsList = $scope.tabsList.map(function(file) {
                            return file.path;
                        });
                        setFolderEditLocalStorage(folderEditLocalStorage);
                    }
                };

                var saveActiveTab = function() {
                    var folderEditLocalStorage = getFolderEditLocalStorage();
                    folderEditLocalStorage.activeTab = $scope.tabsList[$scope.activeTabIndex].path;
                    setFolderEditLocalStorage(folderEditLocalStorage);
                }

                var saveTabScrollPosition = function(path, scroll) {
                    var folderEditLocalStorage = getFolderEditLocalStorage();
                    if (!folderEditLocalStorage.scrollPositions) {
                        folderEditLocalStorage.scrollPositions = {};
                    }
                    folderEditLocalStorage.scrollPositions[path] = scroll;
                    setFolderEditLocalStorage(folderEditLocalStorage);
                }

                var cleanTabScrollPosition = function() {
                    var folderEditLocalStorage = getFolderEditLocalStorage();
                    var scrollPositions = folderEditLocalStorage.scrollPositions;
                    if (scrollPositions) {
                        var tabsPathList = $scope.tabsList.map(function(f) {
                            return f.path;
                        });
                        Object.keys(scrollPositions).forEach(function(path) {
                            if (tabsPathList.indexOf(path) == -1) {
                                delete scrollPositions[path];
                            }
                        });
                    }
                    setFolderEditLocalStorage(folderEditLocalStorage);
                }

                $scope.getTabScrollPosition = function(path) {
                    var folderEditLocalStorage = getFolderEditLocalStorage();
                    return folderEditLocalStorage.scrollPositions && folderEditLocalStorage.scrollPositions[path] ? folderEditLocalStorage.scrollPositions[path] : 0;
                }

                var openSavedTabs = function() {
                    var folderEditLocalStorage = getFolderEditLocalStorage();
                    var activeTab = null;
                    $scope.tabsList =[];
                    folderEditLocalStorage.tabsList.forEach(function (filePath) {
                        var objPath = searchInDevContents(filePath);
                        if (objPath) {
                            var file = objPath[objPath.length - 1];
                            $scope.addTab(file);
                            if (filePath == folderEditLocalStorage.activeTab) {
                                activeTab = file;
                            }
                        }
                    });
                    var fileToOpen = folderEditLocalStorage.activeTab && activeTab ? activeTab : $scope.tabsList[$scope.tabsList.length - 1];
                    if (fileToOpen) {
                        $scope.focusOnFile(fileToOpen.path);
                        $scope.openFile(fileToOpen);
                        $scope.unregisterArrowSliderInit = $scope.$on("DKU_ARROW_SLIDER:arrow_slider_initialized", function() {
                            slideToTab(fileToOpen.path);
                        });
                    }
                }

                /*
                 * CRUD
                 */

                const updateGitRefsAfterSave = function(cond) {
                    if ($scope.gitRefCallbacks) {
                        $scope.listContents();
                    }
                };

                $scope.saveCurrentContent = function() {
                    var currentContent = $scope.getCurrentContent();
                    $scope.saveContent(currentContent);
                };

                function doSaveContent(content) {
                    $scope.folderEditCallbacks.set(content).success(function(data){
                        $scope.originalContentMap[content.path] = angular.copy(content);
                        postSaveCallback();
                        updateGitRefsAfterSave(content.path === 'external-libraries.json');
                        const dirtyFiles = {
                            [content.path]: content.data
                        };
                        reloadPluginIfNeeded(dirtyFiles);
                    }).error(setErrorInScope.bind($scope));
                }

                function validateAndSaveContent(content) {
                    if (!$scope.folderEditCallbacks.validate) {
                        doSaveContent(content)
                    } else {
                        const dirtyFiles = {
                            [content.path]: content.data
                        };
                        $scope.folderEditCallbacks.validate(dirtyFiles).success(function(data) {
                            if (!data.anyMessage) {
                                doSaveContent(content)
                            } else {
                                CreateModalFromTemplate('/templates/plugins/development/plugin-dev-warning-modal.html', $scope, null, function(modalScope) {
                                    modalScope.messages = data;
                                    modalScope.saveAnyway = function() {
                                        modalScope.dismiss();
                                        doSaveContent(content)
                                    }
                                })
                            }
                        }).error(setErrorInScope.bind($scope));
                    }
                }

                $scope.saveContent = function(content) {
                    if (content.readOnly) { // I keep this "readOnly" thing but looks like it's not a feature anymore (in fact was never a feature)
                        Dialogs.confirm($scope,'Save changes','The file is read-only. Make it writable?').then(function() {
                            validateAndSaveContent(content)
                        });
                    } else {
                        validateAndSaveContent(content)
                    }
                };

                function doSaveAll(dirtyFiles) {
                    $scope.folderEditCallbacks.setAll(dirtyFiles).success(function(data){
                        Object.keys(dirtyFiles).forEach(function(filePath) {
                            $scope.originalContentMap[filePath].data = dirtyFiles[filePath];
                        });
                        postSaveCallback();
                        updateGitRefsAfterSave('external-libraries.json' in dirtyFiles);
                        reloadPluginIfNeeded(dirtyFiles)
                    }).error(setErrorInScope.bind($scope));
                }

                $scope.saveAll = function() {
                    var dirtyFiles = {};
                    $scope.tabsList.forEach(function(file) {
                        if ($scope.isContentDirty(file)) {
                            dirtyFiles[file.path] = $scope.editedContentMap[file.path].data;
                        }
                    });
                    resetErrorInScope($scope);
                    if (!$scope.folderEditCallbacks.validate) {
                        doSaveAll(dirtyFiles);
                    } else {
                        $scope.folderEditCallbacks.validate(dirtyFiles).success(function(data) {
                            if (!data.anyMessage) {
                                doSaveAll(dirtyFiles);
                            } else {
                                CreateModalFromTemplate('/templates/plugins/development/plugin-dev-warning-modal.html', $scope, null, function(modalScope) {
                                    modalScope.messages = data;
                                    modalScope.saveAnyway = function() {
                                        modalScope.dismiss();
                                        doSaveAll(dirtyFiles);
                                    }
                                })
                            }
                        }).error(setErrorInScope.bind($scope));
                    }
                };

                function reloadPluginIfNeeded(dirtyFiles) {
                    if (dirtyFiles) { // not specified in the case of folder rename for example (and then we do want to reload)
                        let hasAnyJson = false;
                        let hasAnyJs = false;
                        for (const f of Object.keys(dirtyFiles)) {
                            if (f.toLowerCase().endsWith('.json')) {
                                hasAnyJson = true;
                                break;
                            }
                            if (f.toLowerCase().endsWith('.js')) {
                                hasAnyJs = true;
                                break;
                            }
                        }
                        if (!hasAnyJson && !hasAnyJs) {
                            return;
                        }
                    }
                    $scope.reloadPlugin && $scope.reloadPlugin($stateParams.pluginId);
                }

                $scope.deleteContent = function(content) {
                    var isNonEmptyFolder = content.children != null && content.children.length > 0;
                    var message = isNonEmptyFolder ? 'Are you sure you want to delete ' + content.name + ' and all its contents?' : 'Are you sure you want to delete ' + content.name + ' ?';
                    Dialogs.confirm($scope,'Delete ' + ( isNonEmptyFolder ? 'folder' : 'file'), message).then(function() {
                        $scope.folderEditCallbacks.delete(content).success(function(data){
                            var toClose = [];
                            $scope.tabsList.forEach(function(file) {
                                if (isIncludedOrEqual(file.path, content.path)) {
                                    toClose.push(file);
                                }
                            });
                            toClose.forEach(function(f) {
                                closeContent(f);
                            });
                            DKUtils.reloadState();
                        }).error(setErrorInScope.bind($scope));
                    });
                };

                $scope.renameContent = function(content) {
                    var popinName = content.children ? "Rename folder" : "Rename file";
                    Dialogs.prompt($scope, popinName, 'New name', content.name).then(function(newName) {
                        $scope.folderEditCallbacks.rename(content, newName).success(function(data){
                            //syntaxic coloration issues
                            if (content.mimeType != data.mimeType) {
                                //refreshing code mirror syntaxic coloration if we renamed current content
                                if ($scope.getCurrentContent() && $scope.getCurrentContent().path == content.path) {
                                    refreshSyntaxicColoration(content.name, data.mimeType);
                                }
                                //necessary if file renamed is among tabs (but not active one), otherwise syntaxic coloration won't be updated when we come back to this tab.
                                if ($scope.tabsMap[content.path]) {
                                    propagatingMimeTypeChange(content.path, data.mimeType);
                                }
                            }
                            // necessary, otherwise it fails when clicking on save after a move
                            propagatingPathChange(content.path, data.path);
                            reloadPluginIfNeeded();
                            DKUtils.reloadState();
                        }).error(setErrorInScope.bind($scope));
                    });
                };

                $scope.moveContent = function(content) {
                    CreateModalFromTemplate("/templates/plugins/development/fragments/filemove-prompt.html", $scope, "MoveContentModalController", function(newScope) {
                        newScope.devContents = angular.copy($scope.devContents); // so that the stat is disconnected from the main display of the hierarchy
                        newScope.toMove = content;
                        newScope.doMove = function(to) {
                            $scope.folderEditCallbacks.move(content, to).success(function(data){
                                // necessary, otherwise it fails when clicking on save after a move
                                propagatingPathChange(content.path, data.path);
                                reloadPluginIfNeeded();
                                DKUtils.reloadState();
                            }).error(setErrorInScope.bind($scope));
                        };
                    });
                };

                $scope.canDuplicateContent = $scope.folderEditCallbacks.copy != null;

                $scope.duplicateContent = function(content) {
                    $scope.folderEditCallbacks.copy(content).success(function(data){
                        DKUtils.reloadState();
                    }).error(setErrorInScope.bind($scope));
                }

                var propagatingPathChange = function(oldPath, newPath) {
                    // In tabslist
                    $scope.tabsList.forEach(function(file) {
                        if (isIncludedOrEqual(file.path, oldPath)) {
                            var oldFilePath = file.path;
                            var newFilePath = file.path.replace(oldPath, newPath);
                            file.path = newFilePath;
                            file.name = file.path.match(/[^\/]+$/)[0] // file name may changed
                            //updating originalContentMap
                            var originalContent = $scope.originalContentMap[oldFilePath];
                            if (originalContent) {
                                originalContent.path = newFilePath;
                                originalContent.name = originalContent.path.match(/[^\/]+$/)[0] // file name may changed
                                $scope.originalContentMap[newFilePath] = originalContent;
                                delete $scope.originalContentMap[oldFilePath];
                            }
                            //updating edtitedContentMap
                            var editedContent = $scope.editedContentMap[oldFilePath];
                            if (editedContent) {
                                editedContent.path = newFilePath;
                                editedContent.name = editedContent.path.match(/[^\/]+$/)[0] // file name may changed
                                $scope.editedContentMap[newFilePath] = editedContent;
                                delete $scope.editedContentMap[oldFilePath];
                            }
                        }
                    });
                    // In localStorage
                    var folderEditLocalStorage = getFolderEditLocalStorage();
                    for (var i=0; i<folderEditLocalStorage.tabsList.length; i++) {
                        var filePath = folderEditLocalStorage.tabsList[i];
                        if (isIncludedOrEqual(filePath, oldPath)) {
                            folderEditLocalStorage.tabsList[i] = filePath.replace(oldPath, newPath);
                        }
                    }
                    if (folderEditLocalStorage.activeTab && isIncludedOrEqual(folderEditLocalStorage.activeTab, oldPath)) {
                        folderEditLocalStorage.activeTab = folderEditLocalStorage.activeTab.replace(oldPath, newPath);
                    }
                    setFolderEditLocalStorage(folderEditLocalStorage);
                };

                var propagatingMimeTypeChange = function(path, mimeType) {
                    for (var i = 0; i<$scope.tabsList.length; i++) {
                        var file = $scope.tabsList[i];
                        if (file.path == path) {
                            file.mimeType = mimeType;
                            break;
                        }
                    }
                }

                var decompressibleMimes = ['application/zip', 'application/x-bzip', 'application/x-bzip2', 'application/x-gzip', 'application/x-tar', 'application/gzip', 'application/bzip', 'application/bzip2', 'application/x-compressed-tar'];
                $scope.canBeDecompressed = function(content) {
                    return content && content.mimeType && decompressibleMimes.indexOf(content.mimeType) >= 0;
                };

                $scope.computeFileIconClass = function(file) {
                    if (file.fromGit) {
                        return 'icon-dku-git-file';
                    } else if ($scope.canBeDecompressed(file)) {
                        return 'icon-dku-file-zip';
                    } else if ($scope.isImage(file)) {
                        return 'icon-picture';
                    } else {
                        return 'icon-file-text-alt';
                    }
                };

                $scope.decompressContent = function(content) {
                    $scope.folderEditCallbacks.decompress(content).success(function(data){
                        $scope.listContents();
                    }).error(setErrorInScope.bind($scope));
                };

                $scope.addInElement = function(contentPath, isFolder) {
                    CreateModalFromTemplate("/templates/plugins/development/fragments/filename-prompt.html", $scope, null, function(newScope) {
                        newScope.isFolder = isFolder;
                        newScope.doCreation = function(fileName) {
                            $scope.folderEditCallbacks.create(contentPath + '/' + fileName, isFolder).success(function(data){
                                $scope.listContents().success(function() {
                                    if (!isFolder) {
                                        var newElPath = contentPath && contentPath.length > 0 ? contentPath + '/' + fileName : fileName;
                                        var newElement = searchInDevContents(newElPath);
                                        if (newElement) {
                                            $scope.openFile(newElement[newElement.length - 1]);
                                        }
                                    }
                                });
                            }).error(setErrorInScope.bind($scope));
                        };
                    });
                };

                var openFirstUpload = function(contentPath, firstUpload) {
                    $scope.listContents().success(function() {
                        var firstUploadPath = contentPath && contentPath.length > 0 ? contentPath + "/" + firstUpload.name : firstUpload.name;
                        var firstUploadPathObj = searchInDevContents(firstUploadPath);
                        if (firstUploadPathObj) {
                            $scope.openFile(firstUploadPathObj[firstUploadPathObj.length - 1]);
                        }
                    });
                };
                $scope.uploadElement = function(contentPath) {
                    CreateModalFromTemplate("/templates/plugins/development/fragments/upload-prompt.html", $scope, "UploadContentModalController", function(newScope) {
                        newScope.folderEditCallbacks = $scope.folderEditCallbacks;
                        newScope.openFirstUpload = openFirstUpload;
                        newScope.contentPath = contentPath;
                    });
                };

                checkChangesBeforeLeaving($scope,  $scope.hasDirtyContent, $scope.folderEditSaveWarning);

                /*
                 * Git references actions
                 */

                $scope.gitRefActions = {
                    setModal: function (gitRef, gitRefPath) {
                        CreateModalFromTemplate("/templates/plugins/development/fragments/git-ref-prompt.html", $scope, "GitReferenceSetController", newScope => {
                            if (gitRef && gitRefPath) {
                                newScope.gitRef = gitRef;
                                newScope.gitRefPath = gitRefPath;
                                newScope.isEditingGitRef = true;
                            }

                            newScope.onSetCallback = () => { $scope.listContents(); };
                        });
                    },
                    listModal: function () {
                        $scope.listContents().then(() => {
                            CreateModalFromTemplate("/templates/plugins/development/fragments/git-ref-list.html", $scope);
                        }, setErrorInScope.bind($scope));
                    },
                    pullModal: function (gitRefPath) {
                        const pullGitRefAPI = gitRefPath ?
                            $scope.gitRefCallbacks.pullOne(gitRefPath) :
                            $scope.gitRefCallbacks.pullAll();

                        pullGitRefAPI.then(pullResult => {
                            FutureProgressModal.show($scope, pullResult.data, "Updating").then(futureResult => {
                                if (futureResult) {
                                    Dialogs.infoMessagesDisplayOnly($scope, "Update result", futureResult).then(() => {
                                        // If at least one of the pulls succeeded, we want to reload the state as files might have changed
                                        if (futureResult.messages.some(message => message['severity'] === 'SUCCESS')) {
                                            DKUtils.reloadState();
                                        }
                                    });
                                }
                            }, setErrorInScope.bind($scope));
                        }, setErrorInScope.bind($scope));
                    },
                    rmModal: function (gitRefPath) {
                        Dialogs.confirm($scope, 'Remove Git reference', 'Are you sure you want to remove this Git reference and the associated folder?').then(() => {
                            $scope.gitRefCallbacks.rm(gitRefPath, true).then(() => {
                                DKUtils.reloadState();
                            }, setErrorInScope.bind($scope))
                        });
                    },
                    untrackModal: function (gitRefPath) {
                        Dialogs.confirm($scope, 'Untrack Git reference', 'Are you sure you want to untrack this Git reference and keep the associated folder?').then(() => {
                            $scope.gitRefCallbacks.rm(gitRefPath, false).then(() => {
                                DKUtils.reloadState();
                            }, setErrorInScope.bind($scope))
                        });
                    }
                };


                /*
                 * UI Utils
                 */

                $scope.getMarginFromDepth = function(depth) {
                    return (depth + 1)*15 + 10;
                }

                $scope.getCarretLeftPosition = function(depth) {
                    return $scope.getMarginFromDepth(depth - 1);
                }

                $scope.containsFolder = function(element) {
                    if (!element.children) {
                        return false;
                    }
                    for (var i=0; i<element.children.length; i++) {
                        var e = element.children[i];
                        if (typeof(e.children) !== "undefined") {
                            return true;
                        }
                    }
                    return false;
                }

                $scope.isImage = function(element) {
                    return element.mimeType.startsWith('image');
                }

                $scope.emptyCtaBtnAction = function() {
                    if ($scope.emptyCta && $scope.emptyCta.btnAction) {
                        switch ($scope.emptyCta.btnAction) {
                            case 'create':
                                $scope.addInElement('', false);
                                break;
                            case 'upload':
                                $scope.uploadElement('');
                                break;
                            default:
                                return false;
                        }
                    }
                }


                /*
                 * Utils
                 */

                var isIncludedOrEqual = function(path, path2) {
                    return path.startsWith(path2 + "/") || path == path2;
                }
            }
        };
    });

    app.controller("NewFileModalController", function($scope, DataikuAPI, $state, $stateParams, WT1){
        $scope.fileName = null;
        $scope.create = function() {
            $scope.doCreation($scope.fileName);
            $scope.dismiss();
        };
    });

    app.controller("GitReferenceSetController", function($scope, $stateParams, DKUtils, DataikuAPI, ActivityIndicator, CreateModalFromTemplate, SpinnerService) {
        $scope.gitRef = $scope.gitRef || {
            remote: '',
            remotePath: '',
            checkout: ''
        };
        $scope.gitRefPath = $scope.gitRefPath || '';
        $scope.addPythonPath = true;
        $scope.isGitRefPathUnique = true;

        $scope.$watch("gitRefPath", function(gitRefPath) {
            if (!$scope.isEditingGitRef) {
                $scope.isGitRefPathUnique = !gitRefPath || !(gitRefPath in $scope.gitReferences);
            }
        });

        $scope.setGitRef = function() {
            $scope.gitRefCallbacks.set($scope.gitRef, $scope.gitRefPath, $scope.addPythonPath).then(() => {
                ActivityIndicator.success('Git reference successfully set.');
                if ($scope.onSetCallback) {
                    $scope.onSetCallback();
                }
                $scope.gitRefActions.pullModal($scope.gitRefPath);
            }, setErrorInScope.bind($scope));
        };
    });

    app.controller("MoveContentModalController", function($scope) {
        $scope.uiState = {moveToTop : false, destination : null};

        $scope.changeDestination = function(to) {
            $scope.uiState.destination = to;
            var recClearMoveToHere = function(l) {
                l.forEach(function(e) {
                    if (e != to) {
                        e.moveToHere = false;
                        if (e.children) {
                            recClearMoveToHere(e.children);
                        }
                    }
                });
            };
            recClearMoveToHere($scope.devContents);
            if (to != null) {
                $scope.uiState.moveToTop = false;
                to.moveToHere = true;
            } else {
                $scope.uiState.moveToTop = true;
            }
        };

        $scope.hasNowhereToGo = function() {
            if ($scope.uiState.moveToTop) {
                return false;
            } else if ($scope.uiState.destination && $scope.uiState.destination.moveToHere) {
                return false;
            } else {
                return true;
            }
        }

        $scope.move = function() {
            if ($scope.uiState.moveToTop) {
                $scope.doMove(null);
            } else if ($scope.uiState.destination && $scope.uiState.destination.moveToHere) {
                $scope.doMove($scope.uiState.destination);
            }
            $scope.dismiss();
        };
    });

    app.controller("UploadContentModalController", function($scope, DataikuAPI, $state, $stateParams, WT1, Logger) {
        $scope.toUpload = [];

        $scope.selectedCount = function() {
            return $scope.toUpload.filter(function(f) {return f.$selected;}).length;
        };
        $scope.startedCount = function() {
            return $scope.toUpload.filter(function(f) {return f.started;}).length;
        };
        $scope.doneCount = function() {
            return $scope.toUpload.filter(function(f) {return f.done;}).length;
        };

        var getPathForFileToUpload = function(fileToUpload) {
            return fileToUpload.name;
        };
        var isAlreadyListed = function(filePath) {
            var found = false;
            $scope.toUpload.forEach(function(u) {
                found |= filePath == u.name;
            });
            return found;
        };
        $scope.uploadFiles = function(files) {
            var filePaths = [];
            var newFiles = [];
            for (var i = 0, len = files.length; i < len ; i++) { // no forEach() on the files :(
                var file = files[i];
                var filePath = getPathForFileToUpload(file);
                if (!isAlreadyListed(filePath)) {
                    filePaths.push(filePath);
                    newFiles.push(file);
                }
            }
            $scope.doCheckUpload(filePaths).success(function(data) {
                for (var i = 0, len = newFiles.length; i < len ; i++) { // no forEach() on the files :(
                    var file = newFiles[i];
                    var feasability = data.feasabilities[i];
                    $scope.toUpload.push({file:file, name:getPathForFileToUpload(file), feasability:feasability, $selected:feasability.canUpload});
                }
            }).error(setErrorInScope.bind($scope));
        };

        $scope.upload = function() {
            $scope.doUpload($scope.toUpload.filter(function(f) {return f.$selected;}));
        };

        $scope.goToFirstUploaded = function() {
            var succeeded = $scope.toUpload.filter(function(f) {return f.succeeded != null;})[0];
            if (succeeded != null) {
                $scope.openFirstUpload($scope.contentPath, succeeded);
            }
            $scope.dismiss();
        };
        var checkUploadCompletion = function() {
            if ($scope.startedCount() == 1 && $scope.startedCount() == $scope.doneCount()) {
                var succeeded = $scope.toUpload.filter(function(f) {return f.succeeded != null;})[0];
                if (succeeded != null) {
                    $scope.goToFirstUploaded();
                }
            }
        };
        $scope.doUpload = function(filesToUpload) {
            filesToUpload.forEach(function(fileToUpload) {
                fileToUpload.started = true;
                $scope.folderEditCallbacks.upload($scope.contentPath, fileToUpload.file, function (e) {
                    if (e.lengthComputable) {
                        $scope.$apply(function () {
                            fileToUpload.progress = Math.round(e.loaded * 100 / e.total);
                        });
                    }
              }).then(function (data) {
                  Logger.info("file " + fileToUpload.name + "uploaded", data);
                  fileToUpload.done = true;
                  fileToUpload.succeeded = JSON.parse(data);
                  checkUploadCompletion();
              }, function(payload){
                  Logger.info("file " + fileToUpload.name + "could not be uploaded", payload);
                  fileToUpload.done = true;
                  fileToUpload.failed = getErrorDetails(JSON.parse(payload.response), payload.status, function(h){return payload.getResponseHeader(h)}, payload.statusText);
                  fileToUpload.failed.html = getErrorHTMLFromDetails(fileToUpload.failed);
                  checkUploadCompletion();
              });
            });
        };
        $scope.doCheckUpload = function(filePaths) {
            return $scope.folderEditCallbacks.checkUpload($scope.contentPath, filePaths);
        };
    });
})();

(function() {
'use strict';

const app = angular.module('dataiku.taggableobjects', []);


// Keep in sync with Java TaggableType enum
app.constant("TAGGABLE_TYPES", [
    'PROJECT',
    'FLOW_ZONE',
    'DATASET',
    'MANAGED_FOLDER',
    'STREAMING_ENDPOINT',
    'RECIPE',
    'SQL_NOTEBOOK',
    'JUPYTER_NOTEBOOK',
    'ANALYSIS',
    'STATISTICS_WORKSHEET',
    'SAVED_MODEL',
    'MODEL_EVALUATION_STORE',
    'SCENARIO',
    'DASHBOARD',
    'INSIGHT',
    'WEB_APP',
    'REPORT',
    'ARTICLE',
    'LAMBDA_SERVICE',
]);

// Can be exposed from one project to another
app.constant("EXPOSABLE_TYPES", [
    'DATASET',
    'SAVED_MODEL',
    'MANAGED_FOLDER',
    'JUPYTER_NOTEBOOK',
    'WEB_APP',
    'REPORT',
    'SCENARIO'
]);

// Computable in the flow (as outputs of recipes)
app.constant("FLOW_COMPUTABLE_TYPES", [
    'DATASET',
    'MANAGED_FOLDER',
    'SAVED_MODEL',
    'MODEL_EVALUATION_STORE',
    'STREAMING_ENDPOINT'
]);

// Publishable as insights on dashboards
app.constant("PUBLISHABLE_TYPES", [
    'DATASET',
    'JUPYTER_NOTEBOOK',
    'SAVED_MODEL',
    'MANAGED_FOLDER',
    'SCENARIO',
    'WEB_APP',
    'REPORT'
]);

app.constant('PIPELINEABILITY_ACTIONS', {
    changeSQL: 'action-change-sql-pipelineability',
    changeSpark: 'action-change-spark-pipelineability'
});


function isHDFSAbleType(type) {
    return ['HDFS', 'S3', 'GCS', 'Azure'].includes(type);
}

/*
There are essentially 4 representations for taggable objects in the JS code:
- {type, projectKey, id [,displayName]}, the equivalent of java TaggableObjectRef (so it's good to call those variables tor or something similar)
- the actual serialized taggable object (they can be called using they actual types or 'to' or something similar)
- the graph node (that use in particular a specific id system) (good to call them 'node' or something similar)
- the list items, as used in list pages (good to call them 'listItem' or something similar)

This service helps juggling with them
*/
app.service("TaggableObjectsUtils", function($state, $stateParams) {
    const svc = this;

    // Returns the items common taggableType or 'TAGGABLE_OBJECT' if they don't have the same
    // Items can be an array of taggable type or an array of arbitrary objects that 'typeFieldAccessor' can map to taggable types
    this.getCommonType = function(items, typeFieldAccessor) {
        let commonType = null;
        for (let i = 0; i < items.length; ++i) {
            let itemType = typeFieldAccessor ? typeFieldAccessor(items[i]) : items[i];
            if (!commonType) {
                commonType = itemType;
            } else if (commonType != itemType) {
                return 'TAGGABLE_OBJECT';
            }
        }
        return commonType || 'TAGGABLE_OBJECT';
    };

    this.fromNodeType = function(nodeType) {
        if (!nodeType) return;

        if (nodeType.includes('DATASET')) {
            return 'DATASET';
        } else if (nodeType.includes('LAMBDA_SERVICE')) {
            return 'LAMBDA_SERVICE';
        } else if (nodeType.includes('SAVEDMODEL')) {
            return 'SAVED_MODEL';
        } else if (nodeType.includes('MODELEVALUATIONSTORE')) {
            return 'MODEL_EVALUATION_STORE';
        } else if (nodeType.includes('STREAMING_ENDPOINT')) {
            return 'STREAMING_ENDPOINT';
        } else if (nodeType.includes('MANAGED_FOLDER')) {
            return 'MANAGED_FOLDER';
        } else if (nodeType == 'RECIPE') {
            return 'RECIPE';
        } else if (nodeType == 'PROJECT') {
            return 'PROJECT';
        } else if (nodeType == 'JUPYTER_NOTEBOOK') {
            return 'JUPYTER_NOTEBOOK';
        } else if (nodeType == 'SQL_NOTEBOOK') {
            return 'SQL_NOTEBOOK';
        } else if (nodeType == 'DASHBOARD') {
            return 'DASHBOARD';
        } else if (nodeType == 'INSIGHT') {
            return 'INSIGHT';
        } else if (nodeType == 'SCENARIO') {
            return 'SCENARIO';
        } else if (nodeType == 'ANALYSIS') {
            return 'ANALYSIS';
        } else if (nodeType == 'WEB_APP') {
            return 'WEB_APP';
        } else if (nodeType == 'REPORT') {
            return 'REPORT';
        } else if (nodeType == 'NOTEBOOK') {
            return 'NOTEBOOK';
        } else if (nodeType == 'ZONE') {
            return 'FLOW_ZONE';
        }
    };

    this.fromNode = function(node) {
        return {
            type: svc.fromNodeType(node.nodeType),
            projectKey: node.projectKey,
            id: node.name,
            displayName: node.description || node.name,
            subType: node.datasetType || node.recipeType || node.smType,
            tags: node.tags
        };
    };

    this.fromObjectItem = function(objectItem) {
        return {
            type: svc.fromNodeType(objectItem.nodeType),
            projectKey: objectItem.projectKey,
            id: objectItem.id,
            displayName: objectItem.description || objectItem.name,
            subType: objectItem.datasetType || objectItem.recipeType || objectItem.smType,
            tags: objectItem.tags
        };
    };

    this.fromListItem = function(listItem) {
        return {
            type: svc.taggableTypeFromAngularState(listItem),
            projectKey: $stateParams.projectKey,
            id: listItem.id,
            displayName: listItem.name,
            subType: listItem.type,
            tags: listItem.tags
        };
    };

    this.taggableTypeFromAngularState = function(listItem) {
        const stateName = $state.current.name;

        // in the special case of notebooks, we cannot retrieve the taggable type only from angular state
        // then we use the item to get the language to determine the proper taggle type
        if (listItem && listItem.type && stateName.startsWith('projects.project.notebooks')) {
            if (listItem.type == 'SQL') {
                return 'SQL_NOTEBOOK';
            } else {
                return 'JUPYTER_NOTEBOOK';
            }
        }
        if (listItem && stateName.startsWith('projects.project.continuous-activities')) {
            return 'CONTINUOUS_ACTIVITY';
        }

        if (stateName.startsWith('projects.project.datasets') || stateName.startsWith('projects.project.foreigndatasets')) {
            return 'DATASET';
        } else if (stateName.startsWith('projects.project.streaming-endpoints')) {
            return 'STREAMING_ENDPOINT';
        } else if (stateName.startsWith('projects.project.managedfolders')) {
            return 'MANAGED_FOLDER';
        } else if (stateName.startsWith('projects.project.savedmodels')) {
            return 'SAVED_MODEL';
        } else if (stateName.startsWith('projects.project.modelevaluationstores')) {
            return 'MODEL_EVALUATION_STORE';
        } else if (stateName.startsWith('projects.project.recipes')) {
            return 'RECIPE';
        } else if (stateName.startsWith('projects.project.analyses')) {
            return 'ANALYSIS';
        } else if (stateName.startsWith('projects.project.scenarios')) {
            return 'SCENARIO';
        } else if (stateName.startsWith('projects.project.webapps')) {
            return 'WEB_APP';
        } else if (stateName.startsWith('projects.project.reports')) {
            return 'REPORT';
        } else if (stateName.startsWith('projects.project.dashboards.insights')) {
            return 'INSIGHT';
        } else if (stateName.startsWith('projects.project.dashboards')) {
            return 'DASHBOARD';
        } else if (stateName.startsWith('projects.project.lambdaservices')) {
            return 'LAMBDA_SERVICE';
        } else if (stateName.startsWith('projects.project.continuous-activities')) {
            throw new Error("Cannot get continuous activity taggable type from angular state");
        } else if (stateName.startsWith('projects.project.notebooks')) {
            throw new Error("Cannot get notebook taggable type from angular state");
        }
        //Note that we never return 'PROJECT'
        throw new Error("Failed to get taggable type from angular state");
    };

    this.isComputable = function(tor) {
        if (!tor) return;
        return tor.type == 'DATASET' || tor.type == 'MANAGED_FOLDER' || tor.type == 'SAVED_MODEL' || tor.type == 'MODEL_EVALUATION_STORE' || tor.type == 'STREAMING_ENDPOINT';
    };

    this.isLocal = function(tor) {
        if (!tor || !$stateParams.projectKey) return;
        return tor.projectKey == $stateParams.projectKey;
    };
    this.isHDFSAbleType = isHDFSAbleType;
});


app.service("TaggableObjectsService", function($stateParams, $rootScope, $q, DataikuAPI, CreateModalFromTemplate, Dialogs) {
    /* deletionRequests should be {taggableType: ... , projectKey: ... , id: ...} */
    this.delete = function(deletionRequests, customMassDeleteSelected) {
        let deferred = $q.defer();

        CreateModalFromTemplate("/templates/taggable-objects/delete-modal.html", $rootScope, "DeleteTaggableObjectsModalController", function(modalScope) {
            deletionRequests.forEach(function(dr) {
                dr.options = {dropData: false};
            })

            modalScope.computedImpact = {};
            modalScope.deletionRequests = deletionRequests;
            modalScope.currentProject = $stateParams.projectKey;
        }).then(function() {
            deletionRequests = deletionRequests.filter(it => it.type != "FLOW_ZONE" || it.id != "default"); // do not delete default zone
            deletionRequests.forEach(function(item, index, objcet) {
                if (item.type == 'JUPYTER_NOTEBOOK' && item.activeSessions) {
                    item.activeSessions.forEach(function(session) {
                        DataikuAPI.jupyterNotebooks.unload(session.sessionId);
                    });
                    delete item.activeSessions;
                }

            });

            const deleteCall = customMassDeleteSelected || DataikuAPI.taggableObjects.delete;

            deleteCall(deletionRequests, $stateParams.projectKey)
                .success(function(errors) {
                    $rootScope.$emit('flowItemAddedOrRemoved', deletionRequests);

                    deletionRequests.forEach(function(req) {
                        // HistoryService.notifyRemoved({
                        //     type: "DATASET",
                        //     id: req.name,
                        //     projectKey: req.projectKey
                        // },
                        // $scope.computedImpact.data
                        // );
                    });

                    DataikuAPI.flow.zones.list($stateParams.projectKey).then(data => {
                        if (data.data.length == 1 && data.data[0].id == "default") {
                            DataikuAPI.flow.zones.delete($stateParams.projectKey, "default");
                        }
                    });

                    Dialogs.infoMessagesDisplayOnly($rootScope, "Deletion", errors);
                    deferred.resolve();
                })
                .error(function() {
                    deferred.reject.apply(this, arguments);
                })
        });
        return deferred.promise;
    };
});


app.filter('niceTaggableType', function($filter) {
    const dict = {
        'MANAGED_FOLDER': 'folder',
        'SAVED_MODEL': 'model',
        'MODEL_EVALUATION_STORE': 'evaluation store',
        'LAMBDA_SERVICE': 'API service',
        'SQL_NOTEBOOK': 'SQL notebook',
        'TAGGABLE_OBJECT': 'item'
    };
    const plurals = {
        'ANALYSIS': 'analyses'
    };

    return function(input, count = 1) {
        if (!input) return input;
        return $filter('plurify')(dict[input] || input.toLowerCase().replace('_', ' '), count, plurals[input]);
    };
});


app.filter("taggableObjectRef", function() {
    return function(input) {
        if (!input || !input.type) return "";
        switch (input.type) {
            case 'PROJECT': return "Project " + input.projectKey;
            case 'DATASET': return "Dataset " + input.projectKey + "." + input.id;
            case 'RECIPE': return "Recipe " + input.projectKey + "." + input.id;
            default:
                // Pure laziness
                return input.id;
        }
    }
});


app.controller('_TaggableObjectPageRightColumnActions', function($scope, $controller, TaggableObjectsUtils) {

    $controller('TaggableObjectPageMassActionsCallbacks', {$scope: $scope});

    $scope.getSelectedNodes = function() {
        return [$scope.selection.selectedObject];
    };

    $scope.getSelectedTaggableObjectRefs = function() {
        return $scope.getSelectedNodes().map(TaggableObjectsUtils.fromObjectItem);
    };

});


app.controller("DeleteTaggableObjectsModalController", function($scope, $state, $stateParams, Assert, DataikuAPI, WT1, TaggableObjectsUtils, FLOW_COMPUTABLE_TYPES, PUBLISHABLE_TYPES) {

    $scope.$watch("deletionRequests", function(nv, ov) {
        if (nv == null) {
            return;
        }

        Assert.inScope($scope, 'deletionRequests');

        $scope.commonTaggableType = TaggableObjectsUtils.getCommonType($scope.deletionRequests, function(x) {return x.type;});

        // Flow computables, publishable items and dashboards deletion can have impact
        let typesWithImpact = PUBLISHABLE_TYPES.concat(FLOW_COMPUTABLE_TYPES).concat('DASHBOARD');
        let computeImpact = $scope.deletionRequests.filter(function(x) {return typesWithImpact.indexOf(x.type) > -1;}).length > 0;

        if (computeImpact) {
            DataikuAPI.taggableObjects.computeDeletionImpact($scope.deletionRequests, $stateParams.projectKey)
            .success(function(data) {
                $scope.computedImpact.data = data;
                $scope.nbActions = 0;
                for(let k in data.availableOptions) {
                    let optns = data.availableOptions[k];
                    let enabled = false;
                    for(let j in optns) {
                        enabled |= 'isDropDataDangerous' !== j && optns[j];
                    }
                    if(enabled) {
                        $scope.nbActions++;
                    }
                }
                // dashboards have two additional actions
                $scope.deletionRequests.forEach(function(dr) {
                    switch (dr.type) {
                    case 'DASHBOARD':
                        $scope.nbActions += 2;
                        $scope.hasAnyDashboard = true;
                        break;
                    case 'DATASET':
                        dr.options.dropData = $scope.appConfig.dropDataWithDatasetDeleteEnabled;
                        dr.options.dropMetastoreTable = $scope.appConfig.dropDataWithDatasetDeleteEnabled;
                        break;
                    case 'MANAGED_FOLDER':
                        dr.options.dropData = $scope.appConfig.dropDataWithDatasetDeleteEnabled;
                        break;
                    }
                });
            })
            .error(setErrorInScope.bind($scope));
        } else {
            $scope.computedImpact.data = {
                ok: true
            };
        }

        $scope.confirm = function() {
            WT1.event("taggable-items-delete-many", {state: $state.current, numberOfItems: $scope.deletionRequests.length});
            $scope.resolveModal();
            $scope.dismiss();
        };
    });
});

// WARNING Keep the switch in sync with other _XXX_MassActionsCallbacks controllers (flow, taggable objects pages, list pages)
app.controller('TaggableObjectPageMassActionsCallbacks', function($scope, $rootScope, $state, DKUtils, PIPELINEABILITY_ACTIONS) {

    $scope.onAction = function(action) { //NOSONAR
        switch (action) {
            case 'action-delete':
                $state.go("projects.project.flow");
                break;
            case 'action-tag':
                break;
            case 'action-watch':
            case 'action-star':
                $rootScope.$emit('userInterestsUpdated');
                break;
            case 'action-clear':
                DKUtils.reloadState();
                break;
            case 'action-build':
                break;
            case 'action-change-connection':
                DKUtils.reloadState();
                break;
            case 'action-update-status':
            case 'action-set-auto-count-of-records':
            case 'action-set-virtualizable':
            case 'action-add-to-scenario':
            case 'action-share':
                break;
            case 'action-unshare':
                $state.go("projects.project.flow");
                break;
            case 'action-change-recipes-engines':
            case 'action-change-spark-config':
            case PIPELINEABILITY_ACTIONS.changeSpark:
            case PIPELINEABILITY_ACTIONS.changeSQL:
            case 'action-change-impala-write-mode':
            case 'action-change-hive-engine':
            case 'action-change-spark-engine':
                //Should not be possible on this page
                break;
            case 'action-convert-to-hive':
            case 'action-convert-to-impala':
                DKUtils.reloadState();
                break;
            case 'action-change-python-env':
            case 'action-change-r-env':
                DKUtils.reloadState();
                break;
            default:
                break;
        }
    }
});

// WARNING Keep the switch in sync with other _XXX_MassActionsCallbacks controllers (flow, taggable objects pages, list pages)
app.controller('ListMassActionsCallbacks', function($scope, PIPELINEABILITY_ACTIONS) {

    $scope.onAction = function(action) { //NOSONAR
        switch (action) {
            case 'action-delete':
            case 'action-tag':
            case 'action-watch':
            case 'action-star':
            case 'action-clear':
            case 'action-build':
            case 'action-change-connection':
            case 'action-update-status':
            case 'action-set-auto-count-of-records':
            case 'action-set-virtualizable':
            case 'action-add-to-scenario':
            case 'action-share':
            case 'action-unshare':
            case 'action-change-recipes-engines':
            case 'action-change-spark-config':
            case PIPELINEABILITY_ACTIONS.changeSQL:
            case PIPELINEABILITY_ACTIONS.changeSpark:
            case 'action-change-impala-write-mode':
            case 'action-change-hive-engine':
            case 'action-change-spark-engine':
            case 'action-convert-to-hive':
            case 'action-convert-to-impala':
            case 'action-change-python-env':
            case 'action-change-r-env':
                $scope.list();
                break;
            default:
                break;
        }
    }
});


app.controller('_TaggableObjectsListPageCommon', function($controller, $scope, $filter, $state, $stateParams, $rootScope,
    DataikuAPI, WT1, Fn,
    TaggableObjectsService, TaggableObjectsUtils, TaggingService, InterestsService) {

    $controller('ListMassActionsCallbacks', {$scope: $scope});
    $controller('_TaggableObjectsMassActions', {$scope: $scope});

    let loadMoreLock = false;
    $scope.loadMoreItems = function() {
        if(!loadMoreLock && $scope.listItems && $scope.maxItems < $scope.listItems.length) {
            $scope.maxItems += 20;
            loadMoreLock = true;
            setTimeout(function() {loadMoreLock=false;}, 300);
        }
    };

    $scope.selectTag = function(filterQuery,tag) {
        let index = filterQuery.tags.indexOf(tag);
        if(index >= 0) {
            filterQuery.tags.splice(index, 1);
        } else {
            filterQuery.tags.push(tag);
        }
    };

    $scope.restoreOriginalSelection = function() {
        $scope.selection.filteredSelectedObjects.forEach(obj => {
            let i = $scope.listItems.find(item => item.id === obj.id);
            if (i) {
                i.$selected = true;
            }
        });
    }

    $scope.$on('tagSelectedInList', function(e, tag) {
        $scope.selectTag($scope.selection.filterQuery,tag);
        e.stopPropagation();
    });

    $scope.$on('selectedIndex', function(e, index) {
        // an index has been selected, we unselect the multiselect
        $scope.$broadcast('clearMultiSelect');
    });

    $scope.$on('projectTagsUpdated', function (e, args) {
        if (args.refreshFlowFilters) $scope.list();
    });

    const updateSelectedObjectMetadata = function (metaData) {
        const o = $scope.selection.selectedObject;
        if (o) {
            o.shortDesc = metaData.shortDesc;
            o.description = metaData.description;
            o.tags = metaData.tags;
            o.checklists = metaData.checklists;
            o.customFields = metaData.customFields;
        }
    };

    $scope.$on("objectMetaDataRefresh", function(ev, metaData) {
        updateSelectedObjectMetadata(metaData);
    });  

    $scope.$on('objectMetaDataChanged', (ev, metaData) => {
        updateSelectedObjectMetadata(metaData);
    });

    $scope.allStarred = function(listItems) {
        if (!listItems || !listItems.length) return true;
        return listItems.map(x => !!(x && x.interest && x.interest.starred)).reduce((a,b) => a && b);
    };

    $scope.allWatching = function(listItems) {
        if (!listItems || !listItems.length) return true;

        return listItems
            .map(it => it.interest && it.interest.watching)
            .every($scope.isWatching);
    };

    $scope.watchObject = function(watch, item) {
        InterestsService.watch($scope, [TaggableObjectsUtils.fromListItem(item)], watch).then($scope.list); //GRUIK, list is not that necessary
    };

    $scope.starObject = function(star, item) {
        InterestsService.star($scope, [TaggableObjectsUtils.fromListItem(item)], star).then($scope.list); //GRUIK, list is not that necessary
    };

    $scope.toggleFilterStarred = function() {
        let fq = $scope.selection.filterQuery;
        fq.interest.starred = (fq.interest.starred === '' ? 'true' : '');
    };

    /* Default list call */
    $scope.list = function() {
        $scope.listHeads($stateParams.projectKey, $scope.tagFilter).success(function(data) {
            $scope.filteredOut = data.filteredOut;
            $scope.listItems = data.items;
            $scope.restoreOriginalSelection();
            if ($scope.listHeadHook && typeof($scope.listHeadHook.list) === "function") {
                $scope.listHeadHook.list($scope.listItems);
            }
        }).error(setErrorInScope.bind($scope));
    };

    $scope.getSelectedListItems = function() {
        if($scope.selection.selectedObjects && $scope.selection.selectedObjects.length) {
            return $scope.selection.selectedObjects;
        } else if ($scope.selection.selectedObject) {
            return [$scope.selection.selectedObject];
        } else {
            return [];
        }
    };

    $scope.getSelectedTaggableObjectRefs = function() {
        return $scope.getSelectedListItems().map(TaggableObjectsUtils.fromListItem);
    };

    try {
        $scope.listItemType = TaggableObjectsUtils.taggableTypeFromAngularState();
    } catch (e) {
        console.info("Cannot set the taggable type on this list page"); // It will be the case for notebooks in particular since there is no "notebook" taggableType
    }
});


app.service('TaggableObjectsCapabilities', function($stateParams, RecipesCapabilities, TaggableObjectsUtils) {
    $.extend(this, RecipesCapabilities);

    this.canChangeConnection = function(tor) {
        if (tor.nodeType) {
            //This is a node, not a taggableObjectReference
            tor = TaggableObjectsUtils.fromNode(tor);
        }
        if ($stateParams.projectKey && tor.projectKey != $stateParams.projectKey) {
            return false;
        }
        if (tor.type == 'DATASET') {
            if (tor.subType && ['Inline', 'UploadedFiles'].includes(tor.subType)) {
                return false;
            }
            return true;
        } else if (tor.type == 'MANAGED_FOLDER') {
            return true;
        }
        return false;
    };
    this.canSyncMetastore = function(tor) {
        if (tor.nodeType) {
            //This is a node, not a taggableObjectReference
            tor = TaggableObjectsUtils.fromNode(tor);
        }
        if ($stateParams.projectKey && tor.projectKey != $stateParams.projectKey) {
            return false;
        }
        if (tor.type == 'DATASET') {
            if (tor.subType && isHDFSAbleType(tor.subType)) {
                return true;
            }
        }
        return false;
    };
});


// Move the service functionalities to the scope
app.controller('_TaggableObjectsCapabilities', function($scope, TaggableObjectsCapabilities) {
    $.extend($scope, TaggableObjectsCapabilities);
});


app.controller('_TaggableObjectsMassActions', function($scope, $state, $rootScope, $q, $stateParams, WT1, Logger, Dialogs, DataikuAPI, CreateModalFromTemplate,
    TaggableObjectsService, TaggingService,
    ImpalaService, HiveService, SparkService, ComputablesService, DatasetsService, DatasetConnectionChangeService, SubFlowCopyService, RecipesEnginesService, ExposedObjectsService,
    GlobalProjectActions, RecipeDescService, FlowGraphSelection, FlowTool,
    InterestsService, InterestWording, WatchInterestState,
    CodeEnvsService, PipelineService, PIPELINEABILITY_ACTIONS) {
    //Expects a $scope.getSelectedTaggableObjectRefs()

    function onAction(action) {
        return function(data) {
            if ($scope.onAction) {
                $scope.onAction(action);
            } else {
                Logger.warn('No mass action callbacks handler');
            }
            return data;
        };
    }

    // Generic mass actions

    $scope.deleteSelected = function(items = $scope.getSelectedTaggableObjectRefs(), onSuccess = onAction('action-delete')) {
        WT1.event("action-delete", {state: $state.current.name, items: items.length});
        return TaggableObjectsService.delete(items, $scope.customMassDeleteSelected).then(onSuccess);
    };

    $scope.startApplyTagging = function(selection = $scope.getSelectedTaggableObjectRefs()) {
        WT1.event("action-tag", {state: $state.current.name, items: selection.length});
        TaggingService.startApplyTagging(selection).then(onAction('action-tag'));
    };

    $scope.copyAllSelected = function() {
        // Note that we want the nodes here, not the refs
        WT1.event("action-copy-all", {state: $state.current.name, preselectedNodes: $scope.getSelectedNodes().length});
        $scope.startTool('COPY', {preselectedNodes: $scope.getSelectedNodes().map(n => n.id)});
    };

    $scope.watchObjects = function(watch) {
        InterestsService.watch($scope, $scope.getSelectedTaggableObjectRefs(), watch).then(onAction('action-watch'));
    };

    $scope.starObjects = function(star) {
        InterestsService.star($scope, $scope.getSelectedTaggableObjectRefs(), star).then(onAction('action-star'));
    };

    $scope.isWatching = WatchInterestState.isWatching;
    $scope.actionLabels = { ...InterestWording.labels };
    $scope.actionTooltips = { ...InterestWording.tooltips };

    // Computables

    $scope.resynchronizeMetastore = function() {
        WT1.event("action-sync-metastore", {state: $state.current.name, items: $scope.getSelectedTaggableObjectRefs().length});
        HiveService.resynchronizeMetastore($scope.getSelectedTaggableObjectRefs());
    };

    $scope.resynchronizeDataset = function() {
        WT1.event("action-sync-dataset", {state: $state.current.name, items: $scope.getSelectedTaggableObjectRefs().length});
        HiveService.resynchronizeDataset($scope.getSelectedTaggableObjectRefs());
    };

    $scope.clearSelected = function() {
        WT1.event("action-clear", {state: $state.current.name, items: $scope.getSelectedTaggableObjectRefs().length});
        ComputablesService.clear($scope, $scope.getSelectedTaggableObjectRefs()).then(onAction('action-clear'));
    };

    $scope.buildSelected = function() {
        WT1.event("action-build", {state: $state.current.name, items: $scope.getSelectedTaggableObjectRefs().length});
        $scope.buildSelectedComputables($scope.getSelectedTaggableObjectRefs()).then(onAction('action-build'));
    }

    $scope.changeSelectedItemsConnections = function() {
        WT1.event("action-change-connection", {state: $state.current.name, items: $scope.getSelectedTaggableObjectRefs().length});
        DatasetConnectionChangeService.start($scope.getSelectedTaggableObjectRefs()).then(onAction('action-change-connection'));
    };

    $scope.updateStatuses = function() {
        const items = $scope.getSelectedTaggableObjectRefs().filter(it => it.type == 'DATASET');
        WT1.event("action-update-status", {state: $state.current.name, items: items.length});
        DatasetsService.refreshSummaries($scope, items)
            .then(onAction('action-update-status'))
            .then(function(result) {
                if(result.anyMessage) {
                    Dialogs.infoMessagesDisplayOnly($scope, "Datasets statuses update results", result);
                }
            }, setErrorInScope.bind($scope))
    };

    $scope.startSetAutoCountOfRecords = function() {
        const items = $scope.getSelectedTaggableObjectRefs().filter(it => it.type == 'DATASET');
        WT1.event("action-set-auto-count-of-records", {state: $state.current.name, items: items.length});
        DatasetsService.startSetAutoCountOfRecords(items).then(onAction('action-set-auto-count-of-records'));
    };

    $scope.setAutoCountOfRecords = function(autoCountOfRecords) {
        const items = $scope.getSelectedTaggableObjectRefs().filter(it => it.type == 'DATASET');
        WT1.event("action-set-auto-count-of-records2", {state: $state.current.name, items: items.length});
        DatasetsService.setAutoCountOfRecords(items, autoCountOfRecords).then(onAction('action-set-auto-count-of-records'));
    };

    $scope.setVirtualizable = function(virtualizable) {
        WT1.event("action-set-virtualizable", {state: $state.current.name, items: $scope.getSelectedTaggableObjectRefs().length});
        DatasetsService.setVirtualizable($scope, $scope.getSelectedTaggableObjectRefs(), virtualizable).then(onAction('action-set-virtualizable'));
    };

    $scope.addSelectedToScenario = function() {
        WT1.event("action-add-to-scenario", {state: $state.current.name, items: $scope.getSelectedTaggableObjectRefs().length});

        CreateModalFromTemplate('/templates/scenarios/add-to-scenario-modal.html', $scope, 'AddToScenarioModalController', function(modalScope) {
        /*empty?*/}).then(onAction('action-add-to-scenario'));
    };

    $scope.exposeSelected = function() {
        WT1.event("action-share", {state: $state.current.name, items: $scope.getSelectedTaggableObjectRefs().length});
        ExposedObjectsService.exposeObjects($scope.getSelectedTaggableObjectRefs()).then(onAction('action-share'));
    };

    $scope.unshare = function() {
        WT1.event("action-unshare", {state: $state.current.name, items: $scope.getSelectedTaggableObjectRefs().length});
        ExposedObjectsService.unshare($scope.getSelectedTaggableObjectRefs()).then(onAction('action-unshare'));
    };

    // Recipes

    $scope.changeSelectedRecipesEngines = function() {
        WT1.event("action-change-recipes-engines", {state: $state.current.name, items: $scope.getSelectedTaggableObjectRefs().length});
        RecipesEnginesService.startChangeEngine($scope.getSelectedTaggableObjectRefs()).then(onAction('action-change-recipes-engines'));
    };

    $scope.changeSelectedSparkConfig = function() {
        WT1.event("action-change-spark-config", {state: $state.current.name, items: $scope.getSelectedTaggableObjectRefs().length});
        SparkService.startChangeSparkConfig($scope.getSelectedTaggableObjectRefs()).then(onAction('action-change-spark-config'));
    };

    $scope.changeSelectedPipelineability = function(pipelineActionType) {
        WT1.event(pipelineActionType, {state: $state.current.name, items: $scope.getSelectedTaggableObjectRefs().length});
        const pipelineType = pipelineActionType === PIPELINEABILITY_ACTIONS.changeSpark ? 'SPARK' : 'SQL';
        PipelineService
            .startChangePipelineability($scope.getSelectedTaggableObjectRefs(), pipelineType)
            .then(onAction(pipelineActionType));
    };

    $scope.changeSelectedSparkPipelineability = function() {
        $scope.changeSelectedPipelineability(PIPELINEABILITY_ACTIONS.changeSpark);
    };

    $scope.changeSelectedSqlPipelineability = function() {
        $scope.changeSelectedPipelineability(PIPELINEABILITY_ACTIONS.changeSQL);
    };

    $scope.changeSelectedImpalaWriteMode = function() {
        WT1.event("action-change-impala-write-mode", {state: $state.current.name, items: $scope.getSelectedTaggableObjectRefs().length});
        ImpalaService.startChangeWriteMode($scope.getSelectedTaggableObjectRefs()).then(onAction('action-change-impala-write-mode'));
    };

    $scope.changeSelectedHiveEngine = function() {
        WT1.event("action-change-hive-engine", {state: $state.current.name, items: $scope.getSelectedTaggableObjectRefs().length});
        HiveService.startChangeHiveEngine($scope.getSelectedTaggableObjectRefs()).then(onAction('action-change-hive-engine'));
    };

    $scope.changeSelectedSparkEngine = function() {
        WT1.event("action-change-spark-engine", {state: $state.current.name, items: $scope.getSelectedTaggableObjectRefs().length});
        HiveService.startChangeSparkEngine($scope.getSelectedTaggableObjectRefs()).then(onAction('action-change-spark-engine'));
    };

    $scope.convertSelectedToHive = function() {
        WT1.event("action-convert-to-hive", {state: $state.current.name, items: $scope.getSelectedTaggableObjectRefs().length});
        ImpalaService.convertToHive($scope.getSelectedTaggableObjectRefs()).then(onAction('action-convert-to-hive'));
    };

    $scope.convertSelectedToImpala = function() {
        WT1.event("action-convert-to-impala", {state: $state.current.name, items: $scope.getSelectedTaggableObjectRefs().length});
        HiveService.convertToImpala($scope.getSelectedTaggableObjectRefs()).then(onAction('action-convert-to-impala'));
    };

    $scope.changePythonEnvSelection = function() {
        WT1.event("action-change-python-env", {state: $state.current.name, items: $scope.getSelectedTaggableObjectRefs().length});
        CodeEnvsService.startChangeCodeEnv($scope.getSelectedTaggableObjectRefs(), 'PYTHON', $scope).then(onAction('action-change-python-env'))
    };

    $scope.changeREnvSelection = function() {
        WT1.event("action-change-r-env", {state: $state.current.name, items: $scope.getSelectedTaggableObjectRefs().length});
        CodeEnvsService.startChangeCodeEnv($scope.getSelectedTaggableObjectRefs(), 'R', $scope).then(onAction('action-change-r-env'))
    };

    $scope.computeActionsUsability = function() {
        const usability = {
            recipes: { // quick hack: prefill with actions that will be available even without datasets
                python: {ok: true},
                r: {ok: true},
                shell: {ok: true},
                julia: {ok: true},
            },
            things: {},
            selectablePlugins: []
        };

        function mergeUsability(itemUsability) {
            const rus = usability.recipes;
            $.each(itemUsability.recipes, function(recipeType, ru) {
                if (!rus[recipeType]) {
                    rus[recipeType] = angular.copy({ok: true, details: {enableStatus: 'OK'} });
                }
                if (!rus[recipeType].ok) {
                    return;
                }
                if (!ru.ok) {
                    rus[recipeType].ok = false;
                    rus[recipeType].reason = ru.reason;
                }
            });


            const tus = usability.things;
            $.each(itemUsability.things, function(thing, tu) {
                if (!tus[thing]) {
                    tus[thing] = angular.copy({ok: true, details: {enableStatus: 'OK'} });
                }
                if (!tus[thing].ok) {
                    return;
                }
                if (!tu.ok) {
                    tus[thing].ok = false;
                    tus[thing].reason = tu.reason;
                }
            });
        }

        $scope.getSelectedTaggableObjectRefs().forEach(function(item) {
            if (item.type == 'DATASET') {
                const datasetRef = {
                    projectKey: item.projectKey,
                    name: item.id,
                    type: item.subType
                };
                mergeUsability(GlobalProjectActions.getAllStatusForDataset(datasetRef))
            }
        });
        return usability;
    }
    $scope.startContinuous = function(item) {
        WT1.event("start-continuous")
        CreateModalFromTemplate("/templates/continuous-activities/start-continuous-activity-modal.html", $scope, "StartContinuousActivityController", function(newScope) {
            newScope.recipeId = item.name;
        }).then(function(loopParams) {
            DataikuAPI.continuousActivities.start($stateParams.projectKey, item.name, loopParams).success(function(data){
                onAction('action-build');
            }).error(setErrorInScope.bind($scope));
        });
    }
    $scope.stopContinuous = function(item) {
        WT1.event("stop-continuous")
        DataikuAPI.continuousActivities.stop($stateParams.projectKey, item.name).success(function(data){
            onAction('action-build');
        }).error(setErrorInScope.bind($scope));
    }
    
    $scope.startAllContinuous = function(objects) {
        WT1.event("start-continuous")
        CreateModalFromTemplate("/templates/continuous-activities/start-continuous-activity-modal.html", $scope, "StartContinuousActivityController", function(newScope) {
            newScope.recipeId = objects[0].name;
        }).then(function(loopParams) {
            let promises = objects.map(function(object) {
                return DataikuAPI.continuousActivities.start($stateParams.projectKey, object.name, loopParams)
            });
            $q.all(promises).then(function (values) {
                onAction('action-build');
            });
        });
    };
    $scope.stopAllContinuous = function(objects) {
        WT1.event("stop-continuous")
        let promises = objects.map(function(object) {
            return DataikuAPI.continuousActivities.stop($stateParams.projectKey, object.name)
        });
        $q.all(promises).then(function (values) {
            onAction('action-build');
        });
    };
    $scope.refreshAllContinuous = function(objects) {
        // grab the state of all continuous activities in the project, not just the selected ones
        // but the nodes objects are in the objects parameter
        DataikuAPI.continuousActivities.getStates($stateParams.projectKey).success(function(data) {
            // compute the {beingBuilt,continuousActivityDone} of each activity
            let states = {};
            data.activities.forEach(function(activity) {
                let beingBuilt = activity.desiredState == 'STARTED';
                let continuousActivityDone = beingBuilt && ((activity.mainLoopState || {}).futureInfo || {}).hasResult
                states[activity.recipeId] = {beingBuilt: beingBuilt, continuousActivityDone: continuousActivityDone}
            });
            
            var changes = 0;
            objects.forEach(function(o) {
                let continuousActivityDone = (states[o.name] || {}).continuousActivityDone || false;
                if (o.continuousActivityDone != continuousActivityDone) {
                    o.continuousActivityDone = continuousActivityDone;
                    changes += 1;
                }                    
            });
            if (changes > 0) {
                $rootScope.$broadcast("graphRendered");
            }
        }).error(setErrorInScope.bind($scope));
    };
    
});


app.directive('contributorsList', function($state) {
    return {
        templateUrl: '/templates/contributors-list.html',
        scope: {
            timeline: '=tl'
        },
        link: function(scope) {
            scope.$state = $state;
        }
    };
});


app.service("_SummaryHelper", function($stateParams, Dialogs, DataikuAPI, WT1, Logger, CreateModalFromTemplate, InterestsService) {
    const svc = this;

    this.addEditBehaviour = function($scope, element) {

        $scope.state = {
            currentEditing : null,
            name : { editing: false, newVal: null, selector : ".name-edit-zone"},
            shortDesc : { editing: false, newVal: null, selector : ".shortdesc-edit-zone"},
            description : { editing: false, newVal: null, selector : ".desc-edit-zone"},
            tags: {editing : false, newVal : null},
            projectStatus: {editing : false, newVal : null},

            checklistTitle : { editing : null, newVal : null }
        };

        function cancelAllEdits () {
            if ($scope.state.checklistTitle.editing) {
                $scope.cancelChecklistTitleEdit();
            }
            if ($scope.state.currentEditing) {
                $scope.cancelFieldEdit();
            }
            if ($scope.state.tags.editing) {
                $scope.cancelEditTags();
            }
        }

        $scope.startEditChecklistTitle = function(checklist) {
            cancelAllEdits();
            checklist.editingTitle = true;
            $scope.state.checklistTitle.editing = checklist;
            $scope.state.checklistTitle.newVal = checklist.title;
            window.setTimeout(function() {
                $(".checklist-title", element).on("click.editField", function(e) {
                    e.stopPropagation();
                });
                $("html").on("click.editField", function(event) {
                    $scope.$apply(function() {$scope.cancelChecklistTitleEdit()});
                })
            }, 0)
        };

        $scope.validateChecklistTitleEdit = function() {
            $scope.state.checklistTitle.editing.title = $scope.state.checklistTitle.newVal;
            $scope.cancelChecklistTitleEdit();
        };

        $scope.cancelChecklistTitleEdit = function() {
            $scope.state.checklistTitle.editing.editingTitle = false;
            $scope.state.checklistTitle.editing = null;
            $(".checklist-title", element).off("click.editField");
            $("html").off("click.editField");
        };

        $scope.startFieldEdit = function(field, allowed) {
            if (allowed === false) return;
            cancelAllEdits();
            const fstate = $scope.state[field];
            fstate.editing = true;
            if (fstate.newVal == null) {
                fstate.newVal = $scope.object[field];
            }
            $scope.state.currentEditing = field;

            window.setTimeout(function() {
                fstate.suppressClick = false;
                $(fstate.selector, element).on("mousedown.editField", function(e) {
                    fstate.suppressClick = true;
                });
                $("html").on("mouseup.editField", function(event) {
                    const filterCMHints = function(node) {
                        return node.className == 'CodeMirror-hints';
                    };
                    const filterCMModal = function(node) {
                    return Array.prototype.indexOf.call(node.classList || [],'codemirror-editor-modal') >= 0;  //often this is a DOMTokenList not an array
                    };
                    const filterBSSelect = function(node) {
                        return Array.prototype.indexOf.call(node.classList || [],'bootstrap-select') >= 0;
                    };
                    const filterObjectSelector = function(node) {
                        return Array.prototype.indexOf.call(node.classList || [],'dss-object-selector-popover') >= 0;
                    };
                    const path = event.originalEvent && (event.originalEvent.path || (event.originalEvent.composedPath && event.originalEvent.composedPath()));
                    const isEventFromCMHints = path && path.filter(filterCMHints).length > 0;
                    const isEventFromCMModal = path && path.filter(filterCMModal).length > 0;
                    const isEventFromBSSelect = path && path.filter(filterBSSelect).length > 0;
                    const isEventFromObjectSelector = path && path.filter(filterObjectSelector).length > 0;
                    if (fstate.suppressClick || isEventFromCMHints || isEventFromCMModal || isEventFromBSSelect || isEventFromObjectSelector) {
                        fstate.suppressClick = null;
                    } else {
                        $scope.$apply(function() {$scope.cancelFieldEdit()});
                    }
                })
                $scope.$broadcast('elastic:adjust');
            }, 0)
        };

        $scope.validateFieldEdit = function($event) {
            if ($event) {
                $event.preventDefault();
            }
            $scope.object[$scope.state.currentEditing] = $scope.state[$scope.state.currentEditing].newVal;
            $scope.state[$scope.state.currentEditing].newVal = null;
            $scope.$emit("objectSummaryEdited", $scope.state.currentEditing);
            $scope.cancelFieldEdit();
        };

        $scope.validateFieldEditNotUndefined = function() {
            if ($scope.state[$scope.state.currentEditing].newVal != undefined) {
                $scope.validateFieldEdit();
            }
        }

        $scope.cancelFieldEdit = function() {
            const field = $scope.state.currentEditing;
            if (field) {
                const fstate = $scope.state[field];
                fstate.editing = false;
                fstate.newVal = null;
                $(fstate.selector, element).off("mousedown.editField");
                $("html").off("mouseup.editField");
            }
        };

        $scope.startEditTags = function() {
            cancelAllEdits();
            if ($scope.state.tags.newVal == null) {
                $scope.state.tags.newVal = angular.copy($scope.object.tags);
            }
            $scope.state.tags.editing = true;
        };

        $scope.validateEditTags = function() {
            $scope.$broadcast("tagFieldAddTag", function() {
                $scope.object.tags = angular.copy($scope.state.tags.newVal);
                $scope.state.tags.newVal = null;
                $scope.state.tags.editing = false;
                $scope.$emit("objectSummaryEdited");
            });
        };

        $scope.cancelEditTags = function() {
            $scope.state.tags.newVal = null;
            $scope.state.tags.editing = false;
        };

        $scope.addChecklist = function(index) {
            WT1.event("add-checklist", {objectType: $scope.objectType});
            const nChecklists = $scope.object.checklists.checklists.length;
            $scope.object.checklists.checklists.push({
                id: Math.floor(Math.random()*16777215).toString(16), //16777215 == ffffff
                title:"Todo list"+(nChecklists ? ' '+(nChecklists+1) : ''),
                items: [],
                $newlyCreated : true
            });
        };

        $scope.deleteChecklist = function(index) {
            Dialogs.confirmSimple($scope, "Delete checklist").then(function() {
                $scope.object.checklists.checklists.splice(index, 1);
                $scope.$emit("objectSummaryEdited");
            });
        };

        $scope.$on("checklistEdited", function() {
            $scope.$emit("objectSummaryEdited");
        });

        $scope.editProjectStatus = function(projectStatus) {
            $scope.state.projectStatus.newVal = projectStatus;
            $scope.validateFieldEdit();
        };
    };

    this.addInterestsManagementBehaviour = function($scope) {
        function getTaggableObjects() {
            return [{
                type: $scope.objectType,
                projectKey: $stateParams.projectKey,
                id: $scope.getObjectId()
            }];
        }

        $scope.watchObject = function(watch) { //watch is NOT a boolean : values in YES ENO (explicit no) INO (implicit no) SHALLOW (for projects)
            return InterestsService.watch($scope, getTaggableObjects(), watch)
                .success(function() {
                    $scope.objectInterest.watching = watch;
                    // $scope.objectInterest.nbWatching = data.nbWatching; //TODO @flow
                });
        };

        $scope.starObject = function(star) {
            return InterestsService.star($scope, getTaggableObjects(), star)
                .success(function() {
                    $scope.objectInterest.starred = star;
                    // $scope.objectInterest.nbStarred = data.nbStarred; //TODO @flow
                });
        };

        $scope.showWatchingUsers = function () {
            WT1.event("list-interested-users", {type: 'watches'});
            DataikuAPI.interests.listWatchingUsers($scope.objectType, $stateParams.projectKey, $scope.getObjectId()).success(function(users) {
                const modalScope = $scope.$new();
                modalScope.usersList = users;
                modalScope.icon = "icon-eye-open";
                modalScope.title = users.length + (users.length > 1? " users are " : " user is ") + "watching this object";
                CreateModalFromTemplate("/templates/interested-users.html", modalScope);
            });
        };

        $scope.showUsersWithStar = function () {
            WT1.event("list-interested-users", {type: 'stars'});
            DataikuAPI.interests.listUsersWithStar($scope.objectType, $stateParams.projectKey, $scope.getObjectId()).success(function(users) {
                const modalScope = $scope.$new();
                modalScope.usersList = users;
                modalScope.icon = "icon-star";
                modalScope.title = users.length + " user"+(users.length>1?'s':'')+" starred this object";
                CreateModalFromTemplate("/templates/interested-users.html", modalScope);
            });
        };
    };
});

app.directive('editableSummary', function(DatasetsService, DataikuAPI, $stateParams, $rootScope, TopNav, Dialogs, _SummaryHelper) {
    return {
        templateUrl : '/templates/editable-summary.html',
        scope: {
            object : '=',
            objectType : '@',
            getTags : '=',
            insightMode : '=',
            nameEditable : '=?',
            saveCallback : '=',
            editable : '=?',
            objectInterest : '=?',
            tagColor : '='
        },
        link : function($scope, element, attrs) {
            $scope.appConfig = $rootScope.appConfig;

            if ($scope.nameEditable == undefined) $scope.nameEditable = true;
            $scope.getObjectId = function () {
                if ($scope.objectType == "PROJECT") {
                    return $stateParams.projectKey;
                } else if ($scope.object) {
                    if ($scope.objectType === "DATASET" || $scope.objectType === "DATASET_CONTENT" || $scope.objectType === "RECIPE") {
                        return $scope.object.name;
                    } else {
                        return $scope.object.id;
                    }
                }
                return null;
            };

            _SummaryHelper.addEditBehaviour($scope, element);
            _SummaryHelper.addInterestsManagementBehaviour($scope, element);

            $scope.image = {};
            $scope.pattern = attrs['pattern'];

            $scope.$watch("object", function (nv, ov) {
                if (!nv) return;
                if ($scope.objectType == "PROJECT" || $scope.objectType == "INSIGHT") {
                    $scope.display_image = true;
                    // $scope.image_src = '/dip/api/image/get-image?size=50x50&projectKey=' + $stateParams.projectKey + '&type=' + $scope.objectType + '&id=' + $scope.getObjectId();
                    $scope.totem = {
                        projectKey: $stateParams.projectKey,
                        objectType: $scope.objectType,
                        id: $scope.getObjectId()
                    }
                } else {
                    $scope.display_image = false;
                }
            });

            $scope.nameValidationCB = function(value) {
                if (!value) return true;
                return $scope.isRenamingValid($scope.editSummaryState.formerName, value);
            }

            $scope.isRenamingValid = function(oldName, newName) {
                /* It's a bit ugly to centralize validation here, but it allows reusing the
                directive without complex directive composition with isolate scope */
                if ($scope.objectType == "DATASET") {
                    return DatasetsService.isRenamingValid($stateParams.projectKey, oldName, newName);
                } else if ($scope.objectType === "RECIPE") {
                    return newName.length;
                } else {
                    return newName.length;
                }
            }
            if ($scope.objectType == "DATASET") {
                if (DatasetsService.listPerProject[$stateParams.projectKey] == null) {
                    DatasetsService.updateProjectList($stateParams.projectKey);
                }
            }

            $scope.saveCustomFields = function(customFields) {
                $scope.$emit('customFieldsSummaryEdited', customFields);
            };

            $rootScope.$on('customFieldsSaved', function(event, item, newCustomFields) {
                if (TopNav.sameItem(TopNav.getItem(), item)) {
                    $scope.object.customFields = newCustomFields;
                }
            });
        }
    };
});


app.directive('editableProjectSummary', function($stateParams, $rootScope, TopNav, WT1, DatasetsService, DataikuAPI, _SummaryHelper) {
    return {
        scope : true,
        link : function($scope, element, attrs) {
            $scope.getObjectId = function() {
                return $scope.object && $scope.object.projectKey;
            };

            _SummaryHelper.addEditBehaviour($scope, element);
            _SummaryHelper.addInterestsManagementBehaviour($scope, element);

            $scope.$stateParams = $stateParams;
            $scope.currentBranch = "master";

            $scope.$watch("projectSummary", function(nv) {
                $scope.object = nv;
                $scope.objectType = 'PROJECT';
            });

            $scope.$watch("projectCurrentBranch", function(nv) {
                $scope.currentBranch = nv ? nv : "master";
            });

            $scope.nameValidationCB = function(value) {
                if (!value) return true;
                return $scope.isRenamingValid($scope.editSummaryState.formerName, value);
            };

            $scope.isRenamingValid = function(oldName, newName) {
                return newName.length;
            };

            $scope.saveCustomFields = function(customFields) {
                $scope.$emit('customFieldsSummaryEdited', customFields);
            };

            $rootScope.$on('customFieldsSaved', function(event, item, newCustomFields) {
                if (TopNav.sameItem(TopNav.getItem(), item)) {
                    $scope.object.customFields = newCustomFields;
                }
            });
        }
    };
});

app.controller('CustomFieldsEditModalController', function($scope, $rootScope, PluginConfigUtils) {
    let customFieldsMapFlattenList = [];
    $scope.uiState = { cfComponentIdx: 0 };

    function populateCustomFields() {
        $scope.uiState.customFields = angular.copy($scope.objectCustomFields);
        PluginConfigUtils.setDefaultValues(customFieldsMapFlattenList, $scope.uiState.customFields);
        $scope.uiState.cfComponentIdx = $scope.editingTabIndex === undefined || $scope.editingTabIndex === null ? 0 : $scope.editingTabIndex;
    }

    $scope.$watch('objectType', function() {
        if ($scope.objectType) {
            $scope.customFieldsMap = $rootScope.appConfig.customFieldsMap[$scope.objectType];
            customFieldsMapFlattenList = [];
            $scope.customFieldsMap.forEach(ref => customFieldsMapFlattenList = customFieldsMapFlattenList.concat(ref.customFields));
            if ($scope.objectCustomFields) {
                populateCustomFields();
            }
        }
    });
    $scope.$watch('objectCustomFields', populateCustomFields);
    $scope.save = function() {
        $scope.resolveModal($scope.uiState.customFields);
    };

    populateCustomFields();
});

app.directive('customFieldsPopup', function() {
    return {
        templateUrl: '/templates/taggable-objects/custom-fields-popup.html',
        scope: {
            customFields: '=',
            customFieldsMap: '='
        }
    };
});

app.directive('customFieldsEditForm', function($rootScope) {
    return {
        templateUrl : '/templates/taggable-objects/custom-fields-edit-form.html',
        scope: {
            customFields: '=',
            objectType: '=',
            componentIndex: '='
        },
        link : function($scope, element, attrs) {
            $scope.$watch('componentIndex', function() {
                if ($scope.componentIndex >= 0) {
                    $scope.customFieldsMap = [$rootScope.appConfig.customFieldsMap[$scope.objectType][$scope.componentIndex]];
                } else {
                    $scope.customFieldsMap = $rootScope.appConfig.customFieldsMap[$scope.objectType];
                }
            });
        }
    };
});

// TO DO : Delete this directive when the Summary tab of all DSS objects are moved to the standardizedSidePanel directive
app.directive('customFieldsInSummary', function($rootScope, Logger, PluginConfigUtils) {
    return {
        templateUrl : '/templates/taggable-objects/custom-fields-summary.html',
        scope: {
            customFields: '=',
            objectType: '=',
            saveFn: '='
        },
        link : function($scope, element, attrs) {
            $scope.customFieldsMap = $rootScope.appConfig.customFieldsMap[$scope.objectType];
            let customFieldsMapFlattenList = [];
            $scope.customFieldsMap.forEach(ref => customFieldsMapFlattenList = customFieldsMapFlattenList.concat(ref.customFields));
            $scope.ui = {
                customFields: angular.copy($scope.customFields),
                editing: false
            };
            PluginConfigUtils.setDefaultValues(customFieldsMapFlattenList, $scope.ui.customFields);
            $scope.editCF = function() {
                if (!$scope.saveFn) {
                    Logger.warn("There is no save function attached to the custom fields editable summary");
                    $scope.ui.editing = false;
                } else {
                    $scope.ui.editing = true;
                }
            };
            $scope.discardCF = function() {
                if (!$scope.saveFn) {
                    Logger.warn("There is no save function attached to the custom fields editable summary");
                    $scope.ui.editing = false;
                } else {
                    $scope.ui.customFields = angular.copy($scope.customFields);
                    PluginConfigUtils.setDefaultValues(customFieldsMapFlattenList, $scope.ui.customFields);
                    $scope.ui.editing = false;
                }
            };
            $scope.saveCF = function() {
                if (!$scope.saveFn) {
                    Logger.warn("There is no save function attached to the custom fields editable summary");
                    $scope.ui.editing = false;
                } else {
                    $scope.saveFn(angular.copy($scope.ui.customFields));
                    $scope.ui.editing = false;
                }
            };
            $scope.$watch('customFields', function() {
                $scope.ui.customFields = angular.copy($scope.customFields);
                PluginConfigUtils.setDefaultValues(customFieldsMapFlattenList, $scope.ui.customFields);
            });
        }
    };
});

app.directive('customFieldsInSidePanel', function($rootScope, Logger, PluginConfigUtils, TopNav) {
    return {
        templateUrl : '/templates/taggable-objects/custom-fields-sidepanel.html',
        scope: {
            customFields: '=',
            objectType: '=',
            saveFn: '=',
            editCustomFields: '=',
            editable: '=',
        },
        link : function($scope, element, attrs) {
            $scope.customFieldsMap = $rootScope.appConfig.customFieldsMap[$scope.objectType];
            let customFieldsMapFlattenList = [];
            $scope.customFieldsMap.forEach(ref => customFieldsMapFlattenList = customFieldsMapFlattenList.concat(ref.customFields));
            $scope.ui = {
                customFields: angular.copy($scope.customFields),
            };
            PluginConfigUtils.setDefaultValues(customFieldsMapFlattenList, $scope.ui.customFields);

            $scope.canWriteProject = () => $scope.editable;

            $scope.editCF = function() {
                if (!$scope.saveFn) {
                    Logger.warn("There is no save function attached to the custom fields editable summary");
                }
            };
            $scope.discardCF = function() {
                if (!$scope.saveFn) {
                    Logger.warn("There is no save function attached to the custom fields editable summary");
                } else {
                    $scope.ui.customFields = angular.copy($scope.customFields);
                    PluginConfigUtils.setDefaultValues(customFieldsMapFlattenList, $scope.ui.customFields);
                }
            };
            $scope.saveCF = function() {
                if (!$scope.saveFn) {
                    Logger.warn("There is no save function attached to the custom fields editable summary");
                } else {
                    $scope.saveFn(angular.copy($scope.ui.customFields));
                }
            };
            $scope.$watch('customFields', function() {
                $scope.ui.customFields = angular.copy($scope.customFields);
                PluginConfigUtils.setDefaultValues(customFieldsMapFlattenList, $scope.ui.customFields);
            });

            $rootScope.$on('customFieldsSaved', function(event, item, newCustomFields) {
                if (TopNav.sameItem(TopNav.getItem(), item)) {
                    $scope.ui.customFields = newCustomFields;
                }
            });
        }
    };
});

})();

(function() {
'use strict';

const app = angular.module('dataiku.taggableobjects');


app.service('TaggingService', function($rootScope, $stateParams, $timeout, $q, DataikuAPI, CreateModalFromTemplate, TaggableObjectsUtils) {
    const svc = this;
    let projectTags = {};
    let projectTagsList = undefined;
    let projectTagsUsageMap = undefined;
    let globalTagsCategories = undefined;
    let globalTags = {};


    var setList = function (tagsObj) {
        projectTagsList = [];

        Object.keys(tagsObj).forEach(function(tagTitle, index) {
            projectTagsList.push({'title': tagTitle,  color: tagsObj[tagTitle].color});
        });
        return svc.sortTagList(projectTagsList);
    }

    this.getTagWithUsage = function (tag, items) {
        tag.usage=0;
        items.forEach(i => {if (i.tags && i.tags.indexOf(tag.title)>=0) tag.usage++;});
        tag.initialState = tag.newState = (tag.usage==0 ? 0 : (tag.usage==items.length ? 2 : 1));
        return tag;
    }

    this.sortTagList = function(list) {
        return list.sort((a,b) => a.title.localeCompare(b.title));
    }

    this.getGlobalTags = function(objectType) {
        if (!objectType || objectType === 'TAGGABLE_OBJECT') {
            return globalTags;
        }
        const globalTagsForType = {};
        Object.keys(globalTags).forEach((key) => {
            if (svc.shouldGlobalTagApply(globalTags[key].appliesTo, objectType)) {
                globalTagsForType[key] = globalTags[key];
            }
        });
        return globalTagsForType;
    }

    this.fetchGlobalTags = function(forceFetch) {
        if (globalTagsCategories && !forceFetch) {
            return;
        }
        globalTagsCategories = globalTagsCategories || {};
        DataikuAPI.globalTags.getGlobalTagsInfo().success(function(data) {
            Object.keys(data.globalTags).forEach(function(k) {
                let category = data.globalTags[k].globalTagsCategory;
                Object.assign(data.globalTags[k], {appliesTo : data.globalTagsCategories[category]});
            });
            globalTagsCategories = data.globalTagsCategories;
            globalTags = data.globalTags;
        }).error(setErrorInScope.bind($rootScope));
    }

    this.setProjectTags = function(tags) {
        projectTags = fillTagsMap(tags);
        projectTagsList = undefined;
    };

    this.getProjectTags = function() {
        return projectTags;
    };

    this.getProjectTagsList = function(objectType) {
        if (projectTagsList==undefined) setList(Object.assign(this.getProjectTags(), globalTags));
        return projectTagsList;
    }

    this.getProjectTagsUsageMap = function () {
        const deferred = $q.defer();
        DataikuAPI.taggableObjects.listTagsUsage($stateParams.projectKey, {}, "nospinner").success(function(data) {
            projectTagsUsageMap = data;
            deferred.resolve(projectTagsUsageMap);
        });
        return deferred.promise;
    }

    this.startApplyTagging = function(selectedItems) {
        return CreateModalFromTemplate('/templates/apply-tags-modal.html', $rootScope, 'ApplyTaggingController', function(modalScope) {
            modalScope.selectedItems = selectedItems;
            modalScope.itemsType = TaggableObjectsUtils.getCommonType(selectedItems, it => it.type);
            modalScope.tagsSorted = svc.getTagsSorted([{...projectTags, ...globalTags}], t => svc.getTagWithUsage(t, selectedItems), modalScope.itemsType);
        });
    };

    this.applyTagging = function(request) {
        return DataikuAPI.taggableObjects.applyTagging($stateParams.projectKey, request)
            .success(function() {
                $rootScope.$broadcast('taggableObjectTagsChanged');
            }).error(setErrorInScope.bind($rootScope));
    };

    this.getTagColor = function(tag) {
        return globalTags[tag] ? globalTags[tag].color : projectTags[tag] ? projectTags[tag].color : svc.getDefaultColor(tag);
    };

    this.getGlobalTagCategory = function(tag, objectType) {
        if (globalTags[tag]) {
            let category = globalTags[tag].globalTagsCategory;
            if (objectType == "TAGGABLE_OBJECT" || svc.shouldGlobalTagApply(globalTagsCategories[category],objectType)) {
                return category;
            }
            return false;
        }
        return  null;
    };

    var pushTagsToList = function (tags, list) {
        Object.keys(tags).forEach(function(tagTitle, index) {
            const t = tags[tagTitle];
            const titleLower = tagTitle.toLowerCase();
            list.push({tag: t, title: tagTitle, titleLower: titleLower});
        });
    }

    this.shouldGlobalTagApply = function(appliesTo, objectType) {
        return objectType === "TAGGABLE_OBJECT" || appliesTo.includes(objectType);
    };

    this.getTagsSorted = function(tagLists, fTagMapper, itemsType) {
        const list = [];

        tagLists.forEach(l => pushTagsToList(l, list));

        const titleLookup = {};
        const filteredList = list.filter(it => (!it.tag.appliesTo || !itemsType || (itemsType && svc.shouldGlobalTagApply(it.tag.appliesTo, itemsType))));
        //sort global tags last and if both are global tags, sort by localeCompare
        let sortedList = filteredList.sort((a,b) => (!!a.tag.globalTagsCategory - !!b.tag.globalTagsCategory) || a.title.localeCompare(b.title));
        sortedList.forEach((item, index) => {
            titleLookup[item.titleLower] = index;
        });
        if (fTagMapper) sortedList = sortedList.map(fTagMapper)
        return {list: sortedList, titleLookup: titleLookup}
    }

    this.applyManageTagsChangesToTagList = function (tagsList, newAllTags, keepOrphans) { //rename any tags in-edit
        const newTags = [];
        tagsList.forEach( tag => {
            if (newAllTags[tag]) {
                if (newAllTags[tag].updatedTagName) {
                    newTags.push(newAllTags[tag].updatedTagName);
                }
                else {
                    newTags.push(tag);
                }
            }
            else if (keepOrphans) {
                newTags.push(tag);
            }
        })
        return newTags;
    }

    const COLORS = [
        "#1ac2ab",
        "#0f6d82",
        "#FFD83D",
        "#de1ea5",
        "#90a8b7",
        "#28aadd",
        "#00a55a",
        "#94be8e",
        "#d66b9b",
        "#77bec2",
        "#123883",
        "#a088bd"
    ];

    this.getDefaultColor = function(tag) {
        const hash = tag.split('').reduce(function(a,b) {a=((a<<5)-a)+b.charCodeAt(0);return a&a;},0); //NOSONAR a&a basically means floor, who cares if it is unclear here?
        return COLORS[Math.abs(hash) % 12];
    }

    function fillTagsMap(tags) {
        for (let tag in tags) {
            if (globalTags[tag]) { //update projectTags with globalTags informations
                tags[tag] = globalTags[tag];
            }
            if (!tags[tag].color) {
                tags[tag].color = svc.getDefaultColor(tag);
            }
            const col = d3.rgb(tags[tag].color);
            tags[tag].fadedColor = 'rgba('+col.r+','+col.g+','+col.b+', 0.35)';
        }
        return tags;
    }

    this.fillTagsMapFromArray = function(a) {
        const tagMap = {}
        a.map((tag) => tagMap[tag] = {});
        return fillTagsMap(tagMap);
    }

    function  argsForUpdateBcast(refreshFlowFilters, checkFilterQuery, updateGraphTags) {
        const args = {}
        args.refreshFlowFilters = refreshFlowFilters;
        args.checkFilterQuery = checkFilterQuery;
        args.updateGraphTags = updateGraphTags;
        return args;
    }

    this.bcastTagUpdate = function (minReloadReqd, updateGraphTags) {
        $rootScope.$broadcast('projectTagsUpdated', argsForUpdateBcast(!minReloadReqd, minReloadReqd, updateGraphTags));
    }

    this.update = function(minReloadReqd) {
        return DataikuAPI.taggableObjects.listTags($stateParams.projectKey).success(function(response) {
            svc.setProjectTags(response.tags);
            svc.bcastTagUpdate(minReloadReqd, false);
        });
    };

    this.saveToBackend = function(newTags) {
        return DataikuAPI.taggableObjects.setTags($stateParams.projectKey, newTags).success(function(response) {
            svc.setProjectTags(response.tags);
            svc.bcastTagUpdate(true, false);
        });
    };
});


app.filter('tagToColor', function(TaggingService) {
    return function(tag) {
        return TaggingService.getTagColor(tag);
    }
});

const TRISTATES = {
    OFF: 0,
    PART: 1,
    ON: 2,
    ROTATE: 3
}

app.controller('ApplyTaggingController', function($scope, WT1, TaggingService, CreateModalFromTemplate, $timeout) {
    /*  expect initialisation via TaggingService.startApplyTagging:
     *  scope.selectedItems, scope.itemsType, scope.tagsSorted
    */

    var pushOperation = function(operations, allTags, mode) {
        const reqdState = (mode=='ADD' ? TRISTATES.ON : TRISTATES.OFF);
        const tags = allTags.filter(t => t.newState!=t.initialState && t.newState==reqdState).map(t => t.title);
        if (tags.length > 0) {
            WT1.event("tagging-apply", {tags: tags.length, elements: $scope.selectedItems.length, add: (mode=='ADD')});
            operations.push({tags: tags, mode: mode});
        }
    }

    $scope.uiState = {newTag: ""};

    $scope.save = function() {
        const request = {elements: $scope.selectedItems, operations: [] };
        ['ADD', 'REMOVE'].forEach(mode => pushOperation(request.operations, $scope.tagsSorted.list, mode));

        if (request.operations.length > 0) {
            TaggingService.applyTagging(request)
            .success($scope.resolveModal)
            .error(setErrorInScope.bind($scope));
        }
        else {
            $scope.resolveModal();
        }

    }

    $scope.isChanged = function(tag) {
        return (tag.initialState != tag.newState);
    }

    $scope.createTagOnEnter = function(event) {
        if (event.which === 13) { // create tag when enter key is pressed
            $scope.onAddTag();
        }
    }

    $scope.usageText = function (tag) {
        switch (tag.newState) {
            case TRISTATES.OFF: return "-";
            case TRISTATES.PART: return tag.usage + "/" + $scope.selectedItems.length;
            case TRISTATES.ON: return $scope.selectedItems.length + "/" + $scope.selectedItems.length;
            default:
                break;
        }
    }

    $scope.hasTags = function() {
        return $scope.tagsSorted.filteredList.length > 0;
    }

    const addNewTagToList = function (title, newState, color) {
        $scope.tagsSorted.list.push({
            title: title,
            tag: {color: color ? color : TaggingService.getDefaultColor(title)},
            initialState: TRISTATES.OFF,
            newState: newState});

        $scope.tagsSorted.titleLookup[title.toLowerCase()] = "new";
    }

    const isNewlyAdded = function (title) {
        return $scope.tagsSorted.titleLookup[title.toLowerCase()] == "new"
    }

    $scope.onAddTag = function(){
        if ($scope.canCreateTag()) {
            addNewTagToList($scope.uiState.newTag, TRISTATES.ON);
            TaggingService.sortTagList($scope.tagsSorted.list);
            $scope.uiState.newTag = "";
        }
    };

    function filterTagListByInput(input = $scope.uiState.newTag) {
        if (!input) return $scope.tagsSorted.list;
        return $scope.tagsSorted.list.filter(tag => tag.title.toLowerCase().startsWith(input.toLowerCase()));
    };

    $scope.$watch('uiState.newTag', (nv) => {
        TaggingService.sortTagList($scope.tagsSorted.list);
        $scope.tagsSorted.filteredList = filterTagListByInput(nv);
    });

    $scope.canCreateTag = function() {
        const titleLower = $scope.uiState.newTag.toLowerCase();
        return titleLower && !$scope.tagsSorted.titleLookup.hasOwnProperty(titleLower);
    };

    $scope.rotateCheckbox = function(item) {
        item.newState = TRISTATES.ROTATE;
    }
});

app.directive('checkboxTristate', function () {
    return {
        template: `<input type="checkbox" name="{{id}}" id="{{id}}" ng-click="rotate()" aria-label="{{alabel}}" > `,
        scope: {
            triState: "=ngModel",  // 0=off 1=indeterminate 2=checked
            initialState: "=",
            id: "=",
            alabel: "="
        },
        link: function (scope, $element) {
            const chkbx = $element.children()[0];

            scope.onSet = function (newState) {
                scope.triState = newState;
                switch (newState) {
                    case TRISTATES.PART:  {
                        chkbx.checked = false;
                        chkbx.indeterminate = true;
                        break;
                    }
                    default: {
                        chkbx.checked = !!newState;
                        chkbx.indeterminate = false;
                        break;
                    }

                }
            }

            var incrementValue = function (v) {
                let newState = (v+1) % 3;
                if (newState==TRISTATES.PART && scope.initialState!=TRISTATES.PART) newState = TRISTATES.ON; //you can only return to indeterminate state
                return newState;
            }
            scope.rotate = function (event) {
                const newState = incrementValue(scope.triState);
                scope.onSet(newState);
            }

            scope.$watch("triState", function(nv, ov) {
                if (nv==TRISTATES.ROTATE) {
                    nv = incrementValue(ov);
                }
                scope.onSet(nv);
            });

            scope.onSet(scope.triState);
        }
    }
});

app.directive('addTagInput', function() {
    return {
        template: `<form class="common-styles-only tag-form noflex horizontal-flex" >
                        <input class="flex" type="text"
                        ng-model="newTag"
                        ng-class="{'has-error': !validator()}"
                        placeholder="Create new tag"
                        ng-keydown="onAddKeydown($event)"
                        aria-label="Create new tag" />

                    <button type="button"
                        class="btn btn--primary tags-settings-btn noflex"
                        ng-disabled="uiState.newTag.length == 0 || !validator()"
                        ng-click="addTag($event)">Add</button>
                </form>`,
        scope:   {
            newTag: '=ngModel',
            validator: '&',
            onAddTag: '&'
        },
        link: function (scope, $element){

            function eatEvent(e) {
                e.stopPropagation();
                e.preventDefault();
            }
            scope.onAddKeydown = function (e) {
                if (e.keyCode == 13) { // enter
                    scope.onAddTag();
                    eatEvent(e);
                }
            };

            scope.addTag = function(e) {
                if (scope.validator()) scope.onAddTag();
                eatEvent(e);
            }
        }
    }
});

app.directive('tagsList', function(Assert, CreateModalFromTemplate, TaggingService) {
    return {
        template: `<div class="tagsList">
            <ul class="tags vertical-flex">
                <li ng-repeat="tag in tags">
                    <span ng-if="isTagSelected(tag)" class="tag selected" ng-click="addTag(tag)" style="color:white; background-color:#{{tag.color.substring(1)}}" >
                        <span class="bullet" style="background-color:white;"> </span>
                        <span ui-global-tag="tag.title" object-type="objectType"/>
                    </span>
                    <span ng-if="!isTagSelected(tag)" class="tag" ng-click="addTag(tag)">
                        <span class="bullet" style="background-color:{{tag.color}};"> </span>
                        <span ui-global-tag="tag.title" object-type="objectType"/>
                    </span>
                </li>
                <li ng-if="noTagAvailable()">
                    <span class="tag disabled">No tag available</span>
                </li>
            </ul>
            <button class="btn btn--contained btn--tag-list" ng-click="manageTags()" ng-if="$parent.canWriteProject()">Manage tags</button>
        </div>`,
        scope: {
            selected: '=tagsListSelected',
            objectType: '='
        },
        link: function(scope, element) {
            scope.tags = TaggingService.getProjectTagsList(scope.objectType);
            Assert.trueish(scope.tags, 'no tags list');

            scope.noTagAvailable = function() {
                return scope.tags.length == 0;
            };

            scope.$on('projectTagsUpdated', function (e, args) {
                scope.tags = TaggingService.getProjectTagsList(objectType);
            });

            scope.isTagSelected = function(tag) {
                return scope.selected.indexOf(tag.title) > -1;
            }

            scope.manageTags = function() {
                CreateModalFromTemplate("/templates/widgets/edit-tags-modal.html", scope, null, function(modalScope) {
                    modalScope.tagsDirty = angular.copy(TaggingService.getProjectTags());

                    modalScope.save = function() {
                        scope.selected = TaggingService.applyManageTagsChangesToTagList(scope.selected, modalScope.tagsDirty);
                        TaggingService.saveToBackend(modalScope.tagsDirty)
                            .success(modalScope.resolveModal)
                            .error(setErrorInScope.bind(scope));
                    };
                    modalScope.cancel = function() {modalScope.dismiss();};
                });
            };

            scope.addTag = function(tag) {
                scope.$emit('tagSelectedInList', tag.title);
            };
        }
    };
});


app.directive('tagsListEditor', function($timeout, TaggingService){
    return {
        scope: {
            tags: '=tagsListEditor'
        },
        replace: true,

        template: `<div class="tags-settings vertical-flex h100" style="position:relative" >
        <div class="tag-edit-filter" ng-class="{'tag-edit-filter--focus': filterFocused}">
            <i class="icon-dku-search"></i>
            <input ng-model="uiState.newTag" name="tagEditorInput" type="search" ng-keydown="createTagOnEnter($event)" auto-focus="true" tabindex="0"
                ng-focus="filterFocused = true" ng-blur="filterFocused = false" autocomplete="off"
                placeholder="Filter tags or create a new tag" class="tag-edit-filter__input" aria-label="Selected tags"/>
        </div>
        <div ng-if="hasTag()" class="tag-help-text">
            <span class="tag-help-text__name">Tag name</span>
            <span ng-if="totalObjects > 0" class="tag-help-text__usage">Tag usage</span>
        </div>
        <div class="tags">
            <editable-list ng-if="hasTag()" ng-model="tagsSorted.list" class="tags" disable-create-on-enter="true" skip-to-next-focusable="true"
                transcope="{ uiState: uiState, canRenameTag: canRenameTag, updateTag: updateTag, onRemoveTag: onRemoveTag, onRestoreTag: onRestoreTag}"
                disable-remove="true" disable-add="true" full-width-list="true" has-divider="false">

                <div class="tag-row tag-row--editable-list horizontal-flex"
                    scroll-to-me="{{uiState.scrollToTagIdx==$index}}">

                    <div class="tag-row-item flex horizontal-flex">
                        <span class="tag-color noflex" style="background-color:{{it.tag.color}};" colorpicker colorpicker-with-input="true" ng-model="it.tag.color" aria-role="button" aria-label="Tag color">
                            <i class="icon-tint"></i>
                        </span>
                        <span ng-if="!it.tag.globalTagsCategory" class="tag-edit flex common-styles-only horizontal-flex">
                            <editable-list-input type="text" class="tag-input flex" ng-init="it.updatedTagName = it.tag.updatedTagName || it.title" ng-model="it.updatedTagName" on-key-up-callback="updateTag(it)" aria-label="Tag name" required="true" unique="true"/>
                        </span>
                        <span ng-if="it.tag.globalTagsCategory" class="tag-title flex">
                            <span ui-global-tag="it.tag.updatedTagName || it.title" object-type="'TAGGABLE_OBJECT'"></span>
                        </span>
                        <span ng-show="$parent.$parent.totalObjects > 0" class="tag-usage noflex">{{$parent.$parent.tagsUsage[it.title] || '-'}}</span>
                    </div>
                    <button ng-if="!it.tag.globalTagsCategory" class="noflex btn btn--text btn--danger btn--icon editable-list__delete m0" ng-click="onRemoveTag($event, it.title)"><i class="icon-trash"></i></button>
                    <i ng-if="it.tag.globalTagsCategory" class="noflex icon-info-sign" aria-role="button" aria-label="Restore tag: {{it.title}}"></i>
                </div>
            </editable-list>
            <div ng-if="canCreateTag()" class="tags">
                <div ng-if="canCreateTag()" class="tag-row horizontal-flex tags-settings__create" ng-click="onAddNewTag(e)" ng-keyup="$event.keyCode == 13 && onAddNewTag(e)" tabindex="0">
                    <i class="icon-plus flex-no-grow"></i>
                    <span class="flex">Create &laquo;{{uiState.newTag}}&raquo;</span>
                    <code class="dku-tiny-text-sb text-weak tags-settings__create-shortcut">enter</code>
                    <span class="return flex-no-grow tags-settings-btn mright4">&crarr;</span>
                </div>
            </div>
        </div>
        <div ng-if="!hasTag() && !canCreateTag()" class="noflex no-tag-yet"><p>No tags available</p></div>

    </div>`,

        link: function(scope, element, attrs){
            scope.uiState = {
                originalTagName: "",
                updatedTagName: "",
                editTagIdx : undefined,
                newTag: "",
                scrollToTagIdx : undefined
            };

            scope.totalObjects = 0;

            var ui = scope.uiState;

            var eatEvent = function(e) {
                if (e) {
                    e.stopPropagation();
                    e.preventDefault();
                }
            };

            scope.updateTag = function(item) {
                if (item.title === item.updatedTagName && !item.isEdited) {
                    return;
                }
                ui.originalTagName = item.title;
                ui.updatedTagName = item.updatedTagName || "";
                const tag = scope.tags[ui.originalTagName];
                tag.updatedTagName = ui.updatedTagName;
                tag.isEdited = true;
            }

            scope.createTagOnEnter = function(event) {
                if (event.which === 13) { // create tag when enter key is pressed
                    scope.onAddNewTag(event);
                }
            };

            scope.$watch('uiState.newTag', updateSortedTags);

            function filterTagsByInput(input) {
                const allTags = Object.assign({}, scope.tags, scope.globalTags);
                if (!input) {
                    return allTags;
                }
                const filteredTags = {};
                if (allTags) {
                    Object.keys(allTags).forEach((tagTitle) => {
                        const lowerTitle = tagTitle.toLowerCase();
                        if (lowerTitle.startsWith(input)) {
                            filteredTags[tagTitle] = allTags[tagTitle];
                        }
                    });
                }
                return filteredTags;
            }

            function updateSortedTags() {
                const input = ui.newTag.toLowerCase();
                const filteredTags = filterTagsByInput(input);
                scope.tagsSorted = TaggingService.getTagsSorted([filteredTags]);
            }

            var calcTagUsageForCurrentProject = function() {
                scope.tagsUsage = {};
                TaggingService.getProjectTagsUsageMap().then(usageMap => {
                    const tagsUsage = {};
                    scope.totalObjects = 0;
                    Object.keys(usageMap).forEach((objName) => {
                        scope.totalObjects++;
                        const tags = usageMap[objName];
                        tags.forEach(tagName => {
                            if (!tagsUsage[tagName]) tagsUsage[tagName]=0;
                            tagsUsage[tagName]++;
                        });
                    });
                    Object.keys(scope.tags).forEach(function(t) {
                       if (isNaN(tagsUsage[t])) tagsUsage[t] = 0;
                    });
                    scope.tagsUsage = angular.copy(tagsUsage);
                });
            };

            scope.$watch("tags", function(nv, ov) {
                if (!angular.equals(nv, ov)) {
                    getGlobalTags();
                    updateSortedTags();
                    calcTagUsageForCurrentProject();
                }
            });

            function getGlobalTags() {
                scope.globalTags = TaggingService.getGlobalTags();
                scope.$parent.hasGlobalTags = Object.keys(scope.globalTags).length > 0;
            };
            getGlobalTags();

            scope.onAddNewTag = function(e) {
                if (scope.canCreateTag()) {
                    scope.tags[ui.newTag] = {color: TaggingService.getDefaultColor(ui.newTag), usage:0, isNew: true};
                    updateSortedTags();
                    ui.scrollToTagIdx = scope.tagsSorted.titleLookup[ui.newTag.toLowerCase()];
                    ui.newTag = "";
                }
                updateSortedTags();
                eatEvent(e);
            };

            scope.canCreateTag = function() {
                const titleLower = ui.newTag.toLowerCase();
                return titleLower && !scope.tagsSorted.titleLookup.hasOwnProperty(titleLower);
            };

            scope.onRemoveTag = function(e, tag) {
                ui.updatedTagName = "";
                delete scope.tags[tag];
                updateSortedTags();
                eatEvent(e);
            };

            scope.canRenameTag = function() {
                const toLower = ui.updatedTagName.toLowerCase();
                if (ui.originalTagName.toLowerCase() == toLower) return true;
                return toLower && !scope.tagsSorted.titleLookup.hasOwnProperty(toLower);
            };

            scope.hasTag = function() {
                return !$.isEmptyObject(scope.tags) || !$.isEmptyObject(scope.globalTags);
            };

            updateSortedTags();
            calcTagUsageForCurrentProject();
            element.find('.tag-edit-filter__input').focus();
        }
    };
});

})();
(function() {
'use strict';

const app = angular.module('dataiku.collab.timeline', []);


app.directive("objectTimelineWithPost", function(DataikuAPI) {
    return {
        templateUrl: '/templates/widgets/object-timeline-with-post.html',
        restrict: "A",
        scope: {
            objectType: '=',
            projectKey: '=',
            objectId: '=',
            initialTimeline: '=',
            initialFetch: '@',
            fetchTimelinePromiseFn: '=?'
        },
        link: function($scope) {
            $scope.refreshTimeline = function () {
                if ($scope.fetchTimelinePromiseFn) {
                    $scope.fetchTimelinePromiseFn().success(function (data) {
                        $scope.timeline = data;
                    }).error(setErrorInScope.bind($scope));
                } else {
                    DataikuAPI.timelines.getForObject($scope.projectKey, $scope.objectType, $scope.objectId).success(function (data) {
                        $scope.timeline = data;
                    }).error(setErrorInScope.bind($scope));
                }
            };
            $scope.$watch("initialTimeline", function(nv, ov) {
                if (nv) $scope.timeline = $scope.initialTimeline;
            });
            if ($scope.initialFetch) {
                $scope.refreshTimeline();
            }
        }
    }
});


app.service("TimelineItemUtils", function() {
    const svc = this;
    this.isAboutTags = function(evt) {
        return evt.details.addedTags || evt.details.removedTags;
    };
    this.isAboutTasks = function(evt) {
        return evt.details.totalTasks != null;
    };
    this.isAboutDescriptions = function(evt) {
        return evt.details.descriptionEdited || evt.details.shortDescEdited;
    };
    this.isAboutTagsOnly = function(evt) {
        return svc.isAboutTags(evt) && !svc.isAboutTasks(evt) && !svc.isAboutDescriptions(evt);
    };
    this.isAboutTasksOnly = function(evt) {
        return !svc.isAboutTags(evt) && svc.isAboutTasks(evt) && !svc.isAboutDescriptions(evt);
    };
    this.isMoreComplex = function(evt) {
        return !svc.isAboutTasksOnly(evt) && !svc.isAboutTagsOnly(evt)
    };
});


app.directive('timeline', function($filter, $state) {
    return {
        templateUrl: '/templates/timeline.html',
        scope: {
            timeline: '=timeline',
            context: '@',
            reverse: '@'
        },
        link: function(scope, element) {
            function humanReadableObjectType (objectType) {
                if (!objectType) return;
                switch(objectType) {
                case "MANAGED_FOLDER":
                    return "folder";
                case "SAVED_MODEL":
                    return "model";
                case "MODEL_EVALUATION_STORE":
                    return "evaluation store";
                case "LAMBDA_SERVICE":
                    return "API service";
                default:
                    return objectType.toLowerCase().replace('_', ' ');
                }
            }

            let maxItems = 15;

            function update() {
                if (!scope.timeline) {return}
                angular.forEach(scope.timeline.items, function(item) {
                    item.day = $filter('friendlyDate')(item.time);
                    item.humanReadableObjectType = humanReadableObjectType(item.objectType);
                    item.details = item.details || {};
                    item.details.objectDisplayName = item.details.objectDisplayName || item.objectId;
                });

                const displayedItems = scope.timeline.items ? scope.timeline.items.slice() : [];

                scope.orderedItems = $filter('orderBy')(displayedItems, (scope.reverse?'-time':'time'));
                scope.orderedItems = scope.orderedItems.slice(0, maxItems);

                /* Insert days separators */
                scope.orderedItemsWithDays = [];
                scope.orderedItems.forEach(function(x, i) {
                    if (i === 0) {
                        scope.orderedItemsWithDays.push({isSeparator: true, day : x.day});
                        scope.orderedItemsWithDays.push(x);
                    } else if (x.day === scope.orderedItems[i-1].day) {
                        scope.orderedItemsWithDays.push(x);
                    } else {
                        scope.orderedItemsWithDays.push({isSeparator: true, day : x.day});
                        scope.orderedItemsWithDays.push(x);
                    }
                });
            }

            scope.$state = $state;
            scope.$watch('timeline', function(nv, ov) {
                if(nv) update();
            });

            scope.scroll = function() {
                maxItems += 20;
                update();
            }
        }
    };
});


app.directive('timelineItem', function(TimelineItemUtils) {
    return {
        templateUrl: '/templates/timeline-item.html',
        link: function(scope) {
            scope.TimelineItemUtils = TimelineItemUtils;
        }
    };
});


app.directive('discussionMentionItem', function() {
    return {
        templateUrl: '/templates/discussion-mention-item.html',
    };
});

app.directive('discussionReplyItem', function() {
    return {
        templateUrl: '/templates/discussion-reply-item.html',
    };
});

app.directive('discussionCloseItem', function() {
    return {
        templateUrl: '/templates/discussion-close-item.html',
    };
});

app.directive('commitMentionItem', function() {
    return {
        templateUrl: '/templates/commit-mention-item.html',
    };
});


app.directive('timelineTaskItem', function(DataikuAPI) {
    return {
        templateUrl: '/templates/task-notification-item.html',
        link: function(scope) {
            scope.downloadExport = function(exportId) {
                downloadURL(DataikuAPI.exports.getDownloadURL(exportId));
            };
        }
    };
});


})();
(function() {
'use strict';

const app = angular.module('dataiku.collab.discussions', []);


app.controller('DiscussionsWidgetController', function($scope, $state, $location, $stateParams, $rootScope, $timeout, $filter, Assert, DataikuAPI, WT1, TopNav, Notification, Dialogs, ActivityIndicator, Debounce) {
    let currentItem;

    $scope.appConfig = $rootScope.appConfig;
    $scope.uiState = {};

    /**** UI ****/
    $scope.discussionWidgetPage = function() {
        if (!$scope.discussions) {
            return 'LIST'; //loading
        } else if ($scope.uiState.creatingNewConv) {
            return 'CREATION';
        } else if (!$scope.uiState.creatingNewConv && !$scope.uiState.selectedConv) {
            return 'LIST';
        } else {
            return 'DISCUSSION';
        }
    };

    $scope.onSearchBarEnter = function($event) {
        $event.target.blur();
    };

    $scope.getNewRepliesLabel = function() {
        if (!$scope.uiState.selectedConv) {
            return;
        }
        const newRepliesCount = $scope.getNumberOfNewReplies($scope.uiState.selectedConv, $scope.uiState.cachedUserReadTime || 0);
        return newRepliesCount + ' new repl' + (newRepliesCount > 1 ? 'ies' : 'y');
    };

    $scope.getNumberOfNewReplies = function(discussion, fromTime) {
        if (!discussion) {
            return;
        }
        return discussion.replies.filter(reply => reply.time > fromTime).length;
    };

    $scope.getDisabledReason = function() {
        if (!$scope.uiState.selectedConv && !($scope.uiState.newConvTopic || '').length) {
            return 'The topic cannot be empty!';
        }
        if (!$scope.uiState.selectedConv && ($scope.uiState.newConvTopic || '').length > 200) {
            return 'The topic cannot be longer than 200 characters!';
        }
        if (!($scope.uiState.newReply || '').length) {
            return 'The message cannot be empty!';
        }
        if (($scope.uiState.newReply || '').length > 10000) {
            return 'The message cannot be longer than 10000 characters!';
        }
        return 'Press Enter to insert a new line. And press Ctrl+Enter to send your message.';
    };

    $scope.viewNewReplies = function(scrollToNewReplies) {
        $scope.uiState.displayToastNewReplies = false;
        $scope.uiState.invalidateCachedUserReadTime = true;
        if (scrollToNewReplies) {
            $timeout(function() {
                const el = $('.discussions-widget-list-replies');
                const newReplies = $('.discussions-widget-newreplies');
                if (!newReplies || !el.get(0)) {
                    return;
                }
                const scrollPos = newReplies.length ? el.scrollTop() + newReplies.position().top : el.get(0).scrollHeight;
                el.scrollTop(scrollPos);
            }, 200);
        }

        if ($scope.uiState.selectedConv && (($scope.uiState.selectedConv.users[$rootScope.appConfig.login] || {}).lastReadTime || 0) <= $scope.uiState.selectedConv.lastReplyTime) {
            DataikuAPI.discussions.ack(currentItem.projectKey, currentItem.type, currentItem.id, $scope.uiState.selectedConv.id)
                .error(setErrorInScope.bind($scope));
        }
    };

    $scope.openDiscussion = function(discussion, userAction) {
        $scope.uiState.selectedConv = discussion;
        // handle new replies when discussion is opened
        if ($scope.uiState.selectedConv) {
            // refresh cached user read time when:
            // - flag invalidate is true
            // - action comes from user
            // - no new reply from other users (basically exclude same user replies)
            const newLastReadTime = (($scope.uiState.selectedConv.users[$rootScope.appConfig.login] || {}).lastReadTime || 0);
            const hasLastReadTimeChanged = newLastReadTime != $scope.uiState.cachedUserReadTime;
            const hasNoPeerNewReplies = !$scope.uiState.selectedConv.replies.filter(reply => reply.time > newLastReadTime && reply.author != $rootScope.appConfig.login).length;
            if ($scope.uiState.invalidateCachedUserReadTime || userAction || hasNoPeerNewReplies) {
                $scope.uiState.cachedUserReadTime = newLastReadTime;
                $scope.uiState.invalidateCachedUserReadTime = false;
            }
            // display "view new replies" when action does not comes from user and there are new replies from other users
            if (userAction || hasNoPeerNewReplies) {
                $scope.viewNewReplies(userAction || hasLastReadTimeChanged);
            } else {
                $scope.uiState.displayToastNewReplies = true;
                const convListWidget = $('.discussions-widget-list-replies');
                const newRepliesLine = $('.discussions-widget-newreplies');
                if (convListWidget.size() && newRepliesLine.size()) {
                    $scope.uiState.showToastNewReplies = newRepliesLine.offset().top > convListWidget.offset().top + convListWidget.height() - 30;
                }
            }
        }
    };

    $scope.resetInputs = function() {
        delete $scope.uiState.newConvTopic;
        delete $scope.uiState.newReply;
        delete $scope.uiState.editingTopic;
    };

    $scope.getDiscussionParticipants = function(discussion) {
        const MAX_PARTICIPANT_LIST_LENGTH = 30;
        let participantListLength = 0;
        const participants = [];
        const displayedParticipants = [];
        for (const login in discussion.users) {
            if (discussion.users[login].lastReplyTime > 0) {
                participants.push(discussion.users[login]);
            }
        }
        participants.sort((a, b) => b.lastReplyTime - a.lastReplyTime);
        for (let i = 0; i < participants.length; i++) {
            const escapedDisplayName = $filter('escapeHtml')(participants[i].displayName || 'Unknown user');
            if (participantListLength + escapedDisplayName.length + 2 <= MAX_PARTICIPANT_LIST_LENGTH) {
                displayedParticipants.push(escapedDisplayName);
                participantListLength += escapedDisplayName.length + 2;
            } else {
                break;
            }
        }
        const othersCount = participants.length - displayedParticipants.length;
        let participantsListStr = displayedParticipants.join('<small>, </small>');
        if (othersCount > 0) {
            if (displayedParticipants.length == 0) {
                participantsListStr += participants.length + '<small> participant' + (participants.length > 1 ? 's' : '') + '</small>';
            } else {
                const hiddenParticipantCount = participants.length - displayedParticipants.length;
                participantsListStr += '<small> and </small>' + hiddenParticipantCount + '<small> other' + (hiddenParticipantCount > 1 ? 's' : '') + '</small>';
            }
        }
        return participantsListStr;
    };

    $scope.getDiscussionParticipantsList = function(discussion) {
        const arr = [];
        angular.forEach(discussion.users, function(value, key) {
            arr.push(angular.extend(value, {login: key}));
        });
        arr.sort((a, b) => b.lastReplyTime - a.lastReplyTime);
        return arr;
    };

    $scope.scrollChanged = function(userAction) {
        $timeout(function() {
            const convListWidget = $('.discussions-widget-list-replies');
            const newRepliesLine = $('.discussions-widget-newreplies');
            if (convListWidget.size() && newRepliesLine.size()) {
                $scope.uiState.showToastNewReplies = newRepliesLine.offset().top > convListWidget.offset().top + convListWidget.height() - 30;
                if (userAction && !$scope.uiState.showToastNewReplies && $scope.uiState.displayToastNewReplies) {
                    $scope.viewNewReplies(false);
                }
            }
        });
    };

    /**** Actions ****/
    $scope.closeDiscussion = function(close) {
        if (!$scope.uiState.selectedConv) {
            return;
        }
        DataikuAPI.discussions.close(currentItem.projectKey, currentItem.type, currentItem.id, $scope.uiState.selectedConv.id, close)
            .success(function() {
                WT1.event("discussion-close", {close: close, state: $state.current.name});
                broadcastDiscussionCountChange();
            })
            .error(setErrorInScope.bind($scope));
    };

    $scope.editTopic = function() {
        if (!$scope.uiState.selectedConv || !$scope.uiState.newConvTopic) {
            return;
        }
        WT1.event("discussion-edit-topic", {state: $state.current.name});
        DataikuAPI.discussions.save(currentItem.projectKey, currentItem.type, currentItem.id, $scope.uiState.selectedConv.id, $scope.uiState.newConvTopic)
            .success(() => $scope.uiState.editingTopic = false)
            .error(setErrorInScope.bind($scope));
        $scope.resetInputs();
    };

    $scope.resetEditing = function() {
        delete $scope.uiState.replyEditing;
        delete $scope.uiState.replyEditedText;
    }

    $scope.editReply = function() {
        const validEditedText = ($scope.uiState.replyEditedText || '').length > 0 && ($scope.uiState.replyEditedText || '').length <= 10000;
        if (!$scope.uiState.selectedConv || !($scope.uiState.selectedConv.replies[$scope.uiState.replyEditing] || {}).id || !validEditedText) {
            return;
        }
        WT1.event("discussion-edit-reply", {state: $state.current.name});
        DataikuAPI.discussions.reply(currentItem.projectKey, currentItem.type, currentItem.id, $scope.uiState.selectedConv.id, $scope.uiState.replyEditedText, $scope.uiState.selectedConv.replies[$scope.uiState.replyEditing].id)
            .success(function() {
                $scope.resetEditing();
            })
            .error(setErrorInScope.bind($scope));
        $scope.resetInputs();
    };

    $scope.replyDiscussion = function() {
        const replyTopic = $scope.uiState.newConvTopic || '';
        const replyContent = $scope.uiState.newReply;
        if (!replyContent || (!replyTopic && !$scope.uiState.selectedConv)) {
            return;
        }
        WT1.event("discussion-reply", {
                state: $state.current.name,
                'number_of_discussions': $scope.discussions.length,
                'number_of_replies': $scope.discussions.map(c => c.replies.length).reduce((a,b) => a+b, 0)
        });
        if ($scope.uiState.selectedConv) {
            DataikuAPI.discussions.reply(currentItem.projectKey, currentItem.type, currentItem.id, $scope.uiState.selectedConv.id, replyContent, null)
                .error(setErrorInScope.bind($scope));
        } else {
            DataikuAPI.discussions.create(currentItem.projectKey, currentItem.type, currentItem.id, replyTopic, replyContent)
                .success(function(data) {
                    $scope.uiState.forceSelectedConvId = data.id;
                    broadcastDiscussionCountChange();
                })
                .error(setErrorInScope.bind($scope));
        }
        $scope.resetInputs();
        // ugly hack to remove tooltips
        $timeout(() => { $('body > .tooltip').remove(); });
    };

    $scope.deleteDiscussion = function() {
        if (!$scope.uiState.selectedConv) {
            return;
        }
        Dialogs.confirm($scope, 'Delete discussion', 'Warning: deleting ' + ($scope.uiState.selectedConv.topic ? ('discussion "' + $scope.uiState.selectedConv.topic + '"') : 'this discussion') + ' will erase permanently its whole content including all the replies. This operation is irreversible. Do you want to continue?').then(function() {
            DataikuAPI.discussions.delete(currentItem.projectKey, currentItem.type, currentItem.id, $scope.uiState.selectedConv.id)
                .success(function() {
                    WT1.event("discussion-delete", {state: $state.current.name});
                    delete $scope.uiState.selectedConv;
                    broadcastDiscussionCountChange();
                })
                .error(setErrorInScope.bind($scope));
        });
    };

    function getDiscussionById(id) {
        Assert.inScope($scope, 'discussions');
        return $scope.discussions.find(conv => conv.id == id) || null;
    }

    function refreshDiscussions() {
        const discussionIdFromStateParams = $stateParams.discussionId;
        if (discussionIdFromStateParams) {
            // Clear from stateParams so that it does not stick around if we move directly to another taggable object...
            $state.go('.', {'#': $location.hash(), discussionId: null}, {notify: false, location: 'replace'});
        }
        DataikuAPI.discussions.getForObject(currentItem.projectKey, currentItem.type, currentItem.id)
            .success(function(data) {
                $scope.discussions = data.discussions;
                if ($scope.discussions && $scope.discussions.length > 0 && !$scope.discussions.find(discu => discu.closedOn == 0)) {
                    $scope.uiState.showClosed = true;
                }
                const userActionWhenSingleDiscussion = $scope.discussionId && !$scope.uiState.selectedConv;
                if ($scope.discussionId) {
                    $scope.uiState.forceSelectedConvId = $scope.discussionId();
                }
                if ($scope.uiState.forceSelectedConvId) {
                    $scope.uiState.creatingNewConv = false;
                    $scope.uiState.selectedConv = getDiscussionById($scope.uiState.forceSelectedConvId);
                    delete $scope.uiState.forceSelectedConvId;
                }
                if ($scope.uiState.selectedConv) {
                    $scope.openDiscussion(getDiscussionById($scope.uiState.selectedConv.id), userActionWhenSingleDiscussion);
                } else if (discussionIdFromStateParams && !$scope.discussionId) {
                    const discussion = getDiscussionById(discussionIdFromStateParams);
                    if (discussion) {
                        $scope.openDiscussion(discussion, true);
                    } else {
                        ActivityIndicator.error("Discussion "+discussionIdFromStateParams+" not found");
                    }
                }
                $scope.scrollChanged(false);
            })
            .error(setErrorInScope.bind($scope));
    }

    function updateLastReadByUsers(evt, message) {
        if (!$scope.discussions) {
            return;
        }
        if (!message || !(message.details || {}).time || !message.user) {
            return;
        }
        const conv = $scope.discussions.find(conv => conv.id == message.discussionId);
        if (conv) {
            if (!conv.users[message.user]) {
                conv.users[message.user] = {
                    login: message.user,
                    displayName: message.details.userDisplayName
                };
            }
            conv.users[message.user].lastReadTime = message.details.time;
        }
    }

    function selectedItemUpdated() {
        const value = $scope.selectedItem();
        const hasSelectedItem = !!value;
        const hasSelectedItemChanged = hasSelectedItem && !angular.equals(currentItem, value);
        const hasSingleDiscussionChanged = $scope.discussionId && !angular.equals($scope.discussionId(), $scope.uiState.forceSelectedConvId);
        if (hasSelectedItem && (hasSelectedItemChanged || hasSingleDiscussionChanged)) {
            currentItem = value;
            $scope.uiState = {forceSelectedConvId: $scope.uiState.forceSelectedConvId || ($scope.uiState.selectedConv || {}).id};
            if (currentItem.projectKey && currentItem.type && currentItem.id) {
                refreshDiscussions();
            }
        }
    }

    function broadcastDiscussionCountChange() {
        if ($state.is("projects.project.flow")) {
            $rootScope.$broadcast('discussionCountChanged');
        }
    }

    /*** Init ***/
    if ($scope.watchObject && $scope.selectedItem) {
        // current item is defined through directive attribute
        let debounceFn = Debounce().withDelay(20, 200).withScope($scope).wrap(selectedItemUpdated);
        $scope.$watch('watchObject', debounceFn, true);
    } else {
        // current item is retrieved from TopNav
        currentItem = angular.copy(TopNav.getItem());
        currentItem.projectKey = $stateParams.projectKey;
        refreshDiscussions();
    }

    const replyListenerDestroyer = Notification.registerEvent('discussion-reply', refreshDiscussions);
    const deleteListenerDestroyer = Notification.registerEvent('discussion-delete', refreshDiscussions);
    const updateListenerDestroyer = Notification.registerEvent('discussion-update', refreshDiscussions);
    const closeListenerDestroyer = Notification.registerEvent('discussion-close', refreshDiscussions);
    const ackListenerDestroyer = Notification.registerEvent('discussion-ack', updateLastReadByUsers);

    $scope.$on('$destroy', function() {
        replyListenerDestroyer();
        deleteListenerDestroyer();
        updateListenerDestroyer();
        closeListenerDestroyer();
        ackListenerDestroyer();
    });

});


app.directive('discussionsWidget', function() {
    return {
        restrict: 'AE',
        templateUrl: '/templates/widgets/discussions-widget-content.html',
        scope: {
            selectedItem: '&',
            watchObject: '='
        }
    };
});


app.directive('discussionsWidgetSingle', function() {
    return {
        restrict: 'AE',
        templateUrl: '/templates/widgets/discussions-widget-single.html',
        scope: {
            selectedItem: '&',
            discussionId: '&',
            watchObject: '='
        }
    };
});


app.directive('discussionsButton', function($rootScope, $compile, $q, $templateCache, $http, $state, $stateParams, Assert, DataikuAPI, TopNav, Notification, Debounce) {
    return {
        restrict: 'AE',
        templateUrl: '/templates/widgets/discussions-widget-button.html',
        scope: {
            selectedItem: '&',
            watchObject: '='
        },
        replace: true,
        link: function($scope, element, attrs) {
            let currentItem;

            $scope.discussionCounts = null;

            $scope.uiState = {};
            $scope.uiState.loadRequested = false;
            $scope.uiState.displayed = false;
            $scope.uiState.maximized = false;

            $scope.titleForNumberOfDiscussions = function() {
                let title;
                const counts = $scope.discussionCounts;

                if (!counts) return; //Not ready
                if (counts.open) {
                    title = counts.open +
                        (counts.unread == counts.open && counts.unread > 0 ? ' unread' :'') +
                        ' discussion' +
                        (counts.open == 1 ? '' : 's');
                } else if (counts.total) {
                    title = 'No open discussion';
                } else {
                    title = 'No discussion';
                }
                let objectTypeName = $scope.uiState.currentObjectType.replace('_', ' ');
                if (objectTypeName == 'project') {
                    objectTypeName = "project's home page"; // let's not be confusing
                }
                title += ' on this ' + objectTypeName;

                if(counts.unread != counts.open && counts.unread > 0) {
                    title += ' (' + counts.unread + ' unread)';
                }
                return title;
            };

            function openDiscussionsWidget() {
                if (!$scope.uiState.loadRequested) {
                    loadWidget();
                }
                $scope.uiState.displayed = true;
                $scope.uiState.maximized = true;
            }

            $scope.closeDiscussionsWidget = function() {
                $scope.uiState.displayed = false;
            };

            $scope.toggleDiscussionsWidget = function() {
                if ($scope.uiState.displayed && $scope.uiState.maximized) {
                    $scope.closeDiscussionsWidget();
                } else {
                    openDiscussionsWidget();
                }
            };

            $scope.toggleMaximized = function() {
                $scope.uiState.maximized = !$scope.uiState.maximized;
            };

            function refreshCounts() {
                DataikuAPI.discussions.getCounts(currentItem.projectKey, currentItem.type, currentItem.id)
                    .success(function(data) {
                        $scope.discussionCounts = data;
                        if (!$scope.uiState.displayed && $scope.discussionCounts.unread > 0) {
                            if (!$scope.uiState.loadRequested) {
                                loadWidget();
                            }
                            $scope.uiState.displayed = true;
                            $scope.uiState.maximized = false;
                        }
                    })
                    .error(setErrorInScope.bind($scope));
            }

            function loadWidget() {
                Assert.trueish(!$scope.uiState.loadRequested, 'loadWidget called twice');
                $scope.uiState.loadRequested = true;
                const location = '/templates/widgets/discussions-widget-popover.html'
                $q.when($templateCache.get(location) || $http.get(location, {cache: true}))
                    .then(function(template) {
                        if (angular.isArray(template)) {
                            template = template[1];
                        } else if (angular.isObject(template)) {
                            template = template.data;
                        }
                        const widgetEl = $(template);
                        $compile(widgetEl)($scope);
                        $('.main-view').append(widgetEl);
                        $scope.$on('$destroy', function() {
                            widgetEl.remove();
                        });
                    });
            }

            function selectedItemUpdated() {
                const value = $scope.selectedItem();
                const hasSelectedItem = !!value;
                const hasSelectedItemChanged = hasSelectedItem && !angular.equals(currentItem, value);
                const hasSingleDiscussionChanged = $scope.discussionId && !angular.equals($scope.discussionId(), $scope.uiState.forceSelectedConvId);
                if (hasSelectedItem && (hasSelectedItemChanged || hasSingleDiscussionChanged)) {
                    currentItem = value;
                    $scope.uiState.currentObjectType = value.type.toLowerCase().replace('[^a-zA-Z]', ' ');
                    refreshCounts();
                }
            }

            if ($scope.watchObject && $scope.selectedItem) {
                // current item is defined through directive attribute
                let debounceFn = Debounce().withDelay(20, 200).withScope($scope).wrap(selectedItemUpdated);
                $scope.$watch('watchObject', debounceFn, true);
            } else {
                // current item is retrieved from TopNav
                currentItem = angular.copy(TopNav.getItem());
                currentItem.projectKey = $stateParams.projectKey;
                if (currentItem.type) {
                    $scope.uiState.currentObjectType = currentItem.type.toLowerCase().replace('[^a-zA-Z]', ' ');
                }
                refreshCounts();
            }

            const replyListenerDestroyer = Notification.registerEvent('discussion-reply', refreshCounts);
            const deleteListenerDestroyer = Notification.registerEvent('discussion-delete', refreshCounts);
            const closeListenerDestroyer = Notification.registerEvent('discussion-close', refreshCounts);
            const ackListenerDestroyer = Notification.registerEvent('discussion-ack', function(evtType, message) {
                if ($scope.discussionCounts && $scope.discussionCounts.unread && message.user == $rootScope.appConfig.login) {
                    refreshCounts()
                }
            });
            $scope.$on('$destroy', function() {
                replyListenerDestroyer();
                deleteListenerDestroyer();
                closeListenerDestroyer();
                ackListenerDestroyer();
            });

            if ($stateParams.discussionId) {
                openDiscussionsWidget();
            }
        }
    };
});


app.service('Discussions', function($rootScope, Notification, MessengerUtils, StateUtils, UserImageUrl) {
    function userAvatar(userLogin, size) {
        if (!userLogin)  return "";
        return '<img class="user-avatar" src="' + UserImageUrl(userLogin, size) + '" /> ';
    }

    function userLink(userLogin, innerHTML) {
        return '<a href="/profile/'+escape(userLogin)+'/" class="link-std">'+ innerHTML + '</a>';
    }

    function dssObjectLink(event, innerHTML) {
        const tor = {type: event.objectType, id: event.objectId, projectKey: event.projectKey};
        const link = StateUtils.href.taggableObject(tor, {moveToTargetProject: false, discussionId: event.discussionId});
        return '<a href="'+link+'" class="link-std">'+innerHTML+'</a>';
    }

    function discussionIsOpen(id) {
        const discussionScope = angular.element($('.discussions-widget-list-replies')).scope();
        return discussionScope && discussionScope.uiState && discussionScope.uiState.selectedConv.id == id;
    }

    const replyListenerDestroyer = Notification.registerEvent('discussion-reply',function(evt, message) {
        if (message.user == $rootScope.appConfig.login) {
            return; // Hopefully the user knows that they wrote
        }
        if (!message.newReply) {
            return; // A reply was edited, don't notify...
        }
        if (message.mentionedUsers && message.mentionedUsers.includes($rootScope.appConfig.login)) {
            return; // The current user is mentioned in this message, there will be a specific notification for that, don't duplicate
        }
        if (discussionIsOpen(message.discussionId)) {
            return;
        }

        MessengerUtils.post({
            message: userLink(message.user, sanitize(message.details.userDisplayName || message.user))
                + (message.creation ? " created a discussion on " : " added a reply on ")
                + dssObjectLink(message, sanitize(message.details.objectDisplayName))
                + ":"
                + '<span class="messenger-comment">'
                + sanitize(message.text.substr(0,400))
                + (message.text.length > 400 ? '[...]' : '')
                + '</span>'
                ,
            icon: userAvatar(message.user),
            hideAfter: 5,
            showCloseButton: true,
            id: message.user+'connected',
            type: 'no-severity'
        });
    });

    const mentionListenerDestroyer = Notification.registerEvent("discussion-mention", function(evt, message) {
        MessengerUtils.post({
            message: userLink(message.author, sanitize(message.details.authorDisplayName || message.author))
                + " mentioned you in a discussion on "
                + dssObjectLink(message, sanitize(message.details.objectDisplayName))
                + ":"
                + '<span class="messenger-comment">'
                + sanitize(message.message.substr(0,400))
                + (message.message.length > 400 ? '[...]' : '')
                + '</span>'
                ,
            icon: userAvatar(message.author),
            type: 'no-severity',
            showCloseButton: true
        });
    });

    const closeListenerDestroyer = Notification.registerEvent("discussion-close", function(evt, message) {
        if (message.user == $rootScope.appConfig.login) {
            return;
        }
        MessengerUtils.post({
            message: userLink(message.user, sanitize(message.details.userDisplayName || message.user))
                + " has " + (message.details.closed ? "resolved" : "reopened") + " a discussion on "
                + dssObjectLink(message, sanitize(message.details.objectDisplayName))
                ,
            icon: userAvatar(message.user),
            type: 'no-severity',
            showCloseButton: true
        });
    });

    $rootScope.$on('$destroy', function() {
        replyListenerDestroyer();
        mentionListenerDestroyer();
        closeListenerDestroyer();
    });
});


})();
(function() {
'use strict';

const app = angular.module('dataiku.collab.wikis', []);

app.constant('WIKI_TAXONOMY_KEY', 'dss.wiki.taxonomy');

app.service('WikiUtilsService', function () {
    const svc = this;

    svc.getParentId = function(id, node, taxonomy) {
        const children = node ? node.children : taxonomy;

        if (!children) {
            return null;
        }
        const nodeId = node ? node.id : '';
        for (const child of children) {
            if (child.id === id) {
                return nodeId;
            }
            const foundParent = svc.getParentId(id, child);
            if (foundParent) {
                return foundParent;
            }
        }
        return null;
    };

    svc.getArticleNodeById = function(articleId, node, taxonomy) {
        const children = node && node.children ? node.children : taxonomy;
        for (const child of children) {
            if (child.id === articleId) {
                return child;
            }
            const foundNode = svc.getArticleNodeById(articleId, child);
            if (foundNode) {
                return foundNode;
            }
        }
        return null;
    };

    svc.addArticlesToList = function(nodes, articlesIds) {
        nodes.forEach(function(node) {
            articlesIds.push(node.id);
            svc.addArticlesToList(node.children, articlesIds);
        });
    };

});

app.controller('WikiController', function($scope, $controller, $state, $q, TaggingService, $stateParams, $rootScope, $timeout, WT1, TopNav, Dialogs, CreateModalFromTemplate, DataikuAPI, _SummaryHelper, WikiUtilsService, ActiveProjectKey, TaggableObjectsService, LocalStorage, WIKI_TAXONOMY_KEY) {
    $controller('_WikiSearch', {$scope});

    TopNav.setLocation(TopNav.TOP_WIKI, 'wiki', TopNav.TABS_NONE, null);
    $scope.wikiScope = $scope; // Useful to set errors globally for example

    WT1.event("wiki-visit", {});

    $scope.newArticle = function(newArticleId, parentArticleId) {
        if (newArticleId) {
            $scope.newNotFoundArticle = {id: newArticleId};
        }
        CreateModalFromTemplate("/templates/wikis/new-article-modal.html", $scope, "NewArticleModalController", function(newScope) {
            if (angular.isDefined(parentArticleId)) {
                newScope.newArticle.parent = parentArticleId;
            }
        }).then(function(article) {
            WT1.event("article-create", {});
            $state.go('projects.project.wiki.article.edit', {articleId: article.id}, {reload: false});
            $scope.updateWiki().then(function() {
                // If it's the first article we don't need to scroll to it
                if (angular.isDefined($scope.wikiScope.treeViewHook)) {
                    // Waiting for the node corresponding to the new article to be propagated into the treeview directive
                    $timeout(() => $scope.wikiScope.treeViewHook.scrollToNodeFn(article.id));
                }
            });
        });
    };

    $scope.getParentId = function(id, node) {
        return WikiUtilsService.getParentId(id, node, $scope.wiki.taxonomy);
    };

    $scope.getArticleNodeById = function(articleId, node) {
        return  WikiUtilsService.getArticleNodeById(articleId, node, $scope.wiki.taxonomy);
    };

    function addArticlesToList(nodes) {
        return  WikiUtilsService.addArticlesToList(nodes, $scope.articlesIds);
    }

    function retrieveUnfoldedNodeIDs() {
        let savedStates = LocalStorage.get(WIKI_TAXONOMY_KEY);
        if (savedStates) {
            let unfoldedNodeIDs = savedStates[$stateParams.projectKey];
            if (unfoldedNodeIDs && unfoldedNodeIDs.length > 0) {
                $scope.wiki.unfoldedNodeIds = unfoldedNodeIDs;
            }   
        }
    }

    function retrieveNodeIdsHavingChildren(nodes) {
        nodes.forEach(function(node) {
            if (node.children.length > 0) {
                $scope.wiki.nodeIdsHavingChildren.push(node.id);
                retrieveNodeIdsHavingChildren(node.children);
            }
        });
    }
    
    function initTaxonomy() {
        $scope.wiki.unfoldedNodeIds = [];
        $scope.wiki.nodeIdsHavingChildren = [];
        retrieveUnfoldedNodeIDs();
        retrieveNodeIdsHavingChildren($scope.wiki.taxonomy);
        if (typeof($scope.initNodes) === "function") {
            $scope.initNodes($scope.wiki.taxonomy);
        }
    }

    $scope.getAllTagsForProject = function () {
        const deferred = $q.defer();
        deferred.resolve(TaggingService.getProjectTags());
        return getRewrappedPromise(deferred);
    }

    $scope.updateWiki = function() {
        return DataikuAPI.wikis.getWiki(ActiveProjectKey.get())
            .success(function(wikiSummary) {

                if (angular.isDefined($scope.wiki) && angular.isDefined($scope.wikiScope.saveFoldingState)) {
                    $scope.wikiScope.saveFoldingState();
                }

                $scope.wiki = wikiSummary.wiki;
                $scope.articleMapping = wikiSummary.articleMapping;
                $scope.wikiTimeline = wikiSummary.timeline;
                $scope.articlesIds = [];

                $scope.emptyWiki = !$scope.wiki.taxonomy || !$scope.wiki.taxonomy.length;
                if ($scope.emptyWiki) {
                    return;
                }

                initTaxonomy();
                addArticlesToList($scope.wiki.taxonomy)

                if ($state.current.name == 'projects.project.wiki') { // We are not on an article
                    const rootArticle = $scope.wiki.homeArticleId || $scope.wiki.taxonomy[0].id;
                    $state.go('projects.project.wiki.article.view', {articleId: rootArticle}, {reload: true, location: 'replace'});
                }
                if ($stateParams.articleId) {
                    $scope.articleNode = $scope.getArticleNodeById($stateParams.articleId);
                }
            })
            .error(setErrorInScope.bind($scope));
    };
    $timeout(() => $scope.updateWiki());

    $scope.startChangeArticleParent = function(articleId) {
        $scope.tempArticleID = articleId;
        CreateModalFromTemplate("/templates/wikis/change-article-parent-modal.html", $scope).then(function() {
            delete $scope.tempArticleID;
            $scope.updateWiki().then(_ => $timeout(_ => $scope.wikiScope.treeViewHook.scrollToNodeFn(articleId)));
        });
    };
    
    $scope.saveArticleLayout = function(layout) {
        if (['WIKI_ARTICLE', 'FOLDER'].indexOf(layout) == -1) {
            return;
        }
        WT1.event("article-save-layout", {layout: layout});
        let article = angular.extend({}, $scope.article, {layout: layout});
        return $scope.wikiScope.checkSaveArticle(article, $scope.uiState.editedPayload);
    };

    $scope.setHomeArticle = function(articleId) {
        WT1.event("wiki-set-home", {});
        DataikuAPI.wikis.setHomeArticle($stateParams.projectKey, articleId)
            .success(function() {
                $scope.updateWiki();
            })
            .error(setErrorInScope.bind($scope.wikiScope));
    };

    $scope.startCopyArticle = function(articleId) {
        $scope.copyArticle = {
            name: "Copy of " + $scope.articleMapping[articleId],
            parent: $scope.getParentId(articleId) || null,
            originalArticleId: articleId
        }
        function reallyStartCopy() {
            CreateModalFromTemplate("/templates/wikis/copy-article-modal.html", $scope, "CopyArticleModalController").then(function(article) {
                $state.go('projects.project.wiki.article.edit', {articleId: article.id}, {reload: false});
                $scope.updateWiki().then(function() {
                    // If it's the first article we don't need to scroll to it
                    if (angular.isDefined($scope.wikiScope.treeViewHook)) {
                        // Waiting for the node corresponding to the new article to be propagated into the treeview directive
                        $timeout(() => $scope.wikiScope.treeViewHook.scrollToNodeFn(article.id));
                    }
                });
            });
        }
        $scope.wikiScope.checkDirtiness(reallyStartCopy);
    };

    $scope.startRenameArticle = function(articleId) {
        $scope.tempArticleID = articleId;

        function reallyStartRenaming() {
            CreateModalFromTemplate("/templates/wikis/rename-article-modal.html", $scope).then(function(articleId) {
                delete $scope.tempArticleID;
                $scope.updateWiki();
                $state.go('projects.project.wiki.article.view', {articleId: articleId}, {reload: true});
            });
        }
        $scope.wikiScope.checkDirtiness(reallyStartRenaming);
    };

    $scope.deleteArticles = function(articles) {
        WT1.event("article-delete", {});
        return TaggableObjectsService.delete(articles.map(a => ({projectKey: a.projectKey, type: 'ARTICLE', id: a.id, displayName: $scope.articleMapping[a.id] || a.id})))
            .then(function(data) {
                WT1.event("article-delete", {number_of_articles: $scope.articlesIds && $scope.articlesIds.length});
                $scope.updateWiki();
                $state.go('projects.project.wiki', {projectKey: $stateParams.projectKey}, {reload: true});
            }, setErrorInScope2.bind($scope));
    };

    $scope.uiState = {};
    $scope.getObjectId = function() {
        return $scope.article && $scope.article.id;
    };
    $scope.objectType = 'ARTICLE';
    $scope.$watch('wiki.taxonomy', function(nv, ov) {
        if (nv && ov) {
            return DataikuAPI.wikis.editTaxonomy(ActiveProjectKey.get(), $scope.wikiScope.wiki)
                .error(setErrorInScope.bind($scope));
        }
    }, true);
    _SummaryHelper.addInterestsManagementBehaviour($scope);

    // Override star/watch to update the UI:
    const so = $scope.starObject;
    $scope.starObject = function(s) {
        so(s).then(function() {
            $scope.interest.starred = s;
        });
    };

    const wo = $scope.watchObject;
    $scope.watchObject = function(w) {
        wo(w).then(function() {
            $scope.interest.watching = w;
        });
    };
});


app.controller('ArticleController', function($controller, $scope, $location, $anchorScroll, $state, $stateParams, $filter, $timeout, WT1, SmartId, TopNav, DataikuAPI, TaggingService, CreateModalFromTemplate, TaggableObjectsService, Dialogs, ActiveProjectKey, DKUtils, StateUtils, FullScreenService, executeWithInstantDigest) {
    $scope.SmartId = SmartId;
    $scope.$state = $state;
    $scope.wikiScope.isLoaded = false;

    $scope.markdownCallback = function() {
        // Build the table of content from loaded DOM
        $scope.articleContents = [];
        const container = $('.wiki-article-content div[from-markdown], .wiki-article-preview-content div[from-markdown]');
        if (container.length > 0) {
            const headersIndexes = {};
            for (let i = 1; i <= 6; i++) {
                headersIndexes[i] = 0;
            }
            $(container[0])
                .find('.dku-header-anchor')
                .each(function(idx, headerTag) {
                    const aTag = $(headerTag).find('a[name]');
                    if (aTag.length > 0) {
                        const depth = Number($(headerTag).prop("tagName").substring(1));
                        headersIndexes[depth]++;
                        const indexes = [];
                        for (let i = 1; i <= depth; i++) {
                            indexes.push(headersIndexes[i]);
                        }
                        $scope.articleContents.push({anchor: aTag.attr('name'), label: headerTag.innerText, depth: depth - 1, indexes: indexes.join('.')});
                        for (let i = depth+1; i <= 6; i++) {
                            headersIndexes[i] = 0;
                        }
                    }
                }
            );
        }

        // Scroll to hash if existing
        $anchorScroll();
        $scope.wikiScope.isLoaded = true;
    };

    // Resetting the hash when leaving an article
    $scope.$on('$destroy', () => { $location.hash(''); });

    $scope.anchorLink = function(anchor) {
        return location.pathname + '#' + anchor;
    };

    $scope.startEditTags = function() {
        TaggingService.startApplyTagging([angular.extend({}, $scope.article, {type: 'ARTICLE', displayName: $scope.article.name})]).then(getSummary);
    };

    $scope.getAttachmentIcon = function(item) {
        if (item.attachmentType == 'DSS_OBJECT') {
            return $filter('subTypeToIcon')(item.subtype, item.taggableType) + ' ' + $filter('subTypeToColor')(item.subtype, item.taggableType);
        } else {
            return $filter('mimeTypeToIcon')(item.details.mimeType);
        }
    };

    $scope.wikiScope.editCustomFields = function() {
        if (!$scope.article) {
            return;
        }
        let oldCustomFields = angular.copy($scope.article.customFields);
        let modalScope = angular.extend($scope, {objectType: 'ARTICLE', objectName: $scope.article.id, objectCustomFields: $scope.article.customFields});
        CreateModalFromTemplate("/templates/taggable-objects/custom-fields-edit-modal.html", modalScope).then(function(customFields) {
            $scope.article.customFields = customFields;
            $scope.wikiScope.saveArticlePayload().then(null, function() {
                $scope.article.customFields = oldCustomFields;
            });
        });
    };

    $scope.$on("objectSummaryEdited", function() {
        $scope.wikiScope.checkSaveArticle($scope.article, $scope.articlePayload);
    });

    $scope.wikiScope.checkDirtiness = (cb) => {
        if (typeof cb != 'function') {
            throw Error("Callback is not a function");
        };
        if ($scope.isDirty()) {
            Dialogs.confirm($scope,
                    'Unsaved changes',
                    'There are unsaved changes that are about to be erased. Are you sure you want to continue?')
                .then(() => {
                    $scope.uiState.editedPayload = angular.copy($scope.articlePayload);
                    cb();
                });
        } else {
            cb();
        }
    };

    $scope.startExportArticle = function(articleId) {
        $scope.tempArticleID = articleId;

        function reallyStartExporting() {
            CreateModalFromTemplate("/templates/wikis/export-article-modal.html", $scope);
        }
        $scope.wikiScope.checkDirtiness(reallyStartExporting);
    };

    $scope.wikiScope.checkSaveArticle = function(article, payload, callback, commitMessage) {
        function saveAfterConflictCheck() {
            return DataikuAPI.wikis.saveArticle(article, payload, commitMessage)
                .success(function(data) {
                    setSummary(data);
                    if (typeof callback == 'function') {
                        callback(data);
                    }
                })
                .error(setErrorInScope.bind($scope.wikiScope));
        }
        return DataikuAPI.wikis.checkSaveConflict(article)
            .success(function(conflictResult) {
                if(!conflictResult.canBeSaved) {
                    Dialogs.openConflictDialog($scope, conflictResult)
                        .then(function(resolutionMethod) {
                            if (resolutionMethod == 'erase') {
                                return saveAfterConflictCheck();
                            } else if(resolutionMethod == 'ignore') {
                                DKUtils.reloadState();
                            }
                        });
                } else {
                    return saveAfterConflictCheck();
                }
            })
            .error(setErrorInScope.bind($scope.wikiScope));
    };

    $scope.wikiScope.saveArticlePayload = function(commitMessage, moveToView) {
        const savedPayload = $scope.wikiScope.uiState.editedPayload;
        let cb = function(data) {
            if (moveToView) {
                StateUtils.go.article(data.object.id);
            }
            try {
                window.marked(savedPayload, function(...args) {
                    if (args.length > 1 && args[0]) {
                        let usageReport = args[0];
                        usageReport._payloadLength = savedPayload.length;
                        usageReport._origin = 'article';
                        usageReport._origin_hash = data.object.id.dkuHashCode()
                        WT1.event("article-save", usageReport);
                    }
                });
            } catch (e) {
                Logger.error('Failed to compute markdown usage report', e);
            }
        };
        return $scope.wikiScope.checkSaveArticle($scope.article, savedPayload, cb, commitMessage);
    };

    function escapeLabel(label) {
        return label.replace(/\]/g, '\\]').replace(/\[/g, '\\[');
    }

    $scope.wikiScope.startAddAttachments = function() {
        $scope.wikiScope.checkDirtiness(() => { CreateModalFromTemplate("/templates/wikis/add-article-attachments-modal.html", $scope); });
    };

    $scope.wikiScope.deleteAttachment = function(index) {
        const reallyDeleteAttachment = () => {
            Dialogs.confirm($scope, 'Delete attachment','Are you sure you want to delete this attachment?').then(function() {
                $scope.article.attachments.splice(index, 1);
                WT1.event("article-remove-attachment", {number_of_attachments: $scope.article.attachments.length});

                return $scope.wikiScope.checkSaveArticle($scope.article, $scope.articlePayload);
            });
        };
        $scope.wikiScope.checkDirtiness(reallyDeleteAttachment);
    };

    $scope.wikiScope.insertImage = function(attachment) {
        WT1.event("article-insert-image", {});
        const cms = $('.wiki-article-edit-body-main .CodeMirror');
        if (!cms.length) {
            throw new Error('Cannot reach wiki article edition CodeMirror');
        }
        const cm = cms.get(0).CodeMirror;
        function fn(prevString) {
            const label = prevString || attachment.details.objectDisplayName;
            return `![${escapeLabel(label)}](${attachment.smartId})`;
        }
        cm.editorActions.replaceInEditor(fn, false, 'end');
    };

    $scope.wikiScope.insertFileLink = function(attachment) {
        WT1.event("article-insert-link", {});
        const cms = $('.wiki-article-edit-body-main .CodeMirror');
        if (!cms.length) {
            throw new Error('Cannot reach wiki article edition CodeMirror');
        }
        const cm = cms.get(0).CodeMirror;
        function fn(prevString) {
            const label = prevString || attachment.details.objectDisplayName;
            const filename = prevString || attachment.details.objectDisplayName.replace(/[^\w\-\_\.]+/g, '_');
            return `[${escapeLabel(label)}]{${filename}}(${attachment.smartId})`;
        }
        cm.editorActions.replaceInEditor(fn, false, 'end');
    };

    $scope.wikiScope.getUploadHref = function(attachment) {
        try {
            const ref = SmartId.resolve(attachment.smartId);
            let sanitizedFilename = attachment.details.objectDisplayName.replace(/(((\.)+)?\/)/g, "_"); // remove all slashes and dots located before slashes
            return `/dip/api/projects/wikis/get-uploaded-file/${sanitizedFilename}?projectKey=${ref.projectKey}&uploadId=${ref.id}`;
        } catch (e) {
            console.error('Failed to resolve uploadId'); // NOSONAR: OK to use console.
            return '';
        }
    };

    const articleDisplayModes =  {
        view: 'view',
        edit: 'edit'
    }

    $scope.wikiScope.getArticleDisplayMode = function () {
        return $state.current.name == 'projects.project.wiki.article.edit'? articleDisplayModes.edit : articleDisplayModes.view;
    }

    $scope.wikiScope.getArticleProjectKey = function() {
        return ActiveProjectKey.get();
    }

    $scope.getAttachmentViewTarget = function () {
        return '_blank';
    }


    $scope.wikiScope.isDirty = function() {
        return $scope.wikiScope.uiState.editedPayload != $scope.articlePayload;
    };
    const allowedTransitions = [
        'projects.project.wiki.article.view',
        'projects.project.wiki.article.edit',
        'projects.project.wiki.article.history'
    ];
    function allowedTransitionsFn(data) {
        return (data.toState && data.toParams && data.fromState && data.fromParams &&
            allowedTransitions.indexOf(data.fromState.name) >= 0 && allowedTransitions.indexOf(data.toState.name) >= 0 &&
            data.fromParams.projectKey == data.toParams.projectKey && data.fromParams.articleId == data.toParams.articleId);
    }
    checkChangesBeforeLeaving($scope, $scope.isDirty, null, allowedTransitionsFn);

    function setSummary(data) {
        $scope.wikiScope.article = data.object; // We set it in the global wiki scope to be able to use the main toolbar
        $scope.wikiScope.articlePayload = data.payload;
        $scope.wikiScope.timeline = data.timeline;
        $scope.wikiScope.interest = data.interest;
        $scope.wikiScope.articleEditionTags = {
            lastModifiedBy: data.lastModifiedBy,
            lastModifiedOn: data.lastModifiedOn,
            createdBy: data.createdBy,
            createdOn: data.createdOn
        };
        $scope.wikiScope.uiState.editedPayload = data.payload;

        if (!angular.equals(data, {})) {
            if ($stateParams.articleName !== data.object.name) {
                // Let's make our current URL accurate (and keep the current hash if present)
                $state.go('.', {articleId: data.object.id, articleName: data.object.name, '#': $location.$$hash}, {refresh: false, location: 'replace'});
            }

            TopNav.setPageTitle(data.object.name + " - Wiki");
        }

        TopNav.setItem(TopNav.ITEM_ARTICLE, $stateParams.articleId, $scope.article);

        if(!$scope.article) {
            return;
        }
        $scope.wikiScope.articleNode = $scope.getArticleNodeById($scope.article.id);
        $scope.wikiScope.articleNotFound = null;

        if ($scope.wikiScope.isFullScreen()) {
            $scope.wikiScope.article.layout = "WIKI_ARTICLE";
        }

        $timeout(() => { // wait for the page to load if the article is empty.
            $scope.wikiScope.isLoaded = $scope.wikiScope.isLoaded || !$scope.uiState.editedPayload;
        })
    }

    function getSummary() {
        resetErrorInScope($scope.wikiScope);
        setSummary({}); // empty current state

        const articleId = !$stateParams.articleId && !$stateParams.articleName ? $scope.wiki.homeArticleId : $stateParams.articleId ;
        if (!articleId) {
            $state.go("projects.project.wiki", {projectKey : ActiveProjectKey.get()}, {reload: true});
            return;
        }
        return DataikuAPI.wikis.getArticleSummary(ActiveProjectKey.get(), articleId)
            .success(setSummary)
            .error(function(data, status, headers) {
                if (status != 404) {
                    setErrorInScope.apply($scope.wikiScope, arguments);
                } else {
                    $scope.wikiScope.articleNotFound = $stateParams.articleName ? $stateParams.articleName : $stateParams.articleId;
                }
            });
    }
    getSummary();

    $scope.$watch(() => $state.current.name, function(nv) {
        $scope.wikiScope.isLoaded = false;
        if (nv == 'projects.project.wiki.article.edit') {
            $timeout(function() {
                $('.CodeMirror').each(function(idx, el) {
                    el.CodeMirror.refresh();
                    el.CodeMirror.focus();
                });
            });
        }
    });

    $scope.wikiScope.wikiExportToolBox = {
        checkLoading: function() {
            return !$scope.wikiScope.isLoaded;
        },
        goToArticle: function(articleId) {
            $scope.wikiScope.isLoaded = false;
            executeWithInstantDigest(_ => $location.url(StateUtils.href.article(articleId, $stateParams.projectKey)), $scope.wikiScope);
        }
    }

    $scope.wikiScope.isFullScreen = FullScreenService.isFullScreen;
});


app.controller('WikiTaxonomyController', function($scope, $stateParams, $state, $timeout, LocalStorage, WIKI_TAXONOMY_KEY, StateUtils, ActiveProjectKey, openDkuPopin) {
    $scope.uiState = {
        activeTaxonomyTab: 'articles'
    };

    $scope.nodeName = function(node) {
        return $scope.articleMapping[node.id];
    };

    $scope.scrollToNode = function(nodeId) {
        if (angular.isDefined(nodeId)) {
            // Clearing the search bar will load the taxonomy
            $scope.emptySearchBar();
            // The scrolling occurs on the taxonomy so we have to wait for it to load in the DOM before scrolling
            $timeout(() => $scope.wikiScope.treeViewHook.scrollToNodeFn(nodeId));
        }
    };

    $scope.emptySearchBar = function() {
        $scope.query.queryString = '';
    };

    $scope.openContextMenuSearch = function (item, $event) {
        if (!$scope.isProjectAnalystRW()) {
            return;
        }

        item.$rightClicked = true;
        let node = item._source;

        let template = `<ul class="dropdown-menu" ng-click="popupDismiss()">`;
        template += $scope.wikiScope.getRightClickMenuTemplate(node);
        template += `</ul>`;

        let isElsewhere = function (elt, e) {
            let result = $(e.target).parents('.dropdown-menu').length == 0;
            if (result) {
                delete item.$rightClicked;
            }
            return result;
        };

        $scope.popupDismiss = openDkuPopin($scope, $event, {template: template, isElsewhere: isElsewhere, popinPosition:'CLICK'});
    };

    $scope.onClick = function(node) {
        StateUtils.go.article(node.id, undefined, {articleName: $scope.nodeName(node)});
    };

    /*
        * Persisting folding state
        */

    // The following 2 event listeners detect any action that will let the user leave the wiki
    $scope.$on('$stateChangeStart', function (event, toState, toParams, fromState, fromParams) {
        if (!(toState.name.startsWith('projects.project.wiki') && toParams.projectKey == $stateParams.projectKey)) {
                $scope.wikiScope.saveFoldingState(); // When leaving the wiki through a state change 
        }
    });
    
    window.addEventListener("beforeunload", function() {
        $scope.wikiScope.saveFoldingState(); // When leaving the wiki by closing the tab/window, or manually changing the URL
    });

    $scope.wikiScope.saveFoldingState = function() {
        let newFoldingState = buildNewFoldingState();
        LocalStorage.set(WIKI_TAXONOMY_KEY, newFoldingState);
    }

    // Retrieve the last folding state and build a new one according to the current taxonomy
    function buildNewFoldingState() {
        let projectKey = ActiveProjectKey.get();
        let foldingState = LocalStorage.get(WIKI_TAXONOMY_KEY);

        if (!foldingState) {
            foldingState = {};
        }

        if (foldingState[projectKey]) {
            delete foldingState[projectKey];
        }

        let unfoldedNodeIDs = getUnfoldedNodeIDs();
        if (unfoldedNodeIDs.length > 0) {
            foldingState[projectKey] = unfoldedNodeIDs;
        }
        
        return foldingState;
    }

    function getUnfoldedNodeIDs(nodes = $scope.wiki.taxonomy) {
        let unfoldedNodeIDs = [];

        for (let i=0; i<nodes.length; i++) {
            if (nodes[i].children.length > 0 && !nodes[i].$reduced) {
                unfoldedNodeIDs.push(nodes[i].id);
            }

            let nodeIDs = getUnfoldedNodeIDs(nodes[i].children);
            if (nodeIDs && nodeIDs.length > 0) {
                unfoldedNodeIDs = unfoldedNodeIDs.concat(nodeIDs);
            }
        }

        return unfoldedNodeIDs;
    }

    /*
     * Exposed stuff to treeView directive
     */

    $scope.rightIconClass = function(node) {
        return false;
    };

    $scope.rightIconTitle = function(node) {
        return false;
    };

    $scope.iconClass = function(node) {
        return node.id == $scope.wiki.homeArticleId ? 'icon-home' : '';
    };

    $scope.iconTitle = function(node) {
        return node.id == $scope.wiki.homeArticleId ? 'This is the home page for the wiki' : '';
    };

    $scope.nodeClass = function(node) {
        return node.id == $stateParams.articleId ? 'tree-view-active-node' : '';
    };

    $scope.setUnfoldedNodeIdsFn = function(nodeIds) {
        $scope.wiki.unfoldedNodeIds = nodeIds;
    };

    $scope.getUnfoldedNodeIdsFn = function() {
        return $scope.wiki.unfoldedNodeIds;
    };

    $scope.getNodeIdsHavingChildrenFn = function() {
        return $scope.wiki.nodeIdsHavingChildren;
    };

    const EMPTY_FUNC = function() {}; //NOSONAR: Used to check when $scope.wikiScope.treeViewHook is overrided by the treeview directive

    $scope.wikiScope.treeViewHook = {
        scrollToNodeFn: EMPTY_FUNC,
        expandAllFn: EMPTY_FUNC,
        collapseAllFn: EMPTY_FUNC,
        getTaxonomyMassExpandCollapseStateFn: EMPTY_FUNC,
        setReduceFn: EMPTY_FUNC,
    }

    $scope.contextMenuFns = {
        startChangeArticleParent: $scope.wikiScope.startChangeArticleParent,
        setHomeArticle: $scope.wikiScope.setHomeArticle,
        startCopyArticle: $scope.wikiScope.startCopyArticle,
        startRenameArticle: $scope.wikiScope.startRenameArticle,
        deleteArticles: $scope.wikiScope.deleteArticles,
        startCreateChildArticle: parentNodeId => $scope.wikiScope.newArticle(null, parentNodeId)
    }

    $scope.wikiScope.getRightClickMenuTemplate = function(node) {
        let template =
        `<li>
            <a href="#" ng-click="contextMenuFns.startChangeArticleParent('`+node.id+`')">
                <i class="icon-level-up icon-fixed-width icon-flip-horizontal" /> Change parent article
            </a>
        </li>
        <li>
            <a href="#" ng-click="contextMenuFns.setHomeArticle('`+node.id+`');">
                <i class="icon-home icon-fixed-width" /> Set home article
            </a>
        </li>
        <li>
            <a href="#" ng-click="contextMenuFns.startCreateChildArticle('`+node.id+`');">
                <i class="icon-fixed-width icon-dku-plus" /> Create article from here
            </a>
        </li>
        <li>
            <a href="#" ng-click="activateSortable();">
                <i class="icon-resize-vertical icon-fixed-width" /> Move
            </a>
        </li>
        <li>
            <a href="#" ng-click="contextMenuFns.startCopyArticle('`+node.id+`')">
                <i class="icon-copy icon-fixed-width" /> Copy
            </a>
        </li>
        <li>
            <a href="#" ng-click="contextMenuFns.startRenameArticle('`+node.id+`')">
                <i class="icon-pencil icon-fixed-width" /> Rename
            </a>
        </li>
        <li>
            <a href="#" ng-click="contextMenuFns.deleteArticles([{projectKey:'`+$stateParams.projectKey+`', id:'`+node.id+`'}])">
                <span class="text-error">
                    <i class="icon-trash icon-fixed-width" /> Delete
                </span>
            </a>
        </li>`;
        return template;
    };

    /*
     * Initialization: Waiting for the treeview directive to override $scope.wikiScope.treeViewHook.setReduceFn
     */

    $scope.wikiScope.initNodes = function(nodes) {
        nodes.forEach(function(node) {
            let reduce = $scope.getUnfoldedNodeIdsFn().indexOf(node.id) == -1;
            $scope.wikiScope.treeViewHook.setReduceFn(node, reduce);

            if (node.children.length > 0) {
                $scope.wikiScope.initNodes(node.children);
            }
        });
    };

    let unwatch = $scope.$watch('wikiScope.treeViewHook.setReduceFn', function(nv, ov) {
        if (nv && typeof($scope.wikiScope.treeViewHook.setReduceFn)==="function" && $scope.wikiScope.treeViewHook.setReduceFn != EMPTY_FUNC) {
            $scope.wikiScope.initNodes($scope.wiki.taxonomy);
            $scope.wikiScope.treeViewHook.scrollToNodeFn($stateParams.articleId, 0);
            unwatch();
        }
    });
});


app.controller('NewArticleModalController', function($scope, $stateParams, WT1, DataikuAPI, ActiveProjectKey) {
    const parentArticleId = $stateParams.articleId ? $scope.getParentId($stateParams.articleId) : '';

    if (!$scope.newArticle) {
        $scope.newArticle = {};
    }
    $scope.newArticle.parent = parentArticleId;
    if ($scope.newNotFoundArticle && $scope.newNotFoundArticle.id) {
        $scope.newArticle.id = $scope.newNotFoundArticle.id;
        delete $scope.newNotFoundArticle.id;
    } else {
        delete $scope.newArticle.id;
    }

    $scope.alreadyExistingArticleNames = [".", ".."].concat(Object.values($scope.articleMapping));

    DataikuAPI.wikis.listTemplates().success(function(data) {
            $scope.availableTemplates = data.templates;
            $scope.newArticle.template = $scope.availableTemplates[0];
        }).error(setErrorInScope.bind($scope));

    $scope.create = function() {
        WT1.event("article-create", {number_of_articles: $scope.articlesIds && $scope.articlesIds.length, template: $scope.newArticle.template});

        return DataikuAPI.wikis.createArticle(ActiveProjectKey.get(), $scope.newArticle.id, $scope.newArticle.parent, $scope.newArticle.template)
            .success(function(article) {
                $scope.resolveModal(article);
            })
            .error(setErrorInScope.bind($scope));
    };
});


app.controller('AddArticleAttachmentsModalController', function($scope, $stateParams, $timeout, WT1, DataikuAPI, TAGGABLE_TYPES, SmartId, ActiveProjectKey, executeWithInstantDigest) {
    $scope.taggableTypes = TAGGABLE_TYPES;

    $scope.newAttachment = {
        projectKey: ActiveProjectKey.get()
    };

    $scope.modalNav = {
        tab: 'DSS_OBJECT'
    };

    $scope.uiState = {
        files: [],
        fileProperties: []
    };

    $scope.addAttachment = function() {
        const modifiedArticle = angular.copy($scope.article);
        if ($scope.newAttachment.taggableType == 'PROJECT') {
            $scope.newAttachment.id = $scope.newAttachment.projectKey;
        }
        const targetAttachment = {};
        targetAttachment.smartId = SmartId.fromTor($scope.newAttachment, $stateParams.projectKey);
        targetAttachment.taggableType = $scope.newAttachment.taggableType;
        targetAttachment.attachmentType = 'DSS_OBJECT';
        modifiedArticle.attachments = $scope.article.attachments.concat([targetAttachment]);
        WT1.event("article-add-attachment", {number_of_attachments: modifiedArticle.attachments.length, taggableType: targetAttachment.taggableType});

        return $scope.wikiScope.checkSaveArticle(modifiedArticle, $scope.articlePayload, () => $scope.resolveModal());
    };

    $scope.$watch('newAttachment.projectKey', function(nv) {
        if (!nv) return;
        DataikuAPI.taggableObjects.listAccessibleObjects(nv).then(function(resp) {
            const objList = resp.data;
            $scope.taggableTypesWithNoItems = TAGGABLE_TYPES.filter(t => t != 'PROJECT' && !objList.find(obj => obj.type == t));
        });
    });

    $scope.drop = function(files) {
        WT1.event("article-drop-files", {number_of_files: files.length});
        for (let i = 0; i < files.length; i++) {
            $scope.uiState.files.push(files[i]);
            $scope.uiState.fileProperties.push({
                path: files[i].name,
                length: files[i].size,
                progress: 0,
                uploaded: false
            });
        }
    };

    $scope.deleteFile = function(idx, e) {
        e.preventDefault();
        e.stopPropagation();
        $scope.uiState.files.splice(idx, 1);
        $scope.uiState.fileProperties.splice(idx, 1);
    };

    $scope.uploadFilesAfterDigest = function() {
        $timeout(function() {
            uploadFiles()
        });
    };

    function uploadFiles() {
        $scope.wikiScope.fileUploadProperties = $scope.uiState.fileProperties;

        for (let idx = 0; idx < $scope.uiState.files.length; ++idx) {
            uploadOneFile(idx);
        }
    }

    function uploadOneFile(idx) {
        const fileToUpload = $scope.uiState.files[idx];

        DataikuAPI.wikis.upload(ActiveProjectKey.get(), $stateParams.articleId, fileToUpload, function (e) {
            if (e.lengthComputable) {
                executeWithInstantDigest(() => {
                    $scope.wikiScope.fileUploadProperties[idx].progress = Math.round(e.loaded * 100 / e.total);
                }, $scope.wikiScope);
            }
        }).then(function (data) {
            $scope.wikiScope.article = angular.fromJson(data);
        }, setErrorInScope2.bind($scope.wikiScope)).finally(function () {
            $scope.wikiScope.fileUploadProperties[idx].uploaded = true;
        });

        $scope.dismiss();
    }
});


app.controller('RenameArticleModalController', function($scope, $stateParams, WT1, DataikuAPI) {
    DataikuAPI.wikis.getArticleSummary($stateParams.projectKey, $scope.tempArticleID).then(function (result) {
        $scope.modifiedArticle = result.data.object;
    }, setErrorInScope.bind($scope));

    $scope.alreadyExistingArticleNames = [".", ".."].concat(Object.values($scope.articleMapping));

    $scope.ok = function() {
        WT1.event("article-rename");
        return $scope.wikiScope.checkSaveArticle($scope.modifiedArticle, null, () => $scope.resolveModal($scope.article.id));
    };
});

app.controller('ExportArticleModalController', function($scope, $stateParams, DataikuAPI, FutureProgressModal, ActivityIndicator, WT1) {
    $scope.modalTitle = "Export: " + $stateParams.articleName;
    $scope.params = {
        exportType: 'ARTICLE_AND_CHILDREN',
        exportFormat: { paperSize: 'A4' },
        exportAttachments: false
    }

    $scope.doExportArticle = function() {
        const articleId = $scope.params.exportType === 'WHOLE_WIKI' ? null : $stateParams.articleId;
        const exportChildren = $scope.params.exportType === 'ARTICLE_AND_CHILDREN';
        DataikuAPI.wikis.exportArticle($stateParams.projectKey, articleId, $scope.params.exportFormat, exportChildren, $scope.params.exportAttachments)
            .error(setErrorInScope.bind($scope))
            .success(function (resp) {
                WT1.event("wiki-export", {export: $scope.params.exportType, exportAttachments: $scope.params.exportAttachments});
                FutureProgressModal.show($scope, resp, "Wiki export").then(function (result) {
                    if (result) { // undefined in case of abort
                        downloadURL(DataikuAPI.wikis.getExportURL(result.projectKey, result.exportId));
                        ActivityIndicator.success("Wiki export downloaded!", 5000);
                    } else {
                        ActivityIndicator.error("Wiki export failed", 5000);
                    }
                    $scope.resolveModal();
                });
            });
    }
});

app.directive('wikiExportForm', function(GRAPHIC_EXPORT_OPTIONS) {
    return {
        templateUrl: '/templates/wikis/wiki-export-form.html',
        scope: {
            params: '=',
            origin: '@',
        },
        link: function($scope) {
            $scope.paperSizeMapPage = GRAPHIC_EXPORT_OPTIONS.paperSizeMapPage;
            $scope.params.exportFormat.paperSize = 'A4';
        }
    }
});

app.controller('CopyArticleModalController', function($scope, $stateParams, WT1, DataikuAPI, ActiveProjectKey) {
    $scope.alreadyExistingArticleNames = [".", ".."].concat(Object.values($scope.articleMapping));

    const copyArticleName = $scope.copyArticle.name;
    var i = 0;
    while ($scope.alreadyExistingArticleNames.includes($scope.copyArticle.name)) {
        $scope.copyArticle.name = `${copyArticleName} ${++i}`;
    }

    $scope.ok = function() {
        return DataikuAPI.wikis.copyArticle($stateParams.projectKey, $scope.copyArticle.name, $scope.copyArticle.parent,  $scope.copyArticle.originalArticleId, !!$scope.withAttachments)
            .success(function(article) {
                $scope.resolveModal(article);
            }).error(setErrorInScope.bind($scope));
    };
});


app.controller('ChangeArticleParentModalController', function($scope, $stateParams, WT1, DataikuAPI, ActiveProjectKey) {
    function getFilteredArticleList(siblings, id) {
        let list = [];
        for (let i = 0; i < siblings.length; i++) {
            if (siblings[i].id != id) {
                list.push(siblings[i].id);
                list = list.concat(getFilteredArticleList(siblings[i].children || [], id));
            }
        }
        return list;
    }
    const parentArticleId = $scope.tempArticleID ? $scope.getParentId($scope.tempArticleID) : '';
    $scope.newParent = {id: parentArticleId, oldId: parentArticleId};
    $scope.filteredArticlesIds = $scope.tempArticleID ? getFilteredArticleList($scope.wiki.taxonomy || [], $scope.tempArticleID) : $scope.articlesIds;
    $scope.ok = function(parentId) {
        WT1.event("article-change-parent");
        return DataikuAPI.wikis.changeArticleParent(ActiveProjectKey.get(), $scope.tempArticleID, parentId)
            .success(function() {
                $scope.resolveModal();
            })
            .error(setErrorInScope.bind($scope));
    }
});


app.controller('_WikiSearch', function($scope, $stateParams, $controller, $q, DataikuAPI, ActiveProjectKey) {
    const facets = {
        "scope": ["dss"],
        "projectKey.raw": [ActiveProjectKey.get()],
        "_type":["article"]
    };
    function searchEndpoint(queryString) {
        if(!queryString) {
            $scope.results = null;
            return;
        }
        return DataikuAPI.catalog.search.call(this, queryString, facets)
            .success(function(results) {
                $scope.results = results;
            }); // No need for error handling here, done in _CatalogControllerBase
    }
    $controller("_CatalogControllerBase", {$scope, searchEndpoint});

    $scope.linkToCatalog = function() {
        return `/catalog/search/scope=dss&_type=Article&projectKey.raw=${ActiveProjectKey.get()}&q=${$scope.query.queryString}&_type=article`;
    };
});


app.directive('articleRightColumnSummary', function($controller, $stateParams, $state,
                                                   DataikuAPI, Dialogs, CreateModalFromTemplate, Logger, RecipeComputablesService) {
    return {
        templateUrl: '/templates/wikis/article-right-column-summary.html',

        link: function(scope, element, attrs) {

            $controller('_TaggableObjectsMassActions', {$scope: scope});
            $controller('_TaggableObjectsCapabilities', {$scope: scope});

            scope.refreshData = function() {
                DataikuAPI.wikis.getArticleSummary(scope.selection.selectedObject.projectKey, scope.selection.selectedObject.id).success(function(data){
                    scope.articleData = data;
                    scope.article = data.article;
                }).error(setErrorInScope.bind(scope));
            };

            scope.$watch("selection.selectedObject", function(nv, ov) {
                if (!nv) return;
                scope.articleData = {article: nv, timeline: {}}; // display temporary (incomplete) data
                if(scope.selection.confirmedItem != scope.selection.selectedObject) {
                    scope.article = null;
                }
                scope.articleHref =  $state.href('projects.project.wiki.article.view',
                    {projectKey: scope.selection.selectedObject.projectKey, articleId: scope.selection.selectedObject.id});
            });

            scope.$watch("selection.confirmedItem", function(nv, ov) {
                if (!nv) {
                    return;
                }
                scope.refreshData();
            });

        }
    }
});


})();

(function(){
    'use strict';

    var app = angular.module('dataiku.services');

    app.factory('HistoryService',["$rootScope", "$state", "$stateParams", "LocalStorage", "TopNav", "Logger", "TAGGABLE_TYPES",
        function ($rootScope, $state, $stateParams, LocalStorage, TopNav, Logger, TAGGABLE_TYPES) {
            function getHistory() {
                var dssHistory = LocalStorage.get('dssHistory');
                if (dssHistory && dssHistory.dss_history_version != 2) {
                    Logger.warn("flush old local dss history")
                    dssHistory = {dss_history_version: 2};
                    LocalStorage.set('dssHistory', dssHistory);
                }
                dssHistory = dssHistory || {};

                var user = $rootScope.appConfig.login;
                return dssHistory[user] || {};
            }

            function truncateUserHistoryList(userHistory) {
                const maximumSize = 60;
                const clearedSize = 30; // when maximumSize is reached, keep only the clearedSize most recent

                // we now keep 5 projects and 5 dashboards whenever we can, to improve the population of
                // personal home page.
                const keepProjDbdTarget = 5;

                if (Object.keys(userHistory).length > maximumSize) {
                    let items = Object.keys(userHistory).map(function(key) {return userHistory[key];});
                    items = sortByLastView(items);
                    userHistory = {};

                    let projectsCount = 0;
                    let dashboardsCount = 0;
                    let keptCount = 0;

                    items.forEach(function(item) {
                        let keep = (keptCount < clearedSize);
                        if (!keep && item.type=='PROJECT') keep = (++projectsCount <= keepProjDbdTarget);
                        if (!keep && item.type=='DASHBOARD') keep = (++dashboardsCount <= keepProjDbdTarget);

                        if (keep) {
                            keptCount++;
                            userHistory[item.key] = item;
                        }
                    });
                }
                return userHistory;

            }
            function clean(userHistory) {
                // fix on-going sporadic issue that impacts Personal home page
                if (userHistory.hasOwnProperty("undefined")) {
                    delete userHistory["undefined"];
                }
            }

            function cleanOldWikiArticles(userHistory, savedItem) {
                // cleaning old wiki articles with same projectKey
                if (savedItem.type !== 'ARTICLE') return;

                Object.keys(userHistory).forEach(function(key) {
                    const item = userHistory[key];

                    if (item.type === 'ARTICLE'
                        && item.projectKey === savedItem.projectKey) {
                        delete userHistory[key];
                    }
                });
            }

            function persist(userHistory) {

                clean(userHistory);

                userHistory = truncateUserHistoryList(userHistory);

                var dssHistory = LocalStorage.get('dssHistory') || {};
                var user = $rootScope.appConfig.login;
                dssHistory[user] = userHistory;
                LocalStorage.set('dssHistory', dssHistory);
            }

            /*
                Saved items:
                {
                    key (unique),
                    displayName,
                    type,
                    subtype,
                    projectKey,
                    views,
                    lastViewed (timestamp),

                    [any content saved in TopNav item]
                }
            */
            function doSave(item, incrementView, incrementUpdate) {
                let key = getKey(item);
                if (String(key) === "undefined") return; //unclear how this happens, but it's problematic

                let dssHistory = getHistory();
                let savedItem = dssHistory[key];
                let views = 0;
                let data = {};
                let updates = 0;

                if (savedItem) {
                    views = savedItem.views;
                    data = savedItem.data;
                    updates = savedItem.updates;
                }

                savedItem = $.extend(savedItem, item, {
                    views: views + (incrementView ? 1 : 0),
                    updates: updates + (incrementUpdate ? 1 : 0),
                    lastViewed: Date.now(), //UTC timestamp
                    lastUpdated: !savedItem ? 0 : (incrementUpdate ? Date.now() : savedItem.lastUpdated)
                });

                //avoid overwriting data with
                if (item.data.loading) {
                    savedItem.data = data;
                } else {
                    savedItem.data = $.extend({}, data, savedItem.data);
                }

                savedItem.displayName = savedItem.data.name || savedItem.displayName;
                savedItem.subtype = getSubtype(item) || savedItem.subtype ;
                if (!savedItem.projectKey) savedItem.projectKey = $stateParams.projectKey;

                cleanOldWikiArticles(dssHistory, savedItem);
                dssHistory[key] = savedItem;
                persist(dssHistory);
            }

            function saveItem(item) {
                doSave(item, true);
            }

            function saveItemWithoutViewIncrement(item) {
                doSave(item, false);
            }

            function getKey(item) {
                var projectKey = item.projectKey || $stateParams.projectKey;
                var type = item.type ? item.type : "";
                return projectKey + ':' + type + ':' + item.id;
            }

            function getSubtype(item) {
                if (!item || !item.data) {
                    return;
                }
                if (item.type == "ANALYSIS") {
                    return "ANALYSIS";
                }
                if (item.type == "JUPYTER_NOTEBOOK" || item.type == "SQL_NOTEBOOK") {
                    return item.type;
                }
                var data = item.data;
                return data.datasetType || data.recipeType || data.type;
            }

            var trackedType = TAGGABLE_TYPES;
            function isTracked(item) {
                if (item.data && item.data.dummy) {
                    return false;
                }
                return trackedType.indexOf(item.type) >= 0;
            }

            function hasUpdatedData(itemOld, itemNew) {
                if (!itemNew.data || itemNew.data.loading) {
                    return false;
                } else if (!itemOld.data) {
                    return true;
                } else {
                    return !angular.equals(itemOld.data, $.extend({}, itemOld.data, itemNew.data));
                }
            }

            function onItemChange(item) {
                if (item && item.id && (item.displayName || (item.data && item.data.name)) && isTracked(item)) {
                    if (!TopNav.sameItem(currentItem, item)) {
                        saveItem(item);
                    } else if (hasUpdatedData(currentItem, item)) {
                        saveItemWithoutViewIncrement(item);
                    }
                }
                currentItem = item;
            }

            function sort(items, fn) {
                function compare(a,b) {
                    var fa = fn(a), fb = fn(b);
                    if (fa < fb)
                       return 1;
                    if (fa > fb)
                      return -1;
                    return 0;
                }
                return items.sort(compare);
            }

            function sortByLastView(items) {
                return sort(items, function(item){return item.lastViewed});
            }

            function sortByMostViewed(items) {
                return sort(items, function(item){return item.views});
            }

            var currentItem = $rootScope.topNav.item;
            $rootScope.$watch('topNav.item', onItemChange, true);
            onItemChange(currentItem);



            // ********* Public interface ********

            function getRecentlyViewedItems (n, requestedType, requestedProject, includeCurrentItem) {
                if (requestedType == 'ANY') {
                    requestedType = null;
                }

                var dssHistory = getHistory();
                // Change unwound to help automated testing with older version of Chrome var items = Object.values(dssHistory);
                let items = Object.keys(dssHistory).map(function(key) {return dssHistory[key];});
                items = sortByLastView(items);

                // Filter types and remove the current item from history.
                // Note: using $rootScope.topNav.item directly instead of currentItem because getRecentlyViewedItems
                // can be called before onItemChange is triggered (so before currentItem is updated)
                if ($rootScope.topNav.item || requestedType) {
                    items = items.filter(function(item) {
                        if (!includeCurrentItem && $rootScope.topNav.item && getKey(item) == getKey($rootScope.topNav.item)) {
                            return false;
                        }
                        if (requestedProject && item.projectKey != requestedProject) {
                            return false
                        }
                        item.key = getKey(item);//DEBUG
                        return (
                            !requestedType ||
                             requestedType == 'ANY' ||
                            (requestedProject && item.type=='PROJECT') ||
                            (requestedType == item.type) ||
                            (requestedType == 'NOTEBOOK' && (item.type == 'SQL_NOTEBOOK' || item.type == 'JUPYTER_NOTEBOOK'))
                        );
                    });
                }
                return items.slice(0,n);
            }

            function getHistoryInfo(item) {
                var dssHistory = getHistory();
                var savedItem = dssHistory[getKey(item)];
                return $.extend({}, item, savedItem);
            }

            function notifyRenamed(oldItem, newName) {
                // the following three types are required in oldItem
                if (!oldItem) return;
                var newType = oldItem.type;
                var newId = oldItem.id;
                var newProjectKey = oldItem.projectKey;
                if (!newId || !newType || !newProjectKey) {
                    return;
                }

                var oldKey = getKey(oldItem);
                var dssHistory = getHistory();
                var savedItem = dssHistory[oldKey] || {};
                if (newType == "DATASET" || newType == "RECIPE") {
                    newId = newName; //for these types, id == name
                }

                savedItem.id = newId;
                savedItem.displayName = newName;

                var newKey = getKey({
                    type: newType,
                    id: newId,
                    projectKey: newProjectKey
                });
                if (oldKey != newKey) {
                    delete dssHistory[oldKey];
                }
                dssHistory[newKey] = savedItem;

                persist(dssHistory);

                if (TopNav.sameItem(oldItem, currentItem)) {
                    currentItem.id = newId;
                    currentItem.displayName = newName;
                }
            }


            function notifyRemoved(item, impact) {
                var key = getKey(item);
                var dssHistory = getHistory();

                if (dssHistory.hasOwnProperty(key)) {
                    delete dssHistory[key];
                }

                if (impact) {
                    if (impact.deletedRecipes) {
                        impact.deletedRecipes.forEach(function(recipe){
                            var key = getKey({
                                type: "RECIPE",
                                id: recipe.name,
                                projectKey: recipe.projectKey
                            });

                            if (dssHistory.hasOwnProperty(key)) {
                                delete dssHistory[key];
                            }
                        })
                    }
                    if (impact.deletedAnalyses) {
                        impact.deletedAnalyses.forEach(function(analysis){
                            var key = getKey({
                                type: "ANALYSIS",
                                id: analysis.id,
                                projectKey: analysis.projectKey
                            });

                            if (dssHistory.hasOwnProperty(key)) {
                                delete dssHistory[key];
                            }
                        })
                    }
                }

                persist(dssHistory);
            }

            function itemUpdated(method, data) {
                // most REST API POST commands represent an item update or other interesting action.
                //  A few, though, need to be ignored.
                const ignoredAction  = ['/get', 'pop-', '/refresh', '/prepare', '/check', '/search'].find((s) =>  method.indexOf(s) >=0 );
                if  (ignoredAction || !currentItem || !currentItem.hasOwnProperty("data") || currentItem.data==null || currentItem.id =="New dataset"){
                    return;
                }

                doSave(currentItem, false, true);
            }

            function itemEnriched(item) {
                doSave(item, false, false);
            }

            function projectOpened(project) {
                saveItem( {projectKey: project.projectKey, id: project.projectKey, type:'PROJECT', data: project });

                // current item can be missing project data due to delayed loading
                if (currentItem && currentItem.type=='PROJECT' && currentItem.projectKey==project.projectKey) currentItem.data = project;
            }

            return {
                getRecentlyViewedItems: getRecentlyViewedItems,
                getHistoryInfo: getHistoryInfo,
                // getHistoryInfoAndSort: getHistoryInfoAndSort,
                notifyRenamed: notifyRenamed,
                notifyRemoved: notifyRemoved,
                recordItemPost:  itemUpdated,
                recordProjectOpen: projectOpened,
                recordEnrichment: itemEnriched
            };
    }]);

})();

(function(){
    'use strict';

    var app = angular.module('dataiku.services');

    app.directive('globalSearch', function($state, $stateParams, $filter, DataikuAPI, WT1, Debounce, HistoryService) {
        return {
            restrict : 'A',
            scope : true,
            link : function(scope, element, attrs) {
                var formerPattern;
                function search() {
                    if(formerPattern != scope.quickgo.searchPattern){
                        formerPattern = scope.quickgo.searchPattern;
                        scope.quickgo.searchResults = null;
                        if (!scope.quickgo.searchPattern.length) return;
                        var recentItems = HistoryService.getRecentlyViewedItems(20);
                        var recentKeys = recentItems.map(function(item){
                            return item.key
                        });
                        var serializedRecentKeys = angular.toJson(recentKeys);
                        scope.quickgo.searching = true;
                        DataikuAPI.home.projectSearch($stateParams.projectKey, scope.quickgo.searchPattern, scope.quickgo.requestedType, serializedRecentKeys)
                        .success(function(items) {
                            scope.quickgo.searching = false;
                            var lower = scope.quickgo.searchPattern.toLowerCase();
                            if (items.length > 15) {
                                items.splice(15);
                            }
                            scope.quickgo.searchResults = items;
                            if (scope.quickgo.searchPattern.length) {
                                Debounce()
                                    .withDelay(10000, 15000)
                                    .wrap(function(){WT1.event("global-search")})
                                    .call();
                            }
                        }).error(function(){
                            scope.quickgo.searching = false;
                        });
                    }
                }

                scope.$watch("quickgo.searchPattern", Debounce()
                    //.withDelay(200, 250)
                    .withSpinner(false)
                    .withScope(scope)
                    .wrap(search)
                );
            }
        };
    });


})();
(function(){
    'use strict';

    const app = angular.module('dataiku.widgets.tageditfield', ['dataiku.services']);

    app.service('TagEditService', function(TaggingService) {
        const svc = this;
        let allTags = {};
        let filteredTags = {};
        let globalTagsCategory;
        let tags;

        this.setTags = function(tagsMap) {
            tags = tagsMap;
        };

        this.setActiveCategory = function(category) {
            globalTagsCategory = category;
            return globalTagsCategory;
        };

        this.unSelectedDropDownIdx = function () { // ensure the implicit select of the exact matching tags
            return filteredTags.isExactMatch &&
                    filteredTags.items.length && filteredTags.items[0].isMatch? 0 : undefined;
            }

        function adjustDropDownIndex(ui) {
            if (!isNaN(ui.dropDownIndex)) {
                if (filteredTags.length === 0) {
                    ui.dropDownIndex = undefined;
                }
                else if (ui.dropDownIndex > filteredTags.length - 1) {
                    ui.dropDownIndex = Math.max(filteredTags.length - 1, 0);
                }
            }

            if (isNaN(ui.dropDownIndex)) {
               ui.dropDownIndex = svc.unSelectedDropDownIdx(filteredTags);
            }
            return ui;
        }

        function flagSelectedItems() {
            if (!tags) return;

            Object.keys(allTags).forEach((tagTitle, index) => { allTags[tagTitle].selected = false; });

            tags.forEach((tagTitle) => {
                const tagDetails = allTags[tagTitle];
                if (tagDetails) {
                     tagDetails.selected = true;
                }
            });
            return allTags;
        }

        this.updateDropListOnTagChange = function(uiState, objectType) {
            allTags = flagSelectedItems(allTags);
            filteredTags = svc.filterTagListByInput(allTags, uiState.newTag, objectType);
            uiState = adjustDropDownIndex(filteredTags, uiState);
            return { allTags : allTags,
                    filteredTags : filteredTags,
                    uiState: uiState };
        };

        function isInputMatchingSelectedTag(input) {
            const inputLower = input.toLowerCase();
            return !tags || !tags.every(tagTitle => tagTitle.toLowerCase() != inputLower);
        }

        this.filterTagListByInput = function(allTagsMap, newTag, objectType) {
            allTags = allTagsMap;
            const list = [];
            const selectedList = [];
            const input = newTag.toLowerCase();
            const globalTagsCategories = [];
            const inputWithGlobalTagCat = globalTagsCategory ? `${globalTagsCategory.toLowerCase()}:${input}` : input;
            let isExactMatch = false;
            if (allTags) {
                Object.keys(allTags).forEach((tagTitle, index) => {
                    const tag = allTags[tagTitle];
                    if (!tag.lowerTitle) tag.lowerTitle = tagTitle.toLowerCase();

                    const isMatch = (input === tag.lowerTitle);
                    isExactMatch |= isMatch;
                    const shouldGlobalTagBeListed = !globalTagsCategory || (globalTagsCategory == tag.globalTagsCategory);

                    if (tag.selected && shouldGlobalTagBeListed
                            && (!input || tag.lowerTitle.startsWith(input) || tag.lowerTitle.startsWith(inputWithGlobalTagCat))) {
                        selectedList.push({ 'title': tagTitle,  color: tag.color, globalTagsCategory: tag.globalTagsCategory, match: isMatch });
                    }

                    if (!tag.selected && shouldGlobalTagBeListed
                            && (!input || tag.lowerTitle.startsWith(input) || tag.lowerTitle.startsWith(inputWithGlobalTagCat))) {
                        list.push({ 'title': tagTitle,  color: tag.color, globalTagsCategory: tag.globalTagsCategory, match: isMatch });
                    }
                        //only display add button for categories that have unselected global tags
                    if (!tag.selected && tag.globalTagsCategory && !globalTagsCategories.includes(tag.globalTagsCategory)
                            && TaggingService.shouldGlobalTagApply(tag.appliesTo, objectType)) {
                        globalTagsCategories.push(tag.globalTagsCategory);
                    }
                });
            }

            const isSelectedTag = isInputMatchingSelectedTag(input);
            const canCreateItem = (!!input && !isExactMatch && !isSelectedTag && !globalTagsCategory);

            filteredTags = { items: list.sort((a,b) => a.title.localeCompare(b.title)),
                            selectedItems: selectedList.sort((a,b) => a.title.localeCompare(b.title)),
                            createItem: canCreateItem ? newTag : undefined,
                            length: canCreateItem ? list.length + 1: list.length,
                            isExactMatch: isExactMatch,
                            isSelectedTag: isSelectedTag,
                            globalTagsCategories: globalTagsCategories};

            return filteredTags;
        }

        this.initUiState = function() {
            return {
                newTag: '', // text in the input field via ng-model
            };
        }
    });

    app.directive('tagField', function($timeout, $rootScope, CreateModalFromTemplate, TaggingService, TagEditService){
        return {
            templateUrl: "/templates/taggable-objects/tag-edit-field.html",
            restrict:'E',
            scope: {
                getAllTags: '&?',
                tags: '=ngModel',
                objectType: '=?',
                savedTags: '=?',
                isEditing: '=?',
                onStartEdit: '&?',
                onCancelEdit: '&?',
                onSaveEdit: '&?',
                editable: '=?',
                saveBtnText: '@?',
                manageLink: '='

            },
            link: function(scope, element, attrs){

                scope.allTags = {};

                if (typeof scope.editable == 'undefined') {
                    scope.editable = true;
                    scope.isEditing = false;
                }

                if (typeof scope.saveBtnText == 'undefined') {
                    scope.saveBtnText = "Save";
                }

                if (typeof scope.savedTags == 'undefined') {
                    scope.savedTags = angular.copy(scope.tags);
                }
                if (typeof scope.onStartEdit == 'undefined') { //if onStartEdit callback is missing, assume we are working in self-contained mode without callbacks
                    scope.onStartEdit = function() { 
                        setTagIdxToLastTag();
                        scope.isEditing = true;                      
                    }
                    scope.onCancelEdit  = function() {    
                        scope.tags = angular.copy(scope.savedTags);
                        scope.isEditing = false;   
                    } 
                    scope.onSaveEdit  = function() { 
                        if (scope.isEditing) {
                            scope.savedTags = angular.copy(scope.tags);  
                            scope.isEditing = false;
                        }
                    }  
                }

                if ($rootScope.activeProjectTagColor) {
                    scope.tagColor = $rootScope.activeProjectTagColor;
                } else {
                    scope.tagColor = function() {
                        return "#999";
                    }
                }

                scope.provideDropDown = (scope.getAllTags!=undefined);
                scope.allowManageTags = (scope.manageLink==undefined || scope.manageLink);

                scope.uiState = TagEditService.initUiState();

                function setTagIdxToLastTag() {
                    scope.uiState.tagIndex = scope.tags ? scope.tags.length - 1 : undefined;
                }

                function reInitTagIndex() {
                    if (scope.uiState.newTag) {
                        scope.uiState.tagIndex = undefined; //stop over-enthusiastic delete-key from deleting selected tags
                    }
                    else {
                        if (isNaN(scope.uiState.tagIndex)) {
                            $timeout(setTagIdxToLastTag,1200);
                        }
                    }
                }

                function updateDropListOnTagChange() {
                    if (!scope.provideDropDown) return;
                    const data = TagEditService.updateDropListOnTagChange(scope.uiState, scope.objectType);
                    scope.allTags = data.allTags;
                    scope.filteredTags = data.filteredTags;
                    scope.uiState = Object.assign(scope.uiState, data.uiState);
                    reInitTagIndex();
                };

                var getInput = () => element.find('.tag-editor-input');
                var setInputFocus = () => getInput().focus();

                function eatEvent(e) {
                    e.stopPropagation();
                    e.preventDefault();
                }

                function applyManageTagsChanges(existingList, newAllTags) { //rename any tags in-edit
                    const newTags = [];
                    existingList.forEach( tag => {
                        if (newAllTags[tag]) {
                            if (newAllTags[tag].updatedTagName) {
                                newTags.push(newAllTags[tag].updatedTagName);
                            }
                            else {
                                newTags.push(tag);
                            }
                        }
                        else if (!scope.allTags[tag]) {
                            newTags.push(tag); // a tag just typed into edit field, hence not in the newAllTags list
                        }

                    });

                    return newTags;
                 }

                function handleManageTagsComplete(newAllTags) {
                    if (newAllTags) {
                        scope.tags = applyManageTagsChanges(scope.tags, newAllTags);
                        scope.savedTags = applyManageTagsChanges(scope.savedTags, newAllTags);
                    }
                    setTagIdxToLastTag();
                    $timeout(setInputFocus, 100);
                }

                scope.cancelEdit = function(e) {
                    eatEvent(e);
                    scope.onCancelEdit();
                }

                scope.saveEdit = function(e) {
                    eatEvent(e);
                    scope.onSaveEdit();
                }

                scope.deleteTag = function(isBackspace, idx){
                    let index = idx;
                    if (index === null || index === undefined) index = scope.uiState.tagIndex;

                    if (!isNaN(index)) {
                        scope.tags.splice(index, 1); // remove tag at tagIndex
                        scope.uiState.tagIndex = Math.max(index - (isBackspace ? 1 : 0), 0);
                        setInputFocus();
                    }
                    updateDropListOnTagChange();
                };

                scope.isCreateTagSelected = function (idx) {
                    return (scope.filteredTags.createItem && idx == scope.filteredTags.length-1);
                }

                scope.scrollToInput = function (){
                    $timeout(() => {
                        const $div = getInput().parent();
                        if ($div.length>0)$div[0].scroll({top:0, left:10000, behavior: 'smooth'});
                    }, 10);
                }

                scope.dropListLeft = function(){
                    if (scope.elTags==undefined || !scope.elTags.width()) {
                        scope.elTags = $(element).find('.tags');
                        scope.elInput = $(element).find('.tag-editor-input');
                        scope.elDropList = $(element).find('.tag-pick-options');
                        scope.elOuter = $(element).find('.tag-edit-field');
                    }

                    let left = Math.max(scope.elTags.width() - scope.elInput.width(), 0);
                    left = Math.min(left, scope.elOuter.width() - scope.elDropList.width() - scope.elTags.position().left);
                    return left;
                }

                scope.addTag = function(idx){
                    let added = false;

                    if (!isNaN(idx)) {
                        if (scope.isCreateTagSelected(idx)) {
                            scope.tags.push(scope.filteredTags.createItem); // create new tag
                        }
                        else { //select tag in droplist
                            scope.tags.push(scope.filteredTags.items[idx].title);
                        }
                        added = true;
                        updateDropListOnTagChange();
                        scope.uiState.newTag = "";
                        setTagIdxToLastTag();

                        scope.scrollToInput();
                    }

                    return added;
                };

                scope.$watch('uiState.newTag', function(nv, ov) {
                    scope.filteredTags = TagEditService.filterTagListByInput(scope.allTags,  scope.uiState.newTag, scope.objectType);
                    reInitTagIndex();
                    scope.uiState.dropDownIndex =  TagEditService.unSelectedDropDownIdx();
                    if (nv!="") scope.uiState.tagIndex = undefined;
                });

                scope.$watch('tags', function(nv, ov) {
                    if (!nv) return;
                    if (!ov) setTagIdxToLastTag();
                    TagEditService.setTags(scope.tags);
                    updateDropListOnTagChange();
                });

                scope.$watch('allTags', function(nv, ov) {
                    scope.filteredTags = TagEditService.filterTagListByInput(scope.allTags,  scope.uiState.newTag, scope.objectType);
                    reInitTagIndex();
                    if (scope.tags) updateDropListOnTagChange(); //we need to do this when using Manage Tags but not on initialisation
                });

                scope.$on("tagFieldAddTag", function(event, callback) {
                    //this gets called in a circuitous fashion: onSave -> dip/validateEditTags -> $broadcast back here, with callback that needs to be called to
                    // end the 'editing' mode of the UI.
                    //nothing really happens in this now, as far as I can see.  AddTag is about individual tags, not saveds, while we just need to update the scope.tags array. think.... scope.addTag();
                    if (callback) callback();
                });

                scope.onSelectTag = function (e, idx) {
                    scope.uiState.tagIndex = idx;
                }

                scope.globalTags = TaggingService.getGlobalTags(scope.objectType);
                Object.assign(scope.allTags, scope.globalTags);

                scope.onStartTagEdit = function (e, category) {
                    TagEditService.initUiState();
                    scope.globalTagsCategory = TagEditService.setActiveCategory(category);
                    if (scope.getAllTags){
                        scope.provideDropDown = false;
                        scope.getAllTags().then((d) => {
                            scope.provideDropDown = true;
                            scope.allTags = Object.assign(d, scope.globalTags);
                        });
                    }
                    scope.onStartEdit();
                }

                scope.onDropdownClick = function (e, idx) {
                    eatEvent(e);

                    if (isNaN(idx)) return;
                    scope.addTag(idx);
                    setInputFocus();
                    scope.uiState.dropDownIndex = TagEditService.unSelectedDropDownIdx();
                }

                scope.onDropdownKeydown = function (e, idx) {
                    if (e.keyCode==13) { // enter key
                        scope.addTag(idx);
                        setInputFocus();
                        eatEvent(e);
                    }
                }

                scope.manageTags = function() {
                    CreateModalFromTemplate("/templates/widgets/edit-tags-modal.html", scope, null, function(modalScope) {
                        modalScope.tagsDirty = angular.copy(scope.allTags);

                        modalScope.save = function() {
                            handleManageTagsComplete(modalScope.tagsDirty);
                            TaggingService.saveToBackend(modalScope.tagsDirty)
                                .success(() => {
                                    if (scope.getAllTags) {
                                        scope.getAllTags().then(d => scope.allTags = d);
                                    }
                                    modalScope.resolveModal();
                                })

                                .error(setErrorInScope.bind(scope));
                        };

                        modalScope.cancel = function () {
                            handleManageTagsComplete();
                            modalScope.dismiss();
                        }
                    });
                };

                function onDownArrow(ui) {
                    if (isNaN(ui.dropDownIndex)) {
                        ui.dropDownIndex = 0;
                    }
                    else {
                        ui.dropDownIndex = Math.min(ui.dropDownIndex + 1, scope.filteredTags.length - 1);
                    }
                    return true;
                }

                function onUpArrow(ui) {
                    scope.uiState.dropDownIndex =  isNaN(ui.dropDownIndex) || ui.dropDownIndex <= 0 ? TagEditService.unSelectedDropDownIdx() : ui.dropDownIndex - 1;
                    return true;
                }

                function onLeftArrow(ui) {
                    let eventDone = true;
                    if(!isNaN(ui.tagIndex)) {
                        ui.tagIndex = Math.max(ui.tagIndex - 1, 0);

                    } else if(ui.newTag.length === 0){
                        ui.tagIndex = scope.tags.length - 1;
                    }
                    else {
                        eventDone = false;
                    }
                    return eventDone;
                }

                function onRightArrow(ui) {
                    let eventDone = false;
                    if(!isNaN(ui.tagIndex)){
                        ui.tagIndex = ui.tagIndex + 1;
                        if(ui.tagIndex >= scope.tags.length){
                            ui.tagIndex = scope.tags.length-1;
                            scope.scrollToInput()
                        }
                        eventDone = true;
                    }
                    return eventDone;
                }

                function onDeleteKey(ui) {
                    let eventDone = false;
                    if (ui.newTag.length == 0) {
                        scope.deleteTag(true);
                        eventDone = true;
                    }
                    return eventDone;
                }

                function onEnterKey(ui) {
                    let idx = ui.dropDownIndex;
                    const tags = scope.filteredTags;

                    if (isNaN(idx) && tags.createItem != undefined) idx = tags.length-1; // create new tag
                    if (isNaN(idx) && tags.items.length > 0 && tags.items[0].match) idx = 0; //exact match of existing item with input text
                    if (isNaN(idx) ) {
                        if (ui.newTag=="") scope.onSaveEdit();
                    }
                    else {
                        scope.addTag(idx);
                    }
                    return true;
                }

                scope.onInputKeydown = function (e) {

                    const ui = scope.uiState;
                    let eventDone = false;

                    switch (e.keyCode) {
                        case 40:
                            eventDone = onDownArrow(ui);
                            break;
                        case 38:
                             eventDone = onUpArrow(ui);
                            break;
                        case 37:
                            eventDone = onLeftArrow(ui)
                            break;
                        case 39:
                            eventDone = onRightArrow(ui)
                        break;
                        case  8:
                            eventDone = onDeleteKey(ui)
                            break;
                        case 13:
                            eventDone = onEnterKey(ui)
                            break;
                        default:

                            break;
                    }

                    if (eventDone) eatEvent(e);

                };

            }
        };
    });


    app.directive('tagEditPopover', function($timeout, $rootScope, CreateModalFromTemplate, TaggingService, TagEditService){
        return {
            templateUrl: "/templates/taggable-objects/tag-edit-popover.html",
            restrict:'E',
            scope: {
                tags: '=ngModel',
                getAllTags: '&?',
                objectType: '=?',
                manageLink: "=",
                noTagIcon: '<',
                editable: '=?',
                responsive: '=?'

            },
            link: function(scope, element, attrs) {

                scope.allTags = {};

                if (typeof scope.editable == 'undefined') {
                    scope.editable = true;
                }

                function onStartEdit() {
                    setTagIdxToLastTag();
                    scope.isEditing = true;
                }

                function onSaveEdit() {
                    scope.isEditing = false;
                    if (scope.edited) {
                        scope.$emit("objectSummaryEdited");
                        scope.edited = false;
                    }
                }

                if ($rootScope.activeProjectTagColor) {
                    scope.tagColor = $rootScope.activeProjectTagColor;
                } else {
                    scope.tagColor = TaggingService.getTagColor;
                }

                if (!scope.getAllTags) {
                    scope.tags.forEach((tag) => {
                        scope.allTags[tag] = { color: scope.tagColor(tag) };
                    });
                }

                function initUiState() {
                    scope.uiState = {
                        newTag: '', // text in the input field via ng-model
                    };
                }

                scope.allowManageTags = (scope.manageLink==undefined || scope.manageLink);

                initUiState();

                function setTagIdxToLastTag() {
                    scope.uiState.tagIndex = scope.tags ? scope.tags.length - 1 : undefined;
                }

                function reInitTagIndex() {
                    if (scope.uiState.newTag) {
                        scope.uiState.tagIndex = undefined; //stop over-enthusiastic delete-key from deleting selected tags
                    }
                    else {
                        if (isNaN(scope.uiState.tagIndex)) {
                            $timeout(setTagIdxToLastTag, 1200);
                        }
                    }
                }

                function updateDropListOnTagChange() {
                    TagEditService.setTags(scope.tags);
                    const data = TagEditService.updateDropListOnTagChange(scope.uiState, scope.objectType);
                    scope.allTags = data.allTags;
                    scope.filteredTags = data.filteredTags;
                    scope.uiState = Object.assign(scope.uiState, data.uiState);
                    reInitTagIndex();
                };

                var getInput = () => element.find('.tag-edit-filter__input');
                var setInputFocus = () => getInput().focus();

                function eatEvent(e) {
                    if (e) {
                        e.stopPropagation();
                        e.preventDefault();
                    }
                }

                function applyManageTagsChanges (existingList, newAllTags) { //rename any tags in-edit
                    const newTags = [];
                    existingList.forEach( tag => {
                        if (newAllTags[tag]) {
                            if (newAllTags[tag].updatedTagName) {
                                newTags.push(newAllTags[tag].updatedTagName);
                            }
                            else {
                                newTags.push(tag);
                            }
                        }
                        else if (!scope.allTags[tag]) {
                            newTags.push(tag); // a tag just typed into edit field, hence not in the newAllTags list
                        }

                    });

                    return newTags;
                 }

                function handleManageTagsComplete(newAllTags) {
                    if (newAllTags) {
                        scope.tags = applyManageTagsChanges(scope.tags, newAllTags);
                    }
                    setTagIdxToLastTag();
                    $timeout(setInputFocus, 100);
                }

                scope.saveEdit = function(e) {
                    $("html").off("click.tagEdit");
                    eatEvent(e);
                    onSaveEdit();

                }

                scope.deleteTag = function(isBackspace, index = scope.uiState.tagIndex, isSelected) {
                    if (!isNaN(index)) {
                        scope.tags.splice(index, 1); // remove tag at tagIndex
                        scope.uiState.tagIndex = Math.max(index - (isBackspace ? 1 : 0), 0);
                        setInputFocus();
                    }
                    updateDropListOnTagChange();
                    scope.edited = true;
                    if (isSelected) {
                        scope.saveEdit(isBackspace);
                    }
                };

                function isCreateTagSelected(idx) {
                    return (scope.filteredTags.createItem && idx == scope.filteredTags.length-1);
                }

                scope.addTag = function(idx) {
                    let added = false;

                    if (!isNaN(idx)) {
                        if (isCreateTagSelected(idx)) {
                            scope.tags.push(scope.filteredTags.createItem);
                            scope.allTags[scope.filteredTags.createItem] = { title: scope.filteredTags.createItem, color: TaggingService.getTagColor(scope.filteredTags.createItem) };
                        }
                        else { //select tag in droplist
                            scope.tags.push(scope.filteredTags.items[idx].title);
                        }
                        scope.edited = true;
                        added = true;
                        updateDropListOnTagChange();
                        scope.uiState.newTag = "";
                        setTagIdxToLastTag();
                    }

                    return added;
                };

                if (scope.editable) {
                    scope.$watch('uiState.newTag', function(nv, ov) {
                        scope.filteredTags = TagEditService.filterTagListByInput(scope.allTags, scope.uiState.newTag, scope.objectType);
                        reInitTagIndex();
                        scope.uiState.dropDownIndex =  TagEditService.unSelectedDropDownIdx();
                        if (nv !== "") {
                            scope.uiState.tagIndex = undefined;
                        }
                    });

                    scope.$watch('tags', function(nv, ov) {
                        if (!nv) return;
                        if (!ov) setTagIdxToLastTag();
                        TagEditService.setTags(scope.tags);
                        updateDropListOnTagChange();
                    });

                    scope.$watch('globalTagsCategory', function(nv, ov) {
                        if (nv == ov) return;
                        updateDropListOnTagChange();
                    })

                    scope.$watch('allTags', function(nv, ov) {
                        scope.filteredTags = TagEditService.filterTagListByInput(scope.allTags, scope.uiState.newTag, scope.objectType);
                        reInitTagIndex();
                        if (scope.tags) updateDropListOnTagChange(); //we need to do this when using Manage Tags but not on initialisation
                    });
                }

                function setAllTags() {
                    if (scope.getAllTags) {
                        scope.getAllTags().then((data) => {
                            scope.allTags = Object.assign(data, scope.globalTags);
                        });
                    }
                }
                setAllTags();
                scope.globalTags = TaggingService.getGlobalTags(scope.objectType);
                Object.assign(scope.allTags, scope.globalTags);

                scope.onStartTagEdit = function (e, category) {
                    if (!scope.editable || e.target.classList.contains("responsive-tags-list__tag-button")) {
                        return;
                    }
                    initUiState();
                    scope.globalTagsCategory = TagEditService.setActiveCategory(category);
                    setAllTags();
                    onStartEdit();
                    setInputFocus();
                    window.setTimeout(() => {
                        $("html").on("click.tagEdit", function(event) {
                            const filterTagPopover = function(node) {
                                return Array.prototype.indexOf.call(node.classList || [],'tag-edit-popover__popover') >= 0;
                            };
                            const filterManageTagsModal = function(node) {
                                return Array.prototype.indexOf.call(node.classList || [],'edit-tags-modal') >= 0 || Array.prototype.indexOf.call(node.classList || [],'modal-backdrop') >= 0;
                            };
                            const path = event.originalEvent && (event.originalEvent.path || (event.originalEvent.composedPath && event.originalEvent.composedPath()));
                            const isEventFromTagPopover = path && path.filter(filterTagPopover).length > 0;
                            const isEventFromManageTagsModal = path && path.filter(filterManageTagsModal).length > 0;
                            if (isEventFromTagPopover || isEventFromManageTagsModal) {
                                return;
                            }
                            scope.$apply(function() {
                                scope.saveEdit(event);
                            });
                        })
                    }, 0);
                }

                scope.onDropdownClick = function (e, idx, selected) {
                    eatEvent(e);

                    if (isNaN(idx)) return;
                    if (selected) {
                        const idxUnfilteredTags = scope.tags.indexOf(scope.filteredTags.selectedItems[idx].title);
                        scope.deleteTag(e, idxUnfilteredTags);
                    } else {
                        scope.addTag(idx);
                    }
                    setInputFocus();
                    scope.uiState.dropDownIndex = TagEditService.unSelectedDropDownIdx();
                }

                scope.onDropdownKeydown = function (e, idx) {
                    if (e.keyCode==13) { // enter key
                        if (idx < scope.filteredTags.selectedItems.length) {
                            const idxUnfilteredTags = scope.tags.indexOf(scope.filteredTags.selectedItems[idx].title);
                            scope.deleteTag(e, idxUnfilteredTags);
                        }
                        else {
                            scope.addTag(idx - scope.filteredTags.selectedItems.length);
                        }
                        setInputFocus();
                        eatEvent(e);
                    }
                }

                scope.manageTags = function() {
                    onSaveEdit();
                    CreateModalFromTemplate("/templates/widgets/edit-tags-modal.html", scope, null, (modalScope) => {
                        modalScope.tagsDirty = angular.copy(scope.allTags);

                        modalScope.save = function() {
                            handleManageTagsComplete(modalScope.tagsDirty);
                            TaggingService.saveToBackend(modalScope.tagsDirty)
                                .success(() => {
                                    if (scope.getAllTags) {
                                        scope.getAllTags().then(d => scope.allTags = d);
                                    }
                                    modalScope.resolveModal();
                                })

                                .error(setErrorInScope.bind(scope));
                        };

                        modalScope.cancel = function () {
                            handleManageTagsComplete();
                            modalScope.dismiss();
                        }
                    });
                };

                function onDownArrow(ui) {
                    ui.dropDownIndex = isNaN(ui.dropDownIndex) ? 0 : Math.min(ui.dropDownIndex + 1, scope.filteredTags.length + scope.filteredTags.selectedItems.length - 1);
                    return true;
                }

                function onUpArrow(ui) {
                    scope.uiState.dropDownIndex =  isNaN(ui.dropDownIndex) || ui.dropDownIndex <= 0 ? TagEditService.unSelectedDropDownIdx() : ui.dropDownIndex - 1;
                    return true;
                }

                function onDeleteKey(ui) {
                    let eventDone = false;
                    if (ui.newTag.length == 0) {
                        scope.deleteTag(true);
                        eventDone = true;
                    }
                    return eventDone;
                }

                function onEnterKey(ui) {
                    let idx = ui.dropDownIndex;
                    const tags = scope.filteredTags;

                    if (isNaN(idx) && tags.createItem != undefined) idx = tags.length - 1; // create new tag
                    if (isNaN(idx) && tags.items.length > 0 && tags.items[0].match) idx = 0; //exact match of existing item with input text
                    if (isNaN(idx) ) {
                        if (ui.newTag=="") scope.saveEdit();
                    }
                    else if (idx < scope.filteredTags.selectedItems.length) {
                        const idxUnfilteredTags = scope.tags.indexOf(scope.filteredTags.selectedItems[idx].title);
                        scope.deleteTag(false, idxUnfilteredTags);
                    }
                    else {
                        scope.addTag(idx - scope.filteredTags.selectedItems.length);
                    }
                    return true;
                }

                scope.onInputKeydown = function (e) {

                    const ui = scope.uiState;
                    let eventDone = false;

                    switch (e.keyCode) {
                        case 40:
                            eventDone = onDownArrow(ui);
                            break;
                        case 38:
                             eventDone = onUpArrow(ui);
                            break;
                        case 8:
                            eventDone = onDeleteKey(ui);
                            break;
                        case 13:
                            eventDone = onEnterKey(ui);
                            break;
                        default:
                            break;
                    }

                    if (eventDone) eatEvent(e);

                };

                let saveOnDestroy = scope.$on('$destroy', (e) => {
                    scope.saveEdit();
                });
            }
        };
    });

})();

(function() {
'use strict';

const app = angular.module('dataiku.catalog', []);


app.service('CatalogUtils', function() {
    const svc = this;

    function escape(str) {
        if (!str || typeof str != "string") {
            return;
        }
        return str.replace(/\\/g, '\\\\').replace(/&/g, '\\&').replace(/\+/g, '\\+');
    }

    this.getHash = function(queryString, facets) {
        const hash = [];
        if (queryString) {
            hash.push("q=" + escape(queryString));
        }
        for (const facet in facets) {
            if (!facets[facet] || !facets[facet].length) {
                continue;
            }
            hash.push(facet + "=" + facets[facet].map(escape).join('+'));
        }
        return hash.join("&");
    };

    this.getLink = function(queryString, facets, projectKey) {
        facets.projectKey = [projectKey];
        return "/catalog/#" + svc.getHash(queryString, facets);
    };

    this.parseHash = function($scope, hash) {
        if (!hash) return;
        const params = hash.match(/(\\&|[^&])+/g);  // split on non-escaped &
        const result = {};
        angular.forEach(params, function(param) {
            const parts = param.split('=');
            if (parts.length < 2) return;
            const key = parts[0];
            const value = parts.slice(1).join('').replace(/\\&/g, '&'); // replace \& by &
            result[key] = value;
            if (key == 'q') {
                $scope.query.queryString = value.replace(/\\\+/g, '+'); // replace \+ by +
            } else {
                const values = value.match(/(\\\+|[^\+])+/g);   // split on non-escaped +
                $scope.query.facets[key] = values.map(str => str.replace(/\\\+/, '+')); // replace \+ by +
            }
        });
        return result;
    };
});


app.service('CatalogTypes', function() {
    // taggable type -> catalog type mapping
    this.getCatalogType = function(taggableType) {
        if (!taggableType) return taggableType;
        const t = taggableType.toLowerCase();
        if (t.includes("notebook")) {
            return "notebook"
        }
        return t;
    };
});


app.controller("_CatalogControllerBase", function($state, $stateParams, $scope, searchEndpoint, $controller, $filter,
    Debounce, CatalogUtils, WT1, $timeout, TopNav, TaggingService) {

    let justDone = false;
    $scope.loadMoreItems = function() {
        if (!justDone && $scope.listItems && $scope.maxItems < $scope.listItems.length) {
            $scope.maxItems += 20;
            justDone = true;
            setTimeout(function() {
                justDone = false;
            }, 300);
        }
    };
    $scope.filterSortAndLimitItems = function() { // override to disable items filtering
        $scope.formatted_items = $filter('orderBy')($scope.listItems, $scope.sortOptions.column, $scope.sortOptions.reverse);
    };

    $scope.selection = {};
    $scope.listItems = [];
    $scope.facetsCollapse = {};
    $scope.facetsShowAll = {};
    $scope.facetsFilters = {};

    $scope.query = {
        queryString: "",
        facets: {}
    };

    CatalogUtils.parseHash($scope, $stateParams.hash);

    // Sort by score by default
    $scope.sortOptions = {
        column: '_score',
        reverse: true
    };

    $scope.canShowSearchResults = function() {
        return $scope.notReady || $scope.listItems === undefined || $scope.formatted_items === undefined || $scope.formatted_items.length !== 0;
    };
    let firstTimeRedirect = true;
    let displayedSearchEtag = 0;
    let latestSearchEtag = 0;
    $scope.search = function() {
        const searchEtag = ++latestSearchEtag;
        $scope.facetsShowAll['_type'] = false;
        if ($state.current.name.includes('catalog')) {
            // Do not change states and location hashes when not on catalog
            if (firstTimeRedirect) {
                $state.go('.', {hash: CatalogUtils.getHash($scope.query.queryString, $scope.query.facets)}, {notify: false, location:'replace'});
                firstTimeRedirect = false;
            } else {
                $state.go('.', {hash: CatalogUtils.getHash($scope.query.queryString, $scope.query.facets)}, {notify: false});
            }
        }
        delete $scope.formatted_items;

        const before = new Date().getTime();
        const promise = searchEndpoint($scope.query.queryString, $scope.query.facets);
        if (!promise) {
            return;
        }
        promise.success(function(resp) {
                let results; // Dirty, because inbox and catalog don't have the same result format...
                if (resp.results) {
                    results = resp.results;
                } else {
                    results = resp;
                }
                $scope.notReady = false;
                if (searchEtag <= displayedSearchEtag) {
                    return; // we already refreshed the UI for more recent results
                }
                const after = new Date().getTime();
                getDigestTime($scope, function(time) {
                    WT1.event("catalog-search-done", {searchTime: after - before, digestTime: time,});
                });
                addFacets(results.aggregations);
                $scope.error = false;
                $scope.results = results;
                $scope.listItems = results.hits.hits;
                $scope.filterSortAndLimitItems();
                displayedSearchEtag = searchEtag;
            })
            .error(function(data, status, headers, config) {
                if (status === 503 && data.errorType === "NotReady") {
                    $scope.notReady = true;
                    $timeout($scope.search, 5000); // retry in 5 seconds
                } else {
                    $scope.notReady = false;
                    $scope.error = true;
                }
            });
    };

    // Make sure that active facets are displayed even if their doc_count is 0
    function addFacets(aggs) {
        for (const field in aggs) {
            angular.forEach($scope.query.facets[field], function(value) {
                if (!aggs[field].agg.buckets.filter(function(bucket) {
                        return bucket.key == value;
                    }).length) {
                    aggs[field].agg.buckets.push({key: value, doc_count: 0});
                }
            });
        }
        if ($scope.inboxPage) {
            const statusFacetBuckets = aggs['closed'].agg.buckets;
            if (!statusFacetBuckets.find(bckt => bckt.key === 0)) {
                statusFacetBuckets.push({key: 0, doc_count: 0});
            }
            if (!statusFacetBuckets.find(bckt => bckt.key === 1)) {
                statusFacetBuckets.push({key: 1, doc_count: 0});
            }
        }
    }

    $scope.hasSearch = function() {
        return $scope.query.queryString !== '' || $scope.hasFacets();
    };

    $scope.hasFacets = function() {
        for (const field in $scope.query.facets) {
            for (let i = 0; i < ($scope.query.facets[field] || []).length; i++) {
                if (field !== '_type' || $scope.query.facets[field][i] !== 'all') return true;
            }
        }
        return false;
    };

    $scope.resetSearch = function() {
        $scope.query.queryString = "";
        $scope.query.facets = {};
    };

    $scope.$watch('query.facets', function(nv, ov) {
        if ((ov._type && ov._type.length) && (!nv._type || !nv._type.length)) { // remove subtype facet when switching object type
            delete nv.type_raw;
        }

        Object.entries(nv).forEach(e => $.isEmptyObject(e[1]) && delete nv[e[0]]);
        Object.entries(ov).forEach(e => $.isEmptyObject(e[1]) && delete ov[e[0]]);

        if (!angular.equals(nv, ov)) {
            $timeout($scope.search);
        }
    }, true);
    $scope.$watch('query.queryString', Debounce().withDelay(100, 200).wrap($scope.search));
    $scope.$watch('sortOptions.reverse', function(nv, ov) {
        if (nv !== ov) {
            $scope.filterSortAndLimitItems();
        }
    });
    $scope.$watch('sortOptions.column', function(nv, ov) {
        if (nv !== ov) {
            $scope.filterSortAndLimitItems();
        }
    });
    $scope.$watch('maxItems', function(nv, ov) {
        if (nv !== ov) {
            $scope.filterSortAndLimitItems()
        }
    });

    $scope.$watch("query", function(nv, ov) {
        $scope.maxItems = 20;
        $scope.filterSortAndLimitItems();
        $scope.$broadcast('clearMultiSelect')
    }, true);

    $scope.selectInput = function() {
        $(".catalog-search-input").select();
    };

    $scope.itemToColor = function(item) {
        if(!item) return;
        if (item._type == 'insight') {
            return $filter('insightTypeToColor')(item._source.type_raw) + ' insight-icon';
        } else if (item._type == 'recipe') {
            return 'recipe-' + $filter('recipeTypeToIcon')(item._source.type_raw).split('_')[0].split('icon-')[1];
        } else {
            return item._type;
        }
    };

    $scope.onFacetSearchKeyDown = function(e) {
        if (e.keyCode === 27) { // ESC key
            e.target.blur();
            angular.element(e.target).scope().$parent.showInput = false;
            angular.element(e.target).scope().$parent.facetValueSearch = '';
        }
    };

    $scope.facetValueMatching = function(field) {
        return function(search) {
            search = (search || "").toLowerCase();
            return function(item) {
                if (!search || !search.length) return true;
                return (item.key.toLowerCase().indexOf(search) != -1);
            }
        }
    };

    $scope.facetValueNotMatching = function(field, search) {
        return (item => !$scope.facetValueMatching(field)(search)(item))
    };

    TopNav.setLocation(TopNav.DSS_HOME, "catalog");
    TopNav.setNoItem();
    TaggingService.fetchGlobalTags();
});

})();
(function() {
'use strict';

const app = angular.module('dataiku.catalog');


const FACET_FIELDS_DISPLAY_NAMES = Object.freeze({
    'projectName': 'Project',
    'type_raw': 'Type',
    'numColumns': 'Columns',
    'usedIn': 'Used in',
    'user': 'Contributors',
    'storedAs': 'Stored as',
    'projectKey.raw': 'Project',
    'tag.raw': 'Tags',
    'catalog.raw': 'Database Catalog',
    'connection.raw': 'Connection',
    'schema.raw': 'Schema',
    'partitioned': 'Partitioned',
    'closed': 'Discussion status'
});


const DISPLAY_NAMES = Object.freeze({
    recipeTypes: {
        'shaker': 'Prepare'
    },
    notebookTypes: {
        'SQL_NOTEBOOK': 'SQL',
        'JUPYTER_NOTEBOOK': 'Jupyter',
        'IPYTHON_NOTEBOOK': 'Jupyter' //Legacy
    },
    notebookLanguages: {
        'SQL': 'SQL',
        'python2': 'Python 2',
        'python3': 'Python 3',
        'ir': 'R',
        'toree': 'Scala'
    }
});

/**
     * CatalogItemService makes a set of simple re-useable functions for displaying/formatting catalog-items
     * available to other controllers e.g. personal home page.
     */
    app.service('CatalogItemService', function( StateUtils, $location, Navigator, $filter, $state, FLOW_COMPUTABLE_TYPES) {
        const svc = this;

        svc.getLink = function (_type, _source, discussionId) {
            if (!_type || !_source) return;

            switch (_type) {
                case 'article':
                    return StateUtils.href.dssObject(_type.toUpperCase(), _source.id, _source.projectKey);

                case 'dashboard':
                    return StateUtils.href.dashboard(_source.id, _source.projectKey, {name: _source.name});

                case 'column':
                    return $state.href(
                        'projects.project.datasets.dataset.explore',
                        {projectKey: _source.projectKey, datasetName: _source.dataset}
                    );

                case 'comment':
                    return StateUtils.href.dssObject(
                        _source.objectType.toUpperCase(),
                        _source.objectId,
                        _source.projectKey
                    );
                case 'table':
                    return $state.href(
                        'external-table',
                        {
                            connection: _source.virtualConnection ? _source.virtualConnection : _source.connection,
                            catalog: _source.catalog,
                            schema: _source.schema,
                            table: _source.name
                        }
                    );
                case 'discussion':
                    const obj = {
                        type: _source.objectType.toUpperCase(),
                        id: _source.objectId,
                        projectKey: _source.projectKey
                    };
                    return StateUtils.href.taggableObject(obj, {moveToTargetProject: false, discussionId: _source.discussionId});
                case 'flow_zone':
                    return StateUtils.href.flowZone(_source.id, _source.projectKey, _source.name);
                default:
                    return StateUtils.href.dssObject(
                        (_type === 'notebook') ? _source.type_raw.toUpperCase() : _type.toUpperCase(),
                        _source.hasOwnProperty('id') ? _source.id : _source.name,
                        _source.projectKey
                    )
            }
        };

        svc.goToItem = function (_type, _source) {
            $location.path(svc.getLink(_type, _source));
        };

        svc.hasNavigator = function (_type) {
            return ['dataset', 'recipe', 'saved_model', 'model_evaluation_store', 'managed_folder', 'streaming_endpoint'].indexOf(_type) > -1;
        };

        svc.openNavigator = function (_type, _source) {
            return function () {
                Navigator.show(_source.projectKey, _type.toUpperCase(), _source.id);
            };
        };

        svc.getFlowLink = function (_type, _source, _contextProjectKey) {
            if (!_type || !_source) return;

            var id = "";

            const flowProjectKey = _contextProjectKey ||_source.projectKey;

            switch (_type) {
                case 'dataset':
                    id = "dataset_" + _source.projectKey + '.' + _source.id;
                    break;
                case 'managed_folder':
                    id = "managedfolder_" + _source.projectKey + '.' + _source.id;
                    break;
                case 'model_evaluation_store':
                    id = "modelevaluationstore_" + _source.projectKey + '.' + _source.id;
                    break;
                case 'saved_model':
                    id = "savedmodel_" + _source.projectKey + '.' + _source.id;
                    break;
                case 'streaming_endpoint':
                    id = "streamingendpointl_" + _source.projectKey + '.' + _source.id;
                    break;
                case 'recipe':
                    id = "recipe_" + _source.id;
                    break;
            }

            return $state.href(
                'projects.project.flow',
                {projectKey: flowProjectKey, id: id}
            );
        };

        svc.hasFlowLink = function (_type) {
            return FLOW_COMPUTABLE_TYPES.includes(_type.toUpperCase()) || _type === 'recipe';
        };

        svc.itemToIcon = function (_type, _source, inList) {
            if (!_type || !_source) {
                return;
            }

            switch (_type) {
                case 'dataset':
                    return inList ? $filter('typeToIcon')(_source.type_raw) : $filter('datasetTypeToIcon')(_source.type_raw);
                case 'notebook':
                    return $filter('typeToIcon')(_source.type_raw);
                case 'web_app':
                    return $filter('subTypeToIcon')(_source.subtype || _source.type_raw, _type);
                default:
                    return $filter('subTypeToIcon')(_source.type_raw, _type);
            }
        };

        svc.itemToColor = function (_type, _source) {
            if (!_type || !_source) return;
            if (_type == 'insight') {
                return $filter('insightTypeToColor')(_source.type_raw) + ' insight-icon';
            } else if (_type == 'recipe') {
                return 'recipe-' + $filter('recipeTypeToIcon')(_source.type_raw).split('_')[0].split('icon-')[1];
            } else {
                return _type.toLowerCase();
            }
        };
    });



app.controller('CatalogItemsController', function($controller, $scope, $injector, $state, $stateParams, $route,
    $q, $location, $filter, $timeout,
    DataikuAPI, CreateModalFromTemplate, WT1, TopNav, DatasetsService, StateUtils, Debounce,
    CatalogUtils, Navigator, DashboardUtils, CachedAPICalls, CatalogItemService) {

    const overridenCatalogUtils = {
        getHash: CatalogUtils.getHash,
        getLink: CatalogUtils.getLink,
        parseHash: function($scope, hash) {
            CatalogUtils.parseHash($scope, hash);
            if (!$scope.query.facets['scope']) {
                $scope.query.facets['scope'] = $stateParams.scope ? $stateParams.scope : ['dss'];
            }
            if (!$scope.query.facets['_type'] && $stateParams._type) {
                $scope.query.facets['_type'] = $stateParams._type;
            }
        }
    };

    $controller("_CatalogControllerBase", {
        $scope: $scope,
        searchEndpoint: DataikuAPI.catalog.search,
        CatalogUtils: overridenCatalogUtils
    });

    $scope.getCatalogScope = () => $scope;

    $scope.tableComparator = function(one, other) {
        return one && other && one._id === other._id;
    };

    $scope.getNames = function(tables) {
        return tables.map(el => el._source.name);
    };

    $scope.getImportData = function (tables) {
        const selectedTables = tables || $scope.selection.selectedObjects;

        const tableKeys = selectedTables.map(t => ({
            connectionName: t._source.connection,
            catalog: t._source.catalog,
            schema: t._source.schema,
            name: t._source.name
        }));
        return {
            workflowType : "KEYS",
            tableKeys : tableKeys
        };
    };

    $scope.importTables = function (tables, zoneId) {
        const selectedTables = tables && !angular.isArray(tables) ? [tables] : tables;
        if ($stateParams.projectKey) {
            $state.go('projects.project.tablesimport', {
                projectKey: $stateParams.projectKey,
                importData : JSON.stringify($scope.getImportData(selectedTables)),
                zoneId
            });
        } else {
            let newScope;
            if (selectedTables) {
                newScope = $scope.$new();
                newScope.getImportData = () => $scope.getImportData(selectedTables)
            } else {
                newScope = $scope;
            }
            CreateModalFromTemplate("/templates/datasets/tables-import-project-selection-modal.html", newScope, "TablesImportProjectSelectionModalController");
        }
    };

    $scope.goToConnectionsExplorer = function() {
        if ($state.includes('projects.project')) {
            $state.go('projects.project.catalog.connectionexplorer');
        } else {
            $state.go('catalog.connectionexplorer');
        }
    };

    $scope.hasUnindexedConnections = function() {
        const iau = $scope.indexedAndUnindexed;
        if (!iau) {
            return;
        }
        return (iau.possiblyUnscannedHive || iau.unindexedButIndexableConnections > 0) &&
            ($scope.query.facets.scope[0] === "external" || $scope.query.facets.scope[0] === "all" );
    };

    const parentResetSearch = $scope.resetSearch;
    $scope.resetSearch = function() {
        const facetsScope = $scope.query.facets.scope;
        parentResetSearch();
        $scope.query.facets.scope = facetsScope || ['dss'];
    };

    $scope.isItemSelectable = function(item) {
        return item._type === 'table';
    };

    $scope.clickShowSelected = function() {
        $scope.showSelectedOnly = !$scope.showSelectedOnly;
    };

    $scope.isFunction = angular.isFunction;

    // Init

    $scope.showSelectedOnly = false;

    $scope.showAllTypes = false;

    $scope.projectKey = $stateParams.projectKey;
    $scope.itemsPage = true;

    $scope.locations = [
        {name: 'DSS', id: 'dss'},
        {name: 'External tables', id: 'external'}
    ];

    $scope.sortBy = [
        {
            label: 'Relevance',
            value: '_score'
        },
        {
            label: 'Type',
            value: i => i._type + i._source.type_raw
        },
        {
            label: 'Creation',
            value: i => i._source.createdOn
        },
        {
            label: 'Last modification',
            value: i => i._source.lastModifiedOn
        }
    ];


    const projectNames = {};

    $scope.types = [];
    $scope.tagMaps = {};
    $scope.users = {};

    // Watches

    $scope.$watch('selection.selectedObjects.length', function(nv, ov) {
        if (ov > 0 && nv === 0) {
            $scope.showSelectedOnly = false;
        }
    });

    function init() {
        DataikuAPI.connections.countIndexedAndUnindexed()
            .success(function(response) {
                $scope.indexedAndUnindexed = response;
            })
            .error(setErrorInScope.bind($scope));

        DataikuAPI.taggableObjects.listAllTags()
            .success(function(response) {
                $scope.tagMaps = response;
            })
            .error(setErrorInScope.bind($scope));

        DataikuAPI.security.listUsers()
            .success(function(response) {
                angular.forEach(response, function(user) {
                    $scope.users[user.login] = user.displayName;
                })
            })
            .error(setErrorInScope.bind($scope));

        DataikuAPI.projects.list()
            .success(function(response) {
                angular.forEach(response, function(project) {
                    projectNames[project.projectKey] = project.name;
                })
            })
            .error(setErrorInScope.bind($scope));
    }

    // Make sure that active facets are displayed even if their doc_count is 0
    function addFacets(aggs) {
        for (const field in aggs) {
            angular.forEach($scope.query.facets[field], function(value) {
                if (field == '_type' && value == 'all') return;
                if (!aggs[field].agg.buckets.filter(function(bucket) {
                        return bucket.key == value;
                    }).length) {
                    aggs[field].agg.buckets.push({key: value, doc_count: 0});
                }
            });
        }
    }

    $scope.getLink = function (input, discussionId) {
        if (!input) return;
        return CatalogItemService.getLink(input._type, input._source, discussionId);
    };

    $scope.goToItem = function(item) {
        if (!item) return;
        return CatalogItemService.goToItem(input._type, input._source);
    };

    $scope.hasNavigator = function(item) {
        if (!item) return;
        return CatalogItemService.hasNavigator(input._type);
    };

    $scope.openNavigator = function(item) {
        if (!item) return;
        return CatalogItemService.openNavigator(input._type, input._source);
    };

    $scope.getFlowLink = function(input) {
        if (!input) return;
        return CatalogItemService.getFlowLink(input._type, input._source);
    };

    $scope.hasFlowLink = function(input) {
        if (!input) return;
        return CatalogItemService.hasFlowLink(input._type, input._source);
    };

    $scope.formatFacetField = function(field) {
        return FACET_FIELDS_DISPLAY_NAMES[field] || $filter('capitalize')(field);
    };

    $scope.formatFacetValue = function(value, facet) {
        switch (facet) {
            case 'closed':
                return value ? 'Closed' : 'Open';
            case 'projectKey.raw':
                return projectNames[value] || value;
            case '_type':
                return $filter('capitalize')(value.replace(/_/g, " "));
            case 'user':
                return $scope.users[value] || value;
            case 'owner':
                return $scope.users[value] || value;
            case 'language':
                return DISPLAY_NAMES.notebookLanguages[value] || value;
            case 'connection.raw':
                return $filter('connectionNameFormatter')(value);
            case 'type_raw':
                if (!$scope.query.facets._type) {
                    return value;
                }
                switch ($scope.query.facets._type[0]) {
                    case 'dataset':
                        return $filter('capitalize')(value);
                    case 'recipe':
                        return DISPLAY_NAMES.recipeTypes[value] || $filter('capitalize')(value.replace(/_/g, " "));
                    case 'notebook':
                        return DISPLAY_NAMES.notebookTypes[value];
                    case 'saved_model':
                        return $filter('capitalize')(value);
                    case 'model_evaluation_store':
                        return $filter('capitalize')(value);
                    case 'insight':
                        return DashboardUtils.getInsightHandler(value).name || 'Unknown';
                    default:
                        return value;
                }
            case 'partitioned':
                return value === 0 ? 'No' : 'Yes';
        }
        return value;
    };

    // Override to allow to search for project by both name and key in the project list facet
    $scope.facetValueMatching = function(field) {
        return function(search) {
            search = (search || '').toLowerCase();
            return function(item) {
                if (!search || !search.length) {
                    return true;
                }
                if (item.key.toLowerCase().indexOf(search) != -1) {
                    return true;
                } else if (field == "projectKey.raw") {
                    return (projectNames[item.key] || '').toLowerCase().indexOf(search) != -1;
                }
                return false;
            }
        }
    };

    $scope.itemToIcon = function(item, inList) {
        if (!item) return;
        return CatalogItemService.itemToIcon(item._type, item._source, inList);
    };

    $scope.formatItemName = function(item, inList) {
        if (item._type == 'discussion') {
            const src = item._source;
            // Comes from _source, encode HTML entities in order to display attributes like <stuff
            const topic = (item.highlight && item.highlight['discussions.topic']) ? item.highlight['discussions.topic'][0] : ($filter('escapeHtml')(((src.discussions && src.discussions.length && src.discussions[0].topic) ? src.discussions[0].topic : "Unnamed discussion")));
            const title = topic + " <small>on " + src.objectType.replace('_', ' ') + "</small> " + $filter('escapeHtml')(src.objectName);
            return title;
        }
        if (item.highlight) {
            if (item.highlight.name && item.highlight.name.length) {
                return item.highlight.name[0];
            }
            if (item.highlight['name.raw'] && item.highlight['name.raw'].length) {
                return item.highlight['name.raw'][0];
            }
        }
        // Comes from _source, encode HTML entities in order to display attributes like <stuff
        return $filter('encodeHTML')(item._source.name);
    };

    $scope.getCommentLink = function(item) {
        const tor = {
            type: item._source.objectType.toUpperCase(),
            id: item._source.objectId,
            projectKey: item._source.projectKey
        };
        return StateUtils.href.taggableObject(tor, {moveToTargetProject: false});
    };

    $scope.highlightedAttachmentsList = function(item) {
        if (!item.hasOwnProperty('highlightedAttachments')) {
            item.highlightedAttachments = [];
            let strippedAttachments = [];
            if (item.highlight && item.highlight['attachments.displayName']) {
                strippedAttachments = item.highlight['attachments.displayName'].map(str => str.replace(/<\/?em>/g, ''));
            }
            angular.forEach(item._source.attachments, function(attachment) {
                const index = strippedAttachments.indexOf(attachment.name);
                if (index == -1) {
                    item.highlightedAttachments.push(attachment);
                } else {
                    item.highlightedAttachments.push({
                        displayName: item.highlight['attachments.displayName'][index],
                        type: attachment.type
                    });
                }
            });
        };

        return item.highlightedAttachments;
    };

    $scope.highlightedTagList = function(item) {
        if (!item.hasOwnProperty('highlightedTags')) {
            item.highlightedTags = [];
            let strippedTags = [];
            if (item.highlight && item.highlight.tag) {
                strippedTags = item.highlight.tag.map(str => str.replace(/<\/?em>/g, ''));
            }
            angular.forEach(item._source.tag, function(tag) {
                const index = strippedTags.indexOf(tag);
                if (index == -1) {
                    item.highlightedTags.push({raw: tag});
                } else {
                    item.highlightedTags.push({raw: tag, highlighted: item.highlight.tag[index]});
                }
            });
        }

        return item.highlightedTags;
    };

    $scope.getLinkForElement = function(currentProjectKey, element) {
        const projectKey = element.projectKey || currentProjectKey;
        switch (element.type) {
            case "DATASET":
                if (element.projectKey && element.projectKey !== currentProjectKey) {
                    return $state.href("projects.project.foreigndatasets.dataset.explore", {
                        datasetFullName: element.datasetFullName,
                        projectKey: currentProjectKey
                    });
                } else {
                    return $state.href("projects.project.datasets.dataset.summary", {
                        datasetName: element.name, projectKey: projectKey
                    });
                }
            case "SAVED_MODEL":
                return $state.href("projects.project.savedmodels.savedmodel.summary", {
                    smId: element.name,
                    projectKey: projectKey
                });
            case "MODEL_EVALUATION_STORE":
                return $state.href("projects.project.modelevaluationstores.modelevaluationstore.evaluations", {
                    smId: element.name,
                    projectKey: projectKey
                });
            case "MANAGED_FOLDER":
                return $state.href("projects.project.managedfolders.managedfolder.summary", {
                    odbId: element.name,
                    projectKey: projectKey
                });
            case "STREAMING_ENDPOINT":
                return $state.href("projects.project.streaming-endpoints.streaming-endpoint.settings", {
                    streamingEndpointId: element.name,
                    projectKey: projectKey
                });
            default:
                throw "Incorrect or missing flow computable type";
        }
    };

    $scope.itemCount = function() {
        let type = "all";
        if ($scope.query.facets._type && $scope.query.facets._type.length) {
            type = $scope.query.facets._type[0].replace('_', ' ');
        }
        const plural = $scope.results && $scope.results.hits.total > 1;
        if (type == 'analysis') {
            type = plural ? 'analyses' : 'analysis';
        } else if (type == 'all') {
            type = 'item' + (plural ? 's' : '');
        } else {
            type += plural ? 's' : '';
        }
        return '<strong>' + ($scope.results ? $scope.results.hits.total : 0) + '</strong> ' + type;
    };

    init();
});


app.controller('CatalogRefreshController', function($scope, $rootScope, DataikuAPI, CachedAPICalls, $sce,
                                                    CatalogItemService, ActivityIndicator, ExposedObjectsService, FLOW_COMPUTABLE_TYPES) {
    $scope.$watch("formatted_items", function() {
        if ($scope.formatted_items && $scope.selected && $scope.selected.item) {
            for (let i = 0; i < $scope.formatted_items.length; i++) {
                if ($scope.formatted_items[i]._id == $scope.selected.item._id) {
                    $scope.selected.index = i;
                    $scope.selected.item = $scope.formatted_items[i];
                    return;
                }
            }
            $scope.selected.index = null;
            $scope.selected.item = null;
        }
    });

    function breakFlowComputableNameIntoParts(name) {
        const parts = name.split('.');
        if (parts.length === 1) return {name: name};
        return {
            projectKey: parts[0],
            name: parts.slice(1).join(''),
            fullName: name
        };
    }

    function reformatNames(flowComputables) {
        if (!flowComputables) return [];
        return flowComputables.map(e => Object.assign(e, breakFlowComputableNameIntoParts(e['name'])));
    }

    function highlightedColumnList(item, columns) {
        const highlightedColumns = [];
        let strippedCols = [];
        if (item.highlight && item.highlight['column']) {
            strippedCols = item.highlight['column'].map(str => str.replace(/<\/?em>/g, ''));
        }
        angular.forEach(columns, function(column) {
            const index = strippedCols.indexOf(column.name);
            if (index === -1) {
                highlightedColumns.push(column);
            } else {
                highlightedColumns.push({
                    name: item.highlight['column'][index],
                    type: column.type
                });
            }
        });

        return highlightedColumns;
    }

    $scope.$watch("selected.item", function(nv, ov) {
        if (!$scope.selected || !$scope.selected.item) return;
        const item = $scope.selected.item;

        const related = nv._source.rawRelatedItems;
        if (related) {
            nv.related = {projects:[],datasets:[],recipes:[]};
            related.projects.forEach(p => {
                nv.related.projects.push({key:p.key, name: p.name});
                p.datasets.forEach(d => {
                    nv.related.datasets.push($.extend({}, {projectKey: p.key}, d));
                    d.recipes.forEach(r => {
                        nv.related.recipes.push($.extend({}, {projectKey: p.key}, r));
                    });
                });
            });
        }

        if (item._type === 'insight') {
            $scope.insightData = null;
            DataikuAPI.dashboards.insights.get(item._source.projectKey, item._source.id)
                .success(function(response) {})
                .error(setErrorInScope.bind($scope));
        }

        else if (item._type === 'dataset') {
            item.splitOutputs = reformatNames(item._source.recursiveOutputs);
            item.splitOutputsByType = {};
            item.splitInputsByType = {};
            const obt = item.splitOutputsByType;
            const ibt = item.splitInputsByType;
            reformatNames(item._source.recursiveOutputs).forEach(out => {
                if (!obt[out.type]) {
                    obt[out.type] = [];
                }
                obt[out.type].push(out);
            });
            reformatNames(item._source.recursiveInputs).forEach(out => {
                if (!ibt[out.type]) {
                    ibt[out.type] = [];
                }
                ibt[out.type].push(out);
            });
        }

        else if (item._type === 'recipe') {
            item.splitOutputs = reformatNames(item._source.outputs);
            item.splitInputs = reformatNames(item._source.inputs);
        }

        $scope.navigatorFn = CatalogItemService.hasNavigator(item._type) ? CatalogItemService.openNavigator(item._type, item._source) : false;
        item.highlightedColumns = highlightedColumnList(item, item._source.columns);
        item.highlightedPartitionColumns = highlightedColumnList(item, item._source.partitioning);

        const exposable = FLOW_COMPUTABLE_TYPES.includes(item._type.toUpperCase());
        const targetProjectDefined = !!$scope.projectKey;
        const selectedItemSource = item._source;

        const exposeObjectToTargetProjectFn = () => {
            DataikuAPI.projects
                .addExposedObject(selectedItemSource.projectKey, item._type.toUpperCase(), selectedItemSource.id, $scope.projectKey)
                .success((data) => {
                    const linkMessage = `View ${selectedItemSource.name} in flow`;
                    const message = `${data.title} <a href='${CatalogItemService.getFlowLink(item._type, selectedItemSource, $scope.projectKey)}'> ${linkMessage}</a>.`;
                    if (data.severity === 'SUCCESS') {
                        ActivityIndicator.success(message, 5000);
                    } else {
                        ActivityIndicator.info(message, 5000);
                    }
                })
                .error(setErrorInScope.bind($scope.getCatalogScope()));
        };
        const exposeObjectToProjectsFn = //
            () => ExposedObjectsService.exposeSingleObject(item._type.toUpperCase(), selectedItemSource.id, selectedItemSource.name, selectedItemSource.projectKey);


        $scope.exposeObjectFn = null;
        $scope.exposeLabel = null;
        $scope.exposeDisabled = null;
        if (exposable) {
            if (targetProjectDefined) {
                $scope.exposeObjectFn = exposeObjectToTargetProjectFn;
                if ($scope.projectKey === selectedItemSource.projectKey) {
                    $scope.exposeLabel = 'Target project must be different from source';
                    $scope.exposeDisabled = true;
                } else if (selectedItemSource.usedIn && selectedItemSource.usedIn.includes($scope.projectKey)) {
                    $scope.exposeLabel = 'Object already exposed';
                    $scope.exposeDisabled = true;
                } else {
                    $scope.exposeLabel = 'Expose in ' + $scope.projectKey;
                    $scope.exposeDisabled = false;
                }
            } else {
                $scope.exposeObjectFn = exposeObjectToProjectsFn;
                $scope.exposeLabel = 'Expose';
                $scope.exposeDisabled = false;
            }
        }
    });

    $scope.$watch("selected.item.highlight.description[0]", function(nv, ov) {
        if (!nv) return;
        let description = nv.replace(/<em>/g, "((STARTEM))").replace(/<\/em>/g, "((ENDEM))");
        CachedAPICalls.emojisTable.then(function(emojisTable) {
            marked.setOptions({
                emoji: function(emoji) {
                    return emoji in emojisTable ? emojisTable[emoji] : (':' + emoji + ':');
                }
            });
            description = marked(description);
            $scope.selected.item.$highlightedDescription = description.replace(/\(\(STARTEM\)\)/g, '<em class="highlight">').replace(/\(\(ENDEM\)\)/g, "</em>");
        });
    });

    $scope.$watch("selected.item.highlight.shortDesc[0]", function(nv, ov) {
        if (!nv) return;
        let shortDesc = nv.replace(/<em>/g, "((STARTEM))").replace(/<\/em>/g, "((ENDEM))");
        CachedAPICalls.emojisTable.then(function(emojisTable) {
            marked.setOptions({
                emoji: function(emoji) {
                    return emoji in emojisTable ? emojisTable[emoji] : (':' + emoji + ':');
                }
            });
            shortDesc = marked(shortDesc);
            $scope.selected.item.$highlightedShortDesc = shortDesc.replace(/\(\(STARTEM\)\)/g, '<em class="highlight">').replace(/\(\(ENDEM\)\)/g, "</em>");
        });
    });
});


app.directive('itemHighlight', function() {
    return {
        scope: {
            highlights: '=itemHighlight',//item.highlight.hasOwnProperty('projects') // item['projects']
            label: '@',
            plural: '@'
        },
        template: "<p ng-if=\"highlights\" >\n    <span>{{label | plurify : highlights.length : plural}}:</span>\n    <span ng-if=\"highlights.length > 4\">\n        <span>{{highlights.length}} matching</span>\n    </span>\n    <span ng-if=\"highlights.length < 5\" ng-repeat=\"highlight in highlights track by $index\">\n        <span ng-bind-html=\"highlight\"></span>\n        <span class=\"separator\" ng-show=\"!$last\"> • </span>\n    </span>\n</p>\n            "
    };
});


})();

(function() {
'use strict';

const app = angular.module('dataiku.catalog');


app.controller('CatalogMeaningsController', function($scope, $controller, TopNav, DataikuAPI, Dialogs, CreateModalFromTemplate, UDM_TYPES) {

    $controller("_CatalogControllerBase", {
        $scope : $scope,
        searchEndpoint : DataikuAPI.catalog.searchMeanings
    });

    $controller("_MeaningsCatalogSupportController", {$scope});


    $scope.meaningsPage = true;
    $scope.udmTypes = UDM_TYPES;

    $scope.editUDM = function(item) {
        CreateModalFromTemplate("/templates/meanings/edit-udm.html", $scope, null, function(newScope) {
            newScope.initModal(item._source.id, $scope.search);
        })
    };
    $scope.goToItem = $scope.editUDM; // For compatibility with generic catalog stuff

    $scope.deleteUDM = function(item) {
        DataikuAPI.meanings.prepareDeleteUDM(item._id)
            .success(function(data) {
                Dialogs.confirmInfoMessages($scope, 'Delete meaning', data, 'Are you sure you want to delete this meaning?', false)
                    .then(function() {
                        DataikuAPI.meanings.deleteUDM(item._id)
                            .success($scope.search)
                            .error(setErrorInScope.bind($scope));
                    });
            })
            .error(setErrorInScope.bind($scope));
    };

    $scope.createUDM = function(item) {
        CreateModalFromTemplate("/templates/meanings/edit-udm.html", $scope, null, function(newScope) {
            newScope.initModal(null, $scope.search);
        })
    };

});


// Required stuff for catalog based UI compatibility
app.controller('_MeaningsCatalogSupportController', function($scope, $filter, UDM_TYPES) {

    $scope.hasNavigator = item => false;

    $scope.itemToIcon = item =>'icon-dku-meanings';

    $scope.getLink = input => null;

    $scope.itemCount = function() {
        const hits = $scope.results && $scope.results.hits ? $scope.results.hits.total : 0;
        return '<strong>' + hits + '</strong> meaning' + (hits > 1 ? 's' : '');
    };

    $scope.selectInput = function() {
        $(".catalog-search-input").select();
    };

    const NICE_FACET_FIELDS = {
        "udm_type": "Type"
    };

    $scope.formatFacetField = function(field) {
        return NICE_FACET_FIELDS[field] || $filter('capitalize')(field);
    };

    $scope.formatFacetValue = function(value, facet) {
        switch (facet) {
            case 'udm_type':    return UDM_TYPES[value]; break;
            default:            return value;
        }
    };

    $scope.formatItemName = function(item, inList) {
        if (item.highlight && item.highlight.label && item.highlight.label.length) {
            return item.highlight.label[0];
        }
        // Comes from _source, encode HTML entities in order to display attributes like <stuff
        return $filter('encodeHTML')(item._source.label);
    };

    $scope.sortBy = [
        {label: 'Relevance', value: '_score' },
        {label: 'Type', value: i => i._source.udm_type },
        {label: 'Number of uses', value: i => (i.inner_hits.column.hits.hits || []).length }
    ];
});


app.controller("MeaningRightColumnController", function($scope, UDM_TYPES) {
    $scope.udmTypes = UDM_TYPES;
    $scope.highlightedDescription = function() {
        if ($scope.selected.item.highlight && $scope.selected.item.highlight.description) {
            let description = $scope.selected.item.highlight.description[0].replace(/<em>/g, "((STARTEM))").replace(/<\/em>/g, "((ENDEM))");
            description = marked(description);
            description = description.replace(/\(\(STARTEM\)\)/g, '<em class="highlight">').replace(/\(\(ENDEM\)\)/g, "</em>");
            return description;
        }
        return marked($scope.selected.item._source.description);
    };
});

})();
(function () {
'use strict';

    const app = angular.module('dataiku.catalog');


    app.controller('ExternalTableController', function ($scope,$rootScope, $injector, $stateParams, $route, DataikuAPI, $location,
                                                        $compile, $state, $q, CreateModalFromTemplate, $filter, WT1, $timeout, TopNav, DatasetsService,
                                                        $controller, StateUtils, Debounce, CatalogUtils, Navigator, DashboardUtils, ActivityIndicator,TaggingService) {
        $scope.query = {columnFilter: ""};
        $rootScope.activeProjectTagColor = TaggingService.getTagColor;

        function emptyToNull(string) {
            return string && string.length ? string : null;
        }

        $scope.tableKey = {
            connection: emptyToNull($stateParams.connection),
            catalog: emptyToNull($stateParams.catalog),
            schema: emptyToNull($stateParams.schema),
            table: emptyToNull($stateParams.table)
        };
        $scope.tableKeyJson = JSON.stringify($scope.tableKey);

        $scope.$watch('query.columnFilter',
            Debounce().withDelay(10, 200).withScope($scope).wrap(function (nv) {
                if ($scope.summary) {
                    $scope.columnFiltered = $filter('filter')($scope.summary.table.columns, nv);
                }
            }));

        $scope.selectColumn = function (column) {
            if ($scope.selectedColumn) {
                $scope.selectedColumn.selected = false;
            }
            $scope.selectedColumn = column;
            $scope.selectedColumn.selected = true;
        };
        $scope.import = function () {
            CreateModalFromTemplate("/templates/datasets/tables-import-project-selection-modal.html", $scope, "TablesImportProjectSelectionModalController");
        };
        $scope.getImportData = function(){
            return {
                workflowType : "KEYS",
                tableKeys : [$scope.summary.table.key]
            };
        }

        $scope.$on("objectSummaryEdited", function () {
            DataikuAPI.externalTable.save($scope.tableKey, {description: $scope.summary.table.description, tags : $scope.summary.table.tags}).success(function (data) {
                ActivityIndicator.success("Saved!");
                refreshSummary();
            }).error(setErrorInScope.bind($scope));
        });

        $scope.reloadSample = function () {
            DataikuAPI.externalTable.sample($scope.tableKey).success(data => {
                $scope.sample = data;
                $scope.sampleColumnsWidths = Array.from(Array($scope.sample.columns.length).fill(0));
                $scope.sample.rows.forEach((r, rownum) => {
                    r.forEach((e, i) => {
                        let l = Math.max($scope.sample.columns[i].name.length, e && e.length || 0)*8+10;
                        $scope.sampleColumnsWidths[i] = Math.max($scope.sampleColumnsWidths[i], l);
                    });
                    return r;
                });
                $scope.sampleColumnsWidths = $scope.sampleColumnsWidths.map(e => e);
                $scope.schema = {
                    "schema": $scope.sample.querySchema
                };
            }).error(setErrorInScope.bind($scope));
        };

        function refreshSummary() {
            DataikuAPI.externalTable.summary($scope.tableKey).success(function (data) {
                $scope.summary = data;
                $scope.object = $scope.summary.table;
                $scope.dataSchema = $scope.summary.table.columns;
                $scope.columnFiltered = $scope.summary.table.columns;

                $scope.grouppedDSSItems = [];
                if ($scope.summary.dssItems) {
                    $scope.summary.dssItems.projects.forEach(function (project) {
                        project.datasets.forEach(function (dataset) {
                            $scope.grouppedDSSItems.push({dataset: dataset, project: project, recipes: dataset.recipes})
                        })
                    });
                }
            }).error(setErrorInScope.bind($scope));
        }

        TaggingService.fetchGlobalTags();
        TopNav.setLocation(TopNav.DSS_HOME, "catalog");
        refreshSummary();
    });


    app.directive('externalTableSummary', function (_SummaryHelper) {
        return {
            link: function ($scope, element, attrs) {
                _SummaryHelper.addEditBehaviour($scope, element);
            },
            templateUrl: '/templates/catalog/external-table/summary.html'
        };
    });
})();
(function() {
'use strict';


const app = angular.module('dataiku.catalog');


const FACET_FIELDS_DISPLAY_NAMES = Object.freeze({
    'projectName': 'Project',
    'type_raw': 'Type',
    'numColumns': 'Columns',
    'usedIn': 'Used in',
    'user': 'Contributors',
    'storedAs': 'Stored as',
    'projectKey.raw': 'Project',
    'tag.raw': 'Tags',
    'catalog.raw': 'Database Catalog',
    'connection.raw': 'Connection',
    'schema.raw': 'Schema',
    'objectType': 'Object type',
    'closed': 'Status'
});


app.controller('DiscussionsInboxController', function($controller, $scope, $rootScope, DataikuAPI, TopNav, Notification) {

    function searchWrapper(...args) {
        return DataikuAPI.discussions.inbox.search.apply(this, args)
            .success(function(data) {
                $scope.unreadDiscussionFullIds = data.unreadDiscussionFullIds || [];
            }); // No need for error handling here, done in _CatalogControllerBase
    }
    $controller("_CatalogControllerBase", {$scope: $scope, searchEndpoint: searchWrapper});
    $controller('_InboxCatalogSupportController', {$scope});

    TopNav.setLocation(TopNav.DSS_HOME, "inbox", "items", null);

    $scope.inboxPage = true;

    const projectNames = {};
    $scope.users = {};
    $scope.tagMaps = {};
    $scope.unreadDiscussionFullIds = [];

    $scope.query.facets.closed = [0]; // By default, only show open discussions

    $scope.unread = function(item) {
        const fullId = item._source.projectKey+'.'+item._source.discussionId;
        return $scope.unreadDiscussionFullIds.includes(fullId);
    };

    DataikuAPI.taggableObjects.listAllTags()
        .success(function(data) {
            $scope.tagMaps = data;
        })
        .error(setErrorInScope.bind($scope));

    DataikuAPI.security.listUsers()
        .success(function(data) {
            angular.forEach(data, user => $scope.users[user.login] = user.displayName);
        })
        .error(setErrorInScope.bind($scope));

    DataikuAPI.projects.list()
        .success(function(data) {
            angular.forEach(data, project =>projectNames[project.projectKey] = project.name);
        })
        .error(setErrorInScope.bind($scope));

    const ackListenerDestroyer = Notification.registerEvent('discussion-ack', function(evtType, message) {
        if (message.user != $rootScope.appConfig.login) {
            return; // Only ack current user stuff
        }
        const index = $scope.unreadDiscussionFullIds.indexOf(message.projectKey + '.' + message.discussionId);
        if (index > -1) {
            $scope.unreadDiscussionFullIds.splice(index, 1);
        }
    });
    const replyListenerDestroyer = Notification.registerEvent('discussion-reply', function(evtType, message) {
        if (message.user == $rootScope.appConfig.login) {
            return; // Don't mark current user's messages as unread
        }
        const index = $scope.unreadDiscussionFullIds.indexOf(message.projectKey + '.' + message.discussionId);
        if (index == -1) {
            $scope.unreadDiscussionFullIds.push(message.projectKey + '.' + message.discussionId);
        }
    });

    $scope.$on('$destroy', function() {
        ackListenerDestroyer();
        replyListenerDestroyer();
    });
});


// Required stuff for catalog based UI compatibility
app.controller('_InboxCatalogSupportController', function($scope, $location, StateUtils, $filter) {
    $scope.hasNavigator = item => false;

    $scope.itemToIcon = item => 'icon-comments';

    $scope.isItemSelectable = item => false;

    $scope.getLink = function(item) {
        const src = item._source;
        const tor = {
            type: src.objectType.toUpperCase(),
            id: src.objectId,
            projectKey: src.projectKey
        };
        return StateUtils.href.taggableObject(tor, {discussionId: src.discussionId});
    };

    $scope.goToItem = function(item) {
        $location.path($scope.getLink(item));
    };

    $scope.sortBy = [
        {
            label: 'Last reply',
            value: item => item._source.lastReplyTime
        },
        {
            label: 'Read',
            value: item => $scope.unread(item)
        }
    ];
    $scope.sortOptions = {
        column: $scope.sortBy[0].value,
        reverse: true
    };

    $scope.formatFacetField = function(field) {
        return FACET_FIELDS_DISPLAY_NAMES[field] || $filter('capitalize')(field);
    };

    $scope.formatFacetValue = function(value, facet) {
        if (facet == 'closed') {
            return value ? 'Resolved discussions' : 'Opened discussions';
        }
        return value;
    };

    $scope.formatItemName = function(item, inList) {
        const src = item._source;
        // Comes from _source, encode HTML entities in order to display attributes like <stuff
        const topic = (item.highlight && item.highlight['discussions.topic']) ? item.highlight['discussions.topic'][0] : ($filter('escapeHtml')(((src.discussions && src.discussions.length && src.discussions[0].topic) ? src.discussions[0].topic : "Unnamed discussion")));
        const title = topic + " <small>on " + src.objectType.replace('_', ' ') + "</small> " + $filter('escapeHtml')(src.objectName);
        return title;
    };

    $scope.itemCount = function() {
        const hits = $scope.results && $scope.results.hits ? $scope.results.hits.total : 0;
        return '<strong>' + hits + '</strong> discussion' + (hits > 1 ? 's' : '');
    };

    $scope.selectInput = function() {
        $(".catalog-search-input").select();
    };
});

})();

(function() {
    'use strict';
    
    const app = angular.module('dataiku.deployer', []);

    app.controller('DeployerHomeController', function($scope, $rootScope, TopNav, DataikuAPI) {
        TopNav.setNoItem();
        TopNav.setLocation(TopNav.TOP_DEPLOYER, '');
        const MAX_STAGE_COUNT = 5;

        function stageCounts(deployments, stages) {
            stages = stages.slice(0, MAX_STAGE_COUNT);
            const counts = stages.reduce((obj, stage) => ({ ...obj, [stage.id]: 0 }), {})

            deployments.forEach(deployment => {
                let stageId = deployment.infraBasicInfo.stage;
                if (!stages.find(stage => stage.id === stageId)) {
                    stageId = "__OTHERS__";
                }
                if (!(stageId in counts)) {
                    counts[stageId] = 0;
                }
                counts[stageId]++;
            });

            return counts;
        }

        DataikuAPI.projectdeployer.deployments.listLightStatus().success(function(deployments) {
            if (deployments.length) {
                $scope.projectStageCounts = stageCounts(deployments, $rootScope.appConfig.projectDeploymentStages);
            }
        });

        DataikuAPI.apideployer.deployments.listLightStatus().success(function(deployments) {
            if (deployments.length) {
                $scope.apiStageCounts = stageCounts(deployments, $rootScope.appConfig.apiDeploymentStages);
            }
        });
    });

    app.controller('_DeployerBaseController', function($scope, TaggingService) {
        TaggingService.fetchGlobalTags();
    });

    app.service('DeployerUtils', function(APIDeployerDeploymentUtils) {
        const svc = this;

        svc.DEPLOY_SOURCE = {
            PACKAGE_PANEL: 'PACKAGE_PANEL',
            PACKAGE: 'PACKAGE'
        };
        
        svc.hasUrlSuffix = function(url) {
            const pat = /https?:\/\/[^\/]+(\/+[^\/].*)/; // the fields in the UI enforce http[s] so we do the same here
            return pat.test(url);
        };

        svc.enabledDeploymentCount = function(deployments, enabled) {
            return deployments.filter(depl => depl.enabled === !!enabled).length;
        };

        svc.stageDetails = function(stages, stageId) {
            const foundStage = stages.find(s => s.id == stageId);
            return stageId + ' - ' + (foundStage ? foundStage.desc : 'Unknown stage');
        };

        /*
            allStages: list of all available stages
            displayedStages: list of stages to display
            packageType: bundle or version

            About "others" in packageInfo: 
            - Contains deployments with infras that have no longer existing stage names (__OTHERS__, aka Unknown stages)
            - Contains deployments with infras that are in allStages but not displayedStages

            When displaying stage counts, both these cases fall under __OTHERS__, but only truly unknown stages
            deployments are stored in packageInfo.perStage['__OTHERS__'].deployments.
        */
        svc.getDeploymentsPerPackageAndStage = function(publishedItemStatus, allStages, displayedStages, packageType) {
            const ret = {};
            const infraStagesById = svc.getInfraStagesById(publishedItemStatus, allStages);
            displayedStages = displayedStages || allStages;

            // If displayedStages has an OTHERS stage, add one to allStages as well
            if (displayedStages.some(stage => stage.id === '__OTHERS__')) {
                allStages = svc.addOthersStage(allStages);
            }

            (publishedItemStatus.packages || []).forEach(function(pkg) {
                ret[pkg.id] = {
                    count: 0,
                    perStage: allStages.reduce((obj, stage, idx) => ({
                        ...obj,
                        [stage.id]: {idx: idx, deployments: []}
                    }), {})
                };
            });

            (publishedItemStatus.deployments || []).forEach(function(deploymentBasicInfo) {
                if (packageType === 'bundle') {
                    addCounts(ret, deploymentBasicInfo.bundleId, deploymentBasicInfo);
                } else {
                    const participatingVersions = APIDeployerDeploymentUtils.getParticipatingVersions(deploymentBasicInfo);
                    participatingVersions.forEach(function(version) {
                        addCounts(ret, version, deploymentBasicInfo);
                    });
                }
            });

            return ret;

            function addCounts(item, packageId, deploymentBasicInfo) {
                const packageInfo = item[packageId];

                if (!packageInfo) return;

                const stageId = infraStagesById[deploymentBasicInfo.infraId];
                const isOtherStage = !displayedStages.some(stage => stage.id === stageId) || stageId === '__OTHERS__';

                packageInfo.count++;
                
                // included in the count of other stages
                if (isOtherStage) {
                    packageInfo.others = packageInfo.others || { 
                        stageCounts: {},
                        deployments: [] 
                    };

                    addStage(stageId, packageInfo.others.stageCounts);
                    packageInfo.others.deployments.push(deploymentBasicInfo);
                }
                
                /*
                    Add deployment to corresponding stage, even if it was added to the "others" deployment list. This is because there are pages where we show both a truncated list of stages and a list of all stages (e.g., bundle status page).
                */
                packageInfo.perStage[stageId].deployments.push(deploymentBasicInfo);
            }
        };

        /*
            Returns a map of deployment counts for a published item (project or service)
        */
        svc.getDeploymentCountsPerPublishedItemAndStage = function(publishedItemStatus, allStages, displayedStages) {
            const infraStagesById = svc.getInfraStagesById(publishedItemStatus, allStages);
            displayedStages = displayedStages || allStages;

            // include others stage for counting if displayedStages has them
            if (displayedStages.some(stage => stage.id === '__OTHERS__')) {
                allStages = svc.addOthersStage(allStages);
            }

            // deployment counts per project
            const deployments = {
                counts: allStages.reduce((obj, stage) => ({
                    ...obj,
                    [stage.id]: 0
                }), {})
            };
                        
            publishedItemStatus.deployments.forEach(deployment => {
                const originalStageId = infraStagesById[deployment.infraId];
                const isOtherStage = !displayedStages.some(stage => stage.id === originalStageId) || originalStageId === '__OTHERS__';
                const newStageId = isOtherStage ? '__OTHERS__' : originalStageId;

                addStage(newStageId, deployments.counts);

                if (isOtherStage) {
                    deployments.others = deployments.others || {};
                    addStage(originalStageId, deployments.others);
                }
            });

            return deployments;
        };

        function addStage(stageId, countObj) {
            countObj[stageId] = countObj[stageId] || 0;
            countObj[stageId]++;
        }

        /*
            Return a map of stages with infraId as key
        */
        svc.getInfraStagesById = function(publishedItemStatus, stages) {
            const infraStagesById = {};

            publishedItemStatus.infras.forEach(function(infra) {
                let stageId = infra.stage;
                // if infraId has a stage that no longer exists, set its stage to __OTHERS__
                infraStagesById[infra.id] = !stages.some(stage => stage.id === stageId) ? '__OTHERS__' : stageId;
            });

            return infraStagesById;
        };

        /*
            Returns an array of stages to show
        */
        svc.getStagesToDisplay = function(publishedItemStatusList, stages, maxStageCount) {
            const infraStagesByIdList = publishedItemStatusList.map(publishedItemStatus => svc.getInfraStagesById(publishedItemStatus, stages));
            const hasUnknownStages = infraStagesByIdList.some(infraStagesById => Object.values(infraStagesById).some(stage => stage === '__OTHERS__'));

            if (hasUnknownStages || maxStageCount < stages.length) {
                stages = svc.addOthersStage(stages.slice(0, maxStageCount));
            }

            return stages;
        };

        /*
            Adds "__OTHERS__" stage to stage list
        */
        svc.addOthersStage = function(stages) {
            stages = angular.copy(stages);
            if (!stages.some(stage => stage.id === '__OTHERS__')) {
                stages.push({
                    id: '__OTHERS__'
                });
            }
            return stages;
        };

        svc.getStageCountColor = function(deployments, heavyStatusByDeploymentId, canBeDisabled) {
            if (!deployments || !deployments.length) {
                return '#ddd';
            }
            if (canBeDisabled && !deployments.find(depl => depl.enabled)) {
                return '#ccc';
            }
            if (deployments.some(depl => ['ERROR', 'UNHEALTHY', 'LOADING_FAILED'].includes((heavyStatusByDeploymentId[depl.id] || {}).health))) {
                return '#ce1329';
            }
            if (deployments.some(depl => ['WARNING', 'UNKNOWN', 'OUT_OF_SYNC'].includes((heavyStatusByDeploymentId[depl.id] || {}).health))) {
                return '#f8931e';
            }
            return '#81c241';
        };

        /*
            isSinglePublishedItem: whether or not check if a specific bundle's project can be deployed
        */
        svc.getCannotDeployReason = function(publishedItemStatusList, infraStatusList, publishedItemType, isSinglePublishedItem = true) {
            if (!publishedItemStatusList || !publishedItemStatusList.length) {
                return `There are no ${publishedItemType}s to deploy`;
            }

            if (!canDeploy(publishedItemStatusList)) {
                return `You do not have permission to deploy ${isSinglePublishedItem ? 'this' : 'any'} ${publishedItemType}`;
            }

            if (!infraStatusList || !infraStatusList.length) {
                return 'There are no infras to deploy on';
            }

            if (!canDeploy(infraStatusList)) {
                return 'You do not have permission to deploy on any infra';
            }

            return ''; // can deploy
        };

        function canDeploy(statusList) {
            return statusList && statusList.some(status => status && status.canDeploy);
        }

        svc.getFailedHeavyStatusLoadMessage = function(errorDetails) {
            return {
                maxSeverity: "ERROR",
                messages: [{
                    details: errorDetails.detailedMessage,
                    message: errorDetails.detailedMessage,
                    severity: "ERROR",
                    title: "Failed loading the deployment status"
                }]
            }
        };
    });

    app.controller('_DeployerPermissionsController', function($scope, DataikuAPI) {
        let initialPermissions;
        let hasOwner;

        function makeNewPerm() {
            $scope.newPerm = angular.copy(initialPermissions);
        }

        function buildUnassignedGroups(item) {
            if (!item || !$scope.allGroups) return;

            $scope.unassignedGroups = $scope.allGroups.filter(function(groupName) {
                return item.permissions.every(perm => perm.group !== groupName);
            });
        }
        function fixupPermissions(item) {
            if (!item) {
                return;
            }
            item.permissions.forEach(function(p) {
                const permissionTypes = Object.keys(initialPermissions);
                permissionTypes.forEach(type => {
                    p[`$${type}Disabled`] = false;
                });
                if (p.admin) {
                    // set all to true
                    permissionTypes.filter(type => type !== 'admin').forEach(type => {
                        p[type] = true;
                        p[`$${type}Disabled`] = true;
                    });
                } else if (p.write || p.deploy) {
                    p.read = true;
                    p.$readDisabled = true;
                }
            });
        }

        function setGroups(item) {
            DataikuAPI.security.listGroups(false).success(function(allGroups) {
                if (allGroups) {
                    allGroups.sort();
                }
                $scope.allGroups = allGroups;

                if (hasOwner) {
                    DataikuAPI.security.listUsers().success(function(data) {
                        $scope.allUsers = data;
                    }).error(setErrorInScope.bind($scope));
                }

                buildUnassignedGroups(item);
            }).error(setErrorInScope.bind($scope));
        }

        $scope.addPermission = function(item) {
            item.permissions.push($scope.newPerm);
            makeNewPerm();
        };


        $scope.onPermissionChange = function(item) {
            buildUnassignedGroups(item);
            fixupPermissions(item);
        }

        $scope.initPermissions = function(item, permissions, showOwner) {
            initialPermissions = permissions;
            hasOwner = showOwner;

            fixupPermissions(item);
            setGroups(item);

            makeNewPerm();
        }
    });
})();

(function() {
    'use strict';
    
    const app = angular.module('dataiku.deployer');
    
    app.controller('_DeployerInfrasListController', function($scope, $controller, $state, TopNav, CreateModalFromTemplate, WT1, $rootScope) {
        $controller('_DeployerBaseController', {$scope});
        
        const navLocation = `TOP_${$scope.deployerType.toUpperCase()}_DEPLOYER`;
        TopNav.setNoItem();
        TopNav.setLocation(TopNav[navLocation], 'infras');
    
        if ($scope.isFeatureLocked) return;

        $scope.uiState = {};
    
        $scope.canCreateInfras = function() {
            return $rootScope.appConfig.admin;
        };
    
        $scope.startCreateInfra = function() {
            CreateModalFromTemplate(`/templates/${$scope.deployerType}-deployer/new-infra-modal.html`, $scope).then(function(newInfra) {
                $state.go(`${$scope.deployerType}deployer.infras.infra.settings`, {infraId: newInfra.id});
                WT1.event(`${$scope.deployerType}-deployer-infra-setup`, {infraType: newInfra.type});
            });
        };
    
        $scope.refreshInfraStatusList = function() {
            $scope.deployerAPIBase.infras.listLightStatus()
                .success(function(infraStatusList) {
                    $scope.infraStatusList = infraStatusList;
                }).error(setErrorInScope.bind($scope));
        };
    
        $scope.refreshInfraStatusList();
    });
    
    app.controller('_DeployerInfraController', function($scope, $state, $controller, Dialogs, ActivityIndicator) {
        $controller('_DeployerBaseController', {$scope: $scope});
        $scope.refreshInfraStatus = function() {
            $scope.deployerAPIBase.infras.getLightStatus($state.params.infraId)
            .success(infraStatus => {
                $scope.infraStatus = infraStatus;
            }).error(setErrorInScope.bind($scope));
        }

        $scope.deleteInfra = function() {
            if (!$scope.infraStatus) {
                return;
            }
            if ($scope.infraStatus.deployments.length) {
                Dialogs.error($scope, 'Delete infra', 'You cannot delete this infra because it still has deployments!');
                return;
            }
            Dialogs.confirm($scope, 'Delete infra','Are you sure you want to delete this infra?').then(function() {
                $scope.deployerAPIBase.infras.delete($scope.infraStatus.infraBasicInfo.id)
                    .success(() => {
                        ActivityIndicator.success(`Infra ${$scope.infraStatus.infraBasicInfo.id} successfully deleted.`)
                        $state.go($scope.deployerType + 'deployer.infras.list');
                    })
                    .error(setErrorInScope.bind($scope));
            });
        };

        $scope.refreshInfraStatus();
    });

    app.controller('_DeployerInfraStatusController', function($scope, TopNav) {
        const navLocation = `TOP_${$scope.deployerType.toUpperCase()}_DEPLOYER`;
        TopNav.setNoItem();
        TopNav.setLocation(TopNav[navLocation], 'infras', null, 'status');
    });

    app.controller('_DeployerInfraSetupModalController', function($scope, DeployerUtils) {
        $scope.newInfra = {
            stage: (($scope.stages || [])[0] || {}).id
        };
        
        $scope.hasUrlSuffix = DeployerUtils.hasUrlSuffix;

        $scope.ok = function() {
            $scope.deployerAPIBase.infras.create($scope.newInfra)
                .success($scope.resolveModal)
                .error(setErrorInScope.bind($scope));
        };
    });

    app.controller('_DeployerInfraHistoryController', function($scope, TopNav) {
        const navLocation = `TOP_${$scope.deployerType.toUpperCase()}_DEPLOYER`;
        TopNav.setNoItem();
        TopNav.setLocation(TopNav[navLocation], 'infras', null, 'history');
    });

    app.controller('_DeployerInfraSettingsController', function($scope, $controller, $state, TopNav, ActivityIndicator, DeployerUtils) {
        const navLocation = `TOP_${$scope.deployerType.toUpperCase()}_DEPLOYER`;
        TopNav.setNoItem();
        TopNav.setLocation(TopNav[navLocation], 'infras', null, 'settings');

        $scope.uiState = {
            settingsPane: 'general'
        };

        $scope.hasUrlSuffix = DeployerUtils.hasUrlSuffix;

        $scope.invalidTabs = new Set();
        $scope.$watch("uiState.settingsPane", function(nv, ov) {
            if (nv === ov) return;
            if ($scope.infraSettingsForm.$invalid) {
                $scope.invalidTabs.add(ov);
            }
            $scope.invalidTabs.delete(nv);
        });

        let savedInfra; // for dirtyness detection
        function refreshInfra() {
            $scope.deployerAPIBase.infras.getSettings($state.params.infraId)
                .success(infra => {
                    $scope.infra = infra;
                    savedInfra = angular.copy(infra);
                })
                .error(setErrorInScope.bind($scope));
        };

        $scope.infraIsDirty = function() {
            return !angular.equals(savedInfra, $scope.infra);
        };

        $scope.isInfraSettingsFormInvalid = function() {
            return $scope.infraSettingsForm.$invalid || $scope.invalidTabs.size;
        }

        $scope.saveInfra = function() {
            if (!$scope.infra) return;

            $scope.deployerAPIBase.infras.save($scope.infra)
                .success(function() {
                    if ($scope.isInfraSettingsFormInvalid()) {
                        ActivityIndicator.warning("Saved with some invalid fields");
                    }
                    refreshInfra();
                    $scope.refreshInfraStatus();
                }).error(setErrorInScope.bind($scope));
        };

        /********* Permissions *********/
        $controller('_DeployerPermissionsController', {$scope: $scope});

        // don't initialize until obj is available or else timing issues can occur
        const deregister = $scope.$watch("infra", function(nv, ov) {
            if (!nv) return;

            $scope.initPermissions($scope.infra, {
                deploy: true,
                admin: false,
                read: false
            }, false);

            deregister();
        }, false);

        $scope.$watch("infra.permissions", function(nv, ov) {
            if (!nv) return;
            $scope.onPermissionChange($scope.infra);
        }, true);

        $scope.$watch("infra.permissions", function(nv, ov) {
            if (!nv) return;
            $scope.onPermissionChange($scope.infra);
        }, false);

        refreshInfra();
        checkChangesBeforeLeaving($scope, $scope.infraIsDirty);
    });
})();
(function() {
    'use strict';
    
    const app = angular.module('dataiku.deployer');
    
    app.controller('_DeployerUploadPackageController', function($scope, $timeout) {
        $scope.uiState = $scope.uiState || {};
        $scope.uiState.files = [];
        $scope.uiState.fileProperties = [];

        $scope.drop = function(files) {
            angular.forEach(files, function(file) {
                $scope.uiState.files.push(file);
                $scope.uiState.fileProperties.push({
                    path: file.name,
                    length: file.size
                });
            });
        };

        $scope.deleteFile = function(idx, e) {
            e.preventDefault();
            e.stopPropagation();
            $scope.uiState.files.splice(idx, 1);
            $scope.uiState.fileProperties.splice(idx, 1);
        };

        $scope.uploadFilesAfterDigest = function(files) {
            $timeout(function() {
                uploadFiles(files)
            });
        };

        function uploadFiles(files) {
            files.forEach((file, idx) => uploadOneFile(file, idx));
        }

        function uploadOneFile(fileToUpload, idx) {
            const file = {
                name: fileToUpload.name,
                size: fileToUpload.size,
                lastModified: fileToUpload.lastModified,
                progress: 0
            };

            $scope.publishPackage(fileToUpload, function(e) {
                if (e.lengthComputable) {
                    $scope.$apply(function() {
                        file.progress = Math.round(e.loaded * 100 / e.total);
                    });
                }
            }).then(
                function(response) {
                    $scope.uiState.fileProperties[idx].uploaded = true;
                    if ($scope.afterUploadCallback) {
                        $scope.afterUploadCallback(response);
                    }
                },
                function(payload) {
                    setErrorInScope.call($scope,
                        JSON.parse(payload.response || '{}'), payload.status, h => payload.getResponseHeader(h)
                    );
                }
            );
        }
    });
    
    app.service('DeployerPublishedItemsService', function($rootScope, $q, Dialogs) {
        const svc = this;

        svc.DEPLOYMENT_METHOD_ID = {
            'NEW': 'NEW',
            'UPDATE': 'UPDATE'
        }
    
        svc.deployPackage = function(publishedItemStatus, packageType) {
            const deferred = $q.defer();
            const deploymentMethods = getDeploymentMethods(packageType);

            if (!publishedItemStatus.deployments.length) {
                return $q.resolve(svc.DEPLOYMENT_METHOD_ID.NEW);
            } else {
                Dialogs.select($rootScope, `Deploy ${packageType}`, `Choose how to deploy this ${packageType}`, deploymentMethods, deploymentMethods[1])
                    .then(function(item) {
                        deferred.resolve(item.id);
                });
                return deferred.promise;
            }
        };
    
        svc.openDeploymentSelector = function(publishedItemStatus, includeInfraType) {
            const infraTypeMap = includeInfraType ? publishedItemStatus.infras.reduce((obj, infra) => ({ 
                ...obj,
                [infra.id]: infra.type
            }), {}) : {};
            const deployments = publishedItemStatus.deployments.map(depl => {
                const type = infraTypeMap[depl.infraId];
                return {
                    id: depl.id,
                    title: depl.id,
                    ...type && { type },
                    desc: `Infra: ${depl.infraId} ${type ? ` (${type})` : ''}`
                };
            });
            return Dialogs.select($rootScope, 'Choose the deployment', 'Choose which deployment you want to edit', deployments, deployments[0]);
        };

        function getDeploymentMethods(packageType) {
            return [
                {
                    id: svc.DEPLOYMENT_METHOD_ID.NEW,
                    title: 'Create',
                    desc: `Create a new deployment based on this ${packageType}`
                },
                {
                    id: svc.DEPLOYMENT_METHOD_ID.UPDATE,
                    title: 'Update',
                    desc: `Change the ${packageType} used in an existing deployment`
                }
            ]
        }
    });

})();
    
(function() {
    'use strict';
    
    const app = angular.module('dataiku.deployer');

    app.filter('deploymentHealthToIcon', function() {
        const dict = {
            HEALTHY: 'icon-dku-success text-success',
            WARNING: 'icon-dku-warning text-warning',
            OUT_OF_SYNC: 'icon-dku-out-of-sync text-warning',
            UNHEALTHY: 'icon-dku-error text-error',
            ERROR: 'icon-dku-error text-error',
            UNKNOWN: 'icon-dku-help text-warning',

            LOADING: 'dku-loader icon-spin',
            DISABLED: 'icon-dku-pause',
            LOADING_FAILED: 'icon-dku-help text-error'
        };
        return function(health) {
            if (!health) {
                return dict.LOADING;
            }
            return dict[health] || '';
        };
    });

    app.filter('healthStatusToFriendly', function() {
        return function(healthStatus) {
            return healthStatus.charAt(0).toUpperCase() + healthStatus.substr(1).toLowerCase().replaceAll('_', ' ');
        };
    });

    app.service('DeployerDeploymentTileService', function($filter) {
        const deploymentHeavyStatusToHealthMessage = function(heavyStatus) {
            const displayedHealth = $filter('healthStatusToFriendly')(heavyStatus.health);
            if (heavyStatus.health === "HEALTHY") {
            // there still might be info messages in this case (appearing in the status page)
            // we do not want to startle the user by having them appear in the tooltip however
                return displayedHealth;
            }
            return displayedHealth + ' - ' + heavyStatus.healthMessages.messages.find(msg => msg.severity == heavyStatus.healthMessages.maxSeverity).message;
        }
        return {
            getDeploymentHealth: function(heavyStatus, isDisabled) {
                if (isDisabled) { // API deployments only
                    return {
                        currentState: "DISABLED",
                        message: "Deployment disabled"
                    };
                }
                if (!heavyStatus) {
                   return {
                       currentState: "LOADING"
                   };
                }
                return {
                    currentState: heavyStatus.health,
                    message: deploymentHeavyStatusToHealthMessage(heavyStatus)
                };
            },
            getDeploymentHealthMap: function(deployments, heavyStatusMap) {
                if (!deployments || !heavyStatusMap) return;

                const healthMap = {};

                deployments.forEach(deployment => {
                    healthMap[deployment.id] = this.getDeploymentHealth(heavyStatusMap[deployment.id], deployment.type === 'API_SERVICE' ? !deployment.enabled : false);
                });

                return healthMap;
            }
        }
    });

    app.controller('_DeployerDeploymentDashboardController', function($scope, $controller, $filter, TopNav, TaggingService) {
        $controller('_DeployerBaseController', {$scope});
        const navLocation = `TOP_${$scope.deployerType.toUpperCase()}_DEPLOYER`;
        TopNav.setNoItem();
        TopNav.setLocation(TopNav[navLocation], 'deployments');

        if ($scope.isFeatureLocked) return;

        $scope.uiState = $scope.uiState || {};
        $scope.uiState.query = {q: '', tags: []};
        $scope.uiState.query[`${$scope.publishedItemType}s`] = [];

        $scope.orderByExpression = [];

        $scope.rowHeaderHeight = 45;

        $scope.deployerAPIBase.deployments.listTags()
            .success(tags => { TaggingService.setProjectTags(TaggingService.fillTagsMapFromArray(tags)); })
            .error(setErrorInScope.bind($scope));

        $scope.deployerHasPublishedPackages = function(itemList) {
            return (itemList || []).some(item => !!item.packages.length);
        };

        $scope.displayedStages = angular.copy($scope.stages);

        const getDeploymentsPerStage = function(lightStatusList) {
            const deploymentsPerStage = $scope.displayedStages.reduce((obj, stage) => ({ ...obj, [stage.id]: [] }), {});
            lightStatusList.forEach(function(lightStatus) {
                let stageId = lightStatus.infraBasicInfo.stage;
                if (!$scope.displayedStages.find(stage => stage.id === stageId)) {
                    stageId = "__OTHERS__";
                }
                if (!(stageId in deploymentsPerStage)) {
                    deploymentsPerStage[stageId] = [];
                    $scope.displayedStages.push({id: stageId});
                }
                deploymentsPerStage[stageId].push(lightStatus);
            });
            return deploymentsPerStage;
        };

        $scope.refreshForFilter = function(filteredDeploymentStatusList) {
            $scope.deploymentsPerStage = getDeploymentsPerStage(filteredDeploymentStatusList);
            $scope.deploymentsByRow = [];
            $scope.deploymentHeaders = $scope.deploymentHeaders || Object.keys($scope.deploymentsPerStage);
            $scope.columnWidths =  $scope.columnWidths || $scope.deploymentHeaders.map(_ => 330);   
            const rowCount = Math.max.apply(null, Object.values($scope.deploymentsPerStage).map(d => d.length));
            
            if (rowCount > 0) {
                for (let row = 0; row < rowCount; row++) {
                    const rowData = [];
                    for (let stage in $scope.deploymentsPerStage) {
                        rowData.push(($scope.deploymentsPerStage[stage] || [])[row]);
                    }
                    $scope.deploymentsByRow.push(rowData);
                }
            }
        };

        function filterDeployments() {
            const filteredDeploymentStatusList = $filter('orderBy')(
                $scope.deploymentsStatusList.filter(lightStatus => $scope.deploymentIsInUI(lightStatus)), $scope.orderByExpression
            );
            $scope.refreshForFilter(filteredDeploymentStatusList);
        }

        $scope.selectAndFilterDeployments = function(item) {
            item.$selected = !item.$selected;
            filterDeployments();
        };
        
        $scope.$watch('uiState.query', (nv, ov) => {
            if (nv !== ov) {
                filterDeployments();
            }
        }, true);

        $scope.$on('tagSelectedInList', function(e, tag) {
            let index = $scope.uiState.query.tags.indexOf(tag);
            if (index >= 0) {
                $scope.uiState.query.tags.splice(index, 1);
            } else {
                $scope.uiState.query.tags.push(tag);
            }
            e.stopPropagation();
        });

        $scope.refreshAllDeployments = function() {
            $scope.heavyStatusPerDeploymentId = {};
            $scope.globalLightStatusLoaded = false;
            $scope.deployerAPIBase.globalLightStatus()
                .success(gls => {
                    $scope.globalLightStatusLoaded = true;
                    $scope.deploymentsStatusList = gls.deploymentsStatus;
                    $scope.infraStatusList = gls.infrasStatus;
                    $scope[`${$scope.publishedItemType}StatusList`] = gls[`${$scope.publishedItemType}sStatus`];
                    $scope.refreshForFilter($scope.deploymentsStatusList);
                })
                .error(setErrorInScope.bind($scope));
        }

        $scope.refreshAllDeployments();

        $scope.deployerHasPublishedPackages = function(itemList) {
            return (itemList || []).some(item => !!item.packages.length);
        };

        $scope.countSelectedItems = function(itemList) {
            return (itemList || []).filter(item => item.$selected).length;
        };

        $scope.clearSelectedItems = function(itemList) {
            return (itemList || []).forEach(item => item.$selected = false);
        };

        $scope.clearAndRefreshFilter = function(itemList) {
            $scope.clearSelectedItems(itemList);
            filterDeployments();
        }
        
        $scope.getSelectedHealthStatuses = function() {
            return $scope.countSelectedItems($scope.uiState.query.healthStatusMap) ? $scope.uiState.query.healthStatusMap.filter(healthStatus => healthStatus.$selected).map(healthStatus => $filter('healthStatusToFriendly')(healthStatus.id)).join(', ') : 'All states';
        }
    });

    app.controller('_DeployerPackagesPanelController', function($scope, $stateParams) {
        $scope.DEPLOYED_STATE = {
            'ALL': $scope.deployerType === 'api' ? 'All versions' : 'All bundles',
            'DEPLOYED': 'Deployed',
            'NOT_DEPLOYED': 'Not deployed'
        }

        $scope.uiState = {
            query: {
                search: '',
                deploy: $scope.DEPLOYED_STATE.ALL
            },
            noSelectedItem: true
        };

        function filterPublishedItemList() {
            $scope.uiState.noSelectedItem = itemList.every(item => !item.$selected);

            itemList.forEach(item => {
                let someVersionsAreShown = false;
                item.packages.forEach(pkg => {
                    // show deployed or not
                    pkg.$show = $scope.uiState.query.deploy === $scope.DEPLOYED_STATE.ALL
                        || ($scope.uiState.query.deploy === $scope.DEPLOYED_STATE.DEPLOYED && pkg.$deployed)
                        || ($scope.uiState.query.deploy === $scope.DEPLOYED_STATE.NOT_DEPLOYED && !pkg.$deployed);

                    // filtering by query: if query doesn't match item key/name, filter on packages
                    const query = $scope.uiState.query.search.toLowerCase();
                    if (!item[`${$scope.publishedItemType}BasicInfo`].id.toLowerCase().includes(query) &&
                        !item[`${$scope.publishedItemType}BasicInfo`].name.toLowerCase().includes(query)) {
                        // query matches package id or the id of one of the package deployments
                        pkg.$show = pkg.$show && ( pkg.id.toLowerCase().includes(query)
                            || pkg.$deployments.some(d => d.toLowerCase().includes(query)) );

                    }
                    someVersionsAreShown = pkg.$show || someVersionsAreShown;
                });
                // hide item if it is filtered out or all its packages are filtered out
                item.$show = ($scope.uiState.noSelectedItem || item.$selected) && someVersionsAreShown;
            });
        }

        let itemList;
        $scope.computeFullList = function(statusList) {
            itemList = statusList.filter(item => {
                    // remove any published items with no packages
                    return item.packages.length;
                }).map(item => {
                    item.$show = true; // whether the published item should be shown in list

                    item.packages.forEach(pkg => {
                        pkg.$show = true;
                        pkg.$deployments = $scope.getPackageDeployments(item.deployments, pkg.id).map(d => d.id);
                        pkg.$deployed = !!pkg.$deployments.length;
                    });
                    item.$latestPackage = item.packages.slice(-1).pop();
                    return item;
                });
            return itemList;
        }

        $scope.select = function(item) {
            item.$selected = !item.$selected;
            filterPublishedItemList();
        };

        $scope.clearItemFilter = function() {
            $scope.clearSelectedItems(itemList);
            filterPublishedItemList();
        };

        $scope.setDeployFilter = function(deploy) {
            $scope.uiState.query.deploy = deploy;
            filterPublishedItemList();
        };

        $scope.clearFilters = function() {
            $scope.uiState.query.search = '';
            $scope.uiState.query.deploy = $scope.DEPLOYED_STATE.ALL;
            $scope.clearItemFilter();
        };

        $scope.getFilteredPackageCount = function(item) {
            return item.packages.filter(pkg => pkg.$show).length;
        };

        $scope.deployerHasMatchingPublishedPackages = function() {
            return (itemList || []).some(item => item.$show && !!$scope.getFilteredPackageCount(item));
        };

        $scope.isNewPackage = function(pck) {
            return !pck.$deployed && pck.publishedOn >= (new Date()).getTime() - 24 * 3600 * 1000;
        };

        $scope.hasActiveFilters = function() {
            return $scope.uiState.query.search
                || $scope.uiState.query.deploy !== $scope.DEPLOYED_STATE.ALL
                || (itemList || []).some(item => item.$selected);
        };

        $scope.$watch("uiState.query.search", function(nv, ov) {
            if (nv === ov) return;
            filterPublishedItemList();
        });
    });

    app.controller('_DeployerDeploymentController', function($controller, $scope, $state, Dialogs, Assert, $rootScope, TaggingService) {
        $controller("_DeployerBaseController", {$scope: $scope});
        $scope.savedDeploymentSettings; // for dirtinessDetection

        $rootScope.activeProjectTagColor = TaggingService.getTagColor;
        
        $scope.getLightStatus = function() {
            return $scope.deployerAPIBase.deployments.getLightStatus($state.params.deploymentId).success(lightStatus => {
                $scope.lightStatus = lightStatus;
            }).error(setErrorInScope.bind($scope));
        };
    
        $scope.getHeavyStatus = function() {
            Assert.trueish($scope.lightStatus);
            return $scope.deployerAPIBase.deployments.getHeavyStatus($scope.lightStatus.deploymentBasicInfo.id, true).success(function(data) {
                $scope.heavyStatus = data;
            });
        };

        $scope.refreshLightAndHeavy = function(){
            $scope.getLightStatus(); // Heavy is refreshed by watch
        };
    
        $scope.getDeploymentSettings = function() {
            return $scope.deployerAPIBase.deployments.getSettings($state.params.deploymentId).success(function(data) {
                $scope.savedDeploymentSettings = angular.copy(data);
                $scope.deploymentSettings = data;
                
            }).error(setErrorInScope.bind($scope));
        };
    
        $scope.deploymentIsDirty = function() {
            return $scope.deploymentSettings && !angular.equals($scope.savedDeploymentSettings, $scope.deploymentSettings);
        };

        $scope.saveDeployment = function() {
            Assert.trueish($scope.deploymentSettings);
            if (!$scope.deploymentIsDirty()) return;
            return $scope.deployerAPIBase.deployments.save($scope.deploymentSettings).success(function(data) {
                $scope.getLightStatus();
                $scope.savedDeploymentSettings = angular.copy(data);
                $scope.deploymentSettings = data;
            }).error(setErrorInScope.bind($scope));
        };
    
        // abstract
        $scope.updateOnly = function() {};
    
        $scope.saveAndUpdate = function() {
            $scope.saveDeployment().then(function() { $scope.updateOnly(true); });
        };
    
        $scope.deleteDeployment = function() {
            if (!$scope.lightStatus) {
                return;
            }
            Dialogs.confirmAlert($scope, 'Delete deployment', 'Are you sure you want to delete this deployment?',
                                 $scope.deleteWarning, 'INFO').then(function() {
                $scope.deployerAPIBase.deployments.delete($scope.lightStatus.deploymentBasicInfo.id)
                    .success(_ => $state.go(`${$scope.deployerType}deployer.deployments.dashboard`))
                    .error(setErrorInScope.bind($scope));
            });
        };
    
        /* Main */
        $scope.getLightStatus();
    });
})();

(function() {
    'use strict';

    const app = angular.module('dataiku.apideployer', ['dataiku.lambda']);

    app.controller('APIDeployerController', function($scope, $rootScope, DeployerUtils, DataikuAPI) {
        $scope.DeployerUtils = DeployerUtils;
        $scope.deployerType = 'api';
        $scope.publishedItemType = 'service';
        $scope.deployerAPIBase = DataikuAPI.apideployer;
        $scope.stages = [].concat($rootScope.appConfig.apiDeploymentStages);
        $scope.defaultTitle = "API Deployer";
        $scope.deployerObjectBar = {
            title: $scope.defaultTitle
        };
        $scope.isFeatureLocked = !($rootScope.appConfig.licensedFeatures.apiNodeAllowed || $rootScope.appConfig.licensing.ceEntrepriseTrial);
    });
}());

(function() {
'use strict';

const app = angular.module('dataiku.apideployer');


app.constant('INFRA_TYPES', {
    STATIC: "static",
    K8S: "Kubernetes"
});


app.controller('APIDeployerInfrasListController', function($scope, $controller, DeployerUtils) {
    $controller('_DeployerInfrasListController', {$scope: $scope});

    if ($scope.isFeatureLocked) return;

    $scope.$watch("infraStatusList", function(nv) {
        if (!nv) return;
        nv.forEach(function(infraStatus) {
            infraStatus.enabledDeploymentCount = DeployerUtils.enabledDeploymentCount(infraStatus.deployments, true);
        });
    });
});


app.controller('APIDeployerInfraController', function($controller, $scope) {
    $controller('_DeployerInfraController', {$scope: $scope});
});


app.controller('APIDeployerInfraSetupModalController', function($scope, $controller) {
    $controller('_DeployerInfraSetupModalController', {$scope: $scope});
    $scope.newInfra.type = 'STATIC';
});


app.controller('APIDeployerInfraStatusController', function($scope, $controller, APIDeployerAsyncHeavyStatusLoader, DeployerDeploymentTileService) {
    $controller("_DeployerInfraStatusController", {$scope: $scope});

    $scope.$watch("infraStatus", function(nv) {
        if (nv) {
            const heavyStatusByDeploymentId = {};
            let loader = APIDeployerAsyncHeavyStatusLoader.newLoader($scope.infraStatus.deployments.filter(_ => _.enabled).map(_ => _.id), heavyStatusByDeploymentId);

            loader.loadAllHeavyStatus();

            const deregister = $scope.$watch(function(){
                return loader.stillRefreshing();
            }, function(nv, ov) {
                if (nv || ov === nv) return;
                $scope.healthMap = DeployerDeploymentTileService.getDeploymentHealthMap($scope.infraStatus.deployments, heavyStatusByDeploymentId);
                deregister();
            });
            
            $scope.$on('$destroy', function() {
                loader && loader.stopLoading();
            });
        }
    });
});

app.controller('APIDeployerInfraHistoryController', function($scope, $controller) {
    $controller('_DeployerInfraHistoryController', {$scope: $scope});
});


app.controller('APIDeployerInfraSettingsController', function($scope, $controller, $rootScope, DataikuAPI, ClipboardUtils) {
    $controller('_DeployerInfraSettingsController', {$scope: $scope});
    
    $scope.getUrlSuffixWarning = function(value) {
        if ($scope.hasUrlSuffix(value)) {
            return "URL should be http[s]://host[:port], an URL suffix is unexpected and will likely not work";
        }
        return null;
    }

    let inlineContainerConfig = {
        name: "inline",
        type: "KUBERNETES",
        baseImageType: "EXEC",
        properties: [],
    };

    $scope.getInlineContainerConfig = function() {
        if ($scope.infra) {
            inlineContainerConfig.kubernetesNamespace = $scope.infra.k8sNamespace;
            inlineContainerConfig.kubeCtlContext = $scope.infra.k8sContext;
            inlineContainerConfig.kubeConfigPath = $scope.infra.k8sConfigPath;
            inlineContainerConfig.properties = $scope.infra.k8sProperties;
            inlineContainerConfig.baseImage = $scope.infra.baseImageTag;
            inlineContainerConfig.repositoryURL = $scope.infra.registryHost;
            inlineContainerConfig.prePushMode = $scope.infra.prePushMode;
            inlineContainerConfig.prePushScript = $scope.infra.prePushScript;
        }
        return inlineContainerConfig; // return the same object to avoid never-ending $digest() issues
    };

    if ($rootScope.appConfig.admin) {
        DataikuAPI.admin.connections.list().success(function(allConnections) {
            $scope.allConnections = allConnections;
        }).error(setErrorInScope.bind($scope));
    }
    
    /******** cluster *******/
    DataikuAPI.admin.clusters.listAccessible('KUBERNETES').success(function(data){
        $scope.k8sClusterIds = data.map(function(c) {return c.id;});
    }).error(setErrorInScope.bind($scope));
    

    /******** actions *******/
    $scope.onLocalConnectionChanged = function() {
        if ($scope.uiState.selectedLocalConnectionName) {
            ClipboardUtils.copyToClipboard(JSON.stringify($scope.allConnections[$scope.uiState.selectedLocalConnectionName], null, 2));
        }
    };

    $scope.deleteRemappedConnection = function(pckConId) {
        if ($scope.infra && $scope.infra.remappedConnections) {
            delete $scope.infra.remappedConnections[pckConId];
        }
    };

    $scope.hasRemappedConnections = function() {
        return $scope.infra && Object.keys($scope.infra.remappedConnections).length;
    };
});


app.filter('infraTypeToName', function(INFRA_TYPES) {
    return function(type) {
        if (!type) {
            return;
        }
        return INFRA_TYPES[type] || type;
    };
});


app.filter('infraTypeToIcon', function() {
    return function(type) {
        if (!type) {
            return;
        }
        return 'icon-hdd';
    };
});

})();
(function() {
'use strict';

const app = angular.module('dataiku.apideployer');


app.controller('APIDeployerServicesListController', function($scope, $controller, $state, TopNav, DataikuAPI,
    CreateModalFromTemplate, WT1, DeployerUtils) {
    $controller('_DeployerBaseController', {$scope});
    TopNav.setNoItem();
    TopNav.setLocation(TopNav.TOP_API_DEPLOYER, 'services');

    if ($scope.isFeatureLocked) return;

    $scope.uiState = {};
        
    $scope.canCreateServices = function() {
        return $scope.appConfig.globalPermissions && $scope.appConfig.globalPermissions.mayCreatePublishedAPIServices;
    };

    $scope.startCreateService = function() {
        CreateModalFromTemplate("/templates/api-deployer/new-published-service-modal.html", $scope).then(function(newService) {
            $state.go('apideployer.services.service.status', {serviceId: newService.id});
            WT1.event('api-deployer-service-create');
        });
    };

    function getLastUpdatedTime(serviceStatus) {
        const publishedOn = (serviceStatus.packages[0] || {}).publishedOn || 0;
        const settingsLastModified = (serviceStatus.serviceBasicInfo.versionTag||{}).lastModifiedOn||0;
        return Math.max(publishedOn, settingsLastModified);
    }

    DataikuAPI.apideployer.publishedAPIServices.listLightStatus()
        .success(function(serviceStatusList) {
            $scope.serviceStatusList = serviceStatusList;
            serviceStatusList.forEach(function(serviceStatus) {
                serviceStatus.enabledDeploymentCount = DeployerUtils.enabledDeploymentCount(serviceStatus.deployments, true);
                serviceStatus.lastUpdated = getLastUpdatedTime(serviceStatus);
            })
        })
        .error(setErrorInScope.bind($scope));
});


app.controller('APIDeployerServiceCreationModalController', function($scope, DataikuAPI) {
    $scope.newService = $scope.newService || {};
    $scope.$watch("newService.name", function(nv, ov) {
        if (!nv) return;
        $scope.newService.id = nv.replace(/\W+/g, "");
    });
    $scope.ok = function() {
        DataikuAPI.apideployer.publishedAPIServices.create($scope.newService.id, $scope.newService.name)
            .success($scope.resolveModal)
            .error(setErrorInScope.bind($scope));
    };
});


app.controller('APIDeployerServiceController', function($scope, $controller, $state, DataikuAPI, Dialogs, CreateModalFromTemplate) {
    $controller('_DeployerBaseController', {$scope});

    $scope.refreshServiceStatus = function() {
        return DataikuAPI.apideployer.publishedAPIServices.getLightStatus($state.params.serviceId)
            .success(serviceStatus => {
                $scope.serviceStatus = serviceStatus;
            })
            .error(setErrorInScope.bind($scope));
    };
    $scope.refreshServiceStatus();

    $scope.ui = {};
    let savedService; //for dirtyness detection
    $scope.refreshServiceSettings = function() {
        return DataikuAPI.apideployer.publishedAPIServices.getSettings($state.params.serviceId)
            .success(service => {
                $scope.service = service;
                $scope.ui.ownerLogin = service.owner;
                savedService = angular.copy(service);
            })
            .error(setErrorInScope.bind($scope));
    };

    $scope.serviceIsDirty = function() {
        return !angular.equals(savedService, $scope.service);
    };

    $scope.saveService = function() {
        if (!$scope.service || !$scope.serviceIsDirty()) return;
        DataikuAPI.apideployer.publishedAPIServices.save($scope.service)
            .success(function() {
                $scope.refreshServiceSettings();
                $scope.refreshServiceStatus();
            })
            .error(setErrorInScope.bind($scope));
    };

    $scope.deleteService = function() {
        if (!$scope.serviceStatus) {
            return;
        }
        if ($scope.serviceStatus.deployments.length) {
            Dialogs.error($scope, 'Delete service', 'You cannot delete this service because it has deployments!');
            return;
        }
        Dialogs.confirm($scope, 'Delete service','Are you sure you want to delete this service?').then(function() {
            DataikuAPI.apideployer.publishedAPIServices.delete($scope.serviceStatus.serviceBasicInfo.id)
                .success(() => { $state.go('apideployer.services.list'); })
                .error(setErrorInScope.bind($scope));
        });
    };

    $scope.startUploadPackages = function() {
        CreateModalFromTemplate("/templates/api-deployer/published-service-upload-packages-modal.html", $scope);
    };
});


app.controller('APIDeployerServiceUploadPackagesController', function($scope, $controller, DataikuAPI, WT1) {
    $controller("_DeployerUploadPackageController", {$scope:$scope});
    $scope.publishPackage = (fileToUpload, callback) => {
        return DataikuAPI.apideployer.publishedAPIServices.publishVersion($scope.serviceStatus.serviceBasicInfo.id,
            fileToUpload, callback
        );
    };
    $scope.afterUploadCallback = function() {
        $scope.refreshServiceSettings();
        $scope.refreshServiceStatus();
        if ($scope.uiState.fileProperties.filter(f => !f.uploaded).length == 0) {
            $scope.dismiss();
            WT1.event('api-deployer-upload-package');
        }
    };
});


app.controller('APIDeployerServiceStatusController', function($scope, $stateParams, TopNav, Dialogs, DataikuAPI, WT1, APIDeployerServicesService, APIDeployerAsyncHeavyStatusLoader, DeployerDeploymentTileService, DeployerUtils) {
    TopNav.setNoItem();
    TopNav.setLocation(TopNav.TOP_API_DEPLOYER, 'services', null, 'status');

    $scope.heavyStatusByDeploymentId = {};

    $scope.deployVersion = function(versionId) {
        APIDeployerServicesService.deployVersion($scope.serviceStatus, versionId, DeployerUtils.DEPLOY_SOURCE.PACKAGE);
    };

    $scope.deleteVersion = function(serviceId, versionId) {
        Dialogs.confirm($scope, 'Delete version ' + versionId, 'Are you sure you want to delete this version?').then(function() {
            DataikuAPI.apideployer.publishedAPIServices.deletePackage(serviceId, versionId)
            .success($scope.refreshServiceStatus)
            .error(setErrorInScope.bind($scope));
            WT1.event('api-deployer-packages-delete');
        });
    };

    DataikuAPI.apideployer.infras.listLightStatus()
    .success(function(infraStatusList) {
        $scope.infraStatusList = infraStatusList;
    }).error(setErrorInScope.bind($scope));

    let showOthersStage = false;

    // Only show an empty "others" stage if other versions contain a filled "others" stage
    $scope.showEmptyOthersStage = function(stage, pkg) {
        return stage === '__OTHERS__' && showOthersStage && !$scope.deploymentsPerVersionAndStage[pkg.id].others;
    };

    $scope.$watch("serviceStatus", function() {
        if (!$scope.serviceStatus) return;

        if ($stateParams.versions) {
            $scope.serviceStatus.packages.forEach(function(p) {
                if ($stateParams.versions.includes(p.id)) {
                    p.$expanded = true;
                }
            });
        }

        const MAX_STAGE_COUNT = 3;
        $scope.currentStages = DeployerUtils.getStagesToDisplay([$scope.serviceStatus], $scope.stages, MAX_STAGE_COUNT);
        $scope.deploymentsPerVersionAndStage = DeployerUtils.getDeploymentsPerPackageAndStage($scope.serviceStatus, $scope.stages, $scope.currentStages, 'version');
        showOthersStage = $scope.serviceStatus.packages.some(pkg => $scope.deploymentsPerVersionAndStage[pkg.id].others);

        const heavyStatusByDeploymentId = {};
        let loader = APIDeployerAsyncHeavyStatusLoader.newLoader($scope.serviceStatus.deployments.filter(_ => _.enabled).map(_ => _.id), heavyStatusByDeploymentId);
        loader.loadAllHeavyStatus();

        const deregister = $scope.$watch(function(){
            return loader.stillRefreshing();
        }, function(nv, ov) {
            if (nv || ov === nv) return;
            $scope.heavyStatusByDeploymentId = heavyStatusByDeploymentId;
            $scope.healthMap = DeployerDeploymentTileService.getDeploymentHealthMap($scope.serviceStatus.deployments, heavyStatusByDeploymentId);
            deregister();
        });

        $scope.$on('$destroy', function() {
            loader && loader.stopLoading();
        });
    });
});


app.controller('APIDeployerServiceHistoryController', function($scope, TopNav) {
    TopNav.setNoItem();
    TopNav.setLocation(TopNav.TOP_API_DEPLOYER, 'services', null, 'history');

    $scope.refreshServiceSettings();
});


app.controller('APIDeployerServiceSettingsController', function($controller, $scope, TopNav) {
    TopNav.setNoItem();
    TopNav.setLocation(TopNav.TOP_API_DEPLOYER, 'services', null, 'settings');
    $scope.uiState = {
        active: 'general'
    };

    $controller('_APIDeployerServicePermissionsController', {$scope});

    $scope.refreshServiceSettings();
    checkChangesBeforeLeaving($scope, $scope.serviceIsDirty);
});


app.controller('_APIDeployerServicePermissionsController', function($scope, $controller, PermissionsService) {
    $controller('_DeployerPermissionsController', {$scope: $scope});

    // don't initialize until obj is available
    const deregister = $scope.$watch("service", function(nv, ov) {
        if (!nv) return;
        $scope.initPermissions($scope.service, {
            read: true,
            write: false,
            deploy: false,
            admin: false
        }, true);
        deregister();
    }, false);

    $scope.$watch("ui.ownerLogin", function() {
        PermissionsService.transferOwnership($scope, $scope.service, "service");
    });

    $scope.$watch("service.permissions", function(nv, ov) {
        if (!nv) return;
        $scope.onPermissionChange($scope.service);
    }, true);

    $scope.$watch("service.permissions", function(nv, ov) {
        if (!nv) return;
        $scope.onPermissionChange($scope.service);
    }, false);
});


app.service('APIDeployerServicesService', function($state, DataikuAPI, Assert, WT1, DeployerPublishedItemsService, APIDeployerDeploymentService) {
    this.deployVersion = function(serviceStatus, versionId, source) {
        Assert.trueish(serviceStatus, 'serviceStatus not provided');
        Assert.trueish(serviceStatus.deployments, 'no deployments in serviceStatus');

        DeployerPublishedItemsService.deployPackage(serviceStatus, 'version').then(deploymentMethodId => {
            if (deploymentMethodId == DeployerPublishedItemsService.DEPLOYMENT_METHOD_ID.NEW) {
                deployVersionInNewDeployment(serviceStatus, versionId, source);
            } else {
                deployVersionInExistingDeployment(serviceStatus, versionId, source);
            }
        })
    };

    function deployVersionInNewDeployment(serviceStatus, versionId, source) {
        return APIDeployerDeploymentService.startCreateDeployment(serviceStatus.serviceBasicInfo.id, versionId).then(function(newDeployment) {
            $state.go('apideployer.deployments.deployment.status', {deploymentId: newDeployment.id});
            WT1.event('api-deployer-deploy-version-in-new-deployment', {deploymentType: newDeployment.type, source });
        });
    }

    function deployVersionInExistingDeployment(serviceStatus, versionId, source) {
        DeployerPublishedItemsService.openDeploymentSelector(serviceStatus, true).then(function(depl) {
            DataikuAPI.apideployer.deployments.switchVersion(depl.id, versionId)
                .success(function() {
                    WT1.event('api-deployer-deploy-version-in-existing-deployment', { deploymentType: depl.type, source });
                    $state.go('apideployer.deployments.deployment.settings', {deploymentId: depl.id});
                })
                .error(function() {
                    deferred.reject.call(this, arguments);
                });
        });
    }
});


})();

(function() {
'use strict';

const app = angular.module('dataiku.apideployer');

app.service('APIDeployerAsyncHeavyStatusLoader', function(DataikuAPI, Logger, DeployerUtils) {
    const nbSimultaneousLoading = 2;

    return {
        newLoader: function(deploymentIds, heavyStatusPerDeployment) {
            const loader = {};

            let canLoadStatus = true;
            loader.stopLoading = function() {
                canLoadStatus = false;
            };

            let loading = true;
            loader.stillRefreshing = () => loading;

            let running = 0;
            loader.loadAllHeavyStatus = function() {
                if (!deploymentIds || !deploymentIds.length && !running || !canLoadStatus) {
                    loading = false;
                    return;
                }
                const idListForStatusLoad = deploymentIds.splice(0, nbSimultaneousLoading - running);
                running += idListForStatusLoad.length;
                for (let deploymentId of idListForStatusLoad) {
                    Logger.info("Sending heavy status request for " + deploymentId);
                    DataikuAPI.apideployer.deployments.getHeavyStatus(deploymentId, false).success(function(heavyStatus) {
                        Logger.info("Got heavy status for " + deploymentId + "; health: " + heavyStatus.health);
                        heavyStatusPerDeployment[deploymentId] = heavyStatus;
                        running -= 1;
                        loader.loadAllHeavyStatus();

                    }).error(function(a,b,c) {
                        Logger.warn("Failed to load heavy status for " + deploymentId);
                        heavyStatusPerDeployment[deploymentId] = {
                            health: "LOADING_FAILED",
                            healthMessages: DeployerUtils.getFailedHeavyStatusLoadMessage(getErrorDetails(a,b,c))
                        };
                        running -= 1;
                        loader.loadAllHeavyStatus();
                    });
                }
            };
            return loader;
        }
    }
});

app.directive('apiDeploymentCard', function($state, DataikuAPI, TaggingService, APIDeployerDeploymentUtils,
    DeployerDeploymentTileService) {
    return {
        scope: {
            lightStatus: '=',
            heavyStatus: '=',
            showMonitoring: '=',
        },
        templateUrl: '/templates/api-deployer/deployment-card.html',
        replace: true,
        link: function(scope, elem, attrs) {
            scope.dashboardTile = attrs.hasOwnProperty("deploymentDashboardTile");
            scope.TaggingService = TaggingService;
            scope.APIDeployerDeploymentUtils = APIDeployerDeploymentUtils;
            let loadingSparkline;
            function loadSparkline() {
                if ((scope.deploymentStatus.currentState == "HEALTHY" || scope.deploymentStatus.currentState == "WARNING") &&
                    !loadingSparkline && !scope.lightStatus.failedToLoadSparkline && !scope.heavyStatus.sparkline &&
                    scope.lightStatus.infraBasicInfo.carbonAPIEnabled) {
                    loadingSparkline = true;
                    DataikuAPI.apideployer.deployments.getChartData(scope.lightStatus.deploymentBasicInfo.id, null, "OVERALL_QPS_COMBINED", "SIX_HOURS")
                        .success(function(spkData) {
                            let datapoints;
                            if (spkData[0] && spkData[0].datapoints) {
                                datapoints = spkData[0].datapoints;
                            } else {
                                datapoints = APIDeployerDeploymentUtils.buildZeroDatapoints("SIX_HOURS");
                            }
                            loadingSparkline = false;
                            scope.heavyStatus.sparkline = datapoints.map(x => x[0]);
                    }).error(function(a,b,c) {
                        loadingSparkline = false;
                        scope.lightStatus.failedToLoadSparkline = getErrorDetails(a,b,c);
                    });
                }
            }

            scope.redirect = function() {
                if (attrs.hasOwnProperty("redirectToDeploymentPage")) {
                    $state.go('apideployer.deployments.deployment.status', {deploymentId: scope.lightStatus.deploymentBasicInfo.id});
                }
            }

            scope.$watch('heavyStatus', function() {
                const isDisabled = scope.lightStatus && !scope.lightStatus.deploymentBasicInfo.enabled;
                scope.deploymentStatus = DeployerDeploymentTileService.getDeploymentHealth(scope.heavyStatus, isDisabled);
                if (scope.lightStatus && scope.heavyStatus) {
                    loadSparkline();
                }
            });

            scope.$watch('lightStatus', function() {
                if (scope.lightStatus && scope.heavyStatus) {
                    loadSparkline();
                }
            }, true);
        }
    };
});

app.directive('apiDeploymentsListWidget', function($state, TaggingService) {
    return {
        scope: {
            deployments: '=apiDeploymentsListWidget',
            statusPage: '=',
            healthMap: '='
        },
        templateUrl: '/templates/api-deployer/deployment-list.html',
        replace: true,
        link: function(scope) {
            scope.TaggingService = TaggingService;

            scope.redirect = function(deployment) {
                $state.go('apideployer.deployments.deployment.status', {deploymentId: deployment.id});
            };
        }
    };
});


app.controller('APIDeployerPackagesPanelController', function($scope, $controller, APIDeployerServicesService, APIDeployerDeploymentUtils, TaggingService, DeployerUtils) {
    $controller("_DeployerPackagesPanelController", {$scope});

    $scope.TaggingService = TaggingService;

    $scope.getPackageDeployments = function(deployments, versionId) {
        return deployments.filter(d => APIDeployerDeploymentUtils.getParticipatingVersions(d).includes(versionId));
    }

    $scope.deployVersion = function(serviceStatus, versionId) {
        APIDeployerServicesService.deployVersion(serviceStatus, versionId, DeployerUtils.DEPLOY_SOURCE.PACKAGE_PANEL);
    };

    $scope.$watch("serviceStatusList", function(nv) {
        if (!nv) return;

        $scope.uiState.fullServiceList = $scope.computeFullList(nv);
    });
});

app.controller('APIDeployerDeploymentCopyModalController', function($scope, DataikuAPI, Assert) {
    $scope.newDepl = $scope.newDepl || {};
    DataikuAPI.apideployer.infras.listBasicInfo()
        .success(infraBasicInfoList => {
            $scope.infraBasicInfoList = infraBasicInfoList.infras;
            if ($scope.infraBasicInfoList.length == 1) {
                $scope.newDepl.infraId = $scope.infraBasicInfoList[0].id;
            }
        })
        .error(setErrorInScope.bind($scope));

    DataikuAPI.apideployer.deployments.listBasicInfo()
        .success(deploymentBasicInfoList => {$scope.deploymentIdList = deploymentBasicInfoList.deployments.map(depl => depl.id)})
        .error(setErrorInScope.bind($scope));

    function autoSetDeploymentId() {
        if (!$scope.newDepl.publishedServiceId || !$scope.newDepl.infraId) {
            return;
        }
        let newDeplId = $scope.newDepl.publishedServiceId + '-on-' + $scope.newDepl.infraId;
        let counter = 0;
        while (($scope.deploymentIdList || []).indexOf(newDeplId + (counter ? ('-' + counter) : '')) >= 0) {
            counter++;
        }
        $scope.newDepl.id = newDeplId + (counter ? ('-' + counter) : '');

    }
    $scope.$watch('newDepl.infraId', autoSetDeploymentId);


    $scope.ok = function() {
        DataikuAPI.apideployer.deployments.copy($scope.oldDeplId, $scope.newDepl.id, $scope.newDepl.infraId)
            .success($scope.resolveModal)
            .error(setErrorInScope.bind($scope));
    };
});

app.controller('APIDeployerDeploymentCreationModalController', function($scope, DataikuAPI, Assert) {
    $scope.newDepl = $scope.newDepl || {};

    DataikuAPI.apideployer.infras.listBasicInfo()
        .success(infraBasicInfoList => {
            $scope.infraBasicInfoList = infraBasicInfoList.infras;
            if ($scope.infraBasicInfoList.length == 1) {
                $scope.newDepl.infraId = $scope.infraBasicInfoList[0].id;
            }
        })
        .error(setErrorInScope.bind($scope));

    DataikuAPI.apideployer.publishedAPIServices.listBasicInfo()
        .success(serviceBasicInfoList => {$scope.serviceBasicInfoList = serviceBasicInfoList.services})
        .error(setErrorInScope.bind($scope));

    DataikuAPI.apideployer.deployments.listBasicInfo()
        .success(deploymentBasicInfoList => {$scope.deploymentIdList = deploymentBasicInfoList.deployments.map(depl => depl.id)})
        .error(setErrorInScope.bind($scope));

    function setupVersionsIds() {
        if (!$scope.newDepl.publishedServiceId || !$scope.serviceBasicInfoList) {
            return;
        }
        $scope.versionsIds = [];
        for (let sbi of $scope.serviceBasicInfoList) {
            if (sbi.id == $scope.newDepl.publishedServiceId) {
                $scope.versionsIds = sbi.versionsIds;
                break;
            }
        }
        if (!$scope.versionsIds.includes($scope.newDepl.versionId)) {
            if ($scope.versionsIds.length) {
                $scope.newDepl.versionId = $scope.versionsIds[0];
            } else {
                delete $scope.newDepl.versionId;
            }
        }
    }
    $scope.$watch('newDepl.publishedServiceId', setupVersionsIds);
    $scope.$watch('serviceBasicInfoList', setupVersionsIds);

    function autoSetDeploymentId() {
        if (!$scope.newDepl.publishedServiceId || !$scope.newDepl.infraId) {
            return;
        }
        let newDeplId = $scope.newDepl.publishedServiceId + '-on-' + $scope.newDepl.infraId;
        let counter = 0;
        while (($scope.deploymentIdList || []).indexOf(newDeplId + (counter ? ('-' + counter) : '')) >= 0) {
            counter++;
        }
        $scope.newDepl.id = newDeplId + (counter ? ('-' + counter) : '');

    }
    $scope.$watch('newDepl.publishedServiceId', autoSetDeploymentId);
    $scope.$watch('newDepl.infraId', autoSetDeploymentId);


    $scope.ok = function() {
        DataikuAPI.apideployer.deployments.create($scope.newDepl.id, $scope.newDepl.publishedServiceId, $scope.newDepl.infraId, $scope.newDepl.versionId)
            .success($scope.resolveModal)
            .error(setErrorInScope.bind($scope));
    };
});

app.controller('APIDeployerDeploymentController', function($controller, $scope, $state, WT1, DataikuAPI, Dialogs, Assert,
    APIDeployerDeploymentUtils, CreateModalFromTemplate, FutureProgressModal, StaticDeploymentSyncHelper) {
    $controller('_DeployerDeploymentController', {$scope});

    $scope.unsavedTestQueries =  {} // map endpointId -> json query

    $scope.deleteWarning = 'The deployed API service will not be automatically deleted from the API node. To delete it, please ensure the deployment has been disabled and updated before deleting the deployment.';

    $scope.updateOnly = function(askMode, refreshMode) {
        Assert.trueish($scope.lightStatus);
        if ($scope.lightStatus.infraBasicInfo.type === "K8S") {
            DataikuAPI.apideployer.deployments.executeSyncK8S($scope.lightStatus.deploymentBasicInfo.id).success(function(data) {
                FutureProgressModal.show($scope, data, "Deploying").then(function(result) {
                    $scope.lightStatus.neverEverDeployed = false;
                    $scope.refreshLightAndHeavy();
                });
            }).error(setErrorInScope.bind($scope));
        } else {
            StaticDeploymentSyncHelper.init($scope, $scope.lightStatus, askMode, refreshMode);
        }
        // deployment type is same as infra type in this case
        WT1.event('api-deployer-deployment-update', { deploymentType: $scope.lightStatus.infraBasicInfo.type });
    };

    $scope.copyDeployment = function() {
        if (!$scope.lightStatus || !$scope.lightStatus.deploymentBasicInfo || !$scope.lightStatus.deploymentBasicInfo.id ||
                !$scope.lightStatus.serviceBasicInfo || !$scope.lightStatus.serviceBasicInfo.id) {
            return;
        }
        CreateModalFromTemplate("/templates/api-deployer/copy-deployment-modal.html",
            angular.extend($scope, {oldDeplId: $scope.lightStatus.deploymentBasicInfo.id, newDepl: {publishedServiceId: $scope.lightStatus.serviceBasicInfo.id}})).then(function(newDeployment) {
                $state.go('apideployer.deployments.deployment.status', {deploymentId: newDeployment.id});
                WT1.event('api-deployer-deployment-copy', { deploymentType: newDeployment.type });
        });
    };

    const allowedTransitions = [
        'apideployer.deployments.deployment.status',
        'apideployer.deployments.deployment.history',
        'apideployer.deployments.deployment.settings'
    ];
    checkChangesBeforeLeaving($scope, $scope.deploymentIsDirty, null, allowedTransitions);
});

app.controller('APIDeployerDeploymentStatusController', function($scope, TopNav, DataikuAPI,  DeployerUtils,
    DeployerDeploymentTileService) {
    TopNav.setNoItem();
    TopNav.setLocation(TopNav.TOP_API_DEPLOYER, 'deployments', null, 'status');

    $scope.chartURL = DataikuAPI.apideployer.deployments.chartURL;

    $scope.uiState = {};

    $scope.setCurrentEndpoint = function(endpoint) {
        $scope.currentEndpoint = endpoint;
    };

    $scope.$watch("lightStatus", function(nv, ov) {
        if (nv) {
            $scope.getHeavyStatus().then(function(data) {
                $scope.deploymentStatus = DeployerDeploymentTileService.getDeploymentHealth($scope.heavyStatus, $scope.lightStatus.deploymentBasicInfo.enabled);
                if ($scope.heavyStatus && $scope.heavyStatus.endpoints && $scope.heavyStatus.endpoints.length) {
                    $scope.setCurrentEndpoint($scope.heavyStatus.endpoints[0]);
                }
            }, function(err) {
                $scope.heavyStatus = {
                    health: "LOADING_FAILED",
                    healthMessages: DeployerUtils.getFailedHeavyStatusLoadMessage(getErrorDetails(err.data, err.status, err.headers))
                };
            });
        }
    });

});


app.controller('APIDeployerDeploymentStatusEndpointStatusController', function($scope, $controller, $state, TopNav, DataikuAPI, FutureProgressModal, Assert, CodeMirrorSettingService, DeploymentStatusEndpointSampleCodeGenerator, APIDeployerDeploymentUtils) {
    Assert.trueish($scope.lightStatus);
    Assert.trueish($scope.lightStatus.infraBasicInfo);
    Assert.trueish($scope.heavyStatus);

    $scope.codeMirrorSettingService = CodeMirrorSettingService;

    $scope.epUIState= {
        activeTab: "summary",
        sampleCodeLang: "CURL",
        chartsTimeRange: "SIX_HOURS"
    };
    $scope.chartsTimeRanges = [
        {
            id: 'ONE_HOUR',
            label: '1 hour'
        },
        {
            id: 'SIX_HOURS',
            label: '6 hours'
        },
        {
            id: 'ONE_DAY',
            label: '1 day'
        }
    ];
    $scope.sampleCodeOptions = [
        ["CURL", "Shell (cURL)"],
        ["PYTHON", "Python"],
        ["R", "R"],
        ["JAVA", "Java"]
        //["CSHARP", "C#"],
        //["PHP", "PHP"]
    ];

    if (!$scope.lightStatus.publicAccess && $scope.lightStatus.apiKeys.length) {
        $scope.apiKeyToUse = $scope.lightStatus.apiKeys[0].key;
    }

    function onCodeLangChanged() {
        if ($scope.epUIState.sampleCodeLang && $scope.serviceURLs && $scope.serviceURLs.length > 0) {
            $scope.sampleCode = DeploymentStatusEndpointSampleCodeGenerator.generateSampleCode($scope.lightStatus,
                        $scope.serviceURLs, $scope.endpoint, $scope.epUIState.sampleCodeLang, $scope.heavyStatus);
        } else {
            $scope.sampleCode = '';
        }
    }

    $scope.$watch("epUIState.sampleCodeLang", onCodeLangChanged);
    $scope.$watch("currentEndpoint", function(nv) {
        if (nv) {
            $scope.endpoint = $scope.currentEndpoint;
            $scope.serviceURLs = APIDeployerDeploymentUtils.computeEndpointURLs($scope.lightStatus, $scope.heavyStatus, $scope.endpoint);
            onCodeLangChanged();
            loadCharts($scope.endpoint);
        }
    });

    $scope.$watch("epUIState.chartsTimeRange", function(nv) {
        if (nv && $scope.currentEndpoint) {
            loadCharts($scope.currentEndpoint);
        }
    });

    $scope.$watch("epUIState.activeTab", function(nv, ov) {
        if (nv && ov && nv =="summary") {
            loadCharts($scope.currentEndpoint);
        }
    });

    function cleanupChart(svgId) {
        d3.selectAll('svg#' + svgId + ' > *').remove();
        d3.selectAll('.nvtooltip').remove();
    }

    function displayQPSChart(datapoints, svgId) {
        const data = [{
            key: "QPS",
            values: datapoints,
            color: "rgb(42, 177, 172)"
        },{
            values: datapoints,
            area: true,
            color: "rgba(42, 177, 172, 0.5)"
        }];
        const maxVal = d3.max(datapoints.map(dp => dp.y)) || 10;

        nv.addGraph(function() {
            const chart = nv.models.lineChart().options({
                useInteractiveGuideline:true
            });
            chart.useVoronoi(false);
            chart.showLegend(false);
            chart.margin({top: 5, right: 20, bottom: 20, left: 40});
            chart.xAxis.tickFormat(d => d3.time.format('%H:%M')(new Date(d*1000)));
            chart.yAxis.tickFormat(x => d3.format(',.1f')(x));
            chart.yDomain([0,maxVal])

            d3.select('svg#' + svgId)
                .datum(data)
                .transition().duration(500)
                .call(chart);

            nv.utils.windowResize(chart.update);

            return chart;
        });
    }
    function displayTimeChart(series, svgId) {
        const data = series.map(function(serie, i) {
            return {
                key: serie.target.replace(".totalProcessing.p95", ""),
                max: d3.max(serie.datapoints.map(dp => dp[0])),
                values: serie.datapoints.map(dp => ({x: dp[1], y: dp[0]}))
            }
        });
        const maxVal = d3.max(data.map(serie => serie.max)) || 10;
        nv.addGraph(function() {
            const chart = nv.models.lineChart().options({
                useInteractiveGuideline:true
            });
            chart.showLegend(false);
            chart.useVoronoi(false);
            chart.margin({top: 5, right: 20, bottom: 20, left: 40});
            chart.xAxis.tickFormat(d => d3.time.format('%H:%M')(new Date(d*1000)));
            chart.yAxis.tickFormat(x => d3.format(',.0f')(x) + " ms");
            chart.yDomain([0,maxVal])

            d3.select('svg#' + svgId)
                .datum(data)
                .transition().duration(500)
                .call(chart);

            nv.utils.windowResize(chart.update);

            return chart;
        });
    }

    function loadCharts(endpoint) {
        if ($scope.lightStatus && $scope.lightStatus.deploymentBasicInfo.enabled && $scope.lightStatus.infraBasicInfo.carbonAPIEnabled) {
            // cleanup and reload the queries chart
            delete endpoint.succeededToLoadQueries;
            delete endpoint.failedToLoadQueries;
            cleanupChart('deployment-graph-queries');
            DataikuAPI.apideployer.deployments.getChartData($scope.lightStatus.deploymentBasicInfo.id, endpoint.id, "ENDPOINT_QPS_COMBINED", $scope.epUIState.chartsTimeRange || "SIX_HOURS").success(function(spkData) {
                endpoint.succeededToLoadQueries = true;
                let datapoints;
                if (spkData[0] && spkData[0].datapoints) {
                    datapoints = spkData[0] && spkData[0].datapoints;
                } else {
                    // if no data, fill datapoints with dummy values in order to display the graph anyways
                    datapoints = APIDeployerDeploymentUtils.buildZeroDatapoints($scope.epUIState.chartsTimeRange);
                }
                displayQPSChart(datapoints.map(dp => ({x: dp[1], y: dp[0]})), 'deployment-graph-queries');
            }).error(function(a,b,c) {
                endpoint.failedToLoadQueries = getErrorDetails(a,b,c);
            });
            // cleanup and reload the processingtime chart
            delete endpoint.succeededToLoadTiming;
            delete endpoint.failedToLoadTiming;
            cleanupChart('deployment-graph-processingtime');
            DataikuAPI.apideployer.deployments.getChartData($scope.lightStatus.deploymentBasicInfo.id, endpoint.id, "ENDPOINT_TIMING_SPLIT", $scope.epUIState.chartsTimeRange || "SIX_HOURS").success(function(spkData) {
                endpoint.succeededToLoadTiming = true;
                if (!spkData.length) {
                    spkData.push({
                        target: '',
                        datapoints: APIDeployerDeploymentUtils.buildZeroDatapoints($scope.epUIState.chartsTimeRange)
                    });
                }
                displayTimeChart(spkData, 'deployment-graph-processingtime');
            }).error(function(a,b,c) {
                endpoint.failedToLoadTiming = getErrorDetails(a,b,c);
            });
        }
    }

    $scope.$on("$destroy", function() {
        // ensure chart tooltips get removed when navigating elsewhere
        d3.selectAll('.nvtooltip').remove();
    });
});

app.controller('APIDeployerDeploymentHistoryController', function($scope, TopNav) {
    TopNav.setNoItem();
    TopNav.setLocation(TopNav.TOP_API_DEPLOYER, 'deployments', null, 'history');

    if (!$scope.deploymentSettings) {
        $scope.getDeploymentSettings();
    }
});


app.controller('APIDeployerDeploymentSettingsController', function($scope, $q, TaggingService, TopNav, DataikuAPI,
    CreateModalFromTemplate, GENERATION_MAPPING_STRATEGIES, GENERATION_MAPPING_MODES) {
    TopNav.setNoItem();
    TopNav.setLocation(TopNav.TOP_API_DEPLOYER, 'deployments', null, 'settings');

    $scope.generationsMappingModes = GENERATION_MAPPING_MODES;
    $scope.generationsMappingStrategies = GENERATION_MAPPING_STRATEGIES;

    $scope.uiState = {
        settingsPane: 'general'
    };

    let inlineContainerConfig = {
        name: "inline",
        type: "KUBERNETES",
        baseImageType: "EXEC",
        properties: [],
    };

    $scope.$watch("lightStatus", function() {
        if (!$scope.lightStatus) return;
        DataikuAPI.apideployer.infras.getLightStatus($scope.lightStatus.infraBasicInfo.id)
            .success(function(infraStatus) {
                if (infraStatus.isAdmin && $scope.lightStatus.infraBasicInfo.type === "K8S") {
                    DataikuAPI.apideployer.infras.getSettings($scope.lightStatus.infraBasicInfo.id)
                        .success(infra => {$scope.infra = infra;})
                        .error(setErrorInScope.bind($scope));
                }
            })
            .error(setErrorInScope.bind($scope));
    });

    $scope.getInlineContainerConfig = function() {
        if ($scope.infra) {
            inlineContainerConfig.kubernetesNamespace = $scope.infra.k8sNamespace;
            inlineContainerConfig.kubeCtlContext = $scope.infra.k8sContext;
            inlineContainerConfig.kubeConfigPath = $scope.infra.k8sConfigPath;
            inlineContainerConfig.properties = $scope.infra.k8sProperties;
            inlineContainerConfig.baseImage = $scope.infra.baseImageTag;
            inlineContainerConfig.repositoryURL = $scope.infra.registryHost;
            inlineContainerConfig.prePushMode = $scope.infra.prePushMode;
            inlineContainerConfig.prePushScript = $scope.infra.prePushScript;
        }
        return inlineContainerConfig; // return the same object to avoid never-ending $digest() issues
    };

    $scope.getAllTags = function () {
        var deferred = $q.defer();
        if (!$scope.hasOwnProperty("allProjectLevelTags")) {
            $scope.allProjectLevelTags = [];
            DataikuAPI.apideployer.deployments.listTags()
                .success(function(data) {
                    $scope.allProjectLevelTags = TaggingService.fillTagsMapFromArray(data);
                    deferred.resolve($scope.allProjectLevelTags);
                })
                .error(() => {
                    setErrorInScope.bind($scope);
                    deferred.resolve($scope.allProjectLevelTags);
                });
        }
        else {
            deferred.resolve($scope.allProjectLevelTags);
        }
        return getRewrappedPromise(deferred);
    };

    $scope.startEditTags  = function() {
        $scope.uiState.newTags = angular.copy($scope.deploymentSettings.tags);
        $scope.uiState.isEditingTags = true;
    };
    
    $scope.cancelEditTags  = function() {
        $scope.uiState.newTags = null;
        $scope.uiState.isEditingTags = false;
    };

    $scope.validateEditTags  = function() {
        if ($scope.uiState.isEditingTags) {
            $scope.deploymentSettings.tags = angular.copy($scope.uiState.newTags);
            $scope.uiState.isEditingTags = false;
        }
    };

    function editApiKey(isNew, apiKey) {
        return CreateModalFromTemplate("/templates/lambda/api-key-modal.html", $scope, null, mScope => { mScope.apiKey = apiKey; });
    }

    $scope.editAPIKey = editApiKey.bind(null, false);
    $scope.newAPIKey = function() {
        const apiKey = {
            createdOn: Date.now(),
            createdBy: $scope.appConfig.login
        };
        editApiKey(true, apiKey).then(k => { $scope.deploymentSettings.auth.apiKeys = $scope.deploymentSettings.auth.apiKeys || []; $scope.deploymentSettings.auth.apiKeys.push(apiKey); });
    };

    if (!$scope.deploymentSettings) {
        $scope.getDeploymentSettings();
    }
});


app.controller('APIDeployerTestQueriesController', function($scope, DataikuAPI, Assert, $stateParams) {
    Assert.inScope($scope, 'endpoint');

    $scope.getHeight =  function(q) {
        return Object.keys(q.features).length + 4;
    };

    function getGenericEndpointType(endpoint) {
        switch(endpoint.type) {
            case "STD_PREDICTION":
            case "CUSTOM_PREDICTION":
            case "CUSTOM_R_PREDICTION":
                return "predict";
            case "R_FUNCTION":
            case "PY_FUNCTION":
                return "function";
            case "SQL_QUERY":
                return "query";
            case "DATASETS_LOOKUP":
                return "lookup";
        }
    }

    $scope.$watch("endpoint", function(nv) {
        if (nv) {
            $scope.genericEndpointType = getGenericEndpointType(nv);
            delete $scope.testQueriesResult;
        }
    });

    $scope.uiState = {
        requestType: "EMPTY",
        queriesBatchSize: 1,
        inputDatasetSmartName: null
    };
    if (!$scope.endpoint.testQueries) {
        $scope.endpoint.testQueries = []
    }

    if ($scope.endpoint.testQueries.length > 0) {
        $scope.uiState.testQueryIndex = 0;
    }

    $scope.addQueries = function(requestType, queriesBatchSize, inputDatasetSmartName) {
        const newIndex = $scope.endpoint.testQueries.length;
        if (requestType === "EMPTY") {
            for (let i = 0; i < queriesBatchSize; i++) {
                $scope.endpoint.testQueries.push($scope.emptyTestQueryTemplate());
            }
        } else if (requestType === "DATASET") {
            DataikuAPI.lambda.services.getSampleQueriesFromDataset($stateParams.projectKey,
                inputDatasetSmartName, $scope.endpoint.modelRef, queriesBatchSize, "HEAD_SEQUENTIAL").success(function(data) {
                $scope.endpoint.testQueries.push.apply($scope.endpoint.testQueries, data);
            }).error(setErrorInScope.bind($scope));
        } else {
            setErrorInScope.bind($scope);
        }
        $scope.uiState.testQueryIndex = newIndex;
    };

    $scope.showTestQuery = function(index) {
        $scope.uiState.showUnsavedTestQuery = false;
        $scope.uiState.testQueryIndex = index;
    };

    $scope.showUnsavedTestQuery = function() {
        $scope.uiState.showUnsavedTestQuery = true;
        delete $scope.uiState.testQueryIndex;
    };

    $scope.getCollectedColumnMappings = function() {
        const mappings = {};
        $scope.endpoint.lookups.forEach(function(lookup) {
            angular.forEach(lookup.columnsMapping, function(v,k) {
                mappings[k] = v;
            });
        });
        return mappings;
    };

    $scope.runTestQueries = function() {
        const deploymentId = $scope.lightStatus.deploymentBasicInfo.id;
        const endpointId = $scope.endpoint.id;
        let unsavedTestQueries = {}
        $.each($scope.unsavedTestQueries, function(k, v) {
            if (v) {
                unsavedTestQueries[k] = { q: $scope.unsavedTestQueries[k] }
            }
        })
        DataikuAPI.apideployer.deployments.runTestQuery(deploymentId, endpointId, $scope.endpoint.testQueries, unsavedTestQueries)
            .success(function(testQueriesResult) {
                $scope.testQueriesResult = testQueriesResult;
            })
            .error(setErrorInScope.bind($scope));
    };
})

app.controller('APIDeployerDeploymentsDashboardController', function($scope, $controller, $state, $filter, WT1, APIDeployerAsyncHeavyStatusLoader, APIDeployerDeploymentUtils, APIDeployerDeploymentService) {
    $controller('_DeployerDeploymentDashboardController', {$scope});

    if ($scope.isFeatureLocked) return;

    $scope.uiState.query.healthStatusMap = [
        'HEALTHY',
        'WARNING',
        'UNHEALTHY',
        'ERROR',
        'UNKNOWN',
        'DISABLED',
        'LOADING_FAILED'
    ].map(hs => ({
        id: hs,
        $selected: false
    }));
    $scope.orderByExpression = ['serviceBasicInfo.id', (deployment) => $filter('deploymentToGenerationList')(deployment.deploymentBasicInfo), '-deploymentBasicInfo.enabled', 'deploymentBasicInfo.id'];
    
    $scope.stillRefreshing = function() {
        return !$scope.globalLightStatusLoaded || !loader || loader.stillRefreshing();
    };

    $scope.hasShownDeployments = function(deployments) {
        return deployments.length;
    };

    $scope.canCreateDeployments = function() {
        return true; //TODO @mad
    };

    $scope.startCreateDeployment = function() {
        APIDeployerDeploymentService.startCreateDeployment().then(function(newDeployment) {
            $state.go('apideployer.deployments.deployment.status', {deploymentId: newDeployment.id});
            WT1.event('api-deployer-deployment-create', {deploymentType: newDeployment.type });
        });
    };

    function filterOnSearchBarQuery(lightStatus) {
        if (!$scope.uiState.query.q) return true;
        const query = $scope.uiState.query.q.toLowerCase();
        return lightStatus.deploymentBasicInfo.publishedServiceId.toLowerCase().includes(query)
            || lightStatus.serviceBasicInfo.name.toLowerCase().includes(query)
            || APIDeployerDeploymentUtils.getParticipatingVersions(lightStatus.deploymentBasicInfo).join(', ').toLowerCase().includes(query)
            || lightStatus.deploymentBasicInfo.id.toLowerCase().includes(query)
            || lightStatus.deploymentBasicInfo.infraId.toLowerCase().includes(query)
            || lightStatus.deploymentBasicInfo.type.toLowerCase().includes(query);
    }

    $scope.deploymentIsInUI = function(lightStatus) {
        const selectedServices = $scope.uiState.query.services.filter(service => service.$selected);
        const selectedStatuses = $scope.uiState.query.healthStatusMap.filter(hs => hs.$selected);
        const deploymentHealthStatus = $scope.heavyStatusPerDeploymentId[lightStatus.deploymentBasicInfo.id];

        return filterOnSearchBarQuery(lightStatus) &&
            (!selectedServices.length || selectedServices.find(service => service.serviceBasicInfo.id === lightStatus.deploymentBasicInfo.publishedServiceId)) &&
            (!$scope.uiState.query.tags.length || $scope.uiState.query.tags.find(tag => lightStatus.deploymentBasicInfo.tags.find(deplTag => deplTag === tag))) &&
            (!selectedStatuses.length || selectedStatuses.find(hs => deploymentHealthStatus && deploymentHealthStatus.health === hs.id || hs.id === 'DISABLED' && !lightStatus.deploymentBasicInfo.enabled));
    };

    $scope.getFilteredDeploymentCountText = function(deployments) {
        const counts = getDeploymentsCounts(deployments.filter(deployment => $scope.deploymentIsInUI(deployment)));

        return (counts.disabled > 0 ? counts.enabled + '/' : '') + counts.total;
    };

    $scope.$watch('serviceStatusList', function(nv) { 
        if (!nv) return;

        $scope.uiState.query.services = angular.copy($scope.serviceStatusList);
    });

    function getDeploymentsCounts(deploymentsStatus) {
        const counts = {
            total: deploymentsStatus.length,
            enabled: deploymentsStatus.filter(ls => ls.deploymentBasicInfo.enabled).length,
        }
        counts.disabled = counts.total - counts.enabled;
        return counts;
    }

    let loader;
    $scope.$watch("deploymentsStatusList", function(nv) {
        if (!nv) return;
        $scope.hasCarbonAPIEnabled = $scope.deploymentsStatusList.some(deployment => deployment.infraBasicInfo.carbonAPIEnabled);
        $scope.deploymentsCounts = getDeploymentsCounts(nv);
        loader = APIDeployerAsyncHeavyStatusLoader.newLoader(nv.filter(_ => _.deploymentBasicInfo.enabled).map(_ => _.deploymentBasicInfo.id),
            $scope.heavyStatusPerDeploymentId);
        loader.loadAllHeavyStatus();
    });

    $scope.$on("$destroy", function() {
        loader.stopLoading();
    });
});


})();

(function() {
'use strict';

const app = angular.module('dataiku.apideployer');

app.service("APIDeployerDeploymentUtils", function() {
    var svc = {};

    svc.getParticipatingVersions = function(deploymentBasicInfo) {
        const dbi = deploymentBasicInfo;

        if (!dbi.generationsMapping) {
            return []; //TODO @mad make sure it does not happen in Java: initialise it to full last version or full specific version
        } else if (dbi.generationsMapping.mode == "SINGLE_GENERATION") {
            return [dbi.generationsMapping.generation];
        } else {
            return dbi.generationsMapping.entries.map(e => e.generation);
        }
    };

    svc.computeEndpointURLs = function(lightStatus, heavyStatus, endpoint) {
        function addEndpointSpecificSuffix(epURL) {
            switch (endpoint.type) {
                case "STD_PREDICTION":
                case "CUSTOM_PREDICTION":
                case "CUSTOM_R_PREDICTION":
                    return epURL + "/predict";
                case "PY_FUNCTION":
                case "R_FUNCTION":
                    return epURL + "/run";
                case "DATASETS_LOOKUP":
                    return epURL + "/lookup";
                case "SQL_QUERY":
                    return epURL + "/query";
            }
        }

        function removeURLTrailingSlashes(epURL) {
            let ret = epURL;
            while (ret.length > 0 && ret[ret.length - 1] == '/') {
                ret = ret.slice(0, ret.length - 1);
            }
            return ret;
        }

        const deplBI = lightStatus.deploymentBasicInfo;
        const infraBI = lightStatus.infraBasicInfo;
        const serviceId = deplBI.deployedServiceId || deplBI.publishedServiceId;
        const endpointId = endpoint.id;

        if (infraBI.type == "STATIC") {
            return infraBI.apiNodeUrls
                .map(removeURLTrailingSlashes)
                .map(apiNode => `${apiNode}/public/api/v1/${serviceId}/${endpointId}`)
                .map(addEndpointSpecificSuffix);
        } else {
            if (heavyStatus.publicURL) {
                const suffix = removeURLTrailingSlashes(heavyStatus.publicURL) + "/public/api/v1/" + serviceId + "/"  + endpointId;
                return [addEndpointSpecificSuffix(suffix)];
            } else {
                return [];
            }
        }
    };

    svc.buildZeroDatapoints = function(timeRange) {
        const now = Math.round(new Date().getTime() / 1000);
        let delta;
        switch (timeRange) {
            case "ONE_DAY":
                delta = 24 * 3600;
                break;
            case "ONE_HOUR":
                delta = 1 * 3600;
                break;
            case "SIX_HOURS":
            default:
                delta = 6 * 3600;
                break;
        }
        const ret = [];
        for (let i = 71; i >= 0; i--) {
            ret.push([null, Math.round(now-delta*i/71)]);
        }
        return ret;
    };

    return svc;
})

app.service('APIDeployerDeploymentService', function($rootScope, CreateModalFromTemplate) {
    this.startCreateDeployment = function(preselectedService, preselectedVersion) {
        return CreateModalFromTemplate("/templates/api-deployer/new-deployment-modal.html", $rootScope, null, function(modalScope) {
            modalScope.newDepl.publishedServiceId = preselectedService;
            modalScope.newDepl.versionId = preselectedVersion;
            modalScope.disabledServiceAndVersionInputs = !!(preselectedService && preselectedVersion);
        });
    };
});

app.service('StaticDeploymentSyncHelper', function(DataikuAPI, FutureProgressModal, CreateModalFromTemplate, ActivityIndicator) {
    function init(parentScope, lightStatus, askMode, refreshMode) {
        const $scope = parentScope.$new(); //TODO @apiDeployer gruik

        $scope.uiState = {
            refreshMode: "LIGHT"
        };

        $scope.runStep = function() {
            switch ($scope.uiState.nextStep) {
                case "ASK_MODE":
                    CreateModalFromTemplate("/templates/api-deployer/deploy-result-modal.html", $scope, null, function(modalScope) {
                        modalScope.close = modalScope.dismiss;
                    });
                    break;

                case "PREPARE":  {
                    DataikuAPI.apideployer.deployments.prepareSyncStatic(lightStatus.deploymentBasicInfo.id).success(function(data) {
                        FutureProgressModal.show($scope, data, "Deploying").then(function(result) {
                            if (result && result.nbNOKNodes == 0) {
                                $scope.uiState.nextStep = "DEPLOY";
                                $scope.runStep();
                            } else if (result && result.nbNOKNodes > 0) {
                                $scope.prepareResult = result;
                                $scope.uiState.nextStep = "PREPARE_FAILED";
                                $scope.runStep();
                            }
                        });
                    }).error(setErrorInScope.bind(parentScope));
                    break;
                }
                case "PREPARE_FAILED": {
                    CreateModalFromTemplate("/templates/api-deployer/deploy-result-modal.html", $scope, null, function(modalScope) {
                        modalScope.retryPrepare = function() {
                            modalScope.dismiss();
                            $scope.uiState.nextStep = "PREPARE";
                            $scope.runStep();
                        }
                        modalScope.close = function() {
                            modalScope.dismiss();
                            parentScope.refreshLightAndHeavy();
                            $scope.$destroy();
                        }
                        modalScope.deploy = function() {
                            modalScope.dismiss();
                            $scope.uiState.nextStep = "DEPLOY";
                            $scope.runStep();
                        }
                    });
                    break;
                }
                case "DEPLOY": {
                    DataikuAPI.apideployer.deployments.executeSyncStatic(lightStatus.deploymentBasicInfo.id, $scope.uiState.refreshMode == "FULL").success(function(data) {
                        FutureProgressModal.show($scope, data, "Deploying").then(function(result) {
                            if (result && result.nbNOKNodes == 0) {
                                // Done !
                                ActivityIndicator.success("Deployment updated successfully");
                                parentScope.refreshLightAndHeavy();
                                lightStatus.neverEverDeployed = false;
                                $scope.$destroy();
                            } else if (result && result.nbNOKNodes > 0) {
                                $scope.deployResult = result;
                                $scope.uiState.nextStep = "DEPLOY_FAILED";
                                $scope.runStep();
                            }
                        });
                    }).error(setErrorInScope.bind(parentScope));
                    break;
                }
                case "DEPLOY_FAILED": {
                    CreateModalFromTemplate("/templates/api-deployer/deploy-result-modal.html", $scope, null, function(modalScope) {
                        modalScope.retryDeploy = function() {
                            modalScope.dismiss();
                            $scope.uiState.nextStep = "DEPLOY";
                            $scope.runStep();
                        }
                        modalScope.close = function() {
                            modalScope.dismiss();
                            parentScope.refreshLightAndHeavy();
                            $scope.$destroy();
                        }
                    });
                    break;
                }
            }
        };
        if (askMode) {
            $scope.uiState.nextStep = "ASK_MODE";
        } else {
            $scope.uiState.refreshMode = refreshMode;
            $scope.uiState.nextStep = "PREPARE";
        }

        $scope.runStep();
    }
    return {
        init : init
    };
});

app.service("DeploymentStatusEndpointSampleCodeGenerator", function(Assert){
    var svc = {};

    svc.getFirstBaseURI = function(lightStatus, heavyStatus) {
        const infraBI = lightStatus.infraBasicInfo;
        if (infraBI.type == "STATIC") {
            return infraBI.apiNodeUrls[0];
        } else {
            return heavyStatus.publicURL;
        }
    };

    svc.getJSONExplanationsParams = function(endpoint) {
        const tq = (endpoint.testQueries || []).find(tq => tq.q && tq.q.explanations);
        return tq ? tq.q.explanations : undefined;
    }

    svc.getJSONData = function(endpoint) {
        let jsonData = null;
        switch (endpoint.type) {
        case "STD_PREDICTION":
        case "CUSTOM_PREDICTION":
        case "CUSTOM_R_PREDICTION": {
            if (endpoint.testQueries && endpoint.testQueries.length) {
                const tq = endpoint.testQueries[0];
                if (tq.q && "features" in tq.q) {
                    jsonData = tq.q.features;
                }
            }
            if (!jsonData) {
                jsonData = {
                    categorical_feature1 : "value1",
                    numerical_feature1: 42,
                    categorical_feature2: "value2"
                }
            }
            break;
        }
        case "PY_FUNCTION":
        case "R_FUNCTION":
        case "SQL_QUERY":
            if (endpoint.testQueries && endpoint.testQueries.length) {
                const tq = endpoint.testQueries[0];
                if (tq.q) {
                    jsonData = tq.q;
                }
            }
            if (!jsonData) {
                jsonData = {
                    param1 : "value1",
                    param2: 42
                };
            }
            break;
        case "DATASETS_LOOKUP":
            if (endpoint.testQueries && endpoint.testQueries.length) {
                const tq = endpoint.testQueries[0];
                if (tq.q && "data" in tq.q) {
                    jsonData = tq.q.data;
                }
            }
            if (!jsonData) {
                jsonData = {
                    string_key1 : "keyvalue1",
                    numerical_key2: 42
                };
            }
            break;
        }
        return jsonData;
    };
    svc.getAPIKeyToUse = function(ls) {
        if (!ls.publicAccess && ls.apiKeys.length) {
            return ls.apiKeys[0].key;
        } else {
            return null;
        }
    };

    svc.R_HANDLE_ERROR = '# Handle error if any\n\
if (response$status_code != 200) { \n\
    error_head <- paste0("Query failed (HTTP code ", response$status_code, "): "); \n\
    resp_content_type <- headers(response)$`content-type` \n\
    resp_content <- content(response) \n\
    if (resp_content_type == "application/json") { \n\
        error <- paste0(error_head, resp_content$message); \n\
    } else { \n\
        error <- paste0(error_head, resp_content); \n\
    }\n\
    stop(error); \n\
};\n\n';

    svc.JAVA_HEADER = 'import java.io.IOException;\n\
import java.nio.charset.StandardCharsets;\n\
\n\
import org.apache.commons.io.IOUtils;\n\
import org.apache.http.HttpResponse;\n\
import org.apache.http.client.methods.HttpPost;\n\
import org.apache.http.entity.StringEntity;\n\
import org.apache.http.impl.client.CloseableHttpClient;\n\
import org.apache.http.impl.client.HttpClients;\n\
import org.json.JSONObject;\n\
import org.json.JSONTokener;\n\
\n\
public class DataikuTest {\n\
    public static void main(String[] args) throws Exception{\n\
        try (CloseableHttpClient httpClient = HttpClients.createDefault()) { \n\
\n';

    svc.JAVA_HANDLE_ERROR = '\
            if (resp.getStatusLine().getStatusCode() != 200) {\n\
                if (resp.getEntity().getContentType().getValue().contains("application/json")){\n\
                    JSONObject error = new JSONObject(new JSONTokener(resp.getEntity().getContent()));\n\
            \n\
                    if (error.has("detailedMessage")) {\n\
                        throw new IOException("API query failed with HTTP code " + resp.getStatusLine().getStatusCode() +" and message: " + error.getString("detailedMessage"));\n\
                    } else {\n\
                        throw new IOException("API query failed with HTTP code " + resp.getStatusLine().getStatusCode() +" and body: " + error.toString());\n\
                    }\n\
                } else {\n\
                    String s = IOUtils.toString(resp.getEntity().getContent(), StandardCharsets.UTF_8);\n\
                    throw new IOException("API query failed with HTTP code " + resp.getStatusLine().getStatusCode() +" and body: " + s);\n\
                }\n\
            }\n\
\n';

    svc.JAVA_SET_BODY_AND_RUN = '\
            StringEntity bodyEntity = new StringEntity(body.toString());\n\
            request.setEntity(bodyEntity);\n\
            request.addHeader("content-type", "application/json");\n\
    \n\
            /* Execute the query */\n\
            HttpResponse resp = httpClient.execute(request);\n\
\n';

    svc.JAVA_FOOTER = '\
        }\n\
    }\n\
}';
    function jsonToRList(jsonData) {
        let res = "list(\n";
        let i = 0;
        for (let key of Object.keys(jsonData)) {
            if (i > 0) res +=",\n";
            i++;
            let value;
            if (typeof jsonData[key] === "boolean") {
                value = jsonData[key] ? "TRUE" : "FALSE";
            } else {
                value = JSON.stringify(jsonData[key]);
            }
            res +="    " + key + " = " + value;

        }
        res += ")\n\n";
        return res
    }

    svc.generateSampleCode = function(ls, serviceURLs, endpoint, language, hs) {
        Assert.trueish(serviceURLs.length > 0);
        if (language == "CURL") {
            const jsonData = svc.getJSONData(endpoint);
            let prettyJSON = JSON.stringify(jsonData, undefined, 4);
            let jsonAsCURLLines = prettyJSON.split("\n");
            if (jsonAsCURLLines.length > 2) {
                jsonAsCURLLines = jsonAsCURLLines.slice(1, jsonAsCURLLines.length - 1);
            }

            let code = "";
            code = "curl -X POST";
            if (!ls.publicAccess && ls.apiKeys.length) {
                code += " --user " + ls.apiKeys[0].key + ":"
            }
            code += " \\\n";
            code += "  " + serviceURLs[0] + " \\\n";

            switch (endpoint.type) {
            case "STD_PREDICTION":
            case "CUSTOM_PREDICTION":
            case "CUSTOM_R_PREDICTION": {
                code += "  --data '{ \"features\" : {\n";
                jsonAsCURLLines.forEach(line => code += line + "\n");
                code += "  }";
                const explanationsParamsJSON = svc.getJSONExplanationsParams(endpoint);
                if (explanationsParamsJSON) {
                    code += ', "explanations": ' + JSON.stringify(explanationsParamsJSON, undefined, 4);
                }
                code += "}'";
                return {
                    mode: "shell",
                    code:code
                };
            }
            case "PY_FUNCTION":
            case "R_FUNCTION":
            case "SQL_QUERY":
                code += "  --data '{\n";
                jsonAsCURLLines.forEach(line => code += line + "\n");
                code += "  }'";
                return {
                    mode: "shell",
                    code:code
                };
            case "DATASETS_LOOKUP":
                code += "  --data '{ \"data\" : {\n";
                jsonAsCURLLines.forEach(line => code += line + "\n");
                code += "  }}'";
                return {
                    mode: "shell",
                    code:code
                };
            }
        } else if (language == "PYTHON") {
            const jsonData = svc.getJSONData(endpoint);
            const baseURI = svc.getFirstBaseURI(ls, hs);
            const apiKeyToUse = svc.getAPIKeyToUse(ls);
            const ret = {
                mode: "python"
            };
            let code = "";
            code += "import dataikuapi\n\n";
            code += "client = dataikuapi.APINodeClient(\"" + baseURI + "\", \""
                + (ls.deploymentBasicInfo.deployedServiceId || ls.deploymentBasicInfo.publishedServiceId) + "\"";
            if (apiKeyToUse) {
                code += ", \""  +apiKeyToUse + "\"";
            }
            code += ")\n\n";

            ret.instructions = "You need to install the ``dataiku-api-client`` Python package for this to work.\n\n";
            ret.instructions += "If you are querying from within DSS, this package is already installed. Else, follow ";
            ret.instructions += "[these instructions](https://doc.dataiku.com/dss/latest/publicapi/client-python/)";
            switch (endpoint.type) {
            case "STD_PREDICTION":
            case "CUSTOM_PREDICTION":
            case "CUSTOM_R_PREDICTION": {
                code += "record_to_predict = {\n";
                let prettyJSON = JSON.stringify(jsonData, undefined, 4);
                let jsonAsCURLLines = prettyJSON.split("\n");
                if (jsonAsCURLLines.length > 2) {
                    jsonAsCURLLines = jsonAsCURLLines.slice(1, jsonAsCURLLines.length - 1);
                }
                jsonAsCURLLines.forEach(line => code += line + "\n");
                code += "}\n";

                code += `prediction = client.predict_record("${endpoint.id}", record_to_predict`;
                const explanationsParamsJSON = svc.getJSONExplanationsParams(endpoint);
                if (explanationsParamsJSON) {
                    if (explanationsParamsJSON.enabled) {
                        code += ", with_explanations=True";
                    } else if(explanationsParamsJSON.enabled === false) {
                        code += ", with_explanations=False";
                    }
                    if (explanationsParamsJSON.nExplanations) {
                        code += ", n_explanations="+explanationsParamsJSON.nExplanations;
                    }
                    if (explanationsParamsJSON.method) {
                        code += `, explanation_method="${explanationsParamsJSON.method}"`;
                    }
                    if (explanationsParamsJSON.nMonteCarloSteps) {
                        code += ", n_explanations_mc_steps="+explanationsParamsJSON.nMonteCarloSteps;
                    }
                }

                code += ")\n";

                code += "print(prediction[\"result\"])\n";
                ret.code = code;
                return ret;
            }
            case "PY_FUNCTION":
            case "R_FUNCTION": {
                code += "result = client.run_function(\"" + endpoint.id + "\"";
                for (let key of Object.keys(jsonData)) {
                    code +=",\n";
                    code +="        " + key + " = " + JSON.stringify(jsonData[key]);
                }
                code += ")\n";
                code += "print(\"Function result: %s\" % result.get(\"response\"))\n";
                ret.code = code;
                return ret;
            }
            case "DATASETS_LOOKUP": {
                code += "lookup_keys = {\n";
                let prettyJSON = JSON.stringify(jsonData, undefined, 4);
                let jsonAsCURLLines = prettyJSON.split("\n");
                if (jsonAsCURLLines.length > 2) {
                    jsonAsCURLLines = jsonAsCURLLines.slice(1, jsonAsCURLLines.length - 1);
                }
                jsonAsCURLLines.forEach(line => code += line + "\n");
                code += "}\n";

                code += "lookup_result = client.lookup_record(\"" + endpoint.id + "\", lookup_keys)\n";
                code += "print(lookup_result[\"data\"])\n";
                ret.code = code;
                return ret;
            }
            case "SQL_QUERY": {
                code += "query_parameters = {\n";
                let prettyJSON = JSON.stringify(jsonData, undefined, 4);
                let jsonAsCURLLines = prettyJSON.split("\n");
                if (jsonAsCURLLines.length > 2) {
                    jsonAsCURLLines = jsonAsCURLLines.slice(1, jsonAsCURLLines.length - 1);
                }
                jsonAsCURLLines.forEach(line => code += line + "\n");
                code += "}\n";

                code += "query_result = client.sql_query(\"" + endpoint.id + "\", query_parameters)\n";
                code += "print(query_result)\n";
                ret.code = code;
                return ret;
            }
            }
        } else if (language == "R") {
            const jsonData = svc.getJSONData(endpoint);
            const baseURI = svc.getFirstBaseURI(ls, hs);
            const apiKeyToUse = svc.getAPIKeyToUse(ls);
            const ret = {
                mode: "r"
            };
            let code = "library(httr)\nlibrary(jsonlite)\n\n";

            ret.instructions = "You need to have the ``httr`` R package installed.\n";
            ret.instructions += "If you are querying from within DSS, this package is already installed.";
            switch (endpoint.type) {
            case "STD_PREDICTION":
            case "CUSTOM_PREDICTION":
            case "CUSTOM_R_PREDICTION": {
                const explanationsParamsJSON = this.getJSONExplanationsParams(endpoint);
                if (explanationsParamsJSON) {
                    code += "explanations_params = "+ jsonToRList(explanationsParamsJSON);
                }
                code += "record_to_predict = "+ jsonToRList(jsonData);
                code += "response <- POST(\"" + serviceURLs[0] +"\",\n";
                if (apiKeyToUse) {
                    code += "                    authenticate(\""  +apiKeyToUse + "\", \"\"),\n";
                }
                if (explanationsParamsJSON) {
                    code += "                    body = toJSON(list(features=record_to_predict, explanations=explanations_params), auto_unbox=TRUE))\n\n";
                } else {
                    code += "                    body = toJSON(list(features=record_to_predict), auto_unbox=TRUE))\n\n";
                }
                
                code += svc.R_HANDLE_ERROR;

                code += "result <- content(response)\n";
                code += "print(paste0(\"Prediction: \", toJSON(result$result)))\n";
                ret.code = code;
                return ret;
            }
            case "PY_FUNCTION":
            case "R_FUNCTION":
                code += "function_params = list(\n";
                let i = 0;
                for (let key of Object.keys(jsonData)) {
                    if (i > 0) code +=",\n";
                    i++;
                    code +="    " + key + " = " + JSON.stringify(jsonData[key]);
                }
                code += ")\n\n";

                code += "response <- POST(\"" + serviceURLs[0] +"\",\n";
                if (apiKeyToUse) {
                    code += "                    authenticate(\""  +apiKeyToUse + "\", \"\"),\n";
                }
                code += "                    body = toJSON(function_params, auto_unbox=TRUE))\n\n";

                code += svc.R_HANDLE_ERROR;

                code += "result <- content(response)\n";
                code += "print(paste0(\"Function result: \", result$response))\n";
                ret.code = code;
                return ret;
            case "DATASETS_LOOKUP": {
                code += "lookup_keys = list(\n";
                let i = 0;
                for (let key of Object.keys(jsonData)) {
                    if (i > 0) code +=",\n";
                    i++;
                    code +="    " + key + " = " + JSON.stringify(jsonData[key]);
                }
                code += ")\n\n";

                code += "response <- POST(\"" + serviceURLs[0] +"\",\n";
                if (apiKeyToUse) {
                    code += "                    authenticate(\""  +apiKeyToUse + "\", \"\"),\n";
                }
                code += "                    body = toJSON(list(data=lookup_keys), auto_unbox=TRUE))\n\n";

                code += svc.R_HANDLE_ERROR;

                code += "result <- content(response)\n";
                code += "print(paste0(\"Looked up: \", toJSON(result$data)))\n";
                ret.code = code;
                return ret;
            }
            case "SQL_QUERY": {
                code += "query_params = list(\n";
                let i = 0;
                for (let key of Object.keys(jsonData)) {
                    if (i > 0) code +=",\n";
                    i++;
                    code +="    " + key + " = " + JSON.stringify(jsonData[key]);
                }
                code += ")\n\n";

                code += "response <- POST(\"" + serviceURLs[0] +"\",\n";
                if (apiKeyToUse) {
                    code += "                    authenticate(\""  +apiKeyToUse + "\", \"\"),\n";
                }
                code += "                    body = toJSON(query_params, auto_unbox=TRUE))\n\n";

                code += svc.R_HANDLE_ERROR;

                code += "result <- content(response)\n";
                code += "print(paste0(\"Query results: \", result))\n";
                ret.code = code;
                return ret;
            }
            }
        } else if (language == "JAVA") {
            const jsonData = svc.getJSONData(endpoint);
            const baseURI = svc.getFirstBaseURI(ls, hs);
            const apiKeyToUse = svc.getAPIKeyToUse(ls);
            const ret = {
                mode: "javascript" // Acceptable substitute for Java
            };
            let code = svc.JAVA_HEADER;

            code += "            HttpPost request = new HttpPost(\"" + serviceURLs[0] + "\");\n\n";

            if (apiKeyToUse) {
                code += "            /* Handle authentication */\n";
                code += "            String headerValue = \"" + apiKeyToUse + ":\";\n";
                code += '            String encodedHeaderValue = java.util.Base64.getEncoder().encodeToString(headerValue.getBytes(StandardCharsets.UTF_8));\n';
                code += '            String header =  "Basic "  + encodedHeaderValue;\n';
                code += '            request.addHeader("authentication", "header");\n';
            }

            function jsonDataToJSONObject(objName, json) {
                code += "            JSONObject " + objName + " = new JSONObject();\n";
                for (let key of Object.keys(json)) {
                    code +="            "+ objName + ".put(\"" + key + "\", " + JSON.stringify(json[key]) + ");\n";
                }
                code += "\n";
            }

            ret.instructions = "You need to have the ``httpclient`` 4.3 or higher and ``org.json`` packages installed.\n";
            code += "            /* Build the JSON POST Body */\n";

            switch (endpoint.type) {
            case "STD_PREDICTION":
            case "CUSTOM_PREDICTION":
            case "CUSTOM_R_PREDICTION": {
                jsonDataToJSONObject("recordToPredict", jsonData);
                const explanationsParamsJSON = svc.getJSONExplanationsParams(endpoint)
                if (explanationsParamsJSON) {
                    jsonDataToJSONObject("explanationsParams", explanationsParamsJSON)
                }
                code += '            JSONObject body = new JSONObject();\n';
                code += '            body.put("features", recordToPredict);\n';
                if (explanationsParamsJSON) {
                    code += '            body.put("explanations", explanationsParams);\n';
                }
                code += svc.JAVA_SET_BODY_AND_RUN;
                code += svc.JAVA_HANDLE_ERROR;
                code += '            /* Parse result */\n';
                code += '            JSONObject result = new JSONObject(new JSONTokener(resp.getEntity().getContent()));\n';
                code += '            System.out.println("Model returned:\\n" + result + "\\n");\n';
                code += svc.JAVA_FOOTER;
                ret.code = code;
                return ret;
            }
            case "PY_FUNCTION":
            case "R_FUNCTION":
                jsonDataToJSONObject("body", jsonData);
                code += svc.JAVA_SET_BODY_AND_RUN;
                code += svc.JAVA_HANDLE_ERROR;
                code += '            /* Parse result */\n';
                code += '            JSONObject result = new JSONObject(new JSONTokener(resp.getEntity().getContent()));\n';
                code += '            System.out.println("Function returned:\\n" + result + "\\n");\n';
                code += svc.JAVA_FOOTER;
                ret.code = code;
                return ret;
            case "DATASETS_LOOKUP": {
                jsonDataToJSONObject("lookupKeys", jsonData);
                code += '            JSONObject body = new JSONObject();\n';
                code += '            body.put("data", lookupKeys);\n';
                code += svc.JAVA_SET_BODY_AND_RUN;
                code += svc.JAVA_HANDLE_ERROR;
                code += '            /* Parse result */\n';
                code += '            JSONObject result = new JSONObject(new JSONTokener(resp.getEntity().getContent()));\n';
                code += '            System.out.println("Lookup returned:\\n" + result + "\\n");\n';
                code += svc.JAVA_FOOTER;
                ret.code = code;
                return ret;
            }
            case "SQL_QUERY":
                jsonDataToJSONObject("body", jsonData);
                code += svc.JAVA_SET_BODY_AND_RUN;
                code += svc.JAVA_HANDLE_ERROR;
                code += '            /* Parse result */\n';
                code += '            JSONObject result = new JSONObject(new JSONTokener(resp.getEntity().getContent()));\n';
                code += '            System.out.println("Query returned:\\n" + result + "\\n");\n';
                code += svc.JAVA_FOOTER;
                ret.code = code;
                return ret;
            }
        }
        return code;
    };
    return svc;
})

app.constant('GENERATION_MAPPING_STRATEGIES', [
    {id: 'RANDOM', name: 'Random'},
    {id: 'HASH_BASED', 'name': 'Hash based'}
]);


app.constant('GENERATION_MAPPING_MODES', [
    {id: 'SINGLE_GENERATION', name: 'Single generation'},
    {id: 'MULTI_GENERATION', 'name': 'Multiple generations'}
]);

app.filter("deploymentToGenerationList", function(APIDeployerDeploymentUtils) {
    return function(deploymentBasicInfo) {
        if (!deploymentBasicInfo) {
            return;
        }
        return APIDeployerDeploymentUtils.getParticipatingVersions(deploymentBasicInfo).join(', ');
    };
});

})();

(function() {
    'use strict';

    const app = angular.module('dataiku.projectdeployer', []);

    app.controller('ProjectDeployerController', function($scope, $rootScope, DeployerUtils, DataikuAPI) {
        $scope.DeployerUtils = DeployerUtils;
        $scope.deployerType = 'project';
        $scope.publishedItemType = 'project';
        $scope.deployerAPIBase = DataikuAPI.projectdeployer;
        $scope.stages = [].concat($rootScope.appConfig.projectDeploymentStages);
        $scope.isFeatureLocked = !($rootScope.appConfig.licensedFeatures.bundlesAllowed || $rootScope.appConfig.licensing.ceEntrepriseTrial);
    });
}());

(function() {
    'use strict';
    
    const app = angular.module('dataiku.projectdeployer');
    
    app.service("ProjectDeployerProjectUtils", function() {
        const svc = {};

        svc.getBundleOriginInfo = function(designNodeInfo) {
            const originInfo = {};

            if (designNodeInfo) {
                originInfo.projectKey = designNodeInfo.projectKey;
                if (designNodeInfo.url) {
                    originInfo.url = designNodeInfo.url;
                    if (originInfo.url.substr(-1) !== '/') {
                        originInfo.url += '/';
                    }
                    originInfo.url += 'projects/' + originInfo.projectKey + '/';
                }
            }
            return originInfo;
        };

        return svc;
    });

    app.controller('ProjectDeployerProjectsController', function(TopNav, $scope) {
        TopNav.setNoItem();
        TopNav.setLocation(TopNav.TOP_PROJECT_DEPLOYER, 'projects');
    });

    app.controller('ProjectDeployerProjectListController', function($scope, $state, DataikuAPI, WT1,
        CreateModalFromTemplate, ProjectDeployerProjectUtils, DeployerUtils, ActivityIndicator) {
        if ($scope.isFeatureLocked) return;

        const MAX_STAGE_COUNT = 3;
        let showOthersColumn = false;
        $scope.uiState = $scope.uiState || {};

        $scope.refreshProjectList = function() {
            DataikuAPI.projectdeployer.publishedProjects.listLightStatus()
                .success(projectStatusList => {
                    $scope.projectStatusList = projectStatusList;
                    $scope.canUploadBundles = $scope.appConfig.globalPermissions.mayCreatePublishedProjects;
                    $scope.currentStages = DeployerUtils.getStagesToDisplay(projectStatusList, $scope.stages, MAX_STAGE_COUNT);

                    projectStatusList.forEach(project => {
                        // check if the user can upload a bundle
                        $scope.canUploadBundles = $scope.canUploadBundles || project.canWrite;

                        // compute number of deployments per published project per stage
                        project.deploymentCountPerStage = DeployerUtils.getDeploymentCountsPerPublishedItemAndStage(project, $scope.stages, $scope.currentStages);
                        showOthersColumn = showOthersColumn || !!project.deploymentCountPerStage.counts['__OTHERS__'];

                        if (project.packages.length > 0) {
                            // The bundles are sorted by the publishedBy field in the backend, so the latest bundle is also
                            // the last element of the packages array
                            const latestBundle = project.packages.slice(-1).pop();
                            project.originInfo = ProjectDeployerProjectUtils.getBundleOriginInfo(latestBundle.designNodeInfo);
                          
                            project.lastPublishInfo = {
                                publishedOn: latestBundle.publishedOn,
                                publishedBy: latestBundle.publishedBy
                            };
                        }
                    });

                    // don't show others column if there aren't any grouped/unknown stages
                    if (!showOthersColumn) {
                        $scope.currentStages = $scope.currentStages.filter(stage => stage.id !== '__OTHERS__');
                    }
                })
                .error(setErrorInScope.bind($scope));
        };

        $scope.openUploadBundleModal = function() {
            CreateModalFromTemplate("/templates/project-deployer/upload-bundle-modal.html", $scope, "ProjectDeployerUploadBundleController", function(newScope) {
                newScope.publishedProjects = $scope.projectStatusList.filter(projectStatus => projectStatus.canWrite).sort((a, b) => a.projectBasicInfo.name.localeCompare(b.projectBasicInfo.name));
                if ($scope.appConfig.globalPermissions.mayCreatePublishedProjects) {
                    newScope.publishedProjects.unshift({
                        createProjectMessage: "Create a new project...",
                        projectBasicInfo: {}
                    });
                    newScope.publishedProjectKeys = newScope.publishedProjects.map(function(projectStatus) {
                        if (projectStatus.projectBasicInfo.id === projectStatus.projectBasicInfo.name) return "";
                        return projectStatus.projectBasicInfo.id;
                    });
                }
            }).then(function(projectKey) {
                ActivityIndicator.success("Bundle(s) uploaded successfully.");
                WT1.event('project-deployer-upload-package');
                $state.go("projectdeployer.projects.project.home.status", {publishedProjectKey: projectKey});
            });
        };

        $scope.filterProject = function(project) {
            if (!$scope.uiState.query) return true;
            const query = $scope.uiState.query.toLowerCase();
            return project.originInfo && project.originInfo.projectKey.toLowerCase().includes(query)
                || project.projectBasicInfo.id.toLowerCase().includes(query)
                || project.projectBasicInfo.name.toLowerCase().includes(query)
                || project.lastPublishInfo && project.lastPublishInfo.publishedBy.toLowerCase().includes(query);
        }

        $scope.refreshProjectList();
    });

    app.controller('ProjectDeployerProjectController', function($scope, $state, DataikuAPI, Dialogs, WT1, CreateModalFromTemplate, ActivityIndicator) {
        $scope.ui = {};

        $scope.refreshProjectSettings = function() {
            DataikuAPI.projectdeployer.publishedProjects.getSettings($state.params.publishedProjectKey)
                .success(settings => {
                    $scope.publishedProject = settings;
                    $scope.ui.ownerLogin = $scope.publishedProject.owner;
                    $scope.originalPublishedProject = angular.copy(settings);
                })
                .error(setErrorInScope.bind($scope));
        }

        $scope.refreshProjectStatus = function() {
            DataikuAPI.projectdeployer.publishedProjects.getLightStatus($state.params.publishedProjectKey)
                .success(status => {
                    $scope.projectStatus = status;
                })
                .error(setErrorInScope.bind($scope));
        };

        $scope.redirectToProject = function(project, event) {
            $state.go("projectdeployer.projects.project.home.status",
                { publishedProjectKey: project.projectBasicInfo.id });
            event.stopPropagation();
        }

        $scope.openUploadBundleModal = function() {
            if (!$scope.projectStatus) return;
            $scope.presetProjectKey = $scope.projectStatus.projectBasicInfo.id;
            CreateModalFromTemplate("/templates/project-deployer/upload-bundle-modal.html", $scope, "ProjectDeployerUploadBundleController").then(function() {
                $scope.refreshProjectStatus();
                ActivityIndicator.success("Bundle(s) uploaded successfully.");
                WT1.event('project-deployer-upload-package');
            });
        };

        $scope.deleteProject = function() {
            if (!$scope.projectStatus) {
                return;
            }
            if ($scope.projectStatus.deployments.length) {
                Dialogs.error($scope, 'Delete project', 'You cannot delete this project because it has deployments!');
                return;
            }
            Dialogs.confirm($scope, 'Delete project','Are you sure you want to delete this project?').then(function() {
                DataikuAPI.projectdeployer.publishedProjects.delete($scope.projectStatus.projectBasicInfo.id)
                    .success(() => {
                        ActivityIndicator.success(`Project ${$scope.projectStatus.projectBasicInfo.id} successfully deleted.`)
                        $state.go('projectdeployer.projects.list');
                    })
                    .error(setErrorInScope.bind($scope));
            });
        };
    });

    app.controller('ProjectDeployerProjectStatusController', function($scope, TopNav, DeployerUtils, ProjectDeployerProjectUtils) {
        TopNav.setNoItem();
        TopNav.setLocation(TopNav.TOP_PROJECT_DEPLOYER, 'projects', null, 'status');

        $scope.refreshProjectStatus();

        $scope.uiState = {
            query: ''
        };

        const MAX_STAGE_COUNT = 3;
        $scope.$watch('projectStatus', function(nv, ov) {
            if (nv) {
                $scope.currentStages = DeployerUtils.getStagesToDisplay([$scope.projectStatus], $scope.stages, MAX_STAGE_COUNT);
                const deploymentsPerPackageAndStage = DeployerUtils.getDeploymentsPerPackageAndStage($scope.projectStatus, $scope.stages, $scope.currentStages, 'bundle');

                $scope.projectStatus.packages.forEach(bundle => {
                    bundle.originInfo = ProjectDeployerProjectUtils.getBundleOriginInfo(bundle.designNodeInfo);
                    bundle.stages = deploymentsPerPackageAndStage[bundle.id];
                });
            }
        });
    });

    app.controller('ProjectDeployerProjectSettingsController', function($scope, $controller, TopNav, DataikuAPI, PermissionsService) {
        $controller('_DeployerPermissionsController', {$scope: $scope});

        TopNav.setNoItem();
        TopNav.setLocation(TopNav.TOP_PROJECT_DEPLOYER, 'projects', null, 'settings');

        $scope.uiState = {
            active: 'permissions'
        };

        $scope.saveProject = function() {
            if (!$scope.publishedProject || !$scope.projectIsDirty()) return;
            DataikuAPI.projectdeployer.publishedProjects.save($scope.publishedProject)
                .success(function() {
                    $scope.refreshProjectStatus();
                    $scope.refreshProjectSettings();
                })
                .error(setErrorInScope.bind($scope));
        };
    
        $scope.projectIsDirty = function() {
            return !angular.equals($scope.originalPublishedProject, $scope.publishedProject);
        };

        const deregister = $scope.$watch("publishedProject", function(nv, ov) {
            if (!nv) return;
            $scope.initPermissions($scope.publishedProject, {
                read: true,
                write: false,
                deploy: false,
                admin: false
            }, true);
            deregister();
        }, false);

        $scope.$watch("publishedProject.permissions", function(nv, ov) {
            if (!nv) return;
            $scope.onPermissionChange($scope.publishedProject);
        }, true);

        $scope.$watch("publishedProject.permissions", function(nv, ov) {
            if (!nv) return;
            $scope.onPermissionChange($scope.publishedProject);
        }, false);

        $scope.$watch("ui.ownerLogin", function() {
            PermissionsService.transferOwnership($scope, $scope.publishedProject, "project");
        });

        $scope.refreshProjectStatus();
        $scope.refreshProjectSettings();

        checkChangesBeforeLeaving($scope, $scope.projectIsDirty);
    });

    app.controller('ProjectDeployerProjectHistoryController', function($scope, TopNav) {
        TopNav.setNoItem();
        TopNav.setLocation(TopNav.TOP_PROJECT_DEPLOYER, 'projects', null, 'history');
    
        $scope.refreshProjectStatus();
        $scope.refreshProjectSettings();
    });

    app.controller('ProjectDeployerBundleController', function($scope, $state, $q, DataikuAPI, WT1, Dialogs, ActivityIndicator, DeployerUtils, ProjectDeployerProjectUtils) {
        const projectKey = $state.params.publishedProjectKey;
        const bundleId = $state.params.bundleId;
        const MAX_STAGE_COUNT = 3;

        $scope.bundleDeployments = {};

        $scope.refreshBundle = function() {
            const bundle = DataikuAPI.projectdeployer.publishedProjects.getBundleDetails(projectKey, bundleId)
            .success(bundleDetails => {
                $scope.bundleDetails = bundleDetails;
            })
            .error(setErrorInScope.bind($scope));
            
            $scope.bundleDeployments = {};
            const infraStagesById = DeployerUtils.getInfraStagesById($scope.projectStatus, $scope.stages);
            $scope.projectStatus.deployments
                .filter(deployment => deployment.bundleId === bundleId)
                .forEach(function(deployment) {
                    const stage = infraStagesById[deployment.infraId];
                    $scope.bundleDeployments[stage] = $scope.bundleDeployments[stage] || [];

                    $scope.bundleDeployments[stage].push({
                        infraBasicInfo: $scope.projectStatus.infras.find(infra => infra.id === deployment.infraId),
                        deploymentBasicInfo: deployment,
                        projectBasicInfo: $scope.projectStatus.projectBasicInfo
                    });
                });

            // only use stages that have any deployments
            const usedStages = $scope.stages.filter(stage => Object.keys($scope.bundleDeployments).includes(stage.id));
            $scope.currentStages = DeployerUtils.addOthersStage(usedStages.slice(0, MAX_STAGE_COUNT));

            $scope.deploymentsPerStage = DeployerUtils.getDeploymentsPerPackageAndStage($scope.projectStatus, $scope.stages, $scope.currentStages, 'bundle')[bundleId];

            const packageInfo = $scope.projectStatus.packages.find(pkg => pkg.id === bundleId);
            if (packageInfo) {
                $scope.publishedOn = packageInfo.publishedOn;
                $scope.publishedBy = packageInfo.publishedBy;
                $scope.originInfo = ProjectDeployerProjectUtils.getBundleOriginInfo(packageInfo.designNodeInfo);
            }

            return $q.all(bundle, $scope.projectStatus);
        };

        $scope.hasProjectConfig = function() {
            if (!$scope.bundleDetails) return;
            return Object.values($scope.bundleDetails.configContent).some(configTypeCount => !!configTypeCount);
        }

        $scope.hasAdditionalContent = function() {
            if (!$scope.bundleDetails) return;
            return ($scope.bundleDetails.includedDatasets || []).length + ($scope.bundleDetails.includedManagedFolders || []).length
                + ($scope.bundleDetails.includedSavedModels || []).length + ($scope.bundleDetails.includedModelEvaluationStores || []).length;
        }

        $scope.hasDeployments = function() {
            return Object.keys($scope.bundleDeployments).length;
        }

        $scope.deleteBundle = function() {
            if ($scope.deploymentsPerStage.count) {
                Dialogs.error($scope, 'Delete bundle', 'You cannot delete this bundle because it still has deployments!');
                return;
            }
            Dialogs.confirm($scope, 'Delete bundle ' + bundleId, 'Are you sure you want to delete this bundle?').then(function() {
                DataikuAPI.projectdeployer.publishedProjects.deleteBundle(projectKey, bundleId)
                .success(() => {
                    ActivityIndicator.success(`Bundle ${bundleId} successfully deleted.`)
                    $state.go('projectdeployer.projects.project.home.status', {publishedProjectKey: projectKey});
                })
                .error(setErrorInScope.bind($scope));
                WT1.event('project-deployer-packages-delete');
            });
        };
    });

    app.controller('ProjectDeployerBundleStatusController', function($scope, $state, DataikuAPI, ProjectDeployerProjectsService, ProjectDeployerAsyncHeavyStatusLoader, DeployerDeploymentTileService, DeployerUtils) {
        $scope.heavyStatusByDeploymentId = {};

        $scope.refreshProjectStatus();

        $scope.deployBundle = function() {
            ProjectDeployerProjectsService.deployBundle($scope.projectStatus, $state.params.bundleId, DeployerUtils.DEPLOY_SOURCE.PACKAGE);
        };

        $scope.$watch("projectStatus", function(ov, nv) {
            if ($scope.projectStatus) {
                $scope.refreshBundle();
            }
        });

        DataikuAPI.projectdeployer.infras.listLightStatus()
            .success(function(infraStatusList) {
                $scope.infraStatusList = infraStatusList;
            }).error(setErrorInScope.bind($scope));

        $scope.$watch('bundleDeployments', (nv) => {
            if (!$scope.bundleDeployments || !Object.keys($scope.bundleDeployments).length) return;

            const pseudoInfraLightStatusMap = {};
            for (let stage in $scope.bundleDeployments) {
                $scope.bundleDeployments[stage].forEach(deployment => {
                    const infraBasicInfo = deployment.infraBasicInfo;
                    if (!(infraBasicInfo.id in pseudoInfraLightStatusMap)) {
                        pseudoInfraLightStatusMap[infraBasicInfo.id] = {
                            infraBasicInfo,
                            deployments: []
                        };
                    }
                    pseudoInfraLightStatusMap[infraBasicInfo.id].deployments.push(deployment.deploymentBasicInfo);
                });
            }

            const heavyStatusByDeploymentId = {};
            let loader = ProjectDeployerAsyncHeavyStatusLoader.newLoader(Object.values(pseudoInfraLightStatusMap), heavyStatusByDeploymentId);
            loader.loadHeavyStatus();

            const deregister = $scope.$watch(function(){
                return loader.stillRefreshing();
            }, function(nv, ov) {
                if (nv || ov === nv) return;
                $scope.heavyStatusByDeploymentId = heavyStatusByDeploymentId;
                $scope.healthMap = DeployerDeploymentTileService.getDeploymentHealthMap($scope.projectStatus.deployments, heavyStatusByDeploymentId);
                deregister();
            });

            $scope.$on('$destroy', function() {
                loader && loader.stopLoading();
            });
        });
    });

    app.controller('ProjectDeployerUploadBundleController', function($scope, DataikuAPI, $controller) {
        $controller("_DeployerUploadPackageController", {$scope:$scope});
        if (!$scope.presetProjectKey) {
            $scope.uiState.useBundleProjectKey = true;

            $scope.$watch('uiState.useBundleProjectKey', function(nv, ov) {
                if (nv) {
                    delete $scope.uiState.overridingProject;
                }
            });
        }

        let uploadProjectKey;
        $scope.publishPackage = (fileToUpload, callback) => {
            uploadProjectKey = $scope.uiState.overridingProject && $scope.uiState.overridingProject.projectBasicInfo.id || $scope.presetProjectKey;
            return DataikuAPI.projectdeployer.publishedProjects.uploadBundle(uploadProjectKey, fileToUpload, callback);
        };
        $scope.afterUploadCallback = function(unparsedBundleInfo) {
            if ($scope.uiState.fileProperties.filter(f => !f.uploaded).length == 0) {
                $scope.resolveModal(uploadProjectKey || JSON.parse(unparsedBundleInfo).designNodeInfo.projectKey);
            }
        };
    });

    app.service('ProjectDeployerProjectsService', function($state, $q, DataikuAPI, Assert, WT1, DeployerPublishedItemsService, ProjectDeployerDeploymentUtils, ProjectDeployerDeploymentService) {
        this.deployBundle = function(projectStatus, bundleId, source) {
            Assert.trueish(projectStatus, 'project status not provided');
            Assert.trueish(projectStatus.deployments, 'no deployments in projectStatus');
    
            DeployerPublishedItemsService.deployPackage(projectStatus, 'bundle').then(deploymentMethodId => {
                if (deploymentMethodId === DeployerPublishedItemsService.DEPLOYMENT_METHOD_ID.NEW) {
                    deployBundleInNewDeployment(projectStatus, bundleId, source);
                } else {
                    deployBundleInExistingDeployment(projectStatus, bundleId, source);
                }
            })
        };
    
        function deployBundleInNewDeployment(projectStatus, bundleId, source) {
            return ProjectDeployerDeploymentService.startCreateDeployment(projectStatus.projectBasicInfo.id, bundleId).then(function(newDeployment) {
                $state.go('projectdeployer.deployments.deployment.status', {
                    deploymentId: newDeployment.id
                });
                WT1.event('project-deployer-deploy-bundle-in-new-deployment', {deploymentType: 'PROJECT', source });
            });
        };
    
        function deployBundleInExistingDeployment(projectStatus, bundleId, source) {
            DeployerPublishedItemsService.openDeploymentSelector(projectStatus, false).then(function(deployment) {
                const projectKey = projectStatus.projectBasicInfo.id;
                const settingsPromise = DataikuAPI.projectdeployer.deployments.getSettings(deployment.id);
                const bundleDetailsPromise = DataikuAPI.projectdeployer.publishedProjects.getBundleDetailsExtended(projectKey, bundleId);

                $q.all([settingsPromise, bundleDetailsPromise]).then(function([settingsResponse, bundleDetailsResponse]) {
                    const settings = settingsResponse.data;
                    const bundleDetails = bundleDetailsResponse.data;
                    
                    settings.bundleId = bundleId;
                    settings.scenariosToActivate = ProjectDeployerDeploymentUtils.getUpdatedScenarioMap(settings.scenariosToActivate, bundleDetails.scenarios);

                    DataikuAPI.projectdeployer.deployments.save(settings)
                    .success(function() {
                        $state.go('projectdeployer.deployments.deployment.settings', {
                            deploymentId: deployment.id
                        });
                        WT1.event('project-deployer-deploy-bundle-in-existing-deployment', { deploymentType: 'PROJECT', source });
                    })
                    .error(function() {
                        deferred.reject.call(this, arguments);
                    });
                });
            });
        };
    });


})();


(function() {
    'use strict';
    
    const app = angular.module('dataiku.projectdeployer');

    app.controller('ProjectDeployerInfrasListController', function($scope, $controller, DataikuAPI) {
        $controller('_DeployerInfrasListController', {$scope: $scope});
        
        if ($scope.isFeatureLocked) return;
        
        $scope.uiState = $scope.uiState || {};

        $scope.filterInfra = function(infraStatus) {
            if (!$scope.uiState.query) return true;
            const query = $scope.uiState.query.toLowerCase();
            return infraStatus.infraBasicInfo.id.toLowerCase().includes(query)
                || infraStatus.infraBasicInfo.stage.toLowerCase().includes(query)
                || infraStatus.infraBasicInfo.automationNodeUrl.toLowerCase().includes(query);
        }

        $scope.$watch("infraStatusList", function(nv, ov) {
            if (nv) {
                nv.forEach(function(infraStatus) {
                    const infraId = infraStatus.infraBasicInfo.id;
                    DataikuAPI.projectdeployer.infras.checkStatus(infraId)
                        .success(function(healthStatus) {
                            infraStatus.infraHealthError = healthStatus.messages.find(function(msg) {
                                return msg.severity === healthStatus.maxSeverity;
                            }) || {};
                        })
                        .error(setErrorInScope.bind($scope));
                });
            }
        });
    });

    app.controller('ProjectDeployerInfraController', function($scope, $controller) {
        $controller('_DeployerInfraController', {$scope: $scope});
    });

    app.controller('ProjectDeployerInfraSetupModalController', function($scope, $controller) {
        $controller('_DeployerInfraSetupModalController', {$scope: $scope});
    });
    
    app.controller('ProjectDeployerInfraStatusController', function($scope, $controller, DataikuAPI, ProjectDeployerAsyncHeavyStatusLoader, DeployerDeploymentTileService) {
        $controller('_DeployerInfraStatusController', {$scope: $scope});

        $scope.$watch("infraStatus", function(nv) {
            if (nv) {
                DataikuAPI.projectdeployer.infras.checkStatus($scope.infraStatus.infraBasicInfo.id)
                    .success(function(healthStatus) {
                        if (healthStatus.anyMessage) {
                            $scope.infraHealthErrorMessage = healthStatus.messages.find(function(msg) {
                                return msg.severity === healthStatus.maxSeverity;
                            }).message;
                        }
                    })
                    .error(setErrorInScope.bind($scope));

                DataikuAPI.projectdeployer.publishedProjects.listBasicInfo()
                .success(function(projectBasicInfoList) {
                    const projectBasicInfoMap = projectBasicInfoList.projects.reduce((obj, basicInfo) => ({ ...obj, [basicInfo.id]: basicInfo }), {});
                    $scope.pseudoLightStatusList = $scope.infraStatus.deployments.map(function(deployment) {
                        return {
                            deploymentBasicInfo: deployment,
                            projectBasicInfo: projectBasicInfoMap[deployment.publishedProjectKey]
                        };
                    });
                });
                
                const infraStatusList = [{
                    infraBasicInfo: $scope.infraStatus.infraBasicInfo,
                    deployments: $scope.infraStatus.deployments
                }];
                const heavyStatusByDeploymentId = {};
                let loader = ProjectDeployerAsyncHeavyStatusLoader.newLoader(infraStatusList, heavyStatusByDeploymentId);
                loader.loadHeavyStatus();

                const deregister = $scope.$watch(function(){
                    return loader.stillRefreshing();
                }, function(nv, ov) {
                    if (nv || ov === nv) return;
                    $scope.healthMap = DeployerDeploymentTileService.getDeploymentHealthMap($scope.infraStatus.deployments, heavyStatusByDeploymentId);
                    deregister();
                });
                
                $scope.$on('$destroy', function() {
                    loader && loader.stopLoading();
                });
            }
        });
    });

    app.controller('ProjectDeployerInfraHistoryController', function($scope, $controller) {
        $controller('_DeployerInfraHistoryController', {$scope: $scope});
    });

    app.controller('ProjectDeployerInfraSettingsController', function($scope, $controller) {
        $controller('_DeployerInfraSettingsController', {$scope: $scope});
    });
})();
(function() {
    'use strict';
    
    const app = angular.module('dataiku.projectdeployer');

    app.controller('_ProjectDeployerDeploymentsBaseController', function(TopNav) {
        TopNav.setNoItem();
        TopNav.setLocation(TopNav.TOP_PROJECT_DEPLOYER, 'deployments');
    });

    app.controller('ProjectDeployerDeploymentsController', function($scope, $controller) {
        $controller('_ProjectDeployerDeploymentsBaseController', {$scope: $scope});
    });

    app.service('ProjectDeployerAsyncHeavyStatusLoader', function(DataikuAPI, Logger, DeployerUtils) {
        return {
            newLoader: function(infraStatusList, heavyStatusPerDeploymentId) {
                const loader = {};
                let loading = true;
                loader.stillRefreshing = () => loading

                let canLoadStatus = true;
                loader.stopLoading = function() {
                    canLoadStatus = false;
                },

                loader.loadHeavyStatus = function() {
                    if (!infraStatusList.length || !canLoadStatus) {
                        loading = false;
                        return;
                    }

                    const infraStatus = infraStatusList.shift();
                    const infraId = infraStatus.infraBasicInfo.id;
                    const deploymentIds = infraStatus.deployments.map(_ => _.id);
                    Logger.info("Sending heavy status list request for deployments of infra " + infraId);
                    DataikuAPI.projectdeployer.deployments.listHeavyStatus(infraId)
                        .success(function(heavyStatusList) {
                            Logger.info("Got heavy status list for infra " + infraId);
                            heavyStatusList.forEach((heavyStatus) => {
                                heavyStatusPerDeploymentId[heavyStatus.deploymentId] = heavyStatus;
                            });
                            loader.loadHeavyStatus();
                        }).error(function(a,b,c) {
                            Logger.warn("Failed to load heavy status list for infra " + infraId);
                            deploymentIds.forEach((deploymentId) => {
                                heavyStatusPerDeploymentId[deploymentId] = {
                                    health: "LOADING_FAILED",
                                    healthMessages: DeployerUtils.getFailedHeavyStatusLoadMessage(getErrorDetails(a,b,c))
                                };
                            });
                            loader.loadHeavyStatus();
                        });
                }
                return loader;
            },
        }
    });

    app.directive('projectDeploymentCard', function(ProjectDeployerProjectUtils, ProjectDeployerDeploymentUtils, DeployerDeploymentTileService, $state) {
        return {
            scope: {
                lightStatus: '=',
                heavyStatus: '='
            },
            templateUrl: '/templates/project-deployer/deployment-card.html',
            replace: true,
            link: function(scope, elem, attrs) {
                scope.dashboardTile = attrs.hasOwnProperty("deploymentDashboardTile");
                function onLightStatusChanged() {
                    if (!scope.dashboardTile) {
                        const bundleId = scope.lightStatus.deploymentBasicInfo.bundleId;
                        const bundle = scope.lightStatus.packages.find(p => p.id === bundleId);

                        scope.bundleOriginInfo = ProjectDeployerProjectUtils.getBundleOriginInfo(bundle.designNodeInfo);

                        scope.automationInfo = {};
                        scope.automationInfo.automationProjectKey = ProjectDeployerDeploymentUtils.getAutomationProject(scope.lightStatus.deploymentBasicInfo);
                        scope.automationInfo.automationUrl = ProjectDeployerDeploymentUtils.getAutomationProjectUrl(scope.lightStatus.infraBasicInfo.automationNodeUrl, scope.automationInfo.automationProjectKey);
                    }
                }

                scope.outcome = {
                    FAILED: "failed",
                    WARNING: "with warnings",
                    RUNNING: "currently running",
                    ABORTED: "aborted",
                    SUCCESS: "successful"
                };

                function getAutomationProjectMonitoringSummary(monitoring) {
                    if (!monitoring) {
                        return {
                            unreachable: true
                        }
                    }
                    if (!monitoring.hasScenarios) {
                        return {
                            noScenarios: true
                        };
                    }
                    if (!monitoring.hasActiveScenarios) {
                        return {
                            noActiveScenarios: true
                        };
                    }

                    const failedRuns = monitoring.failed.length;
                    const warningRuns = monitoring.warning.length;
                    const stillRunningRuns = monitoring.running.length;
                    const abortedRuns = monitoring.aborted.length;
                    const successRuns = monitoring.successful.length;
                    const scenarioLastRuns = {
                        total: failedRuns + warningRuns + stillRunningRuns + abortedRuns + successRuns,
                        highestSeverity: {}
                    };

                    if (failedRuns) {
                        scenarioLastRuns.highestSeverity.value = scope.outcome.FAILED;
                        scenarioLastRuns.highestSeverity.scenarios = monitoring.failed;
                    } else if (warningRuns) {
                        scenarioLastRuns.highestSeverity.value = scope.outcome.WARNING;
                        scenarioLastRuns.highestSeverity.scenarios = monitoring.warning;
                    } else if (stillRunningRuns) {
                        scenarioLastRuns.highestSeverity.value = scope.outcome.RUNNING;
                        scenarioLastRuns.highestSeverity.scenarios = monitoring.running;
                    } else if (abortedRuns) {
                        scenarioLastRuns.highestSeverity.value = scope.outcome.ABORTED;
                        scenarioLastRuns.highestSeverity.scenarios = monitoring.aborted;
                    } else if (successRuns) {
                        scenarioLastRuns.highestSeverity.value = scope.outcome.SUCCESS;
                        scenarioLastRuns.highestSeverity.scenarios = monitoring.successful;
                    }

                    return scenarioLastRuns;
                }

                scope.getSummaryLine = function(scenarioLastRuns) {
                    if (!scenarioLastRuns.highestSeverity.scenarios) return;
                    if (scenarioLastRuns.highestSeverity.scenarios.length < scenarioLastRuns.total) {
                        return `${scenarioLastRuns.total} (${scenarioLastRuns.highestSeverity.scenarios.length} ${scenarioLastRuns.highestSeverity.value})`;
                    }
                    return `${scenarioLastRuns.total}, all ${scenarioLastRuns.highestSeverity.value}`;
                }

                scope.displayScenarioNamesOfHighestSeverity = function(scenarioLastRuns, cap=15) {
                    const scenarioNames = scenarioLastRuns.highestSeverity.scenarios;
                    if (!scenarioNames || scenarioNames.length === scenarioLastRuns.total) return '';
                    let tooltipMsg = scenarioNames.slice(0, cap).join(", ");
                    const hiddenRuns = scenarioNames.length - cap;
                    if (hiddenRuns > 0) {
                        tooltipMsg += " and " + hiddenRuns + " more";
                    }
                    return tooltipMsg;
                }

                scope.redirect = function() {
                    if (attrs.hasOwnProperty("redirectToDeploymentPage")) {
                        $state.go('projectdeployer.deployments.deployment.status', {deploymentId: scope.lightStatus.deploymentBasicInfo.id});
                    }
                }

                scope.$watch('lightStatus', function() {
                    if (scope.lightStatus) {
                        onLightStatusChanged();
                    }
                }, true);

                scope.$watch("heavyStatus", function() {
                    scope.deploymentStatus = DeployerDeploymentTileService.getDeploymentHealth(scope.heavyStatus);
                    if (scope.heavyStatus) {
                        scope.scenarioLastRuns = getAutomationProjectMonitoringSummary(scope.heavyStatus.monitoring);
                    } else {
                        delete scope.scenarioLastRuns;
                    }
                })
            }
        }
    });

    app.directive('projectDeploymentsListWidget', function($state) {
        return {
            scope: {
                deployments: '=projectDeploymentsListWidget',
                statusPage: '=',
                healthMap: '='
            },
            templateUrl: '/templates/project-deployer/deployment-list.html',
            replace: true,
            link: function(scope) {
                scope.redirect = function(deployment) {
                    $state.go('projectdeployer.deployments.deployment.status', {deploymentId: deployment.deploymentBasicInfo.id});
                };
            }
        };
    });

    app.controller('ProjectDeployerDeploymentDashboardController', function($scope, $controller, $state, WT1,
    ProjectDeployerDeploymentService, ProjectDeployerAsyncHeavyStatusLoader) {
        $controller('_DeployerDeploymentDashboardController', {$scope});
        
        if ($scope.isFeatureLocked) return;

        $scope.uiState.query.healthStatusMap = [
            'HEALTHY',
            'WARNING',
            'OUT_OF_SYNC',
            'UNHEALTHY',
            'ERROR',
            'UNKNOWN',
            'LOADING_FAILED'
        ].map(hs => ({
            id: hs,
            $selected: false
        }));
        $scope.orderByExpression = ['projectBasicInfo.id', 'deploymentBasicInfo.bundleId', 'deploymentBasicInfo.id'];

        function filterOnSearchBarQuery(lightStatus) {
            if (!$scope.uiState.query.q) return true;
            const query = $scope.uiState.query.q.toLowerCase();
            return lightStatus.deploymentBasicInfo.publishedProjectKey.toLowerCase().includes(query)
                || lightStatus.deploymentBasicInfo.deployedProjectKey && lightStatus.deploymentBasicInfo.deployedProjectKey.toLowerCase().includes(query)
                || lightStatus.deploymentBasicInfo.bundleId.toLowerCase().includes(query)
                || lightStatus.deploymentBasicInfo.id.toLowerCase().includes(query)
                || lightStatus.deploymentBasicInfo.infraId.toLowerCase().includes(query)
                || lightStatus.projectBasicInfo.name.toLowerCase().includes(query);
        }

        $scope.deploymentIsInUI = function(lightStatus) {
            const selectedProjects = $scope.uiState.query.projects.filter(project => project.$selected);
            const selectedStatuses = $scope.uiState.query.healthStatusMap.filter(hs => hs.$selected);
            const deploymentHealthStatus = $scope.heavyStatusPerDeploymentId[lightStatus.deploymentBasicInfo.id];

            return filterOnSearchBarQuery(lightStatus) &&
                (!selectedProjects.length || selectedProjects.find(project => project.projectBasicInfo.id === lightStatus.deploymentBasicInfo.publishedProjectKey)) &&
                (!$scope.uiState.query.tags.length || $scope.uiState.query.tags.find(tag => lightStatus.deploymentBasicInfo.tags.find(deplTag => deplTag === tag))) &&
                (!selectedStatuses.length || selectedStatuses.find(hs => deploymentHealthStatus && deploymentHealthStatus.health === hs.id));
        };

        $scope.getFilteredDeploymentCount = function(deployments) {
            return deployments.filter(deployment => $scope.deploymentIsInUI(deployment)).length;
        };

        $scope.startCreateDeployment = function() {
            ProjectDeployerDeploymentService.startCreateDeployment().then(function(newDeployment) {
                $state.go('projectdeployer.deployments.deployment.status', {deploymentId: newDeployment.id});
                WT1.event('project-deployer-deployment-create', {deploymentType: 'PROJECT' });
            });
        };

        let loader;
        $scope.$watch("infraStatusList", function(nv) {
            if (!nv) return;
            loader = ProjectDeployerAsyncHeavyStatusLoader.newLoader([].concat(nv), $scope.heavyStatusPerDeploymentId);
            loader.loadHeavyStatus();
        });

        $scope.stillRefreshing = function() {
            return !$scope.globalLightStatusLoaded || !loader || loader.stillRefreshing();
        };

        $scope.$on("$destroy", function() {
            loader.stopLoading();
        });

        $scope.$watch('projectStatusList', function(nv) {
            if (!nv) return;

            $scope.uiState.query.projects = angular.copy($scope.projectStatusList);
        });
    });


    app.controller('ProjectDeployerPackagesPanelController', function($scope, $controller, ProjectDeployerProjectsService, DeployerUtils) {
        $controller("_DeployerPackagesPanelController", {$scope});

        $scope.getPackageDeployments = function(deployments, bundleId) {
            return deployments.filter(d => d.bundleId === bundleId);
        };

        $scope.deployBundle = function(projectStatus, bundleId) {
            ProjectDeployerProjectsService.deployBundle(projectStatus, bundleId, DeployerUtils.DEPLOY_SOURCE.PACKAGE_PANEL);
        };

        $scope.$watch('projectStatusList', function(nv) {
            if (!nv) return;

            $scope.uiState.fullProjectList = $scope.computeFullList(nv);
        });
    });

    app.controller('_ProjectDeployerEditDeploymentController', function($scope, $controller,  DataikuAPI) {
        $controller('_ProjectDeployerDeploymentsBaseController', {$scope: $scope});

        $scope.uiState = $scope.uiState || {};

        // --- Target folder setup ---
        $scope.projectFolderHierarchy = {};
    
        $scope.setFolderHierarchy = function(callback) {
            $scope.projectFolderHierarchy = {};

            if ($scope.deploymentSettings.infraId) {
                DataikuAPI.projectdeployer.infras.getProjectFolderHierarchy($scope.deploymentSettings.infraId).success(rootFolder => {
                    $scope.projectFolderHierarchy = rootFolder;

                    // add necessary elements for using browse-path directive
                    function fixupTree(tree) {
                        const children = tree.children;
                        // add pathElts
                        tree.directory = true;
                        tree.fullPath = tree.id;
                        
                        // remove parent and children
                        const treeWithoutChildren = Object.assign({}, tree, { children: [] });
                        children.forEach(child => {
                            child.parent = treeWithoutChildren;
                            fixupTree(child);
                        })
                    }

                    fixupTree($scope.projectFolderHierarchy);

                    if (typeof callback === 'function') {
                        callback();
                    }
                });
            }
        };

        DataikuAPI.projectdeployer.publishedProjects.listLightStatus()
        .success(projects => {
            $scope.projects = projects;
        })
        .error(setErrorInScope.bind($scope));
    });

    app.controller('_ProjectDeployerDeploymentModalController', function($scope, $controller, $timeout, DataikuAPI, StringUtils, PromiseService) {
        $controller('_ProjectDeployerEditDeploymentController', {$scope: $scope});

        let deploymentIds = [];

        $scope.uiState = $scope.uiState || {};
        angular.extend($scope.uiState, {
            deploymentInfo: {},
            selectedFolder: {},
            selectedProject: {}
        });
        $scope.deploymentSettings = {};
        $scope.deployableProjectStatusList = [];
        

        // --- Project folders

        $scope.canSelect = item => item.canWriteContents;
        $scope.getProjectFolderName = item => item.name;
        $scope.browse = (folderIds) => {
            const ids = folderIds.split('/');
            const destination = ids[ids.length - 1];
            const folder = (destination && searchTree($scope.projectFolderHierarchy, destination)) || $scope.projectFolderHierarchy;
            const pathElts = treeToList(folder, folder => folder.parent).map(f => angular.extend({}, f, { toString: () => f.id }));

            return PromiseService.qToHttp($timeout(() => ({
                exists: true,
                directory: true,
                children: folder.children,
                pathElts: pathElts
            }), 0));
        };
        $scope.canEditFolder = function() {
            return $scope.projectFolderHierarchy.id;
        };

        function setProjectFolder() {
            if ($scope.projectFolderHierarchy && $scope.projectFolderHierarchy.id) {
                $scope.uiState.selectedFolder = $scope.projectFolderHierarchy;

                if ($scope.deploymentSettings.projectFolderId) {
                    const folder = searchTree($scope.projectFolderHierarchy, $scope.deploymentSettings.projectFolderId);

                    if (folder) {
                        $scope.uiState.selectedFolder = folder;
                    } else {
                        $scope.deploymentSettings.projectFolderId = ''; // if we couldnt find the ID, reset it
                    }
                }

                $scope.uiState.selectedFolder.pathElts = $scope.uiState.selectedFolder.parent ? treeToList($scope.uiState.selectedFolder, folder => folder.parent).map(f => f.name).join('/') : '/';
            }
        }
        

        // --- Project/deployment naming ---

        $scope.setDeploymentId = function() {
            if ($scope.deploymentSettings.publishedProjectKey && $scope.deploymentSettings.infraId) {
                $scope.deploymentSettings.id = StringUtils.transmogrify(
                    `${$scope.deploymentSettings.publishedProjectKey}-on-${$scope.deploymentSettings.infraId}`, 
                    deploymentIds, 
                    (count, name) => `${name}-${count}`
                );
            }
        };

        $scope.doesDeploymentIdExist = function(deploymentId) {
            return !deploymentIds.includes(deploymentId);
        };

        // default deployment settings 
        let automationProjectList = null;
        function setAutomationProjects() {
            if ($scope.deploymentSettings.infraId) {
                resetErrorInScope($scope);
                $scope.publishedProjectKeyExistsOnAutomationNode = false;
                return DataikuAPI.projectdeployer.infras.getProjectKeys($scope.deploymentSettings.infraId).success(infraProjects => {
                    automationProjectList = infraProjects;
                    $scope.setTargetProjectKey();
                });
            }
        }

        $scope.setTargetProjectKey = function() {            
            if ($scope.deploymentSettings.publishedProjectKey) {
                const projectList = automationProjectList || ($scope.deploymentSettings.deployedProjectKey ? [$scope.deploymentSettings.deployedProjectKey] : []);

                $scope.deploymentSettings.deployedProjectKey = StringUtils.transmogrify(
                    $scope.deploymentSettings.publishedProjectKey, 
                    projectList,
                    (count, name) => `${name}_${count}`
                );

                $scope.publishedProjectKeyExistsOnAutomationNode = $scope.deploymentSettings.deployedProjectKey !== $scope.deploymentSettings.publishedProjectKey;
            }
        };
        
        $scope.$watch('uiState.selectedProject', function(nv) {
            if (nv && $scope.deploymentSettings) {
                if ($scope.deploymentSettings.publishedProjectKey && $scope.uiState.selectedProject) {
                    $scope.bundles = $scope.uiState.selectedProject.packages;
                }
            }
        });

        $scope.setSelectedProject = function() {
            if ($scope.deployableProjectStatusList) {
                $scope.uiState.selectedProject = $scope.deployableProjectStatusList.find(project => $scope.deploymentSettings && project.projectBasicInfo.id === $scope.deploymentSettings.publishedProjectKey);
            }
        };

        $scope.$watch('projects', function(nv) {
            if (nv) {
                $scope.deployableProjectStatusList = $scope.projects.filter(project => project.packages.length && project.canDeploy);
                $scope.setSelectedProject();
            }
        });
        
        DataikuAPI.projectdeployer.infras.listLightStatus().success(infras => {
            $scope.deployableInfraStatusList = infras.filter(infra => infra.canDeploy);
        }).error(setErrorInScope.bind($scope));

        $scope.$watch('deploymentSettings.infraId', function(nv, ov) {
            if (nv) {
                if (ov || !$scope.deploymentSettings.projectFolderId) {
                    $scope.deploymentSettings.projectFolderId = 'ROOT'; // reset
                }

                setAutomationProjects();
                $scope.setFolderHierarchy(setProjectFolder);
                $scope.setDeploymentId();
            }
        });

        $scope.ok = function() {
            DataikuAPI.projectdeployer.deployments.create($scope.deploymentSettings.id, $scope.deploymentSettings.publishedProjectKey, $scope.deploymentSettings.infraId, $scope.deploymentSettings.bundleId, $scope.deploymentSettings.deployedProjectKey, $scope.deploymentSettings.projectFolderId)
                .success($scope.resolveModal)
                .error(setErrorInScope.bind($scope));
        };

        function setDeployments() {
            DataikuAPI.projectdeployer.deployments.listBasicInfo().success(infras => {
                deploymentIds = infras.deployments.map(d => d.id);
            }).error(setErrorInScope.bind($scope));
        }

        setDeployments();
    });

    app.controller('ProjectDeployerDeploymentCreationModalController', function($scope, $controller, DataikuAPI) {
        $controller('_ProjectDeployerDeploymentModalController', {$scope: $scope});

        $scope.ok = function() {
            DataikuAPI.projectdeployer.deployments.create($scope.deploymentSettings.id, $scope.deploymentSettings.publishedProjectKey, $scope.deploymentSettings.infraId, $scope.deploymentSettings.bundleId, $scope.deploymentSettings.deployedProjectKey, $scope.deploymentSettings.projectFolderId)
                .success($scope.resolveModal)
                .error(setErrorInScope.bind($scope));
        };

        $scope.$watch('deploymentSettings.publishedProjectKey', function(nv) {
            if (nv) {
                $scope.setSelectedProject();
                $scope.setTargetProjectKey();
                $scope.setDeploymentId();
            }
        });
    });

    app.controller('ProjectDeployerDeploymentCopyModalController', function($scope, $controller, DataikuAPI) {
        $controller('_ProjectDeployerDeploymentModalController', {$scope: $scope});

        $scope.ok = function() {
            DataikuAPI.projectdeployer.deployments.copy($scope.oldDeploymentId, $scope.deploymentSettings.id, $scope.deploymentSettings.infraId, $scope.deploymentSettings.deployedProjectKey, $scope.deploymentSettings.projectFolderId)
                .success($scope.resolveModal)
                .error(setErrorInScope.bind($scope));
        };

        $scope.$watch('deploymentSettings.publishedProjectKey', function(nv) {
            if (nv) {
                $scope.setTargetProjectKey();
                $scope.setDeploymentId();
            }
        });
    });

    app.controller('ProjectDeployerDeploymentController', function(TopNav, $scope, $rootScope, $state, $controller,
        ActivityIndicator, CreateModalFromTemplate, WT1, DataikuAPI, DeployerUtils) {
        TopNav.setNoItem();
        TopNav.setLocation(TopNav.TOP_PROJECT_DEPLOYER, 'deployments');

        $controller('_DeployerDeploymentController', {$scope});

        $scope.localVariables = {
            asJSON: '{}',
            saved: '{}'
        };

        $scope.deleteWarning = 'The deployed project on the Automation node will not be deleted. You will need to manually delete the project on the Automation node.';

        if (!$scope.deploymentSettings) {
            $scope.getDeploymentSettings();
        }

        $scope.getScenarioRuns = function() {
            const dateFormat = 'YYYY-MM-DD';
            $scope.loadingScenarioRuns = true;
            return DataikuAPI.projectdeployer.deployments.scenarioLastRuns($state.params.deploymentId, moment().subtract(14, 'days').format(dateFormat), moment().add(1, 'days').format(dateFormat))
            .success(scenarioRuns => {
                $scope.scenarioRuns = scenarioRuns;
            }).error(() => {
                $scope.scenarioRuns = $scope.scenarioRuns || {};
            }).finally(() => {
                $scope.loadingScenarioRuns = false;
                addLastRuns();
            });
        };

        function addLastRuns() {
            ($scope.scenarioRuns.rows || []).forEach(function(row) {
                const id = row.uniqueId;
                for (let i = $scope.scenarioRuns.columns.length - 1; i>=0; i--) {
                    const column = $scope.scenarioRuns.columns[i];
                    if (column.actions && column.actions[id]) {
                        const actions = column.actions[id];
                        row.lastRun = {
                            date: column.date,
                            outcome: actions[actions.length - 1].outcome.toLowerCase()
                        };
                        break;
                    }
                }
            });
        }

        $scope.getScenarioRuns();

        $scope.projectDeploymentIsDirty = function() {
            return $scope.localVariables.asJSON !== $scope.localVariables.saved || $scope.deploymentIsDirty();
        };

        $scope.saveProjectDeployment = function() {
            try {
                $scope.deploymentSettings.localVariables = JSON.parse($scope.localVariables.asJSON || '{}');

                return $scope.saveDeployment();
            } catch (err) {
                ActivityIndicator.error("Invalid format: "+err.message);
            }
        };
    
        $scope.saveAndUpdateProjectDeployment = function() {
            const savePromise = $scope.saveProjectDeployment();

            if (savePromise) {
                savePromise.then(function() { $scope.updateOnly(); });
            }
        };

        $scope.updateOnly = function() {
            CreateModalFromTemplate("/templates/project-deployer/deploy-modal.html", $scope, 'ProjectDeployerDeployModalController');
            WT1.event('project-deployer-deployment-update', { deploymentType: 'PROJECT' });
        };

        $scope.copyDeployment = function() {
            if ($scope.deploymentSettings) {
                CreateModalFromTemplate('/templates/project-deployer/copy-deployment-modal.html', $rootScope, null, function(modalScope) {
                    modalScope.oldDeploymentId = $scope.deploymentSettings.id;
                    modalScope.deploymentSettings = {
                        publishedProjectKey: $scope.deploymentSettings.publishedProjectKey,
                    };
                }).then(function(newDeployment) {
                    $state.go('projectdeployer.deployments.deployment.status', {deploymentId: newDeployment.id});
                    WT1.event('project-deployer-deployment-copy', { deploymentType: 'PROJECT' });
                });
            }
        };

        $scope.$watch("lightStatus", function(nv, ov) {
            if ($scope.lightStatus) {
                $scope.getHeavyStatus().error(function(a,b,c) {
                    $scope.heavyStatus = {
                        health: "LOADING_FAILED",
                        healthMessages: DeployerUtils.getFailedHeavyStatusLoadMessage(getErrorDetails(a,b,c))
                    };
                });
            }
        });

        const allowedTransitions = [
            'projectdeployer.deployments.deployment.status',
            'projectdeployer.deployments.deployment.history',
            'projectdeployer.deployments.deployment.settings'
        ];
        checkChangesBeforeLeaving($scope, $scope.projectDeploymentIsDirty, null, allowedTransitions);
    });

    app.controller('ProjectDeployerDeployModalController', function($scope, ProjectDeployerDeploymentSyncHelper, ActivityIndicator) {
        const MODAL_TITLES = {
            IN_PROGRESS: 'Updating project',
            FAILED: 'Project update failed',
            DONE_WITH_WARNINGS: 'Project successfully updated (with warnings)'
        };
        $scope.STEP_STATUS = ProjectDeployerDeploymentSyncHelper.STEP_STATUS;
        $scope.DEPLOY_STEPS = ProjectDeployerDeploymentSyncHelper.DEPLOY_STEPS;
        $scope.DEPLOY_STATUS = ProjectDeployerDeploymentSyncHelper.DEPLOY_STATUS;
        $scope.deployment = {};

        $scope.retryDeploy = function() {
            startDeployment();
        };

        $scope.close = function() {
            const deploymentStatus = $scope.deployment.status;
            if (deploymentStatus === $scope.DEPLOY_STATUS.DONE ||
                deploymentStatus === $scope.DEPLOY_STATUS.DONE_WITH_WARNINGS) {
                let message = 'Deployment updated successfully' +
                    (deploymentStatus === $scope.DEPLOY_STATUS.DONE_WITH_WARNINGS ? ' (with warnings)' : '');
                ActivityIndicator.success(message);
            }
            $scope.dismiss();
            $scope.refreshLightAndHeavy();
            $scope.getScenarioRuns();
            $scope.$destroy();
        };

        function startDeployment() {
            $scope.modalTitle = MODAL_TITLES.IN_PROGRESS;
            ProjectDeployerDeploymentSyncHelper.start($scope, $scope.deploymentSettings, $scope.DEPLOY_STEPS.PREPARE_SYNC, $scope.DEPLOY_STEPS.ACTIVATE_BUNDLE);
        }

        $scope.$on('projectDeploymentUpdate', (event, deployment) => {
            $scope.deployment = deployment;
            $scope.percentage = deployment.progress.current / deployment.progress.end * 100;
            if (deployment.status === $scope.DEPLOY_STATUS.DONE) {
                $scope.close(deployment.status);
            } else {
                $scope.modalTitle = MODAL_TITLES[deployment.status];
            }
        });

        startDeployment();
    });

    app.controller('ProjectDeployerDeploymentSettingsController', function($scope, $controller, DataikuAPI, ProjectDeployerDeploymentUtils, CodeMirrorSettingService, AutomationUtils) {
        $controller('_ProjectDeployerEditDeploymentController', {$scope: $scope});

        $scope.codeMirrorSettingService = CodeMirrorSettingService;
        $scope.AutomationUtils = AutomationUtils;

        angular.extend($scope.uiState, {
            selectedBundle: {},
            connectionNames: [],
            settingsPane: 'information'
        });

        $scope.setupDeploymentUI = function() {
            $scope.localVariables.asJSON = JSON.stringify($scope.deploymentSettings.localVariables, null, 2);
            $scope.localVariables.saved = $scope.localVariables.asJSON;
        };

        // Scenarios
        $scope.allScenariosActive = function () {
            const scenarioIds = Object.keys($scope.deploymentSettings.scenariosToActivate);
            return scenarioIds.length && scenarioIds.every(key => $scope.deploymentSettings.scenariosToActivate[key]);
        };
        
        $scope.toggleScenarios = function () {
            const allActive = $scope.allScenariosActive();

            $scope.uiState.selectedBundle.scenarios.forEach(scenario => {
                $scope.deploymentSettings.scenariosToActivate[scenario.id] = !allActive;
            });
        };

        function setProjectFolderPath() {            
            if ($scope.deploymentSettings.projectFolderId) {
                const folder = searchTree($scope.projectFolderHierarchy, $scope.deploymentSettings.projectFolderId);

                if (folder && folder.parent) {
                    $scope.projectFolderPath = treeToList(folder, folder => folder.parent).map(f => f.name).join('/');
                }
            }
        }

        function getBundleDetails() {
            if ($scope.deploymentSettings.publishedProjectKey && $scope.deploymentSettings.bundleId) {
                // reset selected bundle in case of error
                $scope.uiState.selectedBundle = { usedCodeEnvs: [], scenarios: [] };
                $scope.uiState.connectionNames = [];
                DataikuAPI.projectdeployer.publishedProjects.getBundleDetailsExtended($scope.deploymentSettings.publishedProjectKey, $scope.deploymentSettings.bundleId).success(bundleDetails => {
                    $scope.uiState.selectedBundle = bundleDetails;
                    $scope.uiState.connectionNames = bundleDetails.usedConnections.map(c => c.name); // for suggestions
                    
                    $scope.deploymentSettings.scenariosToActivate = ProjectDeployerDeploymentUtils.getUpdatedScenarioMap($scope.deploymentSettings.scenariosToActivate, bundleDetails.scenarios);
                });
            }
        }

        function setBundleList() {
            if ($scope.bundles || !$scope.deploymentSettings || !$scope.projects) return;

            const project = $scope.projects.find(project => $scope.deploymentSettings && project.projectBasicInfo.id === $scope.deploymentSettings.publishedProjectKey);

            if (project) {
                $scope.bundles = project.packages;
    
                // if a deployment's bundle was deleted, still include it in the list of bundles
                const bundleId = $scope.deploymentSettings.bundleId;
    
                if (!$scope.bundles.some(bundle => bundle.id === bundleId)) {
                    $scope.bundles.unshift({
                        id: bundleId,
                        name: `${bundleId} (deleted)`
                    });
                }
            }
        }

        $scope.$watch('deploymentSettings', function (nv, ov) {
            if (nv) {
                $scope.setupDeploymentUI();
                $scope.setFolderHierarchy(setProjectFolderPath);
            }
        });
                
        $scope.$watch('deploymentSettings.bundleId', function(nv, ov) {
            if (nv) {
                getBundleDetails();
                setBundleList();
            }
        });

        $scope.$watch('projects', function(nv) {
            if (nv) {
                setBundleList();
            }
        });
    });

    app.controller('ProjectDeployerDeploymentStatusController', function(TopNav) {
        TopNav.setNoItem();
        TopNav.setLocation(TopNav.TOP_PROJECT_DEPLOYER, 'deployments', null, 'status');
    });

    app.service("ProjectDeployerDeploymentUtils", function() {
        const svc = {};

        svc.getAutomationProject = function(deploymentBasicInfo) {
            return deploymentBasicInfo.deployedProjectKey || deploymentBasicInfo.publishedProjectKey;
        };

        svc.getAutomationProjectUrl = function(baseUrl, projectKey) {
            if (baseUrl.substr(-1) !== '/') {
                baseUrl += '/';
            }

            return `${baseUrl}projects/${projectKey}/`;
        };

        /*
            When switching bundles, check if any of the scenarios
            found in the new bundle already exist in the deployment
            scenarios (from the previous bundle)
            If so, use the same value
        */
        svc.getUpdatedScenarioMap = function(previousBundleScenarios, bundleScenarios) {
            return bundleScenarios.reduce((obj, scenario) => {
                const isExistingScenario = scenario.id in previousBundleScenarios;
                const newScenario = isExistingScenario ? {
                    [scenario.id]: previousBundleScenarios[scenario.id]
                } : {};

                return { ...obj, ...newScenario };
            }, {});
        };

        return svc;
    });

    app.controller('ProjectDeployerDeploymentScenarioRunsController', function($scope, ProjectDeployerDeploymentUtils) {
        const DAYS = 15;
        $scope.columns = Array.from(Array(DAYS)).map((day, index) => { 
            const date = moment().subtract(DAYS - index - 1, 'days');
            
            return {
                date: date.format('YYYY-MM-DD'),
                dow: date.weekday(),
                dateFormatted: date.format('D/M'),
                dateDay: date.format('ddd')
            }
        });

        const automationProjectKey = ProjectDeployerDeploymentUtils.getAutomationProject($scope.lightStatus.deploymentBasicInfo);
        const automationProjectUrl = ProjectDeployerDeploymentUtils.getAutomationProjectUrl($scope.lightStatus.infraBasicInfo.automationNodeUrl, automationProjectKey);

        $scope.getScenarioLastRunsUrl = function(scenarioId) {
            return automationProjectUrl + "scenarios/" + scenarioId + "/runs/list/";
        };

        $scope.getDailyRunsUrl = function(day) {
            return automationProjectUrl + "monitoring/" + day;
        };

        $scope.hovered = {date : null};

        $scope.hover = function(column) {
            $scope.hovered.date = column.date;
        };

        $scope.unhover = function() {
            $scope.hovered.date = null;
        };

        $scope.getCellGlobalOutcome = function(date, id) {
            const outcomes = $scope.scenarioRuns.columns.find(column => column.date === date);
            if (!outcomes || !outcomes.actions[id]) return "";
            if (outcomes.actions[id].some(scenarioOutcome => scenarioOutcome.outcome === "FAILED")) return "failed";
            if (outcomes.actions[id].some(scenarioOutcome => scenarioOutcome.outcome === "WARNING")) return "warning";
            if (outcomes.actions[id].some(scenarioOutcome => scenarioOutcome.outcome === "SUCCESS")) return "success";
            return "aborted";
        };
    });

    app.controller('ProjectDeployerDeploymentHistoryController', function(TopNav) {
        TopNav.setNoItem();
        TopNav.setLocation(TopNav.TOP_PROJECT_DEPLOYER, 'deployments', null, 'history');
    });
    
})();

(function() {
    'use strict';
    
    const app = angular.module('dataiku.projectdeployer');
    
    app.service('ProjectDeployerDeploymentService', function($rootScope, CreateModalFromTemplate) {
        this.startCreateDeployment = function(preselectedPublishedProjectKey, preselectedBundleId) {
            return CreateModalFromTemplate("/templates/project-deployer/new-deployment-modal.html", $rootScope, null, function(modalScope) {
                modalScope.deploymentSettings = {
                    publishedProjectKey: preselectedPublishedProjectKey,
                    bundleId: preselectedBundleId
                };
                modalScope.fromBundle = !!(preselectedPublishedProjectKey && preselectedBundleId);
            });
        };
    });

    app.service('ProjectDeployerDeploymentSyncHelper', function(DataikuAPI, FutureWatcher) {
        const DEPLOY_STEPS = {
            CREATE: 'Creating deployment',
            SAVE: 'Preparing deployment',
            PREPARE_SYNC: 'Importing bundle',
            PRELOAD_BUNDLE: 'Preloading bundle',
            ACTIVATE_CHECK: 'Bundle activation checks',
            ACTIVATE_BUNDLE: 'Activating bundle'
        };
        const STEP_STATUS = {
            SUCCESS: 'SUCCESS',
            ERROR: 'ERROR',
            WARNING: 'WARNING',
            IN_PROGRESS: 'IN_PROGRESS',
            NOT_STARTED: 'NOT_STARTED'
        };
        const DEPLOY_STATUS = {
            DONE: 'DONE',
            DONE_WITH_WARNINGS: 'DONE_WITH_WARNINGS',
            FAILED: 'FAILED',
            IN_PROGRESS: 'IN_PROGRESS'
        };
        let currentJobId = null;

        function start(parentScope, deploymentSettings, startingStepName, endingStepName) {
            const $scope = parentScope.$new();
            const allSteps = Object.values(DEPLOY_STEPS);
            const startIndex = allSteps.findIndex(step => step === startingStepName);
            const endIndex = endingStepName ? allSteps.findIndex(step => step === endingStepName) : allSteps.length;

            const deploymentSteps = allSteps.filter((step, index) => {
                    return index >= startIndex && index <= endIndex;
                }).map((step, index) => ({
                    name: step,
                    index,
                    status: STEP_STATUS.NOT_STARTED, 
                    infoMessage: {}
                }));
            let currentIndex = 0;
            let currentStep = deploymentSteps[currentIndex];
            const deployment = {
                status: DEPLOY_STATUS.IN_PROGRESS,
                steps: deploymentSteps,
                progress: {
                    current: 1,
                    end: deploymentSteps.length
                },
                currentStep,
                futureResponse: null,
                error: null,
                infoMessages: {
                    messages: []
                }
            };

            function runStep() {
                deployment.currentStep.status = STEP_STATUS.IN_PROGRESS;
                switch (deployment.currentStep.name) {
                    case DEPLOY_STEPS.CREATE:
                        DataikuAPI.projectdeployer.deployments.create(deploymentSettings.id, deploymentSettings.publishedProjectKey, deploymentSettings.infraId, deploymentSettings.bundleId).success(onStepComplete).error(onStepError);
                        break;
                    case DEPLOY_STEPS.SAVE:
                        DataikuAPI.projectdeployer.deployments.save(deploymentSettings).success(onStepComplete).error(onStepError);
                        break;
                    case DEPLOY_STEPS.PREPARE_SYNC:
                        DataikuAPI.projectdeployer.deployments.prepareSync(deploymentSettings.id).success(handleFuture).error(onStepError);
                        break;
                    case DEPLOY_STEPS.PRELOAD_BUNDLE:
                        DataikuAPI.projectdeployer.deployments.startPreload(deploymentSettings.id).success(handleFuture).error(onStepError);
                        break;
                     case DEPLOY_STEPS.ACTIVATE_CHECK:
                        DataikuAPI.projectdeployer.deployments.activateCheck(deploymentSettings.id).success(onStepComplete).error(onStepError);
                        break;
                    case DEPLOY_STEPS.ACTIVATE_BUNDLE:
                        DataikuAPI.projectdeployer.deployments.startActivate(deploymentSettings.id).success(handleFuture).error(onStepError);
                        break;
                }
                $scope.$emit('projectDeploymentUpdate', deployment);
            };

            function handleFuture(data) {
                deployment.futureResponse = null;
                if (data.hasResult) {
                    onStepComplete(data);
                } else {
                    currentJobId = data.jobId;
                    deployment.futureResponse = data;
                    FutureWatcher.watchJobId(currentJobId).success(onStepComplete).update(onStepUpdate).error(onStepError);
                }
            }
            
            function onStepComplete(results) {
                const result = results.result || results; // activateCheck returns the result directly (no future)
                let goToNextStep = false;
                deployment.futureResponse = null;
                if (result && (result.maxSeverity === STEP_STATUS.ERROR || result.maxSeverity === STEP_STATUS.WARNING)) {
                    deployment.currentStep.status = result.maxSeverity;
                    deployment.currentStep.infoMessage = result;
                    if (deployment.currentStep.name === DEPLOY_STEPS.PRELOAD_BUNDLE) {
                        deployment.preloadLog = results.log;
                    }
                    // Only stop on ERROR, not on WARNING
                    if (result.maxSeverity === STEP_STATUS.ERROR) {
                        deployment.status = DEPLOY_STATUS.FAILED;
                    }
                    
                    // Set deployment severity only if not yet defined or if individual step's severity is STEP_STATUS.WARNING
                    // If deployment severity is ever set to STEP_STATUS.ERROR, do not update it again in future steps
                    if (deployment.infoMessages.maxSeverity !== STEP_STATUS.ERROR) {
                        deployment.infoMessages.maxSeverity = result.maxSeverity;
                    }
                    deployment.infoMessages.messages = deployment.infoMessages.messages.concat(result.messages);
                } else {
                    deployment.currentStep.status = STEP_STATUS.SUCCESS;
                }

                if (deployment.status === DEPLOY_STATUS.IN_PROGRESS &&
                    (currentIndex === deploymentSteps.length - 1 || (deployment.currentStep.name == endingStepName))) {
                    deployment.status = deployment.steps.some(step => Object.keys(step.infoMessage).length !== 0) ?
                        DEPLOY_STATUS.DONE_WITH_WARNINGS : DEPLOY_STATUS.DONE;
                }

                goToNextStep = deployment.status === DEPLOY_STATUS.IN_PROGRESS;

                $scope.$emit('projectDeploymentUpdate', deployment);

                if (goToNextStep) {
                    deployment.progress.current++;
                    deployment.currentStep = deploymentSteps[++currentIndex];
                    runStep();
                }
            }

            function onStepUpdate(response) {
                deployment.futureResponse = response;
                $scope.$emit('projectDeploymentUpdate', deployment);
            }

            function onStepError(data, status, headers) {
                deployment.status = DEPLOY_STATUS.FAILED;
                deployment.currentStep.status = STEP_STATUS.ERROR;
                deployment.error = data;
                deployment.futureResponse = null;
                $scope.$emit('projectDeploymentUpdate', deployment);

                setErrorInScope.bind(parentScope)(data, status, headers);
            }

            runStep();
        }

        return {
            STEP_STATUS,
            DEPLOY_STEPS,
            DEPLOY_STATUS,
            start
        };
    });
})();
    

(function() {
'use strict';

var app = angular.module('dataiku.notebooks', ['dataiku.services', 'dataiku.filters', 'dataiku.controllers']);

app.controller('NotebooksCommons', ($scope) => {
    $scope.getCodeEnvHint = item => {
        if (item.type === 'JUPYTER' ) {
            if (item.displayKernelSpec && item.displayKernelSpec.envName) {
                return ' in ' + item.displayKernelSpec.envName;
            } else {
                return ' in builtin env'
            }
        } else {
            return null;
        }
    };
    $scope.getContainerHint = item => {
        if (item.type === 'JUPYTER' && item.displayKernelSpec) {
            if (item.displayKernelSpec.containerConf) {
                return ' in ' + item.displayKernelSpec.containerConf;
            } else if (item.displayKernelSpec.remoteKernelType === 'DATABRICKS') {
                return ' via Databricks';
            } else if (item.displayKernelSpec.remoteKernelType === 'LIVY') {
                return ' via Livy';
            }
        }
        return null;
    };
});

app.controller('NotebooksController', function($scope, $rootScope, $stateParams, $state, $controller, TaggableObjectsUtils,
               DataikuAPI, CreateModalFromTemplate, TaggableObjectsService, TaggingService, Dialogs, TopNav, DatasetUtils, NotebooksUtils, FutureProgressModal) {

    $controller('_TaggableObjectsListPageCommon', {$scope: $scope});
    $controller('NotebooksCommons', { $scope: $scope });

    TopNav.setLocation(TopNav.TOP_NOTEBOOKS, 'notebooks', TopNav.TABS_NONE, null);
    TopNav.setNoItem();

    $scope.projectKey = $stateParams.projectKey

    $scope.sortBy = [
        { value: 'name', label: 'Name' },
        { value: 'type', label: 'Type' },
        { value: '-lastModifiedOn', label: 'Last modified'},
        { value: 'niceConnection', label: 'SQL connection'}
    ];
    $scope.selection = $.extend({
        filterQuery: {
            userQuery: '',
            tags: [],
            interest: {
                starred: '',
            },
            analyzedDataset: [],
            gitReference: ''
        },
        filterParams: {
            userQueryTargets: ["name","type","language","connection","tags"],
            propertyRules: {tag: "tags",conn:"connection",lang:"language"},
            exactMatch: ['analyzedDataset']
        },
        orderQuery: "-lastModifiedOn",
        orderReversed: false,
    }, $scope.selection || {});
    $scope.sortCookieKey = 'notebooks';
    $scope.maxItems = 20;

    if ($stateParams.datasetId) {
        $scope.selection.filterQuery.analyzedDataset.push($stateParams.datasetId);
    }

    DatasetUtils.listDatasetsUsabilityForAny($stateParams.projectKey).success(data => {
    	// Move the usable flag where it's going to be read
        data.forEach(x => {
            x.usable = x.usableAsInput;
            x.usableReason = x.inputReason;
        });
        $scope.availableDatasets = data;
    }).error(setErrorInScope.bind($scope));

    $scope.getNotebookIcon = function(item) {
    	return NotebooksUtils.getNotebookIcon(item);
    };

    $scope.list = function() {
        $scope.uiState = {activeTab : "actions"};
    	DataikuAPI.sqlNotebooks.listHeads($stateParams.projectKey, $rootScope.tagFilter).success(function(sqlNotebooks) {
            sqlNotebooks.items.forEach(function(sqln) {
                var parsedConnection = NotebooksUtils.parseConnection(sqln.connection);
                sqln.type = parsedConnection.type;
                sqln.niceConnection = parsedConnection.niceConnection;
            });
            $scope.listItems = sqlNotebooks.items;

            if ($scope.mayCreateActiveWebContent()) { // Only list jupyter notebooks if user has rights to create web content
                DataikuAPI.jupyterNotebooks.listHeads($stateParams.projectKey, $rootScope.tagFilter).success(function(jupyterNotebooks) {
                    //TODO @notebooks move to backend
                    jupyterNotebooks.items.forEach(function(ipn) {
                        ipn.type = "JUPYTER";
                        ipn.id = ipn.name;
                    });

                    $scope.listItems = sqlNotebooks.items.concat(jupyterNotebooks.items);
                    $scope.restoreOriginalSelection();

                }).error(setErrorInScope.bind($scope));
            } else {
                $scope.restoreOriginalSelection();
            }
            //since we cannot get notebook taggable type from angular state in taggable_objects.js, set it here to use in tag filter
            if (!$scope.listItemType && $scope.listItems.length) $scope.listItemType = TaggableObjectsUtils.taggableTypeFromAngularState($scope.listItems[0]);
        }).error(setErrorInScope.bind($scope));
    };
    $scope.list();

    /* Tags handling */

    $scope.$on('selectedIndex', function(e, index){
        // an index has been selected, we unselect the multiselect
        $scope.$broadcast('clearMultiSelect');
    });

    /* Specific actions */
    $scope.goToItem = function(notebook) {
        if (notebook.type == "JUPYTER") {
            $state.transitionTo('projects.project.notebooks.jupyter_notebook', {projectKey: $scope.projectKey, notebookId:notebook.name})
        } else {
            $state.transitionTo('projects.project.notebooks.sql_notebook', {projectKey: $scope.projectKey, notebookId:notebook.id})
        }
    };

    $scope.newNotebook = function() {
        CreateModalFromTemplate("/templates/notebooks/new-notebook-modal.html", $scope);
    };

    $scope.newNotebookFromFile = function() {
        CreateModalFromTemplate("/templates/notebooks/new-notebook-from-file-modal.html", $scope);
    };

    $scope.newNotebookFromGit = function() {
        CreateModalFromTemplate("/templates/notebooks/new-notebook-from-git-modal.html", $rootScope, null, newScope => {
            newScope.gitRef = {
            };

            newScope.isItemSelectable = item => {
                return item && item.nbFormat >= 4;
            }

            newScope.listNotebooks = () => {
                DataikuAPI.jupyterNotebooks.git.listRemoteNotebooks(newScope.gitRef.repository, newScope.gitRef.ref)
                .success(data => {
                    FutureProgressModal.show(newScope, data, "List remote notebooks").then(notebooks => {
                        if (notebooks) {
                            newScope.remoteNotebooks = notebooks
                                .filter(notebook => {
                                    if(notebook.language === 'R' || notebook.language === 'ir') {
                                        return $rootScope.appConfig.uiCustomization.showR;
                                    } else if(notebook.language === 'scala' || notebook.language === 'toree') {
                                        return $rootScope.appConfig.uiCustomization.showScala;
                                    } else if(notebook.language.toLowerCase().startsWith('julia')) {
                                        return $rootScope.featureFlagEnabled('julia');
                                    } else {
                                        return true; // other languages are not hidden
                                    }
                                })
                                .map(notebook => Object.assign({$selected: notebook.nbFormat >= 4, type: "JUPYTER"}, notebook));
                        }
                    });
                }).error(setErrorInScope.bind(newScope));
            }

            newScope.importNotebooks = () => {
                DataikuAPI.jupyterNotebooks.git.importNotebooks($stateParams.projectKey, newScope.gitRef.repository, newScope.gitRef.ref, newScope.selection.selectedObjects).success(data => {
                    const parentScope = newScope.$parent;
                    newScope.dismiss();
                    FutureProgressModal.show(parentScope, data, "Import remote notebooks").then(() => {
                        $scope.list();
                    })
                }).error(setErrorInScope.bind(newScope));
            }
        });
    };

	$scope.unloadJupyterNotebook = function(session_id) {
        Dialogs.confirm($scope, 'Unload Jupyter kernel', 'Are you sure you want to stop this notebook?').then(function () {
    		DataikuAPI.jupyterNotebooks.unload(session_id).success(function(data) {
    			$scope.list();
    		}).error(setErrorInScope.bind($scope));
        });
	};

    $scope.startApplyTagging = function() {
        var items =  $scope.selection.selectedObjects.map(function(item) {
            return {
                id : getNotebookId(item),
                displayName: item.name,
                type: getTaggableType(item),
                projectKey: $stateParams.projectKey
            };
        });
        TaggingService.startApplyTagging(items).then($scope.list, setErrorInScope.bind($scope));
    };

    $scope.duplicateNotebook = function(notebook) {
        DataikuAPI.sqlNotebooks.copy($stateParams.projectKey, notebook.id, notebook.name+'_copy').success(function(data) {
            $state.transitionTo("projects.project.notebooks.sql_notebook", {projectKey: $stateParams.projectKey, notebookId: data.id});
        }).error(setErrorInScope.bind($scope));
    };

    function getTaggableType(item) {
        return item.type == 'JUPYTER' ? 'JUPYTER_NOTEBOOK' : 'SQL_NOTEBOOK';
    }

    function getNotebookId(item) {
        return item.type == 'JUPYTER' ? item.name : item.id;
    }

    // Not the generic handling for all other types since we have two taggable types on that page
    $scope.deleteSelected = function() {
        var deletionRequests;
        if($scope.selection.single) {
            var item = $scope.selection.selectedObject;
            deletionRequests = [{
                type: getTaggableType(item),
                projectKey: $stateParams.projectKey,
                id: item.id,
                displayName: item.name,
                activeSessions: item.activeSessions //TODO @flow hack, remove
            }];
        } else {
            deletionRequests = $scope.selection.selectedObjects.map(function(item){
                return {
                    type: getTaggableType(item),
                    projectKey: $stateParams.projectKey,
                    id: item.id,
                    displayName: item.name,
                    activeSessions: item.activeSessions //TODO @flow hack, remove
                };
            });
        }

        TaggableObjectsService.delete(deletionRequests)
            .then($scope.list, setErrorInScope.bind($scope));
    };

    $scope.allRemoteNotebooks = selectedObjects => {
        return selectedObjects.every(obj => obj.gitReference && obj.type == 'JUPYTER');
    }

    $scope.pushNotebooksToRemote = NotebooksUtils.pushNotebooksToRemote($scope);
    $scope.pullNotebooksFromRemote = NotebooksUtils.pullNotebooksFromRemote($scope);
    $scope.editNotebookReference = NotebooksUtils.editNotebookReference($scope)($scope.list);
    $scope.unlinkNotebookReference = NotebooksUtils.unlinkNotebookReference($scope)($scope.list);
    $scope.hasRemoteNotebooks = list => list.some(o => o.gitReference && o.type == 'JUPYTER');
});


app.controller('NewNotebookModalController', function($scope, $rootScope, $stateParams, DataikuAPI, WT1, $state, DatasetUtils, GlobalProjectActions, NotebooksUtils) {
    // choose-type, sql, hive, spark, impala, python, r, scala, customjupyter
    $scope.uiState = {
        step : "choose-type"
    }

    function getSQLNotebookType(step) {
        return ['hive', 'impala'].includes(step) ? step + '-jdbc' : step;
    }

    function createSQLNotebookWithoutDataset() {
        DataikuAPI.sqlNotebooks.create($scope.newNotebook.projectKey, $scope.newNotebook.connection, $scope.newNotebook.name).success(data => {
            WT1.event('notebook-sql-create', {
                notebookId : data.id,
                type: getSQLNotebookType($scope.uiState.step),
                withDataset: false
            });
            $scope.dismiss();
            $state.transitionTo("projects.project.notebooks.sql_notebook", { projectKey: $scope.newNotebook.projectKey, notebookId : data.id });
        }).error(setErrorInScope.bind($scope));
    }

    function createSQLNotebookWithDataset() {
        const type = getSQLNotebookType($scope.uiState.step);
        DataikuAPI.sqlNotebooks.createForDataset($stateParams.projectKey, $scope.datasetSmartName, type, $scope.newNotebook.name)
            .success(data => {
                WT1.event('notebook-sql-create', {
                    notebookId : data.id,
                    type: type,
                    withDataset: true
                });
                $state.go("projects.project.notebooks.sql_notebook", { projectKey : $stateParams.projectKey, notebookId: data.id });
                $scope.dismiss();
            }).error(setErrorInScope.bind($scope));
    }

    function createJupyterNotebookWithoutDataset() {
        DataikuAPI.jupyterNotebooks.newNotebookWithTemplate($stateParams.projectKey,
            $scope.newNotebook.name,
            $scope.newNotebook.template, $scope.newNotebook.codeEnv, $scope.newNotebook.containerConf).success(data => {

            WT1.event('notebook-jupyter-create', {
                notebookId : data.name,
                language: $scope.newNotebook.template.language,
                template : $scope.newNotebook.template.id,
                withDataset: false,
                useCodeEnv: !!data.displayKernelSpec.name
            });

            $scope.dismiss();
            $state.transitionTo("projects.project.notebooks.jupyter_notebook", { projectKey : $stateParams.projectKey, notebookId : data.name })
        }).error(setErrorInScope.bind($scope));
    }

    function createJupyterNotebookWithDataset() {
        DataikuAPI.jupyterNotebooks.newNotebookForDataset($stateParams.projectKey,
            $scope.newNotebook.name,
            $scope.datasetSmartName, $scope.newNotebook.template, $scope.newNotebook.codeEnv, $scope.newNotebook.containerConf)
            .success(data => {
                WT1.event('notebook-jupyter-create', {
                    language: data.language,
                    template : $scope.newNotebook.template.id,
                    withDataset: true,
                    useCodeEnv: !!data.displayKernelSpec.name
                });
                $state.go('projects.project.notebooks.jupyter_notebook', { notebookId: data.name });
                $scope.dismiss();
            }).error(setErrorInScope.bind($scope));
    }

    function createNotebookWithDataset() {
        if (NotebooksUtils.sqlNotebooksTypes.includes($scope.uiState.step)) {
            createSQLNotebookWithDataset();
        } else {
            createJupyterNotebookWithDataset();
        }
    }

    function installSQLFunctions() {
        let autoNotebookName = 'New notebook';
        let userModifiedName = false;
        $scope.connections = [];

        $scope.newNotebook = {
            projectKey: $stateParams.projectKey,
            name: autoNotebookName
        };

        $scope.$watch("newNotebook.name", (nv) => {
            if (nv != null && nv != autoNotebookName) {
                userModifiedName = true;
            }
        });

        //  When creating a sql notebook from a dataset (if datasetSmartName), the connection is automatically chosen by the backend so we do not fetch the list.
        if (!$scope.datasetSmartName) {
            DataikuAPI.sqlNotebooks.listConnections($stateParams.projectKey).success(data => {
                $scope.connections = data.nconns;
                $scope.hiveError = data.hiveError;
            }).error(setErrorInScope.bind($scope));

            $scope.$watch("newNotebook.connection", (nv) => {
                if (!userModifiedName) {
                    for(var k in $scope.connections) {
                        var conn = $scope.connections[k];
                        if (conn.name == nv) {
                            autoNotebookName = $scope.appConfig.login + "'s notebook on " + conn.label;
                            $scope.newNotebook.name = autoNotebookName;
                        }
                    }
                }
            });
        } else {
            $scope.newNotebook.name = `${$scope.appConfig.login}'s sql notebook on ${$scope.datasetSmartName}`;
        }

        $scope.createAndRedirect = function() {
            if ($scope.datasetSmartName) {
                createNotebookWithDataset();
            } else {
                createSQLNotebookWithoutDataset();
            }
        };
    }

    const NICE_TYPES = {r: "R", python: "Python", scala: "Scala (Spark)", julia: "Julia"};

    function installJupyterStd(type) {
        let userModifiedName = false;
        const niceType = NICE_TYPES[type] || type;
        const autoNotebookName = $scope.appConfig.user.login.replace(/\.+/g, ' ') + "'s " + niceType + " notebook";

        $scope.newNotebook = {
            name : autoNotebookName,
            language: type,
            containerConf: ''
        };

        $scope.$watch("newNotebook.name", nv => {
            if (nv != null && nv != autoNotebookName) {
                userModifiedName = true;
            }
        });

        if ($scope.datasetSmartName) {
            $scope.newNotebook.name += ' on ' + $scope.datasetSmartName;
        }

        DataikuAPI.notebooks.listTemplates($scope.datasetSmartName ? 'DATASET' : 'STANDALONE', type).success(data => {
            $scope.availableTemplates = data.templates;
            $scope.newNotebook.template = $scope.availableTemplates[0];
        }).error(setErrorInScope.bind($scope));

        $scope.$watch("newNotebook", function(nv, ov) {
            if (!nv) return;
            if ($scope.availableCodeEnvs == null) {
            	if (nv.language == "python" || nv.language == "r" || nv.language == "julia") {
                    $scope.availableCodeEnvs = []; // so that you only do the call once
                    DataikuAPI.codeenvs.listNamesWithDefault(nv.language.toUpperCase(), $stateParams.projectKey).success(function(data){
                        $scope.availableCodeEnvs =
                            [["__BUILTIN__", "Default builtin env"]].concat(data.envs.map(function(ce){
                                return [ce.envName, ce.envName];
                            }))
                        $scope.newNotebook.codeEnv = data.resolvedInheritDefault || "__BUILTIN__";
                    }).error(setErrorInScope.bind($scope));
            	} else {
            		$scope.availableCodeEnvs = [];
                }
            }
            if ($scope.containerConfs == null) {
                if (nv.language == "python" || nv.language == "r" || nv.language == "julia") {
                    $scope.containerConfs = [{id:'', label:"Run locally"}]
                    if ($scope.appConfig.databricksEnabled) {
                        $scope.containerConfs.push({id:'__SPECIAL_DATABRICKS__', label:"Run on Databricks"});
                    }
                    DataikuAPI.containers.listNamesWithDefault($stateParams.projectKey).success(function(data) {
                        data.containerNames.forEach(function(n) { $scope.containerConfs.push({id:n, label:n});});

                        if (data.resolvedInheritValue) {
                            $scope.newNotebook.containerConf = data.resolvedInheritValue;
                        }

                    }).error(setErrorInScope.bind($scope));
            	} else {
            		$scope.containerConfs = []
                }
            }
        }, true);

        $scope.createAndRedirect = function() {
            if ($scope.datasetSmartName) {
                createNotebookWithDataset();
            } else {
                createJupyterNotebookWithoutDataset();
            }
        };
    }

    $scope.$watch("uiState.step", function(nv, ov) {
        switch (nv) {
            case "sql":
            case "impala":
            case "hive":
            case "sparksql":
                installSQLFunctions(nv);
                break;
            case "python":
            case "julia":
            case "r":
            case "scala":
                installJupyterStd(nv);
                break;
        }
    });

    if ($scope.datasetSmartName) {
        DatasetUtils.listDatasetsUsabilityForAny($stateParams.projectKey).success(data => {
            // move the usable flag where it's going to be read
            data.forEach(x => {
                x.usable = x.usableAsInput;
                x.usableReason = x.inputReason;
            });
            $scope.availableDatasets = data;
            // set the usable flag here instead of in the UsabilityComputer, like the other places seem to do
            angular.forEach($scope.availableDatasets, x => {
                x.usable = true;
            });
        }).error(setErrorInScope.bind($scope));

        $scope.usability = {};

        const parts = $scope.datasetSmartName.match(/([^\.]+)\.(.+)/) || [$scope.datasetSmartName, $stateParams.projectKey, $scope.datasetSmartName]; // [smart, project, dataset]

        DataikuAPI.datasets.getFullInfo($stateParams.projectKey, parts[1], parts[2])
            .success(data => {
                var hasSql = false;

                // Check which languages are available
                ['sql', 'hive', 'impala', 'pig', 'sql99'].forEach(thing => {
                    $scope.usability[thing] = GlobalProjectActions.specialThingMaybePossibleFromDataset(data.dataset, thing);
                    hasSql = hasSql || $scope.usability[thing].ok;
                });

                $scope.usability.spark = { ok: true };

                if (!$rootScope.appConfig.sparkEnabled) {
                    if (!$rootScope.addLicInfo.sparkLicensed) {
                        $scope.usability.spark.ok = false;
                        $scope.usability.spark.reason = 'Spark is not licensed';
                    } else {
                        $scope.usability.spark.ok = false;
                        $scope.usability.spark.reason = 'Spark is not configured';
                    }
                }
            }).error(setErrorInScope.bind($scope));
    }

    $scope.canUseLanguage = function(language) {
        if (!$scope.usability || !$scope.usability[language]) {
            return true;
        } else {
            return $scope.usability[language].ok;
        }
    }

    $scope.getDisabledReason = function(language) {
        if (!$scope.usability || !$scope.usability[language] || !$scope.usability[language].reason) {
            return;
        } else {
            return $scope.usability[language].reason.iconDisabledReason;
        }

    }
});

app.controller('NewNotebookFromTemplateModalController', function($scope, $rootScope, $state, $stateParams, DataikuAPI, WT1) {

    let templatedTemplateDeregister = null;

    $scope.newTemplatedNotebook = {};

    let templatedBaseName = $rootScope.appConfig.login + "'s "
        + "analysis of " + $scope.datasetSmartName;

    $scope.newTemplatedNotebook.baseName = templatedBaseName.replace(/\.+/g, ' ');

    DataikuAPI.notebooks.listTemplates("DATASET", "pre-built").success(data => {
        $scope.newTemplatedNotebook.availableTemplates = data.templates;
        $scope.newTemplatedNotebook.template = $scope.newTemplatedNotebook.availableTemplates[0];
    }).error(setErrorInScope.bind($scope));

    if (templatedTemplateDeregister != null) {
        templatedTemplateDeregister();
    }

    if ($scope.containerConfs == null) {
        $scope.containerConfs = [{id:'', label:"Run locally"}]
        DataikuAPI.containers.listNamesWithDefault($stateParams.projectKey).success(data => {
            data.containerNames.forEach(n => { $scope.containerConfs.push({ id: n, label: n }); });
        }).error(setErrorInScope.bind($scope));
    }

    templatedTemplateDeregister = $scope.$watch('newTemplatedNotebook.template', () => {
        if ($scope.newTemplatedNotebook.template != null) { // something was selected
            if (templatedBaseName == $scope.newTemplatedNotebook.baseName) { // name was not modified by user (yet)
                templatedBaseName = ($scope.newTemplatedNotebook.template.title || $scope.newTemplatedNotebook.template.label) + " on "  + $scope.datasetSmartName + " (" + $rootScope.appConfig.login + ")";
                $scope.newTemplatedNotebook.baseName = templatedBaseName.replace(/\.+/g, ' ');
            }
        }
    });

    $scope.createTemplatedNotebook = () => {
        DataikuAPI.jupyterNotebooks.newNotebookForDataset($stateParams.projectKey,
            $scope.newTemplatedNotebook.baseName,
            $scope.datasetSmartName, $scope.newTemplatedNotebook.template, $scope.newTemplatedNotebook.codeEnv, $scope.newTemplatedNotebook.containerConf)
            .success(data => {
                WT1.event("notebook-jupyter-create", {
                    notebookId : data.name,
                    // Anonymize custom template ids
                    template:
                        $scope.newTemplatedNotebook.template.origin === 'PLUGIN'
                        ? $scope.newTemplatedNotebook.template.id.dkuHashCode()
                        : $scope.newTemplatedNotebook.template.id,
                    withDataset: true,
                    useCodeEnv: !!data.displayKernelSpec.name
                });
                $state.go('projects.project.notebooks.jupyter_notebook', { notebookId: data.name });
                $scope.dismiss();
            }).error(setErrorInScope.bind($scope));
    };
});

app.controller('NewNotebookFromFileModalController', function($scope, $stateParams, DataikuAPI, WT1, $state) {

    $scope.newNotebook = {
        name : $scope.appConfig.user.login.replace(/\.+/g, ' ') + "'s notebook from file"
    };

    function parseNotebook(event) {
        $scope.isParsing = true;
        $scope.$apply();
        // Adding a timeout only for User Experience to display a loader while parsing! It requires using apply for quick refresh.
        window.setTimeout(() => {
            try {
                let fileContent;
                fileContent = JSON.parse(event.target.result);

                $scope.isParsing = false;
                $scope.hasParsingFailed = false;

                const parsedLanguage = fileContent.metadata.kernelspec.language;

                if (parsedLanguage) {
                    $scope.newNotebook.language = parsedLanguage.toLowerCase();
                    $scope.isLanguageSupported = !(['python', 'r', 'scala'].includes($scope.newNotebook.language));
                } else {
                    $scope.hasParsingFailed = true;
                }
                $scope.$apply();
            } catch (exception) {
                $scope.hasParsingFailed = true;
                $scope.isParsing = false;
                $scope.$apply();
            }
        }, 1000);
    }

    $scope.uploadAndRedirect = function() {
        DataikuAPI.jupyterNotebooks.newNotebookFromFile($stateParams.projectKey,
            $scope.newNotebook.name,
            $scope.newNotebook.language,
            $scope.datasetSmartName,
            $scope.newNotebook.file)
                .then(data => {
                    data = JSON.parse(data);

                    WT1.event('notebook-jupyter-upload', {
                        notebookId : data.name,
                        language: $scope.newNotebook.language,
                        withDataset: !!$scope.datasetSmartName
                    });

                    $scope.dismiss();
                    $state.transitionTo('projects.project.notebooks.jupyter_notebook', { projectKey : $stateParams.projectKey, notebookId : data.name })

                }, (error) => {
                    setErrorInScope2.call($scope, error);
                });
    };

    $scope.$watch("newNotebook.file", function(newValue) {
        $scope.newNotebook.language = null;
        $scope.isLanguageSupported = false;
        $scope.hasParsingFailed = false;

        if (newValue) {
            const reader = new FileReader();
            reader.onload = parseNotebook;
            reader.readAsText(newValue);
            $scope.newNotebook.name = newValue.name.replace('.ipynb', '');
        }
    });
});

app.controller('NotebookGitPushWithConflictModalController', function($scope, $stateParams, DataikuAPI, FutureProgressModal, Dialogs, DKUtils) {
    $scope.hasNoNotebooksSelectedForPush = () => {
        return !$scope.notebookConflictStatus.conflictingNotebooks.some(notebook => notebook.selected)
            && !$scope.notebookConflictStatus.nonConflictingNotebooks.some(notebook => notebook.selected)
            && !$scope.notebookConflictStatus.noLongerOnRemoteNotebooks.some(notebook => notebook.selected);
    }

    // User have chosen notebooks, push force them.
     $scope.forcePushNotebooks = () => {
        const nonConflictingNotebooks = $scope.notebookConflictStatus.nonConflictingNotebooks;
        const conflictingNotebooks =  $scope.notebookConflictStatus.conflictingNotebooks.filter(notebook => notebook.selected);
        const noLongerOnRemoteNotebooks =  $scope.notebookConflictStatus.noLongerOnRemoteNotebooks.filter(notebook => notebook.selected);

        if (!$scope.commitMessage.title) {
            $scope.commitMessage.title = $scope.getDefaultCommmitMessage();
        }
        let commitMessage = $scope.commitMessage.title;
        if ($scope.commitMessage.content && $scope.commitMessage.title) {
            commitMessage = `${$scope.commitMessage.title}\n${$scope.commitMessage.content}`;
        }
        DataikuAPI.jupyterNotebooks.git.pushNotebooksToGit($stateParams.projectKey,
            [...nonConflictingNotebooks, ...conflictingNotebooks, ...noLongerOnRemoteNotebooks],
            commitMessage)
        .success(data => {
            const scope = $scope.$parent;
            $scope.dismiss();
            FutureProgressModal.show(scope, data, "Push notebooks to remote").then(pushReports => {
                if (pushReports) {
                    Dialogs.infoMessagesDisplayOnly(scope, "Report", pushReports, pushReports.futureLog).then(() => {
                        if ($stateParams && $stateParams.notebookId) {
                            DKUtils.reloadState();
                        }
                    })
                }
            });
        }).error(setErrorInScope.bind($scope));
    }
});

app.controller('NotebookGitPullWithConflictModalController', function($scope, $stateParams, DataikuAPI, FutureProgressModal, DKUtils, Dialogs) {
    $scope.hasNoNotebooksSelectedForPull = () => {
        return !$scope.notebookConflictStatus.conflictingNotebooks.some(notebook => notebook.selected)
            && !$scope.notebookConflictStatus.nonConflictingNotebooks.some(notebook => notebook.selected);
    }

    // User have chosen notebooks, push force them.
     $scope.forcePullNotebooks = () => {
        const nonConflictingNotebookIds = $scope.notebookConflictStatus.nonConflictingNotebooks.map(notebook => notebook.notebookName);
        const conflictingNotebookIds =  $scope.notebookConflictStatus.conflictingNotebooks.filter(notebook => notebook.selected).map(notebook => notebook.notebookName);

        DataikuAPI.jupyterNotebooks.git.pullNotebooks($stateParams.projectKey, [...nonConflictingNotebookIds, ...conflictingNotebookIds])
        .success(data => {
            const scope = $scope.$parent;
            $scope.dismiss();
            FutureProgressModal.show(scope, data, "Pull notebooks from remote").then(pullReports => {
                if (pullReports) {
                    Dialogs.infoMessagesDisplayOnly(scope, "Report", pullReports, pullReports.futureLog).then(() => {
                        if ($stateParams && $stateParams.notebookId) {
                            DKUtils.reloadState();
                        }
                    })
                }
            });
        }).error(setErrorInScope.bind($scope));
    }
});

app.directive('notebookConflictHit', function() {
    return {
        scope: {
          notebook: '=',
          noSelection: '=?' // When we are not enabling the selection, reduce the margin-left to 36px to have a better style
        },
        template: `
        <div class="hit h100">
            <div class="illustration">
                <span ng-if="notebook.language && notebook.language.startsWith('python')">
                    <i class="icon-code_python_recipe universe-color notebook"></i>
                </span>
                <span ng-if="notebook.language=='ir' || notebook.language=='R'">
                    <i class="icon-code_r_recipe universe-color notebook"></i>
                </span>
                <span ng-if="notebook.language.startsWith('julia')">
                    <i class="icon-code_julia_recipe universe-color notebook"></i>
                </span>
                <span ng-if="notebook.language=='toree' || notebook.language=='scala'">
                    <i class="icon-code_spark_scala_recipe universe-color notebook"></i>
                </span>
            </div>
            <div class="h100 hitContent" ng-class="{'hitContent__no-selection': noSelection}">
                <i class="icon-info-sign text-prompt" style="float: right; margin-top: 10px;" toggle="tooltip" container="body" title="Name on the remote Git: {{notebook.remoteNotebookName}}" />
                <div class="hit-content-main">
                    <p class="hit-content-main__title">{{notebook.notebookName}}</p>
                    <p class="hit-content-main__subtitle">
                        {{notebook.gitUrl}} - {{notebook.gitBranch}}
                    </p>
                </div>
            </div>
        </div>`
    };
});

app.service('NotebooksUtils', function(CreateModalFromTemplate, DataikuAPI, DKUtils, $stateParams, $rootScope, FutureProgressModal) {
    var svc = {
        parseConnection: function(connection) {
            var virtualPattern = /^@virtual\((.+)\):(connection:)?(.+)$/;
            var parsed = virtualPattern.exec(connection);
            var niceConnection = connection;
            var type = "SQL";
            if(parsed) {
                if(parsed[1].indexOf('impala')>=0) {
                    niceConnection = parsed[3] + ' (Impala)';
                    type = "IMPALA";
                } else if(parsed[1].indexOf('hive')>=0) {
                    niceConnection = parsed[3] + ' (Hive)';
                    type = "HIVE";
                } else {
                    niceConnection = parsed[3] + ' (SparkSQL)';
                    type = "SPARKSQL";
                }
            }
            return {type: type, niceConnection:niceConnection};
        },

        getNotebookIcon: function(item) {
            const lowerCaseLanguage = item.language.toLowerCase();
            const nbType = item.notebookType || item.type || item.language;
            if (lowerCaseLanguage=='python2' || lowerCaseLanguage=='python3' || lowerCaseLanguage=='python') {return 'icon-code_python_recipe';}
            else if (lowerCaseLanguage=='ir' || lowerCaseLanguage=='r') {return 'icon-code_r_recipe';}
            else if (lowerCaseLanguage.startsWith('julia')) {return 'icon-code_julia_recipe';}
            else if (lowerCaseLanguage=='toree' || lowerCaseLanguage=='scala') {return 'icon-code_spark_scala_recipe';}
            else if (nbType == 'SQL') {return 'icon-code_sql_recipe';}
            else if (nbType == 'HIVE') {return 'icon-code_hive_recipe';}
            else if (nbType == 'IMPALA') {return 'icon-code_impala_recipe';}
            else if (nbType == 'SPARKSQL') {return 'icon-code_sparksql_recipe';}
            else {return 'icon-dku-nav_notebook'}
        },

        pushNotebooksToRemote: function(scope) {
            return function(selectedNotebooks) {
                // Start by investigating if there is some remote notebooks that have changed
                DataikuAPI.jupyterNotebooks.git.getConflictingNotebooks($stateParams.projectKey, selectedNotebooks.filter(n => n.gitReference).map(n => n.id), false)
                .success(data => {
                    FutureProgressModal.show(scope, data, "Checking conflicts").then(notebookConflictStatus => {
                        if (notebookConflictStatus) {
                            // We have conflicting remove notebooks, let's pop a modal to ask the user what we do next
                            CreateModalFromTemplate("/templates/notebooks/notebook-git-push-with-conflict-modal.html", scope, "NotebookGitPushWithConflictModalController", newScope => {
                                newScope.notebookConflictStatus = notebookConflictStatus
                                newScope.getDefaultCommmitMessage = () => {
                                    if (notebookConflictStatus.nonConflictingNotebooks.length + notebookConflictStatus.conflictingNotebooks.length === 1) {
                                        return 'Export ' + notebookConflictStatus.nonConflictingNotebooks.concat(notebookConflictStatus.conflictingNotebooks)[0].notebookName;
                                    } else {
                                        return 'Export %filename%';
                                    }
                                }
                                newScope.commitMessage = {
                                    title: "",
                                    content: ""
                                };
                            });
                        }
                    })
                }).error(setErrorInScope.bind(scope));
            };
        },
        pullNotebooksFromRemote: function(scope) {
            return function(selectedNotebooks) {
                DataikuAPI.jupyterNotebooks.git.getConflictingNotebooks($stateParams.projectKey, selectedNotebooks.filter(n => n.gitReference).map(n => n.id), true)
                .success(data => {
                    FutureProgressModal.show(scope, data, "Checking conflicts").then(notebookConflictStatus => {
                        if (notebookConflictStatus) {
                            // We have conflicting remove notebooks, let's pop a modal to ask the user what we do next
                            CreateModalFromTemplate("/templates/notebooks/notebook-git-pull-with-conflict-modal.html", scope, "NotebookGitPullWithConflictModalController", newScope => {
                                newScope.notebookConflictStatus = notebookConflictStatus
                            });
                        }
                    })
                }).error(setErrorInScope.bind(scope));
            };
        },
        editNotebookReference: function(scope) {
            return function(endCallback = () => {}) {
                return function(notebook) {
                    CreateModalFromTemplate("/templates/notebooks/notebook-git-edit-reference-modal.html", scope, null, newScope => {
                        newScope.isEditMode = notebook.gitReference !== undefined;
                        newScope.notebook = notebook;
                        newScope.gitRef = Object.assign({}, notebook.gitReference);
                        if (!newScope.gitRef.remotePath) {
                            newScope.gitRef.remotePath = notebook.name + ".ipynb";
                        }
                        newScope.save = () => {
                            DataikuAPI.jupyterNotebooks.git.editReference(notebook.projectKey, notebook.name, newScope.gitRef)
                            .success(() => {
                                endCallback();
                                newScope.dismiss();
                            })
                            .error(setErrorInScope.bind(newScope));
                        }
                    });
                };
            };
        },
        unlinkNotebookReference: function(scope) {
            return function(endCallback = () => {}) {
                return function(notebook) {
                    CreateModalFromTemplate("/templates/notebooks/notebook-git-unlink-reference-modal.html", scope, null, newScope => {
                        // transform into NotebooksPushGitDTO
                        newScope.notebook = {
                            notebookName: notebook.name,
                            remoteNotebookName: notebook.gitReference.remotePath,
                            gitUrl: notebook.gitReference.remote,
                            gitBranch: notebook.gitReference.checkout,
                            language: notebook.language
                        };

                        newScope.unlink = () => {
                            DataikuAPI.jupyterNotebooks.git.unlinkReference(notebook.projectKey, notebook.name)
                            .success(() => {
                                endCallback();
                                newScope.dismiss();
                            })
                            .error(setErrorInScope.bind(newScope));
                        }
                    });
                };
            };
        },

        sqlNotebooksTypes: [
            'sql',
            'impala',
            'hive',
            'sparksql'
        ]
    };
    return svc;
});


})();

(function() {
'use strict';

const app = angular.module('dataiku.notebooks.sql', ['dataiku.services', 'dataiku.filters']);


app.controller('SQLNotebookController', function (
        $scope, $state, $timeout, $q, $modal, $stateParams, $rootScope,
        Assert, WT1, Logger, DataikuAPI, Dialogs, TopNav, BigDataService,
        LocalStorage, HistoryService, SQLExplorationService, CreateExportModal,
        ExportUtils, CreateModalFromTemplate) {

	/* *********************** Basic CRUD ********************* */

    $scope.loadNotebook = function() {
        var deferred = $q.defer();
    	DataikuAPI.sqlNotebooks.getSummary($stateParams.projectKey, $stateParams.notebookId).success(function(data) {
            $scope.notebookParams = data.object;
            $scope.objectInterest = data.interest;
            $scope.objectTimeline = data.timeline;

            TopNav.setItem(TopNav.ITEM_SQL_NOTEBOOK, $scope.notebookParams.id, {
                name : $scope.notebookParams.name
                , isHive: $scope.notebookParams.language == 'HIVE'
                , isImpala: $scope.notebookParams.language == 'IMPALA'
                , isSpark: $scope.notebookParams.language == 'SPARKSQL'
            });
            TopNav.setPageTitle($scope.notebookParams.name + " - SQL");

            WT1.event("sql-notebook-load", {language: $scope.notebookParams.language});

    		DataikuAPI.sqlNotebooks.listConnections($stateParams.projectKey).success(function(connections) {
    		    $scope.connectionDetails = undefined;
                $scope.connectionFailed = false;
                for (var i = 0; i < connections.nconns.length; i++) {
                    if (connections.nconns[i].name == $scope.notebookParams.connection) {
                        $scope.connectionDetails = connections.nconns[i];
                        break;
                    }
                }
                if(!$scope.connectionDetails) {
                    $scope.connectionFailed = true;
                } else {
                    $scope.notebookMode = $scope.connectionDetails.type == "HiveServer2" ? "HIVE" : "SQL";
                }

                $scope.notebookLocalState = {};
                $scope.notebookTmpState = {};
                $scope.notebookLocalState.cellMode = 'SINGLE';
                $scope.notebookLocalState.tableListingMode = 'PROJECT';
                $scope.notebookLocalState.tableOrdering = 'TABLE';
                $scope.notebookLocalState.leftPaneTab = 'Cells';

                $scope.$watch("notebookLocalState", $scope.saveLocalStates, true);

                $scope.updateNotebookHistory().then(function() {
                    $scope.$broadcast("history-first-time-loaded");
                });

                if($scope.connectionDetails) {
                    deferred.resolve("ok");
                    $scope.$broadcast('notebookLoaded');
                }
            }).error(setErrorInScope.bind($scope));
    	}).error(setErrorInScope.bind($scope));
        return deferred.promise;
    };

    $scope.refreshTimeline = function(projectKey) {
        DataikuAPI.timelines.getForObject(projectKey || $stateParams.projectKey, "SQL_NOTEBOOK", $stateParams.notebookId).success(function(data) {
            $scope.objectTimeline = data;
        }).error(setErrorInScope.bind($scope));
    };

    $scope.duplicateNotebook = function() {
        WT1.event("sql-notebook-copy", {});
        DataikuAPI.sqlNotebooks.copy($stateParams.projectKey, $stateParams.notebookId, $scope.notebookParams.name+'_copy').success(function(data) {
            $state.transitionTo("projects.project.notebooks.sql_notebook", {projectKey: $stateParams.projectKey, notebookId: data.id});
        }).error(setErrorInScope.bind($scope));
    };

    $scope.$on('customFieldsSummaryEdited', function(event, customFields) {
        $scope.saveCustomFields(customFields);
    });

    $scope.saveCustomFields = function(newCustomFields) {
        WT1.event('custom-fields-save', {objectType: 'SQL_NOTEBOOK'});
        let oldCustomFields = angular.copy($scope.notebookParams.customFields);
        $scope.notebookParams.customFields = newCustomFields;
        return DataikuAPI.sqlNotebooks.save($scope.notebookParams).success(function(data) {
                $scope.refreshTimeline();
                HistoryService.notifyRenamed({
                    type: "SQL_NOTEBOOK",
                    id: $scope.notebookParams.id,
                    projectKey: $scope.notebookParams.projectKey
                }, $scope.notebookParams.name);
                $rootScope.$broadcast('customFieldsSaved', TopNav.getItem(), $scope.notebookParams.customFields);
            }).error(function(a, b, c) {
                $scope.notebookParams.customFields = oldCustomFields;
                setErrorInScope.bind($scope)(a, b,c);
            });
    };

    $scope.editCustomFields = function() {
        if (!$scope.notebookParams) {
            return;
        }
        let modalScope = angular.extend($scope, {objectType: 'SQL_NOTEBOOK', objectName: $scope.notebookParams.name, objectCustomFields: $scope.notebookParams.customFields});
        CreateModalFromTemplate("/templates/taggable-objects/custom-fields-edit-modal.html", modalScope).then(function(customFields) {
            $scope.saveCustomFields(customFields);
        });
    };

	var saveParams = function() {
		DataikuAPI.sqlNotebooks.save($scope.notebookParams).success(function(data) {
			if (data && data.versionTag) {
				$scope.notebookParams.versionTag = data.versionTag;
			}
			doSaveLocalStates();
			$scope.refreshTimeline();
            HistoryService.notifyRenamed({
                type: "SQL_NOTEBOOK",
                id: $scope.notebookParams.id,
                projectKey: $scope.notebookParams.projectKey
            }, $scope.notebookParams.name);
	   	}).error(setErrorInScope.bind($scope));
	};

    /* Auto save */
    var saveParamsTimer;
    $scope.$watch("notebookParams", function(nv, ov) {
        if (nv && ov) {
            Logger.info("Notebook params updated");
            const beforeCopy = angular.copy(ov);
            const afterCopy = angular.copy(nv);
            beforeCopy.versionTag = null;
            afterCopy.versionTag = null;
            if (angular.equals(beforeCopy, afterCopy)) {
                Logger.debug("Only the version tag was modifed, ignoring")
                return;
            }
            $timeout.cancel(saveParamsTimer);
            saveParamsTimer = $timeout(saveParams, 1000);
        }
    }, true);

	/* *********************** Initialization code **************** */

    TopNav.setLocation(TopNav.TOP_NOTEBOOKS, 'notebooks', TopNav.TABS_SQL_NOTEBOOK, "query");
    TopNav.setItem(TopNav.ITEM_SQL_NOTEBOOK, $stateParams.notebookId);

    $scope.uiState = { codeSamplesSelectorVisible: false };

	$scope.loadNotebook().then(function() {
        $scope.cells = $scope.notebookParams.cells;//TODO is that useful?
        $scope.cells.forEach(function(cell){
            cell.$localState = cell.$localState || {}; // localStorage, not sent to server
            cell.$tmpState = cell.$tmpState || {}; // non persistent state
            cell.type = cell.type || 'QUERY';
            if (cell.type == 'QUERY') {
                cell.$localState.query = cell.$localState.query || {};
                var q = cell.$localState.query;
                if ((!q.sql || !q.sql.length) && cell.code) {
                    q.sql = cell.code;
                }
            }
        })
        loadLocalStates();
    });

    $scope.$watch("notebookLocalState.leftPaneTab", function() {
        $scope.$broadcast("reflow");
    });

    /* ************  Cells management *************** */

    var getSpecifiedCellOrSelectedOrLast = function(index) {
        if (index !== undefined) return index;
        var selected = $scope.getSelectedCellIndex();
        if (selected !== undefined) return selected;
        var last = $scope.cells.length - 1;
        return last;
    };

    $scope.selectCell = function(index) {
        $scope.cells.forEach(function(cell, idx) {
            var wasSelected = cell.$localState.selected;
            cell.$localState.selected = idx == index;
            if (!wasSelected && cell.$localState.selected && cell.focusQuery) {
                $timeout(function(){
                    cell.focusQuery();
                }, 500);
            }
        });
        loadResultsIfNeeded();
    };

    //returns the index of the selected cell or undefined if none selected
    $scope.getSelectedCellIndex = function() {
        if (!$scope.cells) return;
        for (var i = 0; i < $scope.cells.length; i++) {
            var cell = $scope.cells[i];
            if (cell.$localState && cell.$localState.selected) return i;
        }
    };

    $scope.selectedCell = function() {
        if (!$scope.cells) return;
        return $scope.cells[$scope.getSelectedCellIndex()];
    };

    $scope.addCell = function(type, index) {
        if (index === undefined) index = $scope.cells.length;
        var cell = {
            type: type,
            id: generateUniqueId(),
            $localState: {unfolded: true},
            $tmpState: {},
            querySettings: {
                addLimitToStatement: true,
                statementsParseMode : "SPLIT",
                statementsExecutionMode : "PREPARED"
            }
        };
        $scope.cells.splice(index, 0, cell);
        $scope.selectCell(index);
        $scope.scrollToCell(index);

        WT1.event("sql-notebook-add-cell", {number_of_cells: $scope.cells.length});
        return cell;
    };

    $scope.removeCell = function(index) {
        if (index === undefined) return;
        Dialogs.confirm($scope, "Confirm deletion", "Are you sure you want to remove this cell ?").then(function() {
            $scope.cells.splice(index, 1);
            if ($scope.cells.length) {
                $scope.selectCell(index < $scope.cells.length ? index : $scope.cells.length - 1);
            }
        });
    };

    $scope.duplicateCell = function(index) {
        if (index === undefined) return;
        WT1.event("sql-notebook-duplicate-cell", {});
        var originalCell = $scope.cells[index];
        //avoid copying some things. Not very pretty...
        var l = originalCell.$localState;
        var t = originalCell.$tmpState;
        originalCell.$localState = {};
        originalCell.$tmpState = {};
        var newCell = angular.copy(originalCell);
        newCell.id = Math.random();
        originalCell.$localState = l;
        originalCell.$tmpState = t;
        if (originalCell.type == 'QUERY') {
            newCell.$localState.query = {sql: l.query.sql};
        }
        $scope.cells.splice(index + 1, 0, newCell);
    };

    $scope.moveCell = function(index, shift) {
        if (index === undefined) return;
        WT1.event("sql-notebook-move-cell", {});
        if (index + shift < 0) {
            shift = -index;
        } else if (index + shift >= $scope.cells.length) {
            shift = $scope.cells.length - 1 - index;
        }
        var cell = $scope.cells[index + shift];
        $scope.cells[index + shift] = $scope.cells[index];
        $scope.cells[index] = cell;
        $scope.scrollToCell(index + shift);
    };

    $scope.hasUnfoldedCell = function() {
        if (!$scope.cells) return;
        for (var i = 0; i < $scope.cells.length; i++) {
            var cell = $scope.cells[i];
            if (cell.$localState && cell.$localState.unfolded) return true;
        }
        return false;
    };

    $scope.unfoldAllCells = function(unfold) {
        WT1.event("sql-notebook-unfold-all-cells", {});
        if (!$scope.cells) return;
        for (var i = 0; i < $scope.cells.length; i++) {
            var cell = $scope.cells[i];
            cell.$localState.unfolded = unfold;
        }
    };

    $scope.selectCellAndScroll = function(index) {
        $scope.selectCell(index);
        $timeout(function(){
            $scope.scrollToCell(index);
        }, 200)
    };

    $scope.scrollToCell = function(index) {
        $timeout(function() {
            $('.multi-query-editor').scrollTop($('.sql-notebook-cell')[index].offsetTop);
        }, 100);
    };

    $scope.filterCells = function() {
        var filteredCells = $scope.cells;
        if (!$scope.cells || !$scope.notebookLocalState) return;
        var query = $scope.notebookLocalState.cellsQuery;
        if (query && query.trim().length) {
            angular.forEach(query.split(/\s+/), function(token){
                token = token.toLowerCase();
                if (token.length) {
                    filteredCells = $.grep(filteredCells, function(cell){
                        return cell.name && cell.name.toLowerCase().indexOf(token) >= 0 ||
                        (cell.$localState && cell.$localState.query && cell.$localState.query.sql && cell.$localState.query.sql.toLowerCase().indexOf(token) >= 0);
                    });
                }
            });
            $scope.cells.forEach(function(cell){
                cell.$tmpState.filteredOut = true;
            });
        }
        filteredCells.forEach(function(cell){
            cell.$tmpState.filteredOut = false;
        });
        $scope.filteredCells = filteredCells.length;
    };
    $scope.$watchCollection("cells", $scope.filterCells);
    $scope.filterCells();

    /* ************  Locally persistent state *************** */

    function localStorateId() {
        return "SQL_NOTEBOOK_"+$stateParams.projectKey + "_" + $scope.notebookParams.id;
    }

    var onLocalStatesLoaded = function() {
        // Make sure a cell is selected
        if ($scope.cells && $scope.cells.length) {
            var selectedCell = $scope.selectedCell();
            if (!selectedCell) {
                $scope.selectCell(0);
            }
        }
    };

    var loadLocalStates = function() {
        if (!$scope.cells) return;
        var localState = LocalStorage.get(localStorateId()) || {cellsStates:{}};
        Logger.info("Loading SQL notebook local state", localState);
        if (localState.notebookLocalState && localState.notebookLocalState.versionTag && localState.notebookLocalState.versionTag.versionNumber < $scope.notebookParams.versionTag.versionNumber) {
            Logger.info("Local state is outdated, discarding saved queries");
            // the localState is outdated, discard all saved queries
            $.each(localState.cellsStates, function(id, cell) {
                delete cell.query;
            });
        }
        $scope.notebookLocalState = $.extend($scope.notebookLocalState || {}, localState.notebookLocalState);
        $scope.cells.forEach(function(cell){
            cell.$localState = $.extend(cell.$localState || {}, localState.cellsStates[cell.id]);
        });
        onLocalStatesLoaded();
    };

    var doSaveLocalStates = function() {
        if (!$scope.notebookParams) return;
        var localState = {cellsStates: {}};
        localState.notebookLocalState = $scope.notebookLocalState;
        localState.notebookLocalState.versionTag = $scope.notebookParams.versionTag
        if ($scope.cells) {
            $scope.cells.forEach(function(cell){
                localState.cellsStates[cell.id] = cell.$localState;
            });
        }
        const now = new Date().getTime();
        LocalStorage.set(localStorateId(), localState);
        Logger.info("Saved SQL notebook local state time=" + (new Date().getTime() - now));
    };

    var saveLocalStateTimer;
    $scope.saveLocalStates = function() {
        $timeout.cancel(saveLocalStateTimer);
        saveLocalStateTimer = $timeout(doSaveLocalStates, 250);
    };

    /* ************  Text insertion *************** */

    function insertText(text, addSelectIfEmptyQuery) {
        var cell = $scope.selectedCell();
        if (cell && cell.$tmpState.insertText) {
            cell.$tmpState.insertText(text, addSelectIfEmptyQuery);
        } else {
            Logger.warn("Cannot insert text: no current cell or no insertText function");
        }
    }

    $scope.onTableClicked = function(table) {
        insertText(table.quoted, true);
    };

    $scope.onFieldClicked = function(field) {
        insertText(field.quotedName);
    };

    $scope.insertCodeSnippet = function(snippet) {
        insertText(snippet.code);
    }

    /* ************ History ************ */

    $scope.updateNotebookHistory = function() {
        var deferred = $q.defer();
        DataikuAPI.sqlNotebooks.getHistory($stateParams.projectKey, $stateParams.notebookId).success(function(data) {
            $scope.notebookTmpState.history = data;
            deferred.resolve("ok");
        }).error(setErrorInScope.bind($scope));
        return deferred.promise;
    };

    $scope.clearHistory = function(cellId) {
        var deferred = $q.defer();
        Dialogs.confirm($scope, 'Are you sure you want to clear query history?').then(function() {
            WT1.event("sql-notebook-clear-history", {});
            DataikuAPI.sqlNotebooks.clearHistory($stateParams.projectKey, $stateParams.notebookId, cellId).success(function(data) {
                delete $scope.notebookTmpState.history[cellId];
                deferred.resolve("ok");
            }).error(setErrorInScope.bind($scope));
        });
        return deferred.promise;
    };

    var loadResultsIfNeeded = function() {
        var cell = $scope.selectedCell();
        if ($scope.notebookLocalState.cellMode == 'SINGLE' && cell.$localState.selected) {
            if (!$scope.fetchingResults[cell.id] && cell.$tmpState.lastQuery  && !cell.$tmpState.runningQuery && !cell.$tmpState.results) { //&& cell.$tmpState.lastQuery.state == 'DONE'
                $scope.fetchLastResults(cell, cell.$tmpState.lastQuery.id)
            }
        }
    };

    $scope.loadQuery = function(cell, query, fetchResults) {
        Assert.trueish(cell, 'no cell');
        delete cell.$tmpState.results;
        cell.$localState.query = angular.copy(query);
        cell.$localState.unfolded = true;
        if(query.state == "RUNNING" || query.state == "NOT_STARTED") {
            cell.$tmpState.runningQuery = angular.copy(query);
            cell.$tmpState.waitFuture();
        } else {
            cell.$tmpState.lastQuery = angular.copy(query);
            loadResultsIfNeeded();
        }
    };

    $scope.createCellWithQuery = function(hQuery, index) {
        var initialCell = $scope.selectedCell();
        var cell = $scope.addCell('QUERY', index);
        cell.name = initialCell.name ? initialCell.name + '_copy' : '';
        cell.$localState.query = cell.$localState.query || {};
        cell.$localState.query.sql = hQuery.sql;
        //TODO add the query to the cell history
        $scope.notebookLocalState.leftPaneTab = 'Cells';
    };

    $scope.removeQuery = function(q) {
        var cell = $scope.selectedCell();
        if (cell && cell.$tmpState && cell.$tmpState.removeQuery) {
            cell.$tmpState.removeQuery(q);
        }
    };

    $scope.fetchingResults = {};
    $scope.fetchLastResults = function(cell, queryId) {
        if ($scope.fetchingResults[cell.id]) {
            Logger.warn("Cell Already fetching results", cell.id);
            return;
        }
        $scope.fetchingResults[cell.id] = true;
        return DataikuAPI.sqlNotebooks.getHistoryResult($stateParams.projectKey, $stateParams.notebookId, queryId).then(function(resp) {
            cell.$tmpState.results = resp.data;
            cell.$tmpState.clearError();
            return resp;
        }, function(resp) {
            cell.$tmpState.error(resp.data, resp.status, resp.headers);
        })
        .finally(function(){
            delete $scope.fetchingResults[cell.id];
        });
    };
});



app.controller('SqlNotebookQueryCellController', function ($scope, $element, $stateParams, $timeout, $q, DataikuAPI,
               WT1, Logger, Dialogs, CreateModalFromTemplate, CreateExportModal, BigDataService, SQLExplorationService, ExportUtils, CodeMirrorSettingService) {

    /* ************  Execution ************ */

    function resetResults() {
        delete $scope.cell.$tmpState.logs;
        if ($scope.cell.$tmpState.results) {
            delete $scope.cell.$tmpState.results.hasResultset;
        }
    }

    $scope.run = function() {
        if($scope.isQueryEmpty() || $scope.cell.$tmpState.runningQuery) {
            return;
        }
        resetResults();
        WT1.event("sql-notebook-run", {});

        var query = angular.copy($scope.cell.$localState.query);
        query.id = Math.random();
        query.connection = $scope.connectionDetails.name;
        query.mode = $scope.notebookMode;
        query.querySettings = $scope.cell.querySettings;

        var full = false;
        
        $scope.cell.$tmpState.initializingQuery = true;
        DataikuAPI.sqlNotebooks.run($stateParams.projectKey, $stateParams.notebookId, $scope.cell.id, query, full).success(function(startedQuery) {
            $scope.cell.$tmpState.runningQuery = startedQuery.toAddtoHistory;
            $scope.waitFuture();
            $scope.updateCellHistory();
            if ($scope.notebookMode == 'HIVE') {
                $scope.cell.$tmpState.resultsTab = 'LOGS';
            }
            $scope.cell.$tmpState.clearError();
        }).error($scope.cell.$tmpState.error)
        .finally(function(){$scope.cell.$tmpState.initializingQuery = false;});
    };

    $scope.abort = function() {
        if(!$scope.cell.$tmpState.runningQuery) return;
        WT1.event("sql-notebook-abort", {});
        DataikuAPI.sqlNotebooks.abort($stateParams.projectKey, $stateParams.notebookId, $scope.cell.id, $scope.cell.$tmpState.runningQuery.id).success(function(data) {
            // No need to do more, the next future refresh it will handle it
        }).error($scope.cell.$tmpState.error);
    };

    $scope.computeFullCount = function(full) {
        resetResults();
        WT1.event("sql-notebook-full-count", {});
        DataikuAPI.sqlNotebooks.computeFullCount($stateParams.projectKey, $stateParams.notebookId, $scope.cell.id, $scope.cell.$localState.query.id).success(function(startedQuery) {
            $scope.cell.$tmpState.runningQuery = startedQuery.toAddtoHistory;
            $scope.cell.$localState.query = angular.copy(startedQuery.toAddtoHistory);
            $scope.waitFuture();
            $scope.updateCellHistory();

            if ($scope.notebookMode == 'HIVE') {
                $scope.cell.$tmpState.resultsTab = 'LOGS';
            }
            $scope.cell.$tmpState.clearError();
        }).error($scope.cell.$tmpState.error);
    };

    $scope.waitFuture = function() {
        $scope.stopfutureTimer();
        DataikuAPI.sqlNotebooks.getProgress($stateParams.projectKey, $stateParams.notebookId, $scope.cell.id, $scope.cell.$tmpState.runningQuery.id).success(function(data) {
            $scope.runningStatus = data;
            $scope.cell.$tmpState.runningQuery = data.query;
            if (data.logTail) {
                $scope.cell.$tmpState.logs = data.logTail;
            }
            if (data.running) {
                $scope.stopfutureTimer();
                $scope.futureTimer = $timeout($scope.waitFuture, 1000);
            } else {
                $scope.onFutureDone(data);
            }
        }).error(function(a,b,c) {
            $scope.onFutureFailed(a,b,c);
        });
    };
    $scope.cell.$tmpState.waitFuture = $scope.waitFuture;

    $scope.onFutureDone = function() {
        var flr = $scope.fetchLastResults($scope.cell, $scope.cell.$tmpState.runningQuery.id)
        if (flr) {
            flr.then(function(){
                $scope.stopfutureTimer();

                $scope.cell.$localState.query = angular.copy($scope.cell.$tmpState.runningQuery);//TODO move query to tmpState and remove running query
                $scope.cell.$tmpState.lastQuery = angular.copy($scope.cell.$tmpState.runningQuery);

                $scope.cell.$tmpState.resultsTab = 'RESULTS';

                delete $scope.cell.$tmpState.runningQuery;
                $scope.updateCellHistory();
            });
        }
    };

    $scope.onFutureFailed = function(a,b,c) {
        $scope.cell.$tmpState.error(a,b,c);
        $scope.runningStatus = null;
        $scope.updateCellHistory(); // TODO per cell
    };

    $scope.stopfutureTimer = function() {
        if($scope.futureTimer) {
            $timeout.cancel($scope.futureTimer);
            $scope.futureTimer = null;
        }
    };

    $scope.showExecutionPlan = function() {
        if($scope.isQueryEmpty()) {
            return;
        }
        var query = angular.copy($scope.cell.$localState.query);
        query.id = Math.random();
        query.connection = $scope.connectionDetails.name;
        query.mode = $scope.notebookMode;
        query.querySettings = $scope.cell.querySettings;

        DataikuAPI.sqlNotebooks.getExecutionPlan($stateParams.projectKey, query).success(function(data) {
            CreateModalFromTemplate("/templates/recipes/fragments/sql-modal.html", $scope, null, function(newScope) {
                newScope.executionPlan = data.executionPlan;
                newScope.failedToComputeExecutionPlan = data.failedToComputeExecutionPlan;
                if (!data.failedToComputeExecutionPlan){
                    newScope.query = data.executionPlan.query;
                }
                newScope.uiState = {currentTab: 'plan'};
                newScope.engine = query.mode;
                newScope.isNotebook = true;
            });
        }).error($scope.cell.$tmpState.error);
    };

    /* ************ Code edition ************ */

    $scope.autocompleteSQL = function(cm,type) {
        SQLExplorationService.listTables($scope.notebookParams.connection, $stateParams.projectKey).then(function(tables) {
            var fieldsToAutocomplete = CodeMirror.sqlFieldsAutocomplete(cm, tables);
            if (fieldsToAutocomplete && fieldsToAutocomplete.length) {
                SQLExplorationService.listFields($scope.notebookParams.connection, fieldsToAutocomplete).then(function(data) {
                    CodeMirror.showHint(cm, function(editor) {
                        return CodeMirror.sqlNotebookHint(editor, type+"-notebook", tables.map(function(t) {return t.table;}),data);
                    }, {completeSingle:false});
                });
            } else {
                CodeMirror.showHint(cm, function(editor){
                    return CodeMirror.sqlNotebookHint(editor, type+"-notebook", tables.map(function(t) {return t.table;}), null);
                }, {completeSingle:false});
            }
        });
    };

    $scope.cell.$tmpState.insertText = function(text, addSelectIfEmptyQuery) {
        if (addSelectIfEmptyQuery && $scope.isQueryEmpty()) {
            text = 'SELECT * FROM '+text;
        }
        $scope.cm.replaceSelection(text);
        var endPos = $scope.cm.getCursor(false);
        $scope.cm.setCursor(endPos);
        $scope.cm.focus();
    };

    $scope.cell.$tmpState.removeQuery = function(hQuery) {
        // if(q.id == $scope.query.id) {
        //     $scope.query.id = undefined;
        //     $scope.query.cachedResult = undefined;
        // }

        DataikuAPI.sqlNotebooks.removeQuery($stateParams.projectKey, $stateParams.notebookId, $scope.selectedCell().id, hQuery.id)
            .success($scope.updateCellHistory)
            .error($scope.cell.$tmpState.error);
    };

    /* ************ History ************ */

    $scope.showHistoryModal = function() {
        CreateModalFromTemplate("/templates/notebooks/sql-notebook-history-modal.html", $scope);
    };

    $scope.updateCellHistory = function() {
        var deferred = $q.defer();
        DataikuAPI.sqlNotebooks.getCellHistory($stateParams.projectKey, $stateParams.notebookId, $scope.cell.id).success(function(data) {
            $scope.notebookTmpState.history = $scope.notebookTmpState.history || {};
            $scope.notebookTmpState.history[$scope.cell.id] = data;
            deferred.resolve("ok");
            $scope.cell.$tmpState.clearError();
        }).error($scope.cell.$tmpState.error);
        return deferred.promise;
    };

    /* ************ Export to recipe ************ */

    // https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions
    function escapeRegExp(string){
        return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
    };

    $scope.createRecipe = function() {
        var script = $scope.cell.$localState.query.sql
        var fromPosition = script.search(/\sfrom\s/i);
        var candidateTables = [];

        if(fromPosition != -1) {
            // Extract table names
            var afterFrom = script.substring(fromPosition+5).toLowerCase();
            candidateTables = afterFrom.split(/['"`.\s]+/);
        }

        // Load table mapping
        DataikuAPI.connections.getSQLTableMapping($scope.notebookParams.connection).success(function(mapping){
            var candidateInputs = [];
            // Assign inputs
            for(var i in candidateTables) {
                for(var j in mapping) {
                    if(mapping[j].projectKey == $stateParams.projectKey
                    && mapping[j].table.toLowerCase() == candidateTables[i].toLowerCase()) {
                        candidateInputs.push(mapping[j].dataset);
                    }
                }
            }

            // Dedup
            candidateInputs = candidateInputs.filter(function(e,i) { return candidateInputs.indexOf(e) == i;});
            var recipeType = 'sql_query';
            if ($scope.notebookParams.connection.startsWith('@virtual(hive-hproxy)')) recipeType = 'hive';
            if ($scope.notebookParams.connection.startsWith('@virtual(hive-jdbc)')) recipeType = 'hive';
            if ($scope.notebookParams.connection.startsWith('@virtual(impala-jdbc)')) recipeType = 'impala';
            if ($scope.notebookParams.connection.startsWith('@virtual(spark-livy)')) recipeType = 'spark_sql_query';
            var prefillKey = BigDataService.store({
                script : script,
                input : candidateInputs,
                output :[]
            });
            $scope.showCreateCodeBasedModal(recipeType, null, null, prefillKey);
        }).error($scope.cell.$tmpState.error);
    };

    /* ************ Export results ************ */

    $scope.exportCurrent = function() {
        WT1.event("sql-notebook-export", {});
        DataikuAPI.sqlNotebooks.testStreamedExport($stateParams.projectKey, $stateParams.notebookId, $scope.cell.id, $scope.cell.$tmpState.lastQuery.id).success(function(data) {
            var features = {
                advancedSampling : false,
                partitionListLoader : null,
                isDownloadable : data.streamedExportAvailable
            };
            var dialog = {
                title : 'SQL Query',
                warn : data.streamedExportAvailable ? null : 'Warning! The query will be re-run'
            };
            CreateExportModal($scope,dialog,features).then(function(params) {
                DataikuAPI.sqlNotebooks.exportResults($stateParams.projectKey, $stateParams.notebookId, $scope.cell.id, $scope.cell.$tmpState.lastQuery.id, params).success(function(data) {
                    ExportUtils.defaultHandleExportResult($scope, params, data);
                }).error($scope.cell.$tmpState.error);
            });

        }).error($scope.cell.$tmpState.error);
    };

    /* ************ UI ************ */

    var setupFattable = function(results) {
        if(!results) {
            return;
        }
        $scope.columnWidths = [];
        for(var k in results.columns) {
            var name = results.columns[k].name;
            var size = 100;
            if(name) {
                size = Math.max(size,name.length*7+10);
            }
            $scope.columnWidths.push(size);
        }
        for(var r in results.rows) {
            for(var k in results.rows[r]) {
                var cell = results.rows[r][k];
                if(cell) {
                    $scope.columnWidths[k] = Math.max(cell.length*7+10,$scope.columnWidths[k]);
                }
            }
        }
    };

    var setupAutoComplete = function(tables, suggestions) { //TODO tables should be in suggestions?
        if (!$scope.cm) {
            Logger.warn("Failed to setup autocomplete");
            return;
        }
        CodeMirror.showHint($scope.cm, function(editor) {
            return CodeMirror.sqlNotebookHint(editor, $scope.notebookMode+"-notebook", tables.map(function(t) {return t.table;}), data);
        }, {completeSingle:false});
    };

    var scrollToResults = function(){
        $('.multi-query-editor').scrollTop($('.sql-results-header', $element)[0].offsetTop);
    };

    $scope.focusQuery = function() {
        if (!$scope.cm) return;
        $scope.cm.focus();
    };

    $scope.focusQueryAfter = function() {
        $scope.cell.$tpmState = $scope.cell.$tpmState || {};
    };

    $scope.isQueryEmpty = function() {
        return !$scope.cell.$localState.query || !$scope.cell.$localState.query.sql || !$scope.cell.$localState.query.sql.trim();
    };

    $scope.foldQuery = function(fold) {
        WT1.event("sql-notebook-fold-cell", {});
        $scope.cell.$localState.foldQuery = fold;
    };

    $scope.toggleUnfoldTable = function() {
        $scope.cell.$localState.unfoldTable = !$scope.cell.$localState.unfoldTable;
        $scope.$broadcast("reflow"); //For fattable to resize
        if ($scope.cell.$localState.unfoldTable) {
            $timeout(scrollToResults);
        };
    };

    /* ************ init ************ */
    $scope.cell.focusQuery = $scope.focusQuery;

    function initQuery() {
        $scope.cell.$localState.query = {
            sql : ''
        };
        if ($scope.cm && $scope.notebookMode == 'HIVE' || $scope.notebookMode == 'IMPALA' || $scope.notebookMode == 'SPARKSQL') {
            $scope.cm.setOption('mode', 'text/x-hivesql');
        }
    }

    $scope.$on('notebookLoaded', initQuery);
    $scope.$on('autocompleteSuggestionsLoaded', setupAutoComplete);

    $scope.editorOptions = function() {
        var mode = ($scope.notebookMode == 'HIVE' || $scope.notebookMode == 'IMPALA' || $scope.notebookMode == 'SPARKSQL') ? 'text/x-hivesql' : 'text/x-sql';
        var opt = {
            noFullScreen: true,
            onLoad: function(cm) {
                $scope.cm = cm;
                if ($scope.notebookMode) {
                    setTimeout(function () {
                        if ($scope.cell.$localState.selected) {
                            cm.focus();
                        }
                    }, 200);
                    $(".CodeMirror", $element).append($('<div class="running-query-overlay"><i class="icon-spin icon-spinner" /></div>'));
                }
            }
        };
        var editorOptions = CodeMirrorSettingService.get(mode, opt);
        editorOptions.extraKeys[CodeMirrorSettingService.getShortcuts()['AUTOCOMPLETE_SHORTCUT']] = function(cm) {
            return $scope.autocompleteSQL(cm, $scope.notebookMode);
        };
        return editorOptions;
    };
    $scope.columnWidths = [];

    $scope.futureTimer = null;
    $scope.$on("$destroy", $scope.stopfutureTimer);

    var saveLocalStatesTimer;
    function saveLocalStateLater() {
        $timeout.cancel(saveLocalStatesTimer);
        saveLocalStatesTimer = $timeout($scope.saveLocalStates, 400);
    }
    $scope.$watch('cell.$localState.query.sql', saveLocalStateLater);

    $scope.$watch('cell.$tmpState.results', setupFattable ,false);

    $scope.$watch('cell.$tmpState.resultsTab', function(nv) {
        if (nv != 'logs') {
            $scope.$broadcast("reflow"); // update fat repeat layout
        }
    });

    setupFattable($scope.cell.$tmpState.results); //DEBUG

    var initLastQuery = function() {
        // Check if the current code is the same as last query, in this case mark the last query as active and load results
        var cellHistory = $scope.notebookTmpState.history[$scope.cell.id];
        $scope.cell.$localState.query = $scope.cell.$localState.query || {};
        var cellCode = $scope.cell.$localState.query.sql
        if (cellHistory && cellHistory.length) {
            var lastQuery = cellHistory[0];
            if (!cellCode || !cellCode.trim() || cellCode == lastQuery.sql) {
                $scope.loadQuery($scope.cell, lastQuery);
            }
        }
    };

    $scope.$on("history-first-time-loaded", initLastQuery);
    if ($scope.notebookTmpState.history) {
        initLastQuery();
    }
});


app.directive('sqlNotebookCell', function(DataikuAPI, $stateParams){
    return {
        link : function(scope, element, attrs) {
            if (scope.cells.length == 1) {
                scope.cell.$localState.unfolded = true;
            }
            scope.$watch("cell.$localState", scope.saveLocalStates, true);

            scope.toggleCell = function() {
                scope.cell.$localState.unfolded = !scope.cell.$localState.unfolded;
            };

            $(element).focus(function(){
                scope.selectCell(scope.$index);
                scope.$apply();
            });
        }
    };
});


app.directive('sqlNotebookQueryCell', function($stateParams, DataikuAPI){
    return {
        templateUrl:'/templates/notebooks/sql-notebook-query-cell.html',
        controller: 'SqlNotebookQueryCellController',
        link : function(scope, element, attrs) {
            scope.cell.$localState.query = scope.cell.$localState.query || {};

            scope.cell.$tmpState.error = function(a,b,c){
                if ($('.local-api-error', element).length > 0) {
                    setErrorInScope.bind($('.local-api-error', element).scope())(a,b,c);
                }
            };

            scope.cell.$tmpState.clearError = function(){
                if ($('.local-api-error', element).length > 0) {
                    resetErrorInScope($('.local-api-error', element).scope());
                }
            };

            $(element).on('click', '.CodeMirror-gutters', function() {
                if (scope.cell.$localState.selected) {
                    scope.foldQuery(true);
                    scope.$apply();
                }
            });
        }
    };
});


app.directive('sqlNotebookQuerySingleCell', function(){
    return {
        templateUrl:'/templates/notebooks/sql-notebook-query-single-cell.html',
        controller: 'SqlNotebookQueryCellController',
        link : function(scope, element, attrs) {
            scope.cell.$tmpState.error = function(a,b,c){
                if ($('.local-api-error', element).length > 0) {
                    setErrorInScope.bind($('.local-api-error', element).scope())(a,b,c);
                }
            };
            scope.cell.$tmpState.clearError = function(){
                if ($('.local-api-error', element).length > 0) {
                    resetErrorInScope($('.local-api-error', element).scope());
                }
            };
        }
    }
});


app.directive('localApiError', function(){
    return {
        scope: {}
    }
});


app.directive('sqlNotebookMdCell', function(DataikuAPI, $stateParams){
    return {
        templateUrl :'/templates/notebooks/sql-notebook-md-cell.html',
        link : function(scope, element, attrs) {
            scope.cell.$localState.tmpCode = scope.cell.code;
            scope.ok = function() {
                scope.cell.code = scope.cell.$localState.tmpCode;
                scope.cell.$tmpState.mdCellEditModeOn = false;
            }
            if (scope.cell.$localState.unfolded === undefined) {
                scope.cell.$localState.unfolded = true;
            }
        }
    };
});


app.directive('sqlNotebookMdSingleCell', function(DataikuAPI, $stateParams){
    return {
        templateUrl :'/templates/notebooks/sql-notebook-md-single-cell.html',
        link : function(scope, element, attrs) {
            scope.cell.$localState.tmpCode = scope.cell.$localState.tmpCode || scope.cell.code;
            scope.ok = function() {
                scope.cell.code = scope.cell.$localState.tmpCode;
                scope.cell.$tmpState.mdCellEditModeOn = false;
            };
        }
    };
});

app.controller("sqlNotebookPageRightColumnActions", async function($controller, $scope, $rootScope, $stateParams, ActiveProjectKey, DataikuAPI) {

    $controller('_TaggableObjectPageRightColumnActions', {$scope: $scope});

    $scope.notebook = (await DataikuAPI.sqlNotebooks.get(ActiveProjectKey.get(), $stateParams.notebookId)).data;

    $scope.selection = {
        selectedObject : {
            projectKey : ActiveProjectKey.get(),
            name : $scope.notebook.name,
            id : $scope.notebook.id,
            nodeType : 'SQL_NOTEBOOK',
            interest : {},
            language : $scope.notebook.language
        },
        confirmedItem : {
            projectKey : ActiveProjectKey.get(),
            name : $stateParams.name,
            id : $scope.notebook.id,
            nodeType : 'SQL_NOTEBOOK',
            interest : {},
            language : $scope.notebook.language
        }
    };

    function updateUserInterests() {
        DataikuAPI.interests.getForObject($rootScope.appConfig.login, "SQL_NOTEBOOK", ActiveProjectKey.get(), $scope.selection.selectedObject.id)
            .success(function(data) {
                $scope.selection.selectedObject.interest = data;
            }).error(setErrorInScope.bind($scope));
    }

    updateUserInterests();
    const interestsListener = $rootScope.$on('userInterestsUpdated', updateUserInterests);

    $scope.$on("$destroy", interestsListener);
});

app.directive('sqlNotebookRightColumnSummary', function(DataikuAPI, $stateParams, QuickView, NotebooksUtils, $controller, ActiveProjectKey, ActivityIndicator, WT1, CreateModalFromTemplate){
    return {
        templateUrl :'/templates/notebooks/sql-notebook-right-column-summary.html',

        link : function(scope, element, attrs) {

            $controller('_TaggableObjectsMassActions', {$scope: scope});
            $controller('_TaggableObjectsCapabilities', {$scope: scope});

            scope.QuickView = QuickView;

            /* Auto save when summary is modified */
            scope.$on("objectSummaryEdited", function(){
                DataikuAPI.sqlNotebooks.save(scope.notebook).success(function(data){
                    ActivityIndicator.success("Saved");
                })
                .error(setErrorInScope.bind(scope));
            });

            scope.saveCustomFields = function(newCustomFields) {
                WT1.event('custom-fields-save', {objectType: 'SQL_NOTEBOOK'});
                let oldCustomFields = angular.copy(scope.notebook.customFields);
                scope.notebook.customFields = newCustomFields;
                return DataikuAPI.sqlNotebooks.save(scope.notebook).success(function(data) {
                        scope.refreshTimeline();
                        HistoryService.notifyRenamed({
                            type: "SQL_NOTEBOOK",
                            id: scope.notebook.id,
                            projectKey: scope.notebook.projectKey
                        }, scope.notebook.name);
                        $rootScope.$broadcast('customFieldsSaved', TopNav.getItem(), scope.notebook.customFields);
                    }).error(function(a, b, c) {
                        scope.notebook.customFields = oldCustomFields;
                        setErrorInScope.bind(scope)(a, b,c);
                    });
            };

            scope.editCustomFields = function() {
                if (!scope.notebook) {
                    return;
                }
                let modalScope = angular.extend(scope, {objectType: 'SQL_NOTEBOOK', objectName: scope.notebook.name, objectCustomFields: scope.notebook.customFields});
                CreateModalFromTemplate("/templates/taggable-objects/custom-fields-edit-modal.html", modalScope).then(function(customFields) {
                    scope.saveCustomFields(customFields);
                });
            };

            scope.refreshData = function(){
                DataikuAPI.sqlNotebooks.get(ActiveProjectKey.get(), scope.selection.selectedObject.id).success(function(data){
                    scope.notebookData = {notebook: data, timeline: scope.notebookTimeline};
                    scope.notebook = data;
                }).error(setErrorInScope.bind(scope));
            }

            scope.refreshTimeline = function(projectKey) {
                if (!scope.selection.selectedObject) return;
                var pkey = scope.selection.selectedObject.projectKey;
                var id = scope.selection.selectedObject.id;
                DataikuAPI.timelines.getForObject(projectKey || ActiveProjectKey.get(), "SQL_NOTEBOOK", scope.selection.selectedObject.id).success(function(data){
                    if (!scope.selection.selectedObject || scope.selection.selectedObject.projectKey != pkey || scope.selection.selectedObject.id != id) {
                        return; // too late!
                    }
                    scope.notebookTimeline = data;
                    if (scope.notebookData) scope.notebookData.timeline = data;
                }).error(setErrorInScope.bind(scope));
            };

            scope.$watch("selection.selectedObject", function(nv, ov) {
                if (!nv) return;
                scope.notebookData = {notebook: nv, timeline: scope.notebookTimeline};
                if(scope.selection.confirmedItem != scope.selection.selectedObject) {
                    scope.notebookTimeline = null;
                }
            });

            scope.$watch("selection.confirmedItem", function(nv, ov) {
                if (!nv) return;
                scope.refreshTimeline(nv.projectKey);
                scope.refreshData();
            });

            scope.$watch('notebook', function(nv, ov){
                if (ov && nv && nv.name == ov.name && !angular.equals(nv.tags, ov.tags)) {
                    DataikuAPI.sqlNotebooks.save(scope.notebook).success(function(data){
                    }).error(setErrorInScope.bind(scope));
                }
            }, true);

            scope.getNotebookIcon = function(item) {
                return NotebooksUtils.getNotebookIcon(item);
            };
        }
    }
});


app.directive('sqlTableExplorer', function($stateParams, $filter, DataikuAPI, SQLExplorationService, Debounce, Logger){
    function generateOnlyLastCall() {
        var ref = null;
        return function() {
            ref = {};
            var curr = ref;
            return function() {
                return curr === ref;
            };
        };
    }

    return {
        templateUrl :'/templates/notebooks/sql-explorer.html',
        restrict: 'E',
        scope : {
            connection: '=',
            connectionDetails: '=',
            notebook: '=',
            onTableClicked: '&?',
            onFieldClicked: '&?'
        },

        link : function(scope) {
            scope.uiState = {
                confirmListTablesFromDB: false, // listing from DB requires user explicit action
                fetchingTables: true
            };
            scope.sortBy = [
                { value: 'DATASET', label: 'Dataset name' },
                { value: 'TABLE', label: 'Table name' }
            ];

            var lastFetchSpecs = null;
            var ignorePreviousListSQLTables = generateOnlyLastCall();
            function load() {
                Logger.info('Init SQL explorer');
                if(!scope.connection) {
                    scope.tables = [];
                    rebuildFatList();
                } else {
                    if (scope.notebook.tableListingMode === 'ALL' && !scope.uiState.confirmListTablesFromDB) {
                        return;
                    }
                    var fetchSpecs = {mode:scope.notebook.tableListingMode, connection:scope.connection, projectKey:$stateParams.projectKey};
                    if (scope.uiState.fetchingTables && angular.equals(lastFetchSpecs, fetchSpecs)) {
                        Logger.info('Same table list fetch is already ongoing');
                    	return;
                    }
                    lastFetchSpecs = fetchSpecs;
                    var isLast = ignorePreviousListSQLTables();
                    scope.uiState.fetchingTables = true;

                    scope.catalogAwareDatabase = scope.connectionDetails.type === 'BigQuery' || scope.connectionDetails.type === 'Snowflake';
                    (scope.notebook.tableListingMode === 'PROJECT'
                        ? SQLExplorationService.listTablesFromProject(scope.connection, $stateParams.projectKey)
                        : SQLExplorationService.listTables(scope.connection, $stateParams.projectKey))
                    .then(function(tables) {
                        if(!isLast()) {
                            return;
                        }
                        scope.uiState.fetchingTables = false;
                        let schemas;
                        if (!scope.catalogAwareDatabase || (scope.notebook.tableListingMode === 'PROJECT' && scope.notebook.tableOrdering === 'DATASET')) {
                            // Build classic "Schema > Table" hierarchy
                            let hasNull = false;
                            let tablesBySchema = {};
                            $.each(tables, function(index, table) {
                                let schema = table.schema;
                                if (!schema) {
                                    hasNull = true;
                                    schema = '(default)';
                                }
                                if (!tablesBySchema[schema]) {
                                    tablesBySchema[schema] = [];
                                }
                                tablesBySchema[schema].push(table);
                            });
                            scope.singleCatalog = true;
                            scope.singleSchema = Object.keys(tablesBySchema).length === 1;
                            scope.schemalessDatabase = scope.singleSchema && hasNull;
                            schemas = $.map(tablesBySchema, function(v, k) {
                                return {
                                    name: k,
                                    tables: v.sort(function(a, b) {
                                        return a.table.localeCompare(b.table);
                                    }),
                                    state: { shown: scope.singleSchema }
                                };
                            });
                        } else {
                            // Build "Catalog > Schema > Table" hierarchy
                            let tablesByCatalogAndSchema = {};
                            $.each(tables, function(index, table) {
                                let schema = table.schema;
                                if (!schema) {
                                    schema = '(default)';
                                }
                                let catalog = table.catalog;
                                if (!catalog) {
                                    catalog = '(default)';
                                }
                                if (!tablesByCatalogAndSchema[catalog]) {
                                    tablesByCatalogAndSchema[catalog] = {};
                                }
                                if (!tablesByCatalogAndSchema[catalog][schema]) {
                                    tablesByCatalogAndSchema[catalog][schema] = [];
                                }
                                tablesByCatalogAndSchema[catalog][schema].push(table);
                            });
                            scope.singleCatalog = Object.keys(tablesByCatalogAndSchema).length === 1;
                            scope.singleSchema = false;
                            scope.schemalessDatabase = false;
                            schemas = $.map(tablesByCatalogAndSchema, function(v, k) {
                                return {
                                    name: k,
                                    schemas: $.map(v, function(sv, sk) {
                                        return {
                                            name: sk,
                                            tables: sv.sort(function(a, b) {
                                                return a.table.localeCompare(b.table);
                                            }),
                                            state: { shown: false }
                                        }
                                    }),
                                    state: { shown: scope.singleCatalog }
                                };
                            });
                        }
                        if (scope.notebook.tableListingMode === 'PROJECT') {
                            scope.schemasRestrictedToProject = schemas;
                        } else {
                            scope.schemasAll = schemas;
                        }
                        rebuildFatList();
                    });
                }
            }

            function loadAndRebuildFatList() {
                load();
                rebuildFatList();
            }

            scope.$watch('connection', load);
            scope.$watch('uiState.confirmListTablesFromDB', load);

            scope.refreshTableList = function() {
                SQLExplorationService.clearCache();
                load();
            };

            scope.openTable = function(table) {
                SQLExplorationService.listFields(scope.connection,[table]).then(function(data) {
                     table.fields = data;
                     rebuildFatList();
                });
            };

            scope.closeTable = function(table) {
                table.fields = undefined;
                rebuildFatList();
            };

            scope.toggleTable = function(table) {
                if(table.fields) {
                    scope.closeTable(table);
                } else {
                    scope.openTable(table);
                }
            };

            scope.toggleCatalog = function(catalog) {
                catalog.state.shown = !catalog.state.shown;
                rebuildFatList();
            };

            scope.toggleSchema = function(schema) {
                schema.state.shown = !schema.state.shown;
                rebuildFatList();
            };

            scope.filterSort = {};

            /**
             * Builds a fat list from a "Schema > Table" hierarchy
             */
            var makeSchemaTableFieldFatList = function(schemas, query) {
                let displayedSchemas = [];
                for (const schema of Object.values(schemas)) {
                    let tables = filterTables(schema.tables, query);
                    if (tables.length > 0) {
                        displayedSchemas.push({
                            name: schema.name,
                            tables: tables,
                            state: schema.state
                        });
                    }
                }

                if (displayedSchemas.length === 1) {
                    displayedSchemas[0].state.shown = true;
                }

                let fatList = [];
                for (const schema of Object.values(displayedSchemas)) {
                    if (!scope.schemalessDatabase) {
                        fatList.push({ type: 's', schema: schema, class: "schema-item" });
                    }
                    if (schema.state.shown) {
                        schema.tables.forEach(function(table, k) {
                            let clazz = k % 2 ? 'even' : 'odd';
                            fatList.push({ type: 't', table: table, 'class': (scope.schemalessDatabase ? 'flat-table-item' : 'table-item') + ' ' + clazz });
                            if (table.fields) {
                                table.fields.forEach(function(f) {
                                    fatList.push({ type: 'f', field: f, 'class': (scope.schemalessDatabase ? 'field-item' : 'flat-field-item') + ' ' + clazz });
                                });
                                if (table.fields.length === 0) {
                                    fatList.push({ type: 'nf', 'class': (scope.schemalessDatabase ? 'flat-nofield-item' : 'nofield-item') + ' ' + clazz });
                                }
                            }
                        });
                    }
                }
                return fatList;
            };

            /**
             * Builds a fat list from a "Catalog > Schema > Table" hierarchy
             */
            var makeCatalogSchemaTableFieldFatList = function(catalogs, query) {
                let displayedCatalogs = [];
                for (const catalog of Object.values(catalogs)) {
                    let displayedSchemas = [];
                    for (const schema of Object.values(catalog.schemas)) {
                        let tables = filterTables(schema.tables, query);
                        if (tables.length > 0) {
                            displayedSchemas.push({
                                name: schema.name,
                                tables: tables,
                                state: schema.state
                            });
                        }
                    }
                    if (displayedSchemas.length > 0) {
                        displayedCatalogs.push({
                            name: catalog.name,
                            schemas: displayedSchemas,
                            state: catalog.state
                        });
                    }
                }

                if (displayedCatalogs.length === 1) {
                    displayedCatalogs[0].state.shown = true;
                    if (displayedCatalogs[0].schemas.length === 1) {
                        displayedCatalogs[0].schemas[0].state.shown = true;
                    }
                }

                let fatList = [];
                for (const catalog of Object.values(displayedCatalogs)) {
                    fatList.push({ type: 'c', catalog: catalog });
                    if (catalog.state.shown) {
                        for (const schema of Object.values(catalog.schemas)) {
                            fatList.push({ type: 's', schema: schema, class: "catalog-schema-item" });
                            if (schema.state.shown) {
                                schema.tables.forEach(function(table, k) {
                                    let clazz = k % 2 ? 'even' : 'odd';
                                    fatList.push({ type: 't', table: table, 'class': 'catalog-table-item ' + clazz });
                                    if (table.fields) {
                                        table.fields.forEach(function(f) {
                                            fatList.push({ type: 'f', field: f, 'class': 'catalog-field-item ' + clazz });
                                        });
                                        if (table.fields.length === 0) {
                                            fatList.push({ type: 'nf', 'class': 'catalog-nofield-item ' + clazz });
                                        }
                                    }
                                });
                            }
                        }
                    }
                }
                return fatList;
            };

            var makeDatasetFieldFatList = function(schemas, query) {
                let tables = [];
                for (const schema of Object.values(schemas)) {
                    tables.push.apply(tables, filterTables(schema.tables, query)); //in place concat
                }
                tables.sort(function(a, b) {
                    return a.dataset.localeCompare(b.dataset);
                });

                let fatList = [];
                tables.forEach(function(table, k) {
                    var clazz = k % 2 ? 'even' : 'odd';
                    fatList.push({ type: 't', table: table, 'class': clazz });
                    if (table.fields) {
                        table.fields.forEach(function(f) {
                            fatList.push({ type: 'f', field: f, 'class': clazz });
                        });
                        if (table.fields.length === 0) {
                            fatList.push({ type: 'nf', 'class': clazz });
                        }
                    }
                });
                return fatList;
            };

            var filterTables = function(tables, query) {
                angular.forEach(query.split(/\s+/), function(token){
                    token = token.toLowerCase();
                    if (token.length) {
                        tables = $.grep(tables, function(item){
                            return item.table.toLowerCase().indexOf(token) >= 0 ||
                            (item.schema && item.schema.toLowerCase().indexOf(token) >= 0);
                        });
                    }
                });
                return tables;
            };

            var rebuildFatList = Debounce().withScope(scope).withDelay(10,200).wrap(function() {
                let query = scope.filterSort.tableFilter || '';
                let schemas = (scope.notebook.tableListingMode == 'PROJECT' ? scope.schemasRestrictedToProject : scope.schemasAll) || [];
                if (scope.notebook.tableListingMode == 'PROJECT' && scope.notebook.tableOrdering == 'DATASET') {
                    scope.fatList = makeDatasetFieldFatList(schemas, query);
                } else {
                    if (scope.catalogAwareDatabase) {
                        scope.fatList = makeCatalogSchemaTableFieldFatList(schemas, query);
                    } else {
                        scope.fatList = makeSchemaTableFieldFatList(schemas, query);
                    }
                }
                scope.$broadcast("reflow"); // update fat repeat layout
            });

            scope.$watch('filterSort', rebuildFatList, true);
            scope.$watch('notebook.tableListingMode', loadAndRebuildFatList);
            scope.$watch('notebook.tableOrdering', loadAndRebuildFatList);
        }
    };
});

})();

(function() {
'use strict';


const app = angular.module('dataiku.notebooks');
const setJupyterErrorInScope = function($scope) {return function(error) {$scope.jupyterError = error; $scope.$digest();}};

app.controller('PublishIPythonController', function ($scope, $stateParams, DataikuAPI, $filter, CreateModalFromTemplate) {
    $scope.exportCreateAndPinInsightNoSave = function(notebook) {
        var notebookName = notebook.name;
        $scope.queryRunning = true;
        var exportPromise = DataikuAPI.jupyterNotebooks.export.create($stateParams.projectKey, notebookName);
        exportPromise.success(function(jupyterExport) {
            var insight = {
                projectKey: $stateParams.projectKey,
                type: 'jupyter',
                name: notebook.name + " (" + $filter('utcDate')(jupyterExport.timestamp, 'YYYY-MM-DD hh:mm') + ")",
                params: {
                    projectKey: $stateParams.projectKey,
                    notebookSmartName: notebookName,
                    timestamp: jupyterExport.timestamp,
                    loadLast: true
                },
            }
            CreateModalFromTemplate("/templates/dashboards/insights/create-and-pin-insight-modal.html", $scope, "CreateAndPinInsightModalController", function(newScope) {
                newScope.init(insight);
            });
        });
        exportPromise.error(setErrorInScope.bind($scope));
    };
    $scope.exportCreateAndPinInsight = function(notebook) {
        $('iframe#jupyter-iframe')[0].contentWindow.IPython.notebook.save_notebook().then(function() {
            $scope.exportCreateAndPinInsightNoSave(notebook);
        }).catch(setJupyterErrorInScope($scope));
    }
});


app.controller('IPythonController', function ($scope, $stateParams, $state, $sce, $q, $rootScope, Dialogs, CreateExportModal, ExportUtils, DataikuAPI, TopNav, ActivityIndicator, LoggerProvider, WT1, $filter, CreateModalFromTemplate, $controller, StateUtils) {
	$controller('PublishIPythonController', {$scope:$scope});

	var Logger = LoggerProvider.getLogger("dku.notebooks");

    TopNav.setLocation(TopNav.TOP_NOTEBOOKS, 'notebooks', TopNav.TABS_JUPYTER_NOTEBOOK, null);
    TopNav.setItem(TopNav.ITEM_JUPYTER_NOTEBOOK, $stateParams.notebookId, {name:$stateParams.notebookId});
    $scope.$stateParams = $stateParams;
    if ($stateParams.kernel_name) {
        $scope.notebookURL = $sce.getTrustedResourceUrl("/jupyter/notebooks/" + $stateParams.projectKey + "/" + $stateParams.notebookId + ".ipynb?kernel_name=" + $stateParams.kernel_name);
    } else {
        $scope.notebookURL = $sce.getTrustedResourceUrl("/jupyter/notebooks/" + $stateParams.projectKey + "/" + $stateParams.notebookId + ".ipynb");
    }

    DataikuAPI.jupyterNotebooks.get($stateParams.projectKey, $stateParams.notebookId, $stateParams.kernel_name).success(function(data) {
        $scope.notebook = data;
        if ($scope.notebook && $scope.notebook.name) {
            $scope.notebook.name = $scope.notebook.name.replace(".ipynb", "");
            $scope.notebook.id = $stateParams.projectKey + "." + $scope.notebook.name;
        }

        if (data && data.content && data.content.metadata && data.content.metadata.kernelspec) {
            if (data.content.metadata.kernelspec.language=='python') {
                $scope.snippetsType = "python";
                $scope.snippetsCategories = ["py-std-dkuapi", "py-std-3rd", "user-py-std", "py-notebook", "py-spark-dkuapi", "py-spark-3rd"];
                $scope.snippetsSaveCategory = "user-py-std"
                TopNav.setItem(TopNav.ITEM_JUPYTER_NOTEBOOK, $stateParams.notebookId, {name:$stateParams.notebookId, type: "python"});
            } else if (data.content.metadata.kernelspec.language.startsWith('julia')) {
                $scope.snippetsType = "julia";
                $scope.snippetsCategories = ["jl-std-dkuapi", "jl-std-3rd", "user-jl-std", "j0l-notebook"];
                $scope.snippetsSaveCategory = "user-jl-std"
                TopNav.setItem(TopNav.ITEM_JUPYTER_NOTEBOOK, $stateParams.notebookId, {name:$stateParams.notebookId, type: "julia"});
            } else if (data.content.metadata.kernelspec.language=='R') {
                $scope.snippetsType = "R";
                $scope.snippetsCategories = ["R-std-dkuapi", "R-std-3rd", "user-R-std", "R-notebook", "sparkr-dkuapi", "sparkr-3rd"];
                $scope.snippetsSaveCategory = "user-R-std";
                TopNav.setItem(TopNav.ITEM_JUPYTER_NOTEBOOK, $stateParams.notebookId, {name:$stateParams.notebookId, type: "R"});
            } else if (data.content.metadata.kernelspec.language=='scala') {
                $scope.snippetsType = "scala";
                $scope.snippetsCategories = ["spark-scala-3rd", "mllib-clustering", "mllib-regressor", "user-scala-std"];
                $scope.snippetsSaveCategory = "user-scala-std";
                TopNav.setItem(TopNav.ITEM_JUPYTER_NOTEBOOK, $stateParams.notebookId, {name:$stateParams.notebookId, type: "scala"});
            }else {
                Logger.warn("Failed to guess snippets types", data);
            }
        } else {
            Logger.warn("Failed to guess snippets types", data);
        }
    });

    var deleteNotebookWithoutConfirm = function(notebook) {
        var deferred = $q.defer();
        var deletionRequest = [{
            type: 'JUPYTER_NOTEBOOK',
            projectKey: $stateParams.projectKey,
            id: notebook.name,
            displayName: notebook.name,
            options: {dropData: false}
        }];
        WT1.event("notebook-ipython-delete");
        if (notebook.kernel_id) {
            DataikuAPI.jupyterNotebooks.unload(notebook.session_id).success(function(d1) {
                DataikuAPI.taggableObjects.delete(deletionRequest, $stateParams.projectKey).success(function(data) {
                    deferred.resolve(true);
                }).error(setErrorInScope.bind($scope));
            }).error(setErrorInScope.bind($scope));
        } else {
            DataikuAPI.taggableObjects.delete(deletionRequest, $stateParams.projectKey).success(function(data) {
                deferred.resolve(true);
            }).error(setErrorInScope.bind($scope));
        }
        return deferred.promise;
    };

    $scope.editCustomFields = function(notebook) {
        const tor = {type: 'JUPYTER_NOTEBOOK', projectKey: $stateParams.projectKey, id: notebook.name};
        DataikuAPI.taggableObjects.getMetadata(tor)
            .success(function(metadata) {
                let modalScope = angular.extend($scope, {objectType: 'JUPYTER_NOTEBOOK', objectName: notebook.name, objectCustomFields: metadata.customFields || {}});
                CreateModalFromTemplate("/templates/taggable-objects/custom-fields-edit-modal.html", modalScope).then(function(customFields) {
                    metadata.customFields = angular.copy(customFields);
                    DataikuAPI.taggableObjects.setMetaData(tor, metadata)
                        .error(setErrorInScope.bind($scope));
                });
            })
            .error(setErrorInScope.bind($scope));
    };

    $scope.deleteNotebook = function(notebook) {
        if (!notebook || !notebook.name) {
            return;
        }
        Dialogs.confirm($scope, "Confirm deletion", "Are you sure you want to delete this notebook: " + notebook.name +" ?").then(function() {
            deleteNotebookWithoutConfirm(notebook).then(function() {
                $state.transitionTo('projects.project.notebooks.list', {projectKey: $stateParams.projectKey});
            });
        });
    };

    $scope.saveBackToRecipe = function(notebook) {
        var notebookHasName = notebook && !!notebook.name;
        var notebookHasMetadata = notebook && notebook.content && !!notebook.content.metadata;
        var notebookHasAssociatedRecipe = notebookHasMetadata && notebook.content.metadata.associatedRecipe && notebook.content.metadata.associatedRecipe.length > 0;
        if (!notebookHasName || !notebookHasAssociatedRecipe) {
            return;
        }
        $('iframe#jupyter-iframe')[0].contentWindow.IPython.notebook.save_notebook().then(function() {
            WT1.event("notebook-ipython-save-back-to-recipe");
            DataikuAPI.jupyterNotebooks.saveBackToRecipe($stateParams.projectKey, notebook.name).success(function(data) {
                StateUtils.go.recipe(data.id);
            }).error(setErrorInScope.bind($scope));
        }).catch(setJupyterErrorInScope($scope));
    };

    $scope.createRecipeFromNotebook = function(notebook) {
        if (!notebook || !notebook.name) {
            return;
        }
        var sparkAvailable = !$rootScope.appConfig.communityEdition && $rootScope.appConfig.sparkEnabled && $rootScope.addLicInfo.sparkLicensed;
        var possibleTypes = [];
        switch (notebook.content.metadata.kernelspec.language) {
            case 'python':
                possibleTypes.push({type: 'python', title: 'Python recipe', desc: 'native Python language'});
                if (sparkAvailable) {
                    possibleTypes.push({type: 'pyspark', title: 'PySpark recipe', desc: 'Python language using Spark framework'});
                }
                break;
            case 'scala':
                possibleTypes.push({type: 'spark_scala', title: 'Spark Scala recipe', desc: 'Scala language using Spark framework'});
                break;
            case 'julia':
                possibleTypes.push({type: 'julia', title: 'Julia recipe', desc: 'native Julia language'});
                break;
            case 'R':
                possibleTypes.push({type: 'r', title: 'R recipe', desc: 'native R language'});
                if (sparkAvailable) {
                    possibleTypes.push({type: 'sparkr', title: 'SparkR recipe', desc: 'native R language using Spark framework'});
                }
                break;
            default:
                return setErrorInScope.bind($scope)(new Error('Unknown notebook language: ' + notebook.content.metadata.kernelspec.language));
        }
        if (possibleTypes.length === 1) {
            $scope.showCreateRecipeFromNotebookModal(notebook.name, possibleTypes[0].type, notebook.content.metadata.analyzedDataset);
        } else if (possibleTypes.length >= 2) {
            Dialogs.select($scope, 'Choose recipe type', 'Please select the recipe type to use', possibleTypes, possibleTypes[0]).then(function(selectedType) {
                $scope.showCreateRecipeFromNotebookModal(notebook.name, selectedType.type, notebook.content.metadata.analyzedDataset);
            }).catch(setErrorInScope.bind($scope));
        }
    };

    $scope.forceReloadJupyterNotebook = function() {

        Dialogs.confirm(
            $scope,
            'Force Reload Jupyter kernel',
            '<p>Are you sure you want to force reload this notebook?</p>' +
            '<p>The kernel will be restarted. All current variables and outputs will be lost.</p>'
        ).then(function () {
            const iFrameWindow = $('iframe#jupyter-iframe')[0].contentWindow;
            iFrameWindow.IPython.notebook.save_notebook().then(function () {
                DataikuAPI.jupyterNotebooks.unload(
                    iFrameWindow.IPython.notebook.session.id
                ).success(function(data) {
                    iFrameWindow.location.reload();
                }).error(setErrorInScope.bind($scope));
            }, setJupyterErrorInScope($scope));
        });
    }

    $scope.copySnippetToClipboard_ = function(variation) {
    	var stringToPutIntoClippboard = variation.code;
    	//ugly but necessary
    	var textArea = document.createElement("textarea");
    	textArea.style.position = 'absolute';
    	textArea.style.top = '-1000px';
    	textArea.style.left = '-1000px';
    	textArea.value = stringToPutIntoClippboard;
    	document.body.appendChild(textArea);
    	textArea.select();
    	try {
		    var successful = document.execCommand('copy');
		    if (successful) {
		    	ActivityIndicator.success("Sample copied into cliboard");
		    } else {
		    	ActivityIndicator.error("Your browser does not support automatic copying into clibboard");
		    }
    	} catch (err) {
    		ActivityIndicator.error("Your browser does not support automatic copying into clibboard");
    	}
    	document.body.removeChild(textArea);
    };

    $scope.uiState = { codeSamplesSelectorVisible: false} ;

    window.openExportModalFromIPython = function(exportName, exportStartedCallback) {
        var features = {
                advancedSampling : false,
                partitionListLoader : null,
                isDownloadable : true
        };
        var dialog = {
                  title : 'Export from Jupyter',
                  warn : null
        };
        CreateExportModal($scope,dialog,features).then(function(params) {
            params.filenameBase = exportName;
            params.contextProjectKey = $stateParams.projectKey;
            DataikuAPI.exports.create(exportName, params).success(function(data){
                exportStartedCallback(data);
                ExportUtils.defaultHandleExportResult($scope, params, data);
            }).error(setErrorInScope.bind($scope));
        });
    };
});

app.controller("jupyterNotebookPageRightColumnActions", async function($controller, $scope, $rootScope, $stateParams, ActiveProjectKey, DataikuAPI, NotebooksUtils, DKUtils) {

    $controller('_TaggableObjectPageRightColumnActions', {$scope: $scope});
    $controller('PublishIPythonController', {$scope:$scope});

    $scope.notebook = (await DataikuAPI.jupyterNotebooks.getNotebook(ActiveProjectKey.get(), $stateParams.notebookId, $stateParams.kernel_name)).data;

    $scope.notebook.id = $scope.notebook.name;
    $scope.notebook.nodeType = 'JUPYTER_NOTEBOOK';
    $scope.notebook.interest = {};

    $scope.selection = {
        selectedObject : $scope.notebook,
        confirmedItem : $scope.notebook
    };

    function updateUserInterests() {
        DataikuAPI.interests.getForObject($rootScope.appConfig.login, "JUPYTER_NOTEBOOK", ActiveProjectKey.get(), $scope.selection.selectedObject.id)
            .success(function(data) {
                $scope.selection.selectedObject.interest = data;
            }).error(setErrorInScope.bind($scope));
    }

    function refreshPage() {
        DKUtils.reloadState();
    }
    updateUserInterests();
    const interestsListener = $rootScope.$on('userInterestsUpdated', updateUserInterests);

    $scope.pushNotebooksToRemote = NotebooksUtils.pushNotebooksToRemote($scope);
    $scope.pullNotebooksFromRemote = NotebooksUtils.pullNotebooksFromRemote($scope);
    $scope.editNotebookReference = NotebooksUtils.editNotebookReference($scope)(refreshPage);
    $scope.unlinkNotebookReference = NotebooksUtils.unlinkNotebookReference($scope)(refreshPage);

    $scope.$on("$destroy", interestsListener);
});


app.directive('jupyterNotebookRightColumnSummary', function(DataikuAPI, $stateParams, QuickView, NotebooksUtils, $controller, ActiveProjectKey, ActivityIndicator){
    return {
        templateUrl :'/templates/notebooks/jupyter-notebook-right-column-summary.html',

        link : function($scope, element, attrs) {

        	$controller('PublishIPythonController', {$scope: $scope});
        	$controller('_TaggableObjectsMassActions', {$scope: $scope});
        	$controller('_TaggableObjectsCapabilities', { $scope: $scope});

            $scope.QuickView = QuickView;

            /* Auto save tags when they are modified */
            $scope.$on("objectSummaryEdited", function(){
                const tor = {type: 'JUPYTER_NOTEBOOK', projectKey: $stateParams.projectKey, id: $scope.notebookData.notebook.name};
                DataikuAPI.taggableObjects.getMetadata(tor).success(function(metadata) {
                    metadata.tags = angular.copy($scope.notebookData.notebook.tags);
                    DataikuAPI.taggableObjects.setMetaData(tor, metadata).success(function() {
                        ActivityIndicator.success("Saved");
                    }).error(setErrorInScope.bind($scope));
                }).error(setErrorInScope.bind($scope));
            });

            $scope.refreshTimeline = function(){
                var obj = $scope.selection.selectedObject;
                if (!obj) return;
                var pkey = obj.projectKey || ActiveProjectKey.get();
                var name = obj.id || obj.name;
                DataikuAPI.timelines.getForObject(pkey, "JUPYTER_NOTEBOOK", name)
                    .success(function(data){
                        if (!obj || obj.projectKey != pkey || obj.name != name) {
                            return; // too late!
                        }
                        $scope.objectTimeline = data;
                        if ($scope.notebookData) {
                            $scope.notebookData.timeline = data;
                            $scope.notebookData.versioning = Object.assign({}, data, {createdBy: null, createdOn: null});
                        }
                    })
                    .error(setErrorInScope.bind($scope));
            };

            $scope.getMetaData = function(){
                $scope.insight = $scope.selection.selectedObject;

                DataikuAPI.analysis.getSummary($scope.selection.selectedObject.projectKey, $scope.selection.selectedObject.id).success(function(data) {
                    $scope.objectFullInfo = data;
                    $scope.analysis = data.object;
                    const d = $scope.analysis;
                    $rootScope.$broadcast('objectMetaDataRefresh', { tags: d.tags, shortDesc: d.shortDesc, description: d.description});
                });
            };

            $scope.$watch("selection.selectedObject", function(nv, ov) {
                if (!nv) return;
                $scope.notebookData = {
                    notebook: $scope.selection.selectedObject,
                    timeline: $scope.objectTimeline,
                    versioning: Object.assign({}, $scope.objectTimeline, {createdBy: null, createdOn: null})
                };
                if($scope.selection.confirmedItem != $scope.selection.selectedObject) {
                    $scope.objectTimeline = null;
                }
            });

            $scope.$watch("selection.confirmedItem", function(nv, ov) {
                if (!nv) return;
                $scope.refreshTimeline();
            });

            $scope.getNotebookIcon = function(item) {
                return NotebooksUtils.getNotebookIcon(item);
            };
        }
    }
});

}());

(function() {
'use strict';

    const app = angular.module('dataiku.export.services', ['dataiku.services']);

    app.factory("ExportUtils", function(FutureProgressModal, DataikuAPI, CreateExportModal, $stateParams, $rootScope, GraphZoomTrackerService){
        var svc = {
            defaultHandleExportResult : function($scope, exportParams, result) {
                FutureProgressModal.show($scope, result.futureResponse, "Exporting ...").then(function(){
                    if (result.exportMethod == "FORMATTER_STREAM" || result.exportMethod == "FORMATTER_TO_FILE" ||
                        result.exportMethod == "CUSTOM_TO_FILE") {
                        downloadURL(DataikuAPI.exports.getDownloadURL(result.exportId));
                        if (result.realFutureResponse) {
                            FutureProgressModal.show($scope, result.realFutureResponse, "Exporting ...");
                        }
                    }
                    // when exporting to a new dataset in the project, refresh the flow
                    // to show the new dataset, and select this dataset
                    if (result.exportMethod=="DATASET") {
                        GraphZoomTrackerService.setFocusItemByName("dataset", result.params.destinationDatasetName);
                        $rootScope.$emit('datasetsListChangedFromModal');
                    }
                });
            },
            exportUIData : function($scope, data, modalTitle){
                var features = {
                    advancedSampling : false,
                    partitionListLoader : null
                }

                CreateExportModal($scope, { title: modalTitle } ,features).then(function(params) {
                	params.contextProjectKey = $stateParams.projectKey;
                    DataikuAPI.exports.exportUIData(data, params).success(function(data) {
                        svc.defaultHandleExportResult($scope, params, data);
                    }).error(setErrorInScope.bind($scope));
                });
            }
        }
        return svc;
    });

    app.factory("ExportService", function($timeout, $q, CreateModalFromTemplate, DataikuAPI, $stateParams, LocalStorage, Logger, Collections, DatasetUtils, CachedAPICalls) {

        function getExportSettings(destinationType) {
            return {
                destinationType : destinationType ? destinationType : 'DOWNLOAD',
                destinationDatasetProjectKey : $stateParams.projectKey,
                overwriteDestinationDataset:false,
                selection : {
                    samplingMethod : 'FULL',
                    partitionSelectionMethod : 'ALL' ,
                    targetRatio : 0.02,
                    maxRecords : 100000,
                    selectedPartitions:[],
                    ordering: {
                        enabled: false,
                        rules : []
                    }
                },
                advancedMode: false
            };
        }

        function setCsvSeparatorParam(format) {
            CachedAPICalls.datasetFormatTypes.success((formats) => {
                const csvFormatParams = formats['csv'];
                format.csvSeparatorParam =
                    csvFormatParams.params.find(param => param.name === 'separator');
            });
        }

        /**
         * Return first connection of type `Filesystem` if there is one in the list of connections, first one of the list otherwise.
         * @param connections: list of connections
         */
        function getDefaultConnection(connections) {
            if(!connections || connections.length == 0) {
                return;
            }

            // Select the first filesystem connection
            for(let i in connections) {
                let connection  = connections[i];
                if(connection.type=='Filesystem') {
                    return connection.connection;
                }
            }

            // If there is no filesystem connection, pick the first one
            return connections[0].connection;
        }

        function getExportModal(scope, dialog, deferred) {
            return  {
                partitionListLoaded : false,
                selectedPartitionsText:'',
                title : dialog.title,
                warn: dialog.warn,
                partitionList : [],
                DatasetUtils:DatasetUtils,
                accept : function() {
                    this.updateModel();
                    deferred.resolve(scope.exportParams);
                },
                cancel : function() {
                    this.updateModel();
                    deferred.reject(scope.exportParams);
                },
                loadPartitions : function() {
                    let ref = this;
                    this.partitionListLoader().then(function(data) {
                        ref.handlePartitionListLoaded(data);
                    },function() {
                        // nothing to do in case of failure
                    });
                },
                handlePartitionListLoaded : function(data) {
                    this.updateModel();
                    this.partitionListLoaded = true;
                    this.partitionList = data;
                },

                // Update the model "scope.exportParams" from the selected option
                // in the current tab
                updateModel : function() {
                    // check if we are currently in "text mode"
                    // update the modal with the list of selected partition
                    // (from the comma separated input field)
                    if(!this.partitionListLoaded) {
                        scope.exportParams.selection.selectedPartitions = this.selectedPartitionsText.length ? this.selectedPartitionsText.split(',') : [];
                    }
                },

                getCacheKey: function(destinationType, optionId) {
                    let key = destinationType;
                    if (optionId) {
                        key += "_" + optionId;
                    }
                    return key;
                },

                cacheExportParams: function(exportParams) {
                    if (this.backupExportParams == null) {
                        this.backupExportParams = {};
                    }
                    if (exportParams && exportParams.destinationType) {
                        let key = this.getCacheKey(exportParams.destinationType, exportParams.originatingOptionId);
                        this.backupExportParams[key] = angular.copy(exportParams);
                    }
                },

                getCachedExportParams: function() {
                    let key = this.getCacheKey(this.$destinationType, this.getSelectedOptionId());
                    if (key && this.backupExportParams && this.backupExportParams[key] != null) {
                       return this.backupExportParams[key];
                    }
                    return null;
                },

                getSelectedOptionId: function() {
                    let selectedOptionId = null;
                    if (this.$destinationType == "DOWNLOAD") {
                        selectedOptionId = this.$selectedDownloadOptionId;
                    } else if (this.$destinationType == "CUSTOM_MANAGED") {
                        selectedOptionId = this.$selectedManagedOptionId;
                    }
                    return selectedOptionId;
                },

                getDefaultExportParams: function() {
                    let exportParams = getExportSettings(this.$destinationType);
                    // Reset existing
                    exportParams.$exportOption = undefined;
                    exportParams.originatingOptionId = undefined;
                    exportParams.format = undefined;
                    exportParams.exporterType = undefined;
                    exportParams.config = undefined;

                    let selectedOptionId = this.getSelectedOptionId(this.$destinationType);
                    let selectedOption = selectedOptionId ? this.optionsMap[selectedOptionId] : null;

                    if (selectedOption) {
                        exportParams.$exportOption = selectedOption;
                        exportParams.originatingOptionId = selectedOption.id;
                        switch (selectedOption.optionType) {
                            case "BUILTIN_FORMAT":
                                exportParams.format = {
                                    type: selectedOption.formatType,
                                    params: angular.copy(selectedOption.predefinedConfig)
                                };
                                if ('csv' === selectedOption.formatType) {
                                    setCsvSeparatorParam(exportParams.format);
                                }
                                break;
                            case "CUSTOM_FORMAT":
                                exportParams.format = {
                                    type: selectedOption.formatType,
                                    params: {
                                        config: angular.copy(selectedOption.predefinedConfig)
                                    }
                                };
                                break;
                            case "CUSTOM_TO_FILE":
                            case "CUSTOM_MANAGED":
                                exportParams.exporterType = selectedOption.exporterType;
                                exportParams.config = angular.copy(selectedOption.predefinedConfig);
                                break;
                        }
                    }

                    if (this.$destinationType == 'DATASET') {
                        exportParams.destinationDatasetConnection = getDefaultConnection(this.managedDatasetConnections);
                    }

                    return exportParams;
                },

                handleSelectedOptionChange : function(){
                    this.cacheExportParams(scope.exportParams);

                    let cachedExportParams = this.getCachedExportParams();
                    if (cachedExportParams != null) {
                        scope.exportParams = cachedExportParams;
                    } else {
                        scope.exportParams = this.getDefaultExportParams();
                    }
                },
                checkFormIsValid : function() {
                    function isSingleChar(str) {
                        return !!str && str.length == 1;
                    }

                    if (scope.exportParams.destinationType == 'DATASET'
                        && !scope.exportParams.overwriteDestinationDataset
                        && (!this.exportModalForm.datasetName || this.exportModalForm.datasetName.$invalid)
                    ) {
                        return false;
                    }

                    if (scope.exportParams.destinationType == 'DATASET'
                        && scope.exportParams.overwriteDestinationDataset && !scope.exportParams.destinationDatasetName
                    ) {
                        return false;
                    }

                    if (scope.exportParams.destinationType == 'DOWNLOAD' &&
                        scope.exportParams.format && scope.exportParams.format.type == "csv"
                        && !isSingleChar(scope.exportParams.format.params.separator)) {
                        return false;
                    }
                    return true;

                },
                getExportButtonText : function() {
                    if(scope.exportParams.destinationType=='DOWNLOAD') {
                        return 'Download';
                    } else if(scope.exportParams.destinationType=='DATASET') {
                        if(scope.exportParams.overwriteDestinationDataset) {
                            return 'Overwrite dataset';
                        } else {
                            return 'Create dataset';
                        }
                    } else {
                        return "Export";
                    }
                }
            };
        }

        var svc = {
            initExportBehavior : function(scope, dialog, featureOptions, exportParamsContainer, initialExportParams, fullInitialExportParams, onExportParamsChanged){
                var deferred = $q.defer();

                // default values
                var defaultFeatures = {
                    forceShowMethods: false,
                    advancedSampling: false,
                    isDownloadable: true,
                    partitionListLoader: null
                };

                if (featureOptions === undefined) {
                    featureOptions = {};
                }
                // Creating fatass object here with load of functions (and extended just afterward with even more parameters)
                scope.exportModal = getExportModal(scope, dialog, deferred);
                $.extend(scope.exportModal, defaultFeatures, featureOptions);

                scope.exportModalForm = {};

                if (fullInitialExportParams != null) {
                    Logger.info("Using forcedInit with", fullInitialExportParams);
                    scope.exportParams = fullInitialExportParams;
                } else {
                    Logger.info("Using regular init, override with", initialExportParams);
                    scope.exportParams = getExportSettings();
                    if (initialExportParams != null) {
                        rextend(scope.exportParams, initialExportParams);
                    }
                }
                if (scope.exportParams.format && scope.exportParams.format.type === 'csv') {
                    setCsvSeparatorParam(scope.exportParams.format);
                }
                scope.exportModal.$destinationType = scope.exportParams.destinationType;

                exportParamsContainer.exportParams = scope.exportParams;

                Logger.warn("Initialized: ", scope.exportParams);

                DataikuAPI.datasets.list($stateParams.projectKey).success(function(data) {
                    scope.datasets = data.filter(function(d) {
                        return !d.type.startsWith('Doctor');
                    }).map(function(d) {
                        d.usable=true;
                        d.smartName=d.name;
                        d.localProject=true;
                        return d;
                    });
                }).error(setErrorInScope.bind(scope));

                DataikuAPI.exports.getOptions().success(function(data) {
                    scope.exportModal.exportOptions = data.options;

                    scope.exportModal.exportableFormats = data.options.filter(function(x){
                        return x.optionType == "BUILTIN_FORMAT" || x.optionType == "CUSTOM_FORMAT" || x.optionType == "CUSTOM_TO_FILE";
                    });
                    scope.exportModal.managedExporters = data.options.filter(function(x){
                        return x.optionType == "CUSTOM_MANAGED";
                    });

                    scope.exportModal.optionsMap = Collections.indexByField(data.options, "id");

                    /* Preinitialize (so that we have a fallback for both modes) */
                    scope.exportModal.$selectedDownloadOptionId =  scope.exportModal.exportableFormats[0].id;
                    if (scope.exportModal.managedExporters.length > 0) {
                        scope.exportModal.$selectedManagedOptionId =  scope.exportModal.managedExporters[0].id;
                    }

                    /* Reload existing option if any */
                    Logger.info("Loading after getting options, current params:"  + JSON.stringify(scope.exportParams));
                    if (scope.exportParams.originatingOptionId != null && scope.exportParams.destinationType == 'DOWNLOAD') {
                        scope.exportModal.$selectedDownloadOptionId = scope.exportParams.originatingOptionId;
                        scope.exportParams.$exportOption = scope.exportModal.optionsMap[scope.exportParams.originatingOptionId];
                    } else if (scope.exportParams.originatingOptionId != null && scope.exportParams.destinationType == 'CUSTOM_MANAGED') {
                        scope.exportModal.$selectedManagedOptionId = scope.exportParams.originatingOptionId;
                        scope.exportParams.$exportOption = scope.exportModal.optionsMap[scope.exportParams.originatingOptionId];
                    }

                    /* None yet, activate the default */
                    if (!scope.exportParams.$exportOption) {
                        Logger.info("No valid option yet (or option lost), initializing");
                        if (scope.exportParams.destinationType == 'DOWNLOAD' && scope.exportModal.exportableFormats.length > 0) {
                            scope.exportModal.$selectedDownloadOptionId = scope.exportModal.exportableFormats[0].id;
                            scope.exportParams.$exportOption = scope.exportModal.exportableFormats[0];
                        } else if (scope.exportParams.destinationType == 'CUSTOM_MANAGED' && scope.exportModal.managedExporters.length > 0) {
                            scope.exportModal.$selectedManagedOptionId = scope.exportModal.managedExporters[0].id;
                            scope.exportParams.$exportOption = scope.exportModal.managedExporters[0];
                        }
                        scope.exportModal.handleSelectedOptionChange();
                    }

                    Logger.info("Initialized export options", scope.exportParams);
                    scope.exportModal.updateModel();

                    scope.$watch("exportModal.$destinationType", function(nv, ov) {
                        if (nv && ov) {
                            scope.exportModal.handleSelectedOptionChange();
                            scope.exportModal.updateModel();
                        }
                    });

                }).error(setErrorInScope.bind(scope));

                if (typeof(onExportParamsChanged) === "function") {
                    scope.$watch('exportParams', function(nv, ov) {
                        let newExportParams = angular.copy(nv);
                        delete newExportParams.$exportOption;
                        if (newExportParams.format) delete newExportParams.format.csvSeparatorParam;
                        onExportParamsChanged(newExportParams);
                    }, true);
                }

                addDatasetUniquenessCheck(scope,DataikuAPI, $stateParams.projectKey);
                fetchManagedDatasetConnections(scope.exportModal, DataikuAPI);

                return deferred.promise;
            }
        }
        return svc;

    });

    app.factory("CreateExportModal", function(ExportService, $timeout, $q, CreateModalFromTemplate, DataikuAPI, $stateParams, LocalStorage, Logger) {
        // Example :
        //
        // features : {
        //   advancedSampling : false,
        //   partitionListLoader : null,
        //   isDownloadable : true
        // }
        //
        // dialog : {
        //     title : 'Export',
        //     warn : 'Be careful'
        // }
        //
        return function(baseScope,dialog, featureOptions, initialExportParams) {
            var scope = baseScope.$new();
            var promise = ExportService.initExportBehavior(scope, dialog, featureOptions, scope, initialExportParams);
            CreateModalFromTemplate('/templates/exports/export_modal.html',scope);
            return promise;
        };
    });

    function initializePluginConfig(Logger, PluginConfigUtils, scope, rootConfigFieldName, pathToConfig, rootConfigType, pathToConfigType, descriptors, descriptorTypeFieldName) {
        function getNestedValue(rootObject, path, defaultValue = {}) {
            let result = rootObject;
            let splitPath = path.split(".");
            for (let i = 0; i < splitPath.length; i++) {
                const pathElement = splitPath[i];
                const isLastPathElement = i === splitPath.length - 1;
                if (isLastPathElement && !(result[pathElement])) {
                    result[pathElement] = defaultValue;
                }
                result = result[pathElement];
            }
            return result;
        }

        function setConfig() {
            scope[rootConfigFieldName] = scope.exportParams;
            Logger.info("LOADED CONFIG:  " + JSON.stringify(scope.exportParams));
            // Initialize if empty.
            getNestedValue(scope[rootConfigFieldName], pathToConfig);
        }

        function updateType() {
            scope[rootConfigType] = getNestedValue(scope.exportParams, pathToConfigType, null);

            var descriptor = descriptors.filter(function(x){
                return x[descriptorTypeFieldName] === scope[rootConfigType];
            });
            if (descriptor.length > 0 ) {
                scope.loadedDesc = descriptor[0];
                scope.pluginDesc = window.dkuAppConfig.loadedPlugins.filter(function(x){
                    return x.id === scope.loadedDesc.ownerPluginId;
                })[0];
                PluginConfigUtils.setDefaultValues(scope.loadedDesc.desc.params, getNestedValue(scope[rootConfigFieldName], pathToConfig));
            } else {
                Logger.warn("Descriptor not found", scope[rootConfigType], " in list", descriptors);
            }
        }
        setConfig();
        scope.$watch('exportParams', setConfig); // updating config in case config's reference change
        scope.$watch("exportParams." + pathToConfigType, updateType, true);
    }

    app.directive('pluginExporterConfig', function($filter, PluginConfigUtils, Logger) {
        return {
            scope : false,
            restrict : 'A',
            link : function($scope, element, attrs) {
                initializePluginConfig(Logger, PluginConfigUtils, $scope ,
                    'exporterConfig', 'config',
                    'exporterType', "exporterType",
                    window.dkuAppConfig.customExporters, 'exporterType');
            }
        };
    });

    app.directive('pluginFormatConfig', function($filter, PluginConfigUtils, Logger) {
        return {
            scope : false,
            restrict : 'A',
            link : function($scope, element, attrs) {
                initializePluginConfig(Logger, PluginConfigUtils, $scope,
                    "formatConfig", "format.params.config",
                    "formatType", "format.type",
                    window.dkuAppConfig.customPythonFormats.concat(window.dkuAppConfig.customJavaFormats), "formatterType");
            }
        };
    });

})();


(function() {
'use strict';

const app = angular.module('dataiku.rstudioserverembed', []);

// Ugly because I use a config block to keep a reference on sceDelegateProvider. I don't know how to do without that.
let ugly;

app.config(function($sceDelegateProvider) {
    ugly = $sceDelegateProvider;
})

app.controller('RStudioServerEmbedController', function ($scope, $stateParams, $state, $sce, $q, $rootScope, Dialogs, CreateExportModal, ExportUtils, DataikuAPI, TopNav, ActivityIndicator, LoggerProvider, WT1, $filter, CreateModalFromTemplate, $controller, StateUtils, Assert) {
    Assert.trueish($scope.appConfig.rstudioServerEmbedURL);
    Assert.trueish(ugly);

    ugly.resourceUrlWhitelist([
        "self",
        $scope.appConfig.rstudioServerEmbedURL +"**"
    ])

    var Logger = LoggerProvider.getLogger("dku.rstudio-server");

    TopNav.setLocation(TopNav.TOP_NOTEBOOKS, 'notebooks', TopNav.TABS_JUPYTER_NOTEBOOK, null);
    TopNav.setItem(TopNav.ITEM_JUPYTER_NOTEBOOK, $stateParams.notebookId, {name:$stateParams.notebookId});
    $scope.$stateParams = $stateParams;

    $scope.rstudioServerURL = $sce.getTrustedResourceUrl($scope.appConfig.rstudioServerEmbedURL)

    $scope.snippetsType = "R";
    $scope.snippetsCategories = ["R-std-dkuapi", "R-std-3rd", "user-R-std", "R-notebook", "sparkr-dkuapi", "sparkr-3rd"];
    $scope.snippetsSaveCategory = "user-R-std";
    TopNav.setItem(TopNav.ITEM_JUPYTER_NOTEBOOK, $stateParams.notebookId, {name:$stateParams.notebookId, type: "R"});

    $scope.uiState = { codeSamplesSelectorVisible: false} ;
});

})();
(function() {
'use strict';

const app = angular.module('dataiku.lambda', []);


app.controller("LambdaServicesListController", function($scope, $controller, $stateParams, DataikuAPI, Dialogs, $state,
    TopNav, WT1, ActivityIndicator) {
    $controller('_TaggableObjectsListPageCommon', {$scope: $scope});

    TopNav.setNoItem();
    TopNav.setLocation(TopNav.TOP_MORE, "lambda", TopNav.TABS_NONE, null);

    $scope.sortBy = [
        {
            value: 'id',
            label: 'Id'
        },
        {
            value: 'name',
            label: 'Name'
        },
        {
            value: 'endpoints.length',
            label: 'Number of endpoints'
        }
    ];
    $scope.sortCookieKey = 'lambdaservices';
    $scope.selection = $.extend({
        filterQuery: {
            userQuery: '',
            tags: [],
            interest: {
                starred: '',
            },
        },
        filterParams: {
            userQueryTargets: ["id",'tags'],
            propertyRules: {tag:"tags"},
        },
        orderQuery: "name",
        orderReversed: false,
    }, $scope.selection || {});

    $scope.maxItems = 20;

    $scope.list = function() {
        DataikuAPI.lambda.services.listHeads($stateParams.projectKey).success(function(data) {
            $scope.listItems = data.items;
            $scope.restoreOriginalSelection();
        }).error(setErrorInScope.bind($scope));
    };
    $scope.list() ;

    $scope.goToItem = function(data) {
        $state.go("projects.project.lambdaservices.service.endpoints", {projectKey: $stateParams.projectKey, serviceId: data.id});
    }

    $scope.newService = function() {
        Dialogs.prompt($scope, "Create API service", "Unique service ID", "", { pattern: "[\\w-]+" })
            .then(function(id) {
                WT1.event('create-api-service');
                DataikuAPI.lambda.services.create($stateParams.projectKey, id)
                    .success(function() {
                        $state.go("projects.project.lambdaservices.service.endpoints", {projectKey: $stateParams.projectKey, serviceId: id});
                    }).error(setErrorInScope.bind($scope));
            });
    };

    $scope.customMassDeleteSelected = DataikuAPI.lambda.services.deleteMulti;

    $scope.$on("objectSummaryEdited", function() {
        return DataikuAPI.lambda.services.save($stateParams.projectKey, $scope.selection.selectedObject).success(
            function(data) {
                ActivityIndicator.success("Saved");
            }).error(setErrorInScope.bind($scope));
    });
});

app.directive('lambdaServiceRightColumnSummary', function(DataikuAPI, $stateParams){
    return {
        templateUrl :'/templates/lambda/right-column-summary.html',
        link: function(scope) {
            scope.refreshData = function(serviceId) {
                DataikuAPI.lambda.services.getSummary($stateParams.projectKey, serviceId)
                .success(function(summary) {
                    scope.serviceSummary = summary;
                }).error(setErrorInScope.bind(scope));
            };

            scope.$watch("selection.confirmedItem", function(nv) {
                if (!nv) return;
                scope.refreshData(nv.id);
            });
        }
    }
});

app.controller("LambdaServiceSummaryController", function($scope, $rootScope, $stateParams, DataikuAPI, TopNav) {
    TopNav.setLocation(TopNav.TOP_HOME, 'lambda', null, 'summary');

    $scope.$on("objectSummaryEdited", $scope.saveService);

    $scope.$on('customFieldsSummaryEdited', function(event, customFields) {
        $scope.saveCustomFields(customFields);
    });
});


app.controller("LambdaServiceBaseController", function($scope, $state, $stateParams, $q, DataikuAPI, TopNav, Logger, Dialogs, Fn, FutureProgressModal, CreateModalFromTemplate, $rootScope, WT1) {
    TopNav.setItem(TopNav.ITEM_LAMBDA_SERVICE, $stateParams.serviceId);

    let savedService; //for dirtyness detection
    function getSummary() {
        return DataikuAPI.lambda.services.getSummary($stateParams.projectKey, $stateParams.serviceId).success(function(data) {
            $scope.service = data.object;
            $scope.timeline = data.timeline;
            $scope.interest = data.interest;
            savedService = angular.copy($scope.service);

            TopNav.setItem(TopNav.ITEM_LAMBDA_SERVICE, $stateParams.serviceId, {name: $scope.service.name});
            TopNav.setPageTitle($scope.service.name + " - API Service");
        }).error(setErrorInScope.bind($scope));
    }

    getSummary().then(function() {
        DataikuAPI.lambda.devServer.getStatus().success(function(data) {
            $scope.lambdaDevServerStatus = data;
        });
    })

    $scope.serviceIsDirty = function() {
        return $scope.service && savedService && !angular.equals($scope.service, savedService);
    };

    $scope.saveServiceIfNeeded = function() {
        if ($scope.serviceIsDirty()) {
            return $scope.saveService();
        }
        return $q.when(null);
    };

    $scope.saveService = function() {
        return DataikuAPI.lambda.services.save($stateParams.projectKey, $scope.service).success(function(data) {
            // Update API keys, some may have been generated on save
            $scope.service.authRealm.queryKeys = data.authRealm.queryKeys;
            savedService = angular.copy($scope.service);
        }).error(setErrorInScope.bind($scope));
    };

    const allowedTransitions = [
        'projects.project.lambdaservices.service.summary',
        'projects.project.lambdaservices.service.endpoints',
        'projects.project.lambdaservices.service.packages',
        'projects.project.lambdaservices.service.config',
    ];
    checkChangesBeforeLeaving($scope, $scope.serviceIsDirty, null, allowedTransitions);

    // Suggest next non-existing name (preferably vX+1, else based on last package)
    $scope.suggestNextName = function(names) {
        if (!names || !names.length) return "v1";
        let matches = names.filter(Fn.regexp(/^v\d+$/i));
        let v;
        let last;
        if (matches.length) {
            v = parseInt(matches[0].substr(1)) + 1;
            while (matches.indexOf("v" + v) >= 0) v++;
            return "v" + v;
        }
        last = names.pop();
        matches = last.match(/(.*)(\d+)(\D*)$/); // rightmost digits
        if (matches) {
            v = parseInt(matches[2]) + 1
            while (names.indexOf(matches[1] + v + matches[3]) >= 0) v++;
            return matches[1] + v + matches[3];
        }
        return last + "2";
    };

    $scope.startPreparePackage = function() {
        Logger.info("Preparing package");

        $q.all([DataikuAPI.lambda.packages.list($stateParams.projectKey, $stateParams.serviceId), $scope.saveServiceIfNeeded()])
            .then(function(data) {
                const names = data[0].data.map(Fn.prop("id"));
                Dialogs.prompt($scope, "New API service version", "Version ID", $scope.suggestNextName(names), { pattern: "^(?!\\.)[\\w\\.-]+$" })
                    .then(function(id) {
                        $state.go("projects.project.lambdaservices.service.packages", {reload:true});

                        DataikuAPI.lambda.services.startPreparePackage($stateParams.projectKey, $stateParams.serviceId, id).success(function(data) {
                            FutureProgressModal.show($scope, data, "Build package").then(function(result) {
                                if (result && result.anyMessage) { // undefined in case of abort
                                    Dialogs.infoMessagesDisplayOnly($scope, "Build result", result, result.futureLog);
                                }
                                $scope.$broadcast("packageReady");
                            });
                        }).error(setErrorInScope.bind($scope));
                    });
            });
    };

    $scope.publishVersionOnDeployer = function(versionId, canChangeVersion) {
        if ($rootScope.appConfig.remoteDeployerMisconfigured) {
            Dialogs.ack($scope, 'Remote deployer not properly configured',
                'To push to a remote deployer, you must previously register it in the DSS instance settings (admin rights required)');
        } else {
            if (!versionId) {
                DataikuAPI.lambda.packages.list($stateParams.projectKey, $stateParams.serviceId)
                    .success(function(packages) {
                        $scope.publishVersionOnDeployer($scope.suggestNextName(packages.map(p => p.id)), true);
                    }).error(setErrorInScope.bind($scope));
            } else {
                $scope.saveService().then(function() {
                    CreateModalFromTemplate("/templates/lambda/publish-version-on-deployer-modal.html", $scope, "PublishVersionOnDeployerModalController", function(modalScope) {
                        modalScope.uploadParams = {canChangeVersion, versionId};
                    });
                });
            }
        }
    };

    $scope.deployToDevServer = function() {
        Logger.info("Deploying to dev server");
        let firstPromise = $q.when(null);
        if ($scope.serviceIsDirty()) {
            firstPromise = $scope.saveService();
        }
        return firstPromise.then(function() {
            const promise = DataikuAPI.lambda.services.deployDev($stateParams.projectKey, $stateParams.serviceId);
            promise.error(setErrorInScope.bind($scope));
            $scope.$broadcast("devServerDeploymentStarted", promise);

            promise.then(function(data) {
                DataikuAPI.lambda.devServer.getStatus().success(function(data) {
                    $scope.lambdaDevServerStatus = data;
                });
            });
            return promise;
        });
    };

    $scope.saveCustomFields = function(newCustomFields) {
        WT1.event('custom-fields-save', {objectType: 'LAMBDA_SERVICE'});
        let oldCustomFields = angular.copy($scope.service.customFields);
        $scope.service.customFields = newCustomFields;
        return $scope.saveService().then(function() {
                $rootScope.$broadcast('customFieldsSaved', TopNav.getItem(), $scope.service.customFields);
            }, function() {
                $scope.service.customFields = oldCustomFields;
            });
    };

    $scope.editCustomFields = function() {
        if (!$scope.service) {
            return;
        }
        let modalScope = angular.extend($scope, {objectType: 'LAMBDA_SERVICE', objectName: $scope.service.name, objectCustomFields: $scope.service.customFields});
        CreateModalFromTemplate("/templates/taggable-objects/custom-fields-edit-modal.html", modalScope).then(function(customFields) {
            $scope.saveCustomFields(customFields);
        });
    };
});


app.controller("LambdaServiceConfigController", function($stateParams, $scope, $state, DataikuAPI, TopNav, Dialogs, CreateModalFromTemplate, Fn) {
    TopNav.setLocation(TopNav.TOP_HOME, "lambda", TopNav.TABS_LAMBDA, "conf");

    function editApiKey(isNew, apiKey) {
        return CreateModalFromTemplate("/templates/lambda/api-key-modal.html", $scope, null, function(modalScope) {
            modalScope.apiKey = apiKey;
        });
    };

    $scope.editAPIKey = editApiKey.bind(null, false);
    $scope.newAPIKey = function() {
        const apiKey = {
            createdOn: Date.now(),
            createdBy: $scope.appConfig.login
        };
        editApiKey(true, apiKey).then(function(k) {
            $scope.service.authRealm.queryKeys.push(apiKey);
        });
    };
});


app.controller("LambdaServicePackagesController", function($stateParams, $scope, $state, DataikuAPI, TopNav, Dialogs, CreateModalFromTemplate) {
    TopNav.setLocation(TopNav.TOP_HOME, "lambda", TopNav.TABS_LAMBDA, "packages");

    function listPackages() {
        DataikuAPI.lambda.packages.list($stateParams.projectKey, $stateParams.serviceId)
            .success(function(packages) {
                $scope.packages = packages;
            }).error(setErrorInScope.bind($scope));
    }
    listPackages();
    $scope.$on("packageReady", listPackages);

    $scope.deletePackage = function(packageId) {
        Dialogs.confirmSimple($scope, "Are you sure you want to delete package <code>" + packageId + "</code>?")
            .then(function() {
                DataikuAPI.lambda.packages.delete($stateParams.projectKey, $stateParams.serviceId, packageId)
                    .success(listPackages)
                    .error(setErrorInScope.bind($scope));
            });
    };

    $scope.downloadPackage = function(packageId) {
        $('body').append(['<iframe src="/dip/api/lambda-services/package/download?projectKey=',
            encodeURIComponent($stateParams.projectKey),
            "&serviceId=", encodeURIComponent($stateParams.serviceId),
            "&packageId=", encodeURIComponent(packageId),
            '"></iframe>'
        ].join(''));
    };
});


app.controller('NewEndpointFromSavedModelModalController', function($scope, $stateParams, DataikuAPI, StateUtils, WT1) {
    DataikuAPI.lambda.services.list($stateParams.projectKey).success(function(lambdaServices) {
        $scope.lambdaServices = lambdaServices;
    }).error(setErrorInScope.bind($scope));

    $scope.createEndPoint = function() {
        WT1.event('add-model-api-endpoint');
        DataikuAPI.lambda.services.addEndpoint($stateParams.projectKey, $scope.service.id, $scope.service.create, $scope.ep)
            .success(function(service) {
                $scope.resolveModal();
                StateUtils.go.lambdaService(service.id, service.projectKey);
            })
            .error(setErrorInScope.bind($scope));
    };
});


app.controller('PublishVersionOnDeployerModalController', function($scope, $rootScope, $stateParams, $q, DataikuAPI, WT1, FutureProgressModal, ActivityIndicator, Dialogs, StringUtils) {
    $scope.publishedServiceIds = [];
    let suggestedServiceId;
    $scope.$watch('uploadParams.targetService.createServiceMessage', function(nv, ov) {
        if (nv) {
            $scope.uploadParams.targetService.serviceBasicInfo.id = suggestedServiceId;
        }
    });

    DataikuAPI.apideployer.client.listPublishedServices()
        .success(function(response) {
            $scope.publishedServices = response.filter(serviceStatus => serviceStatus.canWrite).sort((a, b) => a.serviceBasicInfo.name.localeCompare(b.serviceBasicInfo.name));
            suggestedServiceId = StringUtils.transmogrify($stateParams.serviceId,
                                                          $scope.publishedServices.map(_ => _.serviceBasicInfo.id),
                                                          (count, name) => `${name}-${count}`);
            $scope.publishedServices.unshift({createServiceMessage: "Create a new service...", packages: [], serviceBasicInfo: {id: suggestedServiceId}});
            $scope.publishedServiceIds = $scope.publishedServices.map(function(serviceStatus) {
                if (serviceStatus.createServiceMessage || (serviceStatus.serviceBasicInfo.id === serviceStatus.serviceBasicInfo.name)) return "";
                return serviceStatus.serviceBasicInfo.id;
            });
            $scope.uploadParams.targetService = $scope.publishedServices.find(service => service.serviceBasicInfo.id === $stateParams.serviceId);
            if (!$scope.uploadParams.targetService || $scope.uploadParams.targetService.packages.find(version => version.id === $scope.uploadParams.versionId)) {
                $scope.uploadParams.targetService = $scope.publishedServices[0];
            }
        })
        .error(setErrorInScope.bind($scope));

    $scope.ok = function() {
        function createAVersionIfNecessary() {
            if ($scope.uploadParams.canChangeVersion) {
                const deferred = $q.defer();
                DataikuAPI.lambda.services.startPreparePackage($stateParams.projectKey, $stateParams.serviceId, $scope.uploadParams.versionId).success(function(data) {
                    FutureProgressModal.show($scope, data, "Build package").then(function(result) {
                        if (result && result.anyMessage) { // undefined in case of abort
                            Dialogs.infoMessagesDisplayOnly($scope, "Build result", result, result.futureLog).then(function(){
                                $scope.resolveModal();
                            })
                        } else { 
                            $rootScope.$broadcast("packageReady");
                            deferred.resolve();
                        }
                    });
                }).error(setErrorInScope.bind($scope));
                return deferred.promise;
            } else {
                return $q.when(null);
            }
        }
        createAVersionIfNecessary().then(function() {
            DataikuAPI.lambda.packages.publishToAPIDeployer($scope.service.projectKey, $scope.service.id, $scope.uploadParams.versionId, $scope.uploadParams.targetService.serviceBasicInfo.id)
                .success(function() {
                    if ($rootScope.appConfig.deployerMode == 'LOCAL') {
                        ActivityIndicator.success(`Service published on API deployer! <a href="/api-deployer/services/${$scope.uploadParams.targetService.serviceBasicInfo.id}/?versions=${$scope.uploadParams.versionId}"  target="_blank">Open API deployer.</a>`, 5000);
                    } else if ($rootScope.appConfig.deployerURL) {
                        const deployerURL = $rootScope.appConfig.deployerURL + '/api-deployer/services/' + $scope.uploadParams.targetService.serviceBasicInfo.id + "/?versions=" + $scope.uploadParams.versionId;
                        ActivityIndicator.success(`Service published on API deployer! <a href="${deployerURL}" target="_blank">Open API deployer.</a>`, 5000);
                    }
                    $scope.resolveModal();
                    WT1.event('api-deployer-publish-to-deployer');
                })
                .error(setErrorInScope.bind($scope));
        });
    };
});


app.service("LambdaServicesService", function($rootScope, CreateModalFromTemplate) {
    this.newEndpointFromSavedModel = function(savedModelId, savedModelName) {
        CreateModalFromTemplate("/templates/lambda/new-endpoint-from-saved-model-modal.html", $rootScope, 'NewEndpointFromSavedModelModalController', function(modalScope) {
            modalScope.service = {
                create: true,
                id: null
            };

            modalScope.ep = {
                type: 'STD_PREDICTION',
                modelRef: savedModelId,
                useJava: true
            };

            modalScope.savedModelName = savedModelName;
        });
    };
});


})();

(function() {
'use strict';

const app = angular.module('dataiku.lambda');


app.constant('ENDPOINT_TYPES', {
    STD_PREDICTION: "Prediction",
    CUSTOM_PREDICTION: "Custom prediction (Python)",
    CUSTOM_R_PREDICTION: "Custom prediction (R)",
    DATASETS_LOOKUP: "Lookup",
    SQL_QUERY: "SQL Query",
    PY_FUNCTION: "Python function",
    R_FUNCTION: "R function"
});


app.controller("LambdaServiceEndpointsController", function($stateParams, $scope, $state, DataikuAPI, WT1, TopNav, Dialogs, CreateModalFromTemplate, Fn, ENDPOINT_TYPES) {
    TopNav.setLocation(TopNav.TOP_HOME, "lambda", TopNav.TABS_LAMBDA, "endpoints");
    $scope.endpointTypes = ENDPOINT_TYPES;
    $scope.uiState = {
        activeEndpoint: null
    };
    $scope.$watch("uiState.activeEndpoint", function(nv, ov) {
        $scope.endpoint = nv;
    });
    $scope.$watch("service", function(nv, ov) {
        if (nv && $scope.uiState.activeEndpoint == null && nv.endpoints.length) {
            $scope.uiState.activeEndpoint = nv.endpoints[0];
        }
    });

    $scope.renameEndpoint = function() {
        Dialogs.prompt($scope, "Rename endpoint", "New endpoint name", $scope.endpoint.id, { pattern: "[\\w-_]+" }).then(function(newName) {
            if (!newName || newName === $scope.endpoint.id) return;
            if ($scope.service.endpoints.some(ep => ep.id === newName)) {
                Dialogs.ack("This name is already taken by another endpoint of this API service.");
                return;
            }
            $scope.endpoint.id = newName;
            $scope.saveService();
        });
    };

    $scope.deleteEndpoint = function() {
        const endpoints = $scope.service.endpoints;
        Dialogs.confirm($scope, "Confirm deletion", 'Are you sure you want to delete API endpoint "'+$scope.endpoint.id+'"?').then(function() {
            endpoints.splice(endpoints.indexOf($scope.uiState.activeEndpoint), 1);
            $scope.saveService();
            $scope.uiState.activeEndpoint = endpoints.length ? endpoints[0] : null;
        });
    };

    $scope.createNewEndpoint = function() {
        CreateModalFromTemplate("/templates/lambda/new-endpoint-modal.html", $scope, null, function(modalScope) {
            modalScope.ep = {
                projectKey: $stateParams.projectKey, id: null, type: 'STD_PREDICTION', code: '',
                modelType: 'CLASSIFICATION', testQueries: [], enrichMapping: [], useJava: true
            };

            modalScope.savedModels = [];
            DataikuAPI.savedmodels.list($stateParams.projectKey).success(function(savedModels) {
                modalScope.savedModels = savedModels.filter(Fn(Fn.propStr('miniTask.taskType'), Fn.eq('PREDICTION')));
            });

            modalScope.$watch("ep.modelRef", newVal => {
                if (!newVal || !modalScope.savedModels) return;
                modalScope.ep.backendType = modalScope.savedModels.find(el => el.id === newVal).miniTask.backendType;
                if (modalScope.ep.backendType === 'KERAS') {
                    modalScope.ep.useJava = false;
                } else if (modalScope.ep.backendType !== 'PY_MEMORY') {
                    modalScope.ep.useJava = true;
                }
            });
        }).then(function(endpoint) {
            if (!endpoint) {
                return;
            }
            if (endpoint.type === 'CUSTOM_PREDICTION') {
                const tpl = document.getElementById('custPredEndpointTpl/PYTHON_' + endpoint.modelType);
                if (tpl) {
                    endpoint.code = tpl.innerHTML;
                }
            } else if (endpoint.type === 'CUSTOM_R_PREDICTION') {
                const tpl = document.getElementById('custPredEndpointTpl/R_' + endpoint.modelType);
                if (tpl) {
                    endpoint.code = tpl.innerHTML;
                }
                endpoint.userFunctionName = "prediction_function";
            } else if (endpoint.type === 'R_FUNCTION') {
                const tpl = document.getElementById('custEndpointTpl/R_FUNCTION');
                if (tpl) {
                    endpoint.code = tpl.innerHTML;
                }
                endpoint.userFunctionName = "api_r_function";
            } else if (endpoint.type === 'PY_FUNCTION') {
                const tpl = document.getElementById('custEndpointTpl/PY_FUNCTION');
                if (tpl) {
                    endpoint.code = tpl.innerHTML;
                }
                endpoint.userFunctionName = "api_py_function";
            } else if (endpoint.type == "SQL_QUERY") {
                endpoint.queries = [{ query: "-- Insert your SQL code here", inputParameters: []}]
            } else if (endpoint.type == "DATASETS_LOOKUP") {
                endpoint.lookups = [];
            }
            $scope.service.endpoints.push(endpoint);
            WT1.event('create-api-endpoint', {type: endpoint.type, nEndpints: $scope.service.endpoints.length});
            $scope.saveService();
            $scope.uiState.activeEndpoint = $scope.service.endpoints[$scope.service.endpoints.length - 1];
        });
    };

    $scope.canDevServer = function(endpoint) {
        if (!endpoint) {
            return false;
        }
        const t = endpoint.type;
        return t.substring(t.length - 11) == '_PREDICTION'
            || t.substring(t.length-9) == '_FUNCTION'
            || t == 'DATASETS_LOOKUP'
            || t == 'SQL_QUERY';
    };

    $scope.sendPlayTestQueriesMsg = function() {
        $scope.$broadcast("playTestQueries");
    };
});


app.controller("_EndpointController", function($scope, $stateParams, DataikuAPI, Fn, DatasetUtils, Logger, WT1) {
    $scope.$on("devServerDeploymentStarted", function(evt, promise) {
        if ($scope.testSettingsPane) {
            promise.success(function(data) {
                $scope.deployResult = data;
                $scope.uiState.settingsPane = "test";
            }).catch(console.info.bind(console));   /*@console*/
        }
    });

    $scope.$on("playTestQueries", function() {
        WT1.event('api-designer-test-queries', {nQueries: $scope.endpoint.testQueries.length, outputExplanations: $scope.endpoint.outputExplanations});
        if ($scope.testQueriesMode) {
            Logger.info("Playing testQueries:", $scope.endpoint.testQueries);
            $scope.deployToDevServer().then(function() {
                DataikuAPI.lambda.services.playTestQueries($stateParams.projectKey, $stateParams.serviceId,
                        $scope.endpoint.id, $scope.testQueriesMode, $scope.endpoint.testQueries).success(function(data) {
                            $scope.testQueriesResult = data;
                        }).error(setErrorInScope.bind($scope));
            });
        }
    });
});


app.controller("_WithEnrichmentsController", function($scope, $controller, $stateParams, Assert, DataikuAPI, Fn, Logger) {
    $scope.enrichmentsList = null;

    if ($scope.endpoint.type == "DATASETS_LOOKUP") {
        $scope.enrichmentsList = $scope.endpoint.lookups;
    } else {
        $scope.enrichmentsList = $scope.endpoint.enrichMapping;
    }
    Assert.inScope($scope, 'enrichmentsList');

    $scope.uiState = {};
    if ($scope.enrichmentsList && $scope.enrichmentsList.length>0) {
        $scope.enrichmentIndex = 0;
    }
    DataikuAPI.flow.listUsableComputables($stateParams.projectKey, {datasetsOnly:true}).success(function(datasets) {
        $scope.datasets = datasets;
        $scope.datasets.forEach(function(ds) {
            ds.localProject = ds.projectKey === $stateParams.projectKey;
        });

        $scope.defaultDataset = datasets.filter(Fn.prop('localProject'))[0] || datasets[0];
    }).error(setErrorInScope.bind($scope));

    DataikuAPI.admin.getGeneralSettings().success(function(gs) {
        $scope.devBundledConnection = gs.lambdaDevBundledConnection;
    });

    $scope.showEnrichment = function(index) {
        $scope.enrichmentIndex = index;
    };

    $scope.enrichMappingTemplate = function() { return ; };

    $scope.addEnrichment = function() {
        $scope.enrichmentsList.push({
            packagingType: 'BUNDLED_TOCONNECTION',
            on: [],
            columnsMapping: {},
            missingLookupKeyBehavior: 'IGNORE',
            notFoundBehavior: 'IGNORE',
            multiMatchBehavior: 'KEEP_FIRST'
        });
        $scope.enrichmentIndex = $scope.enrichmentsList.length - 1;
    };

    $scope.deleteEnrichment = function(index) {
        $scope.enrichmentsList.splice(index, 1);
        if (index < $scope.enrichmentIndex) {
            $scope.enrichmentIndex--;
        } else if (index === $scope.enrichmentIndex) {
            $scope.enrichmentIndex = -1;
        }
    };
});


app.controller("SingleEnrichmentController", function($scope, Logger, AnyLoc, $stateParams, DataikuAPI, DatasetUtils) {
    $scope.uiState = {};
    $scope.selection = {};
    $scope.currentEnrichment = $scope.enrichmentsList[$scope.enrichmentIndex];

    function getColumnsUIState(datasetColumns, columnsMapping) {
        if (datasetColumns) {
            datasetColumns
                .filter(column => column.name in columnsMapping)
                .forEach(column => {
                    column.$selected = true;
                    if (columnsMapping[column.name] != column.name) {
                        column.modelFeature = columnsMapping[column.name];
                    }
                });
        }
        return datasetColumns;
    }

    function getColumnsMapping(columns) {
        return columns
            .filter(col => col.$selected)
            .reduce((dict, col) => {
                dict[col.name] = col.modelFeature || col.name;
                return dict;
            }, {});
    }

    $scope.$watch("currentEnrichment.datasetRef", function(nv) {
        if (nv) {
            const datasetLoc = AnyLoc.getLocFromSmart($stateParams.projectKey, nv);
            DataikuAPI.datasets.get(datasetLoc.projectKey, datasetLoc.localId, $stateParams.projectKey)
                .success(function(data) {
                    $scope.uiState.columns = getColumnsUIState(data.schema.columns, $scope.currentEnrichment.columnsMapping);
                    // new uiState.columns => new columnsMapping thanks to watch on uiState.columns
                    // still need to update "on"
                    const columnNames = $scope.uiState.columns.map(x => x.name);
                    $scope.currentEnrichment.on = $scope.currentEnrichment.on.filter(x => (columnNames.indexOf(x.resourceLookupCol) > -1));
                }).error(setErrorInScope.bind($scope));
        }
    });

    $scope.$watch("currentEnrichment.packagingType", (newValue) => {
        if (newValue === 'REFERENCED') {
            $scope.datasets.forEach(ds => ds.usable = DatasetUtils.isSQL(ds.dataset));
        } else if (newValue == 'BUNDLED_TOCONNECTION') {
            $scope.datasets.forEach(ds => ds.usable = true);
        }
    });

    // if uiState.columns changes, update columnsMapping - this watches the change on feature name
    $scope.$watch("uiState.columns", function(nv) {
        if (nv) {
            $scope.currentEnrichment.columnsMapping = getColumnsMapping(nv);
        }
    }, true);
    // We need also to watch $selected of each item - since it's not watchable ($-prefixed),
    // instead we watch selection.selectedObjects in non-deep mode
    $scope.$watch("selection.selectedObjects", function(nv) {
        if (nv && $scope.uiState.columns) {
            $scope.currentEnrichment.columnsMapping = getColumnsMapping($scope.uiState.columns);
        }
    });
});

app.controller("PredictionEndpointController", function($scope, $controller, $stateParams, DataikuAPI, Fn, DatasetUtils, Logger) {
    $controller("_EndpointController", {$scope:$scope});
    $controller("_WithEnrichmentsController", {$scope:$scope});
    $scope.testSettingsPane = 'test';
    $scope.testQueriesMode = 'predict';

    $scope.uiState.settingsPane = 'loading';
    $scope.endpoint.outputExplanations = $scope.endpoint.outputExplanations || false;

    $scope.$watch('endpoint', function(nv) {
        if (!nv) return;
        // Set the correct default pane
        if (['loading', 'model', 'settings', 'code'].indexOf($scope.uiState.settingsPane) >= 0) {
            $scope.uiState.settingsPane = nv.type === 'STD_PREDICTION' ? 'model' : 'settings';
        }
        if (["CUSTOM_R_PREDICTION", "CUSTOM_PREDICTION"].indexOf($scope.endpoint.type) >= 0) {
            $scope.endpoint.envSelection = $scope.endpoint.envSelection || {envMode: 'INHERIT'};
        }
    });

    // STD_PREDICTION / Saved models
    function setSM(ref) {
        if (!ref || !$scope.savedModels) return;
        $scope.savedModel = $scope.savedModels.find(sm => sm.id == ref);
        if ($scope.savedModel.miniTask.backendType === 'KERAS') {
            $scope.endpoint.useJava = false;
            $scope.endpoint.outputExplanations = false;
        } else if ($scope.savedModel.miniTask.backendType !== 'PY_MEMORY') {
            $scope.endpoint.useJava = true;
            $scope.endpoint.outputExplanations = false;
        } else {
            if (!$scope.endpoint.individualExplanationParams) {
                $scope.endpoint.individualExplanationParams = {
                    method: "ICE",
                    nbExplanations: 3,
                    shapleyBackgroundSize: 100
                };
            }
        }
    }

    $scope.$watch("endpoint.modelRef", setSM);
    DataikuAPI.savedmodels.list($stateParams.projectKey).success(function(savedModels) {
        $scope.savedModels = savedModels.filter(Fn(Fn.propStr('miniTask.taskType'), Fn.eq('PREDICTION')));
        setSM($scope.endpoint.modelRef);
    });

    $scope.canComputeExplanations = function() {
        return $scope.savedModel && $scope.savedModel.miniTask.backendType === "PY_MEMORY";
    }

    $scope.getBackendSelectionDisableMessage = function () {
        if ($scope.endpoint.outputExplanations) {
            return "Java scoring is not available when explanations are enabled";
        } else {
            return "Backend selection is not available for this model";
        }
    } 

    $scope.onOutputExplanationsChange = function() {
        if ($scope.endpoint.outputExplanations) {
            $scope.endpoint.useJava = false;
        }
    }


    // CUSTOM_PREDICTION / Managed folders
    function setMF(ref) {
        if (!ref || !$scope.managedFolders) return;
        $scope.managedFolder = $scope.managedFolders.filter(Fn(Fn.prop('id'), Fn.eq(ref)))[0]; // possibly undefined
    }
    $scope.$watch("endpoint.inputFolderRef", setMF);
    DataikuAPI.managedfolder.list($stateParams.projectKey).success(function(managedFolders) {
        $scope.managedFolders = managedFolders;
        setMF($scope.endpoint.inputFolderRef);
    });
    $scope.customCodeSnippetCategories = [''];
    $scope.$watch("endpoint.modelType", function(nv) {
        if (!nv) return;
        $scope.customCodeSnippetCategories = [nv === 'REGRESSION' ? 'py-regressor' : 'py-classifier'];
    });
});


app.controller("FunctionEndpointController", function($scope, $controller, $stateParams, DataikuAPI, Fn, DatasetUtils, Logger) {
    $controller("_EndpointController", {$scope:$scope});
    $scope.testSettingsPane = 'test';
    $scope.testQueriesMode = 'function';

    $scope.uiState.settingsPane = 'loading';

    $scope.$watch('endpoint', function(nv) {
        if (!nv) return;
        if (['loading', 'settings', 'code'].indexOf($scope.uiState.settingsPane) >= 0) {
            $scope.uiState.settingsPane = "code"
        }
        $scope.endpoint.envSelection = $scope.endpoint.envSelection || {envMode:'INHERIT'};
        if ($scope.endpoint.type == 'R_FUNCTION') {
            $scope.customCodeSnippetCategories = ['apinode-r-function-endpoint'];
            $scope.envLang = 'R';
            $scope.sampleType = 'R';
        } else if ($scope.endpoint.type == 'PY_FUNCTION') {
            $scope.customCodeSnippetCategories = ['apinode-py-function-endpoint'];
            $scope.envLang = 'PYTHON';
            $scope.sampleType = 'python';
        }
    });

    DataikuAPI.managedfolder.list($stateParams.projectKey).success(function(managedFolders) {
        $scope.managedFolders = managedFolders;
        // setMF($scope.endpoint.inputFolderRef);
    });
});


app.controller("SQLQueryEndpointController", function($scope, $controller, $stateParams, DataikuAPI, Fn, DatasetUtils, Logger, CodeMirrorSettingService) {
    $controller("_EndpointController", {$scope:$scope});
    $scope.testSettingsPane = 'test';
    $scope.testQueriesMode = 'query';
    $scope.sqlQueryIndex = 0;

    $scope.uiState.settingsPane = 'loading';

    $scope.editorOptions =  CodeMirrorSettingService.get('text/x-sql');
    $scope.customCodeSnippetCategories = ['apinode-sql-query-endpoint'];
    $scope.sampleType = 'sql';

    DataikuAPI.connections.getNames('SQL').success(function (data) { $scope.sqlConnections = data; }).error(setErrorInScope.bind($scope));

    $scope.showSQLQuery = function(index) {
        $scope.sqlQueryIndex = index;
    };

    $scope.addSQLQuery = function() {
        $scope.endpoint.queries.push({query: "-- Insert your SQL code here", inputParameters: [], maxResults: 0});
    };

    $scope.deleteSQLQuery = function(index) {
        $scope.endpoint.queries.splice(index, 1);
        if (index < $scope.sqlQueryIndex) {
            $scope.sqlQueryIndex--;
        } else if (index === $scope.sqlQueryIndex) {
            $scope.sqlQueryIndex = -1;
        }
    };

    $scope.$watch('endpoint', function(nv) {
        if (!nv) return;
        // fromInputParameterNames();
        if (['loading', 'settings', 'query'].indexOf($scope.uiState.settingsPane) >= 0) {
            $scope.uiState.settingsPane = "query"
        }
    });
});


app.controller("DatasetsLookupEndpointController", function($scope, $controller, $stateParams, DataikuAPI, Fn, DatasetUtils, Logger) {
    $controller("_EndpointController", {$scope:$scope});
    $controller("_WithEnrichmentsController", {$scope:$scope});
    $scope.testSettingsPane = 'test';
    $scope.testQueriesMode = 'lookup';

    $scope.uiState.settingsPane = 'loading';

    $scope.$watch('endpoint', function(nv) {
        if (!nv) return;
        $scope.uiState.settingsPane = "lookups";
        $scope.endpoint.lookups = $scope.endpoint.lookups || [];
    });
});


app.directive('endpointTestQueries', function(DataikuAPI, $q, CreateModalFromTemplate, $state, $stateParams, TopNav, Dialogs, Fn, $filter, Logger, CodeMirrorSettingService) {
    return {
        restrict: 'A',
        templateUrl: '/templates/lambda/endpoint-test-queries.html',
        replace: true,
        scope: {
            endpoint: '=',
            deployResult: '=',
            testQueriesResult: '=',
            type: '@',
            datasets: '=',
            inputDatasetSmartName: '=',
            run: '&'
        },
        link: function($scope, element, attrs) {

            $scope.emptyTestQueryTemplate = function() {
                if ($scope.type === "predict") {
                    return enrichTestQueryWithExplanations({ q: { features: {} }});
                } else if ($scope.type == "lookup") {
                    return { q: { data: {} }};
                } else {
                    return { q: { paramNameToReplace: "paramValueToReplace" }};
                }
            };
            $scope.getHeight =  function(q) { return Object.keys(q.features).length + 4; };
            $scope.uiState = {
                requestType: "EMPTY",
                queriesBatchSize: 1,
                inputDatasetSmartName: null
            }
            if ($scope.endpoint.testQueries.length > 0) {
                $scope.uiState.testQueryIndex = 0;
            }
            $scope.createNewQueries = function() {
                if ($scope.type === "predict") {
                    $scope.showAddQueriesModal();
                }
                else {
                    $scope.endpoint.testQueries.push($scope.emptyTestQueryTemplate());
                    $scope.uiState.testQueryIndex  = $scope.endpoint.testQueries.length - 1;
                }
            };
            $scope.addQueries = function(requestType, queriesBatchSize, inputDatasetSmartName) {
                const newIndex = $scope.endpoint.testQueries.length;
                if (requestType === "EMPTY") {
                    for (let i = 0; i < queriesBatchSize; i++) {
                        $scope.endpoint.testQueries.push($scope.emptyTestQueryTemplate());
                    }
                } else if (requestType === "DATASET") {
                    DataikuAPI.lambda.services.getSampleQueriesFromDataset($stateParams.projectKey, 
                                                                           inputDatasetSmartName, 
                                                                           $scope.endpoint.modelRef, 
                                                                           queriesBatchSize, "HEAD_SEQUENTIAL").success(function(data) {
                        data.forEach(enrichTestQueryWithExplanations);
                        $scope.endpoint.testQueries.push.apply($scope.endpoint.testQueries, data);
                    }).error(setErrorInScope.bind($scope));
                } else {
                    setErrorInScope.bind($scope);
                }
                $scope.uiState.testQueryIndex = newIndex;
            }

            $scope.deleteTestQuery = function(index) {
                $scope.endpoint.testQueries.splice(index, 1);
                if ($scope.testQueriesResult && $scope.testQueriesResult.responses) {
                    $scope.testQueriesResult.responses.splice(index, 1);
                }
                if (index < $scope.uiState.testQueryIndex) {
                    $scope.uiState.testQueryIndex--;
                } else if (index === $scope.uiState.testQueryIndex) {
                    $scope.uiState.testQueryIndex = -1;
                }
            };

            $scope.duplicateTestQuery = function(index) {
                if (index < 0 || index >= $scope.endpoint.testQueries.length) return;
                const copied = angular.copy($scope.endpoint.testQueries[index]);
                if (copied.name) {
                    copied.name = 'Copy of ' + copied.name;
                }
                const newIndex = $scope.endpoint.testQueries.length;
                $scope.uiState.testQueryIndex = newIndex;
                $scope.endpoint.testQueries.push(copied);
            };

            $scope.showTestQuery = function(index) {
                $scope.uiState.testQueryIndex = index;
            };

            $scope.showAddQueriesModal = function() {
                CreateModalFromTemplate("/templates/lambda/add-queries-modal.html", $scope)
            };

            $scope.getCollectedColumnMappings = function() {
                const mappings = {};
                $scope.endpoint.lookups.forEach(function(lookup) {
                    angular.forEach(lookup.columnsMapping, function(v,k) {
                        mappings[k] = v;
                    });
                });
                return mappings;
            };
            
            function enrichTestQueryWithExplanations(query) {
                if ($scope.endpoint.outputExplanations) {
                    const tq = {
                        enabled: true,
                        method: $scope.endpoint.individualExplanationParams.method,
                        nExplanations: $scope.endpoint.individualExplanationParams.nbExplanations,
                    };
                    if (tq.method === "SHAPLEY") {
                        tq.nMonteCarloSteps = $scope.endpoint.individualExplanationParams.shapleyBackgroundSize;
                    }
                    query.q.explanations = tq;
                }
                return query;
            }
        }
    };
});


app.filter('endpointTypeToName', function(ENDPOINT_TYPES) {
    return function(type) {
        if (!type) {
            return;
        }
        return ENDPOINT_TYPES[type] || type;
    };
});


app.filter('endpointTypeToIcon', function(ENDPOINT_TYPES) {
    return function(type) { // @TODO lambda: improve endpoint icons
        if (!type) {
            return;
        } else if (type == 'STD_PREDICTION') {
            return 'icon-machine_learning_regression';
        } else if (type == 'CUSTOM_PREDICTION') {
            return 'icon-machine_learning_regression';
        } else if (type == 'CUSTOM_R_PREDICTION') {
            return 'icon-machine_learning_regression';
        } else if (type == 'DATASETS_LOOKUP') {
            return 'icon-dataset';
        } else if (type == 'SQL_QUERY') {
            return 'icon-sql';
        } else if (type == 'PY_FUNCTION') {
            return 'icon-dku-python';
        } else if (type == 'R_FUNCTION') {
            return 'icon-dku-r';
        } else {
            return;
        }
    };
});
})();
(function() {
'use strict';

/** This module provides global Git capabilities that are shared between projects, plugins, git references, ... */
const app = angular.module('dataiku.git', []);

app.controller("CommitObjectModalController", function($scope, $stateParams, Assert, DataikuAPI) {
    $scope.uiState = {
        activeTab: "message"
    };

    function fetch() {
        Assert.inScope($scope, 'object');
        DataikuAPI.git.prepareObjectCommit($stateParams.projectKey,
        	$scope.object.objectType,
        	$scope.object.objectId).success(function(data){
            $scope.preparationData = data;
        }).error(setErrorInScope.bind($scope))
    }

    $scope.$watch("object", function(nv, ov){
        if (!nv) {
            return;
        }
        fetch();
    });

    $scope.commit = function() {
    	Assert.inScope($scope, 'object');
    	DataikuAPI.git.commitObject($stateParams.projectKey,
        	$scope.object.objectType,
        	$scope.object.objectId, $scope.uiState.message).success(function(data){
        	$scope.dismiss();
        }).error(setErrorInScope.bind($scope))
    };
});

app.controller("_gitLogControllerBase", function($scope, DataikuGitAPI, element, objectType, $document, $state, $timeout, CreateModalFromTemplate, $stateParams, Dialogs, $filter, DKUtils) {
    let $element = $(element[0]);
    let $line = $element.find('.line-selected');

    $scope.compare = {};

    $scope.setCompareFrom = function(day, commit) {
        $scope.compare.from = {day: day, commit: commit};
        $scope.compare.to = null;
        $timeout(function() { $document.on('click', $scope.exitCompare); });
    };

    $scope.exitCompare = function() {
        safeApply($scope, function() { $scope.compare = {}; });
        $document.off('click', $scope.exitCompare)
    };

    $scope.$on('$destroy', function() {
        $document.off('click', $scope.exitCompare)
    });

    $scope.setCompareTo = function(day, commit) {
        if (!$scope.compare.from) return;
        $scope.compare.to = {day: day, commit: commit};
    };

    $scope.dayInCompareRange = function(day) {
        if (!$scope.compare.from) return true;
        if (!$scope.compare.to) return $scope.compare.from.day == day;
        return day >= $scope.compare.top.day && day <= $scope.compare.bottom.day;
    };

    $scope.commitInCompareRange = function(day, commit) {
        if (!$scope.compare.from) return true;
        if (!$scope.compare.to) return $scope.compare.from.day == day && $scope.compare.from.commit == commit;

        var afterTop = day > $scope.compare.top.day || (day == $scope.compare.top.day) && commit > $scope.compare.top.commit;
        var beforeBottom = day < $scope.compare.bottom.day || (day == $scope.compare.bottom.day) && commit < $scope.compare.bottom.commit;
        return afterTop && beforeBottom;
    };

    $scope.clickIsOnTag = function($event) {
        return $event.target && $event.target.tagName && $event.target.tagName.toLowerCase() == 'a';
    };
    $scope.openCompareModal = function() {
        if (!$scope.compare.from || !$scope.compare.to) return;

        var commitFrom = $scope.days[$scope.compare.bottom.day].changes[$scope.compare.bottom.commit].commitId;
        var commitTo = $scope.days[$scope.compare.top.day].changes[$scope.compare.top.commit].commitId;

        if (commitFrom === commitTo) return $scope.exitCompare();

        CreateModalFromTemplate("/templates/git/git-compare-modal.html", $scope, null, function(newScope) {
            DataikuGitAPI.getRevisionsDiff(commitFrom, commitTo).success(function (data) {
                newScope.diff = data;
            }).error(setErrorInScope.bind($scope));
        }).then($scope.exitCompare, $scope.exitCompare);
    };

    $scope.isElementA = function($event) {
        return $event.target.tagName.toLowerCase() == 'a';
    };
    $scope.openDiffModal = function(commitId) {
        CreateModalFromTemplate("/templates/git/git-diff-modal.html", $scope, null, function(newScope) {
            // You can't revert an object/project to its last change (#7271)
            newScope.objectRevertable &= commitId !== $scope.logEntries[0].commitId;
            newScope.projectRevertable &= commitId !== $scope.logEntries[0].commitId;

            DataikuGitAPI.getCommitDiff(commitId).success(function(data) {
                newScope.commit = data;

                if (DataikuGitAPI.createBranchFromCommit) {
                    newScope.createBranch = function() {
                        newScope.dismiss();
                        DataikuGitAPI.createBranchFromCommit(commitId);
                    }
                }

                if (newScope.objectRevertable) {
                    newScope.revertTo = function(){
                        newScope.dismiss();
                        $scope.revertObjectToHash(commitId);
                    }
                }
                if (newScope.projectRevertable) {
                    newScope.revertTo = function(){
                        newScope.dismiss();
                        $scope.revertProjectToHash(commitId);
                    }
                }
                if (newScope.commitRevertable) {
                    newScope.revertCommit = function(){
                        newScope.dismiss();
                        $scope.revertSingleCommit(commitId);
                    }
                }
            }).error(setErrorInScope.bind($scope));
        });
    };

    $scope.revertObjectToHash = function(hash) {
        let msg = "Are you sure you want to revert " + $filter("taggableObjectRef")($scope.objectRef) +"?";
        if ($scope.objectRef.projectKey) {
            msg += "\nReverting a single object can lead to inconsistent state. It is recommended to prefer reverting the complete project.";
        }
        Dialogs.confirm($scope, "Revert: " + $filter("taggableObjectRef")($scope.objectRef), msg).then(function(){
            DataikuGitAPI.revertObjectToRevision(hash).success(function(data){
                DKUtils.reloadState();
            }).error(setErrorInScope.bind($scope));
        })
    };

    $scope.revertProjectToHash = function(hash) {
        Dialogs.confirm($scope, "Revert " + objectType,
            "Are you sure you want to revert " + objectType + " to this revision?").then(function(){
            DataikuGitAPI.revertProjectToRevision(hash).success(function(data){
                DKUtils.reloadState();
            }).error(setErrorInScope.bind($scope));
        })
    };

    $scope.revertSingleCommit = function(hash) {
        Dialogs.confirm($scope, "Revert " + hash,
            "Are you sure you want to revert this revision? " +
            "Reverting a single revision can lead to an inconsistent state. It is recommended to prefer reverting "+
            "the complete " + objectType
        ).then(function(){
            DataikuGitAPI.revertSingleCommit(hash).success(function(data){
                Dialogs.infoMessagesDisplayOnly($scope, "Merge results", data).then(function(){
                    DKUtils.reloadState();
                })
            }).error(setErrorInScope.bind($scope));
        })
    };

    $scope.$watch('compare', function(compare) {
        if (!compare || !compare.from || !compare.to) return;

        var days = $element.find('.day');

        if (compare.to.day > compare.from.day || (compare.to.day == compare.from.day) && compare.to.commit > compare.from.commit) {
            compare.bottom = compare.to;
            compare.top = compare.from;
        } else {
            compare.bottom = compare.from;
            compare.top = compare.to;
        }

        var topEl = days.eq(compare.top.day).find('.commit-log-entry').eq(compare.top.commit);
        var bottomEl = days.eq(compare.bottom.day).find('.commit-log-entry').eq(compare.bottom.commit);

        $line.css('top', topEl.position().top + topEl.height()/2);
        $line.css('bottom', $line.parent().height() - bottomEl.position().top - bottomEl.height()/2);
    }, true);

    $scope.$watch("logEntries", function(nv) {
        $scope.days = [];

        if (!nv) return;
        var currentDay = {changes:[]};

        nv.forEach(function(change) {
            var date = new Date(change.timestamp).setHours(0,0,0,0);
            if (date == currentDay.date) {
                currentDay.changes.push(change);
            } else {
                if (currentDay.changes.length) $scope.days.push(currentDay);
                currentDay = {changes: [change], date: date};
            }
        });

        if(currentDay.changes.length) $scope.days.push(currentDay);
    });
});

app.directive("gitLog", function($controller, DataikuAPI, $stateParams) {
    return {
        templateUrl: "/templates/git/git-log.html",
        scope: {
            logEntries: '=',
            lastStatus: '=',
            objectRevertable: '=',
            objectRef: '=',
            projectRevertable: '=',
            commitRevertable: '=',
            noCommitDiff: '=',
            createBranchFromCommit: '='
        },
        link: function ($scope, element) {
            const projectGitAPI = {
                getRevisionsDiff: (commitFrom, commitTo) => DataikuAPI.git.getRevisionsDiff($stateParams.projectKey, commitFrom, commitTo, $scope.objectRef),
                getCommitDiff: (commitId) => DataikuAPI.git.getCommitDiff($stateParams.projectKey, $scope.objectRef, commitId),
                revertObjectToRevision: (hash) => DataikuAPI.git.revertObjectToRevision($scope.objectRef.projectKey, $scope.objectRef.type, $scope.objectRef.id, hash),
                revertProjectToRevision: (hash) => DataikuAPI.git.revertProjectToRevision($stateParams.projectKey, hash),
                revertSingleCommit: (hash) => DataikuAPI.git.revertSingleCommit($stateParams.projectKey, $scope.objectRef, hash),
                createBranchFromCommit: $scope.createBranchFromCommit
            };

            $controller('_gitLogControllerBase', {$scope: $scope, element: element, DataikuGitAPI: projectGitAPI,
                                                objectType: "project"});
        }
    }
});

app.directive("gitDiff", function(DiffFormatter) {
    return {
        templateUrl : "/templates/git/git-diff.html",
        scope: {
            diffEntries : '='
        },
        link: function($scope, element, attrs) {
            $scope.showAll = function() {
                $scope.diffEntries.forEach(function(file) {
                    file.rendered = DiffFormatter.formatChange(file.fileChange);
                    file.shown = true;
                });
            };

            $scope.hideAll = function() {
                $scope.diffEntries.forEach(function(file) {
                    file.shown = false;
                });
            };

            $scope.toggle = function toggle(file) {
                file.shown = !file.shown;
                if (file.shown && !file.rendered) {
                    file.rendered = DiffFormatter.formatChange(file.fileChange);
                }
            };
        }
    }
});

app.directive("objectGitHistory", function($stateParams, DataikuAPI) {
    return {
        scope: {
            objectType: '@',
            objectId: '=',
            projectKey: '=?', // defaults to $stateParams.projectKey
            objectRevertable: '=?'
        },
        templateUrl : "/templates/git/object-git-history.html",
        link: function($scope) {
            var PAGE_SIZE = 20;
            $scope.hasMore = true;

            $scope.objectRef = {
                projectKey: $scope.projectKey || $stateParams.projectKey,
                type: $scope.objectType,
                id: $scope.objectId
            };

            $scope.$watch('objectId', function(nv) {
                $scope.objectRef.id = nv;
            });

            $scope.loadMore = function () {
                if ($scope.hasMore && !$scope.loading) {
                    $scope.loading = true;
                    DataikuAPI.git.getObjectLog($scope.projectKey || $stateParams.projectKey, $scope.objectType, $scope.objectId || $stateParams.webAppId, $scope.nextCommit, PAGE_SIZE).success(function(data){
                        $scope.logEntries = ($scope.logEntries || []).concat(data.logEntries);
                        $scope.nextCommit = data.nextCommit;
                        if (!$scope.nextCommit) {
                            $scope.hasMore = false;
                        }
                        $scope.loading = false;
                    }).error(setErrorInScope.bind($scope));
                }
            };
        }
    };
});

/**
 * This service provides common support for parts of DSS that support "full-repository push-pull" interaction, i.e
 *   - projects
 *   - plugins in development
 */ 
app.service("FullGitSupportService", function(DataikuAPI, $state, $stateParams, CreateModalFromTemplate,
                                                   Dialogs, FutureProgressModal, DKUtils, $filter, WT1) {

    var svc = {};

    svc.getFullStatus = function($scope, apiPromise, cb) {
        return apiPromise.then(function(resp) {
            $scope.gitStatus = resp.data;
            $scope.gitStatus.remoteOrigin = resp.data.remotes.find(r => r.name === 'origin');
            $scope.gitStatus.hasRemoteOrigin = !$.isEmptyObject($scope.gitStatus.remoteOrigin);
            $scope.gitStatus.hasTrackingCount = !$.isEmptyObject($scope.gitStatus.trackingCount);

            if (cb) { cb() }
        },
        setErrorInScope.bind($scope));
    };

    svc.getBranches = function($scope, apiPromise) {
        apiPromise.then(function(resp) {
            $scope.gitBranches = resp.data.sort();
            $scope.gitBranchesFiltered = $scope.gitBranches;
        }, setErrorInScope.bind($scope));
    };

    svc.fetch = function($scope, apiPromise) {
        apiPromise.then(function(resp) {
            FutureProgressModal.show($scope, resp.data, "Fetching Git changes").then(function(result){
                if (result) {
                    Dialogs.infoMessagesDisplayOnly($scope, "Fetch result", result.messages, result.futureLog, true).then(function() {
                        // We're dismissing the first modal when it has succeeded.
                        if (result.commandSucceeded) {
                            DKUtils.reloadState();
                        }
                    }, null);
                }
            });
        }, setErrorInScope.bind($scope));
    };

    svc.editRemote = function($scope, saveCallback) {
        let url = "";
        let action = "Add";
        if ($scope.gitStatus.remoteOrigin && $scope.gitStatus.remoteOrigin.url) {
            url = $scope.gitStatus.remoteOrigin.url;
            action = "Edit";
        }
        Dialogs.prompt($scope, action + " remote origin", "Remote URL", url, { placeholder: "git@github.com:user/repo.git"}).then(function(newURL) {
            if (!newURL || newURL === url) {
                return;
            }
            saveCallback("origin", newURL);
        });
    };

    svc.removeRemote = function($scope, saveCallback) {
        Dialogs.confirm($scope, "Remove remote origin",
            "Are you sure you want to unlink this local repository from the remote repository?").then(function() {
            saveCallback("origin");
        });
    };

    svc.pull = function($scope, apiPromise) {
        apiPromise.then(function(resp) {
            FutureProgressModal.show($scope, resp.data, "Pulling Git changes").then(function(result){
                if (result) {
                    Dialogs.infoMessagesDisplayOnly($scope, "Pull result", result.messages, result.futureLog, true).then(function() {
                        // We're dismissing the first modal & reloading the state when it has succeeded
                        if (result.commandSucceeded) {
                            DKUtils.reloadState();
                        }
                    }, null);
                }
            });
        }, setErrorInScope.bind($scope));
    };

    svc.push = function($scope, apiPromise) {
        apiPromise.then(function(resp) {
            FutureProgressModal.show($scope, resp.data, "Pushing Git changes").then(function(result){
                if (result) {
                    Dialogs.infoMessagesDisplayOnly($scope, "Push result", result.messages, result.futureLog, true).then(function() {
                        // We're dismissing the first modal when it has succeeded.
                        if (result.commandSucceeded) {
                            $scope.getGitFullStatus();
                        }
                    }, null);
                }
            });
        }, setErrorInScope.bind($scope));
    };

    svc.switchToBranch = function($scope, apiPromise) {
        apiPromise.then(function() {
            $state.reload();
        }, setErrorInScope.bind($scope));
    };

    svc.deleteBranches = function($scope, callback) {
        CreateModalFromTemplate("/templates/git/delete-branches-modal.html", $scope, null, function (newScope) {
            newScope.selectedGitBranches = [];
            newScope.deleteOptions = { remoteDelete: false, forceDelete : false };
            newScope.deleteBranches = function () {
                callback(newScope, newScope.selectedGitBranches, newScope.deleteOptions);
            };
        });
    };

    return svc;
})

})();

(function(){
'use strict';

var app = angular.module('dataiku.bundles.common',[]);

app.directive("bundleGitLog", function() {
    return {
        templateUrl : "/templates/bundles/common/bundle-git-log.html",
        scope : {
            changelog : '=',
            noCommitDiff: '=?'
        },
        link : function($scope, element, attrs) {
            var hasMore = true;

            $scope.showMore = function() {
                if (hasMore) {
                    $scope.logEntries = $scope.changelog.logEntries.slice(0, $scope.logEntries.length + 50);
                    hasMore = $scope.logEntries.length < $scope.changelog.logEntries.length;
                }
            };

            $scope.logEntries = $scope.changelog.logEntries.slice(0, 50);
        }
    }
});

app.directive("bundleGitDiff", function(DiffFormatter) {
    return {
        templateUrl : "/templates/bundles/common/bundle-git-diff.html",
        scope : {
            changelog : '='
        }
    }
});

app.directive("bundleConfigContent", function(FeatureFlagsService) {
    return {
        templateUrl : "/templates/bundles/common/bundle-config-content.html",
        scope : {
            configContent : '='
        },
        link : function($scope, element, attrs) {
            $scope.featureFlagEnabled = FeatureFlagsService.featureFlagEnabled;
        }
    }
});

app.directive("bundleNonEditableContent", function(FeatureFlagsService) {
    return {
        templateUrl : "/templates/bundles/common/non-editable-bundle-content.html",
        scope : {
            contentSummary : '='
        },
        link : function($scope, element, attrs) {
            $scope.featureFlagEnabled = FeatureFlagsService.featureFlagEnabled;
        }
    }
});

app.service("DiffFormatter", function($filter){
    var DiffFormatter = {
        formatChange : function(fileChange) {
            var html = '<div class="diff-file-change">';
            fileChange.c.forEach(function(line, idx){
                var s = fileChange.s[idx];
                // var escaped = $("<div>").text(line).html(); // jQuery version
                var escaped = $filter('escapeHtml')(line); // DSS version
                html += '<div class="l ' + s + '">';
                html += '<span class="n" value="' + idx + '"></span>';
                html += '<span class="c" value="' + escaped[0] + '">' + escaped.substring(1) + '</span>';
                html += '</div>';
            });
            return html;
        }
    }
    return DiffFormatter;
})

})();

(function() {
'use strict';

const app = angular.module('dataiku.bundles.design', []);


app.controller("DesignBundleDetailsModalController", function($scope, $stateParams, Assert, DataikuAPI, ProgressStackMessageBuilder, FutureProgressModal) {
    $scope.uiState = {
        activeTab: "content"
    };

    function fetch() {
        Assert.inScope($scope, 'bundleId');
        DataikuAPI.projects.design.getBundleDetails($stateParams.projectKey, $scope.bundleId).success(function(data) {
            $scope.bundleDetails = data;

        }).error(setErrorInScope.bind($scope))
    }

    $scope.$watch("bundleId", function(nv, ov) {
        if (!nv) return;
        fetch();
    });
});


app.controller("DesignBundlesListController", function($scope, $controller, $stateParams, DataikuAPI, Dialogs, $state,
    $q, TopNav, Fn, CreateModalFromTemplate, ProgressStackMessageBuilder, FutureProgressModal, Assert) {
    $controller('_TaggableObjectsListPageCommon', {$scope: $scope});

    TopNav.setLocation(TopNav.TOP_MORE, "bundlesdesign", TopNav.TABS_NONE, null);
    TopNav.setNoItem();

    function exportedOn(bundle) { return ((bundle.exportManifest || {}).exportUserInfo || {}).exportedOn; }

    $scope.noTags = true;
    $scope.noWatch = true;
    $scope.noStar = true;
    $scope.sortBy = [
        { value: 'exportManifest.exportUserInfo.exportedOn', label: 'Date' },
        { value: 'bundleId', label: 'Name' },
    ];
    $scope.sortCookieKey = 'designbundles';
    $scope.selection = $.extend({
        filterQuery: {
            q: '',
        },
        filterParams: {userQueryTargets: "bundleId"},
        orderQuery: 'exportManifest.exportUserInfo.exportedOn',
        orderReversed: false,
    }, $scope.selection || {});
    $scope.noTags = true;

    $scope.maxItems = 20;

    $scope.list = function() {
        DataikuAPI.projects.design.listBundles($stateParams.projectKey).success(function(data) {
            $scope.listItems = data.bundles;
            $scope.$broadcast('clearMultiSelect');

            $scope.listItems.forEach(function(x) {
                if (x.futureItem && x.futureItem.lastResponse && x.futureItem.lastResponse.progress) {
                    // not ProgressStackMessageBuilder.build(...), so pass the states instead of the progress
                    x.progressMsg = ProgressStackMessageBuilder.buildFull(x.futureItem.lastResponse.progress.states);
                }
            });
        }).error(setErrorInScope.bind($scope));
    };

    $scope.list();

    if ($stateParams.showProgressModalFor) {
        FutureProgressModal.showPeekOnlyIfRunning($scope,
                    $stateParams.showProgressModalFor, "Exporting bundle ...").then($scope.list);
    }

    // /* Specific actions */
    $scope.goToItem = function(data) {
        data.state === "BUILT" && $scope.showBundleDetails(data);
    };

    $scope.showBundleDetails = function(data) {
        CreateModalFromTemplate("/templates/bundles/design/details-modal.html", $scope, null, function(modalScope) {
            modalScope.bundleId = data.bundleId;
            modalScope.$apply();
        });
    };

    $scope.downloadBundleArchive = function(bundle) {
        downloadURL(DataikuAPI.projects.design.getBundleDownloadURL($stateParams.projectKey, bundle.bundleId));
    };

    $scope.publishOnDeployer = function(bundle) {
        if ($scope.appConfig.deployerClientEnabled) {
            CreateModalFromTemplate("/templates/bundles/design/publish-on-deployer-modal.html", $scope, "PublishBundleOnDeployerModalController", function(newScope) {
                newScope.uploadParams = {bundleId: bundle.bundleId};

                newScope.refreshBundle = function(bundleId, publishedBundleState) {
                    const latestBundle = $scope.listItems.find(item => item.bundleId === bundleId);
                    latestBundle.publishedBundleState = publishedBundleState;
                }
            });
        }
    };

    $scope.setBundleExporterSettings = function() {
        CreateModalFromTemplate("/templates/bundles/design/exporter-settings-modal.html", $scope);
    };

    $scope.startRevert = function(bundleId) {
        DataikuAPI.projects.design.checkBundleReversion($stateParams.projectKey, bundleId).success(function(data) {
            CreateModalFromTemplate("/templates/bundles/design/reversion-check-result.html", $scope, null, function(modalScope) {
                modalScope.checkResult = data;
                modalScope.doRevert = function() {
                    Assert.inScope(modalScope, 'checkResult');
                    DataikuAPI.projects.design.revertBundle($stateParams.projectKey, modalScope.checkResult.bundleId, modalScope.importOptions).success(function(data) {
                        modalScope.dismiss();

                        FutureProgressModal.show($scope, data, "Activating bundle").then(function(activateResult) {
                            if (activateResult.anyMessage) {
                                Dialogs.infoMessagesDisplayOnly($scope, "Activation report", activateResult);
                            }

                            $scope.refreshProjectData();
                        });

                    }).error(setErrorInScope.bind(modalScope));
                }
            })
        }).error(setErrorInScope.bind($scope));
    };

    $scope.deleteBundle = function(bundle) {
        Dialogs.confirmSimple($scope, "Delete bundle <strong>" + bundle.bundleId +"</strong>?").then(function() {
            DataikuAPI.projects.design.deleteBundle($stateParams.projectKey, bundle.bundleId)
                .success($scope.list.bind(null))
                .error(setErrorInScope.bind($scope));
        });
    };

    $scope.deleteSelected = function() {
        if ($scope.selection.none) {
            return;
        } else if ($scope.selection.single) {
            $scope.deleteBundle($scope.selection.selectedObject);
        } else {
            Dialogs.confirm($scope, "Confirm deletion", "Are you sure you want to delete the selected bundles? Only successfully created bundles will be deleted.").then(function() {
                $q.all($scope.selection.selectedObjects.filter(bundle => bundle.state === 'BUILT').map(Fn.prop('bundleId'))
                    .map(DataikuAPI.projects.design.deleteBundle.bind(null, $stateParams.projectKey))
                ).then($scope.list.bind(null), setErrorInScope.bind($scope));
            });
        }
    };
});

app.directive('bundlesDesignRightColumnSummary', function(){
    return {
        templateUrl :'/templates/bundles/design/right-column-summary.html'
    }
});

app.controller("PublishBundleOnDeployerModalController", function($scope, $stateParams, DataikuAPI, StringUtils, WT1) {
    $scope.publishedProjectKeys = [];

    $scope.step = "confirmPublish";

    let suggestedProjectKey;
    $scope.$watch('uploadParams.targetProject.createProjectMessage', function(nv, ov) {
        if (nv) {
            $scope.uploadParams.targetProject.id = suggestedProjectKey;
        }
    });

    DataikuAPI.projectdeployer.client.listPublishedProjects()
        .success(function(response) {
            $scope.publishedProjects = response.filter(projectStatus => projectStatus.canWrite).sort((a, b) => a.projectBasicInfo.name.localeCompare(b.projectBasicInfo.name));
            suggestedProjectKey = StringUtils.transmogrify($stateParams.projectKey,
                                                          $scope.publishedProjects.map(_ => _.projectBasicInfo.id),
                                                          (count, name) => `${name}_${count}`);
            $scope.publishedProjects.unshift({createProjectMessage: "Create a new project...", packages: [], projectBasicInfo: {id: suggestedProjectKey}});
            $scope.publishedProjectKeys = $scope.publishedProjects.map(function(projectStatus) {
                if (projectStatus.createProjectMessage || (projectStatus.projectBasicInfo.id === projectStatus.projectBasicInfo.name)) return "";
                return projectStatus.projectBasicInfo.id;
            });
            $scope.uploadParams.targetProject = $scope.publishedProjects.find(project => project.projectBasicInfo.id === $stateParams.projectKey);
            if (!$scope.uploadParams.targetProject || $scope.uploadParams.targetProject.packages.find(bundle => bundle.id === $scope.uploadParams.bundleId)) {
                $scope.uploadParams.targetProject = $scope.publishedProjects[0];
            }
        })
        .error(setErrorInScope.bind($scope));

    $scope.ok = function() {
        $scope.step = "publishing";
        DataikuAPI.projects.design.publishToDeployer(
                $stateParams.projectKey,
                $scope.uploadParams.bundleId,
                $scope.uploadParams.targetProject.projectBasicInfo.id)
            .success(function(response) {
                $scope.step = "published";
                $scope.refreshBundle($scope.uploadParams.bundleId, response);
                WT1.event('project-deployer-publish-to-deployer');
            })
            .error(setErrorInScope.bind($scope));
    };
});

app.directive("bundleContentEditor", function(Collections, DataikuAPI, $stateParams, FeatureFlagsService) {
    return {
        templateUrl: "/templates/bundles/design/bundle-content-editor.html",
        scope: {
            "exporterSettings": "="
        },
        link: function($scope) {
            $scope.featureFlagEnabled = FeatureFlagsService.featureFlagEnabled;
            function rebuildAvailableDatasets() {
                $scope.availableDatasets = $scope.rawHeaders.filter(function(x) {
                    return x.type != "JobsDB" && x.type != "StatsDB" && x.type != "Inline"
                }).map(function(dataset) {
                    return {
                        localProject : $stateParams.projectKey,
                        datasetType : dataset.type,
                        type : dataset.type,
                        usable: true,
                        smartName: dataset.name,
                        name : dataset.name
                    };
                });
                $scope.datasetsMap = Collections.indexByField($scope.availableDatasets, "name");
                // filter exported datasets to only have existing datasets
                $scope.exporterSettings.exportOptions.includedDatasetsData = $scope.exporterSettings.exportOptions.includedDatasetsData.filter(function(dataset) {
                    return dataset.name in $scope.datasetsMap;
                });
                $scope.exporterSettings.exportOptions.includedDatasetsData.forEach(function(dataset) {
                    $scope.datasetsMap[dataset.name].usable = false;
                });
            }

            DataikuAPI.datasets.listHeaders($stateParams.projectKey).success(function(data) {
                $scope.rawHeaders = data;
                rebuildAvailableDatasets();
            }).error(setErrorInScope.bind($scope));

            DataikuAPI.managedfolder.list($stateParams.projectKey).success(function(data) {
                $scope.availableManagedFolders = data.map(function(folder) {
                    return {
                        localProject : $stateParams.projectKey,
                        type : folder.type,
                        datasetType: "",
                        usable: true,
                        smartName: folder.id,
                        name : folder.name,
                        id: folder.id
                    };
                });
                $scope.foldersMap = Collections.indexByField($scope.availableManagedFolders, "id");
                $scope.exporterSettings.exportOptions.includedManagedFolders = $scope.exporterSettings.exportOptions.includedManagedFolders.filter(function(folder) {
                    return folder.id in $scope.foldersMap;
                });
                $scope.exporterSettings.exportOptions.includedManagedFolders.forEach(function(folder) {
                    $scope.foldersMap[folder.id].usable = false;
                });
            }).error(setErrorInScope.bind($scope));

            DataikuAPI.savedmodels.list($stateParams.projectKey).success(function(data) {
                $scope.availableSavedModels = data.map(function(model) {
                    return {
                        localProject : $stateParams.projectKey,
                        type : model.miniTask.taskType,
                        datasetType: "",
                        usable: true,
                        smartName: model.id,
                        name : model.name,
                        id: model.id,
                        model: model
                    };
                });
                $scope.modelsMap = Collections.indexByField($scope.availableSavedModels, "id");
                $scope.exporterSettings.exportOptions.includedSavedModels = $scope.exporterSettings.exportOptions.includedSavedModels.filter(function(model) {
                    return model.id in $scope.modelsMap;
                });
                $scope.exporterSettings.exportOptions.includedSavedModels.forEach(function(model) {
                   $scope.modelsMap[model.id].usable = false;
                });
            }).error(setErrorInScope.bind($scope));

            DataikuAPI.modelevaluationstores.list($stateParams.projectKey).success(function(data) {
                $scope.availableModelEvaluationStores = data.map(function(store) {
                    return {
                        localProject : $stateParams.projectKey,
                        type : "",
                        datasetType: "",
                        usable: true,
                        smartName: store.id,
                        name : store.name,
                        id: store.id,
                        store: store
                    };
                });
                $scope.storesMap = Collections.indexByField($scope.availableModelEvaluationStores, "id");
                $scope.exporterSettings.exportOptions.includedModelEvaluationStores = $scope.exporterSettings.exportOptions.includedModelEvaluationStores.filter(function(store) {
                    return store.id in $scope.storesMap;
                });
                $scope.exporterSettings.exportOptions.includedModelEvaluationStores.forEach(function(store) {
                   $scope.storesMap[store.id].usable = false;
                });
            }).error(setErrorInScope.bind($scope));

            $scope.addDataset = {};
            $scope.addSavedModel = {};
            $scope.addManagedFolder = {};
            $scope.addModelEvaluationStore = {};

            $scope.$watch("addDataset.dataset", function(nv) {
                if (nv) {
                    $scope.exporterSettings.exportOptions.includedDatasetsData.unshift($scope.datasetsMap[nv]);
                    rebuildAvailableDatasets();
                    $scope.datasetsMap[nv].usable = false;
                    $scope.addDataset.dataset = null;
                }
            });

            $scope.$watch("addManagedFolder.folder", function(nv) {
                if (nv) {
                    $scope.exporterSettings.exportOptions.includedManagedFolders.unshift($scope.foldersMap[nv]);
                    $scope.foldersMap[nv].usable = false;
                    $scope.addManagedFolder.folder = null;
                }
            });

            $scope.$watch("addSavedModel.model", function(nv) {
                if (nv) {
                    $scope.exporterSettings.exportOptions.includedSavedModels.unshift($scope.modelsMap[nv]);
                    $scope.modelsMap[nv].usable = false;
                    $scope.addSavedModel.model = null;
                }
            });
            
            $scope.$watch("addModelEvaluationStore.store", function(nv) {
                if (nv) {
                    $scope.exporterSettings.exportOptions.includedModelEvaluationStores.unshift($scope.storesMap[nv]);
                    $scope.storesMap[nv].usable = false;
                    $scope.addModelEvaluationStore.store = null;
                }
            });
        }
    }
});


app.controller("DesignBundleContentModalController", function($scope, DataikuAPI, $stateParams) {

    DataikuAPI.projects.design.getBundleExporterSettings($stateParams.projectKey).success(function(data) {
        $scope.exporterSettings = data;
    }).error(setErrorInScope.bind($scope));

    DataikuAPI.datasets.listHeaders($stateParams.projectKey).success(function(data) {
        $scope.availableDatasets = data.map(function(dataset) {
            return {
                localProject: $stateParams.projectKey,
                datasetType: dataset.type,
                type: dataset.type
            };
        });
    }).error(setErrorInScope.bind($scope));

    $scope.save = function() {
        DataikuAPI.projects.design.saveBundleExporterSettings($stateParams.projectKey,  $scope.exporterSettings).success(function(data) {
            $scope.dismiss();
        }).error(setErrorInScope.bind($scope));
    }
});


app.controller("DesignBundlesNewController", function($scope, $state, $stateParams, Assert, DataikuAPI, TopNav, Logger, Dialogs, $q, Fn, MonoFuture, Collections) {
    TopNav.setLocation(TopNav.TOP_HOME, "bundlesdesign", TopNav.TABS_NONE, null);
    TopNav.setNoItem();

    Assert.trueish($stateParams.projectKey, "Not in a project");

    $scope.newBundle = {};

    $scope.createBundle = function() {
        DataikuAPI.projects.design.createBundle($stateParams.projectKey, $scope.newBundle.bundleId, $scope.preparationResult).success(function(data) {
            $state.go("projects.project.bundlesdesign.list", {
                showProgressModalFor : data.jobId
            });
        }).error(setErrorInScope.bind($scope));
    };

    MonoFuture($scope).wrap(DataikuAPI.projects.design.prepareBundleCreation)($stateParams.projectKey).success(function(data) {
        $scope.preparationResult = data.result;
        $scope.preparingFuture = null;
    }).update(function(data) {
        $scope.preparingFuture = data;
    }).error(function (data, status, headers) {
        $scope.preparingFuture = null;
        setErrorInScope.bind($scope)(data, status, headers);
    });
});


app.controller("DesignBundleCheckResultModalController", function($scope, DiffFormatter) {
    $scope.importOptions = {
        meaningsToImport: {}
    };

    $scope.$watch('checkResult', function(nv) {
        if (!nv) return;
        nv.messages.forEach(function(message) {
            if (message.udmId) {
                $scope.hasUDMConflict = true;
                $scope.importOptions.meaningsToImport[message.udmId] = false;
                message.formattedDiff = DiffFormatter.formatChange(message.diff);
            }
        });
    });
});

})();

(function() {
'use strict';

const app = angular.module('dataiku.bundles.automation',[]);


app.controller("AutomationBundleDetailsModalController", function($scope, $stateParams, Assert, DataikuAPI) {
    $scope.uiState = {
        activeTab : "content"
    };

    // We don't have access to the original git on the automation node, and don't store a per-commit diff in the bundle's changelog.json
    $scope.noCommitDiff = true;

    function fetch() {
        Assert.inScope($scope, 'bundleId');
        DataikuAPI.projects.automation.getBundleDetails($stateParams.projectKey, $scope.bundleId).success(function(data) {
            $scope.bundleDetails = data;
        }).error(setErrorInScope.bind($scope))
    }

    $scope.$watch("bundleId", function(nv, ov) {
        if (!nv) return;
        fetch();
    });

    $scope.modalActivate = function() {
        Assert.inScope($scope, 'bundleId');
        $scope.startActivate($scope.bundleId);
        $scope.dismiss();
    };

    $scope.modalPreload = function() {
        Assert.inScope($scope, 'bundleId');
        $scope.preloadBundle($scope.bundleId);
        $scope.dismiss();
    };
});


app.controller("AutomationBundlesSettingsController", function($scope, $stateParams, Assert, DataikuAPI, $state, TopNav, ActivityIndicator, AutomationUtils) {
    TopNav.setLocation(TopNav.TOP_HOME, "bundlesautomation", TopNav.TABS_NONE, "settings");
    TopNav.setNoItem();

    $scope.uiState = {
        settingsPane: 'connections'
    };
    $scope.AutomationUtils = AutomationUtils;

    var savedSettings;
    $scope.dirtySettings = function() {
        return !angular.equals($scope.settings, savedSettings);
    };
    checkChangesBeforeLeaving($scope, $scope.dirtySettings);

    function load() {
        DataikuAPI.projects.automation.getBundleActivationSettingsExt($stateParams.projectKey).success(function(data) {
            $scope.settings = data.settings;
            $scope.availableConnections = data.availableConnections;
            $scope.usedByLastBundle = data.usedByLastBundle;
            savedSettings = angular.copy($scope.settings);
            updateConnectionsCoverage();
        }).error(setErrorInScope.bind($scope));
    }

    $scope.$watch("settings.remapping.connections", updateConnectionsCoverage, true);

    function updateConnectionsCoverage() {
        if(!$scope.usedByLastBundle) {
            return;
        }
        $scope.typeAheadValues = [];
        $scope.usedByLastBundle.forEach(function(connection) {
            var mapped = $scope.settings.remapping.connections.filter(function(v) { return v.source === connection.name; });
            var original = $scope.availableConnections.filter(function(v) { return v.name === connection.name; });
            if (mapped.length) {
                connection.mapsTo = $scope.availableConnections.filter(function(v) { return v.name === mapped[0].target; })[0];
                connection.clickable = false;
            } else if (original.length) {
                connection.mapsTo = original[0];
                connection.clickable = true;
                $scope.typeAheadValues.push(connection.name);
            } else {
                connection.mapsTo = null;
                connection.clickable = true;
                $scope.typeAheadValues.push(connection.name);
            }
        });
    }

    $scope.addConnectionRemapping = function(name) {
        Assert.inScope($scope, 'settings');
        $scope.settings.remapping.connections.push({
            source: name,
            target: null
        });
    };

    $scope.save = function() {
        DataikuAPI.projects.automation.saveBundleActivationSettings($stateParams.projectKey, $scope.settings).success(function(data) {
            ActivityIndicator.success("Saved");
            savedSettings = angular.copy($scope.settings);
        }).error(setErrorInScope.bind($scope));
    };

    load();
});


app.controller("AutomationBundlesListController", function($scope, $controller, $stateParams, DataikuAPI, Dialogs, $state, $q, TopNav, Fn, CreateModalFromTemplate, FutureProgressModal) {
    $controller('_TaggableObjectsListPageCommon', {$scope: $scope});

    TopNav.setLocation(TopNav.TOP_HOME, "bundlesautomation", TopNav.TABS_NONE, "list");
    TopNav.setNoItem();

    $scope.noTags = true;
    $scope.noWatch = true;
    $scope.noStar = true;
    $scope.sortBy = [
        {label: 'Imported On', value: 'importState.importedOn'},
        {label: 'Exported On', value: 'exportManifest.exportUserInfo.exportedOn'},
        {label: 'Name', value: 'bundleId'},
    ];
    $scope.sortCookieKey = 'bundlesautomation';
    $scope.selection = $.extend({
        filterQuery: {
            userQuery: '',
        },
        filterParams: {userQueryTargets: "bundleId"},
        orderQuery: 'importState.importedOn',
        orderReversed: false,
    }, $scope.selection || {});
    $scope.noTags = true;
    $scope.maxItems = 20;

    $scope.list = function() {
        DataikuAPI.projects.automation.listBundles($stateParams.projectKey).success(function(data) {
            $scope.listItems = data.bundles;
            $scope.$broadcast('clearMultiSelect');
        }).error(setErrorInScope.bind($scope));
    };

    $scope.list();

    $scope.goToItem = function(data) {
        $scope.showBundleDetails(data);
    };

    $scope.showBundleDetails = function(data) {
        CreateModalFromTemplate("/templates/bundles/automation/details-modal.html", $scope, null, function(modalScope) {
            modalScope.bundleId = data.bundleId;
            modalScope.$apply();
        });
    };

    $scope.importBundle = function() {
        CreateModalFromTemplate("/templates/bundles/automation/import-bundle-modal.html", $scope);
    };

    $scope.startActivate = function(bundleId) {
        DataikuAPI.projects.automation.checkBundleActivation($stateParams.projectKey, bundleId).success(function(data) {
            CreateModalFromTemplate("/templates/bundles/automation/activation-check-result.html", $scope, null, function(modalScope) {
                modalScope.checkResult = data;
            })
        }).error(setErrorInScope.bind($scope));
    };

    $scope.preloadBundle = function(bundleId) {
        DataikuAPI.projects.automation.preloadBundle($stateParams.projectKey, bundleId).success(function(data) {
            FutureProgressModal.show($scope, data, "Preloading bundle").then(function(preloadResult) {
                if (preloadResult.anyMessage) {
                    Dialogs.infoMessagesDisplayOnly($scope, "Preload report", preloadResult, preloadResult.futureLog);
                }
                $scope.list() // TODO do we really need this?
                $scope.refreshProjectData();
            });
        }).error(setErrorInScope.bind($scope));
    };

    $scope.deleteBundle = function(bundle) {
        Dialogs.confirmSimple($scope, "Delete bundle <strong>" + bundle.bundleId +"</strong>?").then(function() {
            DataikuAPI.projects.automation.deleteBundle($stateParams.projectKey, bundle.bundleId)
                .success($scope.list.bind(null))
                .error(setErrorInScope.bind($scope));
        });
    };

    $scope.deleteSelected = function() {
        if ($scope.selection.none) {
            return;
        } else if ($scope.selection.single) {
            $scope.deleteBundle($scope.selection.selectedObject);
        } else {
            Dialogs.confirm($scope, "Confirm deletion", "Are you sure you want to delete the selected bundles?").then(function() {
                $q.all($scope.selection.selectedObjects.map(Fn.prop('bundleId'))
                    .map(DataikuAPI.projects.automation.deleteBundle.bind(null, $stateParams.projectKey))
                ).then($scope.list.bind(null), setErrorInScope.bind($scope));
            });
        }
    };
});


app.controller("AutomationBundleNewProjectModalController", function($scope, $stateParams, $state, Assert, DataikuAPI, ProjectFolderContext) {
    $scope.newProject = {}

    $scope.create = function() {
        Assert.trueish($scope.newProject.file, "No file for new project");
        DataikuAPI.projects.automation.createWithInitialBundle($scope.newProject.file, ProjectFolderContext.getCurrentProjectFolderId()).then(function(data) {
            $scope.dismiss();
            $state.go("projects.project.home.regular", {projectKey: JSON.parse(data).projectKey});
        }, function(payload) {
            setErrorInScope.bind($scope)(JSON.parse(payload.response), payload.status, function(h) {return payload.getResponseHeader(h)});
        });
    };
});


app.controller("AutomationBundleImportBundleModalController", function($scope, $stateParams, Assert, DataikuAPI) {
    $scope.newBundleImport = {}

    $scope.newBundle = {}

    $scope.import = function() {
        Assert.trueish($scope.newBundle.file, "No file for new bundle");
        DataikuAPI.projects.automation.importBundle($stateParams.projectKey, $scope.newBundle.file).then(function(data) {
            $scope.$parent.$parent.list();
            $scope.dismiss();
        }, function(payload) {
            setErrorInScope.bind($scope)(JSON.parse(payload.response), payload.status, function(h) {return payload.getResponseHeader(h)});
        });
    }
});


app.controller("AutomationBundleCheckResultModalController", function($scope, DataikuAPI, $state, $stateParams, Assert, FutureProgressModal, Dialogs, DKUConstants) {
    $scope.doActivate = function() {
        Assert.inScope($scope, 'checkResult');
        DataikuAPI.projects.automation.activateBundle($stateParams.projectKey, $scope.checkResult.bundleId).success(function(data) {
            var parentScope = $scope.$parent.$parent; // Ugly

            $scope.dismiss();

            FutureProgressModal.show(parentScope, data, "Activating bundle").then(function(activateResult) {
                if (activateResult.anyMessage) {
                    Dialogs.infoMessagesDisplayOnly(parentScope, "Activation report", activateResult);
                }
                parentScope.list() // TODO do we really need this?
                parentScope.refreshProjectData();
            });
        }).error(setErrorInScope.bind($scope));
    };
});

})();
(function(){
'use strict';


var app = angular.module('dataiku.runnables',[]);

app.controller("RunnableCoreController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav) {

});

app.controller("RunnablesListController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate, ProgressStackMessageBuilder, WT1, Dialogs, $q, $timeout, FutureWatcher) {
    TopNav.setLocation(TopNav.TOP_MORE, "runnables", TopNav.TABS_RUNNABLE, null);
    TopNav.setNoItem();

    $scope.runnables = [];
    const refreshList = function () {
        DataikuAPI.runnables.listAccessible($stateParams.projectKey).success(function(data) {
            const runnables = data.runnables
                .filter(runnable => {
                    return !runnable.desc.macroRoles
                        || runnable.desc.macroRoles.length === 0
                        || runnable.desc.macroRoles.some(macroRole => macroRole.type === 'PROJECT_MACROS');
                })
                .sort((first, second) => {
                    const firstName = first.desc.meta.label || first.id;
                    const secondName = second.desc.meta.label || second.id;
                    return firstName.localeCompare(secondName);
                })
                .reduce((map, obj) => {
                    const cat = (obj.desc && obj.desc.meta && obj.desc.meta.category) || 'Misc';
                    (map[cat] = map[cat] || []).push(obj);
                    return map;
                }, {});

            let miscRunnables  = [];
            let categorizedRunnables = [];

            $.each(runnables, function (category, runnables) {
                if (category === 'Misc') {
                    miscRunnables = runnables;
                } else {
                    categorizedRunnables.push({
                        label: category,
                        items: runnables
                    });
                }
            });

            categorizedRunnables.sort((a, b) => a.label.localeCompare(b.label));

            $scope.miscRunnables = miscRunnables;
            $scope.categorizedRunnables = categorizedRunnables;
            initializeFilteredCategories();
        }).error(setErrorInScope.bind($scope));
    };
    refreshList();

    function initializeFilteredCategories () {
        $scope.filteredCategories = ($scope.categorizedRunnables || []).map(category => ({
            label: category.label,
            enabled: true,
            macros: category.items.map(macro => ({macro: macro, enabled: true}))
        }));
    }

    $scope.hasEnabledMacros = function (category) {
        return category.macros.some(macro => macro.enabled);
    };

    $scope.anyMacroAvailable = function () {
        return ($scope.filteredCategories || [])
            .filter(category => category.enabled)
            .some(category => $scope.hasEnabledMacros(category));
    };

    $scope.noCategoryFiltered = function () {
        return ($scope.filteredCategories || []).every(category => category.enabled);
    };

    $scope.resetFilter = function() {
        $scope.filteredCategories.forEach(category => category.enabled = true);
    };

    $scope.selectCategory = function (category) {
        // Unselect all categories if it is the first click (ie. all categories are enabled)
        if ($scope.filteredCategories.every(category => category.enabled)) {
            $scope.filteredCategories.forEach(category => category.enabled = false);
        }

        category.enabled = !category.enabled;

        // If the click unselects the last category than we reset the filter
        if ($scope.filteredCategories.every(category => !category.enabled)) {
            $scope.resetFilter();
        }
    };

    function searchMacros(oldValue, newValue) {
        if (oldValue === newValue || ! $scope.filteredCategories) return;
        const searchText = $scope.searchQuery.toLowerCase();
        for (let category of $scope.filteredCategories) {
            for (let macroWrapper of category.macros) {
                macroWrapper.enabled =
                    macroWrapper.macro.desc.meta.label.toLowerCase().includes(searchText)
                    || macroWrapper.macro.desc.meta.description.toLowerCase().includes(searchText);
            }
        }
    }

    $scope.$watch("searchQuery", searchMacros);

    $scope.$watch("appConfig.customRunnables", refreshList);

});

app.controller("RunnableController", function ($scope, $rootScope, $controller, $stateParams, $anchorScroll, Assert, Fn, DataikuAPI, $state, TopNav,
                                               PluginConfigUtils, CreateModalFromTemplate, ProgressStackMessageBuilder, ProjectFolderContext,
                                               WT1, Dialogs, $q, $timeout, FutureWatcher, LocalStorage) {
    let localStorageKey, localStorageAdminKey;

    function fillRoleTarget() {
        if (angular.isDefined($scope.targetKey) && angular.isDefined($scope.targetValue)) {
            if (angular.isArray($scope.targetKey) && angular.isArray($scope.targetValue)) {
                for (let i = 0; i < $scope.targetValue.length; i++) {
                    $scope.runnable.$config[$scope.targetKey[i]] = $scope.targetValue[i];
                }
            } else {
                $scope.runnable.$config[$scope.targetKey] = $scope.targetValue;
            }
        }
    }

    function init() {
        $scope.runnable.$config = $scope.runnable.$config || {};
        $scope.runnable.$adminConfig = $scope.runnable.$adminConfig || {};
        $scope.desc = $scope.runnable.desc;

        PluginConfigUtils.setDefaultValues($scope.desc.params, $scope.runnable.$config);
        PluginConfigUtils.setDefaultValues($scope.desc.adminParams, $scope.runnable.$adminConfig);

        /* In addition to default values, set properly the columns stuff */
        $scope.desc.params.forEach(function(param) {
            if ($scope.runnable.$config[param.name] === undefined && param.type === "DATASETS") {
                // the dku-list-typeahead expects something not null
                $scope.runnable.$config[param.name] = [];
            }
        });

        $scope.pluginDesc = $rootScope.appConfig.loadedPlugins.filter(function (x) {
            return x.id == $scope.runnable.ownerPluginId;
        })[0];

        $scope.icon = $scope.runnable.desc.meta.icon || ($scope.pluginDesc.meta ? $scope.pluginDesc.meta.icon : 'icon-gears');

        const hasRegularParams = $scope.desc.params && $scope.desc.params.length > 0;
        const hasAdminParams = $scope.desc.adminParams && $scope.desc.adminParams.length > 0;
        const hasCustomForm = $scope.desc.paramsTemplate && $scope.desc.paramsTemplate.length > 0;
        $scope.hasSettings = $scope.pluginDesc.hasSettings || hasRegularParams || hasAdminParams || hasCustomForm;

        $scope.runOutput = {};

        localStorageKey = $stateParams.projectKey + "." + $scope.runnable.runnableType;
        localStorageAdminKey = localStorageKey + ".admin";

        const old = LocalStorage.get(localStorageKey);
        if (old) {
            angular.extend($scope.runnable.$config, old);
        }

        const oldAdmin = LocalStorage.get(localStorageAdminKey);
        if (oldAdmin) {
            angular.extend($scope.runnable.$adminConfig, oldAdmin);
        }

        fillRoleTarget();
    }

    $scope.$watch("runnable", Fn.doIfNv(init));

    $scope.resetSettings = function () {
        $scope.runnable.$config = {};
        $scope.runnable.$adminConfig = {};
        PluginConfigUtils.setDefaultValues($scope.desc.params, $scope.runnable.$config);
        PluginConfigUtils.setDefaultValues($scope.desc.adminParams, $scope.runnable.$adminConfig);

        if ($scope.runnable.$config) {
            LocalStorage.set(localStorageKey, $scope.runnable.$config);
        }
        if ($scope.runnable.$adminConfig) {
            LocalStorage.set(localStorageAdminKey, $scope.runnable.$adminConfig);
        }
        fillRoleTarget();
    };

    $scope.closing = false;
    $scope.canCloseModal = function() {
        if (!$scope.closing && $scope.runState && $scope.runState.running) {
            $scope.closing = true;
            const modalScope = $scope.$new();
            modalScope.canCloseModal = true; // otherwise inherits the method from the present scope
            CreateModalFromTemplate('/templates/macros/exit-runnable-modal.html', modalScope, null, function(newScope) {
                newScope.abortMacro = function() {
                	if ($scope.runState && $scope.runState.running) {
                		// no need to abort if macro is already done
                		$scope.abort($scope.runnable);
                	}
                	newScope.dismiss();
                	$scope.dismiss();
                };
                newScope.keepMacro = function() {
                	newScope.dismiss();
                	$scope.dismiss();
                };
                newScope.cancelClose = function() {
                    $scope.closing = false;
                	newScope.dismiss();
                };
            });
            return false;
        } else {
            return true;
        }
    };

    $scope.$on('runnable-run', function (event, data) {
        if (angular.equals(data, $scope.runnable) && $scope.runnable.$config) {
            LocalStorage.set(localStorageKey, $scope.runnable.$config);
        }
        if (angular.equals(data, $scope.runnable) && $scope.runnable.$adminConfig) {
            LocalStorage.set(localStorageAdminKey, $scope.runnable.$adminConfig);
        }
    });

    $scope.runState = { running: false };

    $scope.run = function(runnable) {
        $scope.$emit('runnable-run', $scope.runnable); // to trigger the config save
        WT1.event("runnable-run", {type : runnable.runnableType});
        $scope.runState.running = true;
        var runCall;
        if ($scope.mode == "PROJECT_CREATION") {
            runCall = DataikuAPI.runnables.projectCreationRun(runnable.runnableType, runnable.$config, ProjectFolderContext.getCurrentProjectFolderId());
        } else if ($scope.insight) {
            runCall = DataikuAPI.runnables.insightRun($stateParams.projectKey, $scope.insight.id);
        } else if ($scope.cluster) {
            runCall = DataikuAPI.runnables.clusterRun($stateParams.clusterId, runnable.runnableType, runnable.$config, runnable.$adminConfig);
        } else {
            runCall = DataikuAPI.runnables.manualRun($stateParams.projectKey, runnable.runnableType, runnable.$config, runnable.$adminConfig);
        }
        runCall.success(function(initialResponse) {
            $scope.runState.jobId = initialResponse.jobId;
            $scope.runOutput.resultType = null;
            $scope.runOutput.resultData = null;
            $scope.runOutput.error = null;
            $scope.runOutput.failure = null;
            $scope.runOutput.logTail = null;
            var fillResultFields = function(data) {

                $scope.runOutput.aborted = data.aborted;
                $scope.runOutput.resultType = data.result.type;
                $scope.runOutput.resultData = data.result.data;
                $scope.runOutput.resultLabel = data.result.label;
                $scope.runOutput.error = data.result.error;
                $scope.runOutput.failure = data.result.failure;
                $scope.runOutput.logTail = data.result.logTail;
                $scope.runState.percentage = null;
                $scope.runState.stateLabels = null;
                $scope.runOutput.showResult = true;
                // prepare it for api-error-alert
                if ($scope.runOutput.error) {
                    $scope.runOutput.error.errorType = $scope.runOutput.error.clazz;
                }
                if ($scope.runOutput.failure) {
                    $scope.runOutput.failure.errorType = $scope.runOutput.failure.clazz;
                }

                if ($scope.mode == "PROJECT_CREATION" && data.result.data) {
                    const dataObj = data.result.data.object;
                    $scope.dismiss();
                    $state.go("projects.project.home.regular", {projectKey: dataObj.projectKey})
                }

            };
            if (initialResponse.hasResult) {
                $scope.runState.running = false;
                fillResultFields(initialResponse);
            } else {
                FutureWatcher.watchJobId(initialResponse.jobId)
                    .success(function(data) {
                        $scope.runState.running = false;
                        fillResultFields(data);
                    }).update(function(data){
                    $scope.runState.percentage  = ProgressStackMessageBuilder.getPercentage(data.progress);
                    $scope.runState.stateLabels = ProgressStackMessageBuilder.build(data.progress, true);
                }).error(function(data, status, headers) {
                    $scope.runState.running = false;
                    setErrorInScope.bind($scope)(data, status, headers);
                }).finally(function() {
                    if ($scope.mode != "PROJECT_CREATION") {
                        $timeout(() => $('.runnable-modal .modal-body div.oa').scrollTop($('.runnable-modal .modal-body div.oa').scrollTop() + $('#runnable-output').position().top - 20), 100);
                    }
                });
            }
        }).error(function(a, b, c) {
            $scope.runState.running = false;
            $scope.runOutput.error = a;

        }).finally(function() {
            $timeout(() => $('.runnable-modal .modal-body div.oa').scrollTop($('.runnable-modal .modal-body div.oa').scrollTop() + $('#runnable-output').position().top - 20), 100);
        });
    };

    $scope.abort = function(runnable) {
        DataikuAPI.futures.abort($scope.runState.jobId).success(function(data) {
            WT1.event("runnable-abort", {type : runnable.runnableType});
        }).error(setErrorInScope.bind($scope));
    };
});

app.directive("runnableRunButton", function($stateParams, DataikuAPI, FutureWatcher, ProgressStackMessageBuilder, WT1){
    return {
        scope : {
            runnable : '=',
            insight : '=',
            cluster : '=',
            runOutput : '='
        },
        templateUrl : '/templates/scenarios/runnable-run-button.html',
        replace : true,
        link : function($scope, element, attrs) {
            $scope.runState = {};
            $scope.run = function(runnable) {
                $scope.$emit('runnable-run', $scope.runnable); // to trigger the config save
                WT1.event("runnable-run", {type : runnable.runnableType});
                $scope.runState.running = true;
                var runCall;
                if ($scope.insight) {
                    runCall = DataikuAPI.runnables.insightRun($stateParams.projectKey, $scope.insight.id);
                } else if ($scope.cluster) {
                    runCall = DataikuAPI.runnables.clusterRun($stateParams.cluster.id, runnable.runnableType, runnable.$config, runnable.$adminConfig);
                } else {
                    runCall = DataikuAPI.runnables.manualRun($stateParams.projectKey, runnable.runnableType, runnable.$config, runnable.$adminConfig);
                }
                runCall.success(function(initialResponse) {
                    $scope.runState.jobId = initialResponse.jobId;
                    $scope.runOutput.resultType = null;
                    $scope.runOutput.resultData = null;
                    $scope.runOutput.error = null;
                    $scope.runOutput.failure = null;
                    $scope.runOutput.logTail = null;
                    var fillResultFields = function(data) {
                        $scope.runOutput.aborted = data.aborted;
                        $scope.runOutput.resultType = data.result.type;
                        $scope.runOutput.resultData = data.result.data;
                        $scope.runOutput.resultLabel = data.result.label;
                        $scope.runOutput.error = data.result.error;
                        $scope.runOutput.failure = data.result.failure;
                        $scope.runOutput.logTail = data.result.logTail;
                        $scope.runState.percentage = null;
                        $scope.runState.stateLabels = null;
                        $scope.runOutput.showResult = true;
                        // prepare it for api-error-alert
                        if ($scope.runOutput.error) {
                            $scope.runOutput.error.errorType = $scope.runOutput.error.clazz;
                        }
                        if ($scope.runOutput.failure) {
                            $scope.runOutput.failure.errorType = $scope.runOutput.failure.clazz;
                        }
                    };
                    if (initialResponse.hasResult) {
                        $scope.runState.running = false;
                        fillResultFields(initialResponse);
                    } else {
                        FutureWatcher.watchJobId(initialResponse.jobId)
                            .success(function(data) {
                                $scope.runState.running = false;
                                fillResultFields(data);
                            }).update(function(data){
                            $scope.runState.percentage  = ProgressStackMessageBuilder.getPercentage(data.progress);
                            $scope.runState.stateLabels = ProgressStackMessageBuilder.build(data.progress, true);
                        }).error(function(data, status, headers) {
                            $scope.runState.running = false;
                            setErrorInScope.bind($scope)(data, status, headers);
                        });
                    }
                }).error(function(a, b, c) {
                    $scope.runState.running = false;
                    $scope.runOutput.error = a;
                    setErrorInScope.bind($scope)(a,b,c);
                });
            };

            $scope.abort = function(runnable) {
                DataikuAPI.futures.abort($scope.runState.jobId).success(function(data) {
                    WT1.event("runnable-abort", {type : runnable.runnableType});
                }).error(setErrorInScope.bind($scope));
            };
        }
    };
});

app.directive("runnableResult", function($stateParams, DataikuAPI, PluginConfigUtils, $rootScope, $timeout,ExportUtils){
    return {
        scope : {
            resultData : '=',
            resultType : '=',
            resultLabel : '=',
            runnable : '=',
            scenarioRun : '=',
            stepRun : '='
        },
        templateUrl : '/templates/scenarios/runnable-result.html',
        replace : true,
        link : function($scope, element, attrs) {
            // 2 possible contexts : in a runnable (then runnable != null) or in a stepRun (then scenarioRun and stepRun != null)
            $scope.loaded = null;
            $scope.previewedItem = null;
            var update = function() {
                if ($scope.resultType == 'FOLDER_FILE') {
                    $scope.odb = {id:$scope.resultData.folderId};
                    $scope.skinState = {itemSkins:[]};
                    DataikuAPI.managedfolder.previewItem($stateParams.projectKey, $stateParams.projectKey, $scope.odb.id, $scope.resultData.itemPath).success(function(data){
                        $scope.previewedItem = data;
                    }).error(setErrorInScope.bind($scope));
                } else if ($scope.resultType == 'URL') {

                } else if ($scope.resultType == 'FILE') {
                    if ($scope.runnable != null) {
                        $scope.downloadUrl = DataikuAPI.runnables.getDownloadURL($stateParams.projectKey, $scope.runnable.runnableType, $scope.resultData, $stateParams.clusterId);
                    } else if ($scope.scenarioRun != null && $scope.stepRun != null) {
                        $scope.downloadUrl = DataikuAPI.scenarios.getDownloadURL($stateParams.projectKey, $scope.scenarioRun.scenario.id, $scope.scenarioRun.runId, $scope.stepRun.step.name, $scope.resultData);
                    }
                } else if ($scope.resultType == 'HTML') {
                    // if lighter than 1Ko, then it was inlined
                    if ($scope.resultData.type == 'INLINE_HTML') {
                        $scope.loaded = $scope.resultData.data;
                    } else {
                        if ($scope.runnable != null) {
                            DataikuAPI.runnables.loadKeptFile($stateParams.projectKey, $scope.runnable.runnableType, $scope.resultData, $stateParams.clusterId).success(function(data){
                                $scope.loaded = data[0]; // sent as json, so it's the 1st element in a list
                            }).error(setErrorInScope.bind($scope));
                        } else if ($scope.scenarioRun != null && $scope.stepRun != null) {
                            DataikuAPI.scenarios.loadKeptFile($stateParams.projectKey, $scope.scenarioRun.scenario.id, $scope.scenarioRun.runId, $scope.stepRun.step.name, $scope.resultData).success(function(data){
                                $scope.loaded = data[0]; // sent as json, so it's the 1st element in a list
                            }).error(setErrorInScope.bind($scope));
                        }
                    }
                } else if ($scope.resultType == "RESULT_TABLE") {
                    if ($scope.resultData.type == "INLINE_RESULT_TABLE") {
                        $scope.resultTable = $scope.resultData.table;
                    } else {
                        if ($scope.runnable != null) {
                            DataikuAPI.runnables.loadKeptFile($stateParams.projectKey, $scope.runnable.runnableType, $scope.resultData, $stateParams.clusterId).success(function(data){
                                $scope.resultTable = JSON.parse(data[0]); // sent as json, so it's the 1st element in a list
                            }).error(setErrorInScope.bind($scope));
                        } else if ($scope.scenarioRun != null && $scope.stepRun != null) {
                            DataikuAPI.scenarios.loadKeptFile($stateParams.projectKey, $scope.scenarioRun.scenario.id, $scope.scenarioRun.runId, $scope.stepRun.step.name, $scope.resultData).success(function(data){
                                $scope.resultTable = JSON.parse(data[0]); // sent as json, so it's the 1st element in a list
                            }).error(setErrorInScope.bind($scope));
                        }
                    }
                }
            };
            update();

            function downloadHTMLBlob(data) {
                var blob = new Blob([data], {type: "octet/stream"});
                var url = window.URL.createObjectURL(blob);

                var a = document.createElement("a");
                a.style.display = "none";
                document.body.appendChild(a);

                a.href = url;
                a.download = "report.html";
                a.click();

                //give Firefox time...
                setTimeout(function(){
                    window.URL.revokeObjectURL(url);
                }, 1000);
            }

            $scope.downloadHtml = function() {
                if ($scope.resultType == 'HTML') {
                    $timeout(function() {downloadHTMLBlob($scope.loaded);});
                }
            };
            function prepareColumnValueForExport(idx, field) {
                var type = $scope.resultTable.columns[idx].type;
                switch (type){
                    case 'LOCAL_DATASET_WITH_TYPE':
                    case 'FQ_DATASET_WITH_TYPE':
                        return field.split(':')[1];
                    case 'STRING_LIST':
                        return field.join(',');
                    default :
                        return field;
                }
            }
            function resultTableTypeToDSSType(c) {
                // Simplification
                return "string";
            }

            $scope.exportResultTable = function () {
                ExportUtils.exportUIData($scope, {
                    name : "Result of " + $scope.resultTable.name,
                    columns: $scope.resultTable.columns.map(function (c) {
                        var type = resultTableTypeToDSSType(c);
                        return {name:c.displayName, type:type}
                    }),
                    data : $scope.resultTable.records.map(function (r) {
                        return r.map(function (field, idx) {
                            return prepareColumnValueForExport(idx, field);
                        });
                    })

                }, "Export macro result");

            };

            $scope.downloadResultTableAsHTML = function(){
                var html = "<table>";
                html += "<tr>"
                $scope.resultTable.columns.forEach(function(col){
                    html += "<th>" + col.displayName + "</th>";
                });
                html += "</tr>"
                $scope.resultTable.records.forEach(function(rec, recIdx){
                    html += "<tr>";
                    rec.forEach(function(cell, cellIdx){
                        html += "<td>" + prepareColumnValueForExport(cellIdx,cell) + "</td>";
                    });
                    html += "</tr>";
                });
                html += "</table>"
                downloadHTMLBlob(html);
            }

            $scope.$watch("resultType", update);
            $scope.$watch("resultData", update);
        }
    };
});


})();

(function(){
'use strict';


var app = angular.module('dataiku.scenarios',[]);

var getPluginStepDisplayType = function($scope, step) {
    if (step.type && step.type.startsWith('pystep_')) {
        if ($scope.appConfig.customPythonPluginSteps) {
            var found = null;
            $scope.appConfig.customPythonPluginSteps.forEach(function(x) {
                if (x.stepType == step.type) {
                    found = x;
                }
            });
            if (found && found.desc && found.desc.meta) {
                return found.desc.meta.label || found.desc.id;
            }
        }
    }
    return step.type;
};

var processUnavailables = function (scenario, data) {
    if (data.unavailableSteps && data.unavailableSteps.length) {
        for (let step of scenario.params.steps) {
            step.unavailable = false;
            for (let unavailInfo of data.unavailableSteps) {
                if (unavailInfo.stepId === step.id) {
                    step.unavailable = true;
                    step.unavailableMessage = "Element " + unavailInfo.elementId
                        + " of type " + unavailInfo.objectType
                        + " from plugin " + unavailInfo.pluginId + " is not available.";
                    break;
                }
            }
        }
    }
    if (data.unavailableTriggerIds && data.unavailableTriggerIds.length) {
        for (let trigger of scenario.triggers) {
            trigger.unavailable = data.unavailableTriggerIds.includes(trigger.id);
        }
    }
}

var getStepDisplayType = (function($scope, step) { return this[step.type] || getPluginStepDisplayType($scope, step); }).bind({
    build_flowitem: "Build",
    check_dataset: "Run checks",
    check_consistency: "Check flow consistency",
    compute_metrics: "Compute metrics",
    sync_hive: "Synchronize Hive",
    update_from_hive: "Update from Hive",
    schema_propagation: "Schema propagation",
    reload_schema: "Reload schema",
    run_scenario: "Run scenario",
    runnable: "Execute macro",
    kill_scenario: "Kill scenario",
    create_dashboard_export: "Export dashboard",
    create_jupyter_export: "Export notebook",
    create_rmarkdown_report_export: "Export RMarkdown report",
    create_wiki_export: "Export wiki",
    create_saved_model_documentation_export: "Export saved model documentation",
    create_analysis_model_documentation_export: "Export analysis model documentation",
    restart_webapp: "Restart webapp",
    exec_sql: "Execute SQL",
    custom_python: "Custom Python",
    run_global_vars_update: "Run global variables update",
    set_project_vars: "Set project variables",
    set_global_vars: "Set global variables",
    define_vars: "Define variables",
    send_report: "Send message",
    clear_items: "Clear",
    invalidate_cache: "Invalidate cache",
    prepare_lambda_package: "Create API service version",
    prepare_bundle: "Create bundle",
    update_apideployer_deployment: "Update API deployment",
    update_projectdeployer_deployment: "Update Project deployment",
    set_up_cluster: "Create a cluster",
    tear_down_cluster: "Destroy a cluster",
    start_cluster: "Start a cluster",
    stop_cluster: "Stop a cluster",
    pull_git_refs: "Update Git references",
    refresh_chart_cache: "Refresh statistics & chart cache",
    start_continuous_activity: "Start continuous activity",
    stop_continuous_activity: "Stop continuous activity",
    compute_data_drift: "Compute data drift",
    retrieve_active_model_version_deployment: "Retrieve active version of deployed model",
    finally: "Cleanup"
});

var getPluginTriggerDisplayType = function($scope, trigger) {
    if (trigger.type && trigger.type.startsWith('pytrigger_')) {
        if ($scope.appConfig.customPythonPluginTriggers) {
            var found = null;
            $scope.appConfig.customPythonPluginTriggers.forEach(function(x) {
                if (x.triggerType == trigger.type) {
                    found = x;
                }
            });
            if (found && found.desc && found.desc.meta) {
                return found.desc.meta.label || found.desc.id;
            }
        }
    }
    return trigger.type;
};

var getTriggerDisplayType = (function($scope, trigger) {
    return this[trigger.type] || getPluginTriggerDisplayType($scope, trigger); }).bind({
        temporal: "Time-based",
        ds_modified: "Dataset modified",
        custom_python: "Custom trigger",
        sql_query: "SQL query change",
        follow_scenariorun: "Follow scenario"
    });

var getReportTargetItemDisplayName = (function(item, info) { return this[item.type](item, info) || item.type; }).bind({
    PROJECT: function(item){return "project " + item.projectKey;},
    DATASET: function(item){return "dataset " + item.datasetName + " in " + item.projectKey;},
    RECIPE: function(item){return "recipe " + item.recipeName + " in " + item.projectKey;},
    DATASET_PARTITION: function(item){return "dataset " + item.datasetName + " in " + item.projectKey + " (partition: " + item.partition + ")";},
    MANAGED_FOLDER: function(item, info){return "folder " + (info && info.name ? info.name : item.folderId) + " in " + item.projectKey;},
    MANAGED_FOLDER_PARTITION: function(item, info){return "folder " + (info && info.name ? info.name : item.folderId) + " in " + item.projectKey + " (partition: " + item.partition + ")";},
    MANAGED_FOLDER_FILE: function(item, info){return "file " + item.itemPath + " in folder " + (info && info.name ? info.name : item.folderId) + " in " + item.projectKey;},
    SAVED_MODEL: function(item, info){return "model " + (info && info.name ? info.name : item.modelId) + " in " + item.projectKey;},
    SAVED_MODEL_PARTITION: function(item, info){return "model " + (info && info.name ? info.name : item.modelId) + " in " + item.projectKey + " (partition: " + item.partition + ")";},
    SCENARIO: function(item){return "scenario " + (info && info.name ? info.name : item.scenarioId) + " in " + item.projectKey;},
    SCENARIO_TRIGGER: function(item){return "trigger " + item.triggerId;},
    SCENARIO_STEP: function(item){return "step " + item.stepId;},
    SQL_CONNECTION: function(item){return "SQL on connection " + item.connection;},
    JOBS: function(item){return "Job";},
    INSIGHT: function(item){return "insight " + (info && info.name ? info.name : item.insightId) + " in " + item.projectKey;},
    PYTHON: function(item){return "Python";},
    KEPT_FILE: function(item){return "file " + item.path;},
    CLUSTER: function(item) {return "cluster" + item.clusterId;}
});


app.factory("ScenarioUtils", function($state, DataikuAPI, WT1, CreateModalFromTemplate) {
    var triggerTypes = {
        manual: "Manual trigger",
        sub: "Launched by scenario",
        temporal: "Time-based trigger",
        ds_modified: "Dataset changed",
        sql_query: "SQL query result changed",
        follow_scenariorun: "After scenario",
        custom_python: "Custom python trigger"
    };

    return {
        getTriggerName: function(trigger) {
            if ( trigger == null ) return "";
            return trigger.name || triggerTypes[trigger.type] || trigger.type;
        },
        duplicate: function(scope, scenario) {
            DataikuAPI.projects.listHeads("WRITE_CONF").success(function(projects) {
                if (projects.length == 0) {
                    Dialogs.error(scope, "No writable project", "You don't have write access to any project, can't duplicate scenario.");
                    return;
                }
                CreateModalFromTemplate("/templates/scenarios/duplicate-scenario-modal.html", scope, null, function(newScope) {
                    const currentProjectWritable = projects.some(_ => _.projectKey === scenario.projectKey);
                    newScope.writableProjects = projects;
                    newScope.projectKey = currentProjectWritable ? scenario.projectKey : projects[0].projectKey;
                    newScope.fillId = function () {
                        if (!newScope.name || newScope.id) return;
                        newScope.id = newScope.name.replace(/\W+/g, '').toUpperCase();
                    }
                    newScope.duplicate = function() {
                        DataikuAPI.scenarios.duplicate(scenario.projectKey, newScope.projectKey, scenario.id, newScope.id,
                            newScope.name).success(function(data) {
                                $state.go('projects.project.scenarios.scenario.settings', {projectKey: newScope.projectKey, scenarioId: data.id});
                        }).error(setErrorInScope.bind(newScope));
                        WT1.event("scenario-duplicate", {onSameProject: scenario.projectKey == newScope.projectKey});
                    };
                    newScope.$watch("projectKey", function (newProjectKey) {
                        if (newProjectKey == scenario.projectKey ) {
                            newScope.name = "Copy of " + scenario.name;
                            newScope.id = undefined;
                        } else {
                            newScope.name = scenario.name;
                            newScope.id = scenario.id;
                        }
                    });
                });
            }).error(setErrorInScope.bind(scope));
        },

        getAutoTriggerDisablingReason: function(appConfig, projectSummaries) {
            if (appConfig.disableAutomaticTriggers) {
                return "Auto-triggers have been disabled in the global automation settings";
            }
            if (projectSummaries && projectSummaries.length == 1 && projectSummaries[0].disableAutomaticTriggers) {
                return "Auto-triggers have been disabled in the project's automation settings";
            }
            if (projectSummaries && projectSummaries.length > 1 && projectSummaries.every(summary => summary.disableAutomaticTriggers)) {
                return "Auto-triggers have been disabled in the automation settings of all selected projects";
            }
            return "";
        }
    }
});


app.controller("ScenarioCoreController", function($scope, $stateParams, CreateModalFromTemplate) {
    $scope.createAndPinInsight = function(scenario) {
        var insight = {
            projectKey: $stateParams.projectKey,
            type: 'scenario_last_runs',
            params: { scenarioSmartId: scenario.id, range: 'LAST_WEEK'},
            name: "Last runs of scenario " + scenario.name
        };
        CreateModalFromTemplate("/templates/dashboards/insights/create-and-pin-insight-modal.html", $scope, "CreateAndPinInsightModalController", function(newScope) {
            newScope.init(insight);
        });
    }
});


app.controller("ScenariosListController", function($scope, $rootScope, $controller, $stateParams, $q, Fn, DataikuAPI, $state,
                TopNav, CreateModalFromTemplate, Dialogs, WT1, ActivityIndicator, ScenarioUtils) {

    $controller('_TaggableObjectsListPageCommon', {$scope: $scope});
    $controller('ScenariosCommonController', {$scope:$scope});

    $scope.sortBy = [
        { value: 'id', label: 'Id' },
        { value: 'name', label: 'Name' },
        { value: 'triggerDigest', label: 'Runs when...' }
    ];
    $scope.selection = $.extend({
        filterQuery: {
            userQuery: '',
            tags: [],
            interest: {
                starred: '',
            },
        },
        filterParams: {
            userQueryTargets: ["name","tags"],
            propertyRules: {tag:"tags"},
        },
        orderQuery: "id",
        orderReversed: false,
    }, $scope.selection || {});
    $scope.sortCookieKey = 'scenarios';
    $scope.maxItems = 20;

    $scope.list = function() {
        DataikuAPI.scenarios.listHeads($stateParams.projectKey).success(function(data) {
            $scope.listItems = data.items;
            $scope.restoreOriginalSelection();
        }).error(setErrorInScope.bind($scope));
    };

    TopNav.setLocation(TopNav.TOP_JOBS, "scenarios", TopNav.TABS_NONE, null);
    TopNav.setNoItem();
    $scope.list() ;

    $scope.$watch("selection.selectedObject",function(nv) {
        if (!nv) return;

        DataikuAPI.scenarios.getSummary($stateParams.projectKey, nv.id).success(function(data) {
            $scope.scenario = data.object;
            processUnavailables($scope.scenario, data);
        }).error(setErrorInScope.bind($scope));
    });

    $scope.newScenario = function() {
        CreateModalFromTemplate("/templates/scenarios/new-scenario-modal.html", $scope);
    };

    /* Specific actions */
    $scope.goToItem = function(data) {};

    $scope.refreshTimeline = function(){    // bound in the view
        DataikuAPI.timelines.getForObject($stateParams.projectKey, "SCENARIO", this.id)
            .success(function(data){
                $scope.objectTimeline = data;
            })
            .error(setErrorInScope.bind($scope));
    };

    $scope.$watch('selection.confirmedItem', function(nv){
        if (!nv) {return}
        $scope.refreshTimeline.bind(nv)();
    });

    $rootScope.$on('toggleActiveList', function(){
        $scope.selection.confirmedItem.active = !$scope.selection.confirmedItem.active;
    });

    $scope.toggleActive = function(scenario) {
        WT1.event("scenario-save-active");
        $rootScope.$emit('toggleActiveRightCol');
        var message = scenario.active ? 'Activate ' : 'Deactivate ';
        message = message + 'auto-triggers of ' + scenario.projectKey + '.' + (scenario.name || scenario.id);
        DataikuAPI.scenarios.saveNoParams($stateParams.projectKey, scenario, {commitMessage:message}).success(function(data){
            // save the expanded states
            ActivityIndicator.success("Saved");
        }).error(setErrorInScope.bind($scope));
    };

    $scope.massAutoTriggers = true;
    $scope.allAutoTriggers = function(objects) {
        if (!objects) return;
        return objects.map(Fn.prop('active')).reduce(function(a,b){return a&&b;},true);
    };

    $scope.allAutoTriggersDisabled = function() {
        return $scope.getAutoTriggerDisablingReason($scope.appConfig, $scope.projectSummary);
    };

    $scope.autoTriggersObjects = function(autoTriggerStatus, objects) {
        objects.forEach(function(object) {
            if (object.active === autoTriggerStatus) return;
            object.active = autoTriggerStatus;
            $scope.toggleActive(object);
        });
    };

    $scope.toggleAutomationLocal = function(scenario) {
        //scenario.active = !scenario.active;
        WT1.event("scenario-save-automationLocal");
        DataikuAPI.scenarios.saveNoParams($stateParams.projectKey, scenario, {}).success(function(data){
            // save the expanded states
            ActivityIndicator.success("Saved");
        }).error(setErrorInScope.bind($scope));
    };

    $scope.runNow = function(scenario) {
        WT1.event("scenario-manual-run-from-list");
        DataikuAPI.scenarios.manualRun($stateParams.projectKey, scenario.id)
        .success(function(data){})
        .error(setErrorInScope.bind($scope));
    };

    $scope.duplicateScenario = function(scenario) {
        ScenarioUtils.duplicate($scope, scenario);
    };

    $scope.getAutoTriggerDisablingReason = function(appConfig, projectSummaries) {
        if (!appConfig || !projectSummaries) return "";
        return ScenarioUtils.getAutoTriggerDisablingReason(appConfig, [].concat(projectSummaries));
    }
});

app.controller("ScenarioPageRightColumnActions", async function($controller, $scope, $rootScope, $stateParams, ActiveProjectKey, DataikuAPI) {

    $controller('_TaggableObjectPageRightColumnActions', {$scope: $scope});

    $scope.data = (await DataikuAPI.scenarios.getSummary(ActiveProjectKey.get(), $stateParams.scenarioId)).data;

    $scope.scenario = $scope.data.object;
    $scope.scenario.nodeType = "SCENARIO";
    $scope.scenario.interest = $scope.data.interest;

    $scope.selection = {
        selectedObject : $scope.scenario,
        confirmedItem : $scope.scenario
    };

    $scope.updateUserInterests = function() {
        DataikuAPI.interests.getForObject($rootScope.appConfig.login, "SCENARIO", ActiveProjectKey.get(), $stateParams.scenarioId)
            .success(function(data){
                $scope.selection.selectedObject.interest = data;
            })
            .error(setErrorInScope.bind($scope));
    }

    const interestsListener = $rootScope.$on('userInterestsUpdated', $scope.updateUserInterests);

    $scope.$on("$destroy", interestsListener);
});

app.directive('scenarioRightColumnSummary', function($controller, DataikuAPI, $stateParams, GlobalProjectActions,
    QuickView, ActiveProjectKey, ActivityIndicator, ScenarioUtils, $rootScope) {
    return {
        templateUrl :'/templates/scenarios/right-column-summary.html',

        link : function(scope, element, attrs) {

            $controller('_TaggableObjectsMassActions', {$scope: scope });
            $controller('_TaggableObjectsCapabilities', {$scope: scope });

            scope.QuickView = QuickView;

            /* Auto save when summary is modified */
            scope.$on("objectSummaryEdited", function() {
                const scriptData = scope.script ? scope.script.data : {};
                DataikuAPI.scenarios.save(ActiveProjectKey.get(), scope.scenario, scriptData, {})
                    .success(() => ActivityIndicator.success("Saved"))
                    .error(setErrorInScope.bind(scope));
            });

            scope.refreshData = function(){
                DataikuAPI.scenarios.getSummary(ActiveProjectKey.get(), scope.selection.selectedObject.id).success(function(data) {
                    if (!scope.selection.selectedObject
                        || scope.selection.selectedObject.id != data.object.id
                        || scope.selection.selectedObject.projectKey != data.object.projectKey) {
                        return; //too late!
                    }
                    scope.scenarioFullInfo = data;
                    scope.scenarioFullInfo.object.triggerDigest = scope.selection.confirmedItem.triggerDigest;
                    scope.scenario = scope.scenarioFullInfo.object;
                    if (scope.projectSummary) {
                        scope.scenarioFullInfo.object.disabledAutoTriggerReason =
                            ScenarioUtils.getAutoTriggerDisablingReason($rootScope.appConfig, [scope.projectSummary]);
                    } else { // right panel from HOME > MYITEMS
                        DataikuAPI.projects.getSummary(scope.scenario.projectKey).success(function(data) {
                            scope.scenarioFullInfo.object.disabledAutoTriggerReason =
                                ScenarioUtils.getAutoTriggerDisablingReason($rootScope.appConfig, [data.object]);
                        });
                    }
                }).error(setErrorInScope.bind(scope));
            };

            scope.$on('customFieldsSaved', scope.refreshData);

            scope.$watch("selection.confirmedItem", function(nv, ov) {
                if (!nv) return;
                scope.refreshData();
            });
        }
    }
});


app.controller("NewScenarioController", function($scope, $controller, $stateParams, DataikuAPI, $state, WT1) {
	WT1.event("scenario-creation-modal");
	$scope.newScenario = {type : 'step_based', name : '', params : {}};
	$scope.create = function() {
		WT1.event("scenario-create");
		DataikuAPI.scenarios.create($stateParams.projectKey, $scope.newScenario).success(function(data) {
			$scope.resolveModal('Scenario created');
			if (data && data.id) {
				$state.go('projects.project.scenarios.scenario.settings', { scenarioId: data.id });
			} else {
				// should not happen
			}
        }).error(setErrorInScope.bind($scope));
	};
    $scope.fillId = function() {
        if (!$scope.newScenario.name || $scope.newScenario.id) return;
        $scope.newScenario.id = $scope.newScenario.name.replace(/\W+/g, '').toUpperCase();
    };
});

app.controller("ScenariosCommonController", function($scope, $rootScope, DataikuAPI, ActivityIndicator, $stateParams,
    TopNav, CreateModalFromTemplate, WT1) {

    $scope.script = {data : null};

    var getMinTriggerDelayForType = function(type) {
        if (type == "ds_modified" || type == "sql_query") {
            return 900;
        } else if (type == "follow_scenariorun") {
            return 60;
        } else if (type == "custom_python" || type.startsWith("pytrigger_")) {
            return 3600;
        }
        return 5;
    };

    $scope.saveScenario = function(){
        WT1.event("scenario-save", {type:$scope.scenario.type});

        $scope.$broadcast("scenario-save");

        // fixup scenario:
        // - don't leave empty delays because they'll become 0
        $scope.scenario.triggers.forEach(function(trigger) {
            if (!trigger.delay) {
                trigger.delay = getMinTriggerDelayForType(trigger.type);
            }
        });
        return DataikuAPI.scenarios.save($stateParams.projectKey, $scope.scenario, $scope.script.data, {
            commitMessage : $scope.currentSaveCommitMessage
        }).success(function(data){
            // save the expanded states
            $scope.saveInfoFromOld.forEach(function(f) {f($scope.scenario, data.scenario)});
            $scope.scenario = data.scenario;
            processUnavailables($scope.scenario, data);
            $scope.oldScenario = angular.copy($scope.scenario);
            $scope.oldScript = angular.copy($scope.script);
            ActivityIndicator.success("Saved");
        }).error(setErrorInScope.bind($scope));
    };

    $scope.saveCustomFields = function(newCustomFields) {
        WT1.event('custom-fields-save', {objectType: 'SCENARIO'});
        let oldCustomFields = angular.copy($scope.scenario.customFields);
        $scope.scenario.customFields = newCustomFields;
        return $scope.saveScenario().then(function() {
                $rootScope.$broadcast('customFieldsSaved', TopNav.getItem(), $scope.scenario.customFields);
            }, function() {
                $scope.scenario.customFields = oldCustomFields;
            });
    };

    $scope.editCustomFields = function() {
        if (!$scope.scenario) {
            return;
        }
        let modalScope = angular.extend($scope, {objectType: 'SCENARIO', objectName: $scope.scenario.name, objectCustomFields: $scope.scenario.customFields});
        CreateModalFromTemplate("/templates/taggable-objects/custom-fields-edit-modal.html", modalScope).then(function(customFields) {
            $scope.saveCustomFields(customFields);
        });
    };
});


app.controller("ScenarioController", function($scope, $controller, $stateParams, $rootScope, DataikuAPI, $state, TopNav,
                CreateModalFromTemplate, ActivityIndicator, WT1, Dialogs, $q, $timeout, ScenarioUtils, ScenarioIntegrations) {

    $controller('ScenariosCommonController', {$scope:$scope});

    TopNav.setItem(TopNav.ITEM_SCENARIO, $stateParams.scenarioId);
    TopNav.setLocation(TopNav.TOP_JOBS, "scenarios", TopNav.TABS_SCENARIO, "settings");

    $scope.getTriggerDisplayType = function(trigger) {return getTriggerDisplayType($scope, trigger);};

    $scope.lastRuns = null;
    $scope.lastTriggerRuns = {};
    DataikuAPI.scenarios.getSummary($stateParams.projectKey, $stateParams.scenarioId).success(function(data){
        $scope.scenario = data.object;
        processUnavailables($scope.scenario, data);
        $scope.objectTimeline = data.timeline;
        $scope.objectInterest = data.interest;
        $scope.oldScenario = angular.copy($scope.scenario);
        TopNav.setItem(TopNav.ITEM_SCENARIO, $stateParams.scenarioId, { name: $scope.scenario.name, id: $scope.scenario.id });

        $scope.refreshLastRuns();

    }).error(setErrorInScope.bind($scope));

    $scope.refreshLastRuns = function() {
        DataikuAPI.scenarios.getLastScenarioRuns($stateParams.projectKey, $stateParams.scenarioId, false).success(function(data){
        	$scope.lastRuns = data;
        }).error(setErrorInScope.bind($scope));

        DataikuAPI.scenarios.getLastTriggerRuns($stateParams.projectKey, $stateParams.scenarioId).success(function(data){
            $scope.lastTriggerRuns = {};
            data.forEach(function(run) {$scope.lastTriggerRuns[run.trigger.id] = run;});
        }).error(setErrorInScope.bind($scope));
    };

    $scope.abortScenario = function(run) {
    	WT1.event("scenario-abort");
		DataikuAPI.futures.abort(run.futureId).success(function(data) {
			$scope.refreshLastRuns();
		}).error(setErrorInScope.bind($scope));
    };

    $scope.scenarioIsDirty = function(){
        return $scope.scenario && $scope.oldScenario && (!angular.equals($scope.scenario, $scope.oldScenario) || !angular.equals($scope.script, $scope.oldScript));
    }

    $scope.saveScenarioIfNeeded = function(){
        if ($scope.scenarioIsDirty()){
            $scope.saveScenario();
        }
    }

    $scope.oldScript = {data : null};

    var keepTriggerExpandeds = function(oldScenario, newScenario) {
    	if (oldScenario.triggers && newScenario.triggers) {
    		for (var i = 0; i < oldScenario.triggers.length; i++) {
    			if ( i < newScenario.triggers.length ) {
    				newScenario.triggers[i].$expanded = oldScenario.triggers[i].$expanded;
    			}
    		}
    	}
    };
    var keepReporterExpandeds = function(oldScenario, newScenario) {
    	if (oldScenario.reporters && newScenario.reporters ) {
    		for (var i = 0; i < oldScenario.reporters.length; i++) {
    			if ( i < newScenario.reporters.length ) {
    				newScenario.reporters[i].$expanded = oldScenario.reporters[i].$expanded;
    			}
    		}
    	}
    };

    $scope.saveInfoFromOld = [];
    $scope.saveInfoFromOld.push(keepTriggerExpandeds);
    $scope.saveInfoFromOld.push(keepReporterExpandeds);



    $scope.saveSummary = function(){
        return DataikuAPI.scenarios.saveNoParams($stateParams.projectKey, $scope.scenario, {summaryOnly: true}).success(function(data) {
            // save the expanded states
            $scope.saveInfoFromOld.forEach(function(f) {f($scope.scenario, data.scenario)});
            $scope.scenario = data.scenario;
            processUnavailables($scope.scenario, data);
            $scope.oldScenario = angular.copy($scope.scenario);
            ActivityIndicator.success("Saved");
        }).error(setErrorInScope.bind($scope));
    };


    $scope.commitScenario = function(){
        CreateModalFromTemplate("/templates/git/commit-object-modal.html", $scope, null, function(newScope) {
            newScope.object = {
                objectType : "SCENARIO",
                objectId : $scope.scenario.id
            }
        });
    }

    $scope.saveScenarioWithCustomCommitMessage = function(){
        var deferred = $q.defer();

        CreateModalFromTemplate("/templates/git/commit-message-only-modal.html", $scope, null, function(newScope) {
            newScope.commitData = {};
            /* Reload previous message if any */
            if ($scope.currentSaveCommitMessage) {
                newScope.commitData.message = $scope.currentSaveCommitMessage;
            }

            newScope.commit = function(){
                deferred.resolve(newScope.commitData);
                newScope.dismiss();
            }
        });

        deferred.promise.then(function(commitData){
            $scope.currentSaveCommitMessage = commitData.message;
            $scope.saveScenario();
        })
    }


    $scope.buildModes = [
                         ["NON_RECURSIVE_FORCED_BUILD", "Build only this dataset"],
                         ["RECURSIVE_BUILD", "Build required datasets"],
                         ["RECURSIVE_FORCED_BUILD", "Force-rebuild dataset and dependencies"],
                         ["RECURSIVE_MISSING_ONLY_BUILD", "Build missing dependent datasets then this one"]
                     ];

    $scope.runNow = function() {
		WT1.event("scenario-manual-run");

        if ($scope.isProjectAnalystRW()) {
        	$scope.saveScenario().then(function() {
                DataikuAPI.scenarios.manualRun($stateParams.projectKey, $scope.scenario.id)
                .success(function(data){})
                .error(setErrorInScope.bind($scope));
        	});
        } else {
                DataikuAPI.scenarios.manualRun($stateParams.projectKey, $scope.scenario.id)
                .success(function(data){})
                .error(setErrorInScope.bind($scope));
        }
    };

    $scope.duplicateScenario = function() {
        $scope.saveScenarioIfNeeded();
        ScenarioUtils.duplicate($scope, $scope.scenario);
    };

    $scope.runWithCustomParams = function() {
        WT1.event("scenario-manual-run", { withCustomParams : true });
        $scope.saveScenario().then(function() {
            CreateModalFromTemplate("/templates/scenarios/run-with-custom-params-modal.html", $scope);
        });
    };


	$scope.addTrigger = function(trigger) {
        WT1.event("scenario-trigger-add", {type:trigger.type});
        const temporalTrigger = $scope.appConfig.licensedFeatures.temporalTriggerAllowed || $scope.appConfig.licensing.ceEntrepriseTrial;
        const otherTriggers = $scope.appConfig.licensedFeatures.allScenarioTriggersAllowed || $scope.appConfig.licensing.ceEntrepriseTrial;
        console.info("Add, t=", temporalTrigger, "o=", otherTriggers)
        if ((trigger.type == "temporal" && !temporalTrigger) || (trigger.type != "temporal" && !otherTriggers)) {
            Dialogs.eeUnavailableFeature($scope,
                "This kind of trigger is not enabled in your Dataiku DSS license",
                "https://www.dataiku.com/dss/features/data-workflow/");
            return;
        }

		if ( $scope.scenario.triggers == null ) {
			$scope.scenario.triggers = [];
		}
		trigger.$expanded = true; // new items show up as expanded. When loading a scenario, all will be collapsed
        if (trigger.type == "temporal") {
            const curDate = new Date();
            curDate.setSeconds(0, 0);
            trigger.params = {
                repeatFrequency: 1,
                frequency: "Hourly",
                monthlyRunOn: "ON_THE_DAY",
                daysOfWeek: [getDayLabels(curDate.getDay())],
                startingFrom: curDate,
                hour: curDate.getHours(),
                minute: curDate.getMinutes(),
                timezone: 'SERVER'
            }
        } else if (trigger.type == "ds_modified" || trigger.type == "sql_query") {
            trigger.delay = 900;
            trigger.graceDelaySettings = {
                delay: 120,
                checkAgainAfterGraceDelay: true
            }
        } else if (trigger.type == "follow_scenariorun") {
            trigger.delay = 60;
            trigger.graceDelaySettings = {
                delay: 0,
                checkAgainAfterGraceDelay: false
            }
        } else if (trigger.type == "custom_python") {
            trigger.delay = 3600;
            trigger.graceDelaySettings = {
                delay: 0,
                checkAgainAfterGraceDelay: false
            }
        } else if (trigger.type.startsWith("pytrigger_")) {
            trigger.delay = 3600;
            trigger.graceDelaySettings = {
                delay: 0,
                checkAgainAfterGraceDelay: false
            }
        }
        trigger.name = getTriggerDisplayType($scope, trigger);
		$scope.scenario.triggers.push(trigger);
	};

	$scope.removeTrigger = function(trigger) {
        WT1.event("scenario-trigger-remove");
		var index = $scope.scenario.triggers.indexOf(trigger);
		if ( index >= 0 ) {
			$scope.scenario.triggers.splice(index, 1);
		}
	};

	$scope.addReporter = function(type) {
	    WT1.event("scenario-reporter-add");
	    var reporter = {
            active : true,
            phase : "END",
            runConditionEnabled : true,
            runCondition : "outcome != 'SUCCESS'",
            messaging : {
                type : type,
                configuration : {
                    variables: [],
                    parameters: [],
                    headers: [],
                    form: []
                }
            }
        }

        if (type === 'slack-scenario' || type === 'webhook-scenario' || type === 'msft-teams-scenario') {
            reporter.messaging.configuration.useProxy = true;
        }
		if ($scope.scenario.reporters == null) {
			$scope.scenario.reporters = [];
		}
		reporter.$expanded = true; // new items show up as expanded. When loading a scenario, all will be collapsed
		$scope.scenario.reporters.push(reporter);
	};

	$scope.removeReporter = function(reporter) {
        WT1.event("scenario-reporter-remove");
		var index = $scope.scenario.reporters.indexOf(reporter);
		if ( index >= 0 ) {
			$scope.scenario.reporters.splice(index, 1);
		}
	};

    $scope.getIntegrationTypeLabel = ScenarioIntegrations.getLabelByType;

	$scope.refreshTimeline = function() {
        DataikuAPI.timelines.getForObject($stateParams.projectKey, "SCENARIO", $stateParams.scenarioId).success(function(data){
            $scope.objectTimeline = data;
        }).error(setErrorInScope.bind($scope));
    };

    DataikuAPI.security.listUsers().success(function(data) {
        $scope.allUsers = data;
    }).error(setErrorInScope.bind($scope));

    $scope.toggleItemExpanded = function(item) {
    	item.$expanded = !item.$expanded;
    };

	// list the flow items in the project, because that's going to be needed for actual work in the steps in any decent scenario
    DataikuAPI.datasets.listWithAccessible($stateParams.projectKey).success(function(data) {
    	data.forEach(function(ds) {ds.foreign = (ds.projectKey != $stateParams.projectKey);});
        $scope.datasets = data;
        $scope.datasetSmartNames = data.map(function(ds) {return {smartName : ds.foreign ? (ds.projectKey + '.' + ds.name) : ds.name, displayName : ds.name + (ds.foreign ? ('(' + ds.projectKey + ')') : '')};});
        $scope.datasetSmartNames.push({smartName : '', displayName : 'Nothing selected'});
    }).error(setErrorInScope.bind($scope));

    DataikuAPI.managedfolder.listWithAccessible($stateParams.projectKey).success(function(data) {
    	data.forEach(function(ds) {ds.foreign = (ds.projectKey != $stateParams.projectKey);});
        $scope.managedfolders = data;
    }).error(setErrorInScope.bind($scope));

    DataikuAPI.savedmodels.listWithAccessible($stateParams.projectKey).success(function(data) {
    	data.forEach(function(ds) {ds.foreign = (ds.projectKey != $stateParams.projectKey);});
        $scope.savedmodels = data;
    }).error(setErrorInScope.bind($scope));

    DataikuAPI.dashboards.listHeads($stateParams.projectKey, {}).success(function(data) {
        $scope.dashboards = data.items;
    }).error(setErrorInScope.bind($scope));

    DataikuAPI.modelevaluationstores.listWithAccessible($stateParams.projectKey).success(function(data) {
        data.forEach(function(ds) {ds.foreign = (ds.projectKey != $stateParams.projectKey);});
        $scope.modelevaluationstores = data;
    }).error(setErrorInScope.bind($scope));

    DataikuAPI.admin.clusters.listAccessible().success(function(data){
        $scope.clusters = data;
        $scope.clusterIds = data.map(function(c) {return c.id;});
    }).error(setErrorInScope.bind($scope));

    function allowedTransitions(data) {
        // scenario has several top-level tabs, so we need to check if we move to a different state but on the same scenario
        return !((data.toState && data.toState.name && data.toState.name.indexOf("projects.project.scenarios.scenario") < 0) || data.toParams.scenarioId != data.fromParams.scenarioId);
    }
    checkChangesBeforeLeaving($scope, $scope.scenarioIsDirty, null, allowedTransitions);

    Mousetrap.bind("@ f a k e", function(){
        CreateModalFromTemplate("/templates/scenarios/fake-run-modal.html", $scope, null, function(newScope){
        	newScope.date = moment().format("YYYY-MM-DD");
        	newScope.time = moment().format("HH:mm");
            newScope.repeats = 1;
            newScope.spacing = 300;
        	newScope.outcome = "SUCCESS";
        	newScope.outcomes = ["SUCCESS", "WARNING", "FAILED", "ABORTED"];
    	    newScope.run = function() {
    	        var t = moment(newScope.date + ' ' + newScope.time + '.00');
    	        for (var i = 0; i < newScope.repeats; i++) {
        	        DataikuAPI.internal.fakeScenarioRun($stateParams.projectKey, $stateParams.scenarioId, t.format("YYYY-MM-DD") + 'T' + t.format("HH:mm:ss") + ".000Z", newScope.outcome).success(function(data) {
        	        }).error(setErrorInScope.bind($scope));
        	        t = t.add(newScope.spacing, 's')
        	    }
                newScope.dismiss();
        	}
        });
    })

    $scope.$on("$destroy", function(){
        Mousetrap.unbind("@ f a k e");
    });
});

app.controller("RunScenarioWithCustomParamsModalController", function($scope, $stateParams, DataikuAPI, Logger, LocalStorage, WT1, CodeMirrorSettingService){
    var storageKey = "dss.scenarios." + $stateParams.projectKey + "." + $scope.scenario.id + ".customRunParams";

    $scope.editorOptions = CodeMirrorSettingService.get('application/json', {onLoad: function(cm) {$scope.codeMirror = cm;}});

    $scope.run = {
        params : {}
    };

    var state = LocalStorage.get(storageKey);
    if (state) {
        try {
            $scope.run.params = JSON.parse(state);
        } catch (e) {
            Logger.warn("Failed to parse previously-saved scenario params", e);
        }
    }

    $scope.go = function(){
        try {
            LocalStorage.set(storageKey, JSON.stringify($scope.run.params));
        } catch (e) {
            Logger.warn("Failed to save scenario params", e);
        }
        WT1.event("scenario-manual-run-with-params");
        DataikuAPI.scenarios.manualRun($stateParams.projectKey, $scope.scenario.id, $scope.run.params).success(function(data){
            $scope.dismiss();
        }).error(setErrorInScope.bind($scope));
    }
})

app.controller("ScenarioRunController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
	$controller('ScenarioController', {$scope: $scope});
    if ($stateParams.runId != undefined) {
    	// go to that run directly
    	$scope.preSelectedRun = {runId : $stateParams.runId};
    }
});


app.controller("ScenarioSettingsController", function($scope, TopNav, ScenarioIntegrations, ScenarioUtils) {
    TopNav.setLocation(TopNav.TOP_JOBS, "scenarios", TopNav.TABS_SCENARIO, "settings");

     $scope.availableIntegrationTypes = ScenarioIntegrations.integrationTypes;
     $scope.getAutoTriggerDisablingReason = function(appConfig, projectSummaries) {
         if (!appConfig || !projectSummaries) return "";
        return ScenarioUtils.getAutoTriggerDisablingReason(appConfig, [].concat(projectSummaries));
     }
});


app.controller("ScenarioSummaryController", function($scope, TopNav) {
    TopNav.setLocation(TopNav.TOP_JOBS, "scenarios", TopNav.TABS_SCENARIO, "summary");

    /* Auto save when summary is modified */
    $scope.$on("objectSummaryEdited", $scope.saveScenario);

    $scope.$on('customFieldsSummaryEdited', function(event, customFields) {
        $scope.saveCustomFields(customFields);
    });
});


app.controller("ScenarioStepsController", function($scope, TopNav) {
    TopNav.setLocation(TopNav.TOP_JOBS, "scenarios", TopNav.TABS_SCENARIO, "steps");
});


app.controller("ScenarioRunsTimelineController", function($scope, TopNav) {
    TopNav.setLocation(TopNav.TOP_JOBS, "scenarios", TopNav.TABS_SCENARIO, "runs");
});


app.controller("objectTimelineController", function($scope, TopNav) {
});


app.controller("ScenarioHistoryController", function($scope, TopNav) {
    TopNav.setLocation(TopNav.TOP_JOBS, "scenarios", TopNav.TABS_SCENARIO, "history");
});

var defaultCode =
"# This sample code helps you get started with the custom scenario API.\n" +
"#For more details and samples, please see our Documentation\n" +
"from dataiku.scenario import Scenario\n" +
"\n" +
"# The Scenario object is the main handle from which you initiate steps\n" +
"scenario = Scenario()\n" +
"\n" +
"# A few example steps follow\n" +
"\n" +
"# Building a dataset\n" +
"scenario.build_dataset(\"customers_prepared\", partitions=\"2015-01-03\")\n" +
"\n" +
"# Controlling the train of a dataset\n" +
"train_ret = scenario.train_model(\"uSEkldfsm\")\n" +
"trained_model = train_ret.get_trained_model()\n" +
"performance = trained_model.get_new_version_metrics().get_performance_values()\n" +
"if performance[\"AUC\"] > 0.85:\n" +
"    trained_model.activate_new_version()\n" +
"\n" +
"# Sending custom reports\n" +
"sender = scenario.get_message_sender(\"mail-scenario\", \"local-mail\") # A messaging channel\n" +
"sender.set_params(sender=\"dss@company.com\", recipient=\"data-scientists@company.com\")\n" +
"\n" +
"sender.send(subject=\"The scenario is doing well\", message=\"All is good\")\n"

app.controller("ScenarioScriptController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate, WT1, ActivityIndicator) {
    TopNav.setLocation(TopNav.TOP_JOBS, "scenarios", TopNav.TABS_SCENARIO, "script");
});


app.controller("ScenarioRunsController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate, WT1, ActivityIndicator, ScenarioUtils) {
	$scope.stepRuns = [];
	$scope.selectedRun = {runId : $stateParams.runId};

	$scope.refreshRunsAndSteps = function() {
		WT1.event("scenario-refresh-runs");
		if ( $scope.selectedRun != null && $scope.selectedRun.futureId != null ) {
			$scope.refreshSteps();
		}
		$scope.refreshLastRuns();
	};

	$scope.refreshSteps = function() {
		if ( $scope.selectedRun != null ) {
			DataikuAPI.scenarios.getScenarioRunDetails($stateParams.projectKey, $stateParams.scenarioId, $scope.selectedRun.runId).success(function(data){
                $scope.selectedRunDetails = data;
				$scope.selectedRunStepRuns = data.stepRuns;
                var results = [];
                if ( $scope.selectedRun.result ) results.push($scope.selectedRun.result);
                data.stepRuns.forEach(function(stepRun) { if ( stepRun.additionalReportItems && stepRun.additionalReportItems.length > 0 ) results.push.apply(results, stepRun.additionalReportItems); });
                results.forEach(function(item) {
                    if (item.logTail && item.logTail.lines && item.logTail.lines.length) {
                        item.logTail.text = item.logTail.lines.join('\n').replace(/^\s+|\s+$/g, '');
                    }
                });
			}).error(setErrorInScope.bind($scope));
		}
	};

	$scope.getTriggerName = ScenarioUtils.getTriggerName;

	$scope.selectRun = function(run) {
		$scope.selectedRun = run;
		if ( run == null ) {
	        $state.transitionTo('projects.project.scenarios.scenario.runs.list', {projectKey: $stateParams.projectKey, scenarioId: $stateParams.scenarioId}
            , {location: true, inherit: true, relative: $state.$current, notify: false})
		} else {
	        $state.transitionTo('projects.project.scenarios.scenario.runs.list.run', {projectKey: $stateParams.projectKey, scenarioId: $stateParams.scenarioId, runId:run.runId}
            , {location: true, inherit: true, relative: $state.$current, notify: false})
		}
		$scope.refreshSteps();
	};

    $scope.downloadRunDiagnosis = function(run) {
        ActivityIndicator.success("Preparing run diagnosis ...");
        downloadURL(DataikuAPI.scenarios.getRunDiagnosisURL($stateParams.projectKey, $stateParams.scenarioId, run.runId));
    };
    $scope.getRunLogURL = function(run) {
        return DataikuAPI.scenarios.getRunLogURL($stateParams.projectKey, $stateParams.scenarioId, run.runId);
    };
    $scope.getStepRunLogURL = function(run, stepRun) {
        return DataikuAPI.scenarios.getStepRunLogURL($stateParams.projectKey, $stateParams.scenarioId, run.runId,
            stepRun.step.type + '_' + stepRun.runId);
    };

    $scope.getDisplayType = function(step) {
        return getStepDisplayType($scope, step);
    };

    $scope.getReportTargetItemDisplayName = getReportTargetItemDisplayName;

	$scope.$watch('lastRuns', function(nv) {
		if ( $scope.lastRuns == null || $scope.selectedRun == null) return;
		// find the selectedRun in the new list (with its new state)
		var runToSelect = null;
		$scope.lastRuns.forEach(function(run) {
			if ( run.runId == $scope.selectedRun.runId ) {
				runToSelect = run;
			}
		});
    	if (!runToSelect) {
    		runToSelect = $scope.lastRuns[0];
    	}
		$scope.selectRun(runToSelect);
	}, true);

	$scope.refreshRunsAndSteps();
});

app.directive("scenarioStepsActionsList", function () {
    return {
        restrict: 'AE',
        templateUrl: '/templates/scenarios/fragments/step-actions-list.html'
    }
});

app.controller("CustomPythonScenarioController", function($scope, $controller, $stateParams, DataikuAPI, CodeMirrorSettingService) {
    DataikuAPI.scenarios.getScript($stateParams.projectKey, $stateParams.scenarioId).success(function(data){
    	$scope.script.data = data.script;
    	$scope.oldScript.data = data.script;

        $scope.scriptReady = true;

    }).error(setErrorInScope.bind($scope));

    $scope.editorOptions = CodeMirrorSettingService.get('text/x-python', {onLoad: function(cm) {$scope.cm = cm;}});
    $scope.editorOptions.gutters = ["CodeMirror-lint-markers","CodeMirror-foldgutter"];
    $scope.editorOptions.lint = {
        'getAnnotations' : function(cm,updateFunction) {
            $scope.linterFunction = function(err) {
                updateFunction(err);
            };
        },
        'async' : true
    };

    $scope.resolveCodeForInsertionFunc = function (sample) {
    	var code = "\n\n";
    	code += $scope.resolveCodeForPreviewFunc(sample);
    	return code;
    };
    $scope.resolveCodeForPreviewFunc = function (sample) {
    	var resolveCode = sample.code;
    	// TODO something. there must be something to do.
        return resolveCode;
    };
});


app.controller("StepBasedScenarioController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate, WT1, Dialogs, ClipboardUtils, ActivityIndicator, openDkuPopin) {

    $scope.currentStep = null;

    $scope.selection = {};

    function setDefaultRunConditions(step) {
        step.runConditionType = 'RUN_IF_STATUS_MATCH';
        step.runConditionStatuses = ['SUCCESS', 'WARNING'];
        step.runConditionExpression = '';
        step.resetScenarioStatus = false;
        step.maxRetriesOnFail = 0;
        step.delayBetweenRetries = 10;
    }

    var keepStepExpandeds = function(oldScenario, newScenario) {
        if (oldScenario && oldScenario.params && oldScenario.params.steps && newScenario.params.steps ) {
            for (var i = 0; i < oldScenario.params.steps.length; i++) {
                if ( i < newScenario.params.steps.length ) {
                    newScenario.params.steps[i].$expanded = oldScenario.params.steps[i].$expanded;
                }
            }
        }
    };
    var keepCurrentStep = function(oldScenario, newScenario) {
        if (oldScenario && oldScenario.params && oldScenario.params.steps && newScenario.params.steps ) {
            var index = oldScenario.params.steps.indexOf($scope.currentStep);
            if ( index >= 0 && index < newScenario.params.steps.length ) {
                $scope.currentStep = newScenario.params.steps[index];
            } else {
                $scope.currentStep = null;
            }
        }
    };
    $scope.saveInfoFromOld.push(keepStepExpandeds);
    $scope.saveInfoFromOld.push(keepCurrentStep);

    $scope.getRunConditionIndicatorIcon = function(step) {
        if (step.runConditionType == 'DISABLED') return 'icon-ban-circle';
        if (step.runConditionType == 'RUN_ALWAYS') return 'icon-play-sign';
        if (step.runConditionType == 'RUN_CONDITIONALLY') return 'icon-code-fork';
        if (step.runConditionType == 'RUN_IF_STATUS_MATCH') {
            if (step.runConditionStatuses.includes('FAILED')) return 'icon-exclamation-sign';
            if (step.runConditionStatuses.includes('ABORTED')) return 'icon-stop';
        }
        return null;
    };

    $scope.addStep = function(step) {
        WT1.event("scenario-step-add", {type:step.type})
		if ( $scope.scenario.params.steps == null ) {
			$scope.scenario.params.steps = [];
		}

        const advancedStepsAllowed = $scope.appConfig.licensedFeatures.advancedScenarioStepsAllowed || $scope.appConfig.licensing.ceEntrepriseTrial;
        if (step.type != "build_flowitem" && !advancedStepsAllowed) {
            Dialogs.eeUnavailableFeature($scope,
                "This kind of scenario step is not enabled in your Dataiku DSS license",
                "https://www.dataiku.com/dss/features/data-workflow/");
            return;
        }

        if (step.type == "custom_python") {
            step.params.envSelection = {
                envMode: "INHERIT"
            }
        }

        setDefaultRunConditions(step);

        step.name = "Step #" + ($scope.scenario.params.steps.length + 1);

        step.$expanded = true; // new items show up as expanded. When loading a scenario, all will be collapsed
        $scope.scenario.params.steps.push(step);
        $scope.editStep(step);
    };

    $scope.deleteSelectedSteps = function() {
        const stepsToDelete = $scope.selection.selectedObjects;
        if (stepsToDelete.length > 0) {
            var dialogScope = $scope.$new();
            dialogScope.stepsToDelete = stepsToDelete;
            dialogScope.perform = function() {
                stepsToDelete.forEach((step) => {
                    $scope.removeStep(step)
                });
                WT1.event("scenario-step-remove", { nbSteps: stepsToDelete.length })
            }
            CreateModalFromTemplate("/templates/widgets/delete-step-dialog.html", dialogScope);
        }
    }

    $scope.copySelectedSteps = function() {
        $scope.copyData($scope.selection.selectedObjects)
    }

    $scope.openPasteModalFromSelectedSteps = function() {
        const selectedSteps = $scope.selection.selectedObjects;
        const insertAfterStep = selectedSteps[selectedSteps.length - 1];
        $scope.openPasteModalFromStep(insertAfterStep)
    }

    $scope.toggleRunConditionSelectedSteps = function() {
        const selectedSteps = $scope.selection.selectedObjects;
        const allStepsDisabled = selectedSteps.every(step => step.runConditionType == "DISABLED");
        for (const step of selectedSteps) {
            if (allStepsDisabled) {
                setDefaultRunConditions(step);
            } else {
                step.runConditionType = "DISABLED";
            }
        }
    }

    /*
        * Copy/Paste steps
        *
    */

    let copyType = 'scenario-steps';

    $scope.copyData = function(data) {
        let copy = {
            "type": copyType,
            "version": $scope.appConfig.version.product_version,
            steps: angular.copy(data)
        };
        copy.steps.forEach(step => step.$selected = false);

        const dataStr = JSON.stringify(copy, (key, value) => {
            let keysToRemove = ['id', '$$hashKey', '$variant'];

            return keysToRemove.includes(key) ? undefined : value;
        }, 2);
        const plural = copy.steps.length > 1 ? 's' : '';
        ClipboardUtils.copyToClipboard(dataStr, `Copied ${copy.steps.length} step${plural} to clipboard.`);
    };

    $scope.openPasteModalFromStep = function(insertAfterStep) {
        let newScope = $scope.$new();
        $scope.insertAfterStep = insertAfterStep;

        CreateModalFromTemplate("/templates/scenarios/paste-steps-modal.html", newScope, 'PasteModalController', function(modalScope) {
            modalScope.copyType = copyType;
            modalScope.itemKey = 'steps';
            modalScope.formatData = $scope.formatStepData;
            modalScope.pasteItems = $scope.pasteSteps;
        });
    };

    $scope.formatStepData = function(steps) {
        steps.forEach(step => {
            const name = step.name;
            if (typeof name !== 'undefined' && name.length > 0) {
                const suffix = ' (copy)';
                if (name.indexOf(suffix, name.length - suffix.length) === -1) {
                    step.name += ' (copy)';
                }
            }
        });

        return steps;
    };

    $scope.pasteSteps = function(stepsToPaste) {
        const allSteps = $scope.scenario.params.steps;

        let insertAfter = allSteps.indexOf($scope.insertAfterStep);
        insertAfter = insertAfter < 0 ? allSteps.length : insertAfter + 1;

        allSteps.splice(insertAfter, 0, ...stepsToPaste);

        const plural = stepsToPaste.length > 1 ? 's' : '';
        ActivityIndicator.success(`Pasted ${stepsToPaste.length} step${plural} successfully.`, 5000);

        WT1.event("scenario-steps-paste", { nbSteps: stepsToPaste.length })
        allSteps.forEach((step) => step.$selected = false);
        stepsToPaste.forEach((step) => step.$selected = true);
        $scope.insertAfterStep = null;
        $scope.currentStep = stepsToPaste[0];
    };

    // immediately show preview state since we've already pasted
    $scope.openPasteModalFromKeydown = function(data) {
        try {
            data = JSON.parse(data);
        } catch(e) {}

        if (data && data.steps && data.steps.length && data.type === copyType) {
            let newScope = $scope.$new();
            $scope.insertAfter = $scope.currentStep;

            CreateModalFromTemplate("/templates/scenarios/paste-steps-modal.html", newScope, 'PasteModalController', function(modalScope) {
                modalScope.uiState.editMode = false;
                modalScope.uiState.items = data.steps;
                modalScope.uiState.type = data.type;
                modalScope.pasteItems = $scope.pasteSteps;
            });
        }
    }

    $scope.keydownCopy = function(event) {
        const selectedSteps = $scope.selection.selectedObjects;
        if (selectedSteps.length > 0) {
            $scope.copyData(selectedSteps);
        }
        event.currentTarget.focus();
    }

    $scope.removeOneStep = function(step) {
        WT1.event("scenario-step-remove", { nbSteps: 1 })
        $scope.removeStep(step);
    }

	$scope.removeStep = function(step) {
		if ( step == $scope.currentStep ) {
			$scope.currentStep = null;
		}
		var index = $scope.scenario.params.steps.indexOf(step);
		if ( index >= 0 ) {
			$scope.scenario.params.steps.splice(index, 1);
		}
	};

	$scope.editStep = function(step, index) {
		$scope.currentStep = step;
		$('.step-help-popover').popover('hide');//hide any displayed help window
	};

    $scope.getDisplayType = function(step) {
        return getStepDisplayType($scope, step);
    };

	$scope.getDisplayName = function(step) {
		return step.name;
    };

    $scope.openMenu = function($event, step) {
        function isElsewhere() {
            return true;
        }

        const dkuPopinOptions = {
            isElsewhere,
            callback: null,
            popinPosition: 'CLICK',
            template: `<ul class="dropdown-menu" scenario-steps-actions-list></ul>`,
        };

        const selectedSteps = $scope.selection.selectedObjects;
        if (selectedSteps && selectedSteps.length > 0 && selectedSteps.indexOf(step) > -1) {
            openDkuPopin($scope, $event, dkuPopinOptions);
        } else {
            const newScope = $scope.$new();
            newScope.step = step;
            openDkuPopin(newScope, $event, dkuPopinOptions);
        }
    };

	$scope.$watch('scenario' , function(nv) {
	    if ( nv == null ) {
	        $scope.currentStep = null;
	    } else {

	    }
	}, true);

	$scope.$on("$destroy", function() {
        $('.step-help-popover').popover('hide');//hide any displayed help window
	});
});


app.directive('editStep', function(DataikuAPI, $state, $stateParams, CreateModalFromTemplate, $timeout) {
    return {
        restrict : 'A',
        templateUrl : '/templates/scenarios/fragments/edit-step.html',
        scope : true,
        link : function($scope, element, attrs) {

            $scope.statuses = [
                           {id:'SUCCESS', label:'ok'},
                           {id:'WARNING', label:'warning'},
                           {id:'ABORTED', label:'aborted'},
                           {id:'FAILED', label:'failed'}
                       ];
            $scope.stepRunConditionVariants = [
                                               {label: 'Never'                      , type:'DISABLED'           , statuses:null                  },
                                               {label: 'If no prior step failed'    , type:'RUN_IF_STATUS_MATCH', statuses:['SUCCESS', 'WARNING']},
                                               {label: 'If some prior step failed'  , type:'RUN_IF_STATUS_MATCH', statuses:['FAILED']            },
                                               {label: 'Always'                     , type:'RUN_ALWAYS'         , statuses:null                  },
                                               {label: 'If current outcome is'      , type:'RUN_IF_STATUS_MATCH', statuses:null                  , showStatuses:true},
                                               {label: 'If condition satisfied'     , type:'RUN_CONDITIONALLY'  , statuses:null                  , showExpression:true}
                                           ];
            $scope.stepRunConditionDescriptions = [
                "This step is disabled and does not run",
                "This step only runs if the scenario is not currently in a failed state (either all previous steps succeedeed, or a prior step reset the failure status)",
                "This step only runs if the scenario is currently in a failed state (because a previous step failed)",
                "This step always runs, even if the scenario is currently in a failed state",
                "This step only runs if the current state of the scenario is among the select states",
                "This step runs if a custom expression is satisfied"
            ]
           $scope.conditionEditorOptions = {
                   mode:'text/grel',
                   theme:'elegant',
                   indentUnit: 4,
                   lineNumbers : false,
                   lineWrapping : true,
                   autofocus: true,
                   onLoad : function(cm) {$scope.codeMirror = cm;}
               };

           $scope.couldResetStatus = function(step) {
               if (step == null || step.runConditionType == null) return false;
               if (step.runConditionType == 'DISABLED') return false;
               if (step.runConditionType != 'RUN_IF_STATUS_MATCH') return true;
               return step.runConditionStatuses.includes('FAILED') || step.runConditionStatuses.includes('ABORTED');
           };

           var setVariant = function(variant, step) {
               if (step == null || variant == null) return;
               step.$variant = variant;
               step.runConditionType = variant.type;
               if (variant.statuses) {
                   step.runConditionStatuses = variant.statuses;
               }
           };
           var variantMatches = function(variant, step) {
               if (variant.type != step.runConditionType) return false;
               if (variant.statuses && step.runConditionStatuses) {
                   var aInB = variant.statuses.filter(function(s) {return !step.runConditionStatuses.includes(s);}).length == 0;
                   var bInA = step.runConditionStatuses.filter(function(s) {return !variant.statuses.includes(s);}).length == 0;
                   return aInB && bInA;
               }
               return true;
           };

           var initStep = function() {
               if ($scope.step == null) return;
               var matchingVariants = $scope.stepRunConditionVariants.filter(function(variant) {return variantMatches(variant, $scope.step);});
               if (matchingVariants.length > 0) {
                   $scope.step.$variant = matchingVariants[0];
               } else {
                   setVariant($scope.stepRunConditionVariants[0], $scope.step);
               }
           };

           $scope.$watch(attrs.editStep, function() {
               $scope.step = $scope.$eval(attrs.editStep);
               initStep();
           });
           $scope.$watch('step.$variant', function() {
               setVariant($scope.step.$variant, $scope.step);
           });
        }
    };
});

app.directive('stepDashboardsTable', function(CreateModalFromTemplate) {
    return {
        restrict: 'E',
        templateUrl: '/templates/scenarios/fragments/step-dashboards-table.html',
        scope: {
            items: '=',
            dashboards: '='
        },
        link: function($scope, element, attrs) {
            $scope.addItem = function() {
                CreateModalFromTemplate("/templates/scenarios/build_flowitem-new-dashboard-modal.html",
                            $scope, "AddDashboardToBuildModalController");
            };

            $scope.removeItem = function(i){
                $scope.items.splice(i, 1);
            };
        }
    }
});

app.directive('stepItemsTable', function(DataikuAPI, $state, $stateParams, CreateModalFromTemplate) {
    return {
        restrict : 'E',
        templateUrl : '/templates/scenarios/fragments/step-items-table.html',
        scope : {
                items : '=',
                canDataset : '=',
                canManagedFolder : '=',
                canSavedModel : '=',
                versionLevelSavedModel : '=',
                canModelEvaluationStore : '=',
                needsPartitions : '=',
                noPartitionSelection : '=',
                datasets : '=',
                savedmodels : '=',
                managedfolders : '=',
                modelevaluationstores : '=',
                actionVerb : '@',
                type : '='
        },
        link : function($scope, element, attrs) {
            $scope.getProjectKeyIfNeeded = function(projectKey) {
                return projectKey && projectKey != $stateParams.projectKey ? projectKey : null;
            };
            $scope.getItemLoc = function(item) {
                return item == null ? null : (item.projectKey || $stateParams.projectKey) + '.' + item.itemId;
            };
            $scope.getDatasetLoc = function(item) {
                return item == null ? null : (item.projectKey || $stateParams.projectKey) + '.' + item.name;
            };
            $scope.getSavedModelLoc = function(item) {
                return item == null ? null : (item.projectKey || $stateParams.projectKey) + '.' + item.id;
            };
            $scope.getManagedFolderLoc = function(item) {
                return item == null ? null : (item.projectKey || $stateParams.projectKey) + '.' + item.id;
            };
            $scope.getModelEvaluationStoreLoc = function(item) {
                return item == null ? null : (item.projectKey || $stateParams.projectKey) + '.' + item.id;
            };

            $scope.partitioning = {};
            $scope.$watch('datasets', function(nv) {
                if (nv == null) return;
                $scope.datasetByLoc = {};
                $scope.datasets.forEach(function(dataset) {$scope.partitioning[$scope.getDatasetLoc(dataset)] = dataset.partitioning;});
                $scope.datasets.forEach(function(dataset) {$scope.datasetByLoc[$scope.getDatasetLoc(dataset)] = dataset;});
            });
            $scope.$watch('savedmodels', function(nv) {
                if (nv == null) return;
                $scope.modelByLoc = {};
                $scope.savedmodels.forEach(function(savedmodel) {$scope.partitioning[$scope.getSavedModelLoc(savedmodel)] = savedmodel.partitioning || {dimensions:[]};});
                $scope.savedmodels.forEach(function(savedmodel) {$scope.modelByLoc[$scope.getSavedModelLoc(savedmodel)] = savedmodel;});
            });
            $scope.$watch('managedfolders', function(nv) {
                if (nv == null) return;
                $scope.folderByLoc = {};
                $scope.managedfolders.forEach(function(managedfolder) {$scope.partitioning[$scope.getManagedFolderLoc(managedfolder)] = managedfolder.partitioning || {dimensions:[]};});
                $scope.managedfolders.forEach(function(managedfolder) {$scope.folderByLoc[$scope.getManagedFolderLoc(managedfolder)] = managedfolder;});
            });
            $scope.$watch('modelevaluationstores', function(nv) {
                if (nv == null) return;
                $scope.evaluationStoreByLoc = {};
                $scope.modelevaluationstores.forEach(function(modelevaluationstore) {$scope.partitioning[$scope.getModelEvaluationStoreLoc(modelevaluationstore)] = modelevaluationstore.partitioning || {dimensions:[]};});
                $scope.modelevaluationstores.forEach(function(modelevaluationstore) {$scope.evaluationStoreByLoc[$scope.getModelEvaluationStoreLoc(modelevaluationstore)] = modelevaluationstore;});
            });

            $scope.getItemDisplayName = function(item) {
                if (!item) return;
                if (item.type == 'DATASET') {
                    return $scope.datasetByLoc[$scope.getItemLoc(item)].name;
                } else if (item.type == 'MANAGED_FOLDER') {
                    return $scope.folderByLoc[$scope.getItemLoc(item)].name;
                } else if (item.type == 'SAVED_MODEL') {
                    return $scope.modelByLoc[$scope.getItemLoc(item)].name;
                } else if (item.type == 'MODEL_EVALUATION_STORE') {
                    return $scope.evaluationStoreByLoc[$scope.getItemLoc(item)].name;
                }
            };

            $scope.addItem = function(type) {
                if (type == 'DATASET') {
                    CreateModalFromTemplate("/templates/scenarios/build_flowitem-new-dataset-modal.html",
                            $scope, "AddDatasetToBuildModalController");
                } else if (type == 'MANAGED_FOLDER') {
                    CreateModalFromTemplate("/templates/scenarios/build_flowitem-new-managedfolder-modal.html",
                            $scope, "AddManagedFolderToBuildModalController");
                } else if (type == 'SAVED_MODEL') {
                    CreateModalFromTemplate("/templates/scenarios/build_flowitem-new-savedmodel-modal.html",
                            $scope, "AddSavedModelToBuildModalController");
                } else if (type == 'MODEL_EVALUATION_STORE') {
                    CreateModalFromTemplate("/templates/scenarios/build_flowitem-new-modelevaluationstore-modal.html",
                            $scope, "AddModelEvaluationStoreToBuildModalController");
                }
            };

            $scope.removeItem = function(i){
                $scope.items.splice(i, 1);
            };

            $scope.getPlaceholder = function(dimension) {
                let format = '';
                if (dimension.type == 'time') {
                    format = 'YYYY';
                    if (dimension.params.period == 'MONTH') {
                        format = 'YYYY-MM';
                    } else if (dimension.params.period == 'DAY') {
                        format = 'YYYY-MM-DD';
                    } else if (dimension.params.period == 'HOUR') {
                        format = 'YYYY-MM-DD-HH';
                    }
                }
                return format;
            };

            $scope.editPartitionSpec = function(item) {
                CreateModalFromTemplate("/templates/scenarios/build_flowitem-edit-partitionspec.html", $scope, null, function(modalScope) {
                    modalScope.item = item;
                    modalScope.flowItemPartitioning = modalScope.partitioning[modalScope.getItemLoc(modalScope.item)];
                    modalScope.newPartition = (item.partitionsSpec === undefined || item.partitionsSpec === null) ? [] : item.partitionsSpec.split('|');

                    modalScope.savePartitionSpec = function() {
                        item.partitionsSpec = modalScope.newPartition.join('|');
                        modalScope.dismiss();
                    }
                });
            };
        }
    };
});
app.directive('stepContinuousActivitiesTable', function(DataikuAPI, $state, $stateParams, CreateModalFromTemplate) {
    return {
        restrict : 'E',
        templateUrl : '/templates/scenarios/fragments/step-continuous-activities-table.html',
        scope : {
                items : '=',
                continuousActivities : '=',
                actionVerb : '@'
        },
        link : function($scope, element, attrs) {
            $scope.$stateParams = $stateParams;

            $scope.addItem = function() {
                CreateModalFromTemplate("/templates/scenarios/start_stop_continuous_activity-new-continuous-activity-modal.html", $scope, "AddContinuousActivityToStartStopModalController");
            };

            $scope.removeItem = function(i){
                $scope.items.splice(i, 1);
            };
        }
    };
});

app.controller("AddContinuousActivityToStartStopModalController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
    $scope.addToList = function(){
        let idx = - 1;
        for(let i = 0; i < $scope.items.length; i++){
            if($scope.items[i] == $scope.newContinuousActivity){
                idx = i;
            }
        }
        if(idx == -1) {
            $scope.items.push($scope.newContinuousActivity);
        }
        $scope.dismiss();
    };
});


app.controller("AddDashboardToBuildModalController", function($scope, $stateParams, SmartId) {
    $scope.addToList = function() {
    	var locToAdd = SmartId.resolve($scope.newDashboard.id, $scope.newDashboard.projectKey)
        if (!$scope.items.some(itm => angular.equals(SmartId.resolve(itm.smartName, $stateParams.projectKey), locToAdd))) {
            $scope.items.push({
                smartName: SmartId.fromTor(locToAdd, $stateParams.projectKey),
                name: $scope.newDashboard.name
            });
        }
        $scope.dismiss();
    }
});

app.controller("AddDatasetToBuildModalController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
    $scope.newPartition = [];

    $scope.addToList = function(){
        let idx = - 1;
        for(let i = 0; i < $scope.items.length; i++){
            if($scope.getItemLoc($scope.items[i]) == $scope.getDatasetLoc($scope.newDataset)
            		&& $scope.items[i].partition == $scope.newPartition){
                idx = i;
            }
        }
        if(idx == -1){
            $scope.items.push({
                type:"DATASET",
                projectKey: $scope.getProjectKeyIfNeeded($scope.newDataset.projectKey),
                itemId: $scope.newDataset.name,
                partitionsSpec: $scope.newPartition.join('|')
            });
        }
        $scope.dismiss();
    };

    $scope.$watch('newDataset', function() {
        $scope.flowItemPartitioning = $scope.partitioning[$scope.getDatasetLoc($scope.newDataset)];
    });
});


app.controller("AddManagedFolderToBuildModalController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
    $scope.newPartition = [];

    $scope.addToList = function() {
        var idx = - 1;
        for(var i = 0; i < $scope.items.length; i++){
            if($scope.getItemLoc($scope.items[i]) == $scope.getManagedFolderLoc($scope.newManagedFolder) && $scope.items[i].partition == $scope.newPartition){
                idx = i;
            }
        }
        if(idx == -1){
            $scope.items.push({
                type:"MANAGED_FOLDER",
                projectKey: $scope.getProjectKeyIfNeeded($scope.newManagedFolder.projectKey),
                itemId: $scope.newManagedFolder.id,
                partitionsSpec: $scope.newPartition.join('|')
            });
        }
        $scope.dismiss();
    };

    $scope.$watch('newManagedFolder', function() {
        $scope.flowItemPartitioning = $scope.partitioning[$scope.getManagedFolderLoc($scope.newManagedFolder)];
    });
});


app.controller("AddSavedModelToBuildModalController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
    $scope.newPartition = [];

    $scope.addToList = function(){
        var idx = - 1;
        for(var i = 0; i < $scope.items.length; i++){
            if($scope.getItemLoc($scope.items[i]) == $scope.getSavedModelLoc($scope.newSavedModel)){
                idx = i;
            }
        }
        if(idx == -1){
            $scope.items.push({
                type:"SAVED_MODEL",
                projectKey: $scope.getProjectKeyIfNeeded($scope.newSavedModel.projectKey),
                itemId: $scope.newSavedModel.id,
                partitionsSpec: $scope.newPartition.join('|')
            });
        }
        $scope.dismiss();
    };

    $scope.$watch('newSavedModel', function() {
        $scope.flowItemPartitioning = $scope.partitioning[$scope.getSavedModelLoc($scope.newSavedModel)];
    });
});

app.controller("AddModelEvaluationStoreToBuildModalController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
    $scope.newPartition = [];

    $scope.addToList = function(){
        var idx = - 1;
        for(var i = 0; i < $scope.items.length; i++){
            if($scope.getItemLoc($scope.items[i]) == $scope.getModelEvaluationStoreLoc($scope.newModelEvaluationStore)){
                idx = i;
            }
        }
        if(idx == -1){
            $scope.items.push({
                type:"MODEL_EVALUATION_STORE",
                projectKey: $scope.getProjectKeyIfNeeded($scope.newModelEvaluationStore.projectKey),
                itemId: $scope.newModelEvaluationStore.id,
                partitionsSpec: $scope.newPartition.join('|')
            });
        }
        $scope.dismiss();
    };

    $scope.$watch('newModelEvaluationStore', function() {
        $scope.flowItemPartitioning = $scope.partitioning[$scope.getModelEvaluationStoreLoc($scope.newModelEvaluationStore)];
    });
});


app.controller("BuildFlowItemStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
    $scope.$watch('step', function() {
    	if ( $scope.step.type == 'build_flowitem' && $scope.step.params.builds == null ) {
    		$scope.step.params.builds = [];
    	}
    	if ( $scope.step.type == 'build_flowitem' && $scope.step.params.jobType == null ) {
    		$scope.step.params.jobType = 'RECURSIVE_BUILD';
    	}
    });
});


app.controller("ClearItemsStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
    $scope.$watch('step', function() {
        if ( $scope.step.type == 'clear_items' && $scope.step.params.clears == null ) {
            $scope.step.params.clears = [];
        }
    });
});

app.controller("InvalidateCacheStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
    $scope.$watch('step', function() {
        if ( $scope.step.type == 'invalidate_cache' && $scope.step.params.invalidates == null ) {
            $scope.step.params.invalidates = [];
        }
    });
});

app.controller("ReloadSchemaStepController", function($scope) {
    $scope.$watch('step', function() {
        if ($scope.step.type == 'reload_schema' && $scope.step.params.items == null ) {
            $scope.step.params.items = [];
        }
    });
});

app.controller("SchemaPropagationStepController", function($scope) {
    $scope.$watch('step', function() {
        if ($scope.step.type == 'schema_propagation' && $scope.step.params.options == null ) {
            $scope.step.params.options = {
                behavior: 'AUTO_WITH_BUILDS',
                recipeUpdateOptions: {},
                partitionByDim: [],
                partitionByComputable: [],
                excludedRecipes: [],
                markAsOkRecipes: []
            };
        }
    });
});

app.controller("RefreshChartCacheStepController", function($scope) {
    $scope.$watch('step', function() {
        if ($scope.step.type == 'refresh_chart_cache' && !$scope.step.params.dashboards) {
            $scope.step.params.dashboards = [];
        }
    });
});


app.controller("ComputeStatsStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
    $scope.$watch('step', function() {
    	if ( $scope.step.type == 'compute_metrics' && $scope.step.params.computes == null ) {
    		$scope.step.params.computes = [];
    	}
    });
});

app.controller("ComputeDataDriftStepController", function($scope, $stateParams, DataikuAPI) {
    $scope.modelEvaluationStores = []
    DataikuAPI.modelevaluationstores.list($stateParams.projectKey).success(function(data) {
        $scope.modelEvaluationStores = data
    }).error(setErrorInScope.bind($scope));
});

app.controller("CheckDatasetStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
    $scope.$watch('step', function() {
    	if ( $scope.step.type == 'check_dataset' && $scope.step.params.checks == null ) {
    		$scope.step.params.checks = [];
    	}
    });
});


app.controller("CheckConsistencyStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
});


app.controller("SynchronizeHiveStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
    $scope.$watch('step', function() {
        if ( $scope.step.type == 'sync_hive' && $scope.step.params.syncs == null ) {
            $scope.step.params.syncs = [];
        }
    });
});


app.controller("UpdateFromHiveStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
    $scope.$watch('step', function() {
        if ( $scope.step.type == 'update_from_hive' && $scope.step.params.syncs == null ) {
            $scope.step.params.syncs = [];
        }
    });
});


app.controller("ExecuteSQLStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
	$scope.connections = [];
    DataikuAPI.sqlNotebooks.listConnections($stateParams.projectKey).success(function(data) {
        $scope.connections = data.nconns; //.filter(function(connection){return connection.type != 'Hive' && connection.type != 'Impala';});
    }).error(setErrorInScope.bind($scope));

    $scope.$watch('step', function() {
        if ( $scope.step.type == 'exec_sql' && $scope.step.params.extraConf == null ) {
    		$scope.step.params.extraConf = [];
    	}
    });
});




app.controller("CustomPythonStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
    $scope.$watch('step', function() {
        if ( $scope.step.type == 'custom_python' && $scope.step.params.envSelection == null ) {
            $scope.step.params.envSelection = {envMode:'INHERIT'};
        }
    });
});


app.controller("UpdateVariablesStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
});


app.controller("EvaluatedVariablesStepSubcontroller", function($scope) {
    $scope.step.params.definitions = $scope.step.params.definitions || [];

    $scope.removeDefinition = function(index) {
        $scope.step.params.definitions.splice(index, 1);
    };
    $scope.canAddDefinition = function() {
        if ( $scope.step.params.definitions == null || $scope.step.params.definitions.length == 0 ) {
            return true;
        }
        var last = $scope.step.params.definitions[$scope.step.params.definitions.length - 1];
        return (last.key && last.value);
    };
    $scope.addDefinition = function() {
        $scope.step.params.definitions.push({key:'', value:''});
    };
});


app.controller("DefineVariablesStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
    $scope.$watch('step', function() {
        if ( $scope.step.type == 'define_vars' && $scope.step.params.definitions == null ) {
            $scope.step.params.definitions = [];
        }

        if ( $scope.step.type == 'define_vars' && $scope.step.params.variables == null ) {
            $scope.step.params.variables = {};
        }
    });
});


app.controller("SetProjectVariablesStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
    $scope.$watch('step', function() {
        if ( $scope.step.type == 'set_project_vars' && $scope.step.params.definitions == null ) {
            $scope.step.params.definitions = [];
        }
        if ( $scope.step.type == 'set_project_vars' && $scope.step.params.variables == null ) {
            $scope.step.params.variables = {};
        }
    });
});


app.controller("SetGlobalVariablesStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
    $scope.$watch('step', function() {
        if ( $scope.step.type == 'set_global_vars' && $scope.step.params.definitions == null ) {
            $scope.step.params.definitions = [];
        }
        if ( $scope.step.type == 'set_global_vars' && $scope.step.params.variables == null ) {
            $scope.step.params.variables = {};
        }
    });
});


app.controller("ExecuteRunnableStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, PluginConfigUtils) {
    $scope.step.params.config = $scope.step.params.config || {};
    var updatePluginDescs = function() {
        $scope.runnable = null;
        $scope.appConfig.customRunnables.forEach(function(x) {
            if (x.runnableType == $scope.step.params.runnableType) {
                $scope.runnable = x;
            }
        });

        if ($scope.runnable == null) {
            $scope.desc = null;
            $scope.pluginDesc = null;
            $scope.hasSettings = null;
        } else {
            $scope.desc = $scope.runnable.desc;

            PluginConfigUtils.setDefaultValues($scope.desc.params, $scope.step.params.config);
            PluginConfigUtils.setDefaultValues($scope.desc.adminParams, $scope.step.params.adminConfig);

            $scope.pluginDesc = $scope.appConfig.loadedPlugins.filter(function(x){
                return x.id == $scope.runnable.ownerPluginId;
            })[0];

            $scope.hasSettings = ($scope.pluginDesc && $scope.pluginDesc.hasSettings) || ($scope.desc.params && $scope.desc.params.length > 0);
        }
    };
    $scope.$watch('step.params.runnableType', function() {
        if ($scope.step.type != 'runnable') {
            return; // don't fixup the step, we're switching the entire step
        }
        $scope.step.params.config = $scope.step.params.config || {};
        $scope.step.params.adminConfig = $scope.step.params.adminConfig || {};
        updatePluginDescs();
    });
    //updatePluginDescs();
});


app.controller("RunOrKillScenarioStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
    var completeSelectedObjectFromScenario = function() {
        if ($scope.scenarios == null) return; // not yet ready
        var found = null;
        $scope.scenarios.forEach(function(scenario) {
            if ( scenario.id == $scope.selected.id ) {
                var projectMatches = scenario.projectKey == $scope.selected.projectKey;
                if ( !projectMatches && scenario.projectKey == $stateParams.projectKey && $scope.selected.projectKey == null ) {
                    projectMatches = true;
                }
                if ( projectMatches ) {
                    found = scenario;
                }
            }
        });
        if ( found != null ) {
            $scope.selected = found;
        } else {
            $scope.scenarios.push($scope.selected);
        }
    };
    DataikuAPI.scenarios.listAccessible().success(function(data) {
        $scope.scenarios = data;
        $scope.scenarios.forEach(function(scenario) {
           scenario.foreign = scenario.projectKey != $stateParams.projectKey,
           scenario.displayName = (scenario.name || scenario.id) + (scenario.foreign ? (' ('+scenario.projectKey+')') : '');
        });
        $scope.scenarios.sort(function(a,b){return a.displayName.localeCompare(b.displayName);});
        completeSelectedObjectFromScenario();
    }).error(setErrorInScope.bind($scope));

    $scope.$watch('selected', function(nv) {
        if ( nv == null ) return;
        $scope.step.params.scenarioId = $scope.selected.id;
        $scope.step.params.projectKey = $scope.selected.projectKey != $stateParams.projectKey ? $scope.selected.projectKey : null;
    }, true);
    $scope.$watch('step', function(nv) {
        if ( nv == null ) return;
        $scope.selected = {id : nv.params.scenarioId, projectKey : nv.params.projectKey};
        completeSelectedObjectFromScenario();
    });
});


app.controller("SendReportStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate, ScenarioIntegrations) {
    $scope.availableIntegrationTypes = ScenarioIntegrations.integrationTypes;
});

app.controller("PullGitRefsStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate, ScenarioIntegrations) {
    DataikuAPI.git.getProjectExternalLibs($stateParams.projectKey).then((result) => {
        $scope.gitReferences = result.data.gitReferences;
    }, setErrorInScope.bind($scope));

    $scope.$watch('step', function() {
        if ($scope.step.type === 'pull_git_refs' && $scope.step.params.updateAll == null) {
            $scope.step.params.updateAll = true;
        }
    });
});

app.controller("PrepareLambdaPackageStepController", function($scope, $stateParams, StringUtils, DataikuAPI) {
    $scope.publishedServiceIds = [];
    DataikuAPI.lambda.services.list($stateParams.projectKey).success(function(data) {
        $scope.services = data;
        $scope.$broadcast("clearMultiSelect");
    }).error(setErrorInScope.bind($scope));

    $scope.ui = {};
    $scope.$watch('ui.selectedPublishedService', function(nv, ov) {
        if (!nv) return;
        $scope.step.params.publishedServiceId = nv.serviceBasicInfo.id;
    }, true);

    let preselectedPublishedService;
    const listPublishedServices = function() {
        DataikuAPI.apideployer.client.listPublishedServices()
        .success(function(response) {
            $scope.publishedServices = response.filter(serviceStatus => serviceStatus.canWrite).sort((a, b) => a.serviceBasicInfo.name.localeCompare(b.serviceBasicInfo.name));
            const suggestedServiceId = $scope.step.params.serviceId &&
                                        StringUtils.transmogrify($scope.step.params.serviceId,
                                        $scope.publishedServices.map(_ => _.serviceBasicInfo.id),
                                        (count, name) => `${name}-${count}`);
            $scope.publishedServices.unshift({createServiceMessage: "Create a new service...", serviceBasicInfo: {}});
            $scope.publishedServiceIds = $scope.publishedServices.map(function(serviceStatus) {
                if (serviceStatus.serviceBasicInfo.id === serviceStatus.serviceBasicInfo.name) return "";
                return serviceStatus.serviceBasicInfo.id;
            });
            preselectedPublishedService = $scope.publishedServices.find(service => service.serviceBasicInfo.id === ($scope.step.params.publishedServiceId || $scope.step.params.serviceId));
            if (!preselectedPublishedService) {
                $scope.publishedServices[0].id = $scope.step.params.publishedServiceId || suggestedServiceId;
                preselectedPublishedService = $scope.publishedServices[0];
            } else {
                $scope.publishedServices[0].id = suggestedServiceId;
            }
            $scope.ui.selectedPublishedService = preselectedPublishedService;
        })
        .error(setErrorInScope.bind($scope));
    }

    $scope.$watch("step.params.publishToAPIDeployer", function(nv, ov) {
        if (nv) {
            if (!$scope.publishedServices) {
                listPublishedServices();
            } else {
                $scope.ui.selectedPublishedService = preselectedPublishedService;
            }
        } else {
            delete $scope.ui.selectedPublishedService;
            delete $scope.step.params.publishedServiceId;
        }
    });
});

app.controller("UpdateAPIDeployerDeploymentStepController", function($scope, DataikuAPI) {
    let deploymentStatusList;
    DataikuAPI.apideployer.client.listDeployments().success(function(data) {
        deploymentStatusList = data;
        $scope.deploymentIds = deploymentStatusList.map(status => status.deploymentBasicInfo.id);
        refreshVersionIds();
    });

    function refreshVersionIds() {
        const deployment = deploymentStatusList.find(status => status.deploymentBasicInfo.id === $scope.step.params.deploymentId);
        if (deployment) {
            $scope.versionIds = deployment.packages.map(p => p.id);
        } else {
            $scope.versionIds = [];
        }
    }

    $scope.$watch("step.params.deploymentId", function(nv, ov) {
        if (nv === ov || !deploymentStatusList) return;
        refreshVersionIds();
    });
});

app.controller("PrepareBundleStepController", function($scope, StringUtils, $stateParams, DataikuAPI) {
    $scope.ui = {};
    $scope.publishedProjectKeys = [];
    $scope.$watch('ui.selectedPublishedProject', function(nv, ov) {
        if (!nv) return;
        $scope.step.params.publishedProjectKey = nv.projectBasicInfo.id;
    }, true);

    let preselectedPublishedProject;
    const listPublishedProjects = function() {
        DataikuAPI.projectdeployer.client.listPublishedProjects()
        .success(function(response) {
            $scope.publishedProjects = response.filter(projectStatus => projectStatus.canWrite).sort((a, b) => a.projectBasicInfo.name.localeCompare(b.projectBasicInfo.name));
            const suggestedProjectKey = StringUtils.transmogrify($stateParams.projectKey,
                                                          $scope.publishedProjects.map(_ => _.projectBasicInfo.id),
                                                          (count, name) => `${name}_${count}`);
            $scope.publishedProjects.unshift({createProjectMessage: "Create a new project...", projectBasicInfo: {}});
            $scope.publishedProjectKeys = $scope.publishedProjects.map(function(projectStatus) {
                if (projectStatus.projectBasicInfo.id === projectStatus.projectBasicInfo.name) return "";
                return projectStatus.projectBasicInfo.id;
            });
            preselectedPublishedProject = $scope.publishedProjects.find(project => project.projectBasicInfo.id === ($scope.step.params.publishedProjectKey || $stateParams.projectKey));
            if (!preselectedPublishedProject) {
                $scope.publishedProjects[0].id = $scope.step.params.publishedProjectKey || suggestedProjectKey;
                preselectedPublishedProject = $scope.publishedProjects[0];
            } else {
                $scope.publishedProjects[0].id = suggestedProjectKey;
            }
            $scope.ui.selectedPublishedProject = preselectedPublishedProject;
        })
        .error(setErrorInScope.bind($scope));
    }

    $scope.$watch("step.params.publishOnDeployer", function(nv, ov) {
        if (nv) {
            if (!$scope.publishedProjects) {
                listPublishedProjects();
            } else {
                $scope.ui.selectedPublishedProject = preselectedPublishedProject;
            }
        } else {
            delete $scope.step.params.publishedProjectKey;
            delete $scope.ui.selectedPublishedProject;
        }
    });
});

app.controller("UpdateProjectDeployerDeploymentStepController", function($scope, DataikuAPI) {
    let deploymentStatusList;
    DataikuAPI.projectdeployer.client.listDeployments().success(function(data) {
        deploymentStatusList = data;
        $scope.deploymentIds = deploymentStatusList.map(status => status.deploymentBasicInfo.id);
        refreshBundleIds();
    });

    function refreshBundleIds() {
        const deployment = deploymentStatusList.find(status => status.deploymentBasicInfo.id === $scope.step.params.deploymentId);
        if (deployment) {
            $scope.bundleIds = deployment.packages.map(p => p.id);
        } else {
            $scope.bundleIds = [];
        }
    }

    $scope.$watch("step.params.deploymentId", function(nv, ov) {
            if (nv === ov || !deploymentStatusList) return;
            refreshBundleIds();
        });
});

app.controller("PluginPythonStepController", function($scope, $controller, $stateParams, Assert, DataikuAPI, $state, TopNav, CreateModalFromTemplate, PluginConfigUtils) {
    $scope.$watch('step', function() { // do a watch on step because angular reuses controllers so you need to detect pystep1 -> pystep2 switches
        if (!$scope.step.unavailable && $scope.step.type.startsWith('pystep_')) { // only for pystep_..., otherwise you arrive here when switching to a non-pystep
            $scope.loadedDesc = $scope.appConfig.customPythonPluginSteps.filter(function(x){
                return x.stepType == $scope.step.type;
            })[0];
    
            $scope.desc = $scope.loadedDesc.desc;
    
            // put default values in place
            PluginConfigUtils.setDefaultValues($scope.desc.params, $scope.step.params.config);
    
            $scope.pluginDesc = $scope.appConfig.loadedPlugins.filter(function(x){
                return x.id == $scope.loadedDesc.ownerPluginId;
            })[0];
        }
    });
});


app.controller("PluginPythonTriggerController", function($scope, $controller, $stateParams, Assert, DataikuAPI, $state, TopNav, CreateModalFromTemplate, PluginConfigUtils) {
    $scope.loadedDesc = $scope.appConfig.customPythonPluginTriggers.filter(function(x){
        return x.triggerType == $scope.trigger.type;
    })[0];

    if ($scope.loadedDesc) {

        $scope.desc = $scope.loadedDesc.desc;

        // put default values in place
        PluginConfigUtils.setDefaultValues($scope.desc.params, $scope.trigger.params.config);

        $scope.pluginDesc = $scope.appConfig.loadedPlugins.filter(function(x){
            return x.id == $scope.loadedDesc.ownerPluginId;
        })[0];
    } else {
        $scope.unavailable = true;
        $scope.unavailablePluginId = $scope.trigger.type.split('_')[1];
    }
});

app.controller("SetUpClusterStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate, PluginConfigUtils) {
    $scope.clusterTypes = [];
    $scope.appConfig.customPythonPluginClusters.forEach(function(t) {
        $scope.clusterTypes.push({id:t.clusterType, label:t.desc.meta.label || t.id, architecture:t.desc.architecture || 'HADOOP'})
    });
    $scope.$watch('step', function() {
        if ( $scope.step.type == 'set_up_cluster' && $scope.step.params.clusterParams == null) {
            $scope.step.params.clusterParams = {config:{}};
        }
    });
});

app.controller("TearDownClusterStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
    $scope.clusterShutdownModes = [{id:'NEVER', label:'No (only disassociate variable)'}, {id:'ALWAYS', label:'Always (if created by a scenario)'}, {id:'IF_EXISTS', label:'If it exists (and is created by a scenario)'}, {id:'IF_STARTED_BY_SCENARIO', label:'If created by this scenario'}];
    $scope.$watch('step', function() {
        if ( $scope.step.type == 'tear_down_cluster' && $scope.step.params.mode == null ) {
            $scope.step.params.mode = 'IF_STARTED_BY_SCENARIO';
        }
    });
});

app.controller("StartContinuousActivityStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate, ScenarioIntegrations) {
    DataikuAPI.continuousActivities.listProjectStates($stateParams.projectKey).success(function (data) {
        $scope.continuousActivities = data.activities;
    }).error(setErrorInScope.bind($scope));

    $scope.$watch('step', function() {
        if ($scope.step.type === 'start_continuous_activity' && $scope.step.params.continuousActivityIds == null) {
            $scope.step.params.continuousActivityIds = [];
        }
        if ($scope.step.type === 'start_continuous_activity' && $scope.step.params.loopParams == null) {
            $scope.step.params.loopParams = {};
        }
    });
});

app.controller("StopContinuousActivityStepController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate, ScenarioIntegrations) {
    DataikuAPI.continuousActivities.listProjectStates($stateParams.projectKey).success(function (data) {
        $scope.continuousActivities = data.activities;
    }).error(setErrorInScope.bind($scope));

    $scope.$watch('step', function() {
        if ($scope.step.type === 'start_continuous_activity' && $scope.step.params.continuousActivityIds == null) {
            $scope.step.params.continuousActivityIds = [];
        }
    });
});


app.controller("TemporalTriggerController", function($rootScope, $scope, DataikuAPI) {
    $scope.repeatCount = 0;
    $scope.frequencyOptions = [['Monthly', 'months'], ['Weekly', 'weeks'], ['Daily', 'days'], ['Hourly', 'hours'], ['Minutely', 'minutes']];
    $scope.monthyOptions = [[0, 0]];
    $scope.repeatFrequencyMax = 2147483647;
    $scope.startingFrom = new Date($scope.trigger.params.startingFrom);

    $scope.$on('scenario-save', () => {
        if($scope.trigger.params.frequency === 'Weekly' && $scope.trigger.params.daysOfWeek.length === 0) {
            $scope.trigger.params.daysOfWeek.push(getDayLabels((new Date()).getDay()));
        }
    });

    $scope.time = new Date();
    $scope.time.setMilliseconds(0);
    $scope.time.setSeconds(0);
    $scope.time.setMinutes($scope.trigger.params.minute);
    $scope.time.setHours($scope.trigger.params.hour);

    // Force format HH:mm for firefox
    $scope.twoDecimals = function (n) {
        if (n < 10) {
            return "0" + n;
        } else {
            return n;
        }
    };
    $scope.getHHmm = () => {
      return ('0' + ($scope.trigger.params.hour || 0)).slice(-2) + ':' + ('0' + ($scope.trigger.params.minute || 0)).slice(-2);
    };
    $scope.timezone_ids = [];
    DataikuAPI.timezone.shortlist().success(function(data){
        $scope.timezone_ids = [['SERVER', 'Server timezone'], ...data.ids.map(i => [i, i])];
    }).error(setErrorInScope.bind($rootScope));

    $scope.shouldDisplayStartingAt = () => {
        return $scope.trigger.params.frequency !== 'Minutely';
    };

    $scope.shouldDisplayTime = () => {
        return ['Hourly', 'Minutely'].includes($scope.trigger.params.frequency);
    };

    $scope.shouldDisplayMonthDayPicker = () => {
        return $scope.trigger.params.frequency === 'Monthly';
    };

    $scope.shouldDisplayWeekDayPicker = () => {
        return $scope.trigger.params.frequency === 'Weekly';
    };

    $scope.shouldDisplayRunAt = () => {
        return ['Monthly', 'Weekly', 'Daily'].includes($scope.trigger.params.frequency);
    };

    $scope.shouldDisplayTimezone = () => {
        return $scope.trigger.params.frequency !== 'Minutely';
    };


    $scope.timeChanged = () => {
        $scope.trigger.params.minute = $scope.time.getMinutes();
        $scope.trigger.params.hour = $scope.time.getHours();
    };

    $scope.getMonthlyRunOn = () => {
        const weekLabels = [['FIRST_WEEK', 'First'], ['SECOND_WEEK', 'Second'], ['THIRD_WEEK', 'Third'], ['FOURTH_WEEK', 'Fourth']];
        const day = $scope.startingFrom.getDate();
        const dayOfWeek =  $scope.startingFrom.getDay();
        // "day - 1" the the 7th day is still part of the first week
        const weekOfMonth = Math.floor((day - 1) / 7);

        // Because we love JS consistance, the method to get the max number of the day in a month need a real month and a real year
        var year = $scope.startingFrom.getYear();
        if (year < 1900) {
            year = year + 1900
        }
        var month = $scope.startingFrom.getMonth() + 1;
        const maxDayOfMonth = new Date(year, month, 0).getDate();


        const options = [['ON_THE_DAY', 'On day ' + day]];
        if (weekOfMonth < 4) { // We do not want to print the fifth week
            options.push([weekLabels[weekOfMonth][0], `On the ${weekLabels[weekOfMonth][1]} ${getDayLabels(dayOfWeek)}`]);
        }
        // If we are in the last 7 day of the months
        if (day > maxDayOfMonth - 7) {
            options.push(['LAST_WEEK', `On the last ${getDayLabels(dayOfWeek)}`]);
        }

        // Check if we are ont he last day of the months
        if (new Date($scope.startingFrom.getTime() + 86400000).getDate() === 1) {
            options.push(['LAST_DAY_OF_THE_MONTH', `On the last day of the month`]);
        }
        $scope.monthyOptions = options;
    }

    $scope.$watch('[trigger.params.frequency,startingFrom]', (nv, ov) => {
        $scope.repeatFrequencyMax = 2147483647;
        $scope.trigger.params.startingFrom = $scope.startingFrom.toISOString();

        if($scope.trigger.params.frequency === 'Monthly') {
            $scope.getMonthlyRunOn();
        }
        if (nv === ov) {
            return;
        }

        // Force the "Run on" to be on a value.
        var currentOptions = $scope.monthyOptions.map(function(x) {
            return x[0];
        });
        if (!$scope.trigger.params.monthlyRunOn || !currentOptions.includes($scope.trigger.params.monthlyRunOn)) {
            $scope.trigger.params.monthlyRunOn = $scope.monthyOptions[0][0];
        }
    });
});

app.controller("DatasetModifiedTriggerController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
    $scope.trigger.params.triggerWhenAllFire = $scope.trigger.params.triggerWhenAllFire || false;
});


app.controller("FollowScenarioRunTriggerController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
    $scope.selected = {id : $scope.trigger.params.scenarioId, projectKey : $scope.trigger.params.projectKey};

    DataikuAPI.scenarios.listAccessible().success(function(data) {
        $scope.scenarios = data;
        // exclude the current scenario, for obvious reasons
        $scope.scenarios = data.filter(function(scenario) {
            return !(scenario.id === $stateParams.scenarioId && scenario.projectKey === $stateParams.projectKey);
        });

        $scope.scenarios.forEach(function(scenario) {
           scenario.foreign = scenario.projectKey != $stateParams.projectKey,
           scenario.displayName = (scenario.name || scenario.id) + (scenario.foreign ? (' ('+scenario.projectKey+')') : '');
        });
        $scope.scenarios.sort(function(a,b){return a.displayName.localeCompare(b.displayName);});
        var found = null;
        $scope.scenarios.forEach(function(scenario) {
            if ( scenario.id == $scope.selected.id ) {
                var projectMatches = scenario.projectKey == $scope.selected.projectKey;
                if ( !projectMatches && scenario.projectKey == $stateParams.projectKey && $scope.selected.projectKey == null ) {
                    projectMatches = true;
                }
                if ( projectMatches ) {
                    found = scenario;
                }
            }
        });
        if ( found != null ) {
            $scope.selected = found;
        } else {
            $scope.scenarios.push($scope.selected);
        }
    }).error(setErrorInScope.bind($scope));

    $scope.$watch('selected', function(nv) {
        if ( nv == null ) return;
        $scope.trigger.params.scenarioId = $scope.selected.id;
        $scope.trigger.params.projectKey = $scope.selected.projectKey != $stateParams.projectKey ? $scope.selected.projectKey : null;
        if ($scope.trigger.params.projectKey == null) {
            delete $scope.trigger.params.projectKey; // to match the state we compare to when checking dirtyness
        }
    }, true);
});


app.controller("SQLQueryTriggerController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate) {
	$scope.connections = [];
    DataikuAPI.sqlNotebooks.listConnections($stateParams.projectKey).success(function(data) {
        $scope.connections = data.nconns; //.filter(function(connection){return connection.type != 'Hive' && connection.type != 'Impala';});
    }).error(setErrorInScope.bind($scope));

    $scope.$watch('trigger.params.hasLimit', function(nv, ov){
        if (nv != ov && !$scope.trigger.params.limit) {
            $scope.trigger.params.limit = 10000;
        }
    });
});

app.service("ScenarioIntegrations", function(){
    var integrationTypes = [
            {"id" : "mail-scenario", "label" : "Mail"},
            {"id" : "slack-scenario", "label" : "Slack"},
            {"id" : "msft-teams-scenario", "label": "Microsoft Teams"},
            {"id" : "webhook-scenario", "label" : "Webhook"},
            {"id" : "twilio-scenario", "label" : "Twilio"},
            {"id" : "shell-scenario", "label" : "Shell command"},
            {"id" : "dataset-scenario", "label" : "Send to dataset"}
    ]

    var getLabelByType = function(type) {
        const integration = integrationTypes.find(element => element.id === type);
        return integration === undefined ? type : integration.label;
    }
    return {integrationTypes: integrationTypes, getLabelByType: getLabelByType};
});


app.directive("scenarioMessagingEditor", function($stateParams, DataikuAPI, CreateModalFromTemplate, ScenarioIntegrations){
    return {
        scope : true,
        link : function($scope, element, attrs) {
            $scope.integrationTypes = ScenarioIntegrations.integrationTypes;
            $scope.$watch(attrs.messaging, function(nv, ov){
                if (nv) {
                    $scope.messaging = nv;
                }
            })
        }
    }
});


app.controller("ReporterController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate, $timeout, $parse) {
    $scope.noStartMessage = $scope.noStartMessage || false;
    $scope.showItemHeader = $scope.showItemHeader == undefined || $scope.showItemHeader;

    $scope.conditionEditorOptions = {
    		mode:'text/grel',
            theme:'elegant',
            indentUnit: 4,
            lineNumbers : false,
            lineWrapping : true,
            autofocus: true,
            onLoad : function(cm) {$scope.codeMirror = cm;}
		};

    // because otherwise the codemirror pops up shrunk when the ng-show on reporter.messaging.channelId changes state
    $scope.$watch("reporter.messaging.configuration.channelId", function() {
        if ( $scope.codeMirror ) {
            $timeout(function() {$scope.codeMirror.refresh();});
        }
    }, true);

    $scope.editCustomVariablesCode = function() {
        CreateModalFromTemplate("/templates/scenarios/edit-custom-variables-code-modal.html", $scope, "EditCustomVariablesCodeController", function(newScope){
        	newScope.variablesCode = $scope.reporter.variablesCode;
        	if ( newScope.variablesCode == null ) {
        		newScope.variablesCode = 'import json\n'
        			                    +'# compute your additional variables from the list of report items \n'
										+'# and return them as a dictionary.\n'
										+'def get_variables(items_json, scenario_run_json, step_run_output_json):\n'
										+'    items = json.loads(items_json)\n'
										+'    return {}'
        	}
        }).then(function(value) {$scope.reporter.variablesCode = value;});
    };

    if ($scope.reporter.messaging == null) {
    	$scope.reporter.messaging = {};
    }
});


app.directive("messagingVariablesBehavior", function(){
    return {
        link : function($scope, element, attrs){

            $scope.$watch("reporter.phase", function(nv, ov){
                if (nv == "START") {
                    $scope.availableVariables = [
                        { name : 'triggerName', title : 'Name of the scenario trigger'},
                        { name : 'triggerType', title : 'Type of the scenario trigger'}
                    ];
                } else if( nv == "END") {
                    $scope.availableVariables = [
                        { name : 'scenarioName', title : 'Name of the scenario'},
                        { name : 'triggerName', title : 'Name of the scenario trigger'},
                        { name : 'triggerType', title : 'Type of the scenario trigger'},

                        { name : 'outcome', title : 'Scenario result'},

                        { name : 'allEventsSummary', title : 'Textual summary of all events in the scenario'},
                        { name : 'warningsEventsSummary', title : 'Textual summary of events with warnings'},
                        { name : 'failedEventsSummary', title : 'Textual summary of failed events'},

                        { name : 'allStepsCount', title : '# of steps'},
                        { name : 'successStepsCount', title : '# of successful steps'},
                        { name : 'warningStepsCount', title : '# of steps with warning'},
                        { name : 'failedStepsCount', title : '# of failed steps'},

                        { name : 'allJobsCount', title : '# of Jobs'},
                        { name : 'successJobsCount', title : '# of successful Jobs'},
                        { name : 'warningJobsCount', title : '# of Jobs with warning'},
                        { name : 'failedJobsCount', title : '# of failed Jobs'},

                        { name : 'allBuiltDatasetsCount', title : '# of Built datasets'},
                        { name : 'successBuiltDatasetsCount', title : '# of successfully built datasets'},
                        { name : 'warningBuiltDatasetsCount', title : '# of datasets builts with warnings'},
                        { name : 'failedBuiltDatasetsCount', title : '# of failed Datasets builds'},

                        { name : 'firstFailedStepName', title : 'Name of first failed step'},
                        { name : 'firstFailedJobName', title : 'Name of first failed build job'},

                        { name : 'dssURL', title : 'URL of the DSS instance'},
                        { name : 'scenarioRunURL', title : 'URL of the scenario run report'}
                    ];
                }
            });
        }
    }
});


app.directive("scenarioIntegrationParams", function(DataikuAPI){
    return {
        scope : {
            messaging : '=',
            reporter : '=',
            availableVariables : '=',
            datasets : '=',
            managedfolders : '=',
            datasetSmartNames : '=',
            form: '='
        },
        templateUrl : '/templates/scenarios/integrations/integration-params.html',
        link : function($scope, element, attrs) {

            DataikuAPI.scenarios.listReportTemplates().success(function(data){
                $scope.reportTemplates = data;
            }).error(setErrorInScope.bind($scope));

            $scope.$watch("messaging.type", function() {
                $scope.messaging.configuration = $scope.messaging.configuration || {};
                if ($scope.messaging.type) {
                    let messaging = $scope.messaging;
                    let messagingConf = $scope.messaging.configuration;
                    switch (messaging.type) {
                        case "slack-scenario":
                            messagingConf.message = messagingConf.message || "DSS Scenario <${scenarioRunURL}|${scenarioName}>"
                                + " triggered by ${triggerName} : ${outcome} "
                                + "${if(outcome == 'SUCCESS', ':white_check_mark:', '')}"
                                + "${if(outcome == 'FAILED', ':red_circle:', '')}"
                                + "${if(outcome == 'WARNING', ':red_circle:', '')}"
                                + "${if(outcome == '' || outcome == 'N/A', ':bell:', '')}";
                            messagingConf.blocks = messagingConf.blocks || '[\n'
                                + '    {\n'
                                + '        "type": "section",\n'
                                + '        "text": {\n'
                                + '            "type": "mrkdwn",\n'
                                // Next message must be in one line.
                                + '            "text": "*DSS Scenario <${scenarioRunURL}|${scenarioName}>:* ${outcome} '
                                + '${if(outcome == \'SUCCESS\', \':white_check_mark:\', \'\')}'
                                + '${if(outcome == \'FAILED\', \':red_circle:\', \'\')}'
                                + '${if(outcome == \'WARNING\', \':red_circle:\', \'\')}'
                                + '${if(outcome == \'\' || outcome == \'N/A\', \':bell:\', \'\')}"\n'
                                + '        }\n'
                                + '    },\n'
                                + '    {\n'
                                + '        "type": "context",\n'
                                + '        "elements": [\n'
                                + '            {\n'
                                + '                "type": "mrkdwn",\n'
                                + '                "text": "Triggered by ${triggerName}"\n'
                                + '            }\n'
                                + '        ]\n'
                                + '    }\n'
                                + ']\n';
                            break;

                        case "mail-scenario":
                            messagingConf.subject = messagingConf.subject || "DSS scenario ${scenarioName}: ${outcome}";
                            messagingConf.messageSource = messagingConf.messageSource || "TEMPLATE_FILE";
                            messagingConf.templateName = messagingConf.templateName || "default.ftl";
                            messagingConf.templateFormat = messagingConf.templateFormat || "FREEMARKER";
                            break;

                        case "webhook-scenario":
                            messagingConf.method = messagingConf.method || "POST";
                            messagingConf.mime = messagingConf.mime || "application/json";
                            messagingConf.payload = messagingConf.payload || '{ "success" : "${outcome}", "addYourOwn" : "payload"}';
                            break;

                        case "msft-teams-scenario":
                            messagingConf.message = messagingConf.message ||
                                "${if(outcome == 'SUCCESS', '&#x2705;', '')}"
                                + "${if(outcome == 'FAILED', '&#x1F534;', '')}"
                                + "${if(outcome == 'WARNING', '&#x1F536;', '')}"
                                + "${if(outcome == '' || outcome == 'N/A', '&#x1F514;', '')}"
                                + " DSS Scenario [${scenarioName}](${scenarioRunURL})"
                                + " triggered by ${triggerName}: **${outcome}**";
                            break;

                        case "twilio-scenario":
                            messagingConf.message = messagingConf.message || "DSS Scenario ${scenarioName} triggered by ${triggerName}: ${outcome}";
                            break;
                    }
                }
            });
        }
    }
});


app.controller("WebhookMessagingController", function($scope, CodeMirrorSettingService) {
    $scope.mimeTypes = [
        'text/plain',
        'text/html',
        'application/json',
        'application/xml',
        'application/x-www-form-urlencoded'
    ];
    $scope.methods = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE']

    $scope.editorOptions = {
        mode : 'text/plain',
        lineNumbers : true,
        matchBrackets : false,
        onLoad : function(cm) {$scope.codeMirror = cm;}
    };

    $scope.htmlEditorOptions = CodeMirrorSettingService.get('text/html', {onLoad: function(cm) {$scope.codeMirror = cm;}});

    $scope.jsonEditorOptions = CodeMirrorSettingService.get('application/json', {onLoad: function(cm) {$scope.codeMirror = cm;}});

    $scope.xmlEditorOptions = CodeMirrorSettingService.get('application/xml', {onLoad: function(cm) {$scope.codeMirror = cm;}});
});

app.controller("MicrosoftTeamsMessagingController", function($scope, CodeMirrorSettingService) {
    $scope.jsonEditorOptions = CodeMirrorSettingService.get('application/json', {onLoad: function(cm) {$scope.codeMirror = cm;}});

});

app.controller("AttachmentsController", function($scope, $controller, $stateParams, $state, $timeout, $parse, DataikuAPI, TopNav,
		CreateModalFromTemplate, RMARKDOWN_ALL_OUTPUT_FORMATS, $rootScope) {

    $scope.messaging.configuration.attachments = $scope.messaging.configuration.attachments || [];

    var availableAttachmentTypeNames = {
        LOG:'Scenario log',
        DATASET:'Dataset data',
        FOLDER:'Folder contents',
        FOLDER_ITEM:'File in folder',
        NOTEBOOK_EXPORT:'Notebook export',
        RMARKDOWN_REPORT: 'RMarkdown report'
    };

    if ($rootScope.appConfig.graphicsExportsEnabled) {
        availableAttachmentTypeNames.DASHBOARD_EXPORT = 'Dashboard export';
        availableAttachmentTypeNames.WIKI_EXPORT = 'Wiki article export';
        availableAttachmentTypeNames.ANALYSIS_MODEL_DOCUMENTATION_EXPORT = 'Analysis model documentation export';
        availableAttachmentTypeNames.SAVED_MODEL_DOCUMENTATION_EXPORT = 'Saved model documentation export';
    }

    $scope.availableAttachmentTypes = Object.keys(availableAttachmentTypeNames);

    var availableAttachmentTypeDefaultParams = {
        RMARKDOWN_REPORT: {rmdOutputFormat: 'PDF_DOCUMENT', useLatestSnapshotIfItContainsFormat: true},
        NOTEBOOK_EXPORT: {mode: "USE_LATEST"},
        WIKI_EXPORT: {exportType: 'WHOLE_WIKI', exportFormat: { paperSize: 'A4'}},
    };

    $scope.rmdOutputFormats = RMARKDOWN_ALL_OUTPUT_FORMATS;

    $scope.removeAttachment = function(attachment) {
		var index = $scope.messaging.configuration.attachments.indexOf(attachment);
		if (index >= 0) {
			$scope.messaging.configuration.attachments.splice(index, 1);
		}
    };

    $scope.addAttachment = function(type) {
    	$scope.messaging.configuration.attachments.push({
            type:type,
            params: availableAttachmentTypeDefaultParams[type] || {}
        });
    };

    $scope.getAttachmentTypeDisplayName = function(type) {
    	return availableAttachmentTypeNames[type];
    };
});


app.controller("AttachmentController", function($scope, $rootScope, $state, $stateParams, DataikuAPI, ExportService) {
	$scope.appConfig = $rootScope.appConfig;

	var updateForType = function() {
        if ($scope.attachment.type == 'DATASET') {
            let setExportParams = function(params) {
                $scope.attachment.params.exportParams = params;
            }
            ExportService.initExportBehavior($scope, {}, {advancedSampling : true, partitionListLoader: null},
                $scope.attachment.params, null, $scope.attachment.params.exportParams, setExportParams);
        }
	};

    $scope.$watch('attachment.type', function() {
        updateForType();
    });
    updateForType();

    var updateDataset = function() {
        if ($scope.datasets && $scope.attachment.params.attachedDataset) {
            $scope.dataset = $scope.datasets.filter(function(d) {return d.name == $scope.attachment.params.attachedDataset;})[0];
        } else {
            $scope.dataset = null;
        }
    };
    $scope.$watch('attachment.params.attachedDataset', function() {
        updateDataset();
    });
    $scope.$watch(function() {return $scope.datasets != null;}, function() {
        updateDataset();
    });
    updateDataset();
});


app.controller("ReporterMessageController", function($scope, CodeMirrorSettingService) {

    $scope.editorOptions = CodeMirrorSettingService.get('text/plain', {onLoad: function(cm) {$scope.codeMirror = cm;}});

    $scope.htmlEditorOptions = CodeMirrorSettingService.get('text/html', {onLoad: function(cm) {$scope.codeMirror = cm;}});
});


app.controller("EditCustomVariablesCodeController", function($scope, CodeMirrorSettingService) {
	$scope.editorOptions = CodeMirrorSettingService.get('text/x-python', {onLoad: function(cm) {$scope.codeMirror = cm;}});

    $scope.keep = function() {
		$scope.resolveModal($scope.variablesCode);
	};
});

app.directive("newCustomPythonStepMenu", function(GlobalProjectActions, $filter){
    return {
        scope : false,
        link : function($scope, element, attrs) {
            $scope.title = attrs.title;

            var elementsByPlugin = {}

            if ( $scope.appConfig.customPythonPluginSteps ) {
                $scope.appConfig.customPythonPluginSteps.forEach(function(x){
                    var pluginSection = elementsByPlugin[x.ownerPluginId];
                    if (pluginSection == null) {
                        pluginSection = {
                                pluginId : x.ownerPluginId,
                                items : []
                        };
                        elementsByPlugin[x.ownerPluginId] = pluginSection;
                    }
                    pluginSection.items.push(x)
                });
            }

            var pluginSections = [];

            $.each(elementsByPlugin, function(pluginId, pluginData){
                var plugin = Array.dkuFindFn($scope.appConfig.loadedPlugins, function(n){
                    return n.id == pluginData.pluginId
                });
                if ( plugin == null ) return;
                pluginData.items.forEach(function(dtype){
                    if (!dtype.icon) dtype.icon = plugin.icon;
                });
                pluginSections.push({
                    plugin : plugin,
                    items : pluginData.items
                });
            });

            $scope.create = function(item) {
            };

            // flatten to put in a non-hierarchical dropdown
            var ret = [];
            pluginSections.forEach(function(pluginSection) {
                var plugin = pluginSection.plugin;
                ret.push({divider:true});
                ret.push({
                    isSection:true,
                    id : "plugin_" + plugin.id,
                    icon : plugin.icon,
                    label : plugin.label || plugin.id
                });
                pluginSection.items.forEach(function(x) {
                    ret.push({
                        type : x.stepType,
                        label : x.desc.meta != null && x.desc.meta.label != null ? x.desc.meta.label : x.ownerPluginId,
                        icon : (x.desc.meta != null ? x.desc.meta.icon : null) || plugin.icon,
                        desc : x
                    });
                });
            });

            $scope.displayedCustomPythonSteps = ret;
        }
    }
});

app.directive("newCustomPythonTriggerMenu", function(GlobalProjectActions, $filter){
    return {
        scope : false,
        link : function($scope, element, attrs) {
            $scope.title = attrs.title;

            var ret = [];

            var pluginSections = {}

            if ( $scope.appConfig.customPythonPluginTriggers ) {
                $scope.appConfig.customPythonPluginTriggers.forEach(function(x){
                    var pluginSection = pluginSections[x.ownerPluginId];
                    if (pluginSection == null) {
                        pluginSection = {
                                pluginId : x.ownerPluginId,
                                items : []
                        };
                        pluginSections[x.ownerPluginId] = pluginSection;
                    }

                    pluginSection.items.push({
                        type : x.triggerType,
                        label : x.desc.meta != null && x.desc.meta.label != null ? x.desc.meta.label : x.ownerPluginId,
                                icon : x.desc.meta != null ? x.desc.meta.icon : null,
                                        desc : x
                    })
                });
            }

            $.each(pluginSections, function(pluginId, pluginData){
                var plugin = Array.dkuFindFn($scope.appConfig.loadedPlugins, function(n){
                    return n.id == pluginData.pluginId
                });
                if ( plugin == null ) return;
                pluginData.items.forEach(function(dtype){
                    if (!dtype.icon) dtype.icon = plugin.icon;
                });
                var section = {
                        isSection : true,
                        id : "plugin_" + plugin.id,
                        icon : plugin.icon,
                        label : plugin.label || plugin.id,
                        items : pluginData.items
                    };
                // add an item to point to the doc
                section.items.splice(0, 0, {isInfo : true, pluginId : plugin.id});
                ret.push(section);
            });

            $scope.displayedItems = ret;
        }
    }
});

app.directive("mailAttachment", function(DataikuAPI){
    return {
        scope : true,
        templateUrl : '/templates/scenarios/integrations/mail-attachment.html',
        link : function($scope, element, attrs) {
        	$scope.$watch(attrs.mailAttachment, function(nv, ov) {
        		$scope.attachment = $scope.$eval(attrs.mailAttachment);
        	});
        }
    }
});


app.controller("AddToScenarioModalController", function($scope, $stateParams, $rootScope, $state, $timeout,
    DataikuAPI, CreateModalFromTemplate, TaggableObjectsUtils) {

    $scope.selectedObjects = $scope.getSelectedTaggableObjectRefs().filter(
        tor => TaggableObjectsUtils.isComputable(tor) && TaggableObjectsUtils.isLocal(tor)
    );

    $scope.commonTaggableType = TaggableObjectsUtils.getCommonType($scope.selectedObjects, it => it.type);

    $scope.options = {
        creation: false,
        action: 'build_flowitem'
    };

    $scope.fillId = function() {
        if (!$scope.options.scenarioName || $scope.options.scenarioId) return;
        $scope.options.scenarioId = $scope.options.scenarioName.replace(/\W+/g, '').toUpperCase();
    };

    $scope.add = function() {
        DataikuAPI.scenarios.addToScenario($scope.selectedObjects, $scope.options)
            .success(function() {
                $scope.resolveModal();
                $state.go('projects.project.scenarios.scenario.steps', {scenarioId: $scope.options.scenarioId}).then(function(data) {
                    // GRUIK GRUIK
                    $timeout(function(){
                        const stepScope = $('.step-list li:last-child').scope();
                        stepScope.editStep(stepScope.step);
                    }, 600);
                });
            })
            .error(setErrorInScope.bind($scope));
    };
});

app.controller("RetrieveActiveModelVersionFromDeploymentController", function($scope, DataikuAPI) {
    $scope.uiState = {
        deploymentStatusList: [],
        currentEndpoints: []
    };

    if (!$scope.step.params.variableName) {
        $scope.step.params.variableName = "activeModelVersion";
    }

    function getPackageFromCurrentDeployment(currentDeploymentStatus) {
        const generation = currentDeploymentStatus.deploymentBasicInfo.generationsMapping.entries
            .reduce((prev,current) => prev?((prev.proba > current.proba)?prev:current):current,
            { generation: "unknown", proba: -1 }).generation;
        return currentDeploymentStatus.packages.find(p => p.id === generation);
    }

    let deploymentStatusList;
    DataikuAPI.apideployer.client.listDeployments()
        .success(data => {
            deploymentStatusList = data;
            $scope.uiState.deploymentsStatusList = deploymentStatusList.map(status => status.deploymentBasicInfo.id);
            refreshEndpoints();
        })
        .error(setErrorInScope.bind($scope));

    function refreshEndpoints() {
        const deployment = deploymentStatusList.find(status => status.deploymentBasicInfo.id === $scope.step.params.deploymentId);
        if (deployment) {
            $scope.uiState.currentEndpoints = (getPackageFromCurrentDeployment(deployment) || {endpoints: []}).endpoints.map(endpoint => endpoint.id);
        } else {
            $scope.uiState.currentEndpoints = [];
        }
    }

    $scope.$watch("step.params.deploymentId", function(nv, ov) {
        if (nv === ov || !deploymentStatusList) return;
        refreshEndpoints();
    });
});

app.directive('selectAnalysisModelForm', function(DataikuAPI, ActiveProjectKey, $filter) {
    function getAnalysisModelDescription(modelVersion) {
        let details = [];
        modelVersion.auc && details.push("AUC : " + modelVersion.auc.toFixed(3));
        modelVersion.silhouette && details.push("Silhouette : " + modelVersion.silhouette.toFixed(3));
        if (modelVersion.trainInfo.state == 'DONE' && modelVersion.trainInfo.endTime) {
            details.push("Done " + $filter('friendlyTimeDelta')(modelVersion.trainInfo.endTime)
            + " (" + $filter("friendlyDate")(modelVersion.trainInfo.endTime, 'yyyy-MM-dd HH:mm:ss') +")");
        }
        return details.join(', ');
    }

    function getModelSnippetsAPI(taskType) {
        switch(taskType) {
            case "CLUSTERING": return DataikuAPI.analysis.cml.getModelSnippets;
            case "PREDICTION": return DataikuAPI.analysis.pml.getModelSnippets;
            default : return null;
        }
    }

    return {
        scope: {
            params: '=',
        },
        templateUrl: '/templates/scenarios/fragments/select-analysis-model-form.html',
        link: ($scope, element, attrs, formCtrl) => {
            $scope.hooks = {mlTask: null};
            $scope.mlTasks = [];

            function cleanVersions() {
                $scope.models = [];
                $scope.descriptions = [];
            }
            function cleanMLTask() {
                cleanVersions();
                $scope.hooks.mlTask = null;
            }
            function cleanAll() {
                cleanMLTask();
                $scope.mlTasks = [];
            }

            function getMLTasks(analysisId) {
                analysisId && DataikuAPI.analysis.getSummary(ActiveProjectKey.get(), analysisId, true)
                .success(data => {
                    $scope.mlTasks = data.mlTasks;
                    setMLTask($scope.params.mlTaskId)
                })
                .error(setErrorInScope.bind($scope));
            }

            function setMLTask(mlTaskId) {
                if (!mlTaskId) return;

                const mlTask = $scope.hooks.mlTask
                if (mlTask && mlTask.mlTaskId == mlTaskId) return; // hooks.mlTask already has expected value

                const result = $scope.mlTasks.filter(m => m.mlTaskId == mlTaskId);
                if (result && result.length) $scope.hooks = {mlTask: result[0]};
            }

            function getAnalysisModels(analysisId, mlTaskId, mlTaskType) {
                const getModelSnippets = getModelSnippetsAPI(mlTaskType);
                if (!mlTaskId || !getModelSnippets) return;

                $scope.params.mlTaskType = mlTaskType;
                $scope.params.mlTaskId = mlTaskId;

                getModelSnippets(ActiveProjectKey.get(), analysisId, mlTaskId)
                .success(data => {
                    const defaultModel = {userMeta: {name: 'Latest version'}, fullModelId: "LATEST_VERSION"};
                    let modelDescriptions = ['Always select the latest version trained'];

                    $scope.models = Object.values(data)
                    .filter(m => m.trainInfo.state == "DONE")
                    .sort((a,b) => b.trainInfo.endTime - a.trainInfo.endTime);

                    $scope.models.forEach(v => {
                        v.userMeta.name += " - Session " + v.sessionId.replace("s","");
                        modelDescriptions.push(getAnalysisModelDescription(v));
                    });
                    $scope.models.unshift(defaultModel);
                    $scope.descriptions = modelDescriptions;
                })
                .error(setErrorInScope.bind($scope.$parent));
            }

            $scope.$watch('params.analysisId', a => a? getMLTasks(a) : cleanAll());
            $scope.$watch('params.mlTaskId', mlTaskId => mlTaskId? setMLTask(mlTaskId) : cleanMLTask());
            $scope.$watch('hooks.mlTask', m =>
                m? getAnalysisModels($scope.params.analysisId, m.mlTaskId, m.taskType) : cleanVersions());
        }
    }
});

app.directive('selectSavedModelVersionForm', function(DataikuAPI, $filter) {
    const DEFAULT_VERSIONS = [
        {label:'Active version', fullModelId: 'ACTIVE_VERSION'},
        {label:'Latest version', fullModelId: 'LATEST_VERSION'}
    ];
    const DEFAULT_DESCRIPTIONS = ['Always select the active version', 'Always select the latest version trained'];

    function getModelStatusAPI(taskType) {
        switch(taskType) {
            case "CLUSTERING": return DataikuAPI.savedmodels.clustering.getStatus;
            case "PREDICTION": return DataikuAPI.savedmodels.prediction.getStatus;
            default : return null;
        }
    }

    function getModelVersionDescription(version) {
        let details = [];
        const v = version.snippet;
        v.auc && details.push("AUC : " + v.auc.toFixed(3));
        v.silhouette && details.push("Silhouette : " + v.silhouette.toFixed(3));
        if (v.trainInfo.state == 'DONE' && v.trainInfo.endTime) {
            details.push("Done " + $filter('friendlyTimeDelta')(v.trainInfo.endTime)
            + " (" + $filter("friendlyDate")(v.trainInfo.endTime, 'yyyy-MM-dd HH:mm:ss') +")");
        }
        version.active && details.push("Active version");
        return details.join(', ');
    }

    return {
        scope: {
            params: '=',
        },
        templateUrl: '/templates/scenarios/fragments/select-saved-model-version-form.html',
        link: ($scope, element, attrs, formCtrl) => {
            function cleanVersions() {
                $scope.versions = [];
                $scope.descriptions = [];
            }

            function getModelVersions(projectKey, modelId, subType) {
                const getModelStatus = getModelStatusAPI(subType);
                if (!projectKey || !modelId || !getModelStatus) return;

                $scope.params.mlTaskType = subType;

                getModelStatus(projectKey, modelId)
                .success(data => {
                    let versions = [...DEFAULT_VERSIONS];
                    let modelDescriptions = [...DEFAULT_DESCRIPTIONS];

                    data.versions
                        .filter(m => m.snippet.trainInfo.state == "DONE")
                        .sort((a,b) => b.snippet.trainInfo.endTime - a.snippet.trainInfo.endTime)
                        .forEach(v => {
                            versions.push({
                                label: v.snippet.userMeta.name,
                                fullModelId: v.snippet.fullModelId
                            })
                            modelDescriptions.push(getModelVersionDescription(v));
                        });

                    $scope.versions = versions;
                    $scope.descriptions = modelDescriptions;
                })
                .error(setErrorInScope.bind($scope.$parent));
            }

            $scope.$watch('hooks.model', val => val? getModelVersions(val.projectKey, val.id, val.subtype) : cleanVersions());
        }
    }
});

app.directive('selectMdgTemplateForm', function(DataikuAPI, ActiveProjectKey) {
    return {
        scope: {
            params: '=',
        },
        templateUrl: '/templates/scenarios/fragments/select-mdg-template-form.html',
        link: ($scope, element, attrs, formCtrl) => {
            function getFiles(folderSmartId) {
                $scope.files = [];
                folderSmartId && DataikuAPI.managedfolder.listFS(ActiveProjectKey.get(), folderSmartId)
                .success(function(data){
                    $scope.files = data.items.filter(f => f.path.match(/.docx$/));
                })
                .error(setErrorInScope.bind($scope.$parent));
            }
            $scope.$watch("params.sourceFolderId", getFiles);
        }
    }
});

app.directive('modelDocumentationExportForm', function() {
    return {
        scope: {
            params: '=',
            type: '@'
        },
        templateUrl: '/templates/scenarios/fragments/model-documentation-export-form.html'
    }
});

app.directive('modelDocumentationExportResult', function() {
    const fmiInfo = {
        TYPE : 0, // 'A' for ANALYSIS or 'S' for SAVED_MODEL
        MODEL_PROJECT_KEY : 1,
        MODEL_ID : 2,
        ML_TASK : 3,
    };
    return {
        scope: {
            reportItem: '<',
        },
        templateUrl: '/templates/scenarios/fragments/model-documentation-export-result.html',
        link: ($scope) => {
            // Split fullModelId and parse result to get details
            const data = $scope.reportItem.fullModelId.split('-');
            $scope.reportType = data[fmiInfo.TYPE];
            $scope.modelProjectKey = data[fmiInfo.MODEL_PROJECT_KEY];
            $scope.modelId = data[fmiInfo.MODEL_ID];
            if ($scope.reportType == 'A') $scope.mlTaskId = data[fmiInfo.ML_TASK];
        }
    }
});

})();

(function(){
'use strict';

var app = angular.module('dataiku.monitoring',[]);

app.controller("ScenariosMonitoringController", function($scope, TopNav, $stateParams) {
    TopNav.setItem(TopNav.ITEM_MONITORING, "scenarios", { name: "Scenario runs", id: null });
    TopNav.setLocation(TopNav.TOP_JOBS, "monitoring", TopNav.TABS_MONITORING, "outcomes");

    $scope.projectSummaryMap = {};
    $scope.$watch("projectSummary", function() {
        if (!$scope.projectSummary) return;
        $scope.projectSummaryMap[$stateParams.projectKey] = $scope.projectSummary;
    });
});

app.controller("ScenarioTimelineControllerCommon", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate, WT1) {

	$scope.report = null;

	$scope.reportRange = {from : 0, to : 0};

    $scope.uiState = {viewMode : 'TIMELINE', viewDetails : 'STEP', stepQuery : null};

	$scope.setScenarioGantt = function(data) {
        $scope.report = data;
        $scope.topItems = [];
        if ( $scope.report == null ) return;

        // organizing items in a tree
        computeTopItems();

        // sort a bit the sub items
        var cmpItem = function(a,b) {
            var prefixForOrder = function(type) {
                if ( type == 'SCENARIO_TRIGGER') {
                    return '0';
                } else if ( type == 'JOB_EXECUTED') {
                    return '1';
                } else {
                    return '2' + type;
                }
            }
            var aType = prefixForOrder(a.target.type || '');
            var bType = prefixForOrder(b.target.type || '');
            return aType.localeCompare(bType);
        };
        $scope.report.items.forEach(function(item) {
            if ( item.subItems ) {
                item.subItems.sort(cmpItem);
            }
        });

        // expansion
        if ($scope.uiState.viewDetails == 'SCENARIO') {
            $scope.expandToScenario();
        } else if ($scope.uiState.viewDetails == 'STEP') {
            $scope.expandToStep();
        } else if ($scope.uiState.viewDetails == 'DETAILS') {
            $scope.expandToDetails();
        }

        // get the top-level actions for the brush

        // prepare access to row by id
        var topRowById = {};
        $scope.topItems.forEach(function(row) {topRowById[row.uniqueId] = row;}); // based on topItems and not just rows
        // get actions of these top rows
        $scope.topActions = [];
        $scope.report.columns.map(function(column) {
            angular.forEach(column.actions, function(columnActions, uniqueId) {
                if ( uniqueId in topRowById && columnActions.length > 0 ) {
                    var action = columnActions[0];
                    // use start/end from column because that's what used when filtering in gantt and runs view
                    $scope.topActions.push({start:column.start, end:column.end, outcome:action.outcome})
                }
            });
        });
        $scope.topActions.sort(function(a, b) {return a.start - b.start;})

        if ( $scope.report.key.from > $scope.reportRange.to || $scope.report.key.to < $scope.reportRange.from ) {
            // replace range
            $scope.reportRange.from = $scope.report.key.from;
            $scope.reportRange.to = $scope.report.key.to;
        } else {
            // clip range
            $scope.reportRange.from = $scope.report.key.from > $scope.reportRange.from ? $scope.report.key.from : $scope.reportRange.from;
            $scope.reportRange.to = $scope.report.key.to < $scope.reportRange.to ? $scope.report.key.to : $scope.reportRange.to;
        }
    };

    // rows in the graph
    var refreshRows = function() {
        $scope.rows = [];
        if ( $scope.topItems == null ) return;
        if ( $scope.uiState.viewMode == 'TIMELINE' ) {
        	// filter by scenario name, and only on top level
        	var recRefreshRows = function(item, depth) {
        		item.depth = depth;
                $scope.rows.push(item);
        		if ( item.expanded && item.subItems && item.subItems.length > 0) {
        		    // merge triggers on same row
        		    var triggerItems = item.subItems.filter(function(i) {return i.target.type == 'SCENARIO_TRIGGER'});
        		    if ( triggerItems.length > 1 ) { // otherwise no merging is needed
        		        var mergeTargetId = triggerItems[0].uniqueId;
        		        for (var i=1;i<triggerItems.length;i++) {
        		            triggerItems[i].displayOnRow = mergeTargetId;
        		        }
        		    }
        			item.subItems.forEach(function(subItem) {recRefreshRows(subItem, depth + 1);});
        		}
        	};
        	$scope.topItems.forEach(function(item) {if ( $scope.scenarioSearch(item) ) {recRefreshRows(item, 0);}});
        } else {
        	// filter by selected scenario, then expand all, and filter by step name
        	var recRefreshRows = function(item, depth) {
    			item.depth = depth;
    			$scope.rows.push(item);
    			if ( item.expanded && item.subItems && item.subItems.length > 0) {
    				item.subItems.forEach(function(subItem) {recRefreshRows(subItem, depth + 1);});
    			}
        	};
        	var acceptsScenario = function(item) {return $scope.uiState.scenario == null || $scope.uiState.scenario == item;};
        	$scope.topItems.forEach(function(item) {if ( acceptsScenario(item) ) {recRefreshRows(item, 0);}});
        	$scope.rows = $scope.rows.filter(function(item) {return $scope.stepSearch(item);});
        }
    };

    $scope.scenarioSearch = function(column) { return searchInTargetAndInfo(column, $scope.uiState.scenarioQuery); };
    $scope.stepSearch = function(column) { return searchInTargetAndInfo(column, $scope.uiState.stepQuery); };


    // update the displayed rows whenever an "expanded" flag changed, and since all items
    // are descendant of the top items, a single recursive $watch suffices
    $scope.$watch("topItems", function(nv, ov) {
        refreshRows();
    }, true);

    $scope.$watch("uiState", function(nv, ov) {
        refreshRows();
    }, true);

    /*
     * Quick views: scenario - step - details
     */

    $scope.expandToScenario = function() {
        $scope.topItems.forEach(function(item) {item.expanded = false;});
    };

    $scope.expandToStep = function() {
        $scope.topItems.forEach(function(item) {
            item.expanded = true;
            if ( item.subItems && item.subItems.length > 0) {
                item.subItems.forEach(function(subItem) {subItem.expanded = false;});
            }
        });
    };

    $scope.expandToDetails = function() {
        $scope.topItems.forEach(function(item) {
            item.expanded = true;
            if ( item.subItems && item.subItems.length > 0) {
                item.subItems.forEach(function(subItem) {subItem.expanded = true;});
            }
        });
    };

    /*
     * Organizing items in a tree
     */
    var computeTopItems = function() {
        var itemById = {};
        $scope.report.items.forEach(function(item) {
            itemById[item.uniqueId] = item;
            item.subItems = null;
            item.expanded = false;
        });
        $scope.report.items.forEach(function(item) {
            if ( item.parentId == null ) {
                // top item, add it under the root
                $scope.topItems.push(item);
            } else {
                var parent = itemById[item.parentId];
                if ( parent == null ) {
                    $scope.topItems.push(item);
                } else {
                    if ( parent.subItems == null ) {
                        parent.subItems = [];
                    }
                    parent.subItems.push(item);
                }
            }
        });
    }

});

app.controller("TimelineController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate, WT1) {
	$controller('ScenarioTimelineControllerCommon', {$scope: $scope});

	$scope.scenarioId = $stateParams.scenarioId;

	// in a uiState object because the search field in below a ng-if and thus in another scope
    angular.extend($scope.uiState, {scenarioQuery: $stateParams.scenarioQuery, scenario: null});
	$scope.pickerFormat = 'YYYY-MM-DD HH:mm';
    $scope.backendFormat = "YYYY-MM-DDTHH:mm:ss.SSS";

    var rangeEnd = moment().add(1, 'hour').startOf('hour');
    if ( $stateParams.scopeToDay ) {
        rangeEnd = moment($stateParams.scopeToDay, "YYYY-MM-DD").add(1, 'days');
    }
    $scope.ganttRange = {from : moment(rangeEnd).subtract(1, 'days').format($scope.pickerFormat), to : moment(rangeEnd).format($scope.pickerFormat)};

    $scope.refreshScenarioGantt = function() {
        WT1.event("refresh-scenarios-gantt");
        var rangeFromTs = moment($scope.ganttRange.from, $scope.pickerFormat).utc();
        var rangeToTs = moment($scope.ganttRange.to, $scope.pickerFormat).utc();
        if ( $scope.scenarioId ) {
            DataikuAPI.scenarios.getScenarioReport($stateParams.projectKey, $scope.scenarioId, rangeFromTs.format($scope.backendFormat) + 'Z', rangeToTs.format($scope.backendFormat) + 'Z').success(function(data){
                $scope.setScenarioGantt(data);
            }).error(setErrorInScope.bind($scope));
        } else if ( $stateParams.projectKey ) {
            DataikuAPI.scenarios.getProjetReport($stateParams.projectKey, rangeFromTs.format($scope.backendFormat) + 'Z', rangeToTs.format($scope.backendFormat) + 'Z').success(function(data){
                $scope.setScenarioGantt(data);
            }).error(setErrorInScope.bind($scope));
        } else {
            DataikuAPI.scenarios.getInstanceReport(rangeFromTs.format($scope.backendFormat) + 'Z', rangeToTs.format($scope.backendFormat) + 'Z').success(function(data){
                $scope.setScenarioGantt(data);
            }).error(setErrorInScope.bind($scope));
        }
    };

    $scope.$watch("ganttRange.from", function(nv, ov) {
        if ( nv == null || ov == nv ) return;
        $scope.refreshScenarioGantt();
    });
    $scope.$watch("ganttRange.to", function(nv, ov) {
        if ( nv == null || ov == nv ) return;
        $scope.refreshScenarioGantt();
    });

    if ( $scope.scenarioId ) {
        $scope.refreshScenarioGantt();
    }

    $scope.brushChanged = function() {
        $scope.$digest();
    };
    $scope.brushDrillDown = function(from, to) {
        $scope.shrinkRange(from, to);
        // finally, set angular loose
        $scope.$digest();
    };
    $scope.shrinkRange = function(from, to) {
        $scope.ganttRange.from = moment(from).startOf('hour').format($scope.pickerFormat);
        var roundedTo = moment(to).startOf('hour');
        if ( to != roundedTo.valueOf()) {
            roundedTo = roundedTo.add(1, 'hour')
        }
        $scope.ganttRange.to = roundedTo.format($scope.pickerFormat);
        $scope.reportRange.from = $scope.ganttRange.from;
        $scope.reportRange.to = $scope.ganttRange.to;
    };

    $scope.getActions = function(item) {
        var actions = [];
        if ( $scope.report && $scope.report.columns ) {
            $scope.report.columns.forEach(function(column) {
                if ( item.uniqueId in column.actions ) {
                    actions = actions.concat(column.actions[item.uniqueId]);
                }
            });
        }
        return actions;
    };
});

function searchInTargetAndInfo(item, query) {
    if (!query) return true;
    if (!item) return false;
    query = query.toLowerCase();
    for (var k in item.target) {
        var v = item.target[k];
        if (typeof v == 'string') {
            if (v.toLowerCase().indexOf(query) >= 0) return true;
        }
    }
    for (var k in item.info) {
        var v = item.info[k];
        if (typeof v == 'string') {
            if (v.toLowerCase().indexOf(query) >= 0) return true;
        }
    }
    return false;
}

app.controller("ActivitiesViewController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate, WT1) {
    var pickerFormat = 'YYYY-MM-DD HH:mm';
    var backendFormat = "YYYY-MM-DDTHH:mm:ss.SSS";
    var nextHour = moment().add(1, 'hour').startOf('hour');
    $scope.activitiesRange = {from : moment(nextHour).subtract(1, 'days').format(pickerFormat), to : moment(nextHour).format(pickerFormat)};

    $scope.refreshActivities = function() {
        WT1.event("refresh-scenarios-activities");
        var rangeFromTs = moment($scope.activitiesRange.from, pickerFormat).utc();
        var rangeToTs = moment($scope.activitiesRange.to, pickerFormat).utc();
        DataikuAPI.scenarios.getProjetActivities($stateParams.projectKey, rangeFromTs.format(backendFormat) + 'Z', rangeToTs.format(backendFormat) + 'Z').success(function(data){
            $scope.activities = data;
        }).error(setErrorInScope.bind($scope));
    };
    $scope.$watch("activitiesRange.from", function(nv, ov) {
        if ( nv == null || ov == nv ) return;
        $scope.refreshActivities();
    });
    $scope.$watch("activitiesRange.to", function(nv, ov) {
        if ( nv == null || ov == nv ) return;
        $scope.refreshActivities();
    });

    // search filters (functions because we search specific fields inside the objects)
    $scope.datasetQuery = null;
    $scope.datasetSearch = function(splitRow) { return searchInTargetAndInfo(splitRow.row, $scope.datasetQuery); };
    $scope.scenarioQuery = null;
    $scope.scenarioSearch = function(column) { return searchInTargetAndInfo(column && column.scenario, $scope.scenarioQuery); };

    $scope.adjustForScroll = {left : 0, top : 0};

    $scope.refreshActivities();
});

app.controller("OutcomesBaseController", function($scope, Fn) {
    $scope.fixupOutcomes = function(columns, nbDays) {
        if(typeof(nbDays) === 'undefined') {
            nbDays = 31;
        }
        if (!columns.length) return;
        // fixup: make sure there are >=31 columns, since the view is set to display 31 columns
        var minDateStr = columns[0].date;
        columns.forEach(function(column) {minDateStr = minDateStr < column.date ? minDateStr : column.date;});
        var minDate = moment(minDateStr, 'YYYY-MM-DD');
        while (columns.length < nbDays) {
            minDate = minDate.subtract(1, 'days');
            columns.unshift({date: minDate.format('YYYY-MM-DD'), actions: {}});
        }
        // fixup: add day of week
        columns.forEach(function(column) {
            var dt = moment(column.date, 'YYYY-MM-DD');
            column.dow = dt.weekday();
            column.dateFormatted = dt.format("D/M");
            column.dateDay = dt.format("ddd");
        });
    };

    $scope.getCellGlobalOutcome = function(actions) {
        if ( actions == null || actions.length == 0 ) return null;
        const outcomes = actions.map(_ => _.outcome.toLowerCase());
        function hasOutcome(outcome) {
            return outcomes.includes(outcome.toLowerCase());
        }
        if (hasOutcome('FAILED'))  return 'failed';
        if (hasOutcome('WARNING')) return 'warning';
        if (hasOutcome('SUCCESS')) return 'success';
        return 'aborted';
    }

    $scope.getSummaryCellGlobalOutcome = function(summary) {
        if (summary.FAILED) return 'failed';
        if (summary.WARNING) return 'warning';
        if (summary.SUCCESS) return 'success';
        return 'aborted';
    }

    $scope.hovered = {date : null, row : null};
    $scope.selected = {column : null, row : null};
});

app.controller("OutcomesViewController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, ScenarioUtils, CreateModalFromTemplate, WT1) {
    $controller('OutcomesBaseController', {$scope: $scope});

    var selectedElement = null;
    var pickerFormat = 'YYYY-MM-DD';
    var backendFormat = "YYYY-MM-DD";
    var nextHour = moment().add(1, 'hour').startOf('hour');
    $scope.outcomesRange = {from : moment(nextHour).subtract(30, 'days').format(pickerFormat), to : moment(nextHour).format(pickerFormat)};

    $scope.projectKey = $stateParams.projectKey;
    $scope.scenarioId = $stateParams.scenarioId;

    $scope.reportRange = {from : 0, to : 0}
    $scope.displayedColumns = [];

    $scope.refreshOutcomes = function() {
        WT1.event("refresh-scenarios-outcomes");
        // send time as is, so that the backend get the day range inputted by the user
        var rangeFromTs = moment($scope.outcomesRange.from, pickerFormat);
        var rangeToTs = moment($scope.outcomesRange.to, pickerFormat);
        DataikuAPI.scenarios.getOutcomes(rangeFromTs.format(backendFormat), rangeToTs.add(1, 'days').format(backendFormat), $scope.projectKey, $scope.scenarioId).success(function(data){
            $scope.outcomes = data;
            $scope.fixupOutcomes(data.columns);
            // refresh displayed range
//            if ( $scope.outcomes.key.from > $scope.reportRange.to || $scope.outcomes.key.to < $scope.reportRange.from ) {
                // replace range
                $scope.reportRange.from = $scope.outcomes.key.from;
                $scope.reportRange.to = $scope.outcomes.key.to;
//            } else {
//                // clip range
//                $scope.reportRange.from = $scope.outcomes.key.from > $scope.reportRange.from ? $scope.outcomes.key.from : $scope.reportRange.from;
//                $scope.reportRange.to = $scope.outcomes.key.to < $scope.reportRange.to ? $scope.outcomes.key.to : $scope.reportRange.to;
//            }
            $scope.refreshDisplayedColumns();
        }).error(setErrorInScope.bind($scope));
    };
    $scope.$watch("outcomesRange.from", function(nv, ov) {
        if ( nv == null || ov == nv ) return;
        $scope.refreshOutcomes();
    });
    $scope.$watch("outcomesRange.to", function(nv, ov) {
        if ( nv == null || ov == nv ) return;
        $scope.refreshOutcomes();
    });

    $scope.refreshDisplayedColumns = function() {
        if ( $scope.outcomes == null || $scope.outcomes.columns == null || $scope.reportRange == null ) {
            $scope.displayedColumns = null;
        } else {
            var startDate = moment($scope.reportRange.from).format('YYYY-MM-DD');
            var endDate = moment($scope.reportRange.to).format('YYYY-MM-DD');
            $scope.displayedColumns = $scope.outcomes.columns.filter(function(column) {return column.date >= startDate && column.date <= endDate});
        }
    };
    $scope.$watch('reportRange', function(nv) {
        if ( nv == null ) return;
        $scope.refreshDisplayedColumns();
    }, true);

    $scope.scenarioQuery = null;
    $scope.scenarioSearch = function(row) { return searchInTargetAndInfo(row, $scope.scenarioQuery); };

    $scope.refreshOutcomes();

    $scope.brushChanged = function() { $scope.$digest(); };

    $scope.hover = function(evt, column, row, localScope) {
        $scope.hovered.date = column.date;
        $scope.hovered.row = row;
        $scope.hovered.actions = row ? column.actions[row.uniqueId] : null;
    };
    $scope.unhover = function(evt, column, row, localScope) {
        $scope.hovered.date = null;
        $scope.hovered.row = null;
        $scope.hovered.actions = null;
    };
    $scope.select = function(evt, column, row, localScope) {
        $scope.selected = {column : column, row : row, formattedDate : moment(column.date).format('dddd, MMMM Do')};
        if(selectedElement) selectedElement.classList.remove('active');
        selectedElement = evt.currentTarget;
        selectedElement.classList.add('active');
    };

    $scope.scenarioIsActive = function(scenarioRow) {
        return scenarioRow.info.active && !ScenarioUtils.getAutoTriggerDisablingReason($scope.appConfig, [$scope.projectSummaryMap[scenarioRow.target.projectKey]]);
    }

    var selectedTarget = null;
    var selectedTargetDate = null;
    $scope.$watch('selected', function() {
        if ( $scope.selected == null || $scope.selected.row == null || $scope.selected.row.target == null ) {
            $scope.selected.scenario = null;
            selectedTarget = null;
            selectedTargetDate = null;
        } else {
            var newSelectedTarget = $scope.selected.row.target;
            var newSelectedTargetDate = moment($scope.selected.column.date).format('YYYY-MM-DD');
            if (newSelectedTarget != selectedTarget || newSelectedTargetDate != selectedTargetDate) {
                selectedTarget = newSelectedTarget;
                selectedTargetDate = newSelectedTargetDate;
                DataikuAPI.scenarios.getOutcomesDetails(selectedTarget.projectKey, selectedTarget.scenarioId, selectedTargetDate).success(function(data){
                    $scope.selected.scenario = data;
                }).error(setErrorInScope.bind($scope));
            } else {
                // no change, don't bother re-fetching
            }
        }
    }, true);
});

app.directive('outcomeCells', function($filter, $timeout) {
    return {
        restrict : 'A',
        scope : true,
        link : function($scope, element, attrs) {
            var hoverCells = [];
            var refreshCells = function() {
                var rows = $scope.$eval(attrs.ngModel);
                var columns = $scope.displayedColumns;
                if (rows == null || columns == null) return;
                if ($scope.scenarioSearch) {
                    rows = $filter('filter')(rows, $scope.scenarioSearch);
                }
                element.empty();
                hoverCells.splice(0,hoverCells.length);
                rows.forEach(function(row) {
                    var rowElement = $(document.createElement("li"));
                    columns.forEach(function(column) {
                        var cellElement = $(document.createElement("div"));
                        // style the cell container
                        cellElement.addClass('cell');
                        cellElement.addClass('clickable');
                        if (angular.equals({}, row)) {
                            cellElement.addClass('empty-row');
                        }
                        if (column.dow == 6 || column.dow == 0) {
                            cellElement.addClass('weekend');
                        }
                        cellElement.css({'width' : (100 / columns.length) + '%'});
                        // put the outcome bar if there is one
                        var cellOutcome = $scope.getCellGlobalOutcome(column.actions[row.uniqueId]);
                        
                        if (cellOutcome) {
                            var lineElement = $(document.createElement("div"));
                            lineElement.addClass('line');
                            lineElement.addClass(cellOutcome);
                            cellElement.append(lineElement);
                        }
                        // add the div to make the hover, hidden by default
                        var hoverElement = $(document.createElement("div"));
                        hoverElement.addClass('fh');
                        hoverElement.addClass('hover-active');
                        hoverElement.addClass('ng-hide');
                        cellElement.append(hoverElement);
                        hoverElement.__row = row;
                        hoverElement.__column = column;
                        hoverCells.push(hoverElement);
                        // add listeners to update the hoverposition
                        cellElement.on('mouseenter', function($event) {$scope.hover($event, column, row, $scope); $timeout(function(){$scope.$digest();});});
                        cellElement.on('mouseleave', function($event) {$scope.unhover($event, column, row, $scope); $timeout(function(){$scope.$digest();});});
                        cellElement.on('click', function($event) {$scope.select($event, column, row, $scope); $timeout(function(){$scope.$digest();});});

                        rowElement.append(cellElement);
                    });
                    rowElement.__row = row;
                    element.append(rowElement);
                });
            };
            var updateHover = function() {
                if (!hoverCells || !$scope.hovered) return;
                hoverCells.forEach(function(hoverCell) {
                   var shown = $scope.hovered.date == hoverCell.__column.date || $scope.hovered.row == hoverCell.__row;
                   if (shown) {
                       if (hoverCell.hasClass('ng-hide')) {
                           hoverCell.removeClass('ng-hide');
                       }
                   } else {
                       if (!hoverCell.hasClass('ng-hide')) {
                           hoverCell.addClass('ng-hide');
                       }
                   }
                });
            };
            $scope.$watch('hovered', updateHover, true);
            $scope.$watch('displayedColumns', refreshCells);
            $scope.$watch(attrs.ngModel, refreshCells, true);
            $scope.$watch('uiState.scenarioQuery', refreshCells, true);
            $scope.$watch('scenarioQuery', refreshCells, true);
        }
    };
});


app.controller("TriggersViewController", function($scope, $controller, DataikuAPI, ActivityIndicator, WT1, Fn) {
    $controller('_TaggableObjectsListPageCommon', {$scope: $scope});
    $scope.listItemType = 'SCENARIO';

    $scope.noTags = true;
    $scope.noStar = true;
    $scope.noWatch = true;
    $scope.sortBy = [
        { value: 'projectKeyAndScenarioName', label: 'Scenario' },
        { value: 'nextRunForSort', label: 'Next planned run' },
        { value: 'activeForSort', label: 'Active' }
    ];
    $scope.selection = $.extend({
        filterQuery: {
            userQuery: '',
            interest: {
                starred: '',
            },
        },
        filterParams: {
            userQueryTargets: ["projectKey","name","tags"],
            propertyRules: {tag:"tags"},
        },
        orderQuery: "projectKeyAndScenarioName",
        orderReversed: false,
    }, $scope.selection || {});
    $scope.sortCookieKey = 'scenarios';
    $scope.maxItems = 20;

    $scope.list = function() {
        WT1.event("refresh-scenarios-list");
        DataikuAPI.scenarios.listAllHeads().success(function(data){
            $scope.scenarios = data;
            $scope.listItems = data.items;
            $scope.listItems.forEach(function(x){
                x.projectKeyAndScenarioName =  x.projectKey + "$$$" + x.name;
                x.activeForSort = (x.active ? "A" : "Z") + "$$$" + x.projectKey + "$$$" + x.name;
                x.nextRunForSort = x.nextRun == 0 ? 900719925474099 : x.nextRun;
                // Make all non-active scenarios appear after active ones, but still before NA ones
                if (!x.active) x.nextRunForSort += (86400*365*1000);
            })
        }).error(setErrorInScope.bind($scope));
    };
    $scope.list() ;

    /* Specific actions */
    $scope.goToItem = function(data) {};

    $scope.toggleActive = function(scenario) {
        WT1.event("scenario-save-active");
        var message = scenario.active ? 'Activate ' : 'Deactivate ';
        message = message + 'auto-triggers of ' + scenario.projectKey + '.' + (scenario.name || scenario.id);
        DataikuAPI.scenarios.saveNoParams(scenario.projectKey, scenario, {commitMessage:message}).success(function(data){
            // save the expanded states
            ActivityIndicator.success("Saved");
        }).error(setErrorInScope.bind($scope));
    };

    $scope.massAutoTriggers = true;
    $scope.allAutoTriggers = function(objects) {
        if (!objects || !objects.length) return;
        return objects.filter(_ => !$scope.getAutoTriggerDisablingReason($scope.appConfig, $scope.projectSummaryMap[_.projectKey])).every(_ => _.active);
    };

    $scope.allAutoTriggersDisabled = function(objects) {
        if (!objects || !objects.length) return;
        const uniqueProjectSummaries = objects.reduce((obj, scenario) => ({...obj, [scenario.projectKey]: $scope.projectSummaryMap[scenario.projectKey]}), {});
        return $scope.getAutoTriggerDisablingReason($scope.appConfig, Object.values(uniqueProjectSummaries));
    };

    $scope.autoTriggersObjects = function(autoTriggerStatus, objects) {
        objects.forEach(function(object) {
            if (!$scope.getAutoTriggerDisablingReason($scope.appConfig, $scope.projectSummaryMap[object.projectKey])
                && object.active !== autoTriggerStatus) {
                object.active = autoTriggerStatus;
                $scope.toggleActive(object);
            }
        });
    };

    $scope.toggleAutomationLocal = function(scenario) {
        //scenario.active = !scenario.active;
        WT1.event("scenario-save-automationLocal");
        DataikuAPI.scenarios.saveNoParams(scenario.projectKey, scenario, {}).success(function(data){
            // save the expanded states
            ActivityIndicator.success("Saved");
        }).error(setErrorInScope.bind($scope));
    };

    $scope.runNow = function(scenario) {
        WT1.event("scenario-manual-run-from-list");
        DataikuAPI.scenarios.manualRun(scenario.projectKey, scenario.id)
        .success(function(data){})
        .error(setErrorInScope.bind($scope));
    };
});

app.controller("ReportersViewController", function($scope, $controller, DataikuAPI, ActivityIndicator, Dialogs, WT1) {
    $controller('_TaggableObjectsListPageCommon', {$scope: $scope});
    $scope.listItemType = 'SCENARIO';

    $scope.hidePreviewColumn = true;
    $scope.noTags = true;
    $scope.noStar = true;
    $scope.noWatch = true;
    $scope.massDelete = true;
    $scope.massReporters = true;
    $scope.noDelete = true;

    $scope.sortBy = [
        { value: 'projectKey', label: 'Project name' },
        { value: 'scenarioName', label: 'Scenario name' },
        { value: 'reporterName', label: 'Reporter name' },
        { value: 'reporterType', label: 'Reporter type' },
        { value: 'reporterActive', label: 'Active' }
    ];
    $scope.selection = $.extend({
        filterQuery: {
            userQuery: '',
            interest: {
                starred: '',
            },
        },
        filterParams: {
            userQueryTargets: ["projectKey", "name", "tags", "reporterName", "reporterType", "reporterProps"],
            propertyRules: { tag: "tags" },
        },
        orderQuery: "scenarioName",
        orderReversed: false,
    }, $scope.selection || {});
    $scope.sortCookieKey = 'scenarios-with-reporters';
    $scope.maxItems = 100;

    $scope.list = () => {
        WT1.event("refresh-scenarios-with-reporters-list");
        DataikuAPI.scenarios.listAllReporters().success((data) => {
            $scope.scenarios = data;
            $scope.listItems = [];
            data.items.forEach(item => {
                item.scenarioName =  item.name;
                item.activeForSort = (item.active ? "A" : "Z") + "$$$" + item.projectKey + "$$$" + item.name;
                item.autoTriggers = item.active;

                item.reporterDigestItems.forEach(reporter => {
                    $scope.listItems.push({
                        ...item,
                        reporter,
                        reporterName: reporter.name,
                        reporterType: formatReporterName(reporter.messagingType),
                        reporterProps: reporter.properties,
                        reporterActive: reporter.active
                    });
                });
            });
        }).error(setErrorInScope.bind($scope));
    };
    $scope.list();

    $scope.toggleActive = (scenario) => {
        WT1.event("scenario-reporter-save-active");
        const message = `${scenario.reporter.active ? 'Activate' : 'Deactivate'}`
                    + ` reporter ${scenario.reporter.name} of ${scenario.projectKey}.${scenario.name || scenario.id}`;
        DataikuAPI.scenarios.saveReporterState(scenario.projectKey, scenario.id, scenario.reporter, { commitMessage:message }).success(() => {
            ActivityIndicator.success("Saved");
        }).error(setErrorInScope.bind($scope));
    };

    $scope.deleteReporter = (scenario) => {
        WT1.event("scenario-reporter-delete");
        const message = `Delete reporter ${scenario.reporter.name} of ${scenario.projectKey}.${scenario.name || scenario.id}`;
        DataikuAPI.scenarios.deleteReporter(scenario.projectKey, scenario.id, scenario.reporter, { commitMessage:message }).success(() => {
            ActivityIndicator.success("Saved");
        }).error(setErrorInScope.bind($scope));
    };

    $scope.allReporters = (objects) => {
        if (!objects) return;
        return objects.map(s => s.reporter.active).reduce((a,b) => a && b, true);
    };

    $scope.setReporterObjects = (status, scenarios) => {
        scenarios.forEach((scenario) => {
            if (scenario.reporter && scenario.reporter.active === status) return;
            scenario.reporter.active = status;
            $scope.toggleActive(scenario);
        })
    };

    $scope.massDeletion = (scenarios) => {
        if(scenarios.length < 1) return;
        Dialogs.confirm($scope, "Confirm deletion", "Are you sure you want to delete the selected reporters?").then(function() {
            scenarios.forEach((scenario) => {
                scenario.reporter.active = status;
                $scope.deleteReporter(scenario);
                $scope.listItems = $scope.listItems.filter(s => s !== scenario)
            })
        });
    };

    const formatReporterName = (type) => {
        const typeMapping = {
            "mail-scenario": "Mail",
            "slack-scenario": "Slack",
            "msft-teams-scenario": "Microsoft Teams",
            "webhook-scenario": "Webhook",
            "twilio-scenario": "Twilio",
            "shell-scenario": "Shell command",
            "dataset-scenario": "Send to dataset"
        };
        return typeMapping[type] || type;
    }
});

app.controller("AutomationOutcomesController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate, WT1, ScenarioUtils) {
	TopNav.setItem(TopNav.ITEM_MONITORING, "scenarios", { name: "Automation monitoring", id: null });
	TopNav.setLocation("DSS_HOME", "automation", TopNav.TABS_SCENARIO, "outcomes");

    $scope.getAutoTriggerDisablingReason = function(appConfig, projectSummaries) {
        if (!appConfig || !projectSummaries) return "";
        return ScenarioUtils.getAutoTriggerDisablingReason(appConfig, [].concat(projectSummaries));
    }

    $scope.projectSummaryMap = {};
    DataikuAPI.projects.list().success(function(projectSummaryList) {
        projectSummaryList.forEach(function(projectSummary) {
            $scope.projectSummaryMap[projectSummary.projectKey] = projectSummary;
        });
    });
});

app.controller("OutcomesSummaryController", function($scope, $controller, DataikuAPI, Fn, $stateParams, $state) {
    $controller('OutcomesBaseController', {$scope: $scope});

    $scope.projectKey = $stateParams.projectKey;

    var backendFormat = "YYYY-MM-DD";
    var nextHour = moment().add(1, 'hour').startOf('hour');
    DataikuAPI.scenarios.getOutcomesSummary(
        $scope.projectKey,
        moment(nextHour).subtract(31, 'days').format(backendFormat),
        moment(nextHour).add(1, 'days').format(backendFormat)
    ).success(function(data) {
        const columns = [];
        for (let i = 31 ; i >=0 ; i--) {
            const c = {date: moment(nextHour).subtract(i, 'days').format(backendFormat)};
            c.dateTooltip = moment(c.date).format('MMM. Do');
            c.scenarios = [];
            for (const scenario in data.countsByScenario) {
                if (c.date in data.countsByScenario[scenario].countsByDay) {
                    const curDate = data.countsByScenario[scenario].countsByDay[c.date];
                    c.scenarios.push({
                        name: scenario,
                        aborted: curDate.countByOutcome.ABORTED || 0,
                        failed: curDate.countByOutcome.FAILED || 0,
                        success: curDate.countByOutcome.SUCCESS || 0,
                        warning: curDate.countByOutcome.WARNING || 0,
                        runs: curDate.total,
                        outcome: $scope.getSummaryCellGlobalOutcome(curDate.countByOutcome)
                    });
                }
                c.outcome = $scope.getCellGlobalOutcome(c.scenarios);
                c.runs = c.scenarios.map(Fn.prop('runs')).reduce(Fn.SUM, 0);
            }
            columns.push(c);
        }

        $scope.fixupOutcomes(columns);
        $scope.totalRuns = data.total;
        $scope.columns = columns;
    })
    .error(setErrorInScope.bind($scope));

    $scope.hover = function(evt, column, localScope) {
        $scope.hovered.date = column.date;
        if (column.outcome) {
            evt.target.classList.add('mainzone');
            $scope.popoverColumn = column;
            localScope.showPopover();
        }
    };
    $scope.unhover = function(evt, column, localScope) {
        $scope.hovered.date = null;
        if (column.outcome) {
            evt.target.classList.remove('mainzone');
            $scope.popoverColumn = null;
            localScope.hidePopover();
        }
    };
    $scope.gotoRuns = function(column) {
        $state.go('projects.project.monitoring.scenarios.scoped', {scopeToDay : column.date});
    };
});

// directives to save the scroll position in the scope. The adjustForScroll object has to be put in the scope by someone else
app.directive('freezeHeader', function() {
    return {
        restrict : 'A',
        scope : true,
        link : function($scope, element, attrs) {
            element.on('scroll', function() {
                $scope.$apply(function() {$scope.adjustForScroll.top = element[0].scrollTop;});
            });
        }
    };
});
app.directive('freezeColumns', function() {
    return {
        restrict : 'A',
        scope : true,
        link : function($scope, element, attrs) {
            element.on('scroll', function() {
                $scope.$apply(function() {$scope.adjustForScroll.left = element[0].scrollLeft;});
            });
        }
    };
});

app.directive('actionsByOutcome', function(DataikuAPI, $state, $stateParams, CreateModalFromTemplate) {
    return {
        restrict : 'A',
        scope : true,
        link : function($scope, element, attrs) {
            $scope.actions = $scope.$eval(attrs.actions);
            $scope.outcomeActions = [];
            if ($scope.actions != null) {
                $scope.actions.forEach(function(action) {
                    var outcomeAction = null;
                    $scope.outcomeActions.forEach(function(ta) {
                        if ( ta.outcome == action.outcome ) {
                            outcomeAction = ta;
                        }
                    });
                    if ( outcomeAction == null ) {
                        outcomeAction = {outcome : action.outcome, actions : []};
                        $scope.outcomeActions.push(outcomeAction);
                    }
                    outcomeAction.actions.push(action);
                });
            }
        }
    }
});

app.directive('groupActionsByRowType', function(DataikuAPI, $state, $stateParams, CreateModalFromTemplate) {
    return {
        restrict : 'A',
        scope : true,
        link : function($scope, element, attrs) {
            $scope.splitRows = [];
            $scope.$watch(attrs.tableData, function() {
                var tableData = $scope.$eval(attrs.tableData);
                if (tableData != null) {
                    var allActionTypesByRow = {};
                    tableData.columns.forEach(function(column) {
                        column.actionsByRowType = {};
                        angular.forEach(column.actions, function(actions, rowId) {
                            var actionsByType = {};
                            if ( allActionTypesByRow[rowId] == null ) {
                                allActionTypesByRow[rowId] = {};
                            }
                            actions.forEach(function(action) {
                                allActionTypesByRow[rowId][action.type] = '';
                                if ( actionsByType[action.type] == null ) {
                                    actionsByType[action.type] = [];
                                }
                                actionsByType[action.type].push(action);
                            });
                            column.actionsByRowType[rowId] = actionsByType;
                        });
                    });
                    $scope.splitRows = [];
                    tableData.rows.forEach(function(row) {
                        var actionTypes = allActionTypesByRow[row.uniqueId];
                        var rowSpan = 0;
                        angular.forEach(actionTypes, function(value, key) {rowSpan++;}); // count types
                        angular.forEach(actionTypes, function(value, key) {
                            $scope.splitRows.push({row: row, actionType: key, span: rowSpan});
                            rowSpan = 0; // only the first cell of the first rows spans the next ones
                        });
                    });
                }
            });
        }
    }
});

app.directive('hierarchicalGantt', function($state, Fn, WT1) {
    return {
        restrict : 'A',
        scope : {
            rows : '=',
            columns : '=',
            reportRange : '=',
            hovered : '=',
            applyHover : '=',
            canWriteProject : '='
        },
        link : function($scope, element, attrs) {
            var headerHeight = 55;
            var rowHeight = 25;
            var triggerWidth = 10;

            // stuff to listen on for graph changes
            $scope.$watch('reportRange', function() {$scope.refreshPlot();}, true);
            $scope.$watch('rows', function() {$scope.refreshPlot();}, true);

            // the svg needs to update when the width changes (different # of ticks, for ex)
            var eventName = 'resize.gantt.' + $scope.$id;
            $(window).on(eventName, function() {$scope.refreshPlot();});
            $scope.$on('$destroy', function(){$(window).off(eventName)});

            // the graph area
            var chartSvg = d3.select(element[0]).classed('chart') ? d3.select(element[0]) : d3.select(element[0]).select(".chart");
            var chart = chartSvg.append("g").attr("transform", "translate(0,"+headerHeight+")");
            var yHoverBackgroundG = chart.append("g").attr("class", "y axis background");
            var actionsG = chart.append("g").attr("class", "actions");
            var triggersG = chart.append("g").attr("class", "triggers");
            var xAxisG = chart.append("g").attr("class", "x axis");
            var xGridLinesG = chart.append("g").attr("class", "x gridlines");
            var yGridLinesG = chart.append("g").attr("class", "y gridlines");

            var y = null;
            // update the graph
            $scope.refreshPlot = function() {
                if ( $scope.rows == null ) return;
                // flatten data
                var yLabels = $scope.rows.filter(function(row) {return row.displayOnRow == null;}).map(function(row) {return row.uniqueId;});
                var data = [];
                if ($scope.columns && $scope.columns.length > 0) {
                    data = $scope.columns.map(function(column) {
                    	var actions = [];
                		angular.forEach(column.actions, function(columnActions, uniqueId) {
                    		columnActions.forEach(function(action) {actions.push({x:action, y:uniqueId, runId:column.runId});});
                    	});
                    	return actions;
                    })
                    .reduce(function(list, actions) {return list.concat(actions);}, []);
                }
                // prepare access to row by id
                var rowById = {};
                $scope.rows.forEach(function(row) {rowById[row.uniqueId] = row;});

                // keep items of shown rows
                data = data.filter(function(action) {return action.y in rowById;});

                // split according to how we want to represent them
                var actionData = [];
                var triggerData = [];
                data.forEach(function(d) {
                    if ( d.x.type == 'TRIGGER_FIRED' ) {
                        triggerData.push(d);
                    } else {
                        actionData.push(d);
                    }
                });

                // get the available width
                var width = element.closest('.cells').innerWidth();
                // height is defined by the data
                var height =  rowHeight * yLabels.length;
                chartSvg.attr("width", width).attr("height", height);

                // make the axes
                var x = d3.time.scale().domain([new Date($scope.reportRange.from), new Date($scope.reportRange.to)]).range([0, width]);
                y = d3.scale.ordinal().domain(yLabels).rangeRoundBands([0, height]);

                var xAxis = d3.svg.axis().scale(x).tickFormat(Fn.getCustomTimeFormat()).orient("top").tickSize(4, 0, 0);
                var xGridLines = d3.svg.axis().scale(x).orient("top").tickSize(-height, 0, 0);
                xAxisG.call(xAxis);
                xGridLinesG.call(xGridLines).selectAll("text").remove();

                yGridLinesG.selectAll("line").remove();
                var yGridLines = yGridLinesG.selectAll("line").data(yLabels);
                yGridLines.enter().append("line")
                        .attr("x1", 0)
                        .attr("x2", width)
                        .attr("y1", function(d) {return y(d);})
                        .attr("y2", function(d) {return y(d);})
                        .classed("top-row", function(d) {return rowById[d].depth == 0;});

                // put the bars
                actionsG.selectAll("*").remove();
                var bars = actionsG.selectAll(".action").data(actionData)
                bars.enter().append("rect")
                      .classed("action", true)
                      .classed("success", function(d) {return d.x.outcome == 'SUCCESS'})
                      .classed("warning", function(d) {return d.x.outcome == 'WARNING'})
                      .classed("failed", function(d) {return d.x.outcome == 'FAILED'})
                      .classed("aborted", function(d) {return d.x.outcome == 'ABORTED'})
                      .classed("none", function(d) {return d.x.outcome == null})
                      .classed("scenario-level", function(d) {return d.x.type == 'SCENARIO_DONE'})
                      .classed("step-level", function(d) {return d.x.type == 'STEP_DONE'})
                      .attr("y", function(d) { return y(d.y); })
                      .attr("height", rowHeight);
                // update every time, not just on enter, for when just the x axis range is modified
                bars.attr("x", function(d) { return x(new Date(d.x.start)); })
                      .attr("width", function(d) { return d.x.end >= d.x.start ? Math.max(1, x(new Date(d.x.end)) - x(new Date(d.x.start))) : 0; });

                triggersG.selectAll("*").remove();
                var triangles = triggersG.selectAll(".trigger").data(triggerData)
                triangles.enter().append("path")
                        .classed("trigger", true)
                        .attr("d", function(d) { return "M" + x(new Date(d.x.start)) + "," + y(rowById[d.y].displayOnRow || d.y) + " l"+triggerWidth+","+(rowHeight/2)+" l-"+triggerWidth+","+(rowHeight/2)+" z"; });
                triangles.on("mouseover", function(d){
                			var row = rowById[d.y];
                			triggersG.append("text")
	                            .attr("x", x(new Date(d.x.start)) + triggerWidth + 3)
	                            .attr("y", y(rowById[d.y].displayOnRow || d.y) + rowHeight / 2 + 4)
	                            .classed("trigger-text", true)
	                            .text((row && row.info) ? row.info.name || row.info.type : '');
                         })
                		.on("mouseout", function(){triggersG.selectAll("text").remove();});

                // click handlers. At the moment, only one is not row-based: jobs
                if ($scope.canWriteProject) {
	                bars.filter(function(d) {return d.x.type == 'JOB_EXECUTED';}).classed("clickable", true).on("click", function(d){
	                    WT1.event("gantt-to-job");$state.go('projects.project.jobs.job', {jobId : d.x.jobId});
	                });
	                bars.filter(function(d) {return d.x.type == 'SCENARIO_DONE';}).classed("clickable", true).on("click", function(d){
	                    WT1.event("gantt-to-scenario-run");$state.go('projects.project.scenarios.scenario.runs.list.run', {projectKey : d.x.target.projectKey, scenarioId : d.x.target.scenarioId, runId : d.runId});
	                });
                }

                var hovers = yHoverBackgroundG.selectAll(".bar");
                hovers.attr("width", width);
           };

           $scope.$watch('hovered', function() {
        	   if (typeof($scope.applyHover)==='function') {
        		   $scope.applyHover(y, rowHeight, yHoverBackgroundG);
        	   }
           }, true);
        }
    };
});
app.directive('hierarchicalActivity', function(DataikuAPI, $state, $stateParams, CreateModalFromTemplate, WT1) {
    return {
        restrict : 'A',
        scope : {
            rows : '=',
            columns : '=',
            reportRange : '=',
            hovered : '=',
            applyHover : '=',
            canWriteProject : '='
        },
        link : function($scope, element, attrs) {
            var headerHeight = 55;
            var rowHeight = 25;

            // stuff to listen on for graph changes
            $scope.$watch('reportRange', function() {$scope.refreshPlot();}, true);
            $scope.$watch('rows', function() {$scope.refreshPlot();}, true);

            // the svg needs to update when the width changes (different # of ticks, for ex)
            var eventName = 'resize.activity.' + $scope.$id;
            $(window).on(eventName, function() {$scope.refreshPlot();});
            $scope.$on('$destroy', function(){$(window).off(eventName)});

            // the graph area
            var chartSvg = d3.select(element[0]).classed('chart') ? d3.select(element[0]) : d3.select(element[0]).select(".chart");
            var chart = chartSvg.append("g").attr("transform", "translate(0,"+headerHeight+")");
            var yHoverBackgroundG = chart.append("g").attr("class", "y axis background");
            var actionsG = chart.append("g").attr("class", "actions");
            var xAxisG = chart.append("g").attr("class", "x axis");
            var xSubAxisG = chart.append("g").attr("class", "x sub-axis");
            var yGridLinesG = chart.append("g").attr("class", "y gridlines");

            var y = null;
            // update the graph
            $scope.refreshPlot = function() {
                if ( $scope.rows == null || $scope.columns == null ) return;
                // prepare access to row and column by id
                var rowById = {};
                $scope.rows.forEach(function(row) {rowById[row.uniqueId] = row;});
                var columnById = {};
                $scope.columns.forEach(function(column) {columnById[column.start] = column;});

                // flatten data
                var yLabels = $scope.rows.map(function(row) {return row.uniqueId;});
                var data = $scope.columns.map(function(column) {
                	var actions = [];
                    // filter x axis on range
                	if ( column.start >= $scope.reportRange.from && column.start <= $scope.reportRange.to ) {
                		angular.forEach(column.actions, function(columnActions, uniqueId) {
                			if ( uniqueId in rowById ) {
                                actions.push({x:column.start,
                                            y:uniqueId,
                                            a:columnActions[columnActions.length - 1],
                                            r:column.runId
                                });
                			}
                		});
                	}
                	return actions;
                })
                .reduce(function(list, actions) {return list.concat(actions);}, []);
                var usedColumns = {};
                data.forEach(function(d) {usedColumns[d.x] = d.x;});
                var filteredXLabels = [];
                angular.forEach(usedColumns, function(value, column) {filteredXLabels.push(value);});
                filteredXLabels.sort();

                var days = [];
                filteredXLabels.forEach(function(start, i) {
                	var day = moment(start).format('ddd MM/DD');
                	if (days.length == 0 || days[days.length-1].day != day) {
                		days.push({day:day, runs:1, i:i})
                	} else {
                		days[days.length-1].runs++;
                	}
                });

                // keep items of shown rows
                data = data.filter(function(action) {return action.x in columnById && action.y in rowById;});

                // get the available width
                var width = element.closest('.cells').innerWidth();
                // height is defined by the data
                var height =  rowHeight * yLabels.length;
                chartSvg.attr("width", width).attr("height", height);

                // make the axes
                y = d3.scale.ordinal().domain(yLabels).rangeRoundBands([0, height]);
                // make the x axis ourselves
                var bandWidth = filteredXLabels.length > 0 ? width / filteredXLabels.length : width;
                var xPos = {};
                filteredXLabels.forEach(function(start, i) {xPos[start] = i;});
                xAxisG.selectAll("*").remove();
                xAxisG.selectAll(".gridlines").data(filteredXLabels).enter().append("line")
                	.classed("gridlines", true)
	            	.attr("x1", function(d) {return bandWidth * xPos[d];})
	            	.attr("x2", function(d) {return bandWidth * xPos[d];})
	            	.attr("y1", -4)
	            	.attr("y2", height);
                xAxisG.selectAll(".tick").data(filteredXLabels).enter().append("text")
                	.classed("tick", true)
	            	.attr("x", function(d) {return bandWidth * (0.5 + xPos[d]);})
	            	.attr("y", -8)
	            	.text(function(d) {return moment(d).format('HH:mm');});
                // and the 'day' sub axis
                xSubAxisG.selectAll("*").remove();
                xSubAxisG.selectAll(".gridlines").data(days).enter().append("line")
                	.classed("gridlines", true)
	            	.attr("x1", function(d) {return bandWidth * d.i;})
	            	.attr("x2", function(d) {return bandWidth * d.i;})
	            	.attr("y1", -35)
	            	.attr("y2", height);
                xSubAxisG.selectAll(".tick").data(days).enter().append("text")
                	.classed("tick", true)
	            	.attr("x", function(d) {return bandWidth * (0.5 * d.runs + d.i);})
	            	.attr("y", -39)
	            	.text(function(d) {return d.day});

                yGridLinesG.selectAll("line").remove();
                var yGridLines = yGridLinesG.selectAll("line").data(yLabels);
                yGridLines.enter().append("line")
                        .attr("x1", 0)
                        .attr("x2", width)
                        .attr("y1", function(d) {return y(d);})
                        .attr("y2", function(d) {return y(d);})
                        .classed("top-row", function(d) {return rowById[d].depth == 0;});

                // put the bars
                actionsG.selectAll("*").remove();
                var dots = actionsG.selectAll("a").data(data)
                dots.enter().append("a")
                    .append("circle")
                        .attr("class", function(d) { return "action " + (d.a.outcome || 'none').toLowerCase(); })
                        .classed("scenario-level", function(d) {return d.a.type == 'SCENARIO_DONE'})
                        .classed("step-level", function(d) {return d.a.type == 'STEP_DONE'})
                        .attr("cy", function(d) { return y(d.y) + 0.5 * rowHeight; })
                        .attr("r", 0.3 * rowHeight);
                // update every time, not just on enter, for when just the x axis range is modified
                dots.selectAll("a circle.action")
                    .attr("cx", function(d) { return (xPos[d.x] + 0.5) * bandWidth; });
                if ($scope.canWriteProject) {
                	dots.filter(function(d) {return d.a.type == 'JOB_EXECUTED';}).classed("clickable", true).on("click", function(d){
                        WT1.event("runs-to-job");$state.go('projects.project.jobs.job', {jobId : d.a.jobId});
                    });
                    dots.filter(function(d) {return d.a.type == 'SCENARIO_DONE';}).classed("clickable", true).on("click", function(d){
                        WT1.event("runs-to-scenario-run");$state.go('projects.project.scenarios.scenario.runs.list.run', {projectKey : d.a.target.projectKey, scenarioId : d.a.target.scenarioId, runId : d.runId});
                    });
                }

                var hovers = yHoverBackgroundG.selectAll(".bar");
                hovers.attr("width", width);
           };

           $scope.$watch('hovered', function() {
        	   if (typeof($scope.applyHover)==='function') {
        		   $scope.applyHover(y, rowHeight, yHoverBackgroundG);
        	   }
           }, true);
        }
    };
});
app.directive('hierarchicalHover', function(DataikuAPI, $state, $stateParams, CreateModalFromTemplate) {
    return {
        restrict : 'A',
        scope : false,
        link : function($scope, element, attrs) {
            // coordinated hovering in chart and header rows
            $scope.hovered = {};
            $scope.hoverOver = function(uniqueId, enter) {
                if ( enter ) $scope.hovered[uniqueId] = true; else delete $scope.hovered[uniqueId];
            };
            $scope.isHovered = function(item) {
                return $scope.hovered[item.uniqueId] || false;
            };

            $scope.applyHover = function(y, rowHeight, yHoverBackgroundG) {
                var uniqueIds = [];
                angular.forEach($scope.hovered, function(value, key) {uniqueIds.push(key);});
                if (y != null) {
                    yHoverBackgroundG.selectAll("*").remove();
                    var bars = yHoverBackgroundG.selectAll(".bar").data(uniqueIds);
                    bars.enter().append("rect")
                    .attr("x", 0)
                    .attr("y", function(d) { return y(d); })
                    .attr("height", rowHeight);

                    var width = element.find('.cells').innerWidth() - 1; // -1 for the last tick
                    bars.attr("width", width);
                }
           };
        }
    };
});

app.directive('actionsGraph', function(DataikuAPI, $state, $stateParams, CreateModalFromTemplate, $filter) {
    return {
        restrict : 'E',
        templateUrl : '/templates/scenarios/fragments/actions-graph.html',
        scope : {
            actions : '=',
            averageDuration : '='
        },
        link : function($scope, element, attrs) {
            // propagate data changes into this directive
            $scope.$watch('actions', function(nv, ov) {
                if ( $scope.actions ) {
                    $scope.refreshPlot();
                }
            });

            var width = $(element).innerWidth();
            var height = $(element).innerHeight();
            var left = 30;
            var right = 10;
            var top = 5;
            var bottom = 10;

            // the graph area
            var chartSvg = d3.select(".actions-chart");
            var chart = chartSvg.append("g").attr("width", width).attr("height", height);
            var xAxisG = chart.append("g").attr("class", "x axis").attr("transform", "translate(" + left + "," + (height-bottom) + ")");
            var yAxisG = chart.append("g").attr("class", "y axis").attr("transform", "translate(" + left + "," + top + ")");
            var actionsG = chart.append("g").attr("class", "actions").attr("transform", "translate(" + left + "," + top + ")");
            var averageG = chart.append("g").attr("class", "average").attr("transform", "translate(" + left + "," + top + ")");

            // update the graph
            $scope.refreshPlot = function() {
                if ( $scope.actions == null ) return;

                var sortedActions = $scope.actions.concat().sort(function(a,b) {return a.start - b.start;});

                var maxDuration = 0;
                var starts = [];
                sortedActions.forEach(function(action) {
                    var duration = action.end - action.start;
                    if ( duration > maxDuration ) maxDuration = duration;
                    starts.push(action.start);
                });
                var x = d3.scale.ordinal().domain(starts).rangeRoundBands([0, width - (left + right)], 0.1, 0.05);
                var y = d3.scale.linear().domain([0, maxDuration]).range([height - (top + bottom), 0]);

                var formatDuration = function(d) {
                    var secs = d / 1000;
                    if ( secs < 120 ) {
                        return '' + Math.round(secs) + 's';
                    }
                    var mins = secs / 60;
                    if ( mins < 120 ) {
                        return '' + Math.round(mins) + 'm';
                    }
                    var hours = mins / 60;
                    return '' + Math.round(hours) + 'h';
                };

                var yAxis = d3.svg.axis()
                    .scale(y)
                    .orient("left")
                    .tickFormat(formatDuration);

                var xAxis = d3.svg.axis()
                    .scale(x)
                    .orient("bottom")
                    .tickFormat(function (d) { return ''; })
                    .tickSize(0);

                xAxisG.call(xAxis);
                //yAxisG.call(yAxis);

                var points = actionsG.selectAll(".action").data(sortedActions)
                points.enter().append("rect")
                    .classed("action", true)
                    .classed("success", function(d) {return d.outcome == 'SUCCESS'})
                    .classed("warning", function(d) {return d.outcome == 'WARNING'})
                    .classed("failed", function(d) {return d.outcome == 'FAILED'})
                    .classed("aborted", function(d) {return d.outcome == 'ABORTED'})
                    .classed("none", function(d) {return d.outcome == null})
                    .attr("x", function(d) { return x(d.start); })
                    .attr("y", function(d) { return y(d.end - d.start); })
                    .attr("width", Math.max(1, x.rangeBand()))
                    .attr("height", function(d) { return height - (top + bottom) - y(d.end - d.start); });

                averageG.selectAll("*").remove();
                averageG.append("line")
                    .attr("x1", 0)
                    .attr("x2", width)
                    .attr("y1", y($scope.averageDuration))
                    .attr("y2", y($scope.averageDuration));
                averageG.append("text")
                .attr("x", -2)
                .attr("y", y($scope.averageDuration))
                .text(formatDuration($scope.averageDuration));
            };
        }
    };
});

app.directive('timeRangeBrush', function(Fn) {
    return {
        restrict : 'A',
        templateUrl : '/templates/scenarios/fragments/time-range-brush.html',
        scope : {
            range : '=',
            selectedRange : '=',
            onChange : '&',
            onDrillDown : '&',
            rounding : '@'
        },
        replace : true,
        link : function($scope, element, attrs) {
            var padding = 10;
            var handleRadius = 5;
            var sliderWidth = 4;
            var brushHeight = 30;
            // the svg needs to update when the width changes (different # of ticks, for ex)
            var eventName = 'resize.brush.' + $scope.$id;
            $(window).on(eventName, function() { if ( $scope.range != null ) $scope.refreshRange();});
            $scope.$on('$destroy', function(){$(window).off(eventName)});
            // also add a watch on the width for the cases where the size changes as a result of
            // stuff being shown/hidden
            $scope.$watch(
                function () {return element.width();},
                function (newValue, oldValue) { if ( $scope.range != null ) $scope.refreshRange(); }
            );

            // get the brush : the root of the template
            var brushSvg = d3.select(element[0]);
            // resize
            brushSvg.attr("height", brushHeight);
            // add stuff in the svg
            var xAxisG = brushSvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + (brushHeight - handleRadius) + ")");
            var xAxisLineG = brushSvg.append("g").attr("class", "x line");
            var brushG = brushSvg.append("g").attr("class", "x brush"); // brush on top (to catch mouse events)
            var xTicksG = brushSvg.append("g").attr("class", "x ticks").attr("transform", "translate(0," + (brushHeight - handleRadius) + ")");
            var brushHandlesG = brushSvg.append("g").attr("class", "x handles");

            brushSvg.on('dblclick', function(e) {
                var insideExtent = false;
                if ( xScale != null ) {
                    var pos = d3.mouse(element[0]);
                    var xPos = xScale.invert(pos[0]).getTime();
                    insideExtent = $scope.selectedRange.from < xPos && $scope.selectedRange.to > xPos;
                }
                if (insideExtent && $scope.onDrillDown() != null) {
                    // why can't I pass the first () in the html? dunno...
                    $scope.onDrillDown()($scope.selectedRange.from, $scope.selectedRange.to);
                } else {
                    $scope.selectedRange.from = $scope.range.from;
                    $scope.selectedRange.to = $scope.range.to;
                    $scope.refreshRange();
                    $scope.onChange();
                }
            });

            var xScale = null;

            // update the total range, and then the graph
            $scope.refreshRange = function() {
                if ( $scope.range == null || $scope.selectedRange == null ) {
                    return;
                }
                var width = $(element).innerWidth();
                // the full range we are selecting in
                var axisRange = [new Date($scope.range.from), new Date($scope.range.to)];
                // the selected range
                var extentRange = $scope.selectedRange.from > 0 ? [new Date($scope.selectedRange.from), new Date($scope.selectedRange.to)] : axisRange;
                // make the scale
                xScale = d3.time.scale().domain(axisRange).range([padding + handleRadius + 1, width - padding - handleRadius - 1]);
                // prepare the brush callback
                var brushed = function() {
                    var extent = brush.extent();
                    if (d3.event.mode === "move") {
                        if ( $scope.rounding == 'day') {
                            var startDay = d3.time.day.round(extent[0]);
                            var daySpan = Math.round((extent[1] - extent[0]) / (24 * 3600 * 1000));
                            var endDay = d3.time.day.offset(startDay, daySpan);
                            extent = [startDay, endDay];
                        }
                    } else {
                        if ( $scope.rounding == 'day') {
                            extent = extent.map(d3.time.day.round);
                            if (extent[0] >= extent[1] ) {
                                extent[0] = d3.time.day.floor(extent[0]);
                                extent[1] = d3.time.day.ceil(extent[1]);
                            }
                        }
                    }
                    d3.select(this).call(brush.extent(extent));
                    brushHandlesG.selectAll('.s').attr("cx", xScale(extent[0]));
                    brushHandlesG.selectAll('.e').attr("cx", xScale(extent[1]));

                    $scope.selectedRange.from = extent[0].getTime();
                    $scope.selectedRange.to = extent[1].getTime();
                    $scope.onChange();
                };
                // make the brush
                var brush = d3.svg.brush().x(xScale).on("brush", brushed).extent(extentRange);
                // make the axis from the scale
                var xAxis = d3.svg.axis().scale(xScale).tickFormat(Fn.getCustomTimeFormat()).orient("top").tickSize(handleRadius);
                // and create the svg objects
                var a = xAxisG.call(xAxis);
                var b = brushG.call(brush);

                var lineY = brushHeight - handleRadius - 0.5 * sliderWidth;
                // replace the axis line by a rect
                a.selectAll(".domain").remove();
                a.selectAll(".tick > line").remove();
                xAxisLineG.selectAll('rect').remove();
                xAxisLineG.append("rect").attr("x", padding + handleRadius + 1).attr("y", lineY).attr("width", Math.max(0, width - 2 * (padding + handleRadius + 1))).attr("height", sliderWidth);
                // make ticks, between the brush and the handles
                xTicksG.selectAll('circle').remove();
                a.selectAll(".tick").each(function(d) { xTicksG.append("circle").attr("r", 0.5 * sliderWidth).attr("cx", xScale(d)); });
                // the brush above it
                b.selectAll(".extent").attr("y", lineY).attr("height", sliderWidth);
                brushG.selectAll(".resize > rect").attr("y", 0).attr("height", brushHeight);
                  // and finally the handles
                brushHandlesG.selectAll('circle').remove();
                brushHandlesG.append("circle").attr("cx", xScale(extentRange[0])).attr("cy", brushHeight - handleRadius).attr("r", handleRadius).classed("s", true);
                brushHandlesG.append("circle").attr("cx", xScale(extentRange[1])).attr("cy", brushHeight - handleRadius).attr("r", handleRadius).classed("e", true);
            };

            // add event handler to adjust the brush when the selection changes
            $scope.$watch('range', function(nv, ov) {
                if ( nv == null ) return;
                $scope.refreshRange();
            }, true);
            $scope.$watch('selectedRange', function(nv, ov) {
                if ( nv == null ) return;
                $scope.refreshRange();
            }, true);
        }
    };
});

})();

(function(){
'use strict';

var app = angular.module('dataiku.continuous-activities',[]);


app.controller("ContinuousActivitiesListController", function($scope, $rootScope, $controller, $stateParams, $q, Fn, DataikuAPI, $state,
                TopNav, CreateModalFromTemplate, Dialogs, WT1, ActivityIndicator) {

    $controller('_TaggableObjectsListPageCommon', {$scope: $scope});
    
    $scope.listItemType = 'CONTINUOUS_ACTIVITY'; // set manually because it's not one of the taggable types

    $scope.sortBy = [
        { value: 'id', label: 'Id' },
        { value: 'name', label: 'Name' }
    ];
    $scope.selection = $.extend({
        filterQuery: {
            userQuery: '',
            tags: [],
            interest: {
                starred: '',
            },
        },
        filterParams: {
            userQueryTargets: ["recipeId", "recipeType", "name","tags"],
            propertyRules: {tag:"tags"},
        },
        orderQuery: "id",
        orderReversed: false,
    }, $scope.selection || {});
    $scope.sortCookieKey = 'continuous-activities';
    $scope.maxItems = 20;
    
    $scope.noTags = true;
    $scope.noStar = true;
    $scope.noWatch = true;
    $scope.noDelete = true;

    $scope.list = function(noRestore) {
        DataikuAPI.continuousActivities.listProjectStates($stateParams.projectKey).success(function(data) {
            $scope.listItems = data.activities.map(a => {a.id = a.recipeId; return a;});
            $scope.restoreOriginalSelection();
        }).error(setErrorInScope.bind($scope));
    };

    TopNav.setLocation(TopNav.TOP_JOBS, "continuous-activities", TopNav.TABS_NONE, null);
    TopNav.setNoItem();
    $scope.list();

    $scope.$watch("selection.selectedObject",function(nv) {
        if (!nv) return;
        // TODO @streaming-ui
    });

    $scope.continuousActivityList = {}; // to be shared between the main page and the standardized panel
    $scope.continuousActivityList.list = $scope.list;

    /* Specific actions */
    $scope.goToItem = function(data) {};

    $scope.startContinuousActivity = function(item) {
        WT1.event("start-continuous", {from:'continuous-activities-list'})
        CreateModalFromTemplate("/templates/continuous-activities/start-continuous-activity-modal.html", $scope, "StartContinuousActivityController", function(newScope) {
            newScope.recipeId = item.recipeId;
        }).then(function(loopParams) {
            DataikuAPI.continuousActivities.start($stateParams.projectKey, item.recipeId, loopParams).success(function(data){
                $scope.list();
            }).error(setErrorInScope.bind($scope));
        });
    }
    $scope.stopContinuousActivity = function(item) {
        WT1.event("stop-continuous", {from:'continuous-activities-list'})
        DataikuAPI.continuousActivities.stop($stateParams.projectKey, item.recipeId).success(function(data){
            $scope.list();
        }).error(setErrorInScope.bind($scope));
    }
    
    // mass actions for the dropdown
    $scope.massStartStopContinuous = true;
    $scope.startAllContinuousActivities = function(objects) {
        WT1.event("start-continuous", {from:'continuous-activities-list'})
        CreateModalFromTemplate("/templates/continuous-activities/start-continuous-activity-modal.html", $scope, "StartContinuousActivityController", function(newScope) {
            newScope.recipeId = objects[0].recipeId;
        }).then(function(loopParams) {
            let promises = objects.map(function(object) {
                return DataikuAPI.continuousActivities.start($stateParams.projectKey, object.recipeId, loopParams)
            });
            $q.all(promises).then(function (values) {
                $scope.list();
            });
        });
    };
    $scope.stopAllContinuousActivities = function(objects) {
        WT1.event("stop-continuous", {from:'continuous-activities-list'})
        let promises = objects.map(function(object) {
            return DataikuAPI.continuousActivities.stop($stateParams.projectKey, object.recipeId)
        });
        $q.all(promises).then(function (values) {
            $scope.list();
        });
    };
    
});

app.controller("ContinuousActivityPageRightColumnActions", function($controller, $scope, $rootScope, $stateParams, ActiveProjectKey, DataikuAPI, CreateModalFromTemplate, WT1) {

    $controller('_TaggableObjectPageRightColumnActions', {$scope: $scope});

    let setLocalState = function(data) {
        // for the right column actions
        if (!data) return;
        $scope.data = data;
        $scope.continuousActivity = $scope.data;
        $scope.continuousActivity.nodeType = "CONTINOUS_ACTIVITY";
        $scope.continuousActivity.interest = {};
        $scope.selection = {
            selectedObject : $scope.continuousActivity,
            confirmedItem : $scope.continuousActivity
        };
    };
    if ($scope.continuousActivityPage) {
        // update the data in the right-column if it changes on the main page
        $scope.$watch("continuousActivityPage.state", function(data) {
            setLocalState($scope.continuousActivityPage.state);
        });
    }

    let refreshData = function() {
        DataikuAPI.continuousActivities.getState(ActiveProjectKey.get(), $stateParams.continuousActivityId).success(function(data) {
            setLocalState(data);
            if ($scope.continuousActivityPage) {
                // and update on the page too
                $scope.continuousActivityPage.state = data;
            }
        }).error(setErrorInScope.bind($scope));
    };
    if ($scope.continuousActivityPage) {
        // if the data is not expected to come from the page, go grab it
        refreshData();
    }
    
    $scope.startContinuousActivity = function() {
        WT1.event("start-continuous", {from:'continuous-activities-page'})
        CreateModalFromTemplate("/templates/continuous-activities/start-continuous-activity-modal.html", $scope, "StartContinuousActivityController", function(newScope) {
            newScope.recipeId = $scope.continuousActivity.recipeId;
        }).then(function(loopParams) {
            DataikuAPI.continuousActivities.start($stateParams.projectKey, $scope.continuousActivity.recipeId, loopParams).success(function(data){
                refreshData();
            }).error(setErrorInScope.bind($scope));
        });
    }
    $scope.stopContinuousActivity = function() {
        WT1.event("stop-continuous", {from:'continuous-activities-page'})
        DataikuAPI.continuousActivities.stop($stateParams.projectKey, $scope.continuousActivity.recipeId).success(function(data){
            refreshData();
        }).error(setErrorInScope.bind($scope));
    }
});

app.controller("StartContinuousActivityController", function($controller, $scope, $rootScope, $stateParams, ActiveProjectKey, DataikuAPI) {
    $scope.uiState = {loopParamsPreset:'FOREVER'};
    $scope.loopParamsPresets = [
                                    {id:'FOREVER', label:'Loop forever, no delay'}
                                  , {id:'ONCE',label:'Only one attempt'}
                                  , {id:'BOUNDED_ATTEMPTS',label:'N attempts max'}
                                  , {id:'CUSTOM',label:'Custom'}
                               ];

    let makeParams = function() {
        if ($scope.uiState.loopParamsPreset == 'FOREVER') return {abortAfterCrashes:-1, initialRestartDelayMS:0, maxRestartDelayMS:0, restartDelayIncMS:0};
        if ($scope.uiState.loopParamsPreset == 'ONCE') return {abortAfterCrashes:1, initialRestartDelayMS:0, maxRestartDelayMS:0, restartDelayIncMS:0};
        if ($scope.uiState.loopParamsPreset == 'BOUNDED_ATTEMPTS') return {abortAfterCrashes:$scope.uiState.abortAfterCrashes, initialRestartDelayMS:0, maxRestartDelayMS:0, restartDelayIncMS:0};
        if ($scope.uiState.loopParamsPreset == 'CUSTOM') return $scope.uiState;
        return {};
    };
    $scope.start = function() {
        $scope.resolveModal(makeParams());
    };
});

app.directive('continuousActivityRightColumnSummary', function($controller, DataikuAPI, $stateParams, GlobalProjectActions, QuickView, ActiveProjectKey, CreateModalFromTemplate, $q, WT1) {
    return {
        templateUrl :'/templates/continuous-activities/right-column-summary.html',

        link : function(scope, element, attrs) {

            $controller('_TaggableObjectsMassActions', {$scope: scope });
            $controller('_TaggableObjectsCapabilities', {$scope: scope });

            scope.QuickView = QuickView;

            if (scope.continuousActivityPage) {
                // we're on the run page, use the state that's already present
                scope.$watch("continuousActivityPage.state", function() {
                    scope.continuousActivity = scope.continuousActivityPage.state;
                });
            } else {
                scope.refreshData = function() {
                    if (!scope.selection.confirmedItem.id) return;
                    DataikuAPI.continuousActivities.getState(ActiveProjectKey.get(), scope.selection.confirmedItem.id).success(function(data) {
                        scope.continuousActivity = data;
                    }).error(setErrorInScope.bind(scope));
                };
    
                scope.$watch("selection.confirmedItem", function(nv, ov) {
                    if (!nv) return;
                    scope.refreshData();
                });
            }
    
            scope.startAllContinuousActivities = function(activities) {
                WT1.event("start-continuous", {from:'continuous-activities-right-column'})
                CreateModalFromTemplate("/templates/continuous-activities/start-continuous-activity-modal.html", scope, "StartContinuousActivityController", function(newScope) {
                    newScope.recipeId = activities[0].recipeId;
                }).then(function(loopParams) {
                    let promises = activities.map(function(activity) {
                        return DataikuAPI.continuousActivities.start($stateParams.projectKey, activity.recipeId, loopParams)
                    });
                    $q.all(promises).then(function (values) {
                        scope.continuousActivityList.list();
                    });
                });
            }
            scope.stopAllContinuousActivities = function(activities) {
                WT1.event("stop-continuous", {from:'continuous-activities-right-column'})
                let promises = activities.map(function(activity) {
                    return DataikuAPI.continuousActivities.stop($stateParams.projectKey, activity.recipeId)
                });
                $q.all(promises).then(function (values) {
                    scope.continuousActivityList.list();
                });
            }
        }
    }
});


app.controller("ContinuousActivityController", function($scope, $controller, $stateParams, $rootScope, DataikuAPI, $state, TopNav,
                CreateModalFromTemplate, ActivityIndicator, WT1, Dialogs, $q, $timeout, RecipesUtils) {

    TopNav.setItem(TopNav.ITEM_CONTINUOUS_ACTIVITY, $stateParams.continousActivityId);
    TopNav.setLocation(TopNav.TOP_JOBS, "continuous-activities", TopNav.TABS_CONTINUOUS_ACTIVITY, "status");
    
    $scope.continuousActivityPage = {}; // to be shared between the main page and the standardized panel

    DataikuAPI.continuousActivities.getFullInfo($stateParams.projectKey, $stateParams.continuousActivityId).success(function(data){
        $scope.continuousActivityPage.state = data.state;
        $scope.continuousActivityPage.recipe = data.recipe;
        $scope.continuousActivityPage.flatOutputs = [];
        if (data.recipe && data.recipe.outputs) {
            $.each(data.recipe.outputs, function(name, output) {  $scope.continuousActivityPage.flatOutputs.push(output); });
        }
    }).error(setErrorInScope.bind($scope));
});


app.controller("ContinuousActivityRunsController", function($scope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate, WT1, ActivityIndicator, $interval) {
    TopNav.setItem(TopNav.ITEM_CONTINUOUS_ACTIVITY, $stateParams.continousActivityId);
    TopNav.setLocation(TopNav.TOP_JOBS, "continuous-activities", TopNav.TABS_CONTINUOUS_ACTIVITY, "status");

    DataikuAPI.continuousActivities.getState($stateParams.projectKey, $stateParams.continuousActivityId).success(function(data) {
        TopNav.setItem(TopNav.ITEM_CONTINUOUS_ACTIVITY, $stateParams.continousActivityId, {name:data.recipeId, type:data.recipeType, state:data.desiredState});
    }).error(setErrorInScope.bind($scope));

    $scope.listLastRuns = function() {
        console.log("list runs");
        return DataikuAPI.continuousActivities.listLastRuns($stateParams.projectKey, $stateParams.continuousActivityId).success(function(data){
            $scope.lastRuns = data.runs;
        }).error(setErrorInScope.bind($scope));
    };
    $scope.listLastAttempts = function() {
        console.log("list attempts");
        return DataikuAPI.continuousActivities.listRunLastAttempts($stateParams.projectKey, $stateParams.continuousActivityId, $stateParams.runId).success(function(data){
            $scope.lastAttempts = data.attempts;
        }).error(setErrorInScope.bind($scope));
    };

    let selectRun = function(run) {
        console.log("select run", run);
        $scope.selectedRun = run;
        $scope.selectedAttempt = null;
        $stateParams.runId = run ? run.runId : null;
    };
    let selectAttempt = function(attempt) {
        console.log("select attempt", attempt);
        $scope.selectedAttempt = attempt;
        $stateParams.attemptId = attempt ? attempt.attemptId : null;
    }
    
    $scope.selectRun = function(run) {
        selectRun(run);
        $scope.refreshLastAttemps();
    };
    $scope.selectAttempt = function(attempt) {
        selectAttempt(attempt);
        $scope.refreshLog();
    };

    $scope.refreshLog = function() {
        if (!$scope.selectedAttempt) return;
        DataikuAPI.continuousActivities.smartTailAttemptLog($stateParams.projectKey, $stateParams.continuousActivityId, $scope.selectedRun.runId, $scope.selectedAttempt.attemptId).success(function(data){
            $scope.attemptLogTail = smartLogTailToHTML(data, false);
        }).error(setErrorInScope.bind($scope));
    }
    $scope.refreshLastAttemps = function() {
        if (!$scope.selectedRun) return;
        $scope.listLastAttempts().then(function() {
            if ($stateParams.attemptId) {
                const attempt = $scope.lastAttempts.filter(x => x.attemptId == $stateParams.attemptId)[0];
                selectAttempt(attempt || $scope.lastAttempts[0]);
            } else {
                // no run selected, pick first
                selectAttempt($scope.lastAttempts[0]);
            }
        }).then(function() {
            console.log("and refresh log");
            $scope.refreshLog();
        });
    };
    $scope.refreshLastRuns = function() {
        $scope.listLastRuns().then(function() {
            if ($stateParams.runId) {
                const run = $scope.lastRuns.filter(x => x.runId == $stateParams.runId)[0];
                selectRun(run || $scope.lastRuns[0]);
            } else {
                // no run selected, pick first
                selectRun($scope.lastRuns[0]);
            }
        }).then(function() {
            console.log("and refresh attempts");
            $scope.refreshLastAttemps();
        });
    };

    $scope.refreshLastRuns();
    
    $scope.getDownloadUrl = function() {
        return DataikuAPI.continuousActivities.getDownloadURL($stateParams.projectKey, $stateParams.continuousActivityId, $scope.selectedRun.runId, $scope.selectedAttempt.attemptId);
    };
    
    let cancelPoll = null;
    let poll = function() {
        DataikuAPI.continuousActivities.getState($stateParams.projectKey, $stateParams.continuousActivityId).success(function(data){
            $scope.continuousActivityPage.state = data;
            if (data && data.mainLoopState && data.mainLoopState.futureInfo && data.mainLoopState.futureInfo.hasResult) {
                // loop exited, no point in polling anymore
                stopPoll();
            }
            $scope.listLastAttempts();
            $scope.refreshLog();
        }).error(setErrorInScope.bind($scope));
    };
    let stopPoll = function() {
        if (cancelPoll) $interval.cancel(cancelPoll);
    };
    let startPoll = function() {
        cancelPoll = $interval(poll, 5000);
    };
    $scope.$watch('continuousActivityPage.state.desiredState', function() {
        if ($scope.continuousActivityPage && $scope.continuousActivityPage.state) {
            if ($scope.continuousActivityPage.state.desiredState == 'STARTED') {
                stopPoll();
                startPoll();            
                $scope.listLastRuns().then(function() {
                    // auto select the new run
                    selectRun($scope.lastRuns[0]);
                }).then(function() {
                    $scope.refreshLastAttemps();
                });
            } else {
                stopPoll();
            }
        }
    });
    
    $scope.getFixedUpRunStatus = function(run, i) {
        let mainLoopState = (($scope.continuousActivityPage || {}).state || {}).mainLoopState || {};
        let futureInfo = mainLoopState.futureInfo || {};
        if (futureInfo.alive) {
            if (mainLoopState.runId == run.runId) {
                return 'running'; // even if the run's lastStatus is not running
            }
        }
        if (run.lastStatus != 'running') return run.lastStatus;
        if (i > 0) {
            return 'interrupted'; // only the last run can be still running
        }
        if (futureInfo.hasResult) {
            return "stopped";
        } else {
            return "running";
        }
    };
    
    $scope.getFixedUpAttemptStatus = function(attempt, i) {
        let mainLoopState = (($scope.continuousActivityPage || {}).state || {}).mainLoopState || {};
        let futureInfo = mainLoopState.futureInfo || {};
        if (attempt.status != 'running') return attempt.status;
        if (i > 0) {
            return 'interrupted'; // only the last run can be still running
        }
        if (mainLoopState.runId != $scope.selectedRun.runId || futureInfo.hasResult) {
            return "stopped";
        } else {
            return "running";
        }
    };
    
    $scope.$on("$destroy", function() {
        stopPoll();
    });
});


})();

(function(){
'use strict';

const app = angular.module('dataiku.webapps', []);

app.factory('WebAppSharedState', function () {
    return {};
});

app.controller("WebAppsCommonController", function($scope, $state, $rootScope, $stateParams, $q, $controller, TopNav,
        WebAppsService, LoggerProvider, WT1, DataikuAPI, FutureWatcher, Dialogs, CreateModalFromTemplate,
        ActivityIndicator, TAIL_STATUS, DKUtils, StateUtils, PluginsService, WebAppSharedState) {
    const Logger = LoggerProvider.getLogger('WebApps');

    $scope.hooks = $scope.hooks || {};

    /* Used to share some state between each specific kind of webapp controller, and the webapp edit/view controllers, which
     * are below this one */
    $scope.sharedState = WebAppSharedState;

    $scope.setupTypeSpecificWebAppBehaviour = function() {
        const baseType = $scope.getBaseType($scope.app.type);
        if (baseType == 'STANDARD') {
            $controller("StandardWebAppController", {$scope});
        } else if (baseType == 'BOKEH') {
            $controller("BokehWebAppController", {$scope});
        } else if (baseType == 'DASH') {
            $controller("DashWebAppController", {$scope});
        } else if (baseType == 'SHINY') {
            $controller("ShinyWebAppController", {$scope});
        } else {
            Logger.error("Unknown app base type: ", baseType);
        }
    };

    $scope.copy = function(app, callBackFunc) {
        function showModal() {
            const newScope = $scope.$new();
            newScope.app = app;
            CreateModalFromTemplate("/templates/webapps/copy-webapp-modal.html", newScope)
            .then(function() {
                if (typeof(callBackFunc) === 'function') callBackFunc();
            });
        }
        if ($scope.hooks.save) {
            $scope.saveWebAppWithCode().then(showModal, setErrorInScope.bind($scope));
        } else {
            showModal();
        }
    };

    $scope.transformToDevPlugin = function() {
        CreateModalFromTemplate("/templates/webapps/convert-webapp-to-custom.html", $scope, null, function(modalScope) {
            const getAPICallParams = function(scope) {
                const params = scope.convert;
                const pluginId = params.mode == 'NEW' ? params.newPluginId : params.targetPluginId;
                return [scope.app.projectKey,
                        scope.app.id,
                        pluginId,
                        params.targetFolder,
                        params.mode];
            };
            PluginsService.transformToDevPlugin(modalScope, DataikuAPI.webapps.convertToCustom, getAPICallParams,
                                                "plugin-convert-webapp", "customWebApps", $scope.app.type);
        });
    };

    $scope.createAndPinInsight = function(webapp) {
        WT1.event("webapp-publish", {webAppId: $stateParams.id, type: webapp.type});
        const insight = {
            projectKey: $stateParams.projectKey,
            type: 'web_app',
            params: {
                webAppSmartId: webapp.id,
                webAppType: webapp.type,
                apiKey: webapp.apiKey
            },
            name: webapp.name
        };
        CreateModalFromTemplate("/templates/dashboards/insights/create-and-pin-insight-modal.html", $scope, "CreateAndPinInsightModalController", function(newScope) {
            newScope.init(insight);
        });
    };

    $scope.backendEnabled = function () {
        return $scope.app && ($scope.app.params.backendEnabled || ['BOKEH', 'DASH', 'SHINY'].indexOf($scope.app.type) >= 0);
    };

    $scope.setBackendLogs = function(data) {
        var logs = null;
        if (data) {
            if (data.logTail) {
                logs = data.logTail;
            } else if (data.lastCrashLogTail) {
                logs = data.lastCrashLogTail;
            } else if (data.currentLogTail) {
                logs = data.currentLogTail;
            }
        }
        $scope.sharedState.backendLogTail = logs;
        if (logs) {
            $scope.errorsInLogs = logs.maxLevel == TAIL_STATUS.ERROR;
            $scope.warningsInLogs = logs.maxLevel == TAIL_STATUS.WARNING;
        } else {
            $scope.errorsInLogs = false;
            $scope.warningsInLogs = false;
        }
    };

    $scope.setBackendState = function(data) {
        $scope.sharedState.backendState = data;
        $scope.sharedState.backendRunning = !!(data && data.futureId && data.futureInfo && data.futureInfo.alive);
        if ($scope.sharedState.backendState) {
            if ($scope.backendEnabled() && !$scope.sharedState.backendRunning) {
                ActivityIndicator.error("Backend not running");
            } else {
                $scope.$broadcast("previewDataUpdated");
            }
        } else {
            $scope.$broadcast("previewDataUpdated");
        }
    };
    
    const editableTypes = ['BOKEH', 'DASH', 'SHINY', 'STANDARD'];
    $scope.isCustomWebAppType = function(webappType) {
        return !editableTypes.includes(webappType);
    };

    $scope.getBaseType = function(webappType) {
        return WebAppsService.getBaseType(webappType);
    };

    $scope.getWebAppTypeName = function(webappType) {
        return WebAppsService.getWebAppTypeName(webappType);
    };

    $scope.restartError = function(data, status, headers, deferred) {
        $scope.setBackendLogs(data);
        ActivityIndicator.error("Backend start failed (check logs)");
        $scope.sharedState.backendFuture = null;
        $scope.sharedState.backendFatalError = getErrorDetails(data, status, headers);
        $scope.sharedState.backendRunning = false;
        deferred.reject();
    };
    $scope.restartSuccess = function(data, deferred) {
        $scope.setBackendLogs(data.result);
        $scope.setBackendState(data.result);
        $scope.sharedState.backendFuture = null;
        $scope.sharedState.backendRunning = true;
        $rootScope.$broadcast("previewDataUpdated");
        deferred.resolve();
    };
    
    $scope.handleStartFuture = function(result, deferred) {
        $scope.sharedState.backendFuture = result;

        if (!result.alive && result.hasResult) {
            // already finished
            $scope.restartSuccess(result, deferred);
        } else {
            FutureWatcher.watchJobId(result.jobId)
            .success(function(data) {
               $scope.restartSuccess(data, deferred);
            }).update(function(data){
                $scope.sharedState.backendFuture = data;
            }).error(function(a, b, c) {
               $scope.restartError(a, b, c, deferred);
            });
        }
    };
    
    $scope.start = function(app){
        if ($scope.sharedState.backendRunning == null) {
            throw new Error("webapp already starting");
        }
        $scope.sharedState.backendRunning = null;
        
        WT1.event("webapp-start", {webAppId: $stateParams.id, type: app.type});
        const deferred = $q.defer();

        $scope.sharedState.backendFatalError = null;
        DataikuAPI.webapps.restartBackend(app).success(function(result) {
            $scope.sharedState.backendFuture = result;

            if (!result.alive && result.hasResult) {
                // already finished
                $scope.restartSuccess(result, deferred);
            } else {
                FutureWatcher.watchJobId(result.jobId)
                .success(function(data) {
                    $scope.restartSuccess(data, deferred);
                }).update(function(data){
                    $scope.sharedState.backendFuture = data;
                }).error(function(a,b,c) {
                    $scope.restartError(a,b,c, deferred);
                });
            }
            $rootScope.$broadcast('backendRestarted');
        }).error(function(a,b,c) {
            $scope.restartError(a,b,c, deferred);
        });

        return deferred.promise;
    };


    $scope.stop = function(webapp) {
        if ($scope.sharedState.backendRunning == null) {
            throw new Error("webapp already starting");
        }
        $scope.sharedState.backendRunning = null;
        
        WT1.event("webapp-stop", {webAppId: $stateParams.id, type: webapp.type});
        return DataikuAPI.webapps.stopBackend(webapp)
            .success(function(){
                $scope.sharedState.backendRunning = false;
                $rootScope.$broadcast('backendStopped');
            })
            .error(setErrorInScope.bind($scope));
    };

    $scope.stopBackendWithDialog = function(webapp) {
        Dialogs.confirm($scope, 'Stop webapp backend', 'Are you sure you want to stop the backend?').then(function () {
            $scope.stop(webapp).then(function(){
                $scope.list();
            });
        });
    };

    $scope.saveWebAppMetadata = function() {
        WT1.event("webapp-save-metadata", {webAppId: $scope.app.id, type: $scope.app.type});
        return DataikuAPI.webapps.saveMetadata($scope.app)
            .error(setErrorInScope.bind($scope))
            .success(function(resp) {
                ActivityIndicator.success("Saved!");
                $scope.hooks.origWebApp = angular.copy($scope.app);
            });
    };

    $scope.saveCustomFields = function(newCustomFields) {
        WT1.event('custom-fields-save', {objectType: 'WEB_APP'});
        let oldCustomFields = angular.copy($scope.app.customFields);
        $scope.app.customFields = newCustomFields;
        return $scope.saveWebAppMetadata().then(function() {
            $rootScope.$broadcast('customFieldsSaved', TopNav.getItem(), $scope.app.customFields);
        }, function() {
            $scope.app.customFields = oldCustomFields;
        });
    };

    $scope.editCustomFields = function() {
        if (!$scope.app) {
            return;
        }
        let modalScope = angular.extend($scope, {objectType: 'WEB_APP', objectName: $scope.app.name, objectCustomFields: $scope.app.customFields});
        CreateModalFromTemplate("/templates/taggable-objects/custom-fields-edit-modal.html", modalScope).then(function(customFields) {
            $scope.saveCustomFields(customFields);
        });
    };
});


app.controller("WebAppsListController", function($scope, $controller, $stateParams, DataikuAPI, CreateModalFromTemplate,$state,$q, TopNav, Fn, $filter, Dialogs, WT1) {
    
    $controller('_TaggableObjectsListPageCommon', {$scope: $scope});
    $controller("WebAppsCommonController", {$scope: $scope});

    $scope.listHeads = DataikuAPI.webapps.listHeads;

    $scope.sortBy = [
        { value: 'name', label: 'Name' },
        { value: '-lastModifiedOn', label: 'Last modified' }
    ];
    $scope.selection = $.extend({
        filterQuery: {
            userQuery: '',
            tags: [],
            interest: {
                starred: '',
            },
        },
        filterParams: {
            userQueryTargets: ["name","tags"],
            propertyRules: {tag: "tags"},
        },
        orderQuery: "-lastModifiedOn",
        orderReversed: false,
    }, $scope.selection || {});

    $scope.sortCookieKey = 'webapps';
    $scope.maxItems = 20;

    TopNav.setLocation(TopNav.TOP_NOTEBOOKS, 'webapps', TopNav.TABS_NONE, null);
    TopNav.setNoItem();
    $scope.list();

    $scope.hasVisualWebapps = false;

    DataikuAPI.webapps.listTypes().then(response => {
        const descriptors = Object.values(response.data);
        // in the flow, only show webapps with roles
        $scope.hasVisualWebapps = descriptors.some(descriptor => descriptor.baseType && (descriptor.roles == null || descriptor.roles.length == 0));
    });
    
    // override because there is no meaningfull sharedState
    $scope.stopBackendInList = function(webapp) {
        Dialogs.confirm($scope, 'Stop webapp backend', 'Are you sure you want to stop the backend?').then(function () {
            WT1.event("webapp-stop", {webAppId: $stateParams.id, type: webapp.type});
            return DataikuAPI.webapps.stopBackend(webapp)
                .success(function(){
                    $scope.list();
                })
                .error(setErrorInScope.bind($scope));
        });
    };
});


app.controller("WebAppCoreController", function($scope, $rootScope, $stateParams, $filter, $state, $controller, $timeout, $q, FutureWatcher, WT1, DKUtils, DataikuAPI, TopNav, WebAppsService, Assert, $interval, Notification) {

    $controller("WebAppsCommonController", {$scope: $scope});

    function getSummary() {
        return DataikuAPI.webapps.getSummary($stateParams.projectKey, $stateParams.webAppId).success(function(data) {
            $scope.app = data.object;
            $scope.timeline = data.timeline;
            $scope.interest = data.interest;
            $scope.setBackendState(data.backendState);
            $scope.hooks.origWebApp = angular.copy($scope.app);

            TopNav.setItem(TopNav.ITEM_WEB_APP, $stateParams.webAppId, $scope.app);
            TopNav.setPageTitle($scope.app.name + " - Webapp");

            $scope.$watch("app.name", function(nv) {
                if (!nv) return;
                $state.go($state.current, {webAppName: $filter('slugify')(nv)}, {location: true, inherit:true, notify:false, reload:false});
            });

            $scope.pluginDesc = WebAppsService.getOwnerPluginDesc($scope.app.type);
        }).error(setErrorInScope.bind($scope));
    }

    $scope.cancelKeepAlive = null;
    getSummary().then(function() {
        TopNav.setItem(TopNav.ITEM_WEB_APP, $stateParams.webAppId, $scope.app);
        TopNav.setPageTitle($scope.app.name + " - Webapp");

        $scope.$watch("app.name", function(nv) {
            if (!nv) return;
            $state.go($state.current, {webAppName: $filter('slugify')(nv)}, {location: true, inherit:true, notify:false, reload:false});
        });
    }).then(function() {
        if ($scope.app && $scope.app.isVirtual) {
            // keep it alive
            let KEEP_ALIVE_INTERVAL_MS = 10*1000;
            $scope.cancelKeepAlive = $interval(function () {
                Notification.publishToBackend('timeoutable-task-keepalive', {
                    taskId: 'webApp:' + $scope.app.projectKey + '.' + $scope.app.id
                });
            }, KEEP_ALIVE_INTERVAL_MS);
        }
    });

    $scope.$on('$destroy', function () {
        if ($scope.cancelKeepAlive) {
            $interval.cancel($scope.cancelKeepAlive);
        }
    });

    $scope.isDirty = function() {
        return !angular.equals($scope.app, $scope.hooks.origWebApp);
    };

    $scope.saveWebAppWithCode = function(commitMessage, forceRestartBackend) {
        WT1.event("webapp-save", {webAppId: $stateParams.id, type: $scope.app.type});
        var deferred = $q.defer();

        $scope.sharedState.backendFatalError = null;
        $scope.sharedState.backendRunning = null;
        DataikuAPI.webapps.save($scope.app, commitMessage, forceRestartBackend).success(function(result) {
        	$scope.hooks.origWebApp = angular.copy($scope.app);
            if (result.backendState == null) {
                // no backend, just update preview
                $scope.$broadcast("previewDataUpdated");
            } else {
                $scope.handleStartFuture(result.backendState, deferred);
            }
        }).error(setErrorInScope.bind($scope));

        return deferred.promise.then($scope.startUpdatePreview, function() {});
    };

    $scope.saveAndViewWebApp = function() {
        $scope.saveWebAppWithCode().then(function() {
            if ($scope.backendEnabled($scope.app)) {
                $scope.start($scope.app).then(function() {
                    $scope.startUpdatePreview().then(function(){
                        $state.go('projects.project.webapps.webapp.view');
                    });
                });
            } else {
                $state.go('projects.project.webapps.webapp.view');
            }
        });
    }

    let releaseListener = $scope.$watch("app", function(nv) {
        if (!nv) return;
        $scope.setupTypeSpecificWebAppBehaviour();
        releaseListener();
    });

    $scope.getBackendLogURL = function(app) {
        return DataikuAPI.webapps.getBackendLogURL(app.projectKey, app.id);
    };
});


app.controller("WebAppSummaryController", function($scope, $rootScope, $stateParams, DataikuAPI, TopNav) {
    TopNav.setLocation(TopNav.TOP_NOTEBOOKS, 'webapps', null, 'summary');

    function refreshTimeline() {
        DataikuAPI.timelines.getForObject($stateParams.projectKey, "WEB_APP", $stateParams.webAppId)
            .success(function(data){
                $scope.timeline = data;
            })
            .error(setErrorInScope.bind($scope));
    }

    $scope.$on("objectSummaryEdited", $scope.saveWebAppMetadata);

    $scope.$on('customFieldsSummaryEdited', function(event, customFields) {
        $scope.saveCustomFields(customFields);
    });
});

app.controller("WebAppPageRightColumnActions", async function($controller, $scope, $q, $rootScope, $stateParams, ActiveProjectKey, DataikuAPI, WT1) {

    $controller('_TaggableObjectPageRightColumnActions', {$scope: $scope});
    $controller("WebAppCoreController", {$scope: $scope});

    $scope.webAppFullInfo = (await DataikuAPI.webapps.getFullInfo(ActiveProjectKey.get(), $stateParams.webAppId)).data;
    $scope.app = $scope.webAppFullInfo.webapp;
    $scope.app.nodeType = 'WEB_APP';
    $scope.app.interest = $scope.webAppFullInfo.interest;


    $scope.selection = {
        selectedObject : $scope.app,
        confirmedItem : $scope.app
    };

    $scope.updateUserInterests = function() {
        DataikuAPI.interests.getForObject($rootScope.appConfig.login, "WEB_APP", ActiveProjectKey.get(), $scope.app.id)
            .success(function(data){
                $scope.selection.selectedObject.interest = data;
            })
            .error(setErrorInScope.bind($scope));
    }

    const interestsListener = $rootScope.$on('userInterestsUpdated', $scope.updateUserInterests);

    const backendRestartListener = $rootScope.$on('backendRestarted',function () {$scope.sharedState.backendRunning = true;});
    const backendStopListener = $rootScope.$on('backendStopped',function () {$scope.sharedState.backendRunning = false;});

    $scope.$on("$destroy", function() {
            interestsListener();
            backendRestartListener();
            backendStopListener();
        });

});

app.directive('webAppRightColumnSummary', function(DataikuAPI, $stateParams, GlobalProjectActions, QuickView, $controller, ActivityIndicator, $rootScope){
    return {
        templateUrl :'/templates/webapps/right-column-summary.html',
        link : function($scope, element, attrs) {
            $controller("WebAppsCommonController", {$scope: $scope});
            $controller('_TaggableObjectsMassActions', {$scope: $scope});
            $controller('_TaggableObjectsCapabilities', {$scope: $scope});

            $scope.QuickView = QuickView;

            /* Auto save when summary is modified */
            $scope.$on("objectSummaryEdited", function(){
                DataikuAPI.webapps.saveMetadata($scope.app).success(function(data) {
                    ActivityIndicator.success("Saved");
                }).error(setErrorInScope.bind($scope));
            });

            $scope.refreshData = function() {
                $scope.webAppFullInfo = { webapp: $scope.selection.selectedObject }; // temporary incomplete data
                DataikuAPI.webapps.getFullInfo($scope.selection.selectedObject.projectKey, $scope.selection.selectedObject.id).success(function(data) {
                    if (!$scope.selection.selectedObject
                        || $scope.selection.selectedObject.id != data.webapp.id
                        || $scope.selection.selectedObject.projectKey != data.webapp.projectKey) {
                        return; //too late!
                    }
                    $scope.webAppFullInfo = data;
                    $scope.app = data.webapp;
                }).error(setErrorInScope.bind($scope));
            };

            $scope.$watch("selection.confirmedItem", function(nv, ov) {
                if (!nv) return;
                $scope.refreshData();
            });
        }
    }
});

app.controller("NewWebAppModalController", function($scope, $window, $state, $stateParams, $controller, DataikuAPI, WT1, FutureWatcher, SpinnerService, PluginsService, WebAppsService, PluginConfigUtils) {

    $scope.usedInsightNames = ($scope.listItems || []).map(function(x){return (x.name || '').toLowerCase();});

    $scope.app = {
        type: '',
        name: '',
        params: {},
        config: {},
        configFromRole: {}
    };

    $scope.searchFilter = '';

    DataikuAPI.webapps.listTypes().then(resp => {
        const descriptors = Object.values(resp.data);
        function f(a, b) {
            const x = (a.meta.label||a.id).toUpperCase();
            const y = (b.meta.label||b.id).toUpperCase();
            if (x < y) {
                return -1;
            }
            if (x > y) {
                return 1;
            }
            return 0;
        }
        $scope.codeWebApps = descriptors.filter(d => !d.baseType).sort(f).reverse();
        $scope.visualWebApps = descriptors.filter(d => d.baseType && (d.roles == null || d.roles.length == 0)).sort(f);

        if ($scope.webappCategory === 'visual' && (!$scope.app || !$scope.app.type) && $scope.visualWebApps.length > 0) {
            $scope.chooseType($scope.visualWebApps[0].id);
        }
    });

    $scope.create = function(preferVirtualOrPersisted){
        WT1.event("webapp-create", { webAppId: $stateParams.id || $scope.app.id, type: $scope.app.webappType || $scope.app.type });

        $scope.isCreating = true;
        DataikuAPI.webapps.create($stateParams.projectKey, $scope.app.name, $scope.app.webappType || $scope.app.type, $scope.app.template, $scope.app.config)
        .success(function(result) {
            $scope.app.id = result.webAppId;

            if (result.backendState && !result.backendState.hasResult) { // There is a backend still starting, wait for it
                SpinnerService.lockOnPromise(FutureWatcher.watchJobId(result.backendState.jobId)
                .success(function(data) {
                    $scope.app.backendReadyOrNoBackend = true;
                    $scope.resolveModal($scope.app);
                }).error(function(data, status, headers) {
                    $scope.app.backendReadyOrNoBackend = false;
                    $scope.resolveModal($scope.app);
                }));
            } else { // No backend, nothing to wait for
                if ($scope.desc && 'hasBackend' in $scope.desc) { // only defined for visual webapps
                    $scope.app.backendReadyOrNoBackend = !$scope.desc.hasBackend;
                } else {
                    $scope.app.backendReadyOrNoBackend = false; // go to edit tab upon creation for code webapp
                }
                $scope.resolveModal($scope.app);
            }
        }).error(function(data, status, headers, config, statusText, xhrStatus) {
            $scope.isCreating = false;
            setErrorInScope.bind($scope)(data, status, headers, config, statusText, xhrStatus);
        });
    };

    $scope.chooseType = function(type) {
        if (!type) {
            throw new Error("Choose webapp type: type parameter required");
        }

        if (type == 'STANDARD') {
            $controller("StandardWebAppController", {$scope: $scope});
        } else if (type == 'BOKEH') {
            $controller("BokehWebAppController", {$scope: $scope});
        } else if (type == 'DASH') {
            $controller("DashWebAppController", {$scope: $scope});
        } else if (type == 'SHINY') {
            $controller("ShinyWebAppController", {$scope: $scope});
        }

        $scope.app.type = type;
        $scope.loadedDesc = WebAppsService.getWebAppLoadedDesc(type) || {};
        $scope.desc = $scope.loadedDesc.desc;
        $scope.pluginDesc = WebAppsService.getOwnerPluginDesc(type);

        if ($scope.pluginDesc && $scope.desc && $scope.desc.params) {
            $scope.app.config = angular.copy($scope.app.configFromRole);
            PluginConfigUtils.setDefaultValues($scope.desc.params, $scope.app.config);
        }

        DataikuAPI.webapps.listTemplates(type).success(function(data) {
            $scope.availableTemplates = data.templates;
            $scope.app.template = $scope.availableTemplates[0];
        }).error(setErrorInScope.bind($scope));

        setTimeout(function(){
            $($window).trigger('resize.modal');
            $('#webapp-name').focus();
        });
        ;
    };


    $scope.getWebAppTypeName = function(webappType) {
        return WebAppsService.getWebAppTypeName(webappType);
    };
});


app.controller("CopyWebAppModalController", function($scope, $state, DataikuAPI, ActivityIndicator, StateUtils, WT1) {

    $scope.newWebApp = {
        name: "Copy of "+$scope.app.name
    };

    $scope.copyWebApp = function() {
        WT1.event("webapp-copy", {type: $scope.app.type});
        return DataikuAPI.webapps.copy($scope.app.projectKey, $scope.app.id, $scope.newWebApp.name)
        .success(function(createdWebApp) {
            $scope.resolveModal(createdWebApp);
            let href = $state.href("projects.project.webapps.webapp.edit", {projectKey: createdWebApp.projectKey, webAppId: createdWebApp.id});

            ActivityIndicator.success(
                '<strong>'+$scope.app.name + '</strong> copied into <strong>' + createdWebApp.name + '</strong>, ' +
                '<a href="'+href+'">edit it now</a>.'
                , 5000);
            if ($scope.list) {
                $scope.list();
                $scope.selection.selectedObject = null;
            }
        })
        .error(setErrorInScope.bind($scope))
    };
});


app.controller("WebAppHistoryController", function($scope, TopNav) {
    TopNav.setLocation(TopNav.TOP_NOTEBOOKS, "webapps", null, "history");
});

app.controller("WebAppLogsController", function($scope, $stateParams, $timeout, $q, TopNav, DataikuAPI, WT1) {
    TopNav.setLocation(TopNav.TOP_NOTEBOOKS, "webapps", null, "logs");

    $scope.restartBackend = function(app) {
        var deferred = $q.defer();
        $scope.start(app).then($scope.refreshBackendLog, $scope.refreshBackendLog);
        return deferred.promise;
    };

    $scope.refreshBackendLog = function() {
        DataikuAPI.webapps.getBackendState($scope.app)
            .success(function(result) {
                $scope.setBackendLogs(result);
            }).error(setErrorInScope.bind($scope));
    };
    $scope.refreshBackendLog();
});

app.controller("_PreviewWebAppController", function($scope, $q, $sce, ActivityIndicator, DataikuAPI, Logger, $rootScope) {
    $scope.startUpdatePreview = function() {
        if ($scope.backendEnabled() && $scope.sharedState.backendRunning !== true) {
            Logger.warn("Not updating preview, backend is not running ...", printStackTrace());
            return;
        }
        return DataikuAPI.webapps.getBackendState($scope.app)
            .success(handleBackendStateResult)
            .error(setErrorInScope.bind($scope));
    };

    $scope.renderPreview = function(iframe) {
        if (!iframe || !iframe.length) {return;}
        if (!$scope.sharedState.backendState) {return;}
        startUpdatePreviewIFrameSource(iframe)
    };

    function startUpdatePreviewIFrameSource(iframe) {
        if ($scope.sharedState.backendState) {
            if ($rootScope.appConfig.webappsIsolationMode === "SANDBOX") {
                iframe.get(0).sandbox = "allow-forms allow-pointer-lock allow-popups allow-scripts" ;
            }
            $scope.getViewURL($scope.app).then(function(url) {
                iframe.attr('src', url);
            });
        }
    }

    function handleBackendStateResult(backendState) {
        if (backendState) {
            if ($scope.backendEnabled()) {
                $scope.sharedState.backendRunning = !!(backendState.futureId && backendState.futureInfo && backendState.futureInfo.alive);
                $scope.setBackendLogs(backendState);
                if (!backendState.futureInfo || !backendState.futureInfo.alive) {
                    ActivityIndicator.error("Backend not running");
                } else {
                    $scope.$broadcast("previewDataUpdated");
                }
            } else {
                $scope.$broadcast("previewDataUpdated");
            }
        } else {
            $scope.$broadcast("previewDataUpdated");
        }
    }
});


app.controller("_BokehDashOrShinyLikeWebAppController", function($scope, $controller, $q, $sce, ActivityIndicator, DataikuAPI, Logger, $rootScope) {
    $controller("_PreviewWebAppController", {$scope:$scope});
    
    $scope.availableTemplates = [
        {
            id : "default",
            label : "Default code"
        },
        {
            id : "empty",
            label : "Empty webapp"
        }
    ];
    $scope.defaultTemplate = 'default';

    $scope.backendEnabled = function (webapp) {
        return true;
    };

    $scope.showFrontendTabs = function(webapp) {
        return false;
    };
});


app.service('WebAppsService', function($rootScope, PluginsService) {
    const svc = this;
    svc.getWebAppLoadedDesc = function(webappType) {
        return $rootScope.appConfig.customWebApps.find(x => x.webappType == webappType);
    };
    svc.getOwnerPluginDesc = function(webappType) {
        return PluginsService.getOwnerPluginDesc(svc.getWebAppLoadedDesc(webappType));
    };
    svc.getWebAppIcon = function(webappType) {
        const loadedDesc = svc.getWebAppLoadedDesc(webappType);
        if (loadedDesc && loadedDesc.desc && loadedDesc.desc.meta && loadedDesc.desc.meta.icon) {
            return loadedDesc.desc.meta.icon;
        } else {
            const pluginDesc = PluginsService.getOwnerPluginDesc(loadedDesc);
            if (pluginDesc) {
                return pluginDesc.icon || "icon-puzzle-piece";
            } else {
                return "icon-puzzle-piece"; // plugin has been removed
            }
        }
    };
    svc.getWebAppTypeName = function(webappType) {
        const loadedDesc = svc.getWebAppLoadedDesc(webappType);
        if (loadedDesc && loadedDesc.desc && loadedDesc.desc.meta && loadedDesc.desc.meta.label) {
            return loadedDesc.desc.meta.label;
        } else {
            return webappType.toLowerCase();
        }
    };
    svc.getBaseType = function(webappType) {
        if (!webappType) return;
        const loadedDesc = svc.getWebAppLoadedDesc(webappType);
        if (loadedDesc && loadedDesc.desc && loadedDesc.desc.baseType) {
            return loadedDesc.desc.baseType;
        }
        return webappType;
    };
    svc.getSkins = function(objectType, path, contentType) {
        return $rootScope.appConfig.customWebApps.filter(function(w) {
            return (w.desc.roles || []).filter(function(r) {
                                                                if (r.type != objectType) return false;
                                                                if (path != null && path.length > 0) {
                                                                    // file in folder or version in model
                                                                    if (r.pathParamsKey == null || r.pathParamsKey.length == 0) return false;
                                                                } else {
                                                                    // folder or model
                                                                    if (r.pathParamsKey != null && r.pathParamsKey.length > 0) return false;
                                                                }
                                                                if (r.contentType != null && r.contentType.length > 0) {
                                                                    // additional filter on contentType
                                                                    if (contentType == null || contentType.length == 0) return false;
                                                                    if (!contentType.startsWith(r.contentType)) return false;
                                                                }
                                                                return true;
                                                            }).length == 1;
        });
    };
});

app.directive('webAppInfra', function(DataikuAPI, $stateParams, $controller, PluginConfigUtils, $timeout){
    return {
        templateUrl :'/templates/webapps/web-app-infra.html',
        scope : {
            infra: '=webAppInfra',
            webAppType: '='
        },
        link : function($scope, $element, attrs) {
            $scope.isVirtualWebappSettings = (!$stateParams.projectKey) && (!$stateParams.webAppId);
            // watch for changes in the container selection
            function fetchInfo() {
                if ($scope.infra && $scope.infra.containerSelection) {
                    DataikuAPI.containers.getConfigInfo($stateParams.projectKey, "WEBAPP", "WEBAPP", $scope.infra.containerSelection, null).success(function(data) {
                        $scope.containerInfo = data;
                    }).error(setErrorInScope.bind($scope));
                }
            };
            fetchInfo();
            $scope.$watch("infra.containerSelection", function(nv, ov) {
                if (!angular.equals(ov, nv)) fetchInfo()
            }, true);
        }
    }
});

// directive to maintain a $containerInfo field in the scope
app.controller('FetchContainerInfoController', function($scope, DataikuAPI, $stateParams, $controller, PluginConfigUtils, $timeout) {
    // watch for changes in the container selection
    function fetchInfo() {
        if ($scope.exposableKind && ($scope.containerSelection || $scope.inlineContainerConfig)) {
            DataikuAPI.containers.getConfigInfo($stateParams.projectKey, $scope.exposableKind, $scope.expositionUsageContext, $scope.containerSelection, $scope.inlineContainerConfig).success(function(data) {
                $scope.$containerInfo = data;
            }).error(setErrorInScope.bind($scope));
        } else if ($scope.containerType) {
            DataikuAPI.containers.getExpositions($scope.containerType, $scope.exposableKind, $scope.expositionUsageContext).success(function(data) {
                $scope.$containerInfo = data;
            }).error(setErrorInScope.bind($scope));
        }
    };
    // for when the containerInfo is set from outside (webapps)
    $scope.$watch("containerInfo", function() {
        if ($scope.containerInfo) {
            $scope.$containerInfo = $scope.containerInfo;
        }
    });
    // if the parent of this directive is not filling the containerInfo itself, do it
    if ($scope.containerInfo) {
        $scope.$containerInfo = $scope.containerInfo;
    } else {
        fetchInfo();
    }
    $scope.$watch("containerSelection", function(nv, ov) {
        if (!angular.equals(ov, nv)) fetchInfo()
    }, true);
    $scope.$watch("inlineContainerConfig", function(nv, ov) {
        if (!angular.equals(ov, nv)) fetchInfo()
    }, true);
    $scope.$watch("exposableKind", function(nv, ov) {
        if (!angular.equals(ov, nv)) fetchInfo()
    }, false);
});


app.directive('serviceExposition', function(DataikuAPI, $stateParams, $controller, PluginConfigUtils, $timeout, $rootScope){
    return {
        templateUrl :'/templates/webapps/service-exposition.html',
        scope : {
            exposition: '=serviceExposition',
            containerInfo: '=',
            exposableKind: '=',
            containerType: '=',
            expositionUsageContext: '=',
            containerSelection: '=',
            inlineContainerConfig: '='
        },
        link : function($scope, $element, attrs) {
            $controller('FetchContainerInfoController', {$scope});
            function getPluginInfoIfNeeded() {
                if ($scope.$exposition == null || $scope.exposition == null) return;
                // find the plugin if exposition is provided by a plugin
                $scope.$exposition.loadedDesc = $rootScope.appConfig.customExpositions.filter(function(x){
                    return x.expositionType == $scope.exposition.type;
                })[0];
            };
            // watch for changes in the containerInfo, to adjust the exposition
            function fixupExposition() {
                if ($scope.$containerInfo) {
                    if ($scope.$containerInfo.expositions) {
                        let currentExpositionType = $scope.exposition ? $scope.exposition.type : null;
                        $scope.$exposition = $scope.$containerInfo.expositions.filter(function(e) {return e.type == currentExpositionType;})[0];
                        if ($scope.$exposition == null) {
                            $scope.$exposition = $scope.$containerInfo.expositions[0];
                            $scope.exposition = $scope.exposition || {};
                            $scope.exposition.type = $scope.$exposition ? $scope.$exposition.type : null;
                        }
                        getPluginInfoIfNeeded();
                    } else {
                        $scope.exposition = null; // to set the default
                    }
                }
            };
            $scope.$watch("$containerInfo", fixupExposition, true);
 
            // watch for changes in the $exposition to set the type
            $scope.$watch("exposition.type", function(nv, ov) {
                if ($scope.exposition && $scope.exposition.type) {
                    $scope.exposition = $scope.exposition || {};
                    if ($scope.$containerInfo && $scope.$containerInfo.expositions) {
                        $scope.$exposition = $scope.$containerInfo.expositions.filter(function(e) {return e.type == $scope.exposition.type;})[0];
                        getPluginInfoIfNeeded();
                    }
                    $scope.exposition.params = $scope.exposition.params || {};
                    if ($scope.$exposition && $scope.$exposition.params) {
                        PluginConfigUtils.setDefaultValues($scope.$exposition.params, $scope.exposition.params);
                    }
                }
            }, false);
        }
    }
});
   
app.directive('deploymentHpa', function(DataikuAPI, $stateParams, $controller, PluginConfigUtils, $timeout){
    return {
        templateUrl :'/templates/webapps/deployment-hpa.html',
        scope : {
            scaling: '=deploymentHpa',
            containerInfo: '=',
            exposableKind: '=',
            containerType: '=',
            expositionUsageContext: '=',
            containerSelection: '=',
            inlineContainerConfig: '='
        },
        link : function($scope, $element, attrs) {
            $controller('FetchContainerInfoController', {$scope});
            
            var doShowExtraMetrics = false;
            $scope.areExtraMetricsShown = function() {
                return doShowExtraMetrics || $scope.scaling.extraMetrics;
            };
            $scope.showExtraMetrics = function() {
                doShowExtraMetrics = true;
            };
        }
    }
});

 app.directive('yamlModifier', function(DataikuAPI, $stateParams, $controller, PluginConfigUtils, $timeout){
    return {
        templateUrl :'/templates/webapps/yaml-modifier.html',
        scope : {
            yamlModifier: '=yamlModifier',
            containerInfo: '=',
            exposableKind: '=',
            containerType: '=',
            expositionUsageContext: '=',
            containerSelection: '=',
            inlineContainerConfig: '='
        },
        link : function($scope, $element, attrs) {
            $controller('FetchContainerInfoController', {$scope});
            
            $scope.uiState = {runnableType:null, runnableTypes:[{runnableType:null, desc:{meta:{label:'None'}, params:[]}}]};
            
            let fixupRunnableType = function() {
                // clear the runnable type if it's not valid
                if ($scope.$containerInfo && $scope.yamlModifier && $scope.yamlModifier.runnableType) {
                    let existing = $scope.$containerInfo.yamlModifiers.filter(function(e) {return e.runnableType == $scope.yamlModifier.runnableType;});
                    if (!existing || existing.length == 0) {
                        $scope.yamlModifier.runnableType = null;
                        $scope.uiState.runnableType = null;
                    } else {
                         $scope.$yamlModifier = existing[0];
                    }
                }
            };
            
            $scope.$watch('$containerInfo', function() {
                if ($scope.$containerInfo) {
                    $scope.uiState.runnableTypes.splice(1, $scope.uiState.runnableTypes.length - 1);
                    $scope.$containerInfo.yamlModifiers.forEach(function(d) {
                        $scope.uiState.runnableTypes.push(d)
                    });
                }
                fixupRunnableType();
            });
            
            let setRunnableTypeFromRunnable = function() {
                $scope.uiState.runnableType = $scope.yamlModifier.runnableType;
            };
            
            let setRunnableTypeFromUI = function() {
                let choice = $scope.uiState.runnableTypes.filter(function(e) {return e.runnableType == $scope.uiState.runnableType})[0];
                if (!choice) return;
                if (choice.runnableType == $scope.yamlModifier.runnableType) return;
                $scope.yamlModifier.runnableType = choice.runnableType;
            };
            $scope.$watch('uiState.runnableType', setRunnableTypeFromUI);
            
            let init = function() {
                if (!$scope.yamlModifier.config) {
                    $scope.yamlModifier.config = {};
                }

                fixupRunnableType();

                $scope.$watch("yamlModifier.runnableType", function(nv, ov) {
                    if ($scope.uiState.runnableTypes) {
                        $scope.$yamlModifier = $scope.uiState.runnableTypes.filter(function(e) {return e.runnableType == $scope.yamlModifier.runnableType;})[0];
                    } else {
                        $scope.$yamlModifier = null;
                    }
                    if ($scope.$yamlModifier) {
                        if ($scope.yamlModifier.config == null) {
                            $scope.yamlModifier.config = {};
                        }
                        PluginConfigUtils.setDefaultValues($scope.$yamlModifier.desc.params, $scope.yamlModifier.config);
                    }
                });
                setRunnableTypeFromRunnable();
            };
            if ($scope.yamlModifier) {
                init();
            } else {
                let deregister = $scope.$watch("yamlModifier", function() {
                    if ($scope.yamlModifier) {
                        init();
                        deregister();
                    }
                });
            }
        }
    }
});
   

})();

(function() {
'use strict';

const app = angular.module('dataiku.webapps');


app.controller("WebAppViewController", function($scope, $stateParams, $rootScope, $state, $q, $sce, $controller, CreateModalFromTemplate, DataikuAPI, WT1, TopNav) {

    TopNav.setLocation(TopNav.TOP_NOTEBOOKS, 'webapps', null, 'view');

    $scope.setupTypeSpecificWebAppBehaviour();
    $scope.getViewURL($scope.app).then(function(url) {
        $scope.iFrameUrl = url;
    });

    $scope.restartBackend = function(app) {
        var deferred = $q.defer();
        $scope.start(app)
            .then($scope.hooks.refreshWebAppView);
        return deferred.promise;
    };

    $scope.hooks.refreshWebAppView = function() {
        const iframe = $('iframe.webapp-container');
        $scope.getViewURL($scope.app).then(function(url) {
            iframe.attr('src', url);
        });
    };

    const backendRestartListener = $rootScope.$on('backendRestarted',function () {$scope.sharedState.backendRunning = true;});
    const backendStopListener = $rootScope.$on('backendStopped',function () {$scope.sharedState.backendRunning = false;});

    $scope.$on("$destroy", function() {
        backendRestartListener();
        backendStopListener();
    });
});

app.service('VirtualWebApp', function($stateParams, $q, DataikuAPI, Logger, WebAppsService, $compile, FutureWatcher,
    FutureProgressModal, LocalStorage, PluginConfigUtils) {
    function updateSkin($scope, $container, webAppTypeProp, webAppConfigProp, projectKey, objectId, objectType,
        pathInObject, uiState, reuseConfig) {

        const webAppType = $scope.$eval(webAppTypeProp);
        let localStorageKey = objectType + '.' + webAppType + '/' + projectKey + '.' + objectId + '/' + pathInObject;
        if ($scope.insight) {
            // for dashboards when multiple views in the same slide
            localStorageKey += "/insight-" + $scope.insight.id;
        } 
        const stored = LocalStorage.get(localStorageKey);
        if (stored) {
            Logger.info("Found stored for " + localStorageKey, stored);
            if ($scope.storedWebAppId === undefined || $scope.storedWebAppId !== stored.webAppId) {
                $scope.storedWebAppId = stored.webAppId;
                if (stored.cfg) {
                    // unplug the watch otherwise one webapp will 'bleed' on the next
                    if ($scope.webAppConfigDeregister) {
                        $scope.webAppConfigDeregister();
                        $scope.webAppConfigDeregister = null;
                    }

                    if (reuseConfig) {
                        // do this before the let webAppConfig = ...
                        $scope[webAppConfigProp] = stored.cfg;
                    }
                }
            }
        }

        uiState.forgetAndRegenerateWebAppView = function() {
            LocalStorage.set(localStorageKey, null);
            if (uiState.regenerateWebAppView) {
                uiState.regenerateWebAppView();
            }
        }

        let webAppConfig = $scope.$eval(webAppConfigProp);

        const hooks = {
            webAppReady: function(webAppId) {
                Logger.info("Store webapp id", webAppId);
                LocalStorage.set(localStorageKey, {webAppId:webAppId, cfg:webAppConfig});
                setCurrentWebAppConfig(webAppId, webAppConfig);

                if ($scope.webAppConfigDeregister) {
                    $scope.webAppConfigDeregister();
                }
                $scope.webAppConfigDeregister = $scope.$watch(webAppConfigProp, function() {
                    LocalStorage.set(localStorageKey, {webAppId:webAppId, cfg:$scope.$eval(webAppConfigProp)});
                    setCurrentWebAppConfig(webAppId, webAppConfig);
                }, true);
            }
        };

        function setCurrentWebAppConfig(webAppId, webAppConfig) {
            $scope.storedWebAppId = webAppId;
            $scope[webAppConfigProp] = webAppConfig;
        }

        return svc.update($scope, $container, webAppTypeProp, webAppConfigProp,
            DataikuAPI.webapps.getOrCreatePluginSkin.bind($scope, projectKey, objectType, objectId, webAppType, webAppConfig),
            uiState, hooks);
    }

    const svc = {
        changeSkin: function($scope, roleType, skin, uiState, skinHolderCSSClass, targetParamsKey, pathParamsKey,
        reuseConfig) {
            if (!skin || !skin.webappType) return;

            if (skin.webappType != $scope.webAppType) {
                Logger.info("Skin type change to " + skin.webappType);
                $scope.webAppConfig = {};
                if ($scope.webAppCustomConfig) {
                    // webAppCustomConfig from the dashboard param tile
                    $scope.webAppConfig = {
                        ...$scope.webAppCustomConfig
                    }
                }
                $scope.webAppType = skin.webappType;
                $scope.loadedDesc = WebAppsService.getWebAppLoadedDesc($scope.webAppType) || {};
                $scope.desc = $scope.loadedDesc.desc;
                $scope.pluginDesc = WebAppsService.getOwnerPluginDesc($scope.webAppType);
                PluginConfigUtils.setDefaultValues($scope.loadedDesc.desc.params, $scope.webAppConfig);
                const role = $scope.loadedDesc.desc.roles.filter(r => r.type === roleType)[0];
                $scope.webAppConfig[role.targetParamsKey] = targetParamsKey;
                if (pathParamsKey) {
                    $scope.webAppConfig[role.pathParamsKey] = pathParamsKey;
                }
            }

            const $container = angular.element($('.' + skinHolderCSSClass));

            uiState.skinWebApp = {};

            updateSkin($scope, $container, 'webAppType', 'webAppConfig',
                $stateParams.sourceProjectKey || $stateParams.projectKey, targetParamsKey, roleType, pathParamsKey,
                uiState.skinWebApp, reuseConfig);
        },
        update: function($scope, $container, webAppTypeProp, webAppConfigProp, getOrCreate, uiState, hooks) {
            Logger.info("Update virtual webapp in scope " + $scope.$id + " with container scope " + $container.scope().$id);

            var deferred = $q.defer();
            let existingWebAppId = null;
            // check is the webapp is already shown
            let existing = $container.find("div[virtual-web-app-holder]");
            if (existing.length > 0) {
                existingWebAppId = existing.attr("web-app-id");
                Logger.info("Located an existing webapp " + existingWebAppId);
            }
            let insightWebAppId = null;
            if (existingWebAppId == null && $scope.insight) {
                let localStorageKey = "insight-chart-" + $stateParams.projectKey + "." + $scope.insight.id;
                insightWebAppId = LocalStorage.get(localStorageKey);
                if (insightWebAppId) {
                    Logger.info("Located an existing webapp for the insight " + insightWebAppId);
                }
            }
            if ($scope.webAppCreationInProgress) {
                deferred.reject("already creating");
                return;
            }
            let runningWebAppId = $scope.storedWebAppId || existingWebAppId || insightWebAppId;

            let getIframeWindow = function() {
                let chartIframe = $container.find("iframe");
                if (!chartIframe || chartIframe.length == 0) {
                    Logger.warn("Failed to find chart's iframe", $container);
                    return null;
                } else {
                    return chartIframe[0].contentWindow;
                }
            };

            let sendConfig = function() {
                let iframeWindow = getIframeWindow();
                if (iframeWindow) {
                    let cfg = $scope.$eval(webAppConfigProp);
                    if (hooks && hooks.webAppConfigPreparation) {
                        cfg = hooks.webAppConfigPreparation(cfg);
                    }
                    iframeWindow.postMessage(JSON.stringify(cfg), location.origin)
                } else {
                    Logger.warn("Chart's iframe is not ready");
                }
            };
            
            if ($container.scope().pingFromWebapp == null) {
                $container.scope().pingFromWebapp = function(event) {
                    // check if it's from our iframe
                    let iframeWindow = getIframeWindow();
                    if (event.source && event.source == iframeWindow) {
                        Logger.info("Got ping from my iframe in " + $container.scope().$id + " saying " + event.data);
                        if (event.data == 'sendConfig') {
                            sendConfig();
                        }
                    }
                };
                Logger.info("Setup ping from child iframe listener in " + $container.scope().$id);
                window.addEventListener('message', $container.scope().pingFromWebapp);
                $container.scope().$on('$destroy', function () {
                    Logger.info("Teardown ping from child iframe listener in " + $container.scope().$id);
                    window.removeEventListener('message', $container.scope().pingFromWebapp);
                });
            } 

            var webAppConfigPropDeregister = null;
            if (!(uiState && uiState.noConfigWatch) && $scope.watchingWebAppConfigProp == null) {
                $scope.watchingWebAppConfigProp = true; // register a watch only once per scope
                webAppConfigPropDeregister = $scope.$watch(webAppConfigProp, sendConfig, true);
            }
            if (hooks && hooks.stopFunction != null && webAppConfigPropDeregister != null) {
                var stopFunctionDeregister = $scope.$watch(hooks.stopFunction, function() {
                    if (hooks.stopFunction()) {
                        webAppConfigPropDeregister();
                        stopFunctionDeregister();
                    }
                });
            }

            function cleanupExisting() {
                // cleanup scopes manually since we touch the DOM directly
                let existing = $container.find("div[virtual-web-app-holder]");
                if (existing.length > 0) {
                    Logger.info("Found existing holder to destroy in scope ", existing.scope().$id);
                    existing.scope().$destroy();
                }
                $container.html('');
            }

            var refreshWebAppView = function() {
                Logger.info("Update webapp shown to " + $scope.webAppId);
                if (!$scope.webAppId) {
                    return;
                }
                cleanupExisting();
                let newElement = $compile('<div class="h100" virtual-web-app-holder web-app-id="webAppId" web-app-type="' + webAppTypeProp + '"></div>')($scope.$new());
                newElement.attr("web-app-id", $scope.webAppId);
                $container.html(newElement);
                existingWebAppId = $scope.webAppId;
                if (uiState && uiState.skinWebApp) uiState.skinWebApp.webAppId = $scope.webAppId;
                
                if ($scope.insight) {
                    let localStorageKey = "insight-chart-" + $stateParams.projectKey + "." + $scope.insight.id;
                    LocalStorage.set(localStorageKey, existingWebAppId);
                }
            }

            function doCreation(webAppId) {
                if (uiState && uiState.skinWebApp) uiState.skinWebApp.webAppId = $scope.webAppId;
                $scope.webAppCreationInProgress = true;
                getOrCreate(webAppId)
                    .success(function (data) {
                        $scope.webAppCreationInProgress = false;
                        uiState.webAppId = data.webapp.id;
                        uiState.hasBackend = data.resp.backendState != null;
                        let showWebappIfNew = function() {
                            Logger.info("show if needed " + data.webapp.id + " vs. " + existingWebAppId);
                            if (data.webapp.id != existingWebAppId) {
                                $scope.webAppId = data.webapp.id;
                                refreshWebAppView();
                                sendConfig();
                            }
                        };
                        if (data.resp.backendState && data.resp.backendState.hasResult == false) {
                            // webapp backend is still starting
                            if ($scope.tile) {
                                $scope.chartSpecific = $scope.chartSpecific || {};
                                $scope.chartSpecific.backendStarting = true;
                                // don't show a in-your-face modal on dashboards (imagine several charts on the same)
                                FutureWatcher.watchJobId(data.resp.backendState.jobId)
                                .success(function() {
                                    $scope.chartSpecific.backendStarting = false;
                                    showWebappIfNew();
                                    sendConfig();
                                }).error(function(a,b,c) {
                                    $scope.chartSpecific.backendStarting = false;
                                    if (hooks && hooks.handleError != null) {
                                        hooks.handleError(a,b,c);
                                    } else {
                                        setErrorInScope.bind($scope)(a,b,c);
                                    }
                                });
                            } else {
                                FutureProgressModal.show($scope, data.resp.backendState, "Starting view")
                                .then(function() {
                                   showWebappIfNew();
                                   sendConfig();
                                });
                            }
                        } else {
                           showWebappIfNew();
                           sendConfig();
                        }
                        if (hooks && hooks.webAppReady) {
                            hooks.webAppReady(data.webapp.id);
                        }
                        deferred.resolve(data.webapp.id);
                    }).error(function(a,b,c) {
                        $scope.webAppCreationInProgress = false;
                        if (hooks && hooks.handleError != null) {
                            hooks.handleError(a,b,c);
                        } else {
                            setErrorInScope.bind($scope)(a,b,c);
                        }
                        deferred.reject("failed to create webapp");
                    });
            }

            uiState.refreshWebAppView = refreshWebAppView;
            uiState.regenerateWebAppView = function() {
                if (uiState.hasBackend) {
                    // kill it now, since we'll forget the webappid just after, and nobody else can have this webapp open
                    DataikuAPI.webapps.stopBackend({projectKey:$stateParams.projectKey, id:$scope.webAppId}); // don't care about the outcome
                }
                $scope.webAppId = null;
                cleanupExisting();
                doCreation(null);
            }
            uiState.restartBackend = function() {
                DataikuAPI.webapps.restartBackend({projectKey:$stateParams.projectKey, id:$scope.webAppId}).success(function(result) {
                    if (!result.alive && result.hasResult) {
                        // already finished
                       refreshWebAppView();
                       sendConfig();
                    } else {
                        FutureProgressModal.show($scope, result, "Restarting backend").then(function() {
                           refreshWebAppView();
                           sendConfig();
                        });
                    }
                }).error(function(a,b,c) {
                    if (hooks && hooks.handleError != null) {
                        hooks.handleError(a,b,c);
                    } else {
                        setErrorInScope.bind($scope)(a,b,c);
                    }
                });
            }

            // start the webapp
            doCreation(runningWebAppId);

            // make sure we cleanup when the webapp holder is removed (caution: the $scope is not necessarily that of the $container)
            $container.scope().$on('$destroy', function () {
                Logger.info("Teardown virtual webapp shown in " + $scope.$id);
                cleanupExisting();
            });

            return deferred.promise;
        }
    };
    return svc;
});

app.directive('virtualWebAppHolder', function($stateParams, $controller, $q, DataikuAPI, Logger, WebAppsService, $interval, Notification) {
    return {
        templateUrl: '/templates/webapps/virtual-web-app-holder.html',
        scope: {
            webAppType: '=',
            webAppId: '='
        },
        link: function($scope, element, attrs) {
            Logger.info("Linking virtual webApp holder in " + $scope.$id);
            $scope.element = element;

            const baseType = WebAppsService.getBaseType($scope.webAppType);
            if (baseType == 'STANDARD') {
                $controller("StandardWebAppController", {$scope: $scope});
            } else if (baseType == 'BOKEH') {
                $controller("BokehWebAppController", {$scope: $scope});
            } else if (baseType == 'DASH') {
                $controller("DashWebAppController", {$scope: $scope});
            } else if (baseType == 'SHINY') {
                $controller("ShinyWebAppController", {$scope: $scope});
            } else {
                Logger.error("Unknown app type: ", $scope.webAppType);
            }

            $scope.$watch('webAppId', function() {
                if ($scope.webAppId == null) {
                    return;
                }
                var app = {
                    projectKey: $stateParams.projectKey,
                    id: $scope.webAppId
                };
                $scope.getViewURL(app).then(function(url) {
                    $scope.iFrameUrl = url;
                });

                // ditch previous kept alive (even if it's the same webapp)
                if ($scope.cancelKeepAlive) {
                    Logger.info("[-] keepalive for " + app.projectKey + '.' + app.id + " in " + $scope.$id);
                    $interval.cancel($scope.cancelKeepAlive);
                }
                // keep the new one alive
                let KEEP_ALIVE_INTERVAL_MS = 10*1000;
                Logger.info("[+] keepalive for " + app.projectKey + '.' + app.id + " in " + $scope.$id);
                $scope.cancelKeepAlive = $interval(function () {
                    Logger.info("keep " + app.projectKey + '.' + app.id + " alive in " + $scope.$id)
                    Notification.publishToBackend('timeoutable-task-keepalive', {
                        taskId: 'webApp:' + app.projectKey + '.' + app.id
                    });
                }, KEEP_ALIVE_INTERVAL_MS);
            });

            $scope.$on('$destroy', function () {
                Logger.info("Stop keeping " + $stateParams.projectKey + '.' + $scope.webAppId + " alive in " + $scope.$id);
                if ($scope.cancelKeepAlive) {
                    $interval.cancel($scope.cancelKeepAlive);
                }
            });
        }
    };
});

})();
(function() {
'use strict';

const app = angular.module('dataiku.webapps');

app.controller("CustomWebAppEditController", function($scope, $stateParams, Assert, WT1, TopNav, WebAppsService, DataikuAPI, CreateModalFromTemplate) {
    TopNav.setLocation(TopNav.TOP_NOTEBOOKS, 'webapps', null, 'edit');
    Assert.inScope($scope, "app");

    WT1.event("custom-webapp-edit", {webappType: $scope.app.type});

    $scope.loadedDesc = WebAppsService.getWebAppLoadedDesc($scope.app.type);
    $scope.desc = $scope.loadedDesc.desc;

    if ($scope.app.apiKey) {
        let accessibleDatasets;
        function updateAccessibleDatasets() {
            DataikuAPI.webapps.getDatasetPrivileges($stateParams.projectKey, $scope.app.apiKey).success(function(data) {
                accessibleDatasets = data.datasets.filter(dp => {
                    return Object.values(dp).some(privilege => privilege === true); // dataset with any privilege
                }).map(dp => dp.datasetName);
                checkAccessibleDatasets();
            }).error(setErrorInScope.bind($scope));
        }
        function checkAccessibleDatasets() {
            if (!accessibleDatasets) {
                return;
            }
            const datasetParams = $scope.desc.params.filter(p => p.type == 'DATASET').map(p => p.name);
            let usedDatasets = datasetParams.map(p => $scope.app.config[p]);
            usedDatasets = usedDatasets.filter((d, i) => usedDatasets.indexOf(d) == i); //dedup
            $scope.unauthorisedUsedDatasets = usedDatasets.filter(d => d && !accessibleDatasets.includes(d));
        }
        updateAccessibleDatasets();

        if (!$scope.app.isVirtual) {
            DataikuAPI.security.listUsers().success(function(data) {
                $scope.allUsers = data;
            }).error(setErrorInScope.bind($scope));
        }

        $scope.$watch('app.config', checkAccessibleDatasets, true);

        $scope.showSettingsModal = function(){
            CreateModalFromTemplate("/templates/webapps/web-app-security-modal.html", $scope).then(updateAccessibleDatasets);
        };
    }
});

app.controller("WebAppEditController", function($scope, $rootScope, $stateParams, $state, $q, $timeout, $controller, Assert, CreateModalFromTemplate, ActivityIndicator, DataikuAPI, WT1, TopNav, FutureWatcher) {
    TopNav.setLocation(TopNav.TOP_NOTEBOOKS, 'webapps', null, 'edit');

    Assert.inScope($scope, "app");

    $scope.setupTypeSpecificWebAppBehaviour();

    DataikuAPI.security.listUsers().success(function(data) {
        $scope.allUsers = data;
    }).error(setErrorInScope.bind($scope));

    $scope.$on("paneSelected", function(evt, pane) {
        $scope.paneSlug = pane.slug;
    });

    $scope.showSettingsModal = function(){
        CreateModalFromTemplate("/templates/webapps/web-app-security-modal.html", $scope);
    };

    $scope.selectPanes = function(selectPanes) {
        if (selectPanes && selectPanes.length == 2) {
            $scope.editorPanes[0].state.activeTab = selectPanes[0];
            $scope.editorPanes[0].state.paneVisible = true;
            $scope.editorPanes[1].state.activeTab = selectPanes[1];
            $scope.editorPanes[1].state.paneVisible = true;
            $scope.editorPanes[1].state.rightmost = true;
            $scope.editorState = 'splitted';
        }
    };

    $scope.insertSnippet_ = function(snippet) {
        for (var i in snippet.variations) {
            var currentVariation = snippet.variations[i];
            if (typeof(currentVariation.code)!=='undefined') {
                switch (currentVariation.id) {
                    case 'js':
                        $scope.app.params.js += '\n\n\n' + currentVariation.code.replace("__INSIGHT_API_KEY__", $scope.app.apiKey);
                        break;
                    case 'html':
                        $scope.app.params.html += '\n\n\n' + currentVariation.code;
                        break;
                    case 'css':
                        $scope.app.params.css += '\n\n\n' + currentVariation.code;
                        break;
                    case 'py':
                        $scope.app.params.python += '\n' + currentVariation.code;
                        break;
                    case 'ui':
                        $scope.app.params.ui += '\n\n' + currentVariation.code;
                        break;
                    case 'server':
                        $scope.app.params.server += '\n\n' + currentVariation.code;
                        break;
                }
            }
        }
        if (snippet.libraries) {
            for (var lib in snippet.libraries) {
                $scope.libraries[snippet.libraries[lib]] = true;
            }
        }
        $scope.selectPanes(snippet.selectPanes);
    }

    $scope.insertPythonSnippet_ = function(snippetVariation) {
        if (typeof(snippetVariation.code) !== 'undefined') {
            $scope.app.params.python += '\n' + snippetVariation.code;
        }
    }

    /* ********************* Main handling ******************** */


    $scope.disablePythonBackend = function() {
        $scope.app.pyBackendEnabled = false;
        $scope.app.pyBackendMustRun =  false;
        $scope.saveWebApp(true, true);
    };
    $scope.enablePythonBackend = function() {
        $scope.app.params.backendEnabled = true;

        // Adding some example in case no python file specified in template (or empty)
        if (!$scope.app.params.python) {
            $scope.app.params.python =  "# Example:\n";
            $scope.app.params.python += "# From JavaScript, you can access the defined endpoints using\n";
            $scope.app.params.python += "# getWebAppBackendUrl('first_api_call')\n\n";
            $scope.app.params.python += "@app.route('/first_api_call')\ndef first_call():\n";
            $scope.app.params.python += "    return json.dumps({\"status\" : \"ok\", \"data\" : [1,2,3]})\n";
        }
        // and the snippet in the js
        if ($scope.app.params.python.includes('first_api_call') && !$scope.app.params.js.includes('first_api_call')) {
        	$scope.app.params.js += "$.getJSON(getWebAppBackendUrl('/first_api_call'), function(data) {\n";
        	$scope.app.params.js += "    console.log('Received data from backend', data)\n";
        	$scope.app.params.js += "    const output = $('<pre />').text('Backend reply: ' + JSON.stringify(data));\n";
        	$scope.app.params.js += "    $('body').append(output)\n";
        	$scope.app.params.js += "});\n";
        }

        $scope.saveWebAppWithCode();
    };

    $scope.refreshBackendLog = function() {
        DataikuAPI.webapps.getBackendState($scope.app)
        .success(function(result) {
            $scope.setBackendLogs(result);
            $timeout(scrollDownLogs);
        }).error(setErrorInScope.bind($scope));
    };

    function scrollDownLogs() {
        var smartLogTailContent = $('.smart-log-tail-content');
        if (smartLogTailContent.length > 0) {
            smartLogTailContent.scrollTop(smartLogTailContent[0].scrollHeight);
        }
    }

    function focusPreviewOrLogsTab() {
        if (!$scope.editorPanes) return; // not ready for tab switching yet
        if ($scope.errorsInLogs) {
            $scope.editorPanes[1].state.activeTab = 'BACKEND_LOG';
            $timeout(scrollDownLogs);
        } else {
            $scope.editorPanes[1].state.activeTab = 'OUTPUT';
        }
    }
    $scope.$on("previewDataUpdated", focusPreviewOrLogsTab);


    $scope.restartBackend = function(app) {
        $scope.saveWebAppWithCode(null, true);
        $rootScope.$broadcast('backendRestarted');
    };

    $scope.hooks.save = $scope.saveWebAppWithCode;

    var currentCommitMessage;
    $scope.saveWithCustomCommitMessage = function(){
        var deferred = $q.defer();

        CreateModalFromTemplate("/templates/git/commit-message-only-modal.html", $scope, null, function(newScope) {
            newScope.commitData = {};
            /* Reload previous message if any */
            if (currentCommitMessage) {
                newScope.commitData.message = currentCommitMessage;
            }

            newScope.commit = function(){
                deferred.resolve(newScope.commitData);
                newScope.dismiss();
            }
        });

        deferred.promise.then(function(commitData){
            currentCommitMessage = commitData.message;
            $scope.save();
        });
    };

    $scope.commit = function(){
        CreateModalFromTemplate("/templates/git/commit-object-modal.html", $scope, null, function(newScope) {
            newScope.object = {
                objectType : "INSIGHT",
                objectId : $scope.insight.id
            }
        });
    };

    $scope.safeMode = !!$scope.$eval($stateParams['safe-mode']);

    $scope.disableSafeMode = () => {
        $scope.safeMode = false;
        $scope.startUpdatePreview();
    };

    checkChangesBeforeLeaving($scope, $scope.isDirty);

    $scope.startUpdatePreview();

    const backendRestartListener = $rootScope.$on('backendRestarted',function () {$scope.sharedState.backendRunning = true;});
    const backendStopListener = $rootScope.$on('backendStopped',function () {$scope.sharedState.backendRunning = false;});

    $scope.$on("$destroy", function() {
        backendRestartListener();
        backendStopListener();
    });
});


app.controller("WebAppEditSettingsModalController", function($scope, $stateParams, DataikuAPI, Fn) {
    $scope.webAppApiKey = {key:$scope.app.apiKey};
    $scope.modalTabState = {
        active : 'security',
        editingApiKey: 'show'
    };

    function getPrivileges() {
        DataikuAPI.webapps.getDatasetPrivileges($stateParams.projectKey, $scope.webAppApiKey.key).success(function(data){
            $scope.privileges = data;
        }).error(setErrorInScope.bind($scope));
    }

    function init() {
        DataikuAPI.projects.publicApi.listProjectApiKeys($stateParams.projectKey).success(function(response){
            response.forEach(function(o){o.type="project"});
            $scope.availableApiKeys = response;
            DataikuAPI.profile.listPersonalAPIKeys().success(function(response){
                response.forEach(function(o){o.type="personal"});
                $scope.availableApiKeys = $scope.availableApiKeys.concat(response);

                $scope.$watch('webAppApiKey.key',function(nv,ov){
                    if (nv==undefined) {return}
                    $scope.validApiKey = ($scope.availableApiKeys.map(Fn.prop('key')).indexOf(nv)!=-1);
                    $scope.isProjectApiKey = ($scope.validApiKey && $scope.availableApiKeys.filter(function(o){return o.key===nv})[0].type === 'project')
                    if ($scope.isProjectApiKey) {getPrivileges();}
                    if ($scope.modalTabState.editingApiKey == 'list') {
                        $scope.modalTabState.editingApiKey = 'show';
                    }
                });
            }).error(setErrorInScope.bind($scope));
        }).error(setErrorInScope.bind($scope));
    }
    init();

    $scope.save = function() {
        if ($scope.validApiKey) {
            $scope.app.apiKey = $scope.webAppApiKey.key;
        }
        $scope.saveWebAppWithCode();
        if ($scope.isProjectApiKey) {
            $scope._savePrivileges().then($scope.resolveModal);
        } else {
            $scope.resolveModal();
        }
    };

    $scope._savePrivileges = function() {
        return DataikuAPI.webapps.setDatasetPrivileges($stateParams.projectKey, $scope.webAppApiKey.key, $scope.privileges)
            .success(function(data){})
            .error(setErrorInScope.bind($scope));
    };

    $scope.addDatasetSnippet = function(datasetName) {
        let found = false;
        $scope.privileges.datasets.forEach(function(fdataset){
            if (fdataset.datasetName == datasetName) {
                fdataset.readData = true;
                fdataset.readMetadata = true;
                fdataset.readSchema = true;
            }
        });
        $scope.app.params.js += "\n\ndataiku.fetch('" + datasetName  + "', {\n";
        $scope.app.params.js += "        sampling: \"head\",\n";
        $scope.app.params.js += "        limit: 10000\n";
        $scope.app.params.js += "    }, function(dataFrame) {\n"
        $scope.app.params.js += "    /* Process the dataframe */\n})";

        $scope._savePrivileges();
        $scope.resolveModal();
    }
    $scope.$watch('modalTabState.editingApiKey', function(nv,ov){
        if (nv === 'write') {$scope.editedApiKey = angular.copy($scope.webAppApiKey);}
        if (ov === 'write') {$scope.webAppApiKey = $scope.editedApiKey;}
    });
});


app.directive("webAppEditorPane", function () {
    return {
        scope: true,
        templateUrl: '/templates/webapps/web-app-editor-pane.html',
        link: function ($scope, element, attrs) {
            $scope.outputTabEnabled = attrs.outputTabEnabled == "true" ? true : false;
            $scope.state = {};
            $scope.editorPanes.push($scope);
            $scope.maximize = function () {
                $scope.parentMaximize($scope);
            };

            $scope.$on("previewDataUpdated", function(evt, pane) {
                var iframe = $('.htmlResult', element);
                $scope.renderPreview(iframe);
            });

            $scope.uiState = { codeSamplesSelectorVisible: false };
        }
    }
});


app.directive("webAppEditor", function($rootScope, CodeMirrorSettingService) {
    return {
        scope: false,
        link: function($scope, element, attrs) {
            $scope.editorPanes = [];
            $scope.editorState = 'splitted';
            $scope.leftWidth = 0;

            $scope.$watch("editorPanes.length", function(nv, ov) {
                if ($scope.editorPanes.length == 2) {
                    $scope.editorPanes[0].state.paneVisible = true;
                    $scope.editorPanes[1].state.paneVisible = true;
                    $scope.editorPanes[1].state.activeTab = 'OUTPUT';
                    $scope.editorPanes[1].state.rightmost = true;
                    $scope.editorState = 'splitted';

                    $scope.editorPanes[0].state.activeTab = $scope.defaultLeftTab;
                }
            });

            $scope.createEditorOptions = function(mode){
                var options = CodeMirrorSettingService.get(mode);
                return options;
            };

            $scope.splitEditor = function() {
                var leftPane = element.find(".left-pane");
                var rightPane = element.find(".right-pane");
                $scope.editorPanes[0].state.paneVisible = true;
                $scope.editorPanes[1].state.paneVisible = true;
                $scope.editorState = 'splitted';
                leftPane.css({width: $scope.leftWidth + "px"});
                rightPane.css({left: $scope.leftWidth + 3, right: "0", width: "auto"});
            };

            $scope.parentMaximize = function(pane) {
                var leftPane = element.find(".left-pane");
                var rightPane = element.find(".right-pane");
                $scope.leftWidth = leftPane.width();
                $scope.rightWidth = rightPane.width();

                $scope.editorState = 'maximized';

                if ($scope.editorPanes[0] == pane) {
                    leftPane.css({width: '100%'});
                    rightPane.css({width: '0'});
                    $scope.editorPanes[0].state.paneVisible = true;
                    $scope.editorPanes[1].state.paneVisible = false;
                } else if ($scope.editorPanes[1] == pane) {
                    leftPane.css({width: '0'});
                    rightPane.css({width: '100%', left: '0'});
                    $scope.editorPanes[0].state.paneVisible = false;
                    $scope.editorPanes[1].state.paneVisible = true;
                }
            }
        }
    }
});

})();

(function() {
'use strict';

const app = angular.module('dataiku.webapps');


    app.controller("StandardWebAppController", function($scope, $controller, $sce, Assert, ActivityIndicator, $q, DataikuAPI, $rootScope) {
        $controller("_PreviewWebAppController", {$scope:$scope});

        $scope.defaultLeftTab = 'JS';

        $scope.backendEnabled = function () {
            return $scope.app && $scope.app.params.backendEnabled;
        };

        $scope.showFrontendTabs = function(webapp) {
            return true;
        };

        $scope.getViewURL = function(app) {
            const deferred = $q.defer();
            app = app || $scope.app;
            const suffix = "/dip/api/webapps/view?" + $.param({
                projectKey: app.projectKey,
                webAppId: app.id,
                apiKey: app.apiKey
            });
            let url;
            if ($rootScope.appConfig.webappsIsolationMode == "ALTERNATIVE_ORIGIN") {
                url = $rootScope.appConfig.webappsIsolationOrigin + suffix;
            } else {
                url = suffix;
            }
            deferred.resolve($sce.trustAsResourceUrl(url));
            return deferred.promise;
        };

        // JS libraries:
        // Params use a list of string
        // UI uses map string -> bool
        function prepareLibrariesForUI() {
            if (!$scope.app) return;
            $scope.libraries = {};
            if($scope.app.params.libraries) {
                for (var i = 0; i < $scope.app.params.libraries.length; i++) {
                    var library = $scope.app.params.libraries[i];
                    $scope.libraries[library] = true;
                }
            }
        }

        function fixupLibraries() {
            if ($scope.libraries && $scope.app) {
                $scope.app.params.libraries = [];
                for (var k in $scope.libraries) {
                    if ($scope.libraries[k]) {
                        $scope.app.params.libraries.push(k);
                    }
                }
            }
        }
        $scope.$watch("libraries", fixupLibraries, true);

        prepareLibrariesForUI();
    });
})();
(function() {
    'use strict';
    var app = angular.module('dataiku.webapps');

    app.controller("BokehWebAppController", function($scope, $controller, $rootScope, $q, DataikuAPI) {
        $controller("_BokehDashOrShinyLikeWebAppController", {$scope: $scope});
        $scope.defaultLeftTab = 'PYTHON';

        $scope.getViewURL = function(app) {
            const deferred = $q.defer();
            app = app || $scope.app;
               DataikuAPI.webapps.getBackendUrl(app.projectKey, app.id, app.apiKey).success(function(data) {
                   const suffix = data.location ? data.location + 'backend' : 'webapp-error-not-running.html';
                   if ($rootScope.appConfig.webappsIsolationMode === "ALTERNATIVE_ORIGIN") {
                       deferred.resolve($rootScope.appConfig.webappsIsolationOrigin + suffix);
                   } else {
                       deferred.resolve(suffix);
                   }
               }).error(setErrorInScope.bind($scope));
            return deferred.promise;
        };
    });
})();
(function() {
    'use strict';
    var app = angular.module('dataiku.webapps');

    app.controller("DashWebAppController", function($scope, $controller, $rootScope, $q, DataikuAPI) {
        $controller("_BokehDashOrShinyLikeWebAppController", {$scope: $scope});
        $scope.defaultLeftTab = 'PYTHON';

        $scope.getViewURL = function(app) {
            const deferred = $q.defer();
            app = app || $scope.app;
               DataikuAPI.webapps.getBackendUrl(app.projectKey, app.id, app.apiKey).success(function(data) {
                   const suffix = data.location ? data.location : 'webapp-error-not-running.html';
                   if ($rootScope.appConfig.webappsIsolationMode === "ALTERNATIVE_ORIGIN") {
                       deferred.resolve($rootScope.appConfig.webappsIsolationOrigin + suffix);
                   } else {
                       deferred.resolve(suffix);
                   }
               }).error(setErrorInScope.bind($scope));
            return deferred.promise;
        };
    });
})();
(function() {
    'use strict';
    var app = angular.module('dataiku.webapps');

    app.controller("ShinyWebAppController", function($scope, $controller, $rootScope, $q, DataikuAPI) {
        $controller("_BokehDashOrShinyLikeWebAppController", {$scope: $scope});
        $scope.defaultLeftTab = 'SHINY_UI';

        $scope.getViewURL = function(app) {
            const deferred = $q.defer();
            app = app || $scope.app;
            DataikuAPI.webapps.getBackendUrl(app.projectKey, app.id, app.apiKey).success(function(data) {
               const suffix = data.location ? data.location : 'webapp-error-not-running.html';
               if ($rootScope.appConfig.webappsIsolationMode === "ALTERNATIVE_ORIGIN") {
                   deferred.resolve($rootScope.appConfig.webappsIsolationOrigin + suffix);
               } else {
                   deferred.resolve(suffix);
               }
            }).error(setErrorInScope.bind($scope));
            return deferred.promise;
        };
    });
})();
(function(){
'use strict';


var app = angular.module('dataiku.report', []);

var reportsDownloader = $('<iframe>').attr('id', 'reports-downloader');

app.constant("RMARKDOWN_ALL_OUTPUT_FORMATS", [
    {name: 'HTML_NOTEBOOK', desc: 'HTML'},
    {name: 'PDF_DOCUMENT', desc: 'PDF'},

    {name: 'HTML_DOCUMENT', desc: 'HTML fixed layout'},
    {name: 'WORD_DOCUMENT', desc: 'Microsoft Word (docx)'},
    {name: 'ODT_DOCUMENT', desc: 'OpenDocument Text (odt)'},
    {name: 'RTF_DOCUMENT', desc: 'Rich Text Format (rtf)'},
    // {name: 'MD_DOCUMENT', desc: 'Markdown'},

    {name: 'IOSLIDES_PRESENTATION', desc: 'HTML presentation with ioslides'},
    {name: 'REVEALJS_PRESENTATION', desc: 'HTML presentation with reveal.js'},
    {name: 'SLIDY_PRESENTATION', desc: 'HTML W3C Slidy presentation'},
    {name: 'BEAMER_PRESENTATION', desc: 'PDF Beamer presentation'},

    {name: 'FLEX_DASHBOARD', desc: 'Flex dashboard'},
    {name: 'TUFTE_HANDOUT', desc: 'PDF Tufte style handout'},
    {name: 'TUFTE_HTML', desc: 'HTML Tufte style handout'},
    {name: 'TUFTE_BOOK', desc: 'PDF Tufte style book'},
    {name: 'HTML_VIGNETTE', desc: 'HTML vignette style'},
    // {name: 'GITHUB_DOCUMENT', desc: 'GitHub Flavored Markdown document'}
]);

app.constant("RMARKDOWN_PREVIEW_OUTPUT_FORMATS", [
    {name: 'HTML_NOTEBOOK', desc: 'HTML'},
    {name: 'PDF_DOCUMENT', desc: 'PDF'},

    {name: 'HTML_DOCUMENT', desc: 'HTML fixed layout'},
    // {name: 'IOSLIDES_PRESENTATION', desc: 'HTML presentation with ioslides'}, //seems buggy
    {name: 'REVEALJS_PRESENTATION', desc: 'HTML presentation with reveal.js'},
    {name: 'SLIDY_PRESENTATION', desc: 'HTML W3C Slidy presentation'},
    {name: 'BEAMER_PRESENTATION', desc: 'PDF Beamer presentation'},

    // {name: 'FLEX_DASHBOARD', desc: 'Flex dashboard'}, //seems buggy
    // {name: 'TUFTE_HANDOUT', desc: 'PDF Tufte style handout'},
    // {name: 'TUFTE_HTML', desc: 'HTML Tufte style handout'},
    // {name: 'TUFTE_BOOK', desc: 'PDF Tufte style book'},
    {name: 'HTML_VIGNETTE', desc: 'HTML vignette style'},
]);

app.controller("ReportsCommonController", function($scope, $rootScope, $state, $stateParams, $q, $controller, $sce, $window,
               TopNav, LoggerProvider, WT1, DataikuAPI, FutureWatcher, CreateModalFromTemplate, FutureProgressModal, ActivityIndicator, TAIL_STATUS) {

    $scope.hooks = $scope.hooks || {};

    $scope.copy = function(report, callBackFunc) {
        function showModal() {
            var newScope = $scope.$new();
            newScope.report = report;
            CreateModalFromTemplate("/templates/code-reports/copy-report-modal.html", newScope)
            .then(function() {
                if (typeof(callBackFunc) === 'function') callBackFunc();
            });
        }
        if ($scope.hooks.save) {
            $scope.saveReport().then(showModal, setErrorInScope.bind($scope));
        } else {
            showModal();
        }
    };

    $scope.publish = function(report) {
        WT1.event("report-publish", {reportId: $stateParams.id});

        DataikuAPI.reports.snapshots.create($scope.report.projectKey, $scope.report.id).success(function(data) {
            FutureProgressModal.show($scope, data, "Building report for publication...").then(function(result) {
                const insight = {
                    projectKey: $stateParams.projectKey,
                    type: 'report',
                    name: report.name,
                    params: {
                        reportSmartId: report.id,
                        loadLast: true,
                        viewFormat: $scope.report.params.viewFormat
                    }
                };

                CreateModalFromTemplate("/templates/dashboards/insights/create-and-pin-insight-modal.html", $scope, "CreateAndPinInsightModalController", function(newScope) {
                    newScope.init(insight);
                });
            });
        })
        .error(setErrorInScope.bind($scope));
    };

    $scope.createSnapshot = function() {
        DataikuAPI.reports.snapshots.create($scope.report.projectKey, $scope.report.id).success(function(data) {
            FutureProgressModal.show($scope, data, "Building report for snapshot...").then(function(result) {
                ActivityIndicator.success('Snapshot done', 3000);
            });
        })
        .error(setErrorInScope.bind($scope));
    };

    $scope.saveReportMetadata = function() {
        return DataikuAPI.reports.saveMetadata($scope.report)
        .success(function(resp) {
            ActivityIndicator.success("Saved!");
        })
        .error(setErrorInScope.bind($scope));
    };

    $scope.saveCustomFields = function(newCustomFields) {
        WT1.event('custom-fields-save', {objectType: 'REPORT'});
        let oldCustomFields = angular.copy($scope.report.customFields);
        $scope.report.customFields = newCustomFields;
        return $scope.saveReportMetadata().then(function() {
                $rootScope.$broadcast('customFieldsSaved', TopNav.getItem(), $scope.report.customFields);
            }, function() {
                $scope.report.customFields = oldCustomFields;
            });
    };

    $scope.editCustomFields = function() {
        if (!$scope.report) {
            return;
        }
        let modalScope = angular.extend($scope, {objectType: 'REPORT', objectName: $scope.report.name, objectCustomFields: $scope.report.customFields});
        CreateModalFromTemplate("/templates/taggable-objects/custom-fields-edit-modal.html", modalScope).then(function(customFields) {
            $scope.saveCustomFields(customFields);
        });
    };

    $scope.getViewURL = function(report) {
        report = report || $scope.report;
        var url = "/dip/api/reports/view?" + $.param({
            projectKey: report.projectKey,
            id: report.id,
            inEditMode : $state.current.name.endsWith(".edit")
        });
        return $sce.trustAsResourceUrl(url);
    };

    $scope.download = function(report, format) {
        report = report || $scope.report;
        var newScope = $scope.$new();
        newScope.report = report;
        CreateModalFromTemplate("/templates/code-reports/download-report-modal.html", newScope, "DownloadReportModalController", function(modalScope) {
            modalScope.handleDownload = function(initialResponse, options, reportsDownloader) {
                WT1.event("report-download", {format: options.format});
                modalScope.dismiss(); // dismiss modal 1
                FutureProgressModal.show($scope, initialResponse, "Preparing download").then(function(result) {
                     var url = "/dip/api/reports/download?" + $.param({
                        projectKey: report.projectKey,
                        id: report.id,
                        format: options.format
                    });

                    reportsDownloader.attr('src', url);
                    $('body').append(reportsDownloader);
                });
            };
        });
    };
});


app.controller("ReportsListController", function($scope, $controller, $stateParams, DataikuAPI, CreateModalFromTemplate, Dialogs,$state,$q, TopNav, Fn, $filter) {
    $controller('_TaggableObjectsListPageCommon', {$scope: $scope});
    $controller("ReportsCommonController", {$scope: $scope});

    $scope.listHeads = DataikuAPI.reports.listHeads;

    $scope.sortBy = [
        { value: 'name', label: 'Name' },
        { value: '-lastModifiedOn', label: 'Last modified' }
    ];

    $scope.selection = $.extend({
        filterQuery: {
            userQuery: '',
            tags: [],
            interest: {
                starred: '',
            },
        },
        filterParams: {
            userQueryTargets: ["name","tags"],
            propertyRules: {tag: "tags"},
        },
        orderQuery: "-lastModifiedOn",
        orderReversed: false,
    }, $scope.selection || {});

    $scope.sortCookieKey = 'reports';
    $scope.maxItems = 20;

    TopNav.setLocation(TopNav.TOP_NOTEBOOKS, 'reports', TopNav.TABS_NONE, null);
    TopNav.setNoItem();
    $scope.list() ;

    /* Specific actions */
    $scope.goToItem = function(data) {
        $state.go("projects.project.analyses.analysis.script", {projectKey : $stateParams.projectKey, analysisId : data.id});
    }

    $scope.createReport = function() {
        // For the time being only one available type of report
        var reportType = "RMARKDOWN";

        $scope.report = {
            type: reportType,
            name: reportType.toLowerCase() + ' report'
        };

        DataikuAPI.reports.listTemplates(reportType).success(function(data) {
            $scope.availableTemplates = data.templates;
            $scope.report.template = $scope.availableTemplates[0];
        }).error(setErrorInScope.bind($scope));

        CreateModalFromTemplate("/templates/code-reports/new-report-modal.html", $scope);
    };
});

app.controller("ReportPageRightColumnActions", async function($controller, $scope, $rootScope, $stateParams,GlobalProjectActions, ActiveProjectKey, DataikuAPI) {

    $controller('_TaggableObjectPageRightColumnActions', {$scope: $scope});

    $scope.reportFullInfo = (await DataikuAPI.reports.getFullInfo(ActiveProjectKey.get(), $stateParams.reportId)).data;
    $scope.report = $scope.reportFullInfo.report;
    $scope.report.interest = $scope.reportFullInfo.interest;
    $scope.report.nodeType = 'REPORT';

    $scope.selection = {
        selectedObject : $scope.report,
        confirmedItem : $scope.report
    };

    $scope.updateUserInterests = function() {
        DataikuAPI.interests.getForObject($rootScope.appConfig.login, "REPORT", ActiveProjectKey.get(), $scope.data.object.id)
            .success(function(data){
                $scope.selection.selectedObject.interest = data;
            })
            .error(setErrorInScope.bind($scope));
    }

    const interestsListener = $rootScope.$on('userInterestsUpdated', $scope.updateUserInterests);

    $scope.$on("$destroy", interestsListener);
});

app.directive('reportRightColumnSummary', function(DataikuAPI, $stateParams, $rootScope, GlobalProjectActions, QuickView, $controller, ActivityIndicator){
    return {
        templateUrl :'/templates/code-reports/right-column-summary.html',
        link : function($scope, element, attrs) {
            $controller("ReportsCommonController", {$scope: $scope});
            $controller('_TaggableObjectsMassActions', {$scope: $scope});
            $controller('_TaggableObjectsCapabilities', {$scope: $scope});

            $scope.QuickView = QuickView;

            /* Auto save when summary is modified */
            $scope.$on("objectSummaryEdited", function(){
                return DataikuAPI.reports.saveMetadata($scope.report).success(function(data) {
                    ActivityIndicator.success("Saved");
                }).error(setErrorInScope.bind($scope));
            });

            $scope.refreshData = function() {
                $scope.reportFullInfo = { report: $scope.selection.selectedObject }; // temporary incomplete data
                DataikuAPI.reports.getFullInfo($scope.selection.selectedObject.projectKey, $scope.selection.selectedObject.id).success(function(data) {
                    if (!$scope.selection.selectedObject
                        || $scope.selection.selectedObject.id != data.report.id
                        || $scope.selection.selectedObject.projectKey != data.report.projectKey) {
                        return; //too late!
                    }
                    $scope.reportFullInfo = data;
                    $scope.report = data.report;
                }).error(setErrorInScope.bind($scope));
            };

            $scope.$watch("selection.confirmedItem", function(nv, ov) {
                if (!nv) return;
                $scope.refreshData();
            });
        }
    }
});


app.controller("ReportSummaryController", function($scope, $rootScope, $stateParams, DataikuAPI, TopNav) {
    TopNav.setLocation(TopNav.TOP_NOTEBOOKS, 'reports', null, 'summary');

    $scope.$on("objectSummaryEdited", $scope.saveReportMetadata);

    $scope.$on('customFieldsSummaryEdited', function(event, customFields) {
        $scope.saveCustomFields(customFields);
    });
});


app.controller("ReportCoreController", function($scope, $controller, $state, $stateParams, $filter, $q,
               DataikuAPI, CreateModalFromTemplate, Dialogs, TopNav, Fn, WT1, ActivityIndicator,
               RMARKDOWN_PREVIEW_OUTPUT_FORMATS, RMARKDOWN_ALL_OUTPUT_FORMATS) {

    $controller("ReportsCommonController", {$scope: $scope});

    function getSummary() {
        return DataikuAPI.reports.getSummary($stateParams.projectKey, $stateParams.reportId).success(function(data) {
            $scope.report = data.object;
            $scope.hooks.script = data.script;
            $scope.timeline = data.timeline;
            $scope.interest = data.interest;
            $scope.backendState = data.backendState;
            $scope.backendRunning = !!(data.backendState && data.backendState.futureId && data.backendState.futureInfo && data.backendState.futureInfo.alive);
            $scope.hooks.origReport = angular.copy($scope.report);
            $scope.hooks.origScript = $scope.hooks.script;

            TopNav.setItem(TopNav.ITEM_REPORT, $stateParams.reportId, $scope.report);
            TopNav.setPageTitle($scope.report.name + " - Report");

            $scope.$watch("report.name", function(nv) {
                if (!nv) return;
                $state.go($state.current, {reportName: $filter('slugify')(nv)}, {location: true, inherit:true, notify:false, reload:false});
            });

        }).error(setErrorInScope.bind($scope));
    }

    getSummary().then(function() {
        TopNav.setItem(TopNav.ITEM_REPORT, $stateParams.reportId, $scope.report);
        TopNav.setPageTitle($scope.report.name + " - Report");

        $scope.$watch("report.name", function(nv) {
            if (!nv) return;
            $state.go($state.current, {reportName: $filter('slugify')(nv)}, {location: true, inherit:true, notify:false, reload:false});
        });
    });

    $scope.isDirty = function() {
        return !angular.equals($scope.report, $scope.hooks.origReport) || !angular.equals($scope.hooks.script, $scope.hooks.origScript);
    };

    $scope.saveReport = function(commitMessage) {
        return $scope.hooks.save(commitMessage);
    };

    $scope.saveReportMetadata = function() {
        WT1.event("report-save-metadata", {reportId: $stateParams.id, type: $scope.report.type});

        return DataikuAPI.reports.saveMetadata($scope.report)
            .error(setErrorInScope.bind($scope))
            .success(function(resp) {
                ActivityIndicator.success("Saved!");
                $scope.hooks.origReport = angular.copy($scope.report);
                $scope.hooks.origScript = $scope.hooks.script;
            });
    };

    // Formats available for in browser view
    $scope.viewFormats = RMARKDOWN_PREVIEW_OUTPUT_FORMATS;
    $scope.snapshotFormats = RMARKDOWN_ALL_OUTPUT_FORMATS;
});


app.controller("ReportViewController", function($scope, TopNav) {
    TopNav.setLocation(TopNav.TOP_NOTEBOOKS, 'reports', null, 'view');
});


app.controller("NewReportModalController", function($scope, $state, $stateParams, WT1, DataikuAPI) {
    $scope.create = function() {
        WT1.event("report-create", {});
        DataikuAPI.reports.create($stateParams.projectKey, $scope.report.name, $scope.report.template)
        .success(function(report) {
            $scope.resolveModal(report);
            $state.go("projects.project.reports.report.edit", {projectKey: $stateParams.projectKey, reportId: report.id});
        })
        .error(setErrorInScope.bind($scope));
    };
});


app.controller("CopyReportModalController", function($scope, $state, DataikuAPI, ActivityIndicator, StateUtils, WT1) {

    $scope.newReport = {
        name: "Copy of "+$scope.report.name
    };

    $scope.copyReport = function() {
        WT1.event("report-copy", {type: $scope.report.type});
        return DataikuAPI.reports.copy($scope.report.projectKey, $scope.report.id, $scope.newReport.name)
        .success(function(createdReport) {
            $scope.resolveModal(createdReport);
            var href = $state.href("projects.project.reports.report.edit", {projectKey: createdReport.projectKey, reportId: createdReport.id});

            ActivityIndicator.success(
                '<strong>'+$scope.report.name + '</strong> copied into <strong>' + createdReport.name + '</strong>, ' +
                '<a href="'+href+'">edit it now</a>.'
                , 5000);

            if ($scope.list) {
                $scope.list();
                $scope.selection.selectedObject = null;
            }
        })
        .error(setErrorInScope.bind($scope))
    };
});


app.controller("DownloadReportModalController", function($scope, $controller, DataikuAPI, CreateModalFromTemplate, FutureWatcher, ProgressStackMessageBuilder, RMARKDOWN_ALL_OUTPUT_FORMATS) {
    $scope.formats = RMARKDOWN_ALL_OUTPUT_FORMATS;

    $scope.options = {
        format: 'PDF_DOCUMENT'
    };

    $scope.downloadReport = function() {
        DataikuAPI.reports.prepareDownload($scope.report.projectKey, $scope.report.id, $scope.options.format)
        .success(function(initialResponse) {
            $scope.handleDownload(initialResponse, $scope.options, reportsDownloader);
        }).error(setErrorInScope.bind($scope));
    };
});


app.controller("ReportHistoryController", function($scope, TopNav) {
    TopNav.setLocation(TopNav.TOP_NOTEBOOKS, "report", null, "history");
});

})();
(function(){
'use strict';


var app = angular.module('dataiku.report');


app.controller("ReportEditController", function($scope, WT1, TopNav, DataikuAPI, TAIL_STATUS, FutureProgressModal) {
    TopNav.setLocation(TopNav.TOP_NOTEBOOKS, 'report', null, 'edit');

    $scope.state = $scope.state || {};
    $scope.state.activeTab = 'OUTPUT';
    
    DataikuAPI.security.listUsers().success(function(data) {
        $scope.allUsers = data;
    }).error(setErrorInScope.bind($scope));

    $scope.hooks.saveAndBuild = function(commitMessage) {
        if ($scope.isDirty()) {
            $scope.hooks.save(commitMessage, true);
        } else {
            $scope.hooks.build();
        }
    };

    $scope.hooks.save = function(commitMessage, forceBuild) {
        WT1.event("report-save", {reportId : $scope.report.id});

        return DataikuAPI.reports.save($scope.report, $scope.hooks.script, commitMessage).then(function(result) {
            $scope.hooks.origReport = angular.copy($scope.report);
            $scope.hooks.origScript = angular.copy($scope.hooks.script);
            if ($scope.report.params.buildOnSave || forceBuild) {
                $scope.hooks.build();
            }
        }, setErrorInScope.bind($scope));
    };

    $scope.hooks.build = function() {
        WT1.event("report-build", {reportId : $scope.report.id});

        return DataikuAPI.reports.build($scope.report.projectKey, $scope.report.id).success(function(data) {
            FutureProgressModal.show($scope, data, "Still building report...").then(function(result) {
                $scope.logTail = result.futureLog;
                $scope.state.activeTab = 'OUTPUT';
                updatePreview();
            });
        }).error(function(result, status, headers){
            setErrorInScope.bind($scope)(result, status, headers);
            $scope.logTail = result.logTail || result.futureLog.logTail;

            $scope.errorsInLogs = $scope.logTail && $scope.logTail.maxLevel == TAIL_STATUS.ERROR;

            if ($scope.errorsInLogs) {
                $scope.state.activeTab = 'LOG';
            } else {
                $scope.state.activeTab = 'OUTPUT';
            }

            updatePreview();
        });
    };

    $scope.insertCodeSnippet = function(snippet) {
        var cm = $('.web-app-editor > .left-pane > div > div:not(.code-snippet-editor-wrapper) > .CodeMirror').get(0).CodeMirror;
        cm.replaceSelection(snippet.code);
        var endPos = cm.getCursor(false);
        cm.setCursor(endPos);
        cm.focus();
    };

    function updatePreview() {
        var iframe = $('#report-container');
        iframe.attr('src', $scope.getViewURL());
    }

    $scope.uiState = { codeSamplesSelectorVisible: false };
    
    var initDeregister = $scope.$watch("report", function(nv) {
        if ($scope.report == null) return;
        $scope.report.params.envSelection = $scope.report.params.envSelection || {envMode:'INHERIT'};
        initDeregister();
    });

});


})();
(function() {
'use strict';

const app = angular.module('dataiku.services');


app.factory("RMarkdownMode", function($window, Logger) {

CodeMirror.defineMode("rmarkdown", function(cmCfg, modeCfg) {
    var htmlFound = CodeMirror.modes.hasOwnProperty("xml");
    var htmlMode = CodeMirror.getMode(cmCfg, htmlFound ? {name: "xml", htmlMode: true} : "text/plain");

    var BLOCK_START = /^```\s*\{(r|python|sql|js|css|bash|rcpp|stan)((\s.*)|(,.+))*}\s*$/i
    var INLINE_CODE_START = /^`(r)\s/i
    var YAML_HEADER_TAG = /^---\s*$/
    var aliases = {
        r: "text/x-rsrc",
        python: "text/x-python",
        sql: "text/x-sql",
        js: "text/javascript",
        css: "text/css",
        rcpp: "text/x-c++src",
        //bash: "text/x-bash",
        //stan: "text/x-stan"
    };

    var getMode = (function () {
        var i, modes = {}, mimes = {}, mime;

        var list = [];
        for (var m1 in CodeMirror.modes) {
            if (CodeMirror.modes.propertyIsEnumerable(m1)) {
                list.push(m1);
            }
        }
        for (i = 0; i < list.length; i++) {
            modes[list[i]] = list[i];
        }
        var mimesList = [];
        for (var m2 in CodeMirror.mimeModes) {
            if (CodeMirror.mimeModes.propertyIsEnumerable(m2)) {
                mimesList.push({mime: m2, mode: CodeMirror.mimeModes[m2]});
            }
        }
        for (i = 0; i < mimesList.length; i++) {
            mime = mimesList[i].mime;
            mimes[mime] = mimesList[i].mime;
        }

        for (var a in aliases) {
            if (aliases[a] in modes || aliases[a] in mimes) {
                modes[a] = aliases[a];
            }
        }

        return function (lang) {
            if(!lang) return null;
            return modes[lang.toLowerCase()] ? CodeMirror.getMode(cmCfg, modes[lang.toLowerCase()]) : null;
        };
    }());

    // Should characters that affect highlighting be highlighted separate?
    // Does not include characters that will be output (such as `1.` and `-` for lists)
    if (modeCfg.highlightFormatting === undefined)
        modeCfg.highlightFormatting = false;

    // Maximum number of nested blockquotes. Set to 0 for infinite nesting.
    // Excess `>` will emit `error` token.
    if (modeCfg.maxBlockquoteDepth === undefined)
        modeCfg.maxBlockquoteDepth = 0;

    // Should underscores in words open/close em/strong?
    if (modeCfg.underscoresBreakWords === undefined)
        modeCfg.underscoresBreakWords = true;

    // Turn on task lists? ("- [ ] " and "- [x] ")
    if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;

    var codeDepth = 0;

    var header     = 'header'
    ,     code         = 'comment'
    ,     quote        = 'quote'
    ,     list1        = 'variable-2'
    ,     list2        = 'variable-3'
    ,     list3        = 'keyword'
    ,     hr             = 'hr'
    ,     image        = 'tag'
    ,     formatting = 'formatting'
    ,     linkinline = 'link'
    ,     linkemail = 'link'
    ,     linktext = 'link'
    ,     linkhref = 'string'
    ,     em             = 'em'
    ,     strong     = 'strong';

    var hrRE = /^([*\-=_])(?:\s*\1){2,}\s*$/
    ,     ulRE = /^[*\-+]\s+/
    ,     olRE = /^[0-9]+\.\s+/
    ,     taskListRE = /^\[(x| )\](?=\s)/ // Must follow ulRE or olRE
    ,     atxHeaderRE = /^#+/
    ,     setextHeaderRE = /^(?:\={1,}|-{1,})$/
    ,     textRE = /^[^#!\[\]*_\\<>` "'(]+/;

    function switchInline(stream, state, f) {
        state.f = state.inline = f;
        return f(stream, state);
    }

    function switchBlock(stream, state, f) {
        state.f = state.block = f;
        return f(stream, state);
    }

    // Blocks
    function blankLine(state) {
        // Reset linkTitle state
        state.linkTitle = false;
        // Reset EM state
        state.em = false;
        // Reset STRONG state
        state.strong = false;
        // Reset state.quote
        state.quote = 0;
        if (!htmlFound && state.f == htmlBlock) {
            state.f = inlineNormal;
            state.block = blockNormal;
        }
        // Reset state.trailingSpace
        state.trailingSpace = 0;
        state.trailingSpaceNewLine = false;
        // Mark this line as blank
        state.thisLineHasContent = false;
        return null;
    }

    function blockNormal(stream, state) {

        var sol = stream.sol();

        var prevLineIsList = (state.list !== false);
        if (state.list !== false && state.indentationDiff >= 0) { // Continued list
            if (state.indentationDiff < 4) { // Only adjust indentation if *not* a code block
                state.indentation -= state.indentationDiff;
            }
            state.list = null;
        } else if (state.list !== false && state.indentation > 0) {
            state.list = null;
            state.listDepth = Math.floor(state.indentation / 4);
        } else if (state.list !== false) { // No longer a list
            state.list = false;
            state.listDepth = 0;
        }

        var match = null;

        if (state.indentationDiff >= 4) {
            state.indentation -= 4;
            stream.skipToEnd();
            return code;
        } else if (stream.eatSpace()) {
            return null;
        } else if (match = stream.match(atxHeaderRE)) {
            state.header = match[0].length <= 6 ? match[0].length : 6;
            if (modeCfg.highlightFormatting) state.formatting = "header";
            state.f = state.inline;
            return getType(state);
        } else if (state.prevLineHasContent && (match = stream.match(setextHeaderRE))) {
            state.header = match[0].charAt(0) == '=' ? 1 : 2;
            if (modeCfg.highlightFormatting) state.formatting = "header";
            state.f = state.inline;
            return getType(state);
        } else if (stream.eat('>')) {
            state.indentation++;
            state.quote = sol ? 1 : state.quote + 1;
            if (modeCfg.highlightFormatting) state.formatting = "quote";
            stream.eatSpace();
            return getType(state);
        } else if (stream.peek() === '[') {
            return switchInline(stream, state, footnoteLink);
        } else if (stream.match(hrRE, true)) {
            return hr;
        } else if ((!state.prevLineHasContent || prevLineIsList) && (stream.match(ulRE, false) || stream.match(olRE, false))) {
            var listType = null;
            if (stream.match(ulRE, true)) {
                listType = 'ul';
            } else {
                stream.match(olRE, true);
                listType = 'ol';
            }
            state.indentation += 4;
            state.list = true;
            state.listDepth++;
            if (modeCfg.taskLists && stream.match(taskListRE, false)) {
                state.taskList = true;
            }
            state.f = state.inline;
            if (modeCfg.highlightFormatting) state.formatting = ["list", "list-" + listType];
            return getType(state);
        } else if (stream.sol() && stream.string.startsWith('```')) {
            if (stream.match(BLOCK_START, true)) {
                // try switching mode
                state.localMode = getMode(RegExp.$1);
                if (state.localMode) state.localState = state.localMode.startState();
                switchBlock(stream, state, local);
                if (modeCfg.highlightFormatting) state.formatting = "code-block";
                state.code = true;
                stream.skipToEnd();
                return getType(state);
            } else if (stream.match(/^```\s*$/, true)) {
                stream.skipToEnd();
                return getType(state);
            } else {
                stream.skipToEnd();
                return "error"
            }
        }

        return switchInline(stream, state, state.inline);
    }

    function htmlBlock(stream, state) {
        var style = htmlMode.token(stream, state.htmlState);
        if ((htmlFound && state.htmlState.tagStart === null && !state.htmlState.context) ||
                (state.md_inside && stream.current().indexOf(">") > -1)) {
            state.f = inlineNormal;
            state.block = blockNormal;
            state.htmlState = null;
        }
        return style;
    }

    function local(stream, state) {
        if (stream.sol() && stream.string.startsWith('```')) {
            if (stream.match(BLOCK_START, true)) {
                return getType(state);
            } else if (stream.match(/^```\s*$/, true)) {
                state.localMode = state.localState = null;
                state.f = inlineNormal;
                state.block = blockNormal;
                if (modeCfg.highlightFormatting) state.formatting = "code-block";
                state.code = true;
                var returnType = getType(state);
                state.code = false;
                return returnType;
            } else {
                stream.skipToEnd();
                return "error"
            }
        } else if (state.localMode) {
            return state.localMode.token(stream, state.localState);
        } else {
            stream.skipToEnd();
            return code;
        }
    }



    function localInline(lang) {
        var lm = getMode(lang);
        if (lm) {
            var ls = lm.startState();
            var start = true;
            return function(stream, state) {
                if (start) {
                    ls.formatting = "code";
                    start = false;
                    return getType(ls);
                } else if (stream.match(/^`/, true)) {
                    state.f = state.inline = inlineNormal;
                    ls.formatting = "code-block";
                    ls.code = true;
                    return getType(ls);
                }
                return lm.token(stream, ls);
            };
        } else {
            Logger.warn("Unknown language:", lang);
            return inlineNormal;
        }
    }

    // Inline
    function getType(state) {
        var styles = [];

        if (state.formatting) {
            styles.push(formatting);

            if (typeof state.formatting === "string") state.formatting = [state.formatting];

            for (var i = 0; i < state.formatting.length; i++) {
                styles.push(formatting + "-" + state.formatting[i]);

                if (state.formatting[i] === "header") {
                    styles.push(formatting + "-" + state.formatting[i] + "-" + state.header);
                }

                // Add `formatting-quote` and `formatting-quote-#` for blockquotes
                // Add `error` instead if the maximum blockquote nesting depth is passed
                if (state.formatting[i] === "quote") {
                    if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
                        styles.push(formatting + "-" + state.formatting[i] + "-" + state.quote);
                    } else {
                        styles.push("error");
                    }
                }
            }
        }

        if (state.taskOpen) {
            styles.push("meta");
            return styles.length ? styles.join(' ') : null;
        }
        if (state.taskClosed) {
            styles.push("property");
            return styles.length ? styles.join(' ') : null;
        }

        if (state.linkHref) {
            styles.push(linkhref);
            return styles.length ? styles.join(' ') : null;
        }

        if (state.strong) { styles.push(strong); }
        if (state.em) { styles.push(em); }

        if (state.linkText) { styles.push(linktext); }

        if (state.code) { styles.push(code); }

        if (state.header) { styles.push(header); styles.push(header + "-" + state.header); }

        if (state.quote) {
            styles.push(quote);

            // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth
            if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
                styles.push(quote + "-" + state.quote);
            } else {
                styles.push(quote + "-" + modeCfg.maxBlockquoteDepth);
            }
        }

        if (state.list !== false) {
            var listMod = (state.listDepth - 1) % 3;
            if (!listMod) {
                styles.push(list1);
            } else if (listMod === 1) {
                styles.push(list2);
            } else {
                styles.push(list3);
            }
        }

        if (state.trailingSpaceNewLine) {
            styles.push("trailing-space-new-line");
        } else if (state.trailingSpace) {
            styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b"));
        }

        return styles.length ? styles.join(' ') : null;
    }

    function handleText(stream, state) {
        if (stream.match(textRE, true)) {
            return getType(state);
        }
        return undefined;
    }

    function inlineNormal(stream, state) {
        var style = state.text(stream, state);
        if (typeof style !== 'undefined')
            return style;

        if (state.list) { // List marker (*, +, -, 1., etc)
            state.list = null;
            return getType(state);
        }

        if (state.taskList) {
            var taskOpen = stream.match(taskListRE, true)[1] !== "x";
            if (taskOpen) state.taskOpen = true;
            else state.taskClosed = true;
            if (modeCfg.highlightFormatting) state.formatting = "task";
            state.taskList = false;
            return getType(state);
        }

        state.taskOpen = false;
        state.taskClosed = false;

        if (state.header && stream.match(/^#+$/, true)) {
            if (modeCfg.highlightFormatting) state.formatting = "header";
            return getType(state);
        }

        // Get sol() value now, before character is consumed
        var sol = stream.sol();

        var ch = stream.next();

        if (ch === '\\') {
            stream.next();
            if (modeCfg.highlightFormatting) {
                var type = getType(state);
                return type ? type + " formatting-escape" : "formatting-escape";
            }
        }

        // Matches link titles present on next line
        if (state.linkTitle) {
            state.linkTitle = false;
            var matchCh = ch;
            if (ch === '(') {
                matchCh = ')';
            }
            matchCh = (matchCh+'').replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
            var regex = '^\\s*(?:[^' + matchCh + '\\\\]+|\\\\\\\\|\\\\.)' + matchCh;
            if (stream.match(new RegExp(regex), true)) {
                return linkhref;
            }
        }

        if (stream.match(INLINE_CODE_START, true)) {
            stream.eatWhile('`');
            switchInline(stream, state, localInline(RegExp.$1));
            state.formatting = "code-block";
            state.code = true;
            var returnType = getType(state);
            state.code = false;
            return returnType;
        } else if (ch === '`') {
            var previousFormatting = state.formatting;
            if (modeCfg.highlightFormatting) state.formatting = "code";
            var retType = getType(state);
            var before = stream.pos;
            stream.eatWhile('`');
            var difference = 1 + stream.pos - before;
            if (!state.code) {
                codeDepth = difference;
                state.code = true;
                return getType(state); // Opening backtick
            } else {
                if (difference === codeDepth) { // Must be exact
                    state.code = false;
                    state.f = state.inline = inlineNormal;
                    return retType;// Closing backtick
                }
                state.formatting = previousFormatting;
                return getType(state);
            }
        } else if (state.code) {
            return getType(state);
        }

        if (ch === '!' && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
            stream.match(/\[[^\]]*\]/);
            state.inline = state.f = linkHref;
            return image;
        }

        if (ch === '[' && stream.match(/.*\](\(| ?\[)/, false)) {
            state.linkText = true;
            if (modeCfg.highlightFormatting) state.formatting = "link";
            return getType(state);
        }

        if (ch === ']' && state.linkText) {
            if (modeCfg.highlightFormatting) state.formatting = "link";
            var type3 = getType(state);
            state.linkText = false;
            state.inline = state.f = linkHref;
            return type3;
        }

        if (ch === '<' && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
            state.f = state.inline = linkInline;
            if (modeCfg.highlightFormatting) state.formatting = "link";
            var type4 = getType(state);
            if (type4){
                type4 += " ";
            } else {
                type4 = "";
            }
            return type4 + linkinline;
        }

        if (ch === '<' && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
            state.f = state.inline = linkInline;
            if (modeCfg.highlightFormatting) state.formatting = "link";
            var type2 = getType(state);
            if (type2){
                type2 += " ";
            } else {
                type2 = "";
            }
            return type2 + linkemail;
        }

        if (ch === '<' && stream.match(/^\w/, false)) {
            if (stream.string.indexOf(">") != -1) {
                var atts = stream.string.substring(1,stream.string.indexOf(">"));
                if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts)) {
                    state.md_inside = true;
                }
            }
            stream.backUp(1);
            state.htmlState = CodeMirror.startState(htmlMode);
            return switchBlock(stream, state, htmlBlock);
        }

        if (ch === '<' && stream.match(/^\/\w*?>/)) {
            state.md_inside = false;
            return "tag";
        }

        var ignoreUnderscore = false;
        if (!modeCfg.underscoresBreakWords) {
            if (ch === '_' && stream.peek() !== '_' && stream.match(/(\w)/, false)) {
                var prevPos = stream.pos - 2;
                if (prevPos >= 0) {
                    var prevCh = stream.string.charAt(prevPos);
                    if (prevCh !== '_' && prevCh.match(/(\w)/, false)) {
                        ignoreUnderscore = true;
                    }
                }
            }
        }

        if (ch === '*' || (ch === '_' && !ignoreUnderscore)) {
            if (sol && stream.peek() === ' ') {
                // Do nothing, surrounded by newline and space
            } else if (state.strong === ch && stream.eat(ch)) { // Remove STRONG
                if (modeCfg.highlightFormatting) state.formatting = "strong";
                var t = getType(state);
                state.strong = false;
                return t;
            } else if (!state.strong && stream.eat(ch)) { // Add STRONG
                state.strong = ch;
                if (modeCfg.highlightFormatting) state.formatting = "strong";
                return getType(state);
            } else if (state.em === ch) { // Remove EM
                if (modeCfg.highlightFormatting) state.formatting = "em";
                var type5 = getType(state);
                state.em = false;
                return type5;
            } else if (!state.em) { // Add EM
                state.em = ch;
                if (modeCfg.highlightFormatting) state.formatting = "em";
                return getType(state);
            }
        } else if (ch === ' ') {
            if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces
                if (stream.peek() === ' ') { // Surrounded by spaces, ignore
                    return getType(state);
                } else { // Not surrounded by spaces, back up pointer
                    stream.backUp(1);
                }
            }

            if (stream.match(/ +$/, false)) {
                state.trailingSpace++;
            } else if (state.trailingSpace) {
                state.trailingSpaceNewLine = true;
            }
        }

        return getType(state);
    }

    function linkInline(stream, state) {
        var ch = stream.next();

        if (ch === ">") {
            state.f = state.inline = inlineNormal;
            if (modeCfg.highlightFormatting) state.formatting = "link";
            var type = getType(state);
            if (type){
                type += " ";
            } else {
                type = "";
            }
            return type + linkinline;
        }

        stream.match(/^[^>]+/, true);

        return linkinline;
    }

    function linkHref(stream, state) {
        // Check if space, and return NULL if so (to avoid marking the space)
        if(stream.eatSpace()){
            return null;
        }
        var ch = stream.next();
        if (ch === '(' || ch === '[') {
            state.f = state.inline = getLinkHrefInside(ch === "(" ? ")" : "]");
            if (modeCfg.highlightFormatting) state.formatting = "link-string";
            state.linkHref = true;
            return getType(state);
        }
        return 'error';
    }

    function getLinkHrefInside(endChar) {
        return function(stream, state) {
            var ch = stream.next();

            if (ch === endChar) {
                state.f = state.inline = inlineNormal;
                if (modeCfg.highlightFormatting) state.formatting = "link-string";
                var returnState = getType(state);
                state.linkHref = false;
                return returnState;
            }

            if (stream.match(inlineRE(endChar), true)) {
                stream.backUp(1);
            }

            state.linkHref = true;
            return getType(state);
        };
    }

    function footnoteLink(stream, state) {
        if (stream.match(/^[^\]]*\]:/, false)) {
            state.f = footnoteLinkInside;
            stream.next(); // Consume [
            if (modeCfg.highlightFormatting) state.formatting = "link";
            state.linkText = true;
            return getType(state);
        }
        return switchInline(stream, state, inlineNormal);
    }

    function footnoteLinkInside(stream, state) {
        if (stream.match(/^\]:/, true)) {
            state.f = state.inline = footnoteUrl;
            if (modeCfg.highlightFormatting) state.formatting = "link";
            var returnType = getType(state);
            state.linkText = false;
            return returnType;
        }

        stream.match(/^[^\]]+/, true);

        return linktext;
    }

    function footnoteUrl(stream, state) {
        // Check if space, and return NULL if so (to avoid marking the space)
        if(stream.eatSpace()){
            return null;
        }
        // Match URL
        stream.match(/^[^\s]+/, true);
        // Check for link title
        if (stream.peek() === undefined) { // End of line, set flag to check next line
            state.linkTitle = true;
        } else { // More content on line, check if link title
            stream.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, true);
        }
        state.f = state.inline = inlineNormal;
        return linkhref;
    }

    var savedInlineRE = [];
    function inlineRE(endChar) {
        if (!savedInlineRE[endChar]) {
            // Escape endChar for RegExp (taken from http://stackoverflow.com/a/494122/526741)
            endChar = (endChar+'').replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
            // Match any non-endChar, escaped character, as well as the closing
            // endChar.
            savedInlineRE[endChar] = new RegExp('^(?:[^\\\\]|\\\\.)*?(' + endChar + ')');
        }
        return savedInlineRE[endChar];
    }

    var mode = {
        startState: function() {
            return {
                f: blockNormal,

                prevLineHasContent: false,
                thisLineHasContent: false,

                block: blockNormal,
                htmlState: null,
                indentation: 0,

                inline: inlineNormal,
                text: handleText,

                formatting: false,
                linkText: false,
                linkHref: false,
                linkTitle: false,
                em: false,
                strong: false,
                header: 0,
                taskList: false,
                list: false,
                listDepth: 0,
                quote: 0,
                trailingSpace: 0,
                trailingSpaceNewLine: false,

                firstLine: true
            };
        },

        copyState: function(s) {
            return {
                f: s.f,

                prevLineHasContent: s.prevLineHasContent,
                thisLineHasContent: s.thisLineHasContent,

                block: s.block,
                htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),
                indentation: s.indentation,

                localMode: s.localMode,
                localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,

                inline: s.inline,
                text: s.text,
                formatting: false,
                linkTitle: s.linkTitle,
                em: s.em,
                strong: s.strong,
                header: s.header,
                taskList: s.taskList,
                list: s.list,
                listDepth: s.listDepth,
                quote: s.quote,
                trailingSpace: s.trailingSpace,
                trailingSpaceNewLine: s.trailingSpaceNewLine,
                md_inside: s.md_inside,

                inYamlHeader: s.inYamlHeader,
                firstLine: s.firstLine
            };
        },

        token: function(stream, state) {
            try {
                if (state.firstLine && stream.sol() && !state.inYamlHeader && stream.match(YAML_HEADER_TAG, false)) {
                    stream.skipToEnd();
                    state.inYamlHeader = true;
                    state.formatting = "header";
                    return "header"
                } else if (state.inYamlHeader && stream.sol() && stream.match(YAML_HEADER_TAG, false)) {
                    state.inYamlHeader = false;
                    stream.skipToEnd();
                    state.formatting = "header";
                    return "header"
                } else if (state.inYamlHeader) {
                    stream.skipToEnd();
                    state.formatting = "comment";
                    return "header"
                }


                // Reset state.formatting
                state.formatting = false;

                if (stream.sol()) {
                    var forceBlankLine = stream.match(/^\s*$/, true) || state.header;

                    // Reset state.header
                    state.header = 0;

                    if (forceBlankLine) {
                        state.prevLineHasContent = false;
                        return blankLine(state);
                    } else {
                        state.prevLineHasContent = state.thisLineHasContent;
                        state.thisLineHasContent = true;
                    }

                    // Reset state.taskList
                    state.taskList = false;

                    // Reset state.code
                    state.code = false;

                    // Reset state.trailingSpace
                    state.trailingSpace = 0;
                    state.trailingSpaceNewLine = false;

                    state.f = state.block;
                    var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, '        ').length;
                    var difference = Math.floor((indentation - state.indentation) / 4) * 4;
                    if (difference > 4) difference = 4;
                    var adjustedIndentation = state.indentation + difference;
                    state.indentationDiff = adjustedIndentation - state.indentation;
                    state.indentation = adjustedIndentation;
                    if (indentation > 0) return null;
                }

                var result = state.f(stream, state);
                var ret;
                if (stream.start == stream.pos) {
                    ret = this.token(stream, state);
                } else {
                    ret = result;
                }
                state.firstLine = false;
                return ret;
            } catch (e) {
                Logger.error("Codemirror mode failed",e)
                stream.skipToEnd();
            }
        },

        innerMode: function(state) {
            if (state.block == htmlBlock) return {state: state.htmlState, mode: htmlMode};
            if (state.localState) return {state: state.localState, mode: state.localMode};
            return {state: state, mode: mode};
        },

        blankLine: blankLine,

        getType: getType,

        fold: "markdown"
    };
    return mode;
});

CodeMirror.defineMIME("text/rmarkdown", "rmarkdown");

return {
    // this is not really a service, it has no functionnality
};

});

})();
(function() {
'use strict';

const app = angular.module('dataiku.controllers');


app.controller('ProfileController', function($scope, $state, $stateParams, $rootScope, AchievementService, ActivityIndicator, DataikuAPI, TopNav, MessengerUtils, WT1, $anchorScroll) {
    var tab = $state.current.data ? $state.current.data.selectedTab : null;
    TopNav.setNoItem();
    TopNav.setLocation(TopNav.DSS_HOME, "administration", null, tab);
    $scope.uiState = $scope.uiState || {};

    $scope.$on("$stateChangeSuccess", function() {
        var tab = $state.current.data ? $state.current.data.selectedTab : null;
        TopNav.setNoItem();
        TopNav.setLocation(TopNav.DSS_HOME, "administration", null, tab);
    });

    $scope.requestedProfile = $rootScope.appConfig.login;
    if ($stateParams.userLogin) {
        $scope.requestedProfile = $stateParams.userLogin;
    }

    $scope.profile = {};

    $scope.logout = function() {
        DataikuAPI.logout().success(function(data) {
            // Violent redirect to avoid keeping a cached appConfig
            window.location = "/login/";
        }).error(setErrorInScope.bind($scope));
    };

    function loadProfile() {
        DataikuAPI.profile.get($scope.requestedProfile).success(function(data) {
            $scope.profile.user = data;
            $anchorScroll();
        }).error(setErrorInScope.bind($scope));

        DataikuAPI.profile.achievements($scope.requestedProfile).success(function(data) {
            // enrich the data
            var achievements = [];
            for(var k in data.achievements) {
                var x = AchievementService.getAchievement(data.achievements[k].id);
                if (x) {
                    var achievement = data.achievements[k];
                    achievement.icon = x.icon;
                    achievement.title = x.title;
                    achievement.text = x.text;
                    achievements.push(achievement);
                }
            }
            $scope.profile.achievements = data;
            $scope.profile.achievements.achievements = achievements;
        }).error(setErrorInScope.bind($scope));
    }

    WT1.event("user-profile-load", {});
    loadProfile();
    $scope.$on("UPDATED_PROFILE", function() {
        loadProfile();
    });

    $scope.oldUserSettings = angular.copy($rootScope.appConfig.userSettings);
    $scope.userSettings = angular.copy($rootScope.appConfig.userSettings);

    $scope.isDirtyUserSettings = function () {
        return !angular.equals($scope.userSettings, $scope.oldUserSettings);
    };

    $scope.isEnableFlowZoomTracking = function (isOn) { // avoid presenting negative names, but store as 'disable' flag to avoid need to migrate settings
        if (angular.isDefined(isOn)) {
            $scope.userSettings.disableFlowZoomTracking = !isOn ;
        } else {        
            return !$scope.userSettings.disableFlowZoomTracking;
        }
    };

    $scope.saveUserSettings = function () {
        DataikuAPI.profile.setUserSettings($scope.userSettings).success(function () {
            if (!angular.equals(($scope.userSettings.home || {}).rows, ($scope.oldUserSettings.home || {}).rows)) {
                WT1.event("user-profile-set-home-row", {rows: ($scope.userSettings.home || {}).rows});
            }
            $rootScope.appConfig.userSettings = $scope.userSettings;
            $scope.oldUserSettings = angular.copy($scope.userSettings);
        })
        .error(setErrorInScope.bind($scope));

        WT1.event("user-profile-save-settings", {
            digests: $scope.userSettings.digests.enabled,
            mentionEmails: $scope.userSettings.mentionEmails.enabled,
            offlineQueue: $scope.userSettings.offlineQueue.enabled,
            frontendNotifications: $scope.userSettings.frontendNotifications,
            codeEditor: $scope.userSettings.codeEditor,
            home: $scope.userSettings.home,
            disableFlowZoomTracking: $scope.userSettings.disableFlowZoomTracking
        });
    };

    $scope.sampleMessengerNotification = function () {
        MessengerUtils.post({
          message: "Here is your example! <br/> So, what do you want to be notified of?",
          hideAfter: 2,
          id: 'sampleNotification'
        });
    };

    $scope.hooks = {save : null, isDirty : null};
});


app.controller('MyProfileEditController', function($scope, $state, $stateParams, DataikuAPI, $rootScope, TopNav, WT1) {
    $scope.user = {};
    $scope.oldUser = {};
    $scope.image = {};

    DataikuAPI.profile.get()
        .success(function(data) {
            $scope.user = data;
            $scope.user.passwordConfirmation='';
            $scope.user.password='';
            $scope.oldUser = angular.copy($scope.user);
        })
        .error(setErrorInScope.bind($scope));

    $scope.isDirtyUser = function() {
        return !angular.equals($scope.user, $scope.oldUser) && $scope.user.passwordConfirmation == $scope.user.password && !$scope.userDescriptionForm.$invalid;
    };

    $scope.saveUser = function() {
        WT1.event("user-profile-save-user", {});
        DataikuAPI.profile.edit($scope.user).success(function(data) {
             $scope.errorMessage ='';
             if($scope.image.file) {
                 DataikuAPI.profile.uploadPicture($scope.image.file).then(function(data) {
                     $state.go("profile.my.view");
                     $rootScope.$broadcast('UPDATED_PROFILE');
                 }, setErrorInScope.bind($scope));
             } else {
                 $rootScope.$broadcast('UPDATED_PROFILE');
                 $state.go("profile.my.view");
             }
        }).error(function(a, b, c) {
            if(a.code == "666") {
                // user error
                $scope.errorMessage = a.message;
            } else {
                // api error
                setErrorInScope.bind($scope)(a, b, c)
            }
        });
    }

    $scope.hooks.save = $scope.saveUser;
    $scope.hooks.isDirty = $scope.isDirtyUser;
});


app.controller('MyProfileAchievementsController', function($scope) {
    $scope.hooks.save = null;
    $scope.hooks.isDirty = null;
});


app.controller('MyProfileStarsController', function($scope, $rootScope, $state, DataikuAPI, TopNav, InterestsService, WT1) {
    $scope.hooks.save = null;
    $scope.hooks.isDirty = null;

    function getUserInterests(offset) {
        DataikuAPI.interests.getUserInterests($rootScope.appConfig.login, offset, 100, $scope.filters).success(function(data) {
            $scope.results = data;
        }).error(setErrorInScope.bind($scope));
    }
    getUserInterests(0);

    $scope.previousResults = function() {
        getUserInterests($scope.results.offset - $scope.results.pageSize);
    };

    $scope.nextResults = function() {
        getUserInterests($scope.results.offset + $scope.results.pageSize);
    };

    function getTaggableObjects(object) {
        return [{
            type: object.objectType,
            projectKey: object.projectKey,
            id: object.objectId
        }];
    }

    $scope.starObject = function(object, star) {
        WT1.event("user-profile-star", {});
        InterestsService.star($scope, getTaggableObjects(object), star).success( () => object.starred = star);
    };

    $scope.watchObject = function(object, watch) {
        WT1.event("user-profile-watch", {});
        InterestsService.watch($scope, getTaggableObjects(object), watch).success( () => object.watching = watch);
    };

    $scope.getProjectName = function(projectKey) {
        if (!projectKey || !projectsMap) return;
        return (projectsMap[projectKey] || {}).name;
    };

    var projectsMap;
    $scope.filters = {projectKey: null, taggableType: null};

    DataikuAPI.projects.list().success(function(data) {
        projectsMap = {};
        data.forEach(function(p) {
            projectsMap[p.projectKey] = p;
        });
        $scope.projects = data;
        $scope.projects.push({projectKey: null, name: 'All projects'});
    }).error(setErrorInScope.bind($scope));

    $scope.$watch("filters", function() { getUserInterests($scope.results ? $scope.results.offset : 0)}, true);
});


app.controller("MyProfilePersonalAPIKeysController", function ($scope, $state, DataikuAPI, CreateModalFromTemplate, Dialogs, TopNav, WT1) {
    $scope.hooks.save = null;
    $scope.hooks.isDirty = null;

    $scope.refreshApiKeysList = function () {
        DataikuAPI.profile.listPersonalAPIKeys().success(function (data) {
            $scope.apiKeys = data;
        }).error(setErrorInScope.bind($scope));
    };

    $scope.refreshApiKeysList();

    $scope.createAPIKey = function () {
        WT1.event("user-profile-create-API-key", {});
        DataikuAPI.profile.createPersonalAPIKey().success(function(data) {
            $scope.refreshApiKeysList();
        }).error(setErrorInScope.bind($scope));
    };

    $scope.deleteAPIKey = function (key) {
        Dialogs.confirm($scope, "Remove API key", "Are you sure you want to remove this API key?").then(function () {
            WT1.event("user-profile-delete-API-key", {});
            DataikuAPI.profile.deletePersonalAPIKey(key).success(function (data) {
                $scope.refreshApiKeysList();
            }).error(setErrorInScope.bind($scope));
        });
    };

    $scope.viewQRCode = function (key) {
        CreateModalFromTemplate("/templates/admin/security/api-key-qrcode-modal.html", $scope, null, function (newScope) {
            newScope.apiKeyQRCode = JSON.stringify({
                k : key.key,
                u : $scope.appConfig.dssExternalURL
            });
        });
    };
});

app.controller("MyProfileConnectionCredentialsController", function ($scope, $state, DataikuAPI, CreateModalFromTemplate, Dialogs, TopNav, WT1, ActivityIndicator, $window) {
    $scope.hooks.save = null;
    $scope.hooks.isDirty = null;

    $scope.refreshCredentials = function () {
        DataikuAPI.profile.listConnectionCredentials().success(function (data) {
            $scope.credentials = data;
        }).error(setErrorInScope.bind($scope));
    };

    $scope.refreshCredentials();

    $scope.editCredential = function (credential) {
        WT1.event("user-profile-edit-credentials", {});

        if ($scope.isConnectionCredential(credential)) {
            $scope.modalTitle = (credential.connection || $scope.cleanConnectionName) + " (" + credential.connectionType + ")"
        } else if (credential.requestSource === 'PLUGIN') {
            var pluginInfo = credential.pluginCredentialRequestInfo
            $scope.modalTitle = pluginInfo.paramName + " (" + pluginInfo.presetId + ")"
        }

        if (credential.type === "SINGLE_FIELD" || credential.type === "BASIC") {
            CreateModalFromTemplate("/templates/profile/edit-connection-credential-modal.html", $scope, null, function (newScope) {
                newScope.credential = credential;
                newScope.credential.password = "";

                newScope.modalTitle = $scope.modalTitle;
                newScope.passwordFieldTitle = credential.type === 'BASIC' ? "Password" : "Credential";

                newScope.confirm = function() {
                    var apiCall;
                    if ($scope.isConnectionCredential(credential)) {
                        apiCall = DataikuAPI.profile.setBasicConnectionCredential(newScope.credential.connection,
                                      newScope.credential.user, newScope.credential.password)
                    } else {
                        var pluginInfo = credential.pluginCredentialRequestInfo
                        apiCall = DataikuAPI.profile.pluginCredentials.setBasicCredential(pluginInfo.pluginId,
                                      pluginInfo.paramSetId, pluginInfo.presetId, pluginInfo.paramName,
                                      newScope.credential.user, newScope.credential.password)
                    }

                    apiCall.success(function (data) {
                        newScope.dismiss();
                        ActivityIndicator.success("Credential saved");
                        $scope.refreshCredentials();
                    }).error(setErrorInScope.bind($scope));
                }
            });
        } else if (credential.type === "AZURE_OAUTH_DEVICECODE") {
            resetErrorInScope($scope);
            CreateModalFromTemplate("/templates/profile/edit-azure-oauth-connection-credential-modal.html", $scope, null, function (newScope) {
                newScope.uiState = {
                    step: "STARTUP"
                }
                newScope.credential = credential;

                newScope.startStep1 = function() {
                    DataikuAPI.profile.connectionCredentials.azureOAuthDeviceCodeDanceStep1(
                                newScope.credential.connection).success(function (data) {
                        newScope.uiState.step = "STEP1_COMPLETE";
                        newScope.uiState.deviceCode = data;
                        if (data.message) {
                            data.htmlMessage = marked(data.message).replace("<a href", "<a target='_blank' href");
                        }
                    }).error(setErrorInScope.bind($scope));
                }
                newScope.startStep2 = function() {
                    DataikuAPI.profile.connectionCredentials.azureOAuthDeviceCodeDanceStep2(
                                newScope.credential.connection, newScope.uiState.deviceCode).success(function (data) {
                        newScope.dismiss();
                        ActivityIndicator.success("Credential obtained")
                    }).error(setErrorInScope.bind($scope));
                }

                newScope.startStep1();
            });
        } else if (credential.type === "OAUTH_REFRESH_TOKEN") {
            resetErrorInScope($scope);
            CreateModalFromTemplate("/templates/profile/edit-oauth-connection-credential-modal.html", $scope, null, function (newScope) {
                newScope.modalTitle = $scope.modalTitle;

                if ($scope.isConnectionCredential(credential)) {
                    newScope.connection = credential.connection;

                    newScope.confirm = function() {
                        DataikuAPI.profile.connectionCredentials.getOAuth2AuthorizationEndpoint(
                            urlWithProtocolAndHost(),
                            $state.current.name,
                            newScope.connection)
                        .success(function (data) {
                            // Redirect to begin authorization process
                            $window.location.href = data;
                        }).error(setErrorInScope.bind($scope));
                    }
                } else if (credential.requestSource === 'PLUGIN') {
                    newScope.credential = credential.pluginCredentialRequestInfo;

                    newScope.confirm = function() {
                        DataikuAPI.profile.pluginCredentials.getOAuth2AuthorizationEndpoint(
                            urlWithProtocolAndHost(),
                            $state.current.name,
                            newScope.credential.pluginId,
                            newScope.credential.paramSetId,
                            newScope.credential.presetId,
                            newScope.credential.paramName)
                        .success(function (data) {
                            // Redirect to begin authorization process
                            $window.location.href = data;
                        }).error(setErrorInScope.bind($scope));
                    }
                }
            });
        }
    };

    $scope.deleteConnectionCredential = function (connection) {
        WT1.event("user-profile-delete-credentials", {});
        Dialogs.confirm($scope, "Remove personal credential", "Are you sure you want to remove this connection credential?").then(function () {
            DataikuAPI.profile.setBasicConnectionCredential(connection, null, null).success(function (data) {
                ActivityIndicator.success("Credential removed")
                $scope.refreshCredentials();
            }).error(setErrorInScope.bind($scope));
        });
    };

    $scope.deletePluginCredential = function (pluginCredentialRequestInfo) {
        WT1.event("user-profile-delete-credentials", {});
        Dialogs.confirm($scope, "Remove personal credential", "Are you sure you want to remove this plugin credential?").then(function () {
            DataikuAPI.profile.pluginCredentials.setBasicCredential(pluginCredentialRequestInfo.pluginId,
                pluginCredentialRequestInfo.paramSetId, pluginCredentialRequestInfo.presetId,
                pluginCredentialRequestInfo.paramName, null, null).success(function (data) {
                ActivityIndicator.success("Credential removed")
                $scope.refreshCredentials();
            }).error(setErrorInScope.bind($scope));
        });
    };

    $scope.isConnectionCredential = function(credential) {
        return ['CONNECTION', 'VIRTUAL_CONNECTION', 'DATABRICKS_INTEGRATION'].includes(credential.requestSource)
    }

    $scope.connectionCredentials = function () {
        if ($scope.credentials) {
            return $scope.credentials.credentials.filter($scope.isConnectionCredential)
        }
    }

    $scope.pluginCredentials = function () {
        if ($scope.credentials) {
            return $scope.credentials.credentials.filter(credential => credential.requestSource == 'PLUGIN')
        }
    }
});


app.controller('MyProfileExportController', function($scope, $rootScope, $state, DataikuAPI, TopNav, WT1, Dialogs) {
    $scope.hooks.save = null;
    $scope.hooks.isDirty = null;

    function list() {
        DataikuAPI.exports.list().success(function(data) {
            $scope.userExports = data;
        }).error(setErrorInScope.bind($scope));
    }

    $scope.downloadExport = function(exportId) {
        WT1.event("user-profile-download-export", {});
        downloadURL(DataikuAPI.exports.getDownloadURL(exportId));
    };

    $scope.deleteExport = function(exportId) {
        WT1.event("user-profile-delete-export", {});
        DataikuAPI.exports.remove(exportId).error(setErrorInScope.bind($scope)).then(list);
    };


    $scope.clearExports = function() {
        WT1.event("user-profile-clear-exports", {});
        Dialogs.confirm($scope,"Remove all exports","Are you sure you want to remove all finished exports ?").then(function() {
            DataikuAPI.exports.clear().error(setErrorInScope.bind($scope)).then(list);
        });
    };


    list();
});

app.controller('MyProfileAccountController', function($scope, $rootScope, CodeMirrorSettingService, HomeBehavior, EXPORTED_TILES) {
    $scope.hooks.save = $scope.saveUserSettings;
    $scope.hooks.isDirty = $scope.isDirtyUserSettings;

    $scope.initCodeEditorSettings = function() {
        if (!$scope.userSettings.codeEditor) {
            $scope.userSettings.codeEditor = {
                theme: 'default',
                fontSize: 13,
                autoCloseBracket: true,
                keyMap: 'default'
            };
        }
    };
    $scope.initCodeEditorSettings();

    /*
     * Preview
     */

    $scope.initEditor = function() {
        $scope.sample = 'def process(dataset, partition_id):\n    parameter1_value = config.get("parameter1", None)\n    # return a dict of the metrics\' values\n    metric_values = {}\n    # type is inferred automatically from the object type\n    metric_values[\'name1\'] = 15\n    # type can be forced using the values in the MetricDataTypes enum\n    metric_values[\'name2\'] = (15, MetricDataTypes.STRING)\n    return metric_values\ntest';
        $scope.editorOptions = CodeMirrorSettingService.get("text/x-python", {onLoad: function(cm){$scope.codeMirror = cm;}});
    };
    $scope.initEditor();

    $scope.updatePreview = function() {
        $scope.codeMirror.setOption('theme', $scope.userSettings.codeEditor.theme);
        $scope.codeMirror.setOption('keyMap', $scope.userSettings.codeEditor.keyMap);
        $scope.codeMirror.setOption('matchBrackets', $scope.userSettings.codeEditor.matchBrackets);
        $($($scope.codeMirror.getTextArea()).siblings('.CodeMirror')[0]).css('font-size', $scope.userSettings.codeEditor.fontSize + 'px');
    };

    /*
     * Options
     */

    $scope.fontSizes = [];
    for (var i = 8; i<=30; i++) {
        $scope.fontSizes.push(i);
    }

    $scope.codeMirrorThemeList = [
        "default",
        "3024-day",
        "3024-night",
        "ambiance",
        "base16-dark",
        "base16-light",
        "blackboard",
        "cobalt",
        "eclipse",
        "elegant",
        "erlang-dark",
        "lesser-dark",
        "mbo",
        "mdn-like",
        "midnight",
        "monokai",
        "neat",
        "neo",
        "night",
        "paraiso-dark",
        "paraiso-light",
        "pastel-on-dark",
        "rubyblue",
        "solarized",
        "the-matrix",
        "tomorrow-night-eighties",
        "twilight",
        "vibrant-ink",
        "xq-dark",
        "xq-light"
    ];

    $scope.homeBehaviorList = [
        {
            label: 'Default',
            state: HomeBehavior.DEFAULT,
        },
        {
            label: 'Projects',
            state: HomeBehavior.PROJECTS,
        },
        {
            label: 'Last homepage',
            state: HomeBehavior.LAST,
        },
    ];

    // Take the potentially new tiles and override with the existing
    $scope.userSettings.home.rows = $scope.userSettings.home.rows || [];
    EXPORTED_TILES.forEach(tile => {
        const found = $scope.userSettings.home.rows.find(row => row.tileType == tile.type);
        if (found) {
            Object.assign(found, { name: tile.heading, tileType: tile.type });
        } else {
            $scope.userSettings.home.rows.push({ name: tile.heading, tileType: tile.type, visible: true });
        }
    });
    $scope.oldUserSettings.home.rows = angular.copy($scope.userSettings.home.rows); // Trick for the save button
    $scope.nonVisibleRows = $scope.userSettings.home.rows.filter(r => r.visible === false);

    $scope.removeRow = (row, idx) => {
        row.visible = false;
        $scope.userSettings.home.rows.push($scope.userSettings.home.rows.splice(idx, 1)[0]);
        $scope.nonVisibleRows = $scope.userSettings.home.rows.filter(r => r.visible === false);
    };

    $scope.addNewRow = selectedOption => {
        if (!selectedOption) { return; }
        const found = $scope.userSettings.home.rows.find(r => r.tileType === selectedOption.tileType);
        const foundIndex = $scope.userSettings.home.rows.findIndex(r => r.tileType === selectedOption.tileType);
        if (found !== undefined) {
            found.visible = true;
            $scope.nonVisibleRows = $scope.userSettings.home.rows.filter(r => r.visible === false);
            $scope.userSettings.home.rows.splice(foundIndex, 1);
            const newPosition = $scope.userSettings.home.rows.length - $scope.nonVisibleRows.length;
            $scope.userSettings.home.rows.splice(newPosition, 0, found);
        }
    };

    $scope.treeOptions = {
        dropped: () => {
            // Rebuild position based on index of the list as the component has already updated their index
            $scope.userSettings.home.rows.forEach((r, index) => r.position = index);
        },
    }
});



app.service("AchievementService", ['$rootScope', function () {
    const achievements = {
        LOL: {
            icon: 'icon-bell',
            title: "I lol on you",
            text: "You clicked the lol button"
        },
        // This is buggy
        // ACTIVE_5_MINUTES : {
        //     icon : 'icon-bell',
        //     title : "Eager discoverer",
        //     text : "Use Dataiku DSS for 5 minutes"
        // },
        // ACTIVE_30_MINUTES : {
        //     icon : 'icon-bell',
        //     title : "Wanna-be addict",
        //     text : "Use Dataiku DSS for 30 minutes"
        // },
        LETS_GET_COOKING: {
            icon: 'icon-book',
            title: "Let's get cooking",
            text: "Create your first recipe"
        },
        APPRENTICE_BARTENDER: {
            icon: 'icon-visual_prep_cleanse_recipe',
            title: "Apprentice bartender",
            text: "Create a shaker script with 5 steps"
        },
        NOT_QUITE_PARKINSON: {
            icon: 'icon-visual_prep_cleanse_recipe',
            title: "Eidetic memory",
            text: "Shake with more than 20 steps"
        },
        ALL_ON_BOARD: {
            icon: 'icon-group',
            title: "All on board !",
            text: "Connect at least 3 times to DSS"
        },
        OH_NOES_JOB_FAILED: {
            icon: 'icon-frown',
            title: 'Oh noes ! Job failed !',
            text: 'Fail your first job'
        },
        MY_FIRST_JOB: {
            icon: 'icon-rocket',
            title: 'My first job !',
            text: 'Make your first job success'
        },
        STING_OF_THE_BEE: {
            icon: 'icon-code_hive_recipe',
            title: 'Sting of the bee',
            text: 'Fail a Hive job'
        },
        SLOW_SHAKE_1: {
            icon: 'icon-visual_prep_cleanse_recipe',
            title: 'I almost had to wait',
            text: 'Make a Shaker script last more than 10 seconds'
        },
        SLOW_SHAKE_2: {
            icon: 'icon-visual_prep_cleanse_recipe',
            title: 'I guess I could grab a coffee',
            text: 'Make a Shaker script last more than 30 seconds'
        },
        SLOW_SHAKE_3: {
            icon: 'icon-visual_prep_cleanse_recipe',
            title: "Almost fell asleep",
            text: 'Make a Shaker script last more than 1 minute'
        },
        CODE_SAMPLE_WIZZARD: {
            icon: 'icon-code',
            title: "My first code sample !",
            text: 'Congrats ! Even better when it\'s shared ;) '
        },
        LIGHT_THE_SPARK: {
            icon: 'icon-magic',
            title: "Homo Erectus",
            text: "Light the first Spark"
        },
        IT_HAD_TO_BE_DONE: {
            icon: 'icon-list-ol',
            title: "It had to be done !",
            text: "Complete your first todo list"
        },
        TEAM_PLAYER: {
            icon: 'icon-thumbs-up-alt',
            title: "Teammate of the month",
            text: "Add description and tags to DSS objects"
        },
        COLORS_OF_THE_WIND: {
            icon: 'icon-sun',
            title: "Paint with all the colors of the wind",
            text: "Color the flow based on various metadata"
        },
        WE_ARE_ALCHEMISTS: {
            icon: 'icon-beaker',
            title: "It's science, we're alchemists",
            text: "Create a recipe from a notebook"
        }
    };

    this.getAchievement = function(id) {
        return achievements[id];
    };
}]);


app.directive('achievements', function(AchievementService, Notification, Logger, $http, $templateCache, $compile) {
    const templatePath = "/templates/achievement.html";

    return {
        restrict : 'A',
        link : function($scope, element, attrs) {
            Notification.registerEvent("achievement-unlocked", function(evt, message) {
                Logger.info("Achievement unlocked", message);

                $http.get(templatePath, {cache: $templateCache}).then(function(response) {
                    const a = $('<div class="achievement" />').html(response.data).css('pointer-events', 'none');
                    const contents = a.contents();
                    $("body").append(a);
                    const newScope = $scope.$new();

                    const achievement = AchievementService.getAchievement(message.achievementId);
                    newScope.achievementId = message.achievementId;
                    newScope.achievementText = achievement.text;
                    newScope.achievementTitle = achievement.title;
                    newScope.achievementIcon = achievement.icon;

                    $compile(contents)(newScope);
                    window.setTimeout(function() {a.addClass("active");}, 800);
                    window.setTimeout(function() {a.addClass("gone");}, 5000);
                });
            });
        }
    };
});

app.factory('InterestWording', () => {
    const labels = {
        WATCH: 'Watch',
        UNWATCH: 'Unwatch',
        STAR: 'Star',
        UNSTAR: 'Unstar',
    };

    const tooltips = {
        WATCH: 'Receive notifications when this object changes',
        UNWATCH: 'Stop receiving notifications when this object changes',
        STAR: 'Mark this object as favorite - favorites can be easily filtered/searched in various places, including your profile',
        UNSTAR: 'Remove this object from your list of favorites',

        plural: {
            WATCH: 'Receive notifications when these objects change',
            UNWATCH: 'Stop receiving notifications when these objects change',
            STAR: 'Mark these objects as favorites - favorites can be easily filtered/searched in various places, including your profile',
            UNSTAR: 'Remove these objects from your list of favorites',
        },
    };

    return {
        labels,
        tooltips,
    };
});

app.factory('WatchInterestState', () => {
    const values = {
        YES: 'YES',
        SHALLOW: 'SHALLOW',
        ENO: 'ENO',
        INO: 'INO',
    };

    const { YES, SHALLOW } = values;
    const isShallowWatching = (state) => SHALLOW == state;
    const isFullyWatching = (state) => YES == state;
    const isWatching = (state) => isFullyWatching(state) || isShallowWatching(state);

    return {
        values,
        isShallowWatching,
        isFullyWatching,
        isWatching,
    };
});

app.service('InterestsService', function($state, WT1, DataikuAPI, WatchInterestState) {
    this.watch = function(scope, taggableObjects, watch) {
        // Note: watch is not a boolean, please see WatchInterestState
        let w;
        if (watch === true) {
            w = WatchInterestState.values.YES;
        } else if (watch === false) {
            w = WatchInterestState.values.ENO;
        } else {
            w = watch;
        }

        WT1.event("watch-object", {watch: w, state: $state.current.name, objects: taggableObjects.length});
        return DataikuAPI.interests.watch(taggableObjects, w)
            .success(function() {})
            .error(setErrorInScope.bind(scope));
    };

    this.star = function(scope, taggableObjects, star) {
        WT1.event("star-object", {star: star, state: $state.current.name, objects: taggableObjects.length});
        return DataikuAPI.interests.star(taggableObjects, star)
            .success(function() {})
            .error(setErrorInScope.bind(scope));
    };
});

}());
