(function() {
'use strict';

    /**
     * Directives and functions for the main flow graphs
     * (flow, inter project graph and job preview subgraph)
     */


    const app = angular.module('dataiku.flow.graph', []);

    app.service('GraphZoomTrackerService', function($timeout, $stateParams, localStorageService) {
        // GraphZoomTrackerService tracks the context needed to restore the zoom level, window position and focussed item when returning to the
        // flow view screen.  The zoomCtx (zoom-context) is persisted in local storage and comprises:
        // - focusItem: details of the last focused node, as tracked by the service.
        // - panzoom: $scope.panzoom context managed by the flowGraph directive, an extended version of the viewBox dimensions of the SVG flow graph element
        // - nodeCount: the number of node in the whole flow

        const svc = this;
        const lsKeyPrefix = "zoomCtx-";
        let zoomCtxKeyLoaded = "";
        let currentCtx = {};
        let disabled = false;

        svc.disable = function(disable = true) {
            disabled = disable;
        }

        svc.isEnabled = function() {
            return !disabled;
        }

        function zoneId() {
            return $stateParams.zoneId ? $stateParams.zoneId : "";
        }

        function projectKey() {
            return $stateParams.projectKey;
        }

        function zoomCtxKey() { // the key to access the zoomCtx in local storage
            return lsKeyPrefix + projectKey() + zoneId();
        }

        /*
            * currentCtx management: loading it from local storage / cleaning it...
            */

        /**
         * Load in current context (ie: global variables) the zoomContext stored in localstorage.
         * Loading won't occur if we already have a current context matching the current project key and that have a focusItem, unless it is forced.
         */
        function ensureZoomCtxLoaded () {
            let isProjectContextLoaded = function() {
                return zoomCtxKey()==zoomCtxKeyLoaded;
            };

            let isFocusItemCtxSet = function() {
                return (currentCtx.focusItem && currentCtx.focusItem.id && currentCtx.focusItem.projectKey==projectKey())
            };

            let timeToCheckLocalStorageUsage = function() {
                // Date.now returns millseconds.
                // ( date % 5 == 0) is effectively "we check about once in 5 times"
                return Date.now() % 5 == 0;
            };

            // reload zoom context from local storage e.g on reload of the flow view
            if (isProjectContextLoaded() && isFocusItemCtxSet()) return;

            clearContext();
            const restored = localStorageService.get(zoomCtxKey());

            if (restored && restored.panzoom) {
                zoomCtxKeyLoaded = zoomCtxKey();
                currentCtx.focusItem = restored.focusItem ? restored.focusItem : {};
                currentCtx.nodeCount = restored.nodeCount ? restored.nodeCount : 0;

                if (svc.isValidPanZoom(restored.panzoom)) {
                    angular.copy(restored.panzoom, currentCtx.panzoom);
                } else {
                    currentCtx.panzoom = {};
                }

                currentCtx.foldState = restored.foldState || [];
            }
            if (timeToCheckLocalStorageUsage()) $timeout(() => tidyLocalStorage(), 2000);
        };

        const blankCtx = {
            focusItem: {},
            nodeCount: 0,
            panzoom: {},
            foldState: []
        }

        function clearContext() {
            zoomCtxKeyLoaded = "";
            angular.copy(blankCtx, currentCtx);
        }

        /*
            * Local storage management: saving, cleaning...
            */

        /**
         * Save the currentCtx to localstorage under the key of 'zoomKey'.
         */
        function setLocalStorage(zoomKey) {
            if (projectKey() == undefined || zoomKey !== zoomCtxKey() || currentCtx.isSaving) {
                // Cancel save in case we force a save but a lazy is pending
                // or when the key are not the same
                return;
            }
            currentCtx.modified = Date.now();
            localStorageService.set(zoomKey, currentCtx);
        }

        /**
         * Set current context's panzoom
         * @param pz
         */
        function setPanzoom(pz) {
            const pzToSave = {};
            ['x', 'y', 'height', 'width'].forEach((f) => pzToSave[f] = pz[f]);
            currentCtx.panzoom = angular.copy(pzToSave);
        }

        /**
         * Save panzoom context immediately to local storage
         * @param pz
         */
        svc.instantSavePanZoomCtx = function(pz) {
            if (disabled === true) {
                return;
            }
            setPanzoom(pz);
            setLocalStorage(zoomCtxKey());
        };

        /**
         * Save the zoom context in local storage, but since this can get called very rapidly when zooming and panning, we make sure we don't write on local storage more than once every second.
         * @param pz
         */
        svc.lazySaveZoomCtx = function(pz) {

            if (disabled === true) {
                return;
            }
            // save the zoom context, but since this can get called v rapidly when zooming and panning,
            setPanzoom(pz);

            if (!currentCtx.isSaving) {
                currentCtx.isSaving = true;
                const zoomKey = zoomCtxKey();
                $timeout (() => {
                    delete currentCtx.isSaving;
                    setLocalStorage(zoomKey);
                }, 1000);
            }
        };

        /**
         * Remove oldest zoomCtxes if we've stored too many of them.
         */
        function tidyLocalStorage() {
            // We allow the number of stored keys to vary between numLsKeysToKeep and maxNumLsKeysAllowed
            // to avoid purging everytime we open a project.  Unclear if this is worthwhile perf saving.
            const numLsKeysToKeep = 10; // number of context entries in localstorage we will keep on purge
            const maxNumLsKeysAllowed = 15; // number of context entries that will trigger a purge.

            let getLsDateModified = function (key) {
                return new Date(localStorageService.get(key).modified);
            }

            const keys = localStorageService.keys().filter((k) => k.startsWith(lsKeyPrefix))

            if (keys.length > maxNumLsKeysAllowed) {
                keys.sort((a,b) => {
                        const aDate = getLsDateModified(a);
                        const bDate = getLsDateModified(b);
                        return aDate > bDate ? -1 : aDate < bDate ? 1 : 0;
                    }
                );

                const keysToDelete = keys.splice(numLsKeysToKeep);
                keysToDelete.forEach((k) => localStorageService.remove(k));
            };

        }

        function updateFoldStateList(foldStateList, foldCmd) {
            const listLen = foldStateList.length;
            let foundFirstFold = false;

            if (foldCmd.action == 'unfold') {
                foldStateList = foldStateList.filter(oldCmd => {
                    //Any unfold commands before a fold are meaningless
                    if (!foundFirstFold) {
                        foundFirstFold = (oldCmd.action == 'fold')
                        if (!foundFirstFold) return false;
                    }
                    // filter out previous fold/unfolds on this node
                    return oldCmd.nodeId != foldCmd.nodeId || oldCmd.direction != foldCmd.direction;
                });
            }

            if (listLen == foldStateList.length) {
                foldStateList.push(foldCmd);
            }

            return foldStateList;
        }

        /*
            * Setters: persisting panzoom ctx elements...
            */

        /**
         * Set current context's focusItem and save it on local storage
         * @param node
         */
        svc.setFocusItemCtx = function(node, nodeChangedByName = false) {

            if (disabled === true) {
                return;
            }

            currentCtx.focusItem = {
                id: node.id,
                nodeChangedByName,
                projectKey: projectKey()
            };
            ensureZoomCtxLoaded();
            setLocalStorage(zoomCtxKey());
        };

        svc.resetFocusItemCtx = function() {
            currentCtx.focusItem = {};
            setLocalStorage(zoomCtxKey());
        };


        /**
         * Set current context's focusItem based on a type and a fullname and save it on local storage
         * (A generalised version of setFocusItemByName which supports foreign datasets, which have a different project key)
         * @param type: node type (recipe, dataset, etc.)
         * @param fullName: node full name (it includes project's key)
         */
        svc.setFocusItemByFullName = function (type, fullName) {

            if (disabled === true) {
                return;
            }
            // A generalised version of setFocusItemByName. It supports foreign datasets,
            // which have a different project key.
            if (!fullName) return;
            ensureZoomCtxLoaded();

            currentCtx.focusItem.id = graphVizEscape(type + "_" + fullName);
            currentCtx.focusItem.nodeChangedByName = true;

            setLocalStorage(zoomCtxKey());
        };

        /**
         * Set current context's focusItem based on a type and a name and save it on local storage
         * Called from various controllers (e.g. dataset/recipe editors) to update the flow item that is will be selected when the flow is next redisplayed.
         * @param type: node type (recipe, dataset, etc.)
         * @param name: node name
         */
        svc.setFocusItemByName = function (type, name) {

            if (disabled === true) {
                return;
            }
            let isIncludeProjRefInNodeId = function(type) {
                return type != "recipe"; //recipes have a slightly different SVG element id format in the flow
            }

            if (!name) return;
            const proj = isIncludeProjRefInNodeId(type) ? projectKey() + "." : "";
            svc.setFocusItemByFullName(type, proj + name);
        };

        svc.setFlowRedrawn = function (newNodeCount) {
            currentCtx.focusItem.nodeChangedByName = false;
            currentCtx.nodeCount = newNodeCount;
        };

        /**
         * Set fold/unfold request
         * Called when the user folds or unfolds a node.  The
         * active fold state is saved so it can be restored when the
         * view is refreshed.
         * On unfold we remove existing 'redundant' commands from the list.
         */
        svc.setFoldCommand = function (foldCmd) {
            currentCtx.foldState = updateFoldStateList(currentCtx.foldState, foldCmd)
            setLocalStorage(zoomCtxKey());
        };

        svc.resetFoldState = function(commands) {
            currentCtx.foldState = commands || [];
            setLocalStorage(zoomCtxKey());
        }

        svc.removeLastFoldCommand = function () {
            currentCtx.foldState.pop();
            setLocalStorage(zoomCtxKey());
        }

        /*
            * Getters: retrieving panzoom ctx elements
            */

        /**
         * Load panzoom ctx that we stored in activePz passed in parameter
         * @param activePz - the current $scope.panZoom.  This is updated not replaced, to avoid any knock on effects
         *                   in the existing graph-handling software
         * @param defaultPz - a panZoom structure with default settings i.e. show the whole flow
         * @returns true if replacement occured, false otherwise (in the case there's no current context's panzoom)
         */
        svc.restoreZoomCtx = function(activePz, defaultPz) {

            if (disabled === true) {
                return;
            }
            ensureZoomCtxLoaded();

            if (svc.isValidPanZoom(currentCtx.panzoom) && activePz && defaultPz) {
                angular.copy(defaultPz, activePz); //copy defaultPz in activePz
                angular.extend (activePz, currentCtx.panzoom); //extend activePz with currentCtx.panzoom
                return true;
            }
            return false;
        };

        /**
         * Returns current context focusItem id (or empty string if this item is not contained in the flowGraph passed in parameter)
         * @param flowGraph to validate current context focusItem's id with
         * @returns current context focusItem's id (or empty string if this item is not contained in the flowGraph passed in parameter)
         */

        svc.getSafeFocusItemId = function (flowGraph) {

            if (disabled === true) {
                return;
            }
            if (flowGraph && currentCtx.focusItem && currentCtx.focusItem.id) {
                if (!flowGraph.node(currentCtx.focusItem.id)) {
                    // focus item may have been added by name without taking in account the zones
                    // try to find it
                    if (currentCtx.focusItem.nodeChangedByName) {
                        currentCtx.focusItem.id = svc.getZoomedName(flowGraph, currentCtx.focusItem.id);
                    }
                    if (!flowGraph.node(currentCtx.focusItem.id)) {
                        currentCtx.focusItem.id = "";
                    }
                }
            }
            return currentCtx.focusItem ? currentCtx.focusItem.id : "";
        };

        /**
         * Returns the id with the correct zone if we are not in a zone
         * In case we are in zone, return the id
         */
        svc.getZoomedName = (flowGraph, id) => {
            if (!id || id.startsWith("zone_")) {
                return id;
            }
            const graph = flowGraph.get();
            if (!graph.hasZones && !$stateParams.zoneId) {
                return id;
            }
            const sharedBetweenZones = graph.zonesUsedByRealId[id];
            if (sharedBetweenZones) {
                const node = flowGraph.node(graphVizEscape(`zone_${sharedBetweenZones[0]}_`) + id);
                if (node && flowGraph.node(graphVizEscape(`zone_${node.ownerZone}_`) + id)) {
                    return graphVizEscape(`zone_${node.ownerZone}_`) + id;
                }
            }
            const foundName = Object.keys(graph.nodes).find(it => it.endsWith(id));
            if (foundName) {
                return foundName;
            }
            return id;
        }

        svc.getNodeCount = function() {
            return currentCtx.nodeCount;
        };

        function isValidDimension(d) {
            return angular.isDefined(d) && isFinite(d) && d > 0;
        }
        svc.isValidPanZoom = function(pz) {
            return isValidDimension(pz.width) && isValidDimension(pz.height);
        };

        svc.wasNodeChangedOutsideFlow = function() {
            return !!currentCtx.focusItem.nodeChangedByName;
        };

        svc.getFoldState = function() {
            return currentCtx.foldState;
        }

        svc.getPreviewFoldState = function(foldCmd) {
            const previewFoldState =  angular.copy(currentCtx.foldState);
            return updateFoldStateList(previewFoldState, foldCmd)
        }

    });


    app.filter("recipeFlowIcon", function() {
        const dict = {
            'sync': 'recipe_sync',
            'shaker': 'recipe_prepare',
            'update': 'recipe_push_to_editable',
            'sampling': 'recipe_filter',
            'grouping': 'recipe_group',
            'distinct': 'recipe_distinct',
            'split': 'recipe_split',
            'topn': 'recipe_topn',
            'sort': 'recipe_sort',
            'vstack': 'recipe_stack',
            'join': 'recipe_join',
            'fuzzyjoin': 'recipe_fuzzyjoin',
            'window': 'recipe_window',
            'export': 'recipe_export',
            'pivot' : "recipe_pivot",
            'download': 'recipe_download',
            'merge_folder': 'recipe_merge_folder',

            'sql_script': 'recipe_sql',
            'sql_query': 'recipe_sql',

            'python': 'recipe_python',
            'julia': 'recipe_julia',
            'r': 'recipe_R',
            'shell': 'recipe_shell',

            'pig': 'recipe_pig',
            'hive': 'recipe_hive',
            'impala': 'recipe_impala',

            'pyspark': 'recipe_pyspark',
            'sparkr': 'recipe_sparkr',
            'spark_scala': 'recipe_spark_scala',
            'spark_sql_query': 'recipe_spark_sql',

            'clustering_cluster': 'recipe_cluster',
            'clustering_training': 'recipe_train',
            'clustering_scoring': 'recipe_score',
            'prediction_training': 'recipe_train',
            'prediction_scoring': 'recipe_score',
            'evaluation': 'recipe_evaluation',
            'standalone_evaluation': 'recipe_standalone_evaluation',

            'csync': 'recipe_sync',
            'streaming_spark_scala': 'recipe_spark_scala',
            'cpython': 'recipe_python',
            'ksql': 'recipe_ksql'
        };
        return function(input) {
            if (input.startsWith('CustomCode_') || input.startsWith("App_")) {
                return 'recipe_empty'
            }
            return dict[input] || 'icon-'+(input||'').toLowerCase();
        };
    });


    app.directive('flowCommon', function($state, $stateParams, $rootScope, FlowGraphSelection, FlowGraph, GraphZoomTrackerService) {
        return {
            restrict: 'EA',
            scope: true,
            link : function(scope, element) {

                function setRightColumnItem() {
                    // This is a quick and dirty hack to keep compatibility with old
                    // right columns that handle only one element at a time
                    scope.rightColumnSelection = FlowGraphSelection.getSelectedNodes();
                    if (scope.rightColumnSelection.length == 0) {
                        scope.rightColumnItem = null;
                        if ($stateParams.zoneId) {
                            const node = FlowGraph.node(`zone_${$stateParams.zoneId}`);
                            if (node) {
                                scope.rightColumnItem = node;
                                scope.rightColumnSelection = [node];
                                GraphZoomTrackerService.setFocusItemCtx(node);
                            }
                        }
                    } else if (scope.rightColumnSelection.length == 1) {
                        scope.rightColumnItem = scope.rightColumnSelection[0];
                    } else {
                        scope.rightColumnItem = {
                            nodeType: 'MULTI',
                            selection: scope.rightColumnSelection
                        };
                    }
                }

                scope.focusLast = function(){
                    if (scope.previousRightColumnItemId) {
                        FlowGraphSelection.clearSelection();
                        scope.zoomGraph(scope.previousRightColumnItemId);
                        FlowGraphSelection.onItemClick(scope.previousRightColumnItemId);
                    }
                };

                const h = $rootScope.$on('flowSelectionUpdated', setRightColumnItem);
                scope.$on('$destroy', h);
            }
        }
    });


    // Main directive for all graphs (project flow, global graph, job graph)
    app.directive('flowGraph', function($rootScope, $timeout, $stateParams, Logger, $state,
                                    FlowGraph, ProjectFlowGraphStyling, InterProjectGraphStyling, ProjectFlowGraphLayout,
                                    InterProjectGraphLayout, FlowGraphFiltering, FlowGraphSelection, FlowGraphFolding, GraphZoomTrackerService) {
    return {
        restrict: 'EA',
        controller: function ($scope, $element, $attrs) {
            $scope.FlowGraph = FlowGraph;//debug
            // Enable Zoom tracking
            GraphZoomTrackerService.disable(false);
            let nextResizeEnabled = true;

            function disableNextResize(disabled = true) {
                nextResizeEnabled = disabled === false;
            }

            $scope.$on('disableNextFlowResize', disableNextResize);

            $scope.setGraphData = function (serializedGraph) {
                if (serializedGraph) {
                    $scope.nodesGraph = serializedGraph;
                    FlowGraph.set($scope.nodesGraph);

                    $scope.nodesGraph.filteredOutElementCount = Object.values(serializedGraph.filteredOutObjectsByType).reduce((a, b) => a + b, 0);
                    $scope.nodesGraph.nodesOnGraphCount = Object.keys(serializedGraph.nodes).filter(it => $stateParams.zoneId ? it.startsWith(`zone__${$stateParams.zoneId}`) : true).length; //if zoomed on a zone we need the zone node for the color, but not in the filter count
                    const displayedElementCount = Object.values(serializedGraph.includedObjectsByType).reduce((a,b)=>a+b, 0);
                    $scope.isFlowEmpty = (($scope.nodesGraph.filteredOutElementCount || 0) + displayedElementCount === 0) && !serializedGraph.hasZoneSharedObjects;
                    $scope.allFilteredOut = !$scope.isFlowEmpty && $scope.nodesGraph.nodesOnGraphCount === 0;
                }
            };
            function setupZoomBehavior() {
                // The scope.panZoom structure controls:
                // - the position of the flow on the screen, via  SVG coords x,y
                // - How zoomed in it is, via SVG dimensions width, height
                // - How far out you can zoom, via maxWidth, maxHeight, SVG dimensions
                //
                // The size of the HTML container element in HTML coords is held in WIDTH and HEIGHT
                // x, y, width, height are used directly as the SVG viewBox settings.
                $scope.panzoom = {
                    x: 0,
                    y: 0,
                    width: undefined,
                    height: undefined,
                    maxWidth: undefined,
                    maxHeight: undefined,
                    WIDTH: $element.width(),
                    HEIGHT: $element.height()
                };

                let h;

                const resizeStrategies = {
                    reinit : "reinit", // don't use any saved settings, redisplay whole flow
                    usePanZoom : "zoom", // use the saved zoom context, but don't smart-adjust the positioning at all
                    zoomToFocusItem : "item", // use the saved zoom contrext, but adjust centring for a 'nice fit'
                    highlight : "highlight" // resize around the highlighted nodes
                };

                const smallFlowNodeCount = 10; // any flow less than 10 nodes can be displayed in full everytime.

                /**
                 * Return the set strategy if some, or calculate the best strategy for restoring the saved zoom and focused item. We want as natural
                 * an experience as possible.  If the user hasn't changed anything, we try to restore the flow layout
                 * exactly as it was before - they presumably set it that way!  If they have added/deleted/navigated
                 * then we need to adjust layout so they can see the last item they navigated to.
                 *
                 * @param currentNodeCount - the current number of nodes in the flow
                 * @returns the resize strateegy
                 */
                function getResizeStrategy(currentNodeCount) {
                    let strategy = resizeStrategies.reinit;

                    if ($scope.strategy) {
                        strategy = $scope.strategy;
                    } else {
                        if ($rootScope.appConfig.userSettings.disableFlowZoomTracking || !currentNodeCount) {
                            return strategy;
                        }

                        if (GraphZoomTrackerService.isValidPanZoom($scope.panzoom)) {
                            const focusItemId = GraphZoomTrackerService.getSafeFocusItemId($scope.FlowGraph);
                            if (focusItemId && $scope.FlowGraph.node(focusItemId) && GraphZoomTrackerService.wasNodeChangedOutsideFlow()) {
                                strategy = resizeStrategies.zoomToFocusItem;
                            } else {
                                strategy = resizeStrategies.usePanZoom;
                            }
                        }

                        const previousNodeCount = GraphZoomTrackerService.getNodeCount()
                        if (currentNodeCount <= smallFlowNodeCount && currentNodeCount != previousNodeCount) { //small flows with a flow change
                            strategy = resizeStrategies.reinit; // with small flows, always snap back to the full flow
                        }
                    }
                    return strategy;
                }

                function setResizeStrategy(scope, strategy='reinit') {
                    if (strategy && resizeStrategies[strategy]) {
                        $scope.strategy = resizeStrategies[strategy];
                    }
                }

                $scope.$on('setResizeStrategy', setResizeStrategy);

                /**
                 * Calculate how close the bounding box for an item is to the edge of the viewable area, as
                 * a fraction of the total size of the view.  This function does the calculation for a
                 * specified dimension i.e. the X or Y axis.
                 *
                 * @param bbItem - the bound box of one item in the viewable area (the one we want to set focus to)
                 * @param bbFlow - the bounding box of the whole flow
                 * @param dimension  'x' for the horizontal dimension, 'y' for vertical
                 * @param viewBoxLength - the viewable size of the SVG window in the specified dimension
                 * @returns the fraction of the total size from the edge.  For example 0.5 means we are in the middle
                 */
                function getFractionalDistOfItemToEdge(bbItem, bbFlow, dimension, viewBoxLength) {

                    const length = dimension=='x' ? 'width' : 'height';
                    const start = dimension; // x or y axis

                    let extentOfItem = bbItem[start] + bbItem[length];
                    let extentOfFlow = bbFlow[start] + bbFlow[length];
                    return (extentOfFlow - extentOfItem) /  viewBoxLength;
                }

                /**
                 * We need the .width / .height aspect ratio for the SVG viewbox to match the
                 * aspect ratio of the containing HTML element, otherwise we get inaccuracies when
                 * we try to drag the whole flow around.
                 * @param pz - the pan zoom to be normalised
                 * returns - the same pan zoom, normalised
                 */
                function normaliseAspectRatio(pz) {
                    const viewBoxAR = pz.width / pz.height;
                    const elementAR = pz.WIDTH / pz.HEIGHT;
                    if (viewBoxAR!=elementAR) {
                        pz.width = pz.height * elementAR; // not sure we need to worry about which way round we adjust AR
                    }
                    return pz;
                }

                function resize(forcedReinit) {
                    let zoomTrackingEnabled = GraphZoomTrackerService.isEnabled();
                    if ($scope.isFlowEmpty || $scope.allFilteredOut || !$scope.svg || !$scope.svg.length) {
                        return false;
                    }

                    $scope.panzoom.WIDTH = $element.width();
                    $scope.panzoom.HEIGHT = $element.height();

                    const bbFlow = $scope.svg.find('g.graph')[0].getBBox(); //get the whole-flow bounding box
                    const defaultPz = buildDefaultPanZoomSettings($scope.panzoom, bbFlow);
                    let pz = $scope.panzoom;
                    if (!GraphZoomTrackerService.isValidPanZoom($scope.panzoom)) {
                        pz = angular.copy(defaultPz);
                    }
                    let isReloadedZoomCtx;
                    if (zoomTrackingEnabled) {
                        isReloadedZoomCtx = (GraphZoomTrackerService.restoreZoomCtx(pz, defaultPz));
                    }

                    $scope.setPanZoom(normaliseAspectRatio(pz));

                    const nodeCount = $scope.FlowGraph.nodeCount();
                    let strategy = getResizeStrategy(nodeCount);
                    let nodeIdToFocus = GraphZoomTrackerService.getSafeFocusItemId($scope.FlowGraph);

                    if (forcedReinit === true) {
                        strategy = resizeStrategies.reinit;
                        nodeIdToFocus = undefined;
                        FlowGraphFolding.clearFoldState();
                        FlowGraph.setGraphBBox(bbFlow);
                    }

                    if (strategy == resizeStrategies.usePanZoom) { // we have saved viewbox setting ie zoom level and positioning.  Reuse these
                        if (isReloadedZoomCtx) $scope.redraw();
                        // SVG will rescale quite nicely by itself with changes in Window size
                    }
                    else if (strategy == resizeStrategies.zoomToFocusItem) { // position this last-used item in the centre of the screen
                        const wPrev = $scope.panzoom.width;
                        const hPrev = $scope.panzoom.height;
                        const node = $scope.nodesGraph.nodes[nodeIdToFocus];
                        const selector = $scope.getSelector(nodeIdToFocus, node);
                        let bb = FlowGraphFiltering.getBBoxFromSelector($scope.svg, selector); //get the focussed-item box

                        let xPosInCell = 0.5; // the middle of the viewable area
                        let yPosInCell = 0.5;

                        const centerOnItemX = bbFlow.width > wPrev; // do we want to try to center the item, or does the whole flow fits in this dimension?
                        const centerOnItemY = bbFlow.height > hPrev;

                        let boxToCentreForX = centerOnItemX ? bb: bbFlow;
                        let boxToCentreForY = centerOnItemY ? bb : bbFlow;

                        if (centerOnItemX) {
                            // we are centring the item in the width of the viewport.
                            // By default we put it in the middle, but if it's near the edges, we adjust it a bit with heuristically developed numbers ;-)
                            const edgeFraction = getFractionalDistOfItemToEdge(bb, bbFlow, "x", wPrev);
                            if (edgeFraction < 0.25) xPosInCell = 0.8 - edgeFraction; // near right hand edge

                            if ((bb.x - bbFlow.x) / wPrev < 0.25)  xPosInCell = 0.25; // near left hand edge
                        }

                        if (centerOnItemY) {
                            // we are centring the item in the height of the item.
                            const edgeFraction = getFractionalDistOfItemToEdge(bb, bbFlow, "y", hPrev) ;
                            if (edgeFraction < 0.2) yPosInCell = 0.8 - edgeFraction;

                            if ((bb.y - bbFlow.y) / hPrev < 0.25) yPosInCell = 0.25;
                        }

                        $scope.panzoom.x = boxToCentreForX.x + boxToCentreForX.width * xPosInCell - wPrev * xPosInCell; //centre the view
                        $scope.panzoom.y = boxToCentreForY.y + boxToCentreForY.height * yPosInCell -hPrev * yPosInCell;
                        $scope.panzoom.height = hPrev; //keep same zoom level as before
                        $scope.panzoom.width = wPrev;

                        $scope.redraw();
                    } else if (strategy === resizeStrategies.highlight) {
                        // Zoom on highlighted nodes
                        let bbox = FlowGraphFiltering.getBBoxFromSelector($scope.svg, '.highlight');
                        $scope.zoomToBbox(bbox);
                    } else { // refit the whole flow.  May have focus item
                        $scope.setPanZoom(defaultPz);

                        let paddingFactor = 1.2;
                        if (nodeCount) paddingFactor += (smallFlowNodeCount-Math.min(nodeCount, smallFlowNodeCount)) * 0.08; // more padding when there are fewer items in the flow.
                        zoomTo(paddingFactor);
                    }

                    // if nodeIdToFocus is set, we want to select this node in the flow. The existing technique for this is
                    // to call FlowGraphSelection.onItemClick. However we need to force the existing FlowGraph data
                    // structure to load the current set of node ids before this will work.
                    if (nodeIdToFocus) {
                        FlowGraph.indexNodesCoordinates($scope.svg, bbFlow);
                        FlowGraphSelection.onItemClick($scope.FlowGraph.node(nodeIdToFocus));
                        applyFlowFolding();
                    } else {
                        h && clearTimeout(h);
                        h = setTimeout(function() {
                            FlowGraph.indexNodesCoordinates($scope.svg, bbFlow);
                            applyFlowFolding();
                        }, 500);
                    }

                    zoomTrackingEnabled === true && GraphZoomTrackerService.setFlowRedrawn(nodeCount);

                    return true;
                }
                function applyFlowFolding() {
                    if ($attrs.showFolding) FlowGraphFolding.restoreState(GraphZoomTrackerService.getFoldState());
                }
                function resizeListener() {
                    resize();
                    if (!$scope.$$phase) {
                        $scope.$apply();
                    }
                }
                $(window).on('resize', resizeListener);
                $scope.$on('$destroy', param => {
                    if (!param.currentScope.projectFlow || !(param.currentScope.nodesGraph && param.currentScope.nodesGraph.hasZones || param.currentScope.zoneIdLoaded)) {
                        GraphZoomTrackerService.instantSavePanZoomCtx($scope.panzoom);
                    }
                    $(window).off('resize', resizeListener)
                });
                $scope.$on('resizePane', resize);
                $scope.$watch('svg', function() {
                    // Wait for the svg to be totally rendered before updating the view (we need to make computation based on bbox)
                    // If the resize has been temporarily disabled, re-enable it.
                    if (nextResizeEnabled) {
                        setTimeout(function() {
                            if (resize($scope.isResetZoomNeeded)) $rootScope.$emit('flowDisplayUpdated');
                            $scope.isResetZoomNeeded = false;
                        });
                    } else {
                        nextResizeEnabled = true;
                    }
                });

                function keepPanZoomDimSane(pz, bbflow, start, length, nearFraction) {
                    if (pz[start] + (1-nearFraction)*pz[length] < bbflow[start]) { //rhs
                        pz[start] = (nearFraction-1)*pz[length] + bbflow[start];
                    }
                    if (bbflow[length] + bbflow[start] < pz[start] + nearFraction * pz[length]) { // lhs
                        pz[start] = (bbflow[start] + bbflow[length] - nearFraction*pz[length]);
                    }
                    return pz;
                }

                function keepPanZoomSane(pz) { //prevent flow being pushed out of view
                    const bbFlow = $scope.svg.find('g.graph')[0].getBBox();
                    pz = keepPanZoomDimSane(pz, bbFlow, "x", "width", 0.3);
                    pz = keepPanZoomDimSane(pz, bbFlow, "y", "height", 0.4);
                    return pz;
                }

                $scope.redraw = function () {
                    if ($scope.svg && $scope.svg.length) {
                        $scope.panzoom = keepPanZoomSane($scope.panzoom);
                        GraphZoomTrackerService.lazySaveZoomCtx($scope.panzoom);
                        $scope.svg[0].setAttribute('viewBox', [
                            $scope.panzoom.x,
                            $scope.panzoom.y,
                            $scope.panzoom.width,
                            $scope.panzoom.height
                        ].join(', '));
                    }
                };

                $scope.getPanZoom = function() {
                    return angular.copy($scope.panzoom);
                };

                $scope.setPanZoom = function(panzoom) {
                    $scope.panzoom = angular.copy(panzoom);
                    $scope.redraw();
                };

                $scope.bbox = function(bbox) {
                    $scope.panzoom.x = bbox.x;
                    $scope.panzoom.y = bbox.y;

                    if (bbox.width / bbox.height > $scope.panzoom.WIDTH / $scope.panzoom.HEIGHT) {
                        $scope.panzoom.width = bbox.width;
                        $scope.panzoom.height = bbox.width * ($scope.panzoom.HEIGHT / $scope.panzoom.WIDTH);
                        $scope.panzoom.y = bbox.y - ($scope.panzoom.height - bbox.height) / 2;
                    } else {
                        $scope.panzoom.width = bbox.height * ($scope.panzoom.WIDTH / $scope.panzoom.HEIGHT);
                        $scope.panzoom.height = bbox.height;
                        $scope.panzoom.x = bbox.x - ($scope.panzoom.width - bbox.width) / 2;
                    }

                    $scope.redraw();
                };
                // Safari, Chrome, Opera, IE
                const WHEEL_ZOOM_STEP = 1.1;
                $element.on('mousewheel', function (e) {
                    let scale = 1;
                    if (e.originalEvent.wheelDeltaY != 0) {
                        scale = e.originalEvent.wheelDeltaY < 0 ? WHEEL_ZOOM_STEP : 1 / WHEEL_ZOOM_STEP;
                    }
                    const eOrig = e.originalEvent && angular.isDefined(e.originalEvent.layerX) ? e.originalEvent : undefined;
                    zoomTo(scale, eOrig ? eOrig.layerX : e.offsetX, eOrig ? eOrig.layerY : e.offsetY);
                    e.stopPropagation();
                    e.preventDefault();
                });

                Mousetrap.bind("Z R", () => $scope.resizeToShowAll());
                Mousetrap.bind("Z A", () => $scope.resizeToShowAll());

                $scope.reinitGraph = () => { resize(true); };

                $scope.$on("$destroy", _ => {
                    Mousetrap.unbind("Z R");
                    Mousetrap.unbind("Z A");
                });

                $scope.zoomIn = () => {
                    zoomTo(1 / WHEEL_ZOOM_STEP, $scope.panzoom.WIDTH / 2, $scope.panzoom.HEIGHT / 2);
                }

                $scope.zoomOut = () => {
                    zoomTo(WHEEL_ZOOM_STEP, $scope.panzoom.WIDTH / 2, $scope.panzoom.HEIGHT / 2);
                }

                $scope.resizeToShowAll = () => {
                    $scope.resetPanZoom();
                    $rootScope.$emit('drawGraph', {ignoreCache:true}, true);
                    FlowGraphSelection.refreshStyle(true);
                }

                $scope.resetPanZoom = function () {
                    $scope.isResetZoomNeeded = true;
                }

                // Touchable devices
                if (isTouchDevice()) {
                    let onTouchStart = (function() {
                        let previousPinchDistance;

                        /*
                            * Utils
                            */

                        function computePinchDistance(e) {
                            let t1 = e.originalEvent.touches[0];
                            let t2 = e.originalEvent.touches[1];
                            let distance = Math.sqrt(Math.pow(Math.max(t1.screenX, t2.screenX) - Math.min(t1.screenX, t2.screenX), 2) + Math.pow(Math.max(t1.screenY, t2.screenY) - Math.min(t1.screenY, t2.screenY), 2));
                            return distance;
                        }

                        function computePinchMiddle(e) {
                            let t1 = e.originalEvent.touches[0];
                            let t2 = e.originalEvent.touches[1];
                            let offset = $($element).offset();
                            // point of contact 1
                            let c1 = {
                                x: t1.pageX - offset.left,
                                y: t1.pageY - offset.top
                            };
                            // point of contact 2
                            let c2 = {
                                x: t2.pageX - offset.left,
                                y: t2.pageY - offset.top
                            };
                            // middle
                            let middle = {
                                x: (c1.x + c2.x)/2,
                                y: (c1.y + c2.y)/2
                            };
                            return middle;
                        }

                        /*
                            * Callbacks
                            */

                        function onTouchMove(e) {
                            e.stopPropagation();
                            e.preventDefault();
                            let distance = computePinchDistance(e);
                            if (!isNaN(previousPinchDistance)) {
                                let scale = previousPinchDistance / distance;
                                let middle = computePinchMiddle(e);
                                requestAnimationFrame(_ =>zoomTo(scale, middle.x, middle.y));
                            }
                            previousPinchDistance = distance;
                        }

                        function onTouchEnd(e) {
                            $element.off('touchmove', onTouchMove);
                            $element.off('touchend', onTouchEnd);
                            e.stopPropagation();
                            e.preventDefault();
                        }

                        return function(e){
                            e.stopPropagation();
                            e.preventDefault();
                            if (e.originalEvent.targetTouches.length !== 2) {
                                return;
                            }

                            previousPinchDistance = computePinchDistance(e);

                            $element.on('touchmove', onTouchMove);
                            $element.on('touchend', onTouchEnd);
                        }
                    })();

                    $element.on('touchstart', onTouchStart);
                }

                // Firefox
                $element.on('DOMMouseScroll', function (e) {
                    const scale = e.originalEvent.detail > 0 ? WHEEL_ZOOM_STEP : 1 / WHEEL_ZOOM_STEP;
                    const coordinates = mouseViewportCoordinates(e);
                    zoomTo(scale, coordinates.x, coordinates.y);
                    e.stopPropagation();
                });
                function zoomTo(scale, x, y) {
                    if (scale < 1 && $scope.panzoom.width && $scope.panzoom.width <= 150) {
                        return; // cannot zoom infinitely
                    }
                    if(scale > 1 && $scope.panzoom.width * scale > $scope.panzoom.maxWidth*2) {
                        return; // cannot dezoom infinitely
                    }
                    if (angular.isUndefined(x)) {
                        x = $scope.panzoom.WIDTH / 2;
                    }
                    if (angular.isUndefined(y)) {
                        const menuH = $('#flow-editor-page .menu').height();
                        y = ($scope.panzoom.HEIGHT - menuH) / 2 + menuH;
                    }

                    $scope.panzoom.x = $scope.panzoom.x + (x / $scope.panzoom.WIDTH) * $scope.panzoom.width * (1 - scale);
                    $scope.panzoom.y = $scope.panzoom.y + (y / $scope.panzoom.HEIGHT) * $scope.panzoom.height * (1 - scale);

                    $scope.panzoom.width = $scope.panzoom.width * scale;
                    $scope.panzoom.height = $scope.panzoom.height * scale;

                    $scope.redraw();
                }
            }

            let original_coordinates;
            let original_graph_coordinates;
            let original_click;

            function getEventWithCoordinates(evt) {
                return angular.isUndefined(evt.originalEvent.changedTouches) ? evt.originalEvent : evt.originalEvent.changedTouches[0];
            }

            /* offsetX and offsetY are not really supported in Firefox. They used to be undefined, but May'18 and they are returning 0.
                It's not clear if this was always the case, but this getOffsetXY function implemented the broadly excepted
                substitute calculation.  Clearly userAgent test is not a great solution, but leaving the Chrome solution
                in place seems safer and more efficient.
                */
            const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
            function getOffsetXY(e) {
                let offsets;

                if (isFirefox || angular.isUndefined(e.offsetX)) { // having problem with offsetX as zero, not undefined, on firefox
                    const target = e.target || e.srcElement;
                    const rect = target.getBoundingClientRect();
                    offsets = { x:   e.clientX - rect.left, y:  e.clientY - rect.top};
                }
                else {
                    offsets = { x: e.offsetX, y: e.offsetY};
                }
                return offsets;
            }

            /*
            * Gives the coordinates of a mouse event in a coordinate system fixed relative viewport
            */
            function mouseViewportCoordinates(evt) {
                const formattedEvt = getEventWithCoordinates(evt);
                //mjt I have a feeling that the existing if clause and the new getOffsetXY function are
                // trying to do similar things and might be conflatable.  It's not trivial though.
                if (angular.isUndefined(formattedEvt.offsetX) || !$scope.svg || formattedEvt.target != $scope.svg[0]) {
                    const containerOffset = $element.offset();
                    return {
                        x: formattedEvt.pageX - containerOffset.left,
                        y: formattedEvt.pageY - containerOffset.top
                    };
                } else {
                    return getOffsetXY(formattedEvt)
                }
            }
            /*
            * Gives the coordinates of a mouse event in the graph coordinate systems:
            * Ex: if the graph is resized and moved, clicking on one specific item would give the same coordinates
            */
            let pt;

            function mouseGraphCoordinates(evt) {
                let formattedEvt = getEventWithCoordinates(evt);
                pt = pt || $scope.svg[0].createSVGPoint();
                pt.x = formattedEvt.clientX;
                pt.y = formattedEvt.clientY;
                return pt.matrixTransform($scope.svg[0].getScreenCTM().inverse());
            }

            function setupMoveAndSelectBehavior() {
                $scope.rectangleSelection = false;

                function moveView(evt) {
                    if (!original_coordinates) return;
                    const coordinates = mouseViewportCoordinates(evt);
                    $scope.panzoom.x = original_coordinates.x - $scope.panzoom.width * (coordinates.x / $scope.panzoom.WIDTH);
                    $scope.panzoom.y = original_coordinates.y - $scope.panzoom.height * (coordinates.y / $scope.panzoom.HEIGHT);
                    $scope.redraw();
                }

                function getBBoxFromPoints(p1, p2) {
                    return {
                        x: Math.min(p1.x, p2.x),
                        y: Math.min(p1.y, p2.y),
                        width: Math.max(p1.x, p2.x) - Math.min(p1.x, p2.x),
                        height: Math.max(p1.y, p2.y) - Math.min(p1.y, p2.y),
                    };
                }

                function updateSelectionRectangle(evt) {
                    const svg = FlowGraph.getSvg();
                    if (!svg) return;
                    clearSelectionRectangle();

                    const coords = mouseGraphCoordinates(evt);
                    const rect = getBBoxFromPoints(coords, original_graph_coordinates);
                    rect.id = 'flow-selection-rectangle';

                    $(svg).append(makeSVG('rect', rect));
                }

                function clearSelectionRectangle() {
                    const svg = FlowGraph.getSvg();
                    $('#flow-selection-rectangle', svg).remove();
                }

                function commitRectangleSelection(evt) {
                    const coords = mouseGraphCoordinates(evt);
                    const rect = getBBoxFromPoints(coords, original_graph_coordinates);
                    const nodeIds = FlowGraph.getEnclosedNodesIds(rect);
                    FlowGraphSelection.select(node => !node.filterRemove && nodeIds.includes(node.id));
                }

                function clearOriginalCoordinates() {
                    original_coordinates = undefined;
                    clearSelectionRectangle();
                    $('#flow-editor-page .mainPane').removeClass('no-pointer-events');
                }

                function isLassoKeyPressed(evt) {
                    const isNotMac = !$('html').hasClass('macos')
                    return evt.shiftKey || evt.metaKey || (evt.ctrlKey && isNotMac);
                }

                $('body').on('keydown.rectangleSelection', function (e) {
                    if ((isLassoKeyPressed(e)) && $stateParams.projectKey) {
                        $scope.$apply(() => $scope.rectangleSelection = true);
                    }
                }).on('keyup.rectangleSelection', function (e) {
                    if ((!isLassoKeyPressed(e)) && $stateParams.projectKey) {
                        $scope.$apply(() => $scope.rectangleSelection = false);
                    }
                });

                $scope.$on('$destroy', function() {
                    $('body').off('keydown.rectangleSelection').off('keyup.rectangleSelection');
                });

                /**
                 * Return a function taking an event in input and calling the callback passed on parameter only if this event is a mono touch event
                 */
                function monoTouchCallBack(fn) {
                    return function(evt) {
                        if (evt.originalEvent.touches && evt.originalEvent.touches.length == 1) {
                            fn(evt);
                        }
                    }
                }

                let dragStart = (function() {
                    /* in order to avoid lag on big flows, when dragging we apply the move cursor to the item initially clicked, and on each item entered during the drag
                     * it performs better because the bottleneck is the style recalculation, not the javascript event part
                     */
                    const applyMoveCursorSelector = 'svg, svg [class~=node], svg [class~=zone_cluster], svg [class~=folded-icon]';
                    let $applyMoveCursorInitialItem = $element;
                    function applyMoveCursor(evt) {
                        $(evt.target).addClass('moving');
                        $(evt.target).parentsUntil($element).addClass('moving');
                    }
                    function cleanMoveCursor() {
                        $element.find('.moving').removeClass('moving');
                    }

                    /*
                        *  Utils
                        */
                    // Remove listeners on drag release
                    function removeListeners() {
                        $(document).off('mousemove', drag);
                        $element.off('mouseenter', applyMoveCursorSelector, applyMoveCursor);
                        $element.off('mouseup', 'svg [class~=node]', releaseDragOnNode);
                        $element.off('mouseup', 'svg [class~=folded-icon]', releaseDragOnUnfoldButton);
                        $element.off('mouseup', 'svg [class~=zone_cluster]', releaseDragOnZone);
                        $(document).off('mouseup', releaseDrag);

                        if (isTouchDevice()) {
                            $(document).off('touchmove', monoTouchCallBack(drag));
                            $element.off('touchend', 'svg [class~=node]', releaseDragOnNode);
                            $element.off('touchend', 'svg [class~=zone_cluster]', releaseDragOnZone);
                            $element.off('touchend', 'svg [class~=folded-icon]', releaseDragOnUnfoldButton);
                            $(document).off('touchend', releaseDrag);
                        }
                    }

                    /*
                    * Calllbacks
                    */

                    // Ondrag callback
                    function drag(evt) {
                        if (!$scope.svg) {
                            return;
                        }

                        $applyMoveCursorInitialItem.addClass('moving');

                        if (!((isLassoKeyPressed(evt) ) && $stateParams.projectKey) && $scope.rectangleSelection) {
                            //This is an old rectangleSelection that was not cleared
                            clearOriginalCoordinates();
                        }
                        if (!(isLassoKeyPressed(evt) ) && $scope.rectangleSelection) {
                            $scope.$apply(() => $scope.rectangleSelection = false);
                        }
                        if (original_coordinates) {
                            if ($scope.rectangleSelection) {
                                const coordinates = mouseViewportCoordinates(evt);
                                if (original_click && square_distance(coordinates, original_click) > 16) {
                                    // We don't want to immediately add no-pointer-events because cmd+click will not work (1 pixel moves)
                                    $('#flow-editor-page .mainPane').addClass('no-pointer-events');
                                }
                                updateSelectionRectangle(evt);
                            } else {
                                requestAnimationFrame(_ => moveView(evt));
                            }
                        }
                        evt.stopPropagation();
                        if(!$rootScope.$$phase) $scope.$apply();
                    }

                    // Ondragend on node callback
                    function releaseDragOnNode(e) {
                        cleanMoveCursor();
                        if ( e.originalEvent && e.originalEvent.detail == 2 ) {
                            let zoneId = $(this).attr('id');
                            if (!$stateParams.zoneId && zoneId.startsWith('zone_')) {
                                zoneId = zoneId.split('_')[1];
                                $state.go('projects.project.flow', Object.assign({}, $stateParams, { zoneId }));
                            }
                        }
                        const coordinates = mouseViewportCoordinates(e);
                        // travelled distance
                        if (original_click && square_distance(coordinates, original_click) < 16) {
                            // if mouse has moved less than 4px
                            if ((e.which == 1) || (e.which == 2) || (e.type=='touchend')) {
                                const nodeId = $(this).attr('data-id');
                                const node = FlowGraph.node(nodeId);
                                if (node) {
                                    GraphZoomTrackerService.setFocusItemCtx(node);
                                    FlowGraphSelection.onItemClick(node, e);
                                    $scope.$apply();
                                }
                            }
                        }
                        clearOriginalCoordinates();
                        removeListeners();
                        //$scope.$apply();
                        e.stopPropagation();
                    }

                    // Ondragend on unfold callback
                    function releaseDragOnUnfoldButton(e) {
                        cleanMoveCursor();
                        if ( e.originalEvent && e.originalEvent.detail == 2 ) {
                            return; // that's a double click
                        }
                        FlowGraphFolding.unfoldNode(this);


                        clearOriginalCoordinates();
                        removeListeners();
                        e.stopPropagation();
                    }

                    // Ondragend on unfold callback
                    function releaseDragOnZone(e) {
                        cleanMoveCursor();
                         if ( e.originalEvent && e.originalEvent.detail == 2 ) {
                            const zoneId = $(this).attr('id').split('_')[2];
                            $state.go('projects.project.flow', Object.assign({}, $stateParams, { zoneId }));
                            return;
                        }
                        const coordinates = mouseViewportCoordinates(e);
                        // travelled distance
                        if (original_click && square_distance(coordinates, original_click) < 16) {
                            // if mouse has moved less than 4px
                            if ((e.which == 1) || (e.which == 2) || (e.type=='touchend')) {
                                const nodeId = $(this).attr('id').split(/_(.+)/)[1];
                                const node = FlowGraph.node(nodeId);
                                if (node) {
                                    GraphZoomTrackerService.setFocusItemCtx(node);
                                    FlowGraphSelection.onItemClick(node, e);
                                    $scope.$apply();
                                }
                            }
                        }
                        clearOriginalCoordinates();
                        removeListeners();
                        //$scope.$apply();
                        e.stopPropagation();

                    }

                    // Ondragend on something else than a node
                    function releaseDrag(e) {
                        cleanMoveCursor();
                        try {
                            const coordinates = mouseViewportCoordinates(e);
                            if (original_click) {
                                // travelled distance
                                if (square_distance(coordinates, original_click) < 16) {
                                    // if mouse has moved less than 4px
                                    const isTagEditPopoverOpened = $(".tag-edit-popover__popover")[0];
                                    if ((e.which == 1 || e.which == 2 || e.type=='touchend') && !(e.metaKey || e.shiftKey) && !isTagEditPopoverOpened) {
                                        FlowGraphSelection.clearSelection();
                                    }
                                } else if ($scope.rectangleSelection) {
                                    commitRectangleSelection(e);
                                }
                            }
                        } catch (e) {
                            Logger.error(e);
                        }
                        clearOriginalCoordinates();
                        removeListeners();
                        $scope.$apply();
                    }

                    return function(evt) {
                        if (!$scope.svg) {
                            return;
                        }
                        if (evt.which == 1 || evt.type == 'touchstart') {
                            const coordinates = mouseViewportCoordinates(evt);
                            original_coordinates = {
                                x: $scope.panzoom.x + $scope.panzoom.width * (coordinates.x / $scope.panzoom.WIDTH),
                                y: $scope.panzoom.y + $scope.panzoom.height * (coordinates.y / $scope.panzoom.HEIGHT)
                            };
                            original_graph_coordinates = mouseGraphCoordinates(evt);
                            original_click = {
                                x: coordinates.x,
                                y: coordinates.y
                            };
                        }

                        //store the item under the cusror at the beginning of what could be a drag&drop action
                        $applyMoveCursorInitialItem = $(evt.target);

                        $(document).on('mousemove', drag);
                        $element.on('mouseenter', applyMoveCursorSelector, applyMoveCursor);
                        $element.on('mouseup', 'svg [class~=node]', releaseDragOnNode);
                        $element.on('mouseup', 'svg [class~=zone_cluster]', releaseDragOnZone);
                        $element.on('mouseup', 'svg [class~=folded-icon]', releaseDragOnUnfoldButton);

                        $(document).on('mouseup', releaseDrag);

                        if (isTouchDevice()) {
                            $(document).on('touchmove', monoTouchCallBack(drag));
                            $element.on('touchend', 'svg [class~=node]', releaseDragOnNode);
                            $element.on('touchend', 'svg [class~=zone_cluster]', releaseDragOnZone);
                            $element.on('touchend', 'svg [class~=folded-icon]', releaseDragOnUnfoldButton);
                            $(document).on('touchend', releaseDrag);
                        }

                        $scope.$apply();
                    };
                })();

                $element.on('mousedown', dragStart);
                $element.on('touchstart', monoTouchCallBack(dragStart));

                $element.on('dblclick', 'svg [class~=node]', function (e) {
                    const nodeId = $(this).attr('data-id');
                    const node = FlowGraph.node(nodeId);
                    clearOriginalCoordinates();
                    $scope.onItemDblClick(node, e);
                    e.stopPropagation();
                });

                const KEYBOARD_FACTOR = 100;

                $scope.moveLeft = () => {
                    $scope.panzoom.x = $scope.panzoom.x + $scope.panzoom.width / 2 - $scope.panzoom.width * ((($scope.panzoom.WIDTH / 2) + KEYBOARD_FACTOR) / $scope.panzoom.WIDTH);
                    $scope.redraw();
                }

                $scope.moveRight = () => {
                    $scope.panzoom.x = $scope.panzoom.x + $scope.panzoom.width / 2 - $scope.panzoom.width * ((($scope.panzoom.WIDTH / 2) - KEYBOARD_FACTOR) / $scope.panzoom.WIDTH);
                    $scope.redraw();
                }

                $scope.moveUp = () => {
                    $scope.panzoom.y = $scope.panzoom.y + $scope.panzoom.height / 2 - $scope.panzoom.height * ((($scope.panzoom.HEIGHT / 2) + KEYBOARD_FACTOR) / $scope.panzoom.HEIGHT);
                    $scope.redraw();
                }

                $scope.moveDown = () => {
                    $scope.panzoom.y = $scope.panzoom.y + $scope.panzoom.height / 2 - $scope.panzoom.height * ((($scope.panzoom.HEIGHT / 2) - KEYBOARD_FACTOR) / $scope.panzoom.HEIGHT);
                    $scope.redraw();
                }
            }

            $scope.getNode = id => {
                if (!id) {
                    return undefined;
                }
                const item = $scope.nodesGraph.nodes[id];
                if (!item) {
                    return $scope.nodesGraph.nodes[id.replace("cluster_", "")];
                }
                return item;
            }

            $scope.getSelector = (id, node) => {
                const item = node ? node : $scope.getNode(id);
                let selector = id ? `g[data-id=${id}]` : 'g .highlight';
                if (item && item.nodeType === 'ZONE') {
                    selector = `#cluster_${id}`;
                }
                return selector;
            }

            $scope.zoomGraph = (id, paddingFactor = 3, item = null) => {
                FlowGraphFolding.ensureNodesNotFolded([id]);
                if (!item) {
                    item = $scope.getNode(id);
                }
                const selector = $scope.getSelector(id, item);
                if (item && item.nodeType === 'ZONE') {
                    paddingFactor = 1.5;
                }
                $scope.zoomToBbox(FlowGraphFiltering.getBBoxFromSelector($scope.svg, selector), paddingFactor);
            };

            $scope.zoomToBbox = function(bbox, paddingFactor = 1.5) {
                if (!$scope.svg || !bbox) return;
                $scope.panzoom.x = bbox.x;
                $scope.panzoom.y = bbox.y;

                if (bbox.width / bbox.height > $scope.panzoom.WIDTH / $scope.panzoom.HEIGHT) {
                    $scope.panzoom.width = bbox.width;
                    $scope.panzoom.height = bbox.width / ($scope.panzoom.WIDTH / $scope.panzoom.HEIGHT);
                    $scope.panzoom.y = bbox.y - ($scope.panzoom.height - bbox.height) / 2;
                } else {
                    $scope.panzoom.width = bbox.height * ($scope.panzoom.WIDTH / $scope.panzoom.HEIGHT);
                    $scope.panzoom.height = bbox.height;
                    $scope.panzoom.x = bbox.x - ($scope.panzoom.width - bbox.width) / 2;
                }

                const menuHeight = $('#flow-editor-page .menu').height();
                const x = $scope.panzoom.WIDTH / 2;
                const y = ($scope.panzoom.HEIGHT - menuHeight) / 2 + menuHeight;
                $scope.panzoom.x = $scope.panzoom.x + $scope.panzoom.width * (x / $scope.panzoom.WIDTH) * (1 - paddingFactor);
                $scope.panzoom.y = $scope.panzoom.y + $scope.panzoom.height * (y / $scope.panzoom.HEIGHT) * (1 - paddingFactor);
                $scope.panzoom.width  = $scope.panzoom.width * paddingFactor;
                $scope.panzoom.height = $scope.panzoom.height * paddingFactor;

                d3.select($scope.svg[0]).transition(300).attr(
                    'viewBox', [
                        $scope.panzoom.x,
                        $scope.panzoom.y,
                        $scope.panzoom.width,
                        $scope.panzoom.height
                    ].join(', ')
                );
            };

            setupZoomBehavior();
            setupMoveAndSelectBehavior();

            Mousetrap.bind("Z S", _ => $scope.zoomToBbox(FlowGraphFiltering.getBBoxFromSelector($scope.svg, '.selected')));
            $scope.$on("$destroy", _ => Mousetrap.unbind("Z S"));

            Mousetrap.bind("Z F", _ => $scope.zoomToBbox(FlowGraphFiltering.getBBoxFromSelector($scope.svg, '.focus')));
            $scope.$on("$destroy", _ => Mousetrap.unbind("Z F"));

            Mousetrap.bind("Z U", _ => $scope.zoomToBbox(FlowGraphFiltering.getBBoxFromSelector($scope.svg, '.usedDatasets .node')));
            $scope.$on("$destroy", _ => Mousetrap.unbind("Z U"));

            Mousetrap.bind("j e l l y", function(){
                let x = [];
                let y = [];
                let t = c => (c||0)*0.95 + 10 * (Math.random() - 0.5);
                let d = 9000;
                window.setInterval(function(){
                    d3.selectAll("g.node,g.edge").transition().duration(d).ease("elastic").attr("transform", function(d, i) {
                        [x[i], y[i]] = [t(x[i]), t(y[i])];
                        return "translate(" + x[i] + " , " + y[i] + ")";
                    });
                }, d*0.09);
            });

            Mousetrap.bind("d i s c o", function(){
                let r = {};
                let g = {};
                let b = {};
                let s = c => (c === undefined ? 255*Math.random() : c) + 100 * (Math.random() - 0.5);
                let bn = c => Math.max(0, Math.min(255, c));
                let sb = c => bn(s(c))
                let d = 2000;
                window.setInterval(function(){
                    d3.selectAll("g.node,g.edge").transition().duration(d).ease("elastic").style("fill", function(d,i) {
                        let id = $(this).attr('id')+'';
                        r[id] = sb(r[id])
                        g[id] = sb(g[id])
                        b[id] = sb(b[id])
                        // [r[id], g[id], b[id]] = [sb(r[id]), sb(g[id]), sb(b[id])];
                        return `rgb(${r[id]}, ${g[id]}, ${b[id]})`;
                    });
                }, d*0.09);
            });

            Mousetrap.bind("b e r n a r d", function(){
                d3.select($scope.svg[0])
                    .append("defs")
                    .append('pattern')
                    .attr('id', 'bp')
                    .attr('patternUnits', 'userSpaceOnUse')
                    .attr('width', 120)
                    .attr('height', 120)
                    .append("image")
                    .attr("xlink:href", "https://dev.dataiku.com/egg/bp.jpg")
                    .attr('width', 122)
                    .attr('height', 110)
                    .attr('x', -11);

                d3.select($scope.svg[0]).selectAll("g[data-recipe-type='pivot']").selectAll("path").attr("fill", "url(#bp)");
                d3.select($scope.svg[0]).selectAll("g[data-recipe-type='pivot']").style("opacity", "1")
            })

            let last_svg_str; //cache used only withing state, going out of the flow discards it
            let last_svg_element;
            let last_$svg;
            let last_filter_str;
            let last_nodes;
            let last_unread_ids;
            let deregister = $rootScope.$on('drawGraph', function (tgtScope, filter, indexNodes) {
                if (!$scope.nodesGraph.nodes) return; // Too early

                if (!filter && $scope.filtering) {
                    const filteringResults = $scope.filtering.filteringResults;
                    if (filteringResults && filteringResults.filteredGraphElements && !filteringResults.filteringError) {
                        filter = $scope.createGraphFilteringObject(filteringResults.filteredGraphElements);
                    }
                }

                let svgElement;
                let cachedSVG = !!$stateParams.projectKey && last_svg_str == $scope.nodesGraph.svg && last_filter_str === JSON.stringify(filter) && (!filter || !filter.ignoreCache) && angular.equals($scope.nodesGraph.nodes, last_nodes) && angular.equals(($rootScope.discussionsUnreadStatus || {}).unreadFullIds || [], last_unread_ids); // TODO and = last filter TODO
                if (cachedSVG) {
                    Logger.debug('use cached svg');
                    svgElement = last_svg_element;
                } else {
                    svgElement = $($scope.nodesGraph.svg);

                    // Manipulate the SVG in a hidden DIV as far as possible before switching to it,
                    // rather than switch early and then apply a sequence of changes. When we switch, don't change the SVG element, but its contents

                    $element.addClass('no-animation'); // Initial rendering should not have animation (especially when a flow view is active)

                    if (filter) {
                        let fakeElt = $('<div />');
                        fakeElt.append(svgElement);
                        FlowGraphFiltering.filterGraph(fakeElt.find('svg'), filter);
                    }

                    last_svg_str = $scope.nodesGraph.svg;
                    last_filter_str = JSON.stringify(filter);
                    last_svg_element = svgElement;
                    last_$svg = $element.find('svg');
                    last_nodes = $scope.nodesGraph.nodes;
                    last_unread_ids = angular.copy(($rootScope.discussionsUnreadStatus || {}).unreadFullIds || []);
                }

                if (!!$stateParams.zoneId) {
                    svgElement = $(svgElement).find(`.zone#zone_${$stateParams.zoneId}>svg`).removeAttr('x').removeAttr('y')
                }

                if (cachedSVG) {
                    Logger.debug('Graph is ready, reset style');
                    //TODO @flow move to do flow styling + views
                    $('g', $scope.svg).removeAttr('style');
                    $('.newG', $scope.svg).removeAttr('color');
                    $('.tool-simple-zone', $scope.svg).empty();
                    $('.node-label', $scope.svg).remove();
                    $('.node-totem span', $scope.svg).removeAttr('style').removeClass();
                    $('.never-built-computable *', $scope.svg).removeAttr('style');
                    $scope.svg = last_$svg;

                    $scope.$emit('refreshFlowState');
                } else {
                    Logger.debug('Graph is not ready, add svg element', svgElement);

                    var isReload = false;

                    if ($element.children().length > 0) {
                        isReload = true;
                        $element.append("<div style='visibility:hidden; width:100%; height:100%' id='hc-svnt-dracones'></div>")
                        var $preloadedGraph = $element.find('#hc-svnt-dracones');
                        $preloadedGraph.append(svgElement);
                        $scope.svg = last_$svg = $preloadedGraph.find('>svg');
                    } else {
                        $element.children().remove();
                        $element.find('svg').remove();
                        $element.append(svgElement);
                        $scope.svg = last_$svg = $element.find('>svg');
                    }

                    const bbFlow = $scope.svg.find('g.graph')[0].getBBox(); //get the whole-flow bounding box
                    const defaultPz = buildDefaultPanZoomSettings($scope.panzoom, bbFlow);
                    if (!GraphZoomTrackerService.isValidPanZoom($scope.panzoom)) {
                        $scope.panzoom = defaultPz;
                    }

                    $scope.svg.attr('height', '100%').attr('width', '100%');

                    // remove background polygon
                    // Firefox use to have an issue but seems resolved with recent version (Check history of the file)
                    $scope.svg[0].setAttribute('viewBox', '-10000 -10000 10 10'); //mjt move offscreen to avoid flicker
                    $scope.svg.find('g').first().attr('transform', '').find('polygon').first().remove();
                    d3.select($scope.svg[0]).selectAll("g.cluster:not(.zone_cluster)").remove()


                    if (!!$stateParams.projectKey) {
                        ProjectFlowGraphStyling.restyleGraph($scope.svg, $scope);
                        ProjectFlowGraphLayout.relayout($scope.svg);
                    } else {
                        InterProjectGraphStyling.restyleGraph($scope.svg, $scope);
                        InterProjectGraphLayout.relayout($scope.svg);
                    }
                    $scope.$emit('graphRendered');
                    $scope.$emit('refreshFlowState');
                }
                FlowGraphSelection.refreshStyle();

                if (filter) {
                    FlowGraphFiltering.fadeOut($scope.svg, filter);
                }

                $('#flow-graph').attr('style', '');
                $rootScope.$broadcast('reflow');

                //mjt experiment in anti-flicker
                if (isReload) {
                    const $newSvg = $preloadedGraph.children().first();//find('svg');
                    const $origSvg = $element.children().first();
                    $origSvg.children().remove();
                    $origSvg.append($newSvg.children());
                    $scope.svg = last_$svg = $element.find('>svg');
                    $preloadedGraph.remove();
                }

                if (indexNodes === true) {
                    let graphDOM = $scope.svg.find('g.graph')[0];
                    if (graphDOM) {
                        FlowGraph.indexNodesCoordinates($scope.svg, graphDOM.getBBox());
                    }
                }

            }, true);
            $scope.$on('$destroy', deregister);

            $element[0].oncontextmenu = function(evt) {
                const itemElt =  $(evt.target).parents('g[data-type]').first();
                let nodeId = $(itemElt).attr('data-id');
                if (itemElt.attr("data-type") === "ZONE") {
                    nodeId = nodeId.replace("cluster_", "");
                }
                const node = FlowGraph.node(nodeId);
                return $scope.onContextualMenu(node, evt);
            };

            //TODO @flow move?
            $scope.$watchCollection('tool.user.state.focusMap', function(nv,ov) {
                if (!nv ) return;
                $scope.tool.drawHooks.updateFlowToolDisplay();
                $scope.tool.saveFocus();
            })


            $scope.$on('graphRendered', function() {
                if (FlowGraph.get().nodes.length < 200) { // Too slow for bigger graphs
                    Logger.debug('Reactivate animations')
                    $('#flow-graph').toggleClass('no-animation', false);
                }
            });
            // Attempt to render SVG into canvas, so as to extract a dataURL that could in turn be used as a thumbnail
            // It lacks a lot of refinement, but the core principle is solid
            //NOSONAR
            // $scope.$on('graphRendered', function() {
            //     setTimeout(function() {
            //         if($scope.svg.length) {
            //             const canvas = $('<canvas style="width:600px;height:300px;position:absolute;top:0;left:0;border:solid;"></canvas>')[0];
            //             const ctx = canvas.getContext('2d');
            //
            //             const data = "data:image/svg+xml," + $scope.svg[0].outerHTML.replace('height=""', 'height="600"').replace('width=""', 'width="300"');
            //             const img = new Image();
            //             img.src = data;
            //             img.onload = function() { ctx.drawImage(img, 0, 0, 600, 300); }
            //             document.body.appendChild(canvas);
            //         }
            //     }, 1000)
            // })

            }
        };
    });


    app.directive('flowGraphWithTooltips', function($rootScope, FlowGraph, ChartTooltipsUtils, WatchInterestState) {

    return {
        restrict: 'EA',
        link: function (scope, element, attrs) {
            let tooltip, tooltipScope;
            let timeout;
            const DEFAULT_DELAY = 500;
            const SHORT_DELAY = 250; // Just enough so that if you just want to click on an item, you don't see the tooltip

            function show(node, tooltipScope, evt, delay) {
                timeout = setTimeout(function() {
                    ChartTooltipsUtils.handleMouseOverElement(tooltipScope);
                    tooltipScope.node = node;
                    tooltipScope.$apply();
                    ChartTooltipsUtils.appear(tooltip, '#777', evt, element);
                }, delay);
            }

            function hide(digestInProgress) {
                if (tooltipScope == null) return; // might not be ready yet
                clearTimeout(timeout);
                ChartTooltipsUtils.handleMouseOutElement(tooltip, tooltipScope, digestInProgress);
            }

            function addTooltipBehavior(elt, boxplot) {
                const nodeId = elt.attr('data-id');
                const node = FlowGraph.node(nodeId);

                if (node) {
                    elt.on("mouseover", function(d, i) {
                        if (node.filterRemove || tooltipScope == null) return; // might not be ready yet

                        if (scope.tool && scope.tool.drawHooks && scope.tool.drawHooks.setupTootip) {
                            tooltipScope.tooltip = scope.tool.drawHooks.setupTootip(node);
                            show(node, tooltipScope, d3.event, SHORT_DELAY);
                        } else if ((node.nodeType.endsWith('DATASET') || node.nodeType.endsWith('ZONE')) && !node.shortDesc && !(node.tags && node.tags.length)) {
                            return; // Let's not display the tooltip just for the name of the dataset...
                        } else {
                            tooltipScope.tooltip = {};
                            show(node, tooltipScope, d3.event, DEFAULT_DELAY);
                        }
                    })
                        .on("mouseout", hide);
                }
            }

            ChartTooltipsUtils.createWithStdAggr1DBehaviour(scope, attrs.tooltipType || 'flow-tooltip', element)
                .then(function(x){
                    tooltip = x[0];
                    tooltipScope = x[1];
                })
                .then(() => {
                    tooltipScope.isWatching = WatchInterestState.isWatching;
                });

            scope.setupTootips = function() {
                $('[data-id][data-type]:not([data-type="ZONE"])').each(function(_, g) {
                    addTooltipBehavior(d3.select(g))
                });
                $('.zone_cluster').each(function(_, g) {
                    addTooltipBehavior(d3.select(g))
                });
            }

            const h = $rootScope.$on('flowSelectionUpdated', _ => hide(true));
            scope.$on('$destroy', h);

            scope.$on("graphRendered", scope.setupTootips);
        }
    }
    });


    // Used to have global variables...
    app.service('FlowGraph', function($rootScope) {
        const svc = this;

        let graph;
        let nodesElements;
        let edgesElementsTo;
        let edgesElementsFrom;
        let nodesCoordinates; // simple list: [{nodeId, middlePoint}]
        let zonesElements;
        let graphBBox;

        this.set = function(g) {
            graph = g;
        };

        this.get = function() {
            return graph;
        };

        this.node = function(nodeId) {
            return graph.nodes[nodeId];
        };

        this.nodeCount = function() {
            return graph.nodesOnGraphCount;
        };

        this.getDOMElement = function() {
            return $('#flow-graph');
        };

        this.getSvg = function() {
            return $('#flow-graph > svg');
        };

        this.rawNodeWithId = function(nodeId) {
            if (!nodesElements) return; // not ready
            return nodesElements[nodeId];
        };
        this.d3NodeWithId = function(nodeId) {
            if (!nodesElements) return; // not ready
            return d3.select(svc.rawNodeWithId(nodeId));
        };
        this.d3ZoneNodeWithId = function(nodeId) {
            if (!zonesElements) return; // not ready
            return d3.select(zonesElements[nodeId]);
        };
        this.rawZoneNodeWithId = function(nodeId) {
            if (!zonesElements) return; // not ready
            return zonesElements[nodeId];
        };

        this.rawEdgesWithFromId = function(nodeId) {
            if (!edgesElementsFrom) return [];
            return edgesElementsFrom[nodeId] || [];
        };

        this.rawEdgesWithToId = function(nodeId) {
            if (!edgesElementsTo) return [];
            return edgesElementsTo[nodeId] || [];
        };

        // No fancy search (for now?)
        this.getEnclosedNodesIds = function(rect) {
            if (!nodesCoordinates) return []; // not ready
            const bounds = {x1: rect.x, y1: rect.y, x2: rect.x + rect.width, y2: rect.y + rect.height};
            return nodesCoordinates.filter(c => c.middlePoint.x >= bounds.x1 && c.middlePoint.x <= bounds.x2 && c.middlePoint.y >= bounds.y1 && c.middlePoint.y <= bounds.y2).map(c => c.nodeId);
        };

        // Return the graphBBox, filled when indexNodesCoordinates is called
        this.getGraphBBox = function() {
            return graphBBox;
        }

        this.setGraphBBox = function(newBBox) {
            graphBBox = newBBox;
        }

        this.indexNodesCoordinates = function(globalSvg, svgBBox) {
            nodesElements = {};
            edgesElementsTo = {};
            edgesElementsFrom = {};
            zonesElements = {};
            nodesCoordinates = [];

            function pushEltToEdgeMap(nodeId, elt, edgeMap) {
                if (nodeId) {
                    if (!edgeMap[nodeId]) edgeMap[nodeId] = [];
                    edgeMap[nodeId].push(elt);
                }
            }
            this.setGraphBBox(svgBBox);
            $('.usedDatasets .node,.connectedProjects .node', globalSvg).each(function(_, elt) {
                const nodeId = $(elt).attr('data-id');
                const bbox = elt.getBBox();
                const svg = $(elt).closest('svg');

                if (!svg.is(globalSvg)) {
                     // In case the parent is a zone, map the bbox to the globalSVG coords
                    const matrix = elt.getTransformToElement(globalSvg[0]);
                    let topLeft = svg[0].createSVGPoint();
                    topLeft.x = bbox.x;
                    topLeft.y = bbox.y;

                    topLeft = topLeft.matrixTransform(matrix);

                    bbox.x = topLeft.x;
                    bbox.y = topLeft.y;
                }

                const middlePoint = {x: bbox.x + bbox.width/2, y: bbox.y + bbox.height/2}
                nodesElements[nodeId] = elt;
                nodesCoordinates.push({nodeId, middlePoint});
            });

            // build a map of edges to accelerate path highlighting hugely on large flows
            $('.edge', globalSvg).each(function(_, elt) {
                pushEltToEdgeMap($(elt).attr('data-from'), elt, edgesElementsFrom);
                pushEltToEdgeMap($(elt).attr('data-to'), elt, edgesElementsTo);
            });

            $('.draftDatasets > .node', globalSvg).each(function(_, elt) {
                const nodeId = $(elt).attr('data-id');
                const bbox = elt.getBBox();
                const svg = $(elt).closest('svg');

                if (!svg.is(globalSvg)) {
                    // In case the parent is a zone, map the bbox to the globalSVG coords
                    const matrix = elt.getTransformToElement(globalSvg[0]);

                    let topLeft = svg[0].createSVGPoint();
                    topLeft.x = bbox.x;
                    topLeft.y = bbox.y;

                    topLeft = topLeft.matrixTransform(matrix);

                    bbox.x = topLeft.x;
                    bbox.y = topLeft.y;
                } else {
                    bbox.x = svgBBox.x + bbox.x;
                    bbox.y = svgBBox.y + bbox.y;
                }

                const middlePoint = { x: bbox.x + bbox.width/2, y: bbox.y + bbox.height/2 };
                nodesElements[nodeId] = elt;
                nodesCoordinates.push({nodeId, middlePoint});
            });

            $('.zone_cluster', globalSvg).each(function(_, elt) {
                const nodeId = $(elt).attr('id').replace('cluster_', '');

                zonesElements[nodeId] = elt;
            });

            $rootScope.$emit('flowDisplayUpdated');
            $rootScope.$broadcast('indexNodesDone');
        };

        this.ready = function() {
            return !!graph && !!nodesCoordinates;
        };

        // Some services make API calls that require to be displayed in API error directive so bound to a scope
        // But the services have no scope and binding errors to rootScope is inconvenient
        // (because the error won't necessarily go away when moving to another state)
        this.setError = function() {
            const flowGraphScope = angular.element('#flow-graph').scope();
            return setErrorInScope.bind(flowGraphScope);
        }

        this.updateTagsFromFlowTool = function(tagsByNode) {
            Object.keys(graph.nodes).forEach(node => {
                if (tagsByNode.hasOwnProperty(node)) graph.nodes[node].tags = tagsByNode[node];
            });
        }

        this.nodeSharedBetweenZones = node => {
            const found = graph.zonesUsedByRealId[node.realId];
            if (found) {
                const set = new Set(found);
                set.delete(node.ownerZone);
                return set;
            }
            return null;
        };
    });


    function square_distance(A, B) {
        const dx = A.x - B.x;
        const dy = A.y - B.y;
        return (dx*dx + dy*dy);
    }

    /**
     * Create a panZoom structure that will display the whole flow nicely.
     * This is the classic fall-back display used when there is no saved zoom settings
     * or the flow is too small to justify re-using the saved zoom settings.
     *
     * @param currentPz - the current panZoom settings.
     * @param bbFlow - the SVG bounding box structure for the whole flow
     * @returns a new panZoom structure
     */
    function buildDefaultPanZoomSettings(currentPz, bbFlow) {
        //copy existing settings, in particular the HEIGHT/WIDTH (for the HTML container,
        // and typically the maxHeight / maxWidth, which control how far you can zoom out.

        const pz = angular.copy(currentPz);

        pz.width = bbFlow.width;
        pz.height = bbFlow.height;
        pz.x = bbFlow.x;
        pz.y = bbFlow.y;
        if (bbFlow.width / bbFlow.height > pz.WIDTH / pz.HEIGHT) {
            pz.width = bbFlow.width;
            pz.height = bbFlow.width * (pz.HEIGHT / pz.WIDTH);
            pz.y = bbFlow.y - (pz.height - bbFlow.height) / 2;
        } else {
            pz.width = bbFlow.height * (pz.WIDTH / pz.HEIGHT);
            pz.height = bbFlow.height;
            pz.x = bbFlow.x - (pz.width - bbFlow.width) / 2;
        }

        pz.maxHeight = pz.height;
        pz.maxWidth = pz.width;

        return pz;
    }

})();

(function(){
'use strict';

const app = angular.module('dataiku.flow.graph');


/* We get a first SVG flow generated by graphviz in the backend,
 * frontend post-processing is done here
 */


app.service('ProjectFlowGraphStyling', function($filter, FlowGraph, CachedAPICalls, LoggerProvider, TimingService, $sanitize, DataikuAPI, $rootScope, $q, objectTypeFromNodeFlowType, $state, $compile) {

const SIZE = 100;

const logger = LoggerProvider.getLogger('flow');

let flowIconset;
 CachedAPICalls.flowIcons.success(function(data) {
    flowIconset = data;
});

const formatters = {
    'RECIPE': restyleRecipeNode,
    'LOCAL_DATASET': restyleDatasetNode(true),
    'FOREIGN_DATASET': restyleDatasetNode(false),
    'LOCAL_SAVEDMODEL': restyleModelNode(true),
    'FOREIGN_SAVEDMODEL': restyleModelNode(false),
    'LOCAL_MODELEVALUATIONSTORE': restyleEvaluationStoreNode(true),
    'FOREIGN_MODELEVALUATIONSTORE': restyleEvaluationStoreNode(false),
    'LOCAL_MANAGED_FOLDER': restyleFolderNode(true),
    'FOREIGN_MANAGED_FOLDER': restyleFolderNode(false),
    'LOCAL_STREAMING_ENDPOINT': restyleStreamingEndpointNode(true),
    'FOREIGN_STREAMING_ENDPOINT': restyleStreamingEndpointNode(false)
};

this.restyleGraph = TimingService.wrapInTimePrinter("ProjectFlowGraphStyling::restyleGraph", function(svg, $scope) {
    const zones = svg.find('.zone_cluster');
    if (zones) {
        for (let i = 0; i < zones.length; i++) {
            const zone = zones[i];
            try {
                restyleZone(svg, zone, $scope);
            } catch (e) {
                logger.error("Failed to restyle flow zone: ", e);
            }
        }
    }
    svg.find(".zone_label_remove").remove();
    svg.find('text').remove();
    svg.find('title').remove();

    const nodes = $('.node:not(.zone)', svg);

    if (nodes) {
        for (let i = 0; i<nodes.length; i++) {
            const g = nodes[i];
            try {
                restyleNode(g);
            } catch (e) {
                logger.error("Failed to restyle flow node: ", e);
            }
        }
    }
    svg.find('.node.zone>svg g polygon').remove();
});


function drawInformationSticker(svg, coords) {
    svg.appendChild(makeSVG('ellipse', {
        class: 'flow-information-sticker__background',
        cx: coords.cx,
        cy: coords.cy,
        rx: coords.rx,
        ry: coords.ry
    }));

    svg.appendChild(makeForeignObject({
        x: coords.indicatorX,
        y: coords.indicatorY,
        width: 20,
        height: 20,
        class: 'flow-information-sticker__indicator',
    }, $(`<span size="32" class="icon-info-sign">`)));
}

function drawDiscussionSticker(svg, discussionCount, has_unread_discussions, coords, offset, indicatorOffset = {x: 0, y: 0}) {
    svg.appendChild(makeSVG('ellipse', {
        class: 'flow-discussions-sticker__background',
        cx: coords.cx - offset.x,
        cy: coords.cy - offset.y,
        rx: coords.rx,
        ry: coords.ry
    }));

    svg.appendChild(makeForeignObject({
        x: coords.indicatorX - offset.x - indicatorOffset.x,
        y: coords.indicatorY - offset.y - indicatorOffset.y,
        width: 20,
        height: 20,
        class: 'flow-discussions-sticker__indicator' + ((has_unread_discussions) ? ' flow-discussions-sticker__indicator--unread' : ''),
    }, $(`<span size="32" class="icon-dku-discussions">`)));
    
    svg.appendChild(makeForeignObject({
        x: coords.contentX - offset.x,
        y: coords.contentY - offset.y,
        width: 40,
        height: 20,
        class: 'flow-discussions-sticker__content',
    }, $(`<span>` + (discussionCount > 9 ? '9+' : discussionCount) + `</span>`)));
}

function hasUnreadDiscussion(flowNode) {
    return (($rootScope.discussionsUnreadStatus || {}).unreadFullIds || []).find(discuId => (flowNode.discussionsFullIds || []).includes(discuId));
}

function restyleNode(g) {
    const nodeType = $(g).attr('data-type');
    if (formatters[nodeType]) {
        formatters[nodeType](g);
    }
}

function restyleZone(svg, zone_cluster, $scope) {
    const jZone_cluster = $(zone_cluster);
    const cluster_polygon = jZone_cluster.find('>polygon');
    const text = jZone_cluster.find(">text");
    const id = zone_cluster.id.split("_").splice(2).join('');
    const zone = svg.find(`.zone[id='zone_${id}']`);
    const zone_polygon = zone.find('>polygon');
    // Calculate difference between zone top and cluster top (Gives us the height for the text)

    if (zone_polygon && cluster_polygon) {
        const zone_coords = polygonToRectData(zone_polygon);
        const cluster_coords = polygonToRectData(cluster_polygon);
        const zoneNode = FlowGraph.node(`zone_${id}`);
        const collapseIcon = zoneNode.customData.isCollapsed ? "icon-resize-full" : "icon-resize-small";
        let height = (zone_coords.y - cluster_coords.y) * 2;
        if (!height > 0) {
            logger.warn("Calculated height is not a valid number, default to 44");
            height = 44;
        }
        const foreignObject = makeForeignObject({
            x: cluster_coords.x,
            y: cluster_coords.y,
            width: zone_coords.width,
            height,
            class: 'zone_header'
        }, $(`<div><p>${$sanitize(text.text())}</p><i ng-click="toggleZoneCollapse([{id:'${$sanitize(id)}'}])" class="${collapseIcon} cursor-pointer" id="collapse-button-zone-${$sanitize(id)}"/><i ng-click="zoomOnZone('${$sanitize(id)}')" class="icon-DKU_expand cursor-pointer"/></div>`));
        const color = d3.rgb(zoneNode.customData.color);
        const zoneTitleColor = (color.r*0.299 + color.g*0.587 + color.b*0.114) >= 128 ? "#000" : "#FFF";
        foreignObject.style = `background-color: ${color}; color: ${zoneTitleColor}; border-bottom: none;`;
        zone_cluster.appendChild(makeSVG('g', {
            class: 'tool-simple-zone',
            transform: `translate(${cluster_coords.x + cluster_coords.width}, ${cluster_coords.y + cluster_coords.height})`,
            'data-height': 0
        }));
        zone_cluster.appendChild(foreignObject);
        $compile(foreignObject)($scope);
        zone_polygon.remove();
    }

    $(zone_cluster)[0].setAttribute("data-zone-title", $sanitize(text[0].textContent));
    $(zone_cluster)[0].setAttribute("data-id", "zone_" + $sanitize(id));
}

function restyleDatasetNode(local) {
    // Note that differentiation local/foreign is made with CSS
    return function (g) {
        const nodeId = $(g).attr('data-id');
        const nodeZoneId = $(g).attr('data-zone-id');
        const dataset = FlowGraph.node(nodeId);

        const dotPolygon = $(g).find("polygon");
        if (dotPolygon.length) {
            const coords = polygonToRectData(dotPolygon);

            let clazz = 'newG';
            if (dataset.neverBuilt) {
                clazz += ' never-built-computable';
            }
            const newG = makeSVG('g', {class: clazz, transform: `translate(${coords.x} ${coords.y})`});
            d3.select(newG).classed("bzicon", true);

            const othersZones = FlowGraph.nodeSharedBetweenZones(dataset);
            const isExported = othersZones && !othersZones.has(nodeZoneId);
            const isImported = othersZones && othersZones.has(nodeZoneId);
            const margin = isExported && othersZones.size > 0 ? 4 : 0;

            if (dataset.partitioned) {
                newG.appendChild(makeSVG('rect', {
                    x: -10,
                    y: -10,
                    width: coords.width,
                    height: coords.height,
                    class: 'fill dataset-rectangle partitioning-indicator' + (isImported ? ' dataset-zone-imported' : '')
                }));

                newG.appendChild(makeSVG('rect', {
                    x: -5,
                    y: -5,
                    width: coords.width,
                    height: coords.height,
                    class: 'fill dataset-rectangle partitioning-indicator' + (isImported ? ' dataset-zone-imported' : '')
                }));
            }


            if (isExported) {
                newG.appendChild(makeSVG('rect', {
                    x: 0,
                    y: 0,
                    width: coords.width,
                    height: coords.height,
                    class: 'fill dataset-zone-exported'
                }));
            }
            newG.appendChild(makeSVG('rect', {
                x: margin,
                y: margin,
                width: coords.width - (margin*2),
                height: coords.height - (margin*2),
                class: 'fill dataset-rectangle main-dataset-rectangle' + (isImported ? ' dataset-zone-imported' : '')
            }));

            newG.appendChild(makeSVG('g', {
                class: 'tool-simple-zone',
                transform: `translate(${coords.width}, 0)`,
                'data-height': '72'
            }));

            newG.appendChild(makeForeignObject({
                x: -30,
                y: coords.height * 1.07,
                width: coords.width + 60,
                height: 45,
                class: 'nodelabel-wrapper'
            }, $('<div><span>' + $sanitize(dataset.description.replace(/([-_])/g, '$1\u200b')) + '</span></div>')));

            const icon = $filter("datasetTypeToIcon")(dataset.datasetType);
            newG.appendChild(makeForeignObject({
                x: 15,
                y: 16,
                width: 42,
                height: 42,
                class: 'nodeicon' + (isImported ? 'dataset-imported' : '')
            }, $(`<div style="text-align: center"><i class="${icon}" /></div>`)));

            newG.appendChild(makeSVG('rect', {
                class: 'selection-outline',
                x: 0,
                y: 0,
                width: 72,
                height: 72
            }));

            newG.appendChild(makeForeignObject({
                x: 56,
                y: -15,
                width: 34,
                height: 34,
                class: 'node-totem'
            }, $(`<span size="32">`)));

            let offset = {x: 0, y: 0};

            // Information sticker
            // To display when the dataset has a short description
            if (angular.isDefined(dataset.shortDesc) && dataset.shortDesc.length > 0) {
                let coords = {
                    cx: 1,
                    cy: 67,
                    rx: 10,
                    ry: 10,
                    indicatorX: -9,
                    indicatorY: 57
                };

                drawInformationSticker(newG, coords);
                offset.y += 20;
            }

            // Discussion sticker
            // To display when the dataset has an unread discussion
            if (local && dataset.discussionsFullIds.length > 0) {

                let unread = hasUnreadDiscussion(dataset);
                let coords = {
                    cx: 0,
                    cy: 69.5,
                    rx: 10.5,
                    ry: 9,
                    indicatorX: -10,
                    indicatorY: 60,
                    contentX: -20,
                    contentY: 60
                };
                const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
                drawDiscussionSticker(newG, dataset.discussionsFullIds.length, unread, coords, offset, {x: 0, y: isFirefox ? -2 : 0});

            }

            $(dotPolygon).replaceWith(newG);
        }
    }
}

function restyleModelNode(local) {
    return function(g) {
        const nodeId = $(g).attr('data-id');
        const nodeZoneId = $(g).attr('data-zone-id');
        const sm = FlowGraph.node(nodeId);

        const dotPolygon = $(g).find('polygon');
        if (dotPolygon.length) {
            $(g).find("text").remove();
            const coords = polygonToRectData(dotPolygon);
            const newG = makeSVG('g', {class: 'newG', transform: `translate(${coords.x} ${coords.y-coords.height})`});

            newG.appendChild(makeSVG('rect', {
                x: 0,
                y: 0,
                width: coords.width * 0.707,
                height: coords.height * 0.707,
                transform: `translate(${coords.width/2}) rotate(45)`,
                opacity: 0,
                class: 'fill'
            }));

            const othersZones = FlowGraph.nodeSharedBetweenZones(sm);
            const isExported = othersZones && !othersZones.has(nodeZoneId);
            const isImported = othersZones && othersZones.has(nodeZoneId);

            if (sm.partitioned) {
                /* Partition boxes */
                for (let offset of [-10, -5, 0]) {
                    newG.appendChild(makeSVG('rect', {
                        x: offset,
                        y: offset,
                        width: coords.width * 1.41421,
                        height: coords.height * 1.41421,
                        transform: `translate(${coords.width}) rotate(45)`,
                        class: 'fill node__rectangle--partitioned partitioning-indicator'
                    }));
                }

                /* White background for the rest of the icon */
                newG.appendChild(makeSVG('rect', {
                    x: 0,
                    y: 0,
                    width: coords.width * 1.41421,
                    height: coords.height * 1.41421,
                    transform: `translate(${coords.width}) rotate(45)`,
                    class: 'node__rectangle--blank'
                }));
            }

            if (isExported) {
                newG.appendChild(makeSVG('rect', {
                    x: 0,
                    y: 0,
                    width: coords.width * 1.41421,
                    height: coords.height * 1.41421,
                    transform: `translate(${coords.width}) rotate(45)`,
                    class: 'fill model-zone-exported'
                }));
            }

            const iconText = flowIconset.icons[sm.smType == "CLUSTERING" ? "model_clustering" : "model_regression"];
            const iconElt = d3.select($.parseXML(iconText)).select("svg").selectAll("path");
            const newG2 = makeSVG("g");
            iconElt[0].forEach(i => newG2.appendChild(i));
            d3.select(newG2).attr("transform", " scale(0.707, 0.707) translate(1, 1)")
            d3.select(newG2).classed("bzicon sm-icon" + (isImported ? ' model-zone-imported': isExported ? ' model-zone-exported' : ''), true);

            newG.appendChild(newG2);

            newG.appendChild(makeSVG('g', {
                class: 'tool-simple-zone',
                transform: `translate(${coords.width + 26}, 24)`,
                'data-height': coords.height
            }));

            if (!sm.description) {
                sm.description = "Saved model...";
            }

            newG.appendChild(makeSVG('rect', {
                class: 'selection-outline',
                x: 0,
                y: 0,
                width: coords.width * 1.41421,
                height: coords.height * 1.41421,
                transform: `translate(${coords.width})  rotate(45)`,
            }));

                // x: -coords.width*0.2071,
            newG.appendChild(makeForeignObject({
                x: -30,
                y: coords.height * 2.07,
                width: coords.width*2+60,
                height: 42,
                class: 'nodelabel-wrapper'
            }, $('<div><span>' + $sanitize(sm.description.replace(/([-_])/g, '$1\u200b')) + '</span></div>')));

            newG.appendChild(makeForeignObject({
                x: 45,
                y: -10,
                width: 32,
                height: 32,
                class: 'node-totem'
            }, $(`<span size="32">`)));

            let offset = {x: 0, y: 0};

            // Information sticker
            // To display when the sm has a short description
            if (angular.isDefined(sm.shortDesc) && sm.shortDesc.length > 0) {
                let coords = {
                    cx: 27,
                    cy: 63,
                    rx: 10,
                    ry: 10,
                    indicatorX: 17,
                    indicatorY: 53
                };

                drawInformationSticker(newG, coords);
                offset.x += 12;
                offset.y += 12;
            }

            // Discussion sticker
            // To display when the dataset has an unread discussion
            if (local && sm.discussionsFullIds.length > 0) {

                let unread = hasUnreadDiscussion(sm);
                let coords = {
                    cx: 24,
                    cy: 64.5,
                    rx: 10.5,
                    ry: 9,
                    indicatorX: 14,
                    indicatorY: 55,
                    contentX: 4,
                    contentY: 55
                };
                const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
                drawDiscussionSticker(newG, sm.discussionsFullIds.length, unread, coords, offset, {x: 0, y: isFirefox ? -2 : 0});

            }

            $(dotPolygon).replaceWith(newG);
        }
    }
}

function restyleEvaluationStoreNode(local) {
    return function(g) {
        const nodeId = $(g).attr('data-id');
        const nodeZoneId = $(g).attr('data-zone-id');
        const mes = FlowGraph.node(nodeId);

        const dotPolygon = $(g).find('polygon');
        if (dotPolygon.length) {
            $(g).find("text").remove();
            const coords = polygonToRectData(dotPolygon);
            const newG = makeSVG('g', {class: 'newG', transform: `translate(${coords.x} ${coords.y-coords.height})`});

            newG.appendChild(makeSVG('rect', {
                x: 0,
                y: 0,
                width: coords.width * 0.707,
                height: coords.height * 0.707,
                transform: `translate(${coords.width/2}) rotate(45)`,
                opacity: 0,
                class: 'fill'
            }));

            const othersZones = FlowGraph.nodeSharedBetweenZones(mes);
            const isExported = othersZones && !othersZones.has(nodeZoneId);
            const isImported = othersZones && othersZones.has(nodeZoneId);

            if (mes.partitioned) {
                /* Partition boxes */
                for (let offset of [-10, -5, 0]) {
                    newG.appendChild(makeSVG('rect', {
                        x: offset,
                        y: offset,
                        width: coords.width * 1.41421,
                        height: coords.height * 1.41421,
                        transform: `translate(${coords.width}) rotate(45)`,
                        class: 'fill node__rectangle--partitioned partitioning-indicator'
                    }));
                }

                /* White background for the rest of the icon */
                newG.appendChild(makeSVG('rect', {
                    x: 0,
                    y: 0,
                    width: coords.width * 1.41421,
                    height: coords.height * 1.41421,
                    transform: `translate(${coords.width}) rotate(45)`
                }));
            } else {
                newG.appendChild(makeSVG('rect', {
                    x: 0,
                    y: 0,
                    width: coords.width * 1.41421,
                    height: coords.height * 1.41421,
                    transform: `translate(${coords.width}) rotate(45)`
                }));
            }

            if (isExported) {
                newG.appendChild(makeSVG('rect', {
                    x: 0,
                    y: 0,
                    width: coords.width * 1.41421,
                    height: coords.height * 1.41421,
                    transform: `translate(${coords.width}) rotate(45)`,
                    class: 'fill evaluation-store-zone-exported'
                }));
            }

            const icon = 'icon-model-evaluation-store';
            newG.appendChild(makeForeignObject({
                x: 15,
                y: 16,
                width: 42,
                height: 42,
                class: 'nodeicon' + (isImported ? ' evaluation-store-zone-imported': isExported ? ' evaluation-store-zone-exported' : '')
            }, $(`<div style="text-align: center"><i class="${icon}" /></div>`)));

            newG.appendChild(makeSVG('g', {
                class: 'tool-simple-zone',
                transform: `translate(${coords.width + 26}, 24)`,
                'data-height': coords.height
            }));

            if (!mes.description) {
                mes.description = "Model evaluation store...";
            }

            newG.appendChild(makeSVG('rect', {
                class: 'selection-outline',
                x: 0,
                y: 0,
                width: coords.width * 1.41421,
                height: coords.height * 1.41421,
                transform: `translate(${coords.width})  rotate(45)`,
            }));

                // x: -coords.width*0.2071,
            newG.appendChild(makeForeignObject({
                x: -30,
                y: coords.height * 2.07,
                width: coords.width*2+60,
                height: 42,
                class: 'nodelabel-wrapper'
            }, $('<div><span>' + $sanitize(mes.description.replace(/([-_])/g, '$1\u200b')) + '</span></div>')));

            newG.appendChild(makeForeignObject({
                x: 45,
                y: -10,
                width: 32,
                height: 32,
                class: 'node-totem'
            }, $(`<span size="32">`)));

            let offset = {x: 0, y: 0};

            // Information sticker
            // To display when the mes has a short description
            if (angular.isDefined(mes.shortDesc) && mes.shortDesc.length > 0) {
                let coords = {
                    cx: 27,
                    cy: 63,
                    rx: 10,
                    ry: 10,
                    indicatorX: 17,
                    indicatorY: 53
                };

                drawInformationSticker(newG, coords);
                offset.x += 12;
                offset.y += 12;
            }

            // Discussion sticker
            // To display when the dataset has an unread discussion
            if (local && mes.discussionsFullIds.length > 0) {

                let unread = hasUnreadDiscussion(mes);
                let coords = {
                    cx: 24,
                    cy: 64.5,
                    rx: 10.5,
                    ry: 9,
                    indicatorX: 14,
                    indicatorY: 55,
                    contentX: 4,
                    contentY: 55
                };
                const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
                drawDiscussionSticker(newG, mes.discussionsFullIds.length, unread, coords, offset, {x: 0, y: isFirefox ? -2 : 0});

            }

            $(dotPolygon).replaceWith(newG);
        }
    }
}

function restyleFolderNode(local) {
    return function(g) {
        const nodeId = $(g).attr('data-id');
        const nodeZoneId = $(g).attr('data-zone-id');
        const folder = FlowGraph.node(nodeId);

        const dotPolygon = $(g).find('polygon');
        if (dotPolygon.length) {
            const coords = polygonToRectData(dotPolygon);

            const newG = makeSVG('g', {class: 'newG', transform: `translate(${coords.x} ${coords.y})`});

            const othersZones = FlowGraph.nodeSharedBetweenZones(folder);
            const isExported = othersZones && !othersZones.has(nodeZoneId);
            const isImported = othersZones && othersZones.has(nodeZoneId);

            $(g).find("text").remove();

            const iconText = flowIconset.icons["folder"];
            let iconElt = d3.select($.parseXML(iconText)).select("svg").select("g")
            iconElt.attr("transform", " scale(0.57, 0.57) ");
            iconElt.classed("bzicon" + (isImported ? " folder-zone-imported" : ''), true);

            newG.appendChild(iconElt[0][0]);

            newG.appendChild(makeSVG('g', {
                class: 'tool-simple-zone',
                transform: `translate(${coords.width}, 0)`,
                'data-height': coords.height
            }));

            if (!folder.description) {
                folder.description = "Managed folder";
            }
            newG.appendChild(makeForeignObject({
                x: -30,
                y: coords.height * 1.01,
                width: coords.width + 60,
                height: 42,
                class: 'nodelabel-wrapper'
            }, $('<div><span>' + $sanitize(folder.description.replace(/([-_])/g, '$1\u200b')) + '</span></div>')));

            // Invisible rect to capture mouse events, else
            // the holes in the icon don't capture the mouse
            newG.appendChild(makeSVG('rect', {
                x: 0,
                y: 0,
                width: coords.width,
                height: coords.height,
                opacity: 0
            }));

            newG.appendChild(makeForeignObject({
                x: 48,
                y: -13,
                width: 32,
                height: 32,
                class: 'node-totem'
            }, $(`<span size="32">`)));

            let offset = {x: 0, y: 0};

            // Information sticker
            // To display when the folder has a short description
            if (angular.isDefined(folder.shortDesc) && folder.shortDesc.length > 0) {
                let coords = {
                    cx: 1,
                    cy: 55,
                    rx: 10,
                    ry: 10,
                    indicatorX: -9,
                    indicatorY: 45
                };

                drawInformationSticker(newG, coords);
                offset.y += 13;
            }

            // Discussion sticker
            // To display when the dataset has an unread discussion
            if (local && folder.discussionsFullIds.length > 0) {

                let unread = hasUnreadDiscussion(folder);
                let coords = {
                    cx: 0,
                    cy: 51.5,
                    rx: 10.5,
                    ry: 9,
                    indicatorX: -10,
                    indicatorY: 42,
                    contentX: -20,
                    contentY: 42
                };
                const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
                drawDiscussionSticker(newG, folder.discussionsFullIds.length, unread, coords, offset, {x: 0, y: isFirefox ? -2 : 0});

            }

            $(dotPolygon).replaceWith(newG);
        }
    };
}

function restyleStreamingEndpointNode(local) {
    return function(g) {
        const nodeId = $(g).attr('data-id');
        const sm = FlowGraph.node(nodeId);

        const streamingEndpoint = FlowGraph.node(nodeId);
        const dotPolygon = $(g).find('polygon');
        if (dotPolygon.length) {
            $(g).find("text").remove();
            const coords = polygonToRectData(dotPolygon);
            const newG = makeSVG('g', {class: 'newG bzicon', transform: `translate(${coords.x} ${coords.y})`});
            d3.select(newG).classed("bzicon", true);

            newG.appendChild(makeSVG('path', {
                d: "M0,0 L48,0 L64,29 L48,58 L0,58 Z",
                opacity: 1,
                class: 'fill'
            }));

            const icon = $filter("datasetTypeToIcon")(streamingEndpoint.streamingEndpointType);
            newG.appendChild(makeForeignObject({
                x: 8,
                y: 8,
                width: 42,
                height: 42,
                class: 'nodeicon'
            }, $(`<div style="text-align: center"><i class="${icon}" /></div>`)));
            
            newG.appendChild(makeSVG('g', {
                class: 'tool-simple-zone',
                transform: `translate(${coords.width + 26}, 24)`,
                'data-height': coords.height
            }));

            newG.appendChild(makeSVG('path', {
                class: 'selection-outline',
                d: "M-1,-1 L48.5,-1 L65,29 L48.5,59 L-1,59 Z"
            }));

                // x: -coords.width*0.2071,
            newG.appendChild(makeForeignObject({
                x: -30,
                y: coords.height * 1.2,
                width: coords.width + 60,
                height: 42,
                class: 'nodelabel-wrapper'
            }, $('<div><span>' + sm.name.replace(/([-_])/g, '$1\u200b') + '</span></div>')));

            newG.appendChild(makeForeignObject({
                x: 45,
                y: -10,
                width: 32,
                height: 32,
                class: 'node-totem'
            }, $(`<span size="32">`)));

            $(dotPolygon).replaceWith(newG);
        }
    }
}

function restyleRecipeNode(g) {
    const nodeId = $(g).attr('data-id');
    const recipe = FlowGraph.node(nodeId);

    const iconScale = 0.52

    const dotEllipse = $(g).find("ellipse");
    if (dotEllipse.length) {
        const coords = circleToRectData(dotEllipse);
        const newG = makeSVG('g', {class: 'newG', transform: `translate(${coords.x} ${coords.y}) scale(${iconScale}, ${iconScale})`});

        const iconText = flowIconset.icons[$filter("recipeFlowIcon")(recipe.recipeType)];
        d3.select(newG).classed("bzicon recipeicon-" + recipe.recipeType, true);

        if (recipe.recipeType.startsWith("CustomCode_") || recipe.recipeType.startsWith("App_")) {
            const colorClass = $filter("recipeTypeToColorClass")(recipe.recipeType);
            d3.select(newG).classed("universe-fill " + colorClass, true);
        }

        d3.select(g).attr("data-recipe-type", recipe.recipeType);

        let iconElt = d3.select($.parseXML(iconText)).select("svg").selectAll("g");
        // Some icons don't have a g ...
        if (iconElt.length == 0 || iconElt[0].length == 0) {
            iconElt = d3.select($.parseXML(iconText)).select("svg").selectAll("path");
        }
        if (iconElt.length == 0 || iconElt[0].length == 0) {
            iconElt = d3.select($.parseXML(iconText)).select("svg").selectAll("path");
        }
        try {
            $(dotEllipse).replaceWith(newG);
            iconElt[0].forEach(function(x){
                newG.appendChild(x);
            });
            // Invisible rect to capture mouse events, else
            // the holes in the icon don't capture the mouse
            newG.appendChild(makeSVG('rect', {
                x: 0,
                y: 0,
                width: coords.width / iconScale,
                height: coords.height / iconScale,
                opacity: 0
            }));

        } catch (e) {
            logger.error("Failed patch recipe icon", e)
        }

        // WARNING: this conflicts with graphviz layout: recipe names and other nodes can overlap.
        // newG.appendChild(makeForeignObject({
        //     x: -30,
        //     y: coords.height * 1.07,
        //     width: coords.width + 60,
        //     height: 45,
        //     class: 'nodelabel-wrapper',
        //     transform: `scale(${1/iconScale}, ${1/iconScale})`
        // }, $('<div><span>' + recipe.description.replace(/([-_])/g, '$1\u200b') + '</span></div>')));

        if (recipe.recipeType.startsWith("CustomCode_") || recipe.recipeType.startsWith("App_")){
            const icon = $filter("recipeTypeToIcon")(recipe.recipeType);
            newG.appendChild(makeForeignObject({
                x: 0,
                y: 0,
                width: SIZE,
                height: SIZE,
                class: 'nodeicon'
            }, $('<div class="recipe-custom-code-object"><i class="' + icon + '"></i></div>')));
        }

        newG.appendChild(makeSVG('g', {
            class: 'tool-simple-zone',
            transform: `translate(${SIZE}, 0) scale(${1/iconScale}, ${1/iconScale})`,
            'data-height': SIZE * iconScale
        }));

        newG.appendChild(makeSVG('circle', {
            class: 'selection-outline',
            r: 50*iconScale,
            cx: 50*iconScale,
            cy: 50*iconScale,
            transform: `scale(${1/iconScale}, ${1/iconScale})`,
        }));

        newG.appendChild(makeForeignObject({
            x: 30,
            y: -17,
            width: 32,
            height: 32,
            class: 'node-totem',
            transform: `scale(${1/iconScale}, ${1/iconScale})`
        }, $(`<span size="32">`)));

        let offset = {x: 0, y: 0};

        // Information sticker
        // To display when the recipe has a short description
        if (angular.isDefined(recipe.shortDesc) && recipe.shortDesc.length > 0) {
            let coords = {
                cx: 14,
                cy: 86,
                rx: 20,
                ry: 20,
                indicatorX: 0,
                indicatorY: 69
            };

            drawInformationSticker(newG, coords);
            offset.x += 12;
            offset.y += 26;
        }

        // Discussion sticker
        // To display when the dataset has an unread discussion
        if (recipe.discussionsFullIds.length > 0) {

            let unread = hasUnreadDiscussion(recipe);
            let coords = {
                cx: 8.5,
                cy: 84.5,
                rx: 19,
                ry: 17,
                indicatorX: -9,
                indicatorY: 69,
                contentX: -11,
                contentY: 74
            };
            drawDiscussionSticker(newG, recipe.discussionsFullIds.length, unread, coords, offset);

        }
    }
}
});


app.service('ProjectFlowGraphLayout', function(FlowGraph, LoggerProvider) {

    var logger = LoggerProvider.getLogger('flow');

    // This function takes isolated ("draft") computables
    // and move them to a container to put them next to the flow
    // Note that things are called datasets for historical reasons but they might be other things
    this.relayout = function(globalSvg) {
        const zones = $(globalSvg).find("svg");
        if (zones && zones.length > 0) {
            for (let i = 0; i < zones.length; i++) {
                this.relayoutSVG($(zones[i]), true);
            }
        } else {
            this.relayoutSVG(globalSvg, false);
        }
    };

    this.relayoutSVG = (svg, zones) => {
        const usedDatasets = makeSVG('g', { class: 'usedDatasets' });
        const inputDatasets = makeSVG('g', { class: 'inputDatasets' });
        const draftDatasets = makeSVG('g', { class: 'draftDatasets' });
        svg.find('g[class=graph]').append(usedDatasets);
        $(usedDatasets).append(inputDatasets);
        svg.find('g[class=graph]').append(draftDatasets);

        svg.find('g[data-type]').each(function (index, boxElement) {
            const nodeId = $(boxElement).data("id");
            const node = FlowGraph.node(nodeId);
            if(!node) {
                logger.warn('Graph node does not exist: ', nodeId)
                return;
            }
            // hidden stuff is related to implicit (not recipes) links like a dataset and its metric dataset for example
            if(!node.predecessors.length && !node.successors.length && !node.isHiddenLinkSource && !node.isHiddenLinkTarget) {
                draftDatasets.appendChild(boxElement);
            } else if(!node.predecessors.length && !node.isHiddenLinkTarget && !node.isHiddenLinkSource) {
                inputDatasets.appendChild(boxElement);
            } else {
                usedDatasets.appendChild(boxElement);
            }
        });

        // Relayout
        const hasChildNodes = usedDatasets.childNodes.length + inputDatasets.childNodes.length > 1;
        let datasetsPerColumns = Math.max(inputDatasets.childNodes.length, Math.floor(Math.sqrt(draftDatasets.childNodes.length)), 1);
        let gridWidth = 180;
        let gridHeight = 180;
        let columnHeight = gridHeight * datasetsPerColumns;
        if(inputDatasets.childNodes.length && !zones) {
            datasetsPerColumns = inputDatasets.childNodes.length;
            gridWidth = inputDatasets.childNodes[0].getBBox().width + 50;
            columnHeight = inputDatasets.getBBox().height;
            gridHeight = columnHeight / datasetsPerColumns;
        }
        let nbFullRows = Math.floor(draftDatasets.childNodes.length / datasetsPerColumns) || 1;
        for(let index = 0; index < draftDatasets.childNodes.length; index++) {
            // full row
            let offset = 0;
            if (nbFullRows > 0 && index >= nbFullRows * datasetsPerColumns) {
                offset = (columnHeight - gridHeight * (draftDatasets.childNodes.length % datasetsPerColumns))/2;
            }
            let dx = Math.floor(index / datasetsPerColumns) * gridWidth + 20;
            let dy = offset + index % datasetsPerColumns * gridHeight + 50;
            $(draftDatasets).children().eq(index).find('g').first().attr('transform', `translate(${dx}  ${dy})`);
        }

        //  move draftDatasets out of the way
        setTimeout(function() {
            let usedDatasetsBB = usedDatasets.getBBox();
            let draftDatasetsBB = draftDatasets.getBBox();
            let translateX = usedDatasetsBB.x - draftDatasetsBB.x - draftDatasetsBB.width - 200;
            let translateY = usedDatasetsBB.y - draftDatasetsBB.y;
            if (!zones) {
                draftDatasets.setAttribute('transform', 'translate(' + translateX + ' ' + translateY + ')');
            } else {
                let translateGraphY = hasChildNodes && draftDatasets.childNodes.length ? -usedDatasetsBB.y + 32 : hasChildNodes ? -usedDatasetsBB.y : -draftDatasetsBB.y;
                svg.find('g[class=graph]')[0].setAttribute('transform', 'translate(32,' + translateGraphY + ')');
            }
        });
    }
});


app.service('InterProjectGraphLayout', function(FlowGraph) {
    // Similar to project flow, this function takes isolated ("standalone") projects
    // and move them to a container to put them below the graph of connected (by exposed elements) projects
    this.relayout = function(svg) {
        let connectedProjects = makeSVG('g', { class: 'connectedProjects' });
        let inputProjects = makeSVG('g', { class: 'inputProjects' });
        let standAloneProjects = makeSVG('g', { class: 'standAloneProjects' });
        let projectFolders = makeSVG('g', { class: 'projectFolders' });

        svg.find('g[class=graph]').append(projectFolders);
        svg.find('g[class=graph]').append(connectedProjects);
        $(connectedProjects).append(inputProjects);
        svg.find('g[class=graph]').append(standAloneProjects);

        svg.find('g[data-type]').each(function (index, boxElement) {
            let node = FlowGraph.node($(boxElement).data("id"));
            // if its a draft dataset, move it to another elt
            if (node.nodeType == "PROJECT_FOLDER") {
                projectFolders.appendChild(boxElement);
            } else if (!node.predecessors.length && !node.successors.length) {
                standAloneProjects.appendChild(boxElement);
            } else if (!node.predecessors.length) {
                inputProjects.appendChild(boxElement);
            } else {
                connectedProjects.appendChild(boxElement);
            }
        });

        // Relayout
        let minProjectsPerRow = 3;
        let maxProjecsPerRow = 10;

        let projectsPerRows = Math.min(Math.max(minProjectsPerRow, Math.floor(Math.sqrt(standAloneProjects.childNodes.length))), maxProjecsPerRow);
        let cellMargin = 20
        let cellWidth = 150 + cellMargin;
        let cellHeight = 100 + cellMargin;
        let pfCellHeight = 40 + cellMargin;
        let rowWidth = cellWidth * projectsPerRows;
        if (inputProjects.childNodes.length) {
            cellWidth = inputProjects.childNodes[0].getBBox().width + 50;
            cellHeight = inputProjects.childNodes[0].getBBox().height + cellMargin;
            projectsPerRows = Math.min(Math.max(minProjectsPerRow, Math.floor(connectedProjects.getBBox().width / cellWidth)), maxProjecsPerRow);
        }
        if (projectFolders.childNodes.length) {
            pfCellHeight = projectFolders.childNodes[0].getBBox().height + cellMargin;
        }
        for(let index = 0; index < standAloneProjects.childNodes.length; index++) {
            let tr = (index % projectsPerRows) * cellWidth +' '+ Math.floor(index / projectsPerRows) * cellHeight;
            $(standAloneProjects).children().eq(index).find('g').first()
                .attr('transform', 'translate('+ tr +')');
        }
        for (let index = 0; index < projectFolders.childNodes.length; index++) {
            let tr = (index % projectsPerRows) * cellWidth + ' ' + Math.floor(index / projectsPerRows) * pfCellHeight;
            $(projectFolders).children().eq(index).find('g').first()
                .attr('transform', 'translate(' + tr + ')');
        }
        //  move standAloneProjects out of the way
        let connectedProjectsBB = connectedProjects.getBBox();
        let standAloneProjectsBB = standAloneProjects.getBBox();
        let sapTranslateX = connectedProjectsBB.x;
        let sapTranslateY = connectedProjectsBB.y + connectedProjectsBB.height + 100;
        standAloneProjects.setAttribute('transform', 'translate(' + sapTranslateX + ' ' + sapTranslateY + ')');
        // move projectFolders out of the way (upside)
        let projectFoldersBB = projectFolders.getBBox();
        let pfTranslateX = connectedProjectsBB.x;
        let pfTranslateY = connectedProjectsBB.y - (projectFoldersBB.height + 100);
        projectFolders.setAttribute('transform', 'translate(' + pfTranslateX + ' ' + pfTranslateY + ')');
    };
});


app.service('InterProjectGraphStyling', function($filter, ImageUrl, FlowGraph, CachedAPICalls, LoggerProvider, $sanitize) {

    const SIZE = 100;

    const logger = LoggerProvider.getLogger('projectsGraph');

    const formatters = {
        'PROJECT_FOLDER': restyleNodeForProjectFolder,
        'PROJECT': restyleNodeForProject,
        'BUNDLE_EO': restyleNodeForExposedObject,
    };
    let flowIconset;
    CachedAPICalls.flowIcons.success(function(data) {
        flowIconset = data;
    });

    this.restyleGraph = function(svg, graph) {
        svg.find('title').remove();
        svg.find('g[data-type]').each(function (index, g) {
            try {
                restyleNode(g);
            } catch (e) {
                logger.error("Failed to restyle flow node: ", e);
            }
        });
    };

    function restyleNode(g) {
        const nodeType = $(g).attr('data-type');
        if (formatters[nodeType]) {
            formatters[nodeType](g);
        }
    };

    function createExposedObjectSvg(nodeIcons, index, x, y, d) {
        const g = makeSVG('g', {
            class: nodeIcons[index].type,
            transform: 'translate(' + x + ' ' + y + ') scale(' + d/SIZE +',' + d/SIZE +')'
        });
        nodeIcons[index].elt[0].forEach(function(x){
            g.appendChild(x);
        });
        addCountToExposedObjectSvg(g, nodeIcons, index, x, y, d)
        return g
    }

    function addCountToExposedObjectSvg(g, nodeIcons, index, x, y, d) {
        const r = SIZE / 5;
        const cx = SIZE/2 + SIZE/(2 * Math.sqrt(2));
        const cy = SIZE/2 + SIZE/(2 * Math.sqrt(2));

        const circle = makeSVG('circle', {
            r: r,
            cx: cx,
            cy: cy,
            class: 'count-circle'
        });

        const text = makeSVG('text', {
            x: cx,
            y: cy,
            class: "count-text"
        });
        text.textContent = nodeIcons[index].nbElements;

        g.appendChild(circle);
        g.appendChild(text);
    }

    // several exposed objects (of different type) will result in one nodes containing several icons
    function drawExposedObjectNodeIcons(newG, nodeIcons, coords) {
        switch (nodeIcons.length) {
            case 1: {
                const g0 = createExposedObjectSvg(nodeIcons, 0, 1, 1, coords.width - 2);
                newG.appendChild(g0);
                break;
            }
            case 2: {
                const diameter = (coords.width - 2)/2;

                const x0 = 1;
                const y0 = 1 + coords.height/4;
                const g0 = createExposedObjectSvg(nodeIcons, 0, x0, y0, diameter);
                newG.appendChild(g0);

                const x1 = 1 + coords.width/2;
                const y1 = 1 + coords.height/4;
                const g1 = createExposedObjectSvg(nodeIcons, 1, x1, y1, diameter);
                newG.appendChild(g1);

                break;
            }
            case 3: {
                const diameter = (coords.width - 2)/2;

                const x0 = 1;
                const y0 = 1 + coords.height/4;
                const g0 = createExposedObjectSvg(nodeIcons, 0, x0, y0, diameter);
                newG.appendChild(g0);

                const x1 = 1 + coords.width/2;
                const y1 = 1;
                const g1 = createExposedObjectSvg(nodeIcons, 1, x1, y1, diameter);
                newG.appendChild(g1);

                const x2 = 1 + coords.width/2;
                const y2 = 1 + coords.height/2;
                const g2 = createExposedObjectSvg(nodeIcons, 2, x2, y2, diameter);
                newG.appendChild(g2);

                break;
            }
            case 4: {
                const diameter = (coords.width - 2)/2;

                const x0 = 1;
                const y0 = 1;
                const g0 = createExposedObjectSvg(nodeIcons, 0, x0, y0, diameter);
                newG.appendChild(g0);

                const x1 = 1;
                const y1 = 1 + coords.height/2;;
                const g1 = createExposedObjectSvg(nodeIcons, 1, x1, y1, diameter);
                newG.appendChild(g1);

                const x2 = 1 + coords.width/2;
                const y2 = 1;
                const g2 = createExposedObjectSvg(nodeIcons, 2, x2, y2, diameter);
                newG.appendChild(g2);

                const x3 = 1 + coords.width/2;
                const y3 = 1 + coords.height/2;
                const g3 = createExposedObjectSvg(nodeIcons, 3, x3, y3, diameter);
                newG.appendChild(g3);

                break;
            }
            case 5: {
                const diameter = (coords.width - 2)/3;

                const x0 = 1 + coords.width/3;
                const y0 = 1 ;
                const g0 = createExposedObjectSvg(nodeIcons, 0, x0, y0, diameter);
                newG.appendChild(g0);

                const x1 = 1;
                const y1 = 1 + coords.height/3;
                const g1 = createExposedObjectSvg(nodeIcons, 1, x1, y1, diameter);
                newG.appendChild(g1);

                const x2 = 1 + coords.width/3;
                const y2 = 1 + coords.height/3;
                const g2 = createExposedObjectSvg(nodeIcons, 2, x2, y2, diameter);
                newG.appendChild(g2);

                const x3 = 1 + coords.width * 2/3;
                const y3 = 1 + coords.height/3;
                const g3 = createExposedObjectSvg(nodeIcons, 3, x3, y3, diameter);
                newG.appendChild(g3);

                const x4 = 1 + coords.width/3;
                const y4 = 1 + coords.height * 2/3;
                const g4 = createExposedObjectSvg(nodeIcons, 4, x4, y4, diameter);
                newG.appendChild(g4);
            }
        }
    }

    function restyleNodeForProjectFolder(g) {
        const nodeId = $(g).attr('data-id');
        const projectFolder = FlowGraph.node(nodeId);
        const dotPolygon = $(g).find('polygon');

        //replacing polygon by g of same size
        const coords = polygonToRectData(dotPolygon);
        const newG = makeSVG('g', {class: 'newG', transform: 'translate(' + coords.x + ' ' + coords.y + ')'});
        $(dotPolygon).replaceWith(newG);
        $(g).find("text").remove();

        // fill
        newG.appendChild(makeSVG('rect', {
            x: 0,
            y: 0,
            width: coords.width,
            height: coords.height,
            class: 'fill'
        }));

        // html-content
        newG.appendChild(makeForeignObject(
            {
                x: 0,
                y: 0,
                width: coords.width,
                height: coords.height,
                class: 'project-folder-meta nodelabel-wrapper'
            },
            $(
                '<div>' +
                    '<p class="single-line"><i class="icon-folder-close"></i>' + $sanitize(projectFolder.description.replace(/([-_])/g, '$1\u200b')) + '</p>' +
                '</div>'
            )
        ));
    }

    function restyleNodeForProject(g) {
        const nodeId = $(g).attr('data-id');
        const project = FlowGraph.node(nodeId);
        const dotPolygon = $(g).find('polygon');

        //replacing polygon by g of same size
        const coords = polygonToRectData(dotPolygon);
        const newG = makeSVG('g', {class: 'newG',
            transform: 'translate(' + coords.x + ' ' + coords.y + ')'
        });
        if (project.isArchived) {
            d3.select(newG).classed("archived", true);
        }
        if (project.isForbidden) {
            d3.select(newG).classed("forbidden", true);
        }
        if (project.isNotInFolder) {
            d3.select(newG).classed("not-in-folder", true);
        }
        $(dotPolygon).replaceWith(newG);
        $(g).find("text").remove();

        //fill
        newG.appendChild(makeSVG('rect', {
            x: 0,
            y: 0,
            width: coords.width,
            height: coords.height,
            class: 'fill'
        }));

        // html-content
        newG.appendChild(makeForeignObject(
            {
                x: 0,
                y: 0,
                width: coords.width,
                height: coords.height,
                class: 'project-meta nodelabel-wrapper'
            },
            $(
                '<div>' +
                    '<i class="img-area">' + (project.isForbidden ? '' : ('<img src="' + ImageUrl(project.name, project.projectKey, project.projectKey, "PROJECT", project.objectImgHash, "80x200", project.imgColor, project.imgPattern, project.showInitials) + '" />')) + '</i>' +
                    '<p>' + $sanitize(project.description.replace(/([-_])/g, '$1\u200b')) + '</p>' +
                '</div>'
            )
        ));

        if (project.projectAppType === 'APP_TEMPLATE') {
            const appIconSize = 25;
            newG.appendChild(makeForeignObject(
                {
                    x: 0,
                    y: coords.height - appIconSize,
                    width: appIconSize,
                    height: appIconSize,
                    class: 'project-meta'
                },
                $(`
                    <div class="app-template-overlay app-template-overlay--graph" title="${project.isAppAsRecipe ? 'Application-as-recipe' : 'Visual application'} template">
                        <i class="${project.isAppAsRecipe ? 'icon-dku-application-as-recipe' : 'icon-project-app'}"></i>
                    </div>
                `)
            ));
        }

        // forbidden-project (we can still see it because we can read exposed object from it)
        if (project.isForbidden) {
            newG.appendChild(makeForeignObject({
                x: 113,
                y: 64,
                width: 30,
                height: 30,
                class: 'forbidden-icon'
            }, $('<div><i class="icon-lock" /></div>')));

        }

        // forbidden-project (we can still see it because we can read exposed object from it)
        if (project.isNotInFolder) {
            newG.appendChild(makeForeignObject({
                x: 35,
                y: 63,
                width: 30,
                height: 30,
                class: 'not-in-folder-icon'
            }, $('<div><span class="icon-stack"><i class="icon-folder-close"></i><i class="icon-ban-circle icon-stack-base"></i></span></div>')));

        }
    }

    function restyleNodeForExposedObject(g) {
        const icons = [];
        function addIcon (type, nbElements) {
            const icon = {};
            const iconText = flowIconset.icons[type];
            let iconElt = d3.select($.parseXML(iconText)).select("svg").selectAll("circle, path, rect");
            icon.elt = iconElt;
            icon.type = type;
            icon.nbElements = nbElements;
            icons.push(icon);
        }

        function addIcons(bundle) {
            if (bundle.exposedDatasets.length > 0) {
                addIcon("eo_datasets", bundle.exposedDatasets.length);
            }
            if (bundle.exposedFolders.length > 0) {
                addIcon("eo_folders", bundle.exposedFolders.length);
            }
            if (bundle.exposedModels.length > 0) {
                addIcon("eo_models", bundle.exposedModels.length);
            }
            if (bundle.exposedNotebooks.length > 0) {
                addIcon("eo_notebooks", bundle.exposedNotebooks.length);
            }
            if (bundle.exposedWebApps.length > 0) {
                addIcon("eo_webapps", bundle.exposedWebApps.length);
            }
            if (bundle.exposedReports.length > 0) {
                addIcon("eo_reports", bundle.exposedReports.length);
            }
            if (bundle.errorMessages.length > 0) {
                addIcon("error", bundle.errorMessages.length);
            }
        }

        const nodeId = $(g).attr('data-id');
        const bundle = FlowGraph.node(nodeId);

        const dotEllipse = $(g).find("ellipse");

        const coords = circleToRectData(dotEllipse);
        const newG = makeSVG('g', {class: 'newG', transform: `translate(${coords.x} ${coords.y})` });
        d3.select(newG).classed("bzicon", true);

        addIcons(bundle);
        if (icons.length == 0) {
            throw new Error("No icons for type", bundle);
        }
        drawExposedObjectNodeIcons(newG, icons, coords);

        try {
            $(dotEllipse).replaceWith(newG);
            // Invisible rect to capture mouse events, else
            // the holes in the icon don't capture the mouse
            newG.appendChild(makeSVG('rect', {
                x: 0,
                y: 0,
                width: coords.width,
                height: coords.height,
                opacity: 0
            }));
        } catch (e) {
        }

        const text = $(g).find('text:not(.count-text)');
        text.remove();
    }
});


app.service('FlowGraphFiltering', function(TimingService) {

    this.filterGraph = TimingService.wrapInTimePrinter("FlowGraphFiltering::filterGraph", function(svg, filter) {

        let d3node = d3.select(svg[0]);
        filter.keptNodes && d3node.selectAll('.node').classed('filter-remove', true).classed('filter-keep', false).classed('no-animation',true);
        filter.keptEdges && d3node.selectAll('.edge').classed('filter-remove', true).classed('filter-keep', false).classed('no-animation',true);

		let nodeIdMap = {};
		let nodeToMap = {};
        if (filter.keptNodes || filter.keptEdges) {
			// Build a simple  element-map on-the-fly to avoid having repeated calls of the form: svg.find(' [data-id="' + nodeId + '"]')[0];
			// This is a major performance improvement on larger flows

			svg.find('*').each(function (_, elt) {
				if (filter.keptNodes) {
					const nodeId = $(elt).attr('data-id');
					if (nodeId) nodeIdMap[nodeId] = elt;
				}
				if (filter.keptEdges) {
					const nodeTo = $(elt).attr('data-to');
					if (nodeTo) {
						if (nodeToMap[nodeTo] == undefined) nodeToMap[nodeTo] = [];
						nodeToMap[nodeTo].push(elt);
					}
				}
			});
		}

		filter.keptNodes && $.each(filter.keptNodes, function (idx, nodeId) {
			let elt = nodeIdMap[nodeId];
            if (elt == null) {
                // maybe a saved model
                const savedmodel_nodeId = 'savedmodel' + nodeId.substring('dataset'.length);
                elt = nodeIdMap[nodeId];
            }
            if (elt == null) {
                // maybe a model evaluation store
                const modelevaluationstore_nodeId = 'modelevaluationstore' + nodeId.substring('dataset'.length);
                elt = nodeIdMap[nodeId];
            }
			if (elt == null) {
				// or managed folder
				const managedfolder_nodeId = 'managedfolder' + nodeId.substring('dataset'.length);
				elt = nodeIdMap[nodeId];
			}
			if (elt == null) {
				return;
			}
			d3.select(elt).classed('filter-remove', false).classed('filter-keep', true);
		});

		$.each(filter.keptEdges, function (idx, toNodeId) {

			if (nodeToMap[toNodeId]) nodeToMap[toNodeId].forEach(function (elt) {
				d3.select(elt).classed('filter-remove', false).classed('filter-keep', true);
			});
            const savedmodel_nodeId = 'savedmodel' + toNodeId.substring('dataset'.length);
            if (nodeToMap[savedmodel_nodeId]) nodeToMap[savedmodel_nodeId].forEach(function (elt) {
                d3.select(elt).classed('filter-remove', false).classed('filter-keep', true);
            });
            const modelevaluationstore_nodeId = 'modelevaluationstore' + toNodeId.substring('dataset'.length);
            if (nodeToMap[modelevaluationstore_nodeId]) nodeToMap[modelevaluationstore_nodeId].forEach(function (elt) {
                d3.select(elt).classed('filter-remove', false).classed('filter-keep', true);
            });
			const managedfolder_nodeId = 'managedfolder' + toNodeId.substring('dataset'.length);
			if (nodeToMap[managedfolder_nodeId]) nodeToMap[managedfolder_nodeId].forEach(function (elt) {
				d3.select(elt).classed('filter-remove', false).classed('filter-keep', true);
			});
		});
        if (filter.removeFadedElements) {
            svg.find('.filter-remove').remove();
        }
        d3node.selectAll('.node').classed('no-animation',false);
        d3node.selectAll('.edge').classed('no-animation',false);
    });

    //TODO @flow move to another service
    this.getBBoxFromSelector = function (globalSvg, selector) {
        const svgs = $(selector).closest('svg'); // Retrieve correct svg (Mostly in case of zones)
        let gTopLeft, gBottomRight;
        svgs.each(function() {
            const svg = $(this);
            let topLeft, bottomRight;
            function addItemToBBox(refBBox) {
                return function() {
                    let bbox = this.getBBox();
                    if (refBBox && svg.is(globalSvg)) {
                        // "draftDatasets" (unconnected objects) have been translated,
                        // We need to compensate for that (Only when no zones are present)
                        bbox = {
                            x: bbox.x + refBBox.x,
                            y: bbox.y + refBBox.y,
                            width: bbox.width,
                            height: bbox.height,
                        };
                    }

                    if (topLeft === undefined) {
                        topLeft = svg[0].createSVGPoint();
                        topLeft.x = bbox.x;
                        topLeft.y = bbox.y;

                        bottomRight = svg[0].createSVGPoint();
                        bottomRight.x = bbox.x + bbox.width;
                        bottomRight.y = bbox.y + bbox.height;
                    } else {
                        topLeft.x = Math.min(topLeft.x, bbox.x);
                        topLeft.y = Math.min(topLeft.y, bbox.y);

                        bottomRight.x = Math.max(bottomRight.x, bbox.x + bbox.width);
                        bottomRight.y = Math.max(bottomRight.y, bbox.y + bbox.height);
                    }
                }
            }
            const graphBBox = svg.find('g.graph')[0].getBBox();
            const isZone = $(selector).parentsUntil(svg, '.usedDatasets').length === 0 && $(selector).parentsUntil(svg, '.draftDatasets').length === 0;
            const matrix = isZone ? svg[0].getTransformToElement(globalSvg[0]) : $('.usedDatasets', svg)[0].getTransformToElement(globalSvg[0]);

            if (isZone) {
                svg.find(selector).each(addItemToBBox());
            } else {
                $('.usedDatasets', svg).find(selector).each(addItemToBBox());
                $('.draftDatasets', svg).find(selector).each(addItemToBBox(graphBBox));
            }

            if (topLeft === undefined) {
                //console.info("Cannot compute bounding box around empty set of items");
                return undefined;
            }

            topLeft = topLeft.matrixTransform(matrix);
            bottomRight = bottomRight.matrixTransform(matrix);

            if (gTopLeft === undefined) {
                gTopLeft = { x: topLeft.x, y: topLeft.y };
                gBottomRight = { x: bottomRight.x, y: bottomRight.y };
            } else {
                gTopLeft.x = Math.min(gTopLeft.x, topLeft.x);
                gTopLeft.y = Math.min(gTopLeft.y, topLeft.y);

                gBottomRight.x = Math.max(gBottomRight.x, bottomRight.x);
                gBottomRight.y = Math.max(gBottomRight.y, bottomRight.y);
            }
        });

        if (gTopLeft === undefined) {
            return undefined;
        }

        return {
            x: gTopLeft.x,
            y: gTopLeft.y,
            width: gBottomRight.x - gTopLeft.x,
            height: gBottomRight.y - gTopLeft.y
        };
    };

    this.fadeOut = function(svg, filter) {
        // Fade out nodes that need to
        if (filter && filter.doFading) {
            let d3node = d3.select(svg[0]);
            d3node.selectAll('.node').classed('filter-faded', true);
            d3node.selectAll('.edge').classed('filter-faded', true);

            $.each(filter.nonFadedNodes, function(idx, nodeId) {
                let elt = svg.find(' [data-id="' + nodeId + '"]')[0];
                if (elt == null) {
                    // maybe a saved model
                    let savedmodel_nodeId = 'savedmodel' + nodeId.substring('dataset'.length);
                    elt = svg.find(' [data-id="' + savedmodel_nodeId + '"]')[0];
                    if (elt == null) {
                        // maybe a model evaluation store
                        let modelevaluationstore_nodeId = 'modelevaluationstore' + nodeId.substring('dataset'.length);
                        elt = svg.find(' [data-id="' + modelevaluationstore_nodeId + '"]')[0];
                        if (elt == null) {
                            // or managed folder
                            let managedfolder_nodeId = 'managedfolder' + nodeId.substring('dataset'.length);
                            elt = svg.find(' [data-id="' + managedfolder_nodeId + '"]')[0];
                            if (elt == null) {
                                return;
                            }
                        }
                    }
                }
                d3.select(elt).classed('filter-faded', false);
            });
            $.each(filter.nonFadedEdges, function(idx, toNodeId) {
                svg.find(' [data-to="' + toNodeId + '"]').each(function () {
                    d3.select(this).classed('filter-faded', false);
                });
                let savedmodel_nodeId = 'savedmodel' + toNodeId.substring('dataset'.length);
                svg.find(' [data-to="' + savedmodel_nodeId + '"]').each(function () {
                    d3.select(this).classed('filter-faded', false);
                });
                let modelevaluationstore_nodeId = 'modelevaluationstore' + toNodeId.substring('dataset'.length);
                svg.find(' [data-to="' + modelevaluationstore_nodeId + '"]').each(function () {
                    d3.select(this).classed('filter-faded', false);
                });
                let managedfolder_nodeId = 'managedfolder' + toNodeId.substring('dataset'.length);
                svg.find(' [data-to="' + managedfolder_nodeId + '"]').each(function () {
                    d3.select(this).classed('filter-faded', false);
                });
            });
        }
    };
});


function polygonToRectData(polygon) { // polygon is an svg element
    const points = $(polygon).attr('points').split(' ');
    // points = [top right, top left, bottom left, bottom right, top right]
    return {
        x: parseFloat(points[1].split(',')[0]),
        y: parseFloat(points[1].split(',')[1]),
        width: parseFloat(points[0].split(',')[0], 10) - parseFloat(points[1].split(',')[0], 10),
        height: parseFloat(points[2].split(',')[1], 10) - parseFloat(points[1].split(',')[1], 10)
    };
}

function circleToRectData(ellipse) {// ellipse is an svg element
    const el = $(ellipse);
    return {
        x: el.attr('cx') - el.attr("rx"),
        y: el.attr('cy') - el.attr("ry"),
        width: el.attr('rx') * 2,
        height: el.attr('ry') * 2
    };
}

function makeForeignObject(attrs, jq) {
    const el = makeSVG('foreignObject', attrs)
    $(el).append(jq);
    return el;
}

})();

(function() {
'use strict';

/**
* Main flow page functionalities
*/
const app = angular.module('dataiku.flow.project', ['dataiku.flow.graph']);

app.directive('flowRightColumn', function(QuickView, TaggableObjectsUtils, FlowGraphSelection, FlowGraph) {
    return {
        scope: true,
        link: function(scope, element, attrs) {
            scope.QuickView = QuickView;

            scope.$watch("rightColumnItem", function() {
                scope.context = "FLOW";
                scope.selection = {
                    selectedObject: scope.rightColumnItem,
                    confirmedItem: scope.rightColumnItem
                };
            });

            scope.getSelectedNodes = function() {
                return scope.rightColumnSelection || [];
            };

            scope.getSelectedTaggableObjectRefs = function() {
                return scope.getSelectedNodes().map(TaggableObjectsUtils.fromNode);
            };

            scope.computeMovingImpact = function() {
                    var computedImpact = [];
                    var movingItems = FlowGraphSelection.getSelectedTaggableObjectRefs();

                    function addSuccessors(node, original) {
                        if (node.nodeType != "RECIPE") return;
                        node.successors.forEach(function(successor) {
                            let newTaggableObjectRef = TaggableObjectsUtils.fromNode(FlowGraph.node(successor));
                            if (original && successor == original.id || movingItems.filter(it => it.id == newTaggableObjectRef.id).length) return;
                            computedImpact.push(newTaggableObjectRef);
                        });
                    }
                    function computeImpact(node) {
                        let predecessor = node.predecessors[0];
                        if (predecessor && node.nodeType != "RECIPE") {
                            let newTaggableObjectRef = TaggableObjectsUtils.fromNode(FlowGraph.node(predecessor));
                            if (computedImpact.filter(it => it.id == newTaggableObjectRef.id).length) return;
                            if (!movingItems.filter(it => it.id == newTaggableObjectRef.id).length) {
                                computedImpact.push(newTaggableObjectRef);
                            }
                            addSuccessors(FlowGraph.node(predecessor), node);
                        }

                        addSuccessors(node);
                    }

                    FlowGraphSelection.getSelectedNodes().forEach(function(node) {
                        let realNode = node.usedByZones.length ? FlowGraph.node(`zone__${node.ownerZone}__${node.realId}`) : node;
                        computeImpact(realNode);
                    });
                    return computedImpact;
                }
        }
    };
});



// WARNING Keep the switch in sync with other _XXX_MassActionsCallbacks controllers (flow, taggable objects pages, list pages)
app.controller('FlowMassActionsCallbacks', function($scope, $controller, $rootScope, FlowTool, FlowGraphSelection, PIPELINEABILITY_ACTIONS) {

    $scope.onAction = function(action) {
        switch (action) {
            case 'action-delete':
                reloadGraph();
                FlowGraphSelection.clearSelection();
                break;
            case 'action-tag':
                refreshFlowStateWhenViewIsActive(['TAGS']);
                break;
            case 'action-watch':
            case 'action-star':
                refreshFlowStateWhenViewIsActive(['WATCH']);
                $rootScope.$emit('userInterestsUpdated');
                break;
            case 'action-clear':
                reloadGraph();
                break;
            case 'action-build':
                reloadGraph();
                break;
            case 'action-change-connection':
                reloadGraph();
                break;
            case 'action-update-status':
                refreshFlowStateWhenViewIsActive(['COUNT_OF_RECORDS', 'FILESIZE']);
                break;
            case 'action-set-auto-count-of-records':
                refreshFlowStateWhenViewIsActive(['COUNT_OF_RECORDS']);
                break;
            case 'action-set-virtualizable':
                reloadGraph();
                break;
            case 'action-add-to-scenario':
                refreshFlowStateWhenViewIsActive(['SCHEDULING']);
                break;
            case 'action-share':
                reloadGraph();
                break;
            case 'action-unshare':
                reloadGraph();
                FlowGraphSelection.clearSelection();
                break;
            case 'action-change-recipes-engines':
                refreshFlowStateWhenViewIsActive();
                break;
            case 'action-change-spark-config':
                refreshFlowStateWhenViewIsActive(['SPARK_CONFIG']);
                break;
            case PIPELINEABILITY_ACTIONS.changeSpark:
                refreshFlowStateWhenViewIsActive(['SPARK_PIPELINES']);
                break;
            case PIPELINEABILITY_ACTIONS.changeSQL:
                refreshFlowStateWhenViewIsActive(['SQL_PIPELINES']);
                break;
            case 'action-change-impala-write-mode':
                refreshFlowStateWhenViewIsActive(['IMPALA_WRITE_MODE']);
                break;
            case 'action-change-hive-engine':
                refreshFlowStateWhenViewIsActive(['HIVE_MODE']);
                break;
            case 'action-change-spark-engine':
                refreshFlowStateWhenViewIsActive(['SPARK_ENGINE']);
                break;
            case 'action-convert-to-hive':
            case 'action-convert-to-impala':
                reloadGraph();
                break;
            case 'action-change-python-env':
            case 'action-change-r-env':
                refreshFlowStateWhenViewIsActive();
                break;
            default:
                break;
        }
    }

    /*
    * Refresh the flow state only for some views
    * (or all is not specified)
    */
    function refreshFlowStateWhenViewIsActive(viewNames) {
        const currentTool = FlowTool.getCurrent();
        if (currentTool.def && (!viewNames || !viewNames.length || viewNames.includes(currentTool.def.getName()))) {
            currentTool.refreshState();
        }
    }

    /*
    * Fetch the whole flow + the view state if any active
    */
    function reloadGraph() {
        $rootScope.$emit('reloadGraph');
    }
});


app.directive('flowEditor', function($compile, $state, $stateParams, $timeout, $rootScope, $controller, Debounce, GraphZoomTrackerService,
            Assert, TopNav, CreateModalFromTemplate, DataikuAPI, ContextualMenu, HistoryService, Logger, StateUtils, TaggableObjectsUtils, localStorageService,
            FlowGraphSelection, FlowToolsRegistry, FlowToolsUtils, FlowGraph, FlowGraphFiltering, FlowFilterQueryService, FlowGraphFolding, executeWithInstantDigest, Notification, $q, MessengerUtils) {

function drawExposedIndicators(svg, nodesGraph) {
    svg.find('.exposed-indicator').remove();

    svg.find('g[data-type=LOCAL_DATASET], g[data-type=LOCAL_SAVEDMODEL], g[data-type=LOCAL_MODELEVALUATIONSTORE], g[data-type=LOCAL_MANAGED_FOLDER]').each(function (index, boxElement) {
        const nodeId = $(boxElement).attr('data-id');
        const node = nodesGraph.nodes[nodeId];
        if (!node) {
            Logger.warn("Graph node not found:", nodeId);
            return;
        }
        if (node.isExposed) {
            const type = {
                LOCAL_DATASET: 'dataset',
                LOCAL_SAVEDMODEL: 'model',
                LOCAL_MODELEVALUATIONSTORE: 'evaluation store',
                LOCAL_MANAGED_FOLDER: 'folder'
            }[$(boxElement).data('type')];

            const exposedSVG = $(makeSVG('foreignObject', {
                    x: 2,
                    y: 2,
                    width: 20,
                    height: 20,
                    class: 'exposed-indicator nodeicon-small'+(type == 'dataset' ? '' : '-dark')
                }))
                .append($(`<div><i class="icon-mail-forward" title="This ${type} is exposed in other projects"></i></div>`));
            if (type == 'folder') {
                $(boxElement).find('>g').first().append(exposedSVG);
            } else {
                $(boxElement).find('>g').append(exposedSVG);
            }
        }
    });
}

function drawBuildInProgressIndicators(svg, nodesGraph) {
    svg.find('.build-indicator').remove();

    svg.find('g[data-type=LOCAL_DATASET], g[data-type=LOCAL_SAVEDMODEL], g[data-type=LOCAL_MODELEVALUATIONSTORE], g[data-type=LOCAL_MANAGED_FOLDER]').each(function (index, boxElement) {
        let nodeId = $(boxElement).attr('data-id');
        let node = nodesGraph.nodes[nodeId];

        if (!node) {
            Logger.warn("Graph node not found:", nodeId)
            return;
        }

        let iconDom = null;
        if (node.beingBuilt) {
            iconDom = $('<div class="icon-being-built"><i class="icon-play" /></div>');
        } else if (node.aboutToBeBuilt) {
            iconDom = $('<div class="icon-about-to-be-built"><i class="icon-spinner"></i></div>');
        }
        if (iconDom) {
            let $pinSvg = $(makeSVG('foreignObject', {
                    x: 75,
                    y: 55,
                    width: 20,
                    height: 20,
                    'class': 'build-indicator'
            })).append(iconDom);

            if ($(boxElement).data('type') == 'LOCAL_MANAGED_FOLDER') {
                $(boxElement).find('>g').first().append($pinSvg);
            } else {
                $(boxElement).find('>g').append($pinSvg);
            }
        }
    });

    svg.find('g[data-type=RECIPE]').each(function (index, boxElement) {
        let nodeId = $(boxElement).attr('data-id');
        let node = nodesGraph.nodes[nodeId];

        if (!node) {
            Logger.warn("Graph node not found:", nodeId)
            return;
        }

        let iconDom = null;
        if (node.continuousActivityDone) {
            iconDom = $('<div class="icon-continuous-activity-done"><i class="icon-warning-sign" /></div>');
        } else if (node.beingBuilt) {
            iconDom = $('<div class="icon-being-built"><i class="icon-play" /></div>');
        }
        if (iconDom) {
            let $pinSvg = $(makeSVG('foreignObject', {
                    x: 55,
                    y: 40,
                    width: 20,
                    height: 20,
                    'class': 'build-indicator',
                    transform: 'scale(1.92 1.92)'  // scale to conteract the 0.52 iconScale
            })).append(iconDom);

            $(boxElement).find('>g').append($pinSvg);
        }
    });
}

return {
    restrict: 'EA',
    scope: true,
    controller: function($scope, $element) {
        $controller('FlowMassActionsCallbacks', {$scope: $scope});

        TopNav.setLocation(TopNav.TOP_FLOW, "flow", TopNav.TABS_NONE, null);
        TopNav.setNoItem();

        $scope.projectFlow = true;
        $scope.nodesGraph = {flowFiltersAndSettings : {}};

        $scope.getZoneColor = zoneId => {
            const nodeFound = $scope.nodesGraph.nodes ? $scope.nodesGraph.nodes[`zone_${zoneId}`] : undefined;
            if (nodeFound && nodeFound.customData) {
                return nodeFound.customData.color
            }
            return "#ffffff";
        };

        function updateUserInterests() {
            DataikuAPI.interests.getUserInterests($rootScope.appConfig.login, 0, 10000, {projectKey: $stateParams.projectKey}).success(function(data) {
                // It would be nice to fetch that with the graph but it is a little dangerous to require the database to be functional to see any flow...
                $scope.userInterests = data.interests.filter(x => ['RECIPE', 'DATASET', 'SAVED_MODEL', 'MODEL_EVALUATION_STORE', 'MANAGED_FOLDER'].includes(x.objectType));

                const indexedInterests = {};
                $scope.userInterests.forEach(function(interest) {
                    //TODO @flow using the node ids as keys would be better but we don't generate them in js for now (I think)
                    indexedInterests[interest.objectType+'___'+interest.objectId] = interest;
                });
                $.each($scope.nodesGraph.nodes, function(nodeId, node) {
                    const taggableType = TaggableObjectsUtils.fromNodeType(node.nodeType);
                    const interest = indexedInterests[taggableType+'___'+node.name]
                    if (interest) {
                        node.interest = interest;
                    } else {
                        node.interest = {
                            starred: false,
                            watching: false
                        };
                    }
                });

            }).error(setErrorInScope.bind($scope));
        }



        $scope.createGraphFilteringObject = function (keptNodes) {
            return {
                keptNodes: keptNodes,
                keptEdges: keptNodes,
                doFading: true,
                nonFadedNodes: [],
                nonFadedEdges: [],
                removeFadedElements: false
            };
        };
        $scope.applyNodeFiltering = function (filteredNodes) {
            $rootScope.$emit('drawGraph');

            $.each(FlowGraph.get().nodes, (key, node) => {
                node.filterRemove = !filteredNodes.includes(key);
            });

            FlowGraphSelection.clearSelection();
            $scope.zoomToBbox(FlowGraphFiltering.getBBoxFromSelector($scope.svg, '.node:not(.filter-remove)'));
        };

        $scope.isNotInGraph = function(item) {
            return $scope.nodesGraph && $scope.nodesGraph.nodes &&
                ! $scope.nodesGraph.nodes.hasOwnProperty('dataset_' + item.name);
        };

        $scope.processSerializedFilteredGraphResponse = function (serializedFilteredGraph, zoomTo) {
            $scope.setGraphData(serializedFilteredGraph.serializedGraph);
            if (typeof zoomTo === 'string') {
                const deregisterListener = $scope.$root.$on("flowDisplayUpdated", function () {
                    deregisterListener();
                    setTimeout(() => {
                        let id = zoomTo;
                        let node = $scope.nodesGraph.nodes[zoomTo];
                        if (!node) {
                            id = graphVizEscape(zoomTo);
                            node = $scope.nodesGraph.nodes[id];
                        }
                        if (!node && $scope.nodesGraph.hasProjectZones) {
                            id = Object.values($scope.nodesGraph.nodes).filter(it => it.realId == id && !it.usedByZones.length)[0].id;
                        }
                        $scope.zoomGraph(id);
                        GraphZoomTrackerService.instantSavePanZoomCtx($scope.panzoom);
                        GraphZoomTrackerService.setFocusItemCtx($scope.nodesGraph.nodes[id]);
                        FlowGraphSelection.onItemClick($scope.nodesGraph.nodes[id]);
                    });
                })
            }

            $scope.filtering.filteringResults = serializedFilteredGraph.filteringResults;
            $.each(FlowGraph.get().nodes, (key, node) => {
                node.filterRemove = $scope.filtering.filteringResults && (!$scope.filtering.filteringResults.filteredGraphElements || !$scope.filtering.filteringResults.filteredGraphElements.includes(key));
            });
            $rootScope.$emit('drawGraph');
        };

        $scope.reloadFilters = function(structuredFlowObjectFilter, args) {
            if (args && args.refreshFlowFilters) $scope.reloadFlowFilterSettings()
         }

        $scope.reloadFlowFilterSettings = function () {

            DataikuAPI.flow.loadFlowFilterSettings($stateParams.projectKey, $stateParams.zoneId, $scope.collapsedZones)
                .success(function (resp) {
                    Object.assign($scope.filtering, resp.flowFiltersAndSettings);
                    const findId = $scope.filtering.activeFilter.id
                    const refreshedFilter = $scope.filtering.filters.find( e => e.id == findId)
                    if (refreshedFilter) $scope.filtering.activeFilter = refreshedFilter;
                })
                .error(setErrorInScope.bind($scope));
        }

        $scope.processLoadFlowResponse = function (resp, zoomTo, graphReloaded, resetZoom) {
            Assert.trueish(resp, "Received empty response");
            if (resp.flowFiltersAndSettings) {
                Object.assign($scope.filtering, resp.flowFiltersAndSettings);
                if (resp.flowFiltersAndSettings.filters) {
                    if (resp.flowFiltersAndSettings.activeFilterId) {
                        $scope.filtering.activeFilter = $scope.filtering.filters.find(e => e.id === resp.flowFiltersAndSettings.activeFilterId);
                    } else {
                        // by default select "All" filter
                        $scope.filtering.activeFilter = $scope.filtering.filters.find(e => e.id === '-1');
                    }
                    if (!$scope.filtering.activeFilter) {
                        $scope.resetFilter();
                    }
                    if ($scope.filtering.activeFilter) {
                        if (!graphReloaded) $scope.reloadFilters($scope.filtering.activeFilter.structuredFlowObjectFilter);
                        const creationDate = $scope.filtering.activeFilter.structuredFlowObjectFilter.customCreationDateRange;
                        $scope.filtering.pickerStartCreationDate = creationDate && creationDate.from ? moment(creationDate.from).format($scope.format) : null;
                        $scope.filtering.pickerEndCreationDate = creationDate && creationDate.to ? moment(creationDate.to).format($scope.format) : null;
                        const modificationDate = $scope.filtering.activeFilter.structuredFlowObjectFilter.customModificationDateRange;
                        $scope.filtering.pickerStartModificationDate = modificationDate && modificationDate.from ? moment(modificationDate.from).format($scope.format) : null;
                        $scope.filtering.pickerEndModificationDate = modificationDate && modificationDate.to ? moment(modificationDate.to).format($scope.format) : null;
                    }
                }
            }
            $scope.filtering.filtersByCategories = {'global': [], 'shared': [], 'private': []};
            $scope.filtering.filters.forEach(f => {
                if (f.scope === 'BUILT_IN') {
                    $scope.filtering.filtersByCategories['global'].push(f);
                } else if (f.scope === 'SHARED') {
                    $scope.filtering.filtersByCategories['shared'].push(f);
                } else {
                    $scope.filtering.filtersByCategories['private'].push(f);
                }
            });
            if (resp.serializedFilteredGraph) {
                $scope.processSerializedFilteredGraphResponse(resp.serializedFilteredGraph, zoomTo);
            }
            if (resetZoom) $scope.resetPanZoom();
            $scope.isFlowLoaded = true;
        };

        $scope.updateGraph = function (zoomTo) {
            DataikuAPI.flow.recipes.getGraph($stateParams.projectKey, null, true, $scope.drawZones.drawZones, $stateParams.zoneId || "", $scope.collapsedZones)
                .success(function(response) {
                        $scope.zoneIdLoaded = $stateParams.zoneId;
                        $scope.processLoadFlowResponse(response, zoomTo, true);
                        updateUserInterests();
                    }
                )
                .error(setErrorInScope.bind($scope));
            //TODO @flow move to flow_search
            // DataikuAPI.datasets.list($stateParams.projectKey).success(function(data) {
            //     $scope.datasets = data;
            // }).error(setErrorInScope.bind($scope));
            // DataikuAPI.datasets.listHeads($stateParams.projectKey, {}, false).success(function(data) {
            //     $scope.filteredDatasets = data;
            // }).error(setErrorInScope.bind($scope));
        };

        var storageKey = `dku.flow.drawZones.${$stateParams.projectKey}`;
        $scope.drawZones = {
            drawZones: !!$stateParams.zoneId || JSON.parse(localStorageService.get(storageKey) || true)
        }

        $scope.$watch("drawZones.drawZones", function(nv, ov) {
            if (nv !== ov && !$scope.inFlowExport) {
                localStorageService.set(storageKey, $scope.drawZones.drawZones);
                $scope.resetPanZoom();
                $scope.updateGraph();
            }
        });

        var collapsedZonesStorageKey = `dku.flow.collapsedZones.${$stateParams.projectKey}`;

        $scope.cleanupCollapsedZones = (collapsedZones = $scope.collapsedZones) => {
            let changed = false;
            [...collapsedZones].forEach(collapsedZone => {
                const zoneFound = FlowGraph.node(`zone_${collapsedZone}`);
                if (!zoneFound) {
                    const index = collapsedZones.indexOf(collapsedZone);
                    if (index !== -1) {
                        collapsedZones.splice(index, 1);
                        changed = true;
                    }
                }
            });
            if (changed) {
                localStorageService.set(collapsedZonesStorageKey, JSON.stringify(collapsedZones));
            }
            return collapsedZones;
        }
        $scope.collapsedZones = localStorageService.get(collapsedZonesStorageKey) || [];

        $scope.toggleZoneCollapse = (collapseItems, multiItemStrategy) => {
            let zoneIds = collapseItems.map(it => it.id);
            zoneIds.forEach(function(zoneId) {
                let index = $scope.collapsedZones.findIndex(it => it === zoneId);
                if (index > -1 && multiItemStrategy !== 'collapseAll') {
                    $scope.collapsedZones.splice(index, 1);
                } else if (index < 0 && multiItemStrategy !== 'expandAll') {
                    $scope.collapsedZones.push(zoneId);
                }
            });
            localStorageService.set(collapsedZonesStorageKey, JSON.stringify($scope.collapsedZones));
            $scope.updateGraph();
        }

        $scope.filtering = {};

        $scope.resetFilter = function (isAdvanced) {
            $scope.filtering.activeFilter = {
                id: null,
                isAdvanced: !!isAdvanced,
                isDirty: true,
                structuredFlowObjectFilter: {
                    tags: [],
                    creator: [],
                    customCreationDateRange: {
                        from: null,
                        to: null
                    },
                    customModificationDateRange: {
                        from: null,
                        to: null
                    },
                    datasetTypes: [],
                    recipeTypes: [],
                    types: [],
                    downstreamPredecessorsIds: []
                },
                active: false,
                removeFadedElements: false,
                advancedFilter: '',
                query: ''
            };
            $scope.filtering.pickerStartCreationDate = null;
            $scope.filtering.pickerEndCreationDate = null;
            $scope.filtering.pickerStartModificationDate = null;
            $scope.filtering.pickerEndModificationDate = null;
        };

        $scope.resetFilter();
        $scope.updateGraph($stateParams.id);

        $scope.buildDataset = function(projectKey, name, trainMode) {
            DataikuAPI.datasets.get(projectKey, name, $stateParams.projectKey).success(function(dataset) {
                CreateModalFromTemplate("/templates/datasets/build-dataset-modal.html", $scope, "BuildDatasetController", function(modalScope) {
                    modalScope.dataset = dataset;
                    if (trainMode) {
                        modalScope.trainMode = true;
                    }
                }, "build-dataset-modal");
            }).error(setErrorInScope.bind($scope));
        };
        $scope.trainModel = function(projectKey, id) {
            CreateModalFromTemplate("/templates/savedmodels/build-model-modal.html", $scope, "BuildSavedModelController", function(modalScope) {
                    modalScope.modelId = id;
            });
        };
        $scope.buildManagedFolder = function(projectKey, id) {
            CreateModalFromTemplate("/templates/managedfolder/build-folder-modal.html", $scope, "BuildManagedFolderController", function(modalScope) {
                    modalScope.odbId = id;
            });
        };
        $scope.buildModelEvaluationStore = function(projectKey, id) {
            CreateModalFromTemplate("/templates/modelevaluationstores/build-store-modal.html", $scope, "BuildModelEvaluationStoreController", function(modalScope) {
                    modalScope.mesId = id;
            });
        };

        $scope.startCopy = function() {
            $scope.startTool('COPY', {preselectedNodes: FlowGraphSelection.getSelectedNodes().map(n => n.id)});
        };

        const interestsListener = $rootScope.$on('userInterestsUpdated', updateUserInterests);

        $scope.$on('projectTagsUpdated', function (e, args) {
            $scope.reloadFilters($scope.filtering.activeFilter.structuredFlowObjectFilter, args);
        });

        let jobStateChangeListener = Notification.registerEvent("job-state-change", function(evt, message) {

            let refreshGraph = false;

            function getNodeNameForItem(itemType, itemName) {
                return itemType + "__" + graphVizEscape(itemName);
            }


            function isRunning(message) {
                if (message.state=='DONE' || message.state=='FAILED' || message.state=='ABORTED') return false;
                if (message.state=='RUNNING') return true;
                return undefined;
            }

            function updateNodeStatus(isRunIcon, node) {
                if (!node) return;

                if (isRunIcon && !node.beingBuilt) {
                    refreshGraph = true;
                    node.beingBuilt = true;
                    node.aboutToBeBuilt = false;
                }
                else if (node.beingBuilt || node.aboutToBeBuilt) {
                    refreshGraph = true;
                    node.beingBuilt = false;
                    node.aboutToBeBuilt = false;
                }

            }

            function updateNodeStatusFlowWithZones() {
                // selector matching job output datasets realId (can be in multiple zones)
                const selector = message.outputs.filter(output => output.type && output.type.toLowerCase() === 'dataset').map(output => {
                    const realId = getNodeNameForItem('dataset',  output.targetDatasetProjectKey + '.' + output.targetDataset);
                    return `svg [data-node-id="${realId}"]`;
                }).join(', ');

                // update node status for each matching output dataset
                if (selector) {
                    d3.selectAll(selector).each(function() {
                        const id = this.getAttribute('data-id');
                        updateNodeStatus(isRun, FlowGraph.node(id));
                    });
                }
            }

            function updateNodeStatusFlowWithoutZones() {
                message.outputs.forEach(output => {
                    if (output.type && output.type.toLowerCase() === 'dataset') {
                        updateNodeStatus(isRun, $scope.nodesGraph.nodes[getNodeNameForItem('dataset',  output.targetDatasetProjectKey + '.' + output.targetDataset)]);
                    }
                });
            }

            let isRun = isRunning(message);
            if (isRun!==undefined) {
                if ($scope.nodesGraph.hasProjectZones && $scope.drawZones.drawZones) {
                    updateNodeStatusFlowWithZones()
                } else {
                    updateNodeStatusFlowWithoutZones();
                }
            }

            if (refreshGraph) {
                drawBuildInProgressIndicators(FlowGraph.getSvg(), $scope.nodesGraph);
            }
        });
        let continuousActivityStateChangeListener = Notification.registerEvent("continuous-activity-state-change", function(evt, message) {

            let refreshGraph = false;

            function getNodeNameForItem(itemType, itemName) {
                return itemType + "__" + graphVizEscape(itemName);
            }


            function isRunning(message) {
                if (message.state=='STOPPED') return false;
                if (message.state=='STARTED') return true;
                return undefined;
            }

            function updateNodeStatus(isRunIcon, node) {
                if (!node) return;

                if (isRunIcon && !node.beingBuilt) {
                    refreshGraph = true;
                    node.beingBuilt = true;
                    node.continuousActivityDone = false;
                    node.aboutToBeBuilt = false;
                }
                else if (node.beingBuilt || node.aboutToBeBuilt) {
                    refreshGraph = true;
                    node.beingBuilt = false;
                    node.continuousActivityDone = false;
                    node.aboutToBeBuilt = false;
                }

            }

            let isRun = isRunning(message);
            if (isRun!==undefined) {
                let nodeName = getNodeNameForItem('recipe', message.continuousActivityId);
                updateNodeStatus(isRun, $scope.nodesGraph.nodes[nodeName]);
            }

            if (refreshGraph) {
                drawBuildInProgressIndicators(FlowGraph.getSvg(), $scope.nodesGraph);
            }
        });

        $scope.$on("$destroy", function() {
            if ($scope.svg) {
                $scope.svg.empty();
                $scope.svg.remove();
                $scope.svg = null;
            }
            interestsListener();
            jobStateChangeListener();
            continuousActivityStateChangeListener();
        });

        $scope.toggleFilter = function () {
            DataikuAPI.flow.enableFlowFiltering($stateParams.projectKey, !$scope.filtering.filteringEnabled, $scope.collapsedZones)
                .success($scope.processLoadFlowResponse)
                .error(setErrorInScope.bind($scope));
        };

        $scope.unfoldAll = function() {
            FlowGraphFolding.unfoldAll();
        }

        $scope.zoomToSelection = function() {
            $scope.zoomToBbox(FlowGraphFiltering.getBBoxFromSelector($scope.svg, '.selected'), 1.2);
        };

        $scope.exportFlow = function() {
            const graphBBox = $scope.svg.find('g.graph')[0].getBBox();
            CreateModalFromTemplate("/templates/flow-editor/export-flow-modal.html", $scope, "ExportFlowModalController", function(newScope) {
                newScope.init($stateParams.projectKey, graphBBox);
            });
        };

        // Toolbox used by export-flow.js to prepare the flow to be exported
        $scope.exportToolbox = {
            checkLoading: function() {
                return $scope.httpRequests.length !== 0 || !$scope.isFlowLoaded;
            },
            removeDecorations: function(drawZones) {
                executeWithInstantDigest(function() {
                    $scope.hideForExport = true;
                    $scope.fullScreen = true;
                    $scope.inFlowExport = true; // Prevent the flow from automatically refreshing when zones are shown/hidden
                }, $scope);
            },
            getGraphBoundaries: function () {
                const graphBBox = $scope.svg.find('g.graph')[0].getBBox();
                return {
                    x: graphBBox.x,
                    y: graphBBox.y,
                    width: graphBBox.width,
                    height: graphBBox.height
                };
            },
            adjustViewBox: function(x, y, width, height) {
                $scope.svg[0].setAttribute('viewBox', [x, y, width, height].join(', '));
            },
            configureZones: function(drawZones, collpasedZones) {
                $scope.drawZones.drawZones = drawZones;
                $scope.collapsedZones = collpasedZones;
                // Reload the flow graph
                $scope.isFlowLoaded = false;
                $scope.updateGraph();
            }
        };


        $scope.zoomOnZone = zoneId => {
            $state.go('projects.project.flow', Object.assign({}, $stateParams, { zoneId }));
        };

        $scope.zoomOutOfZone = (id = null) => {
            $state.go('projects.project.flow', Object.assign({}, $stateParams, { zoneId: null, id }));
        }
    },
    link: function(scope, element) {
        // Try to find the more recent item for the project and zone
        function getLastItemInHistory(projectKey, zoneId) {
            const items = HistoryService.getRecentlyViewedItems();
            if (items && items.length) {
                const validItems = items.filter(it => it.type !== 'PROJECT' && it.projectKey === projectKey);
                if (!zoneId) {
                    return validItems[0];
                }
                const zoneName = graphVizEscape(`zone_${zoneId}`);
                const zoneContent = Object.keys(scope.nodesGraph.nodes).filter(it => it.startsWith(zoneName)).map(it => scope.nodesGraph.nodes[it]);
                return validItems.find(item => zoneContent.find(it => it.name === item.id));
            }
            return null;
        }

        function getName(item) {
            if (item.type === 'RECIPE') {
                return item.type.toLowerCase() + graphVizEscape(`_${item.id}`)
            }
            return item.type.toLowerCase().replace('_', '') + graphVizEscape(`_${item.projectKey}.${item.id}`);
        }

        function zoomOnLast() {
            if (!scope.nodesGraph || !scope.nodesGraph.nodes) {
                return; // not ready
            }
            const itemFound = getLastItemInHistory($stateParams.projectKey, $stateParams.zoneId);
            if (itemFound) {
                const id = GraphZoomTrackerService.getZoomedName(FlowGraph, getName(itemFound));
                Logger.info("zooming on " + id + "--> ", scope.nodesGraph.nodes[id]);
                scope.zoomGraph(id);
                FlowGraphSelection.onItemClick(scope.nodesGraph.nodes[id]);
                scope.$apply();
            }
        }

        const lastUsedZoneKey = `dku.flow.lastUsedZone.${$stateParams.projectKey}`;

        function preselectZone() {
            const selectedItems = FlowGraphSelection.getSelectedNodes();
            if (selectedItems.length == 1 && selectedItems[0].nodeType == "ZONE") {
                return selectedItems[0].cleanId;
            }
            return localStorageService.get(lastUsedZoneKey);
        }

        scope.zoneComparator = (v1, v2) => {
            // If we don't get strings, just compare by index
            if (v1.type !== 'string' || v2.type !== 'string') {
              return (v1.index < v2.index) ? -1 : 1;
            }
            if (scope.uiState.zones[v1.index].id === 'default') {
                return 1;
            }
            if (scope.uiState.zones[v2.index].id === 'default') {
                return -1;
            }
            // Compare strings alphabetically, taking locale into account
            return v1.value.localeCompare(v2.value);
          };

        scope.moveToFlowZone = (movingItems, forceCreation = false, computedImpact = []) => {
            scope.movingItems = movingItems;
            scope.computedImpact = computedImpact;
            scope.uiState = {
                zones: [],
                selectedZone: undefined,
                creationMode: forceCreation ? 'create' : 'move',
                stockColors: ["#C82423","#8C2DA7","#31439C","#087ABF","#0F786B","#4B8021","#F9BE40","#C54F00","#D03713","#465A64"],
                color: "#FF0000",
                forceCreation
            };
            DataikuAPI.flow.zones.list($stateParams.projectKey).success(zones => {
                scope.uiState.zones = zones;
                scope.uiState.creationMode = !forceCreation && zones.length > 0 ? 'move' : 'create';
            }).error(setErrorInScope.bind(scope));
            CreateModalFromTemplate("/templates/flow-editor/move-to-zone.html", scope, null, newScope => {
                newScope.uiState.color = newScope.uiState.stockColors[Math.floor(Math.random() * newScope.uiState.stockColors.length)]
                newScope.uiState.selectedZone = preselectZone();
                newScope.pickStockColor = color => {
                    newScope.uiState.color = color;
                };
                newScope.onClick = () => {
                    let movingTo = newScope.uiState.selectedZone;
                    let promise = null
                    movingItems = movingItems.concat(scope.computedImpact);
                    if (newScope.uiState.creationMode === 'create') {
                        promise = DataikuAPI.flow.zones.create($stateParams.projectKey, newScope.uiState.name, newScope.uiState.color).success(zoneCreated => {
                            movingTo = zoneCreated.id;
                            $rootScope.$emit('zonesListChanged');
                        }).error($q.reject);
                    } else {
                        promise = $q.resolve();
                    }

                    if (movingItems.length > 0) {
                        promise = promise.then(() => DataikuAPI.flow.zones.moveItems($stateParams.projectKey, movingTo, movingItems).error($q.reject));
                    }
                    promise.then(() => {
                        localStorageService.set(lastUsedZoneKey, movingTo);
                        GraphZoomTrackerService.setFocusItemCtx({id: `zone_${movingTo}`}, true);
                        newScope.$emit('reloadGraph');
                        newScope.dismiss();
                    }, setErrorInScope.bind(newScope))
                }
            });
        };

        scope.shareToFlowZone = (sharingItems, forceCreation = false) => {
            scope.uiState = {
                zones: [],
                selectedZone: undefined,
                creationMode: forceCreation ? 'create' : 'share',
                stockColors: ["#C82423","#8C2DA7","#31439C","#087ABF","#0F786B","#4B8021","#F9BE40","#C54F00","#D03713","#465A64"],
                color: "#FF0000",
                forceCreation
            };
            DataikuAPI.flow.zones.list($stateParams.projectKey).success(zones => {
                scope.uiState.zones = zones;
                scope.uiState.creationMode = !forceCreation && zones.length > 0 ? 'share' : 'create';
            }).error(setErrorInScope.bind(scope));
            CreateModalFromTemplate("/templates/flow-editor/share-to-zone.html", scope, null, newScope => {
                newScope.uiState.color = newScope.uiState.stockColors[Math.floor(Math.random() * newScope.uiState.stockColors.length)]
                newScope.uiState.selectedZone = preselectZone();
                newScope.pickStockColor = color => {
                    newScope.uiState.color = color;
                };
                newScope.onClick = () => {
                    let sharedTo = newScope.uiState.selectedZone;
                    let promise = null
                    if (newScope.uiState.creationMode === 'create') {
                        promise = DataikuAPI.flow.zones.create($stateParams.projectKey, newScope.uiState.name, newScope.uiState.color).success(zoneCreated => {
                            sharedTo = zoneCreated.id;
                            newScope.uiState.zones.push(zoneCreated);
                            $rootScope.$emit('zonesListChanged');
                        }).error($q.reject);
                    } else {
                        promise = $q.resolve();
                    }

                    if (sharingItems.length > 0) {
                        promise = promise.then(() => DataikuAPI.flow.zones.shareItems($stateParams.projectKey, sharedTo, sharingItems).error($q.reject));
                    }

                    promise.then(() => {
                        localStorageService.set(lastUsedZoneKey, sharedTo);
                        if ($stateParams.zoneId) {
                            const found = newScope.uiState.zones.find(z => z.id === sharedTo);
                            if (found) {
                                MessengerUtils.post({
                                    message: `Shared to zone: <a class="link-std" href="${StateUtils.href.dssObject("FLOW_ZONE", found.id, $stateParams.projectKey)}">${newScope.sanitize(found.name)}</a>`,
                                    icon: '<i class="icon-zone"/>',
                                    type: "no-severity",
                                    id: "share-flow-zone" + found.id,
                                    showCloseButton: true
                                });
                            }
                        }
                        newScope.$emit('reloadGraph');
                        newScope.dismiss()
                    }, setErrorInScope.bind(newScope));
                }
            });
        };

        scope.unshareToFlowZone = (sharingItems, zoneIds) => {
            if (sharingItems.length > 0) {
                DataikuAPI.flow.zones.unshareItems($stateParams.projectKey, zoneIds, sharingItems).success(scope.$emit('reloadGraph'));
            }
        };

        scope.onItemDblClick = function(item, evt) {
            let destUrl = StateUtils.href.node(item);
            fakeClickOnLink(destUrl, evt);
        };

        scope.onContextualMenu = function(item, evt) {
            let $itemEl = $(evt.target).parents("g[data-type]").first();
            if ($itemEl.length > 0) {
                let x = evt.pageX;
                let y = evt.pageY;
                let ctxMenuScope = scope.$new();
                const selectedNodes = FlowGraphSelection.getSelectedNodes();
                let type = selectedNodes.length > 1 ? 'MULTI' : item.nodeType;

                let controller = {
                    "LOCAL_DATASET": "DatasetContextualMenuController",
                    "FOREIGN_DATASET": "ForeignDatasetContextualMenuController",
                    "LOCAL_STREAMING_ENDPOINT": "StreamingEndpointContextualMenuController",
                    "RECIPE": "RecipeContextualMenuController",
                    "LOCAL_SAVEDMODEL": "SavedModelContextualMenuController",
                    "FOREIGN_SAVEDMODEL": "SavedModelContextualMenuController",
                    "LOCAL_MODELEVALUATIONSTORE": "ModelEvaluationStoreContextualMenuController",
                    "FOREIGN_MODELEVALUATIONSTORE": "ModelEvaluationStoreContextualMenuController",
                    "LOCAL_MANAGED_FOLDER": "ManagedFolderContextualMenuController",
                    "FOREIGN_MANAGED_FOLDER": "ManagedFolderContextualMenuController",
                    "ZONE": "ZoneContextualMenuController",
                    "MULTI": "MultiContextualMenuController",
                }[type];

                let template = "/templates/flow-editor/" + {
                    "LOCAL_DATASET": "dataset-contextual-menu.html",
                    "FOREIGN_DATASET": "foreign-dataset-contextual-menu.html",
                    "LOCAL_STREAMING_ENDPOINT": "streaming-endpoint-contextual-menu.html",
                    "RECIPE": "recipe-contextual-menu.html",
                    "LOCAL_SAVEDMODEL": "savedmodel-contextual-menu.html",
                    "FOREIGN_SAVEDMODEL": "savedmodel-contextual-menu.html",
                    "LOCAL_MODELEVALUATIONSTORE": "modelevaluationstore-contextual-menu.html",
                    "FOREIGN_MODELEVALUATIONSTORE": "modelevaluationstore-contextual-menu.html",
                    "LOCAL_MANAGED_FOLDER": "managed-folder-contextual-menu.html",
                    "FOREIGN_MANAGED_FOLDER": "managed-folder-contextual-menu.html",
                    "ZONE": "zone-contextual-menu.html",
                    "MULTI": "multi-contextual-menu.html",
                }[type];

                ctxMenuScope.object = item;
                ctxMenuScope.hasZone = [...selectedNodes, item].find(it => it.nodeType === "ZONE") !== undefined;

                let menu = new ContextualMenu({
                    template: template,
                    scope: ctxMenuScope,
                    contextual: true,
                    controller: controller,
                });
                menu.openAtXY(x, y);
                return false;
            } else {
                ContextualMenu.prototype.closeAny();
                return true;
            }
        };

        FlowGraphSelection.clearSelection();

        scope.flowViews = FlowToolsRegistry.getFlowViews();

        Mousetrap.bind("z", zoomOnLast);

        Mousetrap.bind("left", scope.moveLeft);
        Mousetrap.bind("right", scope.moveRight);
        Mousetrap.bind("up", scope.moveUp);
        Mousetrap.bind("down", scope.moveDown);

        Mousetrap.bind("-", scope.zoomOut);
        Mousetrap.bind("+", scope.zoomIn);
        Mousetrap.bind("=", scope.zoomIn); // For more practicity on qwerty keyboard without numpad

        const updateGraphDebounced = Debounce().withDelay(200,200).wrap(scope.updateGraph);

        const deregister1 = $rootScope.$on('datasetsListChangedFromModal', updateGraphDebounced);
        const deregister2 = $rootScope.$on('taggableObjectTagsChanged', updateGraphDebounced);
        const deregister3 = $rootScope.$on('flowItemAddedOrRemoved', updateGraphDebounced);
        const deregister4 = $rootScope.$on('reloadGraph', (event, { zoomTo } = {}) => updateGraphDebounced(zoomTo));
        const deregister5 = $rootScope.$on('objectMetaDataChanged', updateGraphDebounced);
        const deregister6 = $rootScope.$on('discussionCountChanged', updateGraphDebounced);
        //const deregister7 = $rootScope.$on('unreadDiscussionsChanged', updateGraphDebounced); TODO: find a better solution to live-refresh the unread discussions

        scope.$on("$destroy", function() {
            Mousetrap.unbind("z");
            Mousetrap.unbind("left");
            Mousetrap.unbind("right");
            Mousetrap.unbind("up");
            Mousetrap.unbind("down");
            Mousetrap.unbind("-");
            Mousetrap.unbind("+");
            Mousetrap.unbind("=");
            deregister1();
            deregister2();
            deregister3();
            deregister4();
            deregister5();
            deregister6();
            //deregister7(); TODO: find a better solution to live-refresh the unread discussions

        });

        scope.$on('graphRendered', function() {
            drawBuildInProgressIndicators(scope.svg, scope.nodesGraph);
            drawExposedIndicators(scope.svg, scope.nodesGraph);
        });

        scope.$on('indexNodesDone', () => {
            scope.cleanupCollapsedZones();
        });
    }
};
});

app.directive('flowExportForm', function(GRAPHIC_EXPORT_OPTIONS, WT1, GraphicImportService) {
    return {
        replace: false,
        require: '^form',
        restrict: 'EA',
        scope: {
            params: '=',
            graphBoundaries: '='
        },
        templateUrl: '/templates/flow-editor/export-flow-form.html',
        link: function($scope, element, attrs, formCtrl) {
            WT1.event("flow-export-form-displayed", {});

            $scope.exportFormController = formCtrl;
            // Utilities that give us all the choices possible
            $scope.paperSizeMap = GRAPHIC_EXPORT_OPTIONS.paperSizeMap;
            $scope.orientationMap = GRAPHIC_EXPORT_OPTIONS.orientationMap;
            $scope.ratioMap = GRAPHIC_EXPORT_OPTIONS.ratioMap;
            $scope.paperInchesMap = GRAPHIC_EXPORT_OPTIONS.paperInchesMap;
            $scope.fileTypes = GRAPHIC_EXPORT_OPTIONS.fileTypes;
            $scope.tileScaleModes = GRAPHIC_EXPORT_OPTIONS.tileScaleModes;

            $scope.minResW = 500;
            $scope.minResH = 500;
            $scope.maxResW = 10000;
            $scope.maxResH = 10000;
            $scope.maxDpi = 300;

            let computeTileScale = function (tileScaleProps) {
                if (!tileScaleProps.enabled || tileScaleProps.percentage === undefined) {
                    return 1;
                } else {
                    return Math.max(1, tileScaleProps.percentage / 100)
                }
            };

            let computeBestTileScale = function(width, height) {
                const targetFactor = 1.0; // 1-to-1 between size of graph and exported image
                const xFactor = $scope.graphBoundaries.width / width;
                const yFactor = $scope.graphBoundaries.height / height;
                return Math.max(1, Math.ceil(Math.max(xFactor, yFactor) / targetFactor));
            };

            let capWidth = function(width) {
                return Math.min($scope.maxResW, Math.max($scope.minResW, width));
            };
            let capHeight = function(height) {
                return Math.min($scope.maxResH, Math.max($scope.minResH, height));
            };

            // Given an image width, height and tile scale, compute how many pages
            // will be required to render the whole graph
            let computeTileScaleSheets = function(width, height, tileScale) {
                if (width === undefined || height === undefined || tileScale == undefined) {
                    return {x: 0, y: 0, count: 0};
                }
                const sheetRatio = width / height;
                const graphRatio = $scope.graphBoundaries.width / $scope.graphBoundaries.height;
                let graphSheetWidth;
                let graphSheetHeight;
                if (sheetRatio < graphRatio) {
                    // Dominant width
                    graphSheetWidth = $scope.graphBoundaries.width / tileScale;
                    graphSheetHeight = graphSheetWidth / sheetRatio;
                } else {
                    // Dominant height
                    graphSheetHeight = $scope.graphBoundaries.height / tileScale;
                    graphSheetWidth = graphSheetHeight * sheetRatio;
                }
                const x = Math.max(1, Math.ceil($scope.graphBoundaries.width / graphSheetWidth));
                const y = Math.max(1, Math.ceil($scope.graphBoundaries.height / graphSheetHeight));
                const count = x * y;
                return {x: x, y: y, count: count};
            };

            // Compute the best width, height and tile scale for the exported image
            // for the supplied paper size and orientation.
            let setBestDimensions = function(authorizeTileScaling = true) {
                let exportFormat = $scope.params.exportFormat;

                let width, height;
                const sheetRatio = (exportFormat.orientation == "LANDSCAPE") ?
                    $scope.ratioMap[exportFormat.paperSize] :
                    1 / $scope.ratioMap[exportFormat.paperSize];
                const graphRatio = $scope.graphBoundaries.width / $scope.graphBoundaries.height;
                if (sheetRatio < graphRatio) {
                    // Dominant width
                    width = $scope.graphBoundaries.width;
                    height = width / sheetRatio;
                } else {
                    // Dominant height
                    height = $scope.graphBoundaries.height;
                    width = height * sheetRatio;
                }

                let tileScale = 1;
                let dpi = Math.max(width, height) / $scope.paperInchesMap[exportFormat.paperSize];
                if (authorizeTileScaling && dpi > $scope.maxDpi) {
                    width = (width * $scope.maxDpi) / dpi;
                    height = (height * $scope.maxDpi) / dpi;
                    tileScale = computeBestTileScale(width, height);
                }

                exportFormat.width = capWidth(Math.round(width));
                exportFormat.height = capHeight(Math.round(height));
                exportFormat.tileScale = tileScale;
            };

            // Parameters of the export
            $scope.params.exportFormat = {
                paperSize: "A4",
                orientation: "LANDSCAPE",
                fileType: "PDF",
                width: 1920,
                height: 1358,
                tileScale: 1,
            };
            let exportFormat = $scope.params.exportFormat;

            // Restore values from LocalStorage if they have been saved
            let savedFileType = localStorage.getItem("dku.flow.export.fileType");
            if (savedFileType && $scope.fileTypes.indexOf(savedFileType) >= 0) {
                exportFormat.fileType = savedFileType;
            }
            let savedPaperSize = localStorage.getItem("dku.flow.export.paperSize");
            if (savedPaperSize && $scope.paperSizeMap[savedPaperSize]) {
                exportFormat.paperSize = savedPaperSize;
            }
            if (savedPaperSize == "CUSTOM") {
                let savedWidth = localStorage.getItem("dku.flow.export.width");
                if (savedWidth && !isNaN(Number(savedWidth))) {
                    exportFormat.width = capWidth(Number(savedWidth));
                }
                let savedHeight = localStorage.getItem("dku.flow.export.height");
                if (savedHeight && !isNaN(Number(savedHeight))) {
                    exportFormat.height = capHeight(Number(savedHeight));
                }
            } else {
                let savedOrientation = localStorage.getItem("dku.flow.export.orientation");
                if (savedOrientation && $scope.orientationMap[savedOrientation]) {
                    exportFormat.orientation = savedOrientation;
                }
            }
            if (exportFormat.paperSize != "CUSTOM") {
                // Choose the best width & height and compute the tile scale
                setBestDimensions();
            }
            $scope.tileScale = {};
            $scope.tileScale.enabled = exportFormat.tileScale > 1;
            $scope.tileScale.percentage = exportFormat.tileScale * 100;
            $scope.tileScale.sheets = computeTileScaleSheets(exportFormat.width, exportFormat.height, exportFormat.tileScale);

            let onUpdatePaperSizeOrOrientation = function() {
                setBestDimensions();
                let exportFormat = $scope.params.exportFormat;
                $scope.tileScale.enabled = exportFormat.tileScale > 1;
                $scope.tileScale.percentage = exportFormat.tileScale * 100;
                $scope.tileScale.sheets = computeTileScaleSheets(exportFormat.width, exportFormat.height, exportFormat.tileScale);
            };

            $scope.$watch('params.exportFormat.paperSize', function (newVal, oldVal) {
                if (newVal !== oldVal && newVal != 'CUSTOM') {
                    onUpdatePaperSizeOrOrientation();
                }
            });

            $scope.$watch('params.exportFormat.orientation', function (newVal, oldVal) {
                if (newVal !== oldVal) {
                    onUpdatePaperSizeOrOrientation();
                }
            });

            $scope.$watch('params.exportFormat.width', function (newVal, oldVal) {
                if (newVal !== oldVal) {
                    let exportFormat = $scope.params.exportFormat;
                    $scope.tileScale.sheets = computeTileScaleSheets(exportFormat.width, exportFormat.height, exportFormat.tileScale);
                }
            });

            $scope.$watch('params.exportFormat.height', function (newVal, oldVal) {
                if (newVal !== oldVal) {
                    let exportFormat = $scope.params.exportFormat;
                    $scope.tileScale.sheets = computeTileScaleSheets(exportFormat.width, exportFormat.height, exportFormat.tileScale);
                }
            });

            $scope.$watch('tileScale.enabled', function (newVal, oldVal) {
                if (newVal !== oldVal) {
                    let exportFormat = $scope.params.exportFormat;
                    if (newVal == true) {
                        // Try to keep the DPI of exported images around 300 dpi
                        if (exportFormat.paperSize != "CUSTOM") {
                            let dpi = Math.max(exportFormat.width, exportFormat.height) / GRAPHIC_EXPORT_OPTIONS.paperInchesMap[exportFormat.paperSize];
                            if (dpi > $scope.maxDpi) {
                                exportFormat.width = capWidth(Math.round(exportFormat.width * $scope.maxDpi / dpi));
                                exportFormat.height = capHeight(Math.round(exportFormat.height * $scope.maxDpi / dpi));
                            }
                        }
                        $scope.tileScale.percentage = computeBestTileScale(exportFormat.width, exportFormat.height) * 100;
                        exportFormat.tileScale = computeTileScale($scope.tileScale);
                    } else {
                        if (exportFormat.paperSize != "CUSTOM") {
                            setBestDimensions(false);
                        } else {
                            exportFormat.tileScale = 1;
                        }
                    }

                }
            });
            $scope.$watch('tileScale.percentage', function (newVal, oldVal) {
                if (newVal !== oldVal) {
                    let exportFormat = $scope.params.exportFormat;
                    exportFormat.tileScale = computeTileScale($scope.tileScale);
                    $scope.tileScale.sheets = computeTileScaleSheets(exportFormat.width, exportFormat.height, exportFormat.tileScale);
                }
            });
        }
    }
});

app.controller("ExportFlowModalController", function($scope, DataikuAPI, ActivityIndicator, FutureProgressModal, WT1) {
    $scope.init = function (projectKey, graphBoundaries) {
        $scope.params = {};
        $scope.modalTitle = "Export Flow graph";
        $scope.projectKey = projectKey;
        $scope.graphBoundaries = graphBoundaries;
    };

    $scope.doExportFlow = function() {
        WT1.event("flow-exported", {
            format: $scope.params.exportFormat
        });

        // Duplicate export format and add the zones export information
        let exportFormat = JSON.parse(JSON.stringify($scope.params.exportFormat));
        exportFormat.drawZones = $scope.drawZones.drawZones;
        exportFormat.collapsedZones = $scope.collapsedZones;

        // Save options into LocalStorage to use them again for next export
        localStorage.setItem("dku.flow.export.fileType", exportFormat.fileType);
        localStorage.setItem("dku.flow.export.paperSize", exportFormat.paperSize);
        if (exportFormat.paperSize === "CUSTOM") {
            localStorage.setItem("dku.flow.export.width", exportFormat.width);
            localStorage.setItem("dku.flow.export.height", exportFormat.height);
        } else {
            localStorage.setItem("dku.flow.export.orientation", exportFormat.orientation);
        }

        // Export the flow
        DataikuAPI.flow.export($scope.projectKey, exportFormat)
            .error(setErrorInScope.bind($scope))
            .success(function (resp) {
                FutureProgressModal.show($scope, resp, "Export Flow graph").then(function (result) {
                    if (result) { // undefined in case of abort
                        downloadURL(DataikuAPI.flow.getExportURL(result.projectKey, result.exportId));
                        ActivityIndicator.success("Flow graph export downloaded!", 5000);
                    } else {
                        ActivityIndicator.error("Export Flow failed", 5000);
                    }
                    $scope.resolveModal();
                });
            });
    }
});

app.directive('flowFilter', function ($stateParams, DataikuAPI,$rootScope,$timeout,CreateModalFromTemplate,Dialogs,FlowFilterQueryService) {

    return {
        controller: function ($scope) {

            function processLoadFlowResponse (response) {
                $scope.processLoadFlowResponse(response, undefined, undefined, true);
            }

            $scope.delete = function (id) {
                Dialogs.confirmSimple($scope, 'Delete filter?').then(function () {
                    DataikuAPI.flow.deleteFlowFilter($stateParams.projectKey, id, $scope.drawZones.drawZones, $stateParams.zoneId, $scope.collapsedZones)
                        .success(response => {
                            processLoadFlowResponse(response);
                            $scope.resetFilter($scope.filtering.activeFilter.isAdvanced);
                        })
                        .error(setErrorInScope.bind($scope));
                });

            };
            $scope.revertDirtyFilter = function (id) {
                Dialogs.confirmSimple($scope, 'Discard changes?').then(function () {
                    DataikuAPI.flow.revertDirtyFilter($stateParams.projectKey, id, $scope.drawZones.drawZones, $stateParams.zoneId, $scope.collapsedZones)
                        .success(processLoadFlowResponse)
                        .error(setErrorInScope.bind($scope));
                });

            };

            $scope.showEditNameModal = function(isSaveAs) {
                CreateModalFromTemplate("/templates/flow-editor/fragments/flow-filter-save-modal.html", $scope, null, function (newScope) {
                    newScope.isSaveAs = isSaveAs;
                    newScope.filter = angular.copy($scope.filtering.activeFilter);
                });
            }

            $scope.showModalIfNeededAndSave = function (isSaveAs) {
                if (!$scope.filtering.activeFilter.id || $scope.filtering.activeFilter.isDirty && !$scope.filtering.activeFilter.name || isSaveAs) {
                    $scope.showEditNameModal(isSaveAs);
                } else {
                    $scope.save($scope.filtering.activeFilter,isSaveAs);
                }
            };

            $scope.applyFilterOrHandleError = function() {
                const filteringResults = $scope.filtering.filteringResults;
                if (filteringResults && filteringResults.filteredGraphElements && !filteringResults.filteringError) {
                    $scope.applyNodeFiltering(filteringResults.filteredGraphElements);
                } else {
                    $scope.applyNodeFiltering(Object.keys($scope.nodesGraph.nodes));
                }
            }

            $scope.applyFilter = function () {
                $scope.filtering.activeFilter.query = $scope.filtering.activeFilter.isAdvanced ? $scope.filtering.activeFilter.advancedFilter : uiFilterToQuery();
                DataikuAPI.flow.applyFlowFilter($stateParams.projectKey, $scope.filtering.activeFilter, $scope.drawZones.drawZones, $stateParams.zoneId, $scope.collapsedZones)
                    .success(processLoadFlowResponse)
                    .error(setErrorInScope.bind($scope));
            };

            $scope.save = function (filter, isSaveAs) {
                $scope.filtering.activeFilter.query = $scope.filtering.activeFilter.isAdvanced ? $scope.filtering.activeFilter.advancedFilter : uiFilterToQuery();
                filter.id = isSaveAs ? null : $scope.filtering.activeFilter.id;
                DataikuAPI.flow.saveProjectFlowFilter($stateParams.projectKey, filter, $scope.drawZones.drawZones, $stateParams.zoneId, $scope.collapsedZones)
                    .success(function (response) {
                        processLoadFlowResponse(response);
                        $scope.hidePopover();
                        $('.dbt-tooltip').remove();
                    })
                    .error(setErrorInScope.bind($scope));
            };

            $scope.resetFilterWithWarning = function (isAdvanced) {
                const dirtyFilter= $scope.filtering.filters.find(f => f.isDirty);
                if (dirtyFilter){
                    Dialogs.confirmSimple($scope, 'There is an unsaved filter, changes will be discarded').then(function () {
                        $scope.resetFilter(isAdvanced);
                        $scope.applyFilter();
                    });
                } else {
                    $scope.resetFilter(isAdvanced);
                    $scope.applyFilter();
                }
            };

            $scope.filtering.pickerFormat = FlowFilterQueryService.pickerFormat;

            function uiFilterToQuery() {
                return FlowFilterQueryService.uiFilterToQuery($scope.filtering.activeFilter.structuredFlowObjectFilter, $scope.filtering.pickerFormat);
            }

            $scope.changeMode = function () {
                $scope.filtering.activeFilter.isAdvanced = !$scope.filtering.activeFilter.isAdvanced;
                if (!$scope.filtering.activeFilter.advancedFilter) {
                    $scope.filtering.activeFilter.advancedFilter = uiFilterToQuery();
                }
            };

            $scope.onFilterChange = function (filter) {
                if (filter.id === $scope.filtering.activeFilter.id) {
                    return
                }

                function __doConfirm() {
                    $scope.filtering.activeFilter = filter;
                    if ($scope.filtering.activeFilter) {
                        DataikuAPI.flow.activateFlowFilter($stateParams.projectKey, $scope.filtering.activeFilter.id, $scope.drawZones.drawZones, $stateParams.zoneId, $scope.collapsedZones)
                            .success(processLoadFlowResponse)
                            .error(setErrorInScope.bind($scope));
                    }
                }

                if ($scope.filtering.filters.find(f => f.isDirty)) {
                    Dialogs.confirm($scope, 'Erase filter?', 'Switching to another filter will erase your unsaved changes.  Do you want to continue?').then(function () {
                        __doConfirm();
                    });
                } else {
                    __doConfirm();
                }


            };

            $scope.projectKey = $stateParams.projectKey;

            $scope.filteringOptions = {
                selectors: [
                    {value: "tag:", label: "Tags"},
                    {value: "user:", label: "Users"},
                    {value: "createdBetween:", label: "Created"},
                    {value: "modifiedBetween:", label: "Modified"}
                ],
                values: {}
            };

            $scope.$watchCollection('[filtering.pickerStartCreationDate,filtering.pickerEndCreationDate]', function () {
                if ($scope.filtering.activeFilter) {
                    $scope.filtering.activeFilter.structuredFlowObjectFilter.customCreationDateRange.from = $scope.filtering.pickerStartCreationDate && moment($scope.filtering.pickerStartCreationDate, $scope.filtering.pickerFormat).toDate().getTime() || null;
                    $scope.filtering.activeFilter.structuredFlowObjectFilter.customCreationDateRange.to = $scope.filtering.pickerEndCreationDate && moment($scope.filtering.pickerEndCreationDate, $scope.filtering.pickerFormat).toDate().getTime() || null;
                }
            });

            $scope.$watchCollection('[filtering.pickerStartModificationDate,filtering.pickerEndModificationDate]', function () {
                if ($scope.filtering.activeFilter) {
                    $scope.filtering.activeFilter.structuredFlowObjectFilter.customModificationDateRange.from = $scope.filtering.pickerStartModificationDate && moment($scope.filtering.pickerStartModificationDate, $scope.filtering.pickerFormat).toDate().getTime() || null;
                    $scope.filtering.activeFilter.structuredFlowObjectFilter.customModificationDateRange.to = $scope.filtering.pickerEndModificationDate && moment($scope.filtering.pickerEndModificationDate, $scope.filtering.pickerFormat).toDate().getTime() || null;
                }
            });

            $scope.filterTypeOrderFunction = function (filter) {
                if (filter.scope === 'BUILT_IN') return 0;
                if (filter.isDirty && !filter.name) return 1;
                if (filter.scope === 'SHARED') return 2;
                return Infinity;
            }

            $scope.customSuggests = {
                "name:": ['REGEXP'],
                "tag:": $scope.filtering.flowFilteringFacetData.tagsStatistics.map(e => FlowFilterQueryService.escapeStr(e.key)).sort(),
                "user:": $scope.filtering.flowFilteringFacetData.usersStatistics.map(e => FlowFilterQueryService.escapeStr(e.key)).sort(),
                "type:": $scope.filtering.flowFilteringFacetData.elementIdsTypeStatistics.map(e => FlowFilterQueryService.escapeStr(e.key)).sort(),
                "datasetType:": $scope.filtering.flowFilteringFacetData.datasetTypeStatistics.map(e => FlowFilterQueryService.escapeStr(e.key)).sort(),
                "recipeType:": $scope.filtering.flowFilteringFacetData.recipeTypeStatistics.map(e => FlowFilterQueryService.escapeStr(e.key)).sort(),
            };

            $scope.suggestionSettings = {
                'REGEXP':         {suggestion: 'regular expression',    value: '',   shiftPosition: 0},
                'VALUE':          {suggestion: 'string',                value: '',   shiftPosition: 0},
                'ESCAPED_TEXT':   {suggestion: '"escaped string"',      value: '""', shiftPosition: 1},
                'DATE':           {suggestion: 'YYYY-MM-DD',            value: '',   shiftPosition: 0},
                'DATETIME':       {suggestion: 'YYYY-MM-DD HH:mm',      value: '',   shiftPosition: 0},
            };
            $scope.formatErrorMessage = function (error) {
                if (!error) {
                    return;
                }
                const expectedTokensString = !error.expectedTokens ? "" : error.expectedTokens.map(t => {
                    return t in $scope.suggestionSettings ? $scope.suggestionSettings[t]['suggestion'] : t;
                }).join(', ');
                return error.message + expectedTokensString;
            };
        },
        link:function (scope, element, attr) {

            $timeout(() => {
                $('.daterangepicker').on('click', function (e) {
                    e.stopPropagation();
                });
            });
        },
        templateUrl: '/templates/flow-editor/flow_filter.html'
    };
});

app.directive('advancedFilterInput', function () {
    return{
        link: function (scope, element, attr) {
            scope.typeaheadClass = attr.typeaheadClass;
            let lastCaretPosition;

            let typeahead, textarea;

            function overrideTypeahead() {
                typeahead = element.find('[bs-typeahead]').data('typeahead');
                textarea = element.find('textarea')[0];


                typeahead.lookup = function () {
                    typeahead.query = "";
                    return typeahead.process(scope.suggests);
                };

                typeahead.updater = function (val) {
                    let beforeCaret = scope.filtering.activeFilter.advancedFilter.substr(0, lastCaretPosition);
                    const afterCaret = scope.filtering.activeFilter.advancedFilter.substr(lastCaretPosition).trim();
                    (function (lastCaretPosition) {
                        setTimeout(function () {
                            textarea.focus();
                            let newPosition = lastCaretPosition + (scope.suggestionSettings[val] ? scope.suggestionSettings[val].shiftPosition : val.length + 1);
                            textarea.setSelectionRange(newPosition, newPosition);
                            if (scope.suggestionSettings[val] && scope.suggestionSettings[val].shiftPosition > 0) {
                                scope.updateSuggestions();
                            }
                        })
                    })(lastCaretPosition);
                    const offeringSymbol = FlowFilterParser.suggestTokens(beforeCaret).offeringSymbol;
                    if (offeringSymbol && val.toLowerCase().startsWith(offeringSymbol.toLowerCase())){
                        beforeCaret = beforeCaret.substr(0, beforeCaret.length - offeringSymbol.length);
                    }

                    if (val === 'AND' || val === 'OR') {
                        if (beforeCaret.length > 0 && beforeCaret.substr(-1) !== ' ') {
                            val = ' ' + val;
                        }
                        if (beforeCaret.length > 0 && afterCaret.substr(0, 1) !== ' ') {
                            val = val  + ' ' ;
                        }
                    }
                    let newValue = `${beforeCaret}${scope.suggestionSettings[val] ? scope.suggestionSettings[val].value : val}${afterCaret}`;

                    return newValue;

                };

                let superSelect = typeahead.select;
                typeahead.select = function () {
                    superSelect.call(typeahead);
                    scope.updateSuggestions();
                };
                let superKeyup = typeahead.keyup;
                typeahead.$element.off('keyup');
                typeahead.keyup = function (event) {
                    if (event.which === 13 && (event.ctrlKey)) {
                        event.stopPropagation();
                        scope.applyFilter();
                        return;
                    }
                    superKeyup.call(typeahead,event);
                    if (event.which !== 38 && event.which !== 40)
                        scope.updateSuggestions();
                };
                typeahead.$element.on('keyup', $.proxy(typeahead.keyup, typeahead));

                typeahead.render = function (items) {
                    let that = this;

                    items = $(items).map(function (i, item) {
                        i = $(that.options.item).attr('data-value', item);
                        if (scope.suggestionSettings[item]) {
                            i.find('a').html(`<i>${scope.suggestionSettings[item].suggestion}</i>`);
                        } else {
                            i.find('a').html(that.highlighter(item))
                        }
                        return i[0]
                    });
                    const emptySpace = $('<div class="empty-space" style="width:100%">');
                    emptySpace.on('mousedown', function (e) {
                        e.stopPropagation();
                        typeahead.$element.off('blur');
                    });
                    emptySpace.on('click', function (e) {
                        e.stopPropagation();
                        typeahead.hide();
                        typeahead.$element.on('blur', $.proxy(typeahead.blur, typeahead));
                    });
                    items.push(emptySpace[0]);
                    items.first().addClass('active');
                    this.$menu.html(items);
                    return this
                };
            }

            scope.updateSuggestions = function (event) {
                lastCaretPosition = textarea.selectionStart;
                const textBeforeCaret = !scope.filtering.activeFilter.advancedFilter ? "" : scope.filtering.activeFilter.advancedFilter.substr(0, lastCaretPosition);

                const suggestionResult = FlowFilterParser.suggestTokens(textBeforeCaret);
                const tokens = suggestionResult.tokens;

                if (tokens[tokens.length - 1] in scope.customSuggests) {
                    scope.suggests = scope.customSuggests[tokens[tokens.length - 1]]
                } else {
                    scope.suggests = suggestionResult.suggestions;
                }
                scope.suggests = scope.suggests.filter(e => !suggestionResult.offeringSymbol || suggestionResult.offeringSymbol == '<EOF>' ||  e.toLowerCase().startsWith(suggestionResult.offeringSymbol.toLowerCase()));
                typeahead.lookup();
                if (!typeahead.shown) {
                    typeahead.show();
                }
            };

            overrideTypeahead();
        },
        template:`<textarea rows="5" style="width: 100%"
                    bs-typeahead="suggests" class="{{typeaheadClass}}"
                    ng-keyup="updateSuggestions($event)"
                    ng-click="updateSuggestions($event)"
                    ng-trim="false"
                    ng-model="filtering.activeFilter.advancedFilter" min-length="0">
                  </textarea>`
    }
});

app.directive('facetFilterableList', function ($filter) {
    return {
        scope: {items: '=', model: '=facetFilterableList', showAllItems: '=?', orderBy:'@'},
        transclude: true,
        link: function (scope, element, attr) {
            if (attr.filterFunction) {
                scope.filterFunction = scope.$parent.$eval(attr.filterFunction);
            } else {
                scope.filterFunction = $filter('filter');
            }
            scope.model = scope.model || [];
            scope.onFacetSearchKeyDown = function (e) {
                if (e.keyCode === 27) { // ESC key
                    e.target.blur();
                    angular.element(e.target).scope().$parent.showInput = false;
                    angular.element(e.target).scope().$parent.facetValueSearch = '';
                }
            };
        },
        templateUrl: '/templates/flow-editor/facet-filterable-list.html'
    }
});


app.directive('multiItemsRightColumnSummary', function($controller, $rootScope, $stateParams,
    DataikuAPI, Fn, TaggableObjectsUtils, RecipeDescService, CodeEnvsService,
    FlowGraphSelection, FlowGraphFiltering, SelectablePluginsService, WatchInterestState) {

    return {
        templateUrl:'/templates/flow-editor/multi-items-right-column-summary.html',

        link: function(scope, element, attrs) {
            $controller('_TaggableObjectsMassActions', {$scope: scope});
            $controller('_TaggableObjectsCapabilities', {$scope: scope});

            const getType = attrs.singleType ? () => attrs.singleType : item => item.nodeType;
            const getSelectedItems = attrs.selectedItems ? () => scope.$eval(attrs.selectedItems) : FlowGraphSelection.getSelectedNodes;
            const newItemsWatch = attrs.selectedItems ? () => scope.$eval(attrs.selectedItems) : 'rightColumnItem';

            function getCountByNodeType(selectedNodes) {
                let ret = {};
                selectedNodes.forEach(function(item) {
                    const type = getType(item);
                    ret[type] = (ret[type] || 0) + 1;
                });
                return ret;
            }
            function getCountByTaggableType(selectedNodes) {
                let ret = {};
                selectedNodes.forEach(function(item) {
                    const taggableType = TaggableObjectsUtils.fromNodeType(getType(item));
                    ret[taggableType] = (ret[taggableType] || 0) + 1;
                });
                return ret;
            }

            scope.getTaggableTypeMap = function () {
                let ret = {};
                scope.getSelectedNodes().forEach(function (item) {
                    let type = TaggableObjectsUtils.fromNodeType(getType(item));
                    if (ret.hasOwnProperty(type)) {
                        ret[type].push(getSmartName(item));
                    } else {
                        ret[type] = [getSmartName(item)];
                    }
                })
                return ret;
            }

            function count(nodeType) {
                return scope.selection.countByNodeType[nodeType] || 0;
            }

            function selectedNodes() {
                return scope.selection.selectedObjects;
            }
            scope.getSelectedNodes = selectedNodes;

            function isAll(nodeTypes) {
                return function() {
                    const total = scope.selection.selectedObjects.length;
                    return total > 0 && nodeTypes.map(count).reduce(Fn.SUM) == total;
                };
            }
            function allHaveFlag(propName) {
                return function() {
                    const total = scope.selection.selectedObjects.length;
                    return total > 0 && scope.selection.selectedObjects.filter(Fn.prop(propName)).length == total
                };
            }
            scope.isAllRecipes = isAll(['RECIPE']);
            scope.isAllContinuousRecipes = allHaveFlag("continuous");
            scope.isAllDatasets = isAll(['LOCAL_DATASET', 'FOREIGN_DATASET']);
            scope.isAllFolders = isAll(['LOCAL_MANAGED_FOLDER', 'FOREIGN_MANAGED_FOLDER']);
            scope.isAllStreamingEndpoints = isAll(['LOCAL_STREAMING_ENDPOINT']);
            scope.isAllModels = isAll(['LOCAL_SAVEDMODEL', 'FOREIGN_SAVEDMODEL']);
            scope.isAllEvaluationStores = isAll(['LOCAL_MODELEVALUATIONSTORE', 'FOREIGN_MODELEVALUATIONSTORE']);
            scope.isAllZones = isAll(['ZONE']);
            scope.isAllProjects = isAll(['PROJECT']);
            scope.isAllLocal = isAll(['RECIPE', 'LOCAL_DATASET', 'LOCAL_MANAGED_FOLDER', 'LOCAL_SAVEDMODEL', 'LOCAL_MODELEVALUATIONSTORE']);
            scope.isAllForeign = isAll(['FOREIGN_DATASET', 'FOREIGN_MANAGED_FOLDER', 'FOREIGN_SAVEDMODEL', 'FOREIGN_MODELEVALUATIONSTORE']);
            scope.isAllComputables = isAll(['LOCAL_DATASET', 'FOREIGN_DATASET', 'LOCAL_MANAGED_FOLDER', 'FOREIGN_MANAGED_FOLDER', 'LOCAL_SAVEDMODEL', 'FOREIGN_SAVEDMODEL', 'LOCAL_MODELEVALUATIONSTORE', 'FOREIGN_MODELEVALUATIONSTORE']);
            scope.isAllDatasetsAndFolders = isAll(['LOCAL_DATASET', 'FOREIGN_DATASET', 'LOCAL_MANAGED_FOLDER', 'FOREIGN_MANAGED_FOLDER']);

            scope.getSingleSelectedDataset = function() {
                const candidates = selectedNodes().filter(({nodeType}) => ['LOCAL_DATASET', 'FOREIGN_DATASET'].includes(nodeType));
                return candidates.length == 1 ? candidates[0] : null;
            }

            scope.getSingleSelectedModel = function() {
                const candidates = selectedNodes().filter(({nodeType}) => ['LOCAL_SAVEDMODEL', 'FOREIGN_SAVEDMODEL'].includes(nodeType));
                return candidates.length == 1 ? candidates[0] : null;
            }

            scope.isPredictionModel = function() {
                return scope.singleSelectedModelInfos
                    && scope.singleSelectedModelInfos.model.miniTask.taskType == 'PREDICTION'
                    && scope.singleSelectedModelInfos.model.miniTask.backendType !== 'VERTICA';
            }

            scope.isClusteringModel = function() {
                return scope.singleSelectedModelInfos
                    && scope.singleSelectedModelInfos.model.miniTask.taskType == 'CLUSTERING'
                    && scope.singleSelectedModelInfos.model.miniTask.backendType !== 'VERTICA';
            }

            scope.isDatasetAndModel = function() {
                return selectedNodes().length == 2 && scope.getSingleSelectedDataset() && scope.getSingleSelectedModel();
            }

            scope.isAllMetastoreAware = function() {
                const total = selectedNodes().length;
                const hiveRecipes = selectedNodes().filter(n => TaggableObjectsUtils.isHDFSAbleType(n.datasetType)).length;
                return total > 0 && hiveRecipes == total;
            };
            scope.isAllImpalaRecipes = function() {
                const total = selectedNodes().length;
                const impalaRecipes = selectedNodes().filter(n => (n.recipeType||n.type) == 'impala').length;
                return total > 0 && impalaRecipes == total;
            };
            scope.isAllPythonCodeEnvSelectableRecipes = function() {
                const total = selectedNodes().length;
                const codeEnvSelectableRecipes = selectedNodes().filter(n => (n.recipeType||n.type) && CodeEnvsService.canPythonCodeEnv(n)).length;
                return total > 0 && codeEnvSelectableRecipes == total;
            };
            scope.isAllRCodeEnvSelectableRecipes = function() {
                const total = selectedNodes().length;
                const codeEnvSelectableRecipes = selectedNodes().filter(n => (n.recipeType||n.type) && CodeEnvsService.canRCodeEnv(n)).length;
                return total > 0 && codeEnvSelectableRecipes == total;
            };
            scope.isAllHiveRecipes = function() {
                const total = selectedNodes().length;
                const hiveRecipes = selectedNodes().filter(n => (n.recipeType||n.type) == 'hive').length;
                return total > 0 && hiveRecipes == total;
            };

            scope.isAllManaged = function() {
                const total = selectedNodes().length;
                const managed = selectedNodes().filter(n => n.managed).length;
                return total > 0 && managed == total;
            };
            scope.isAllWatched = function() {
                const total = selectedNodes().length;
                const watched = selectedNodes().filter(n => n.interest && WatchInterestState.isWatching(n.interest.watching)).length;
                return total > 0 && watched == total;
            };
            scope.isAllStarred = function() {
                const total = selectedNodes().length;
                const starred = selectedNodes().filter(n => n.interest && n.interest.starred).length;
                return total > 0 && starred == total;
            };
            scope.isAllVirtualizable = function() {
                return selectedNodes().map(x => !!x.virtualizable).reduce((a,b) => a && b, true);
            };

            scope.anyPipelineTypeEnabled = function() {
                return $rootScope.projectSummary.sparkPipelinesEnabled || $rootScope.projectSummary.sqlPipelinesEnabled;
            };

            function showVirtualizationAction(showDeactivate) {
                return function() {
                    return scope.isProjectAnalystRW()
                        && scope.isAllDatasets()
                        && scope.isAllLocal()
                        && showDeactivate === scope.isAllVirtualizable();
                }
            }
            scope.showAllowVirtualizationAction = showVirtualizationAction(false);
            scope.showStopVirtualizationAction = showVirtualizationAction(true);


            scope.anyMultiEngineRecipe = function() {
                function isMultiEngine(recipeType) {
                    const desc = RecipeDescService.getDescriptor(recipeType);
                    return !!desc && desc.isMultiEngine;
                }
                return !!selectedNodes().filter(node => isMultiEngine(node.recipeType||node.type)).length;
            };

            scope.anyImpala = function() {
                return !!selectedNodes().filter(n => (n.recipeType||n.type) == 'impala').length;
            };

            scope.anyHive = function() {
                return !!selectedNodes().filter(n => (n.recipeType||n.type) == 'hive').length;
            };

            scope.anyCanSpark = function() {
                return !!selectedNodes().filter(node => scope.canSpark(node)).length;
            };

            scope.allAreSparkNotSQLRecipes = function() {
                return selectedNodes().every(node => ['spark_scala','pyspark','sparkr'].indexOf(node.recipeType||node.type) >= 0);
            };

            scope.anyCanSparkPipeline = function() {
                return selectedNodes().some(node => scope.canSparkPipeline(node));
            };

            scope.anyCanSqlPipeline = function() {
                return selectedNodes().some(node => scope.canSqlPipeline(node));
            };

            scope.allAutoTriggersDisabled = function() {
                return scope.getAutoTriggerDisablingReason($rootScope.appConfig, $rootScope.projectSummary);
            };

            scope.autoTriggersObjects = function(autoTriggerStatus, objects) {
                objects.forEach(function(object){
                    object.active = autoTriggerStatus;
                    scope.toggleActive(object);
                })
            };

            scope.isAllUnshareable = function() {
                const total = selectedNodes().length;
                const unshareables = selectedNodes().filter(n => n.usedByZones && n.usedByZones.length && !n.successors.length).length;
                return total > 0 && unshareables == total;
            }

            scope.getSelectedObjectsZones = function() {
                return getSelectedItems().map(n => n.usedByZones[0]);
            }

            scope.getCommonZone = function () {
                const nodesSelected = selectedNodes();
                return nodesSelected.length ? nodesSelected[0].ownerZone : null;
            };

            function getSmartName(it) {
                return it.projectKey == $stateParams.projectKey ? it.name : it.projectKey+'.'+it.name;
            }
            scope.getSmartNames = function () {
                return selectedNodes().map(getSmartName);
            };

            scope.clearSelection = function() {
                FlowGraphSelection.clearSelection();
            };

            scope.refreshData = function() {
                let selectedNodes = getSelectedItems();
                scope.selection = {
                    selectedObjects: selectedNodes,
                    taggableType: TaggableObjectsUtils.getCommonType(selectedNodes, node => TaggableObjectsUtils.fromNodeType(getType(node))),
                    countByNodeType: getCountByNodeType(selectedNodes),
                    countByTaggableType: getCountByTaggableType(selectedNodes)
                };
                scope.usability = scope.computeActionsUsability();
                scope.selectablePlugins =  scope.isAllComputables(selectedNodes) ? SelectablePluginsService.listSelectablePlugins(scope.selection.countByTaggableType) : [];

                scope.singleSelectedDataset = scope.getSingleSelectedDataset();
                scope.refreshSingleSelectedModelInfos();
            };

            scope.refreshSingleSelectedModelInfos = function() {
                if(!scope.getSingleSelectedModel()) {
                    scope.singleSelectedModelInfos = null;
                    scope.singleSelectedModel = null;
                }
                if(scope.getSingleSelectedModel() == scope.singleSelectedModel) {
                    return;
                }
                scope.singleSelectedModel = scope.getSingleSelectedModel();
                scope.singleSelectedModelInfos = null;
                let projectKey = scope.singleSelectedModel.projectKey;
                let name = scope.singleSelectedModel.name;
                DataikuAPI.savedmodels.getFullInfo($stateParams.projectKey, getSmartName(scope.singleSelectedModel)).success(data => {
                    if (!scope.singleSelectedModel || scope.singleSelectedModel.projectKey != projectKey || scope.singleSelectedModel.name != name) {
                        return; // too late, the selected model has changed in the meantime
                    }
                    scope.singleSelectedModelInfos = data;
                    scope.singleSelectedModelInfos.zone = (scope.singleSelectedModel.usedByZones || [])[0] || scope.singleSelectedModel.ownerZone;
                }).error(setErrorInScope.bind(scope));
            };

            scope.filterSelection = function(taggableType) {
                FlowGraphSelection.filterByTaggableType(taggableType);
                scope.refreshData();
            }

            scope.refreshData();
            scope.$watch(newItemsWatch, scope.refreshData);

            scope.collapseSelectedZones = () => {
                scope.toggleZoneCollapse(FlowGraphSelection.getSelectedTaggableObjectRefs(), 'collapseAll');
            }

            scope.expandSelectedZones = () => {
                scope.toggleZoneCollapse(FlowGraphSelection.getSelectedTaggableObjectRefs(), 'expandAll');
            }

            scope.isAllZonesExpanded = function() {
                const allZones = scope.selection.selectedObjects.filter(so => getType(so) === 'ZONE');
                return allZones.filter(z => z.customData.isCollapsed === false).length === allZones.length;
            };

            scope.isAllZonesCollapsed = function() {
                const allZones = scope.selection.selectedObjects.filter(so => getType(so) === 'ZONE');
                return allZones.filter(z => z.customData.isCollapsed === true).length === allZones.length;
            };
        }
    }
});


app.controller('_FlowContextMenus', function($scope, $state, $stateParams, $controller, WT1, GlobalProjectActions, FlowGraph, FlowGraphSelection, FlowGraphFolding, TaggableObjectsUtils) {

    WT1.event("flow-context-menu-open");

    $controller('_TaggableObjectsCapabilities', {$scope: $scope});
    $controller('_TaggableObjectsMassActions', {$scope: $scope});

    $scope.toggleTab = tabName => {
        FlowGraphSelection.clearSelection();
        FlowGraphSelection.onItemClick($scope.object);

       $scope.standardizedSidePanel.toggleTab(tabName);
    };

    $scope.getSelectedTaggableObjectRefs = function() {
        return [TaggableObjectsUtils.fromNode($scope.object)];
    };

    $scope.computeMovingImpact = function() {
        let realNode = $scope.object.usedByZones.length ? FlowGraph.node(`zone__${$scope.object.ownerZone}__${$scope.object.realId}`) : $scope.object;
        var computedImpact = [];
        function addSuccessors(node) {
            if (node.nodeType != "RECIPE") return;
            let successors = node.successors;
            successors.forEach(function(successor) {
                if (successor == realNode.id) return;
                computedImpact.push(TaggableObjectsUtils.fromNode(FlowGraph.node(successor)));
            });
        }

        let predecessor = realNode.predecessors[0];
        if (predecessor && realNode.nodeType != "RECIPE" && !realNode.isHiddenLinkTarget) {
            computedImpact.push(TaggableObjectsUtils.fromNode(FlowGraph.node(predecessor)));
            addSuccessors(FlowGraph.node(predecessor));
        }

        addSuccessors(realNode);
        return computedImpact;
    }

    $scope.zoomToOtherZoneNode = function(zoneId) {
        const otherNodeId = $scope.object.id.replace(/zone__.+?__/, "zone__" + zoneId + "__");
        if ($stateParams.zoneId) {
            $state.go('projects.project.flow', Object.assign({}, $stateParams, { zoneId, id: graphVizUnescape(otherNodeId) }));
        }
        else {
            $scope.zoomGraph(otherNodeId);
            FlowGraphSelection.clearSelection();
            FlowGraphSelection.onItemClick($scope.nodesGraph.nodes[otherNodeId]);
        }
    }

    $scope.$state = $state;
    $scope.$stateParams = $stateParams;
    $scope.othersZones = FlowGraph.nodeSharedBetweenZones($scope.object) ? Array.from(FlowGraph.nodeSharedBetweenZones($scope.object)) : null;

    $scope.startPropagateToolFromRecipe = function(node) {
        const predecessorNodeId = node.predecessors[0];
        const predecessorNode = FlowGraph.get().nodes[predecessorNodeId];
        $scope.startTool('PROPAGATE_SCHEMA', {projectKey: predecessorNode.projectKey, datasetName: predecessorNode.name});
    }

    $scope.selectSuccessors = function() {
        WT1.event("flow-context-menu-select-successors");
        FlowGraphSelection.selectSuccessors($scope.object);
    };

    $scope.selectPredecessors = function() {
        WT1.event("flow-context-menu-select-predecessors");
        FlowGraphSelection.selectPredecessors($scope.object);
    };

    $scope.hasPredecessorsInOtherZone = function(object) {
        return !$stateParams.zoneId && FlowGraphSelection.hasPredecessorsInOtherZone(object);
    }

    $scope.hasSuccessorsInOtherZone = function(object) {
        return !$stateParams.zoneId && FlowGraphSelection.hasSuccessorsInOtherZone(object);
    }

    $scope.foldSuccessors = function() {
        WT1.event("flow-context-menu-fold", {direction:'successors'});
        FlowGraphFolding.foldSuccessors($scope.object);
    };

    $scope.foldPredecessors = function() {
        WT1.event("flow-context-menu-fold", {direction: 'predecessors'});
        FlowGraphFolding.foldPredecessors($scope.object);
    };

    $scope.previewSelectSuccessors = function(object) {
        FlowGraphFolding.previewSelect($scope.object, "successors");
    };

    $scope.previewSelectPredecessors = function(object) {
        FlowGraphFolding.previewSelect($scope.object, "predecessors");
    };

    $scope.previewFoldSuccessors = function(object) {
        FlowGraphFolding.previewFold($scope.object, "successors");
    };

    $scope.previewFoldPredecessors = function(object) {
        FlowGraphFolding.previewFold($scope.object, "predecessors");
    };

    $scope.endPreviewBranch = function() {
        FlowGraphFolding.endPreviewBranch();
    };

    $scope.deleteFlowItem = function() {
        WT1.event('flow-context-menu-delete');

        const type = TaggableObjectsUtils.fromNodeType($scope.object.nodeType);
        const id = $scope.object.name;
        const displayName = $scope.object.description;
        GlobalProjectActions.deleteTaggableObject($scope, type, id, displayName)
            .then(FlowGraphSelection.clearSelection);
    };
});


app.controller("SavedModelContextualMenuController", function($scope, $controller, WT1, DatasetsService) {
    $controller('_FlowContextMenus', {$scope: $scope});

    $scope.trainThisModel = function() {
        WT1.event('flow-context-menu-train');
        $scope.trainModel($scope.object.projectKey, $scope.object.name);
    };
});

app.controller("ModelEvaluationStoreContextualMenuController", function($scope, $controller, WT1, DatasetsService) {
    $controller('_FlowContextMenus', {$scope: $scope});
});


app.controller("ManagedFolderContextualMenuController", function($scope, $controller, WT1) {
    $controller('_FlowContextMenus', {$scope: $scope});

    $scope.buildThis = function() {
        WT1.event('flow-context-menu-build');
        $scope.buildManagedFolder($scope.object.projectKey, $scope.object.id);
    };
});


app.controller("ZoneContextualMenuController", function($scope, $rootScope, $controller, WT1, DataikuAPI, TaggableObjectsUtils, $stateParams, CreateModalFromTemplate, FlowGraph) {
    $controller('_FlowContextMenus', {$scope: $scope});

    $scope.deleteZone = () => {
        DataikuAPI.flow.zones.delete($stateParams.projectKey, $scope.object.name).success(() => {
            if ($stateParams.zoneId) {
                $scope.zoomOutOfZone();
            } else {
                $scope.$emit('reloadGraph');
            }
        }).error(setErrorInScope.bind($scope));
    };

    $scope.openZone = items => {
        const zoneToOpen = items.map(ref => ref.id)[0];
        $scope.zoomOnZone(zoneToOpen);
    }

    $scope.collapseAllZones = () => {
        const allFlowZones = Object.values(FlowGraph.get().nodes).filter(it => TaggableObjectsUtils.fromNodeType(it.nodeType) === 'FLOW_ZONE');
        $scope.toggleZoneCollapse(allFlowZones.map(TaggableObjectsUtils.fromNode), 'collapseAll');
    }

    $scope.expandAllZones = () => {
        const allFlowZones = Object.values(FlowGraph.get().nodes).filter(it => TaggableObjectsUtils.fromNodeType(it.nodeType) === 'FLOW_ZONE');
        $scope.toggleZoneCollapse(allFlowZones.map(TaggableObjectsUtils.fromNode), 'expandAll');
    }

    $scope.collapseSelectedZones = () => {
        $scope.toggleZoneCollapse(FlowGraphSelection.getSelectedTaggableObjectRefs(), 'collapseAll');
    }

    $scope.expandSelectedZones = () => {
        $scope.toggleZoneCollapse(FlowGraphSelection.getSelectedTaggableObjectRefs(), 'expandAll');
    }

    $scope.editZone = () => {
        CreateModalFromTemplate("/templates/zones/edit-zone-box.html", $scope, null, function(newScope){
            newScope.zoneName = $scope.object.description;
            newScope.uiState = {
                stockColors: ["#C82423","#8C2DA7","#31439C","#087ABF","#0F786B","#4B8021","#F9BE40","#C54F00","#D03713","#465A64"],
                newColor: $scope.object.customData.color,
                newName: $scope.object.description
            };

            newScope.pickStockColor = color => {
                newScope.uiState.newColor = color;
            };

            newScope.go = function(){
                DataikuAPI.flow.zones.edit($stateParams.projectKey, $scope.object.name, newScope.uiState.newName, newScope.uiState.newColor).success(function () {
                    $scope.$emit('reloadGraph');
                    if ($stateParams.zoneId) {
                        $rootScope.$emit("zonesListChanged", newScope.uiState.newName);
                    }
                    newScope.dismiss()
                }).error(setErrorInScope.bind(newScope));
            }
        });
    }
});


app.controller("DatasetContextualMenuController", function($scope, $rootScope, $controller, WT1, DataikuAPI, TaggableObjectsUtils) {
    $controller('_FlowContextMenus', {$scope: $scope});

    $scope.buildThisDataset = function() {
        WT1.event('flow-context-menu-build');
        $scope.buildDataset($scope.object.projectKey, $scope.object.name);
    };

    $scope.markAsBuilt = function() {
        WT1.event('flow-context-menu-mark-as-built');
        DataikuAPI.datasets.markAsBuilt([TaggableObjectsUtils.fromNode($scope.object)]).then(function() {
            $rootScope.$emit('reloadGraph');
        }, setErrorInScope.bind($scope));
    };
});


app.controller("ForeignDatasetContextualMenuController", function($scope, $controller, $state, WT1, DataikuAPI) {
    $controller('_FlowContextMenus', {$scope: $scope});
});


app.controller("StreamingEndpointContextualMenuController", function($scope, $rootScope, $controller, WT1, DataikuAPI, TaggableObjectsUtils) {
    $controller('_FlowContextMenus', {$scope: $scope});
});

app.controller("RecipeContextualMenuController", function($scope, $controller, $stateParams, WT1, ComputableSchemaRecipeSave) {
    $controller('_FlowContextMenus', {$scope: $scope});

    $scope.propagateSchema = function() {
        WT1.event('flow-context-menu-propagate-schema');
        ComputableSchemaRecipeSave.handleSchemaUpdateFromAnywhere($scope, $stateParams.projectKey, $scope.object.name)
    }
});


app.controller("SavedModelContextualMenuController", function ($scope, $controller) {
    $controller('_FlowContextMenus', {$scope: $scope});

});

app.controller("ModelEvaluationStoreContextualMenuController", function ($scope, $controller) {
    $controller('_FlowContextMenus', {$scope: $scope});

});


app.controller("MultiContextualMenuController", function($scope, $controller, WT1, FlowGraphSelection, FlowGraphFolding, TaggableObjectsService, TaggableObjectsUtils, FlowGraph) {
    $controller('_FlowContextMenus', {$scope: $scope});

    $controller('_TaggableObjectsMassActions', {$scope: $scope});
    $controller('_TaggableObjectsCapabilities', {$scope: $scope});

    $scope.getSelectedTaggableObjectRefs = FlowGraphSelection.getSelectedTaggableObjectRefs;

    $scope.computeMovingImpact = function() {
        var computedImpact = [];
        var movingItems = FlowGraphSelection.getSelectedTaggableObjectRefs();

        function addSuccessors(node, original) {
            if (node.nodeType != "RECIPE") return;
            node.successors.forEach(function(successor) {
                let newTaggableObjectRef = TaggableObjectsUtils.fromNode(FlowGraph.node(successor));
                if (original && successor == original.id || movingItems.filter(it => it.id == newTaggableObjectRef.id).length) return;
                computedImpact.push(newTaggableObjectRef);
            });
        }
        function computeImpact(node) {
            let predecessor = node.predecessors[0];
            if (predecessor && node.nodeType != "RECIPE") {
                let newTaggableObjectRef = TaggableObjectsUtils.fromNode(FlowGraph.node(predecessor));
                if (computedImpact.filter(it => it.id == newTaggableObjectRef.id).length) return;
                if (!movingItems.filter(it => it.id == newTaggableObjectRef.id).length) {
                    computedImpact.push(newTaggableObjectRef);
                }
                addSuccessors(FlowGraph.node(predecessor), node);
            }

            addSuccessors(node);
        }

        FlowGraphSelection.getSelectedNodes().forEach(function(node) {
            let realNode = node.usedByZones.length ? FlowGraph.node(`zone__${node.ownerZone}__${node.realId}`) : node;
            computeImpact(realNode);
        });
        return computedImpact;
    }

    $scope.selectedObjectsZones = FlowGraphSelection.getSelectedNodes().map(n => n.usedByZones[0]);

    $scope.deleteFlowItems = function() {
        WT1.event('flow-context-menu-delete-multi');

        TaggableObjectsService.delete(FlowGraphSelection.getSelectedTaggableObjectRefs())
            .then(FlowGraphSelection.clearSelection);
    };

    $scope.selectSuccessors = function() {
        WT1.event("flow-context-menu-select-successors-multi");
        FlowGraphSelection.getSelectedNodes().forEach(FlowGraphSelection.selectSuccessors);
    };

    $scope.selectPredecessors = function() {
        WT1.event("flow-context-menu-select-predecessors-multi");
        FlowGraphSelection.getSelectedNodes().forEach(FlowGraphSelection.selectPredecessors);
    };

    $scope.havePredecessors = false;
    $scope.haveSuccessors = false;
    $scope.anyLocalDataset = false;
    $scope.anyLocalFolder = false;
    $scope.anyLocalComputable = false;
    $scope.anyRecipe = false;
    $scope.anyNonVirtualizable = false;
    $scope.anyCanSpark = false;
    $scope.anyCanChangeConnection = false;
    $scope.allShareable = true;
    $scope.allUnshareable = true;
    $scope.isAllZonesCollapsed = true;
    $scope.isAllZonesExpanded = true;

    FlowGraphSelection.getSelectedNodes().forEach(function(node) {
        if (node.nodeType.startsWith('LOCAL')) {
            $scope.anyLocalComputable = true;
        }
        if (node.nodeType == 'LOCAL_DATASET') {
            $scope.anyLocalDataset = true;
            if (!node.virtualizable) {
                $scope.anyNonVirtualizable = true;
            }
        }
        if (node.nodeType == 'LOCAL_MANAGED_FOLDER') {
            $scope.anyLocalFolder = true;
        }
        if (node.nodeType == 'RECIPE') {
            $scope.anyRecipe = true;
            if ($scope.canSpark(node)) {
                $scope.anyCanSpark = true;
            }
        }
        if (node.predecessors.length) {
            $scope.havePredecessors = true;
        }
        if (node.successors.length) {
            $scope.haveSuccessors = true;
        }
        if (["ZONE","RECIPE"].includes(node.nodeType)) {
            $scope.allShareable = false;
        }
        if (!node.usedByZones.length || node.successors.length) {
            $scope.allUnshareable = false;
        }
        if (node.nodeType == "ZONE" && !node.customData.isCollapsed) {
            $scope.isAllZonesCollapsed = false;
        }
        if (node.nodeType == "ZONE" && node.customData.isCollapsed) {
            $scope.isAllZonesExpanded = false;
        }

        $scope.anyCanChangeConnection = $scope.anyCanChangeConnection || $scope.canChangeConnection(node);
    })

});

app.service('FlowFilterQueryService', function() {
    const svc = this;

    this.escapeStr = function (string) {
        if (string.includes(' ') || string.includes('"') || string.includes(':')) {
            return `"${string.replace(/"/g, '\\"')}"`
        }
        return string;
    };

    function uiFilterArrayToQueryClause(elements, key) {
        if (!elements) return;
        const resultString = elements.map(el => key + svc.escapeStr(el)).join(' OR ');
        return elements.length > 1 ? `(${resultString})` : resultString;
    }

    this.pickerFormat = "YYYY-MM-DD HH:mm";

    const queryClauseOrNull = (types, type) => types && types.includes(type) ? uiFilterArrayToQueryClause([type], "type:"): null;

    this.uiFilterToQuery = function(structuredFlowObjectFilter) {

        function formatDate(date) {
            return moment(date).format(svc.pickerFormat);
        }

        const creationDate = structuredFlowObjectFilter.customCreationDateRange;
        const modificationDate = structuredFlowObjectFilter.customModificationDateRange;

        let createdRangeClause;
        let modifiedRangeClause;
        if (structuredFlowObjectFilter.creationDateRange) {
            if (structuredFlowObjectFilter.creationDateRange === 'CUSTOM') {
                createdRangeClause = creationDate && creationDate.from && creationDate.to ? `createdBetween:${formatDate(creationDate.from)} / ${formatDate(creationDate.to)}` : null;
            } else {
                createdRangeClause = `created:${structuredFlowObjectFilter.creationDateRange}`;
            }
        }
        if (structuredFlowObjectFilter.modificationDateRange) {
            if (structuredFlowObjectFilter.modificationDateRange === 'CUSTOM') {
                modifiedRangeClause = modificationDate && modificationDate.from && modificationDate.to ? `modifiedBetween:${formatDate(modificationDate.from)} / ${formatDate(modificationDate.to)}` : null;
            } else {
                modifiedRangeClause = `modified:${structuredFlowObjectFilter.modificationDateRange}`;
            }
        }
        const datasetTypeClause = uiFilterArrayToQueryClause(structuredFlowObjectFilter.datasetTypes, "datasetType:");
        const recipeTypeClause = uiFilterArrayToQueryClause(structuredFlowObjectFilter.recipeTypes, "recipeType:");

        const recipeClauseArr = [queryClauseOrNull(structuredFlowObjectFilter.types, 'RECIPE'), recipeTypeClause].filter(e=>e);
        const recipeClause = recipeClauseArr.length > 1 ? `(${recipeClauseArr.join(' AND ')})` : recipeClauseArr.join(' AND ');
        const datasetClauseArr = [queryClauseOrNull(structuredFlowObjectFilter.types, 'DATASET'), datasetTypeClause].filter(e=>e);
        const datasetClause = datasetClauseArr.length > 1 ? `(${datasetClauseArr.join(' AND ')})` : datasetClauseArr.join(' AND ');

        const typeClauses = structuredFlowObjectFilter.types.filter(e => (e !== 'RECIPE' && e !== 'DATASET')).map(e => uiFilterArrayToQueryClause([e], "type:"));
        const typeWithRefinements = [...typeClauses,recipeClause, datasetClause].filter(e=>e);

        let typeWithRefinementClause = typeWithRefinements.join(' OR ');
        if (typeWithRefinements.length > 1){
            typeWithRefinementClause = `(${typeWithRefinementClause})`
        }

        return [
            uiFilterArrayToQueryClause(structuredFlowObjectFilter.tags, "tag:"),
            uiFilterArrayToQueryClause(structuredFlowObjectFilter.creator, "user:"),
            typeWithRefinementClause,
            createdRangeClause,
            modifiedRangeClause
        ].filter(e => e).join(' AND ');
    }
});

})();

(function() {
'use strict';

/**
 * This file groups functionalities for selecting and highlighting items in the flow graphs
 * (flow, inter project graph and job preview subgraph)
*/


const app = angular.module('dataiku.flow.project');


app.service('FlowGraphSelection', function($rootScope, WT1, FlowGraphFolding, TaggableObjectsUtils, FlowGraph, FlowGraphHighlighting) {
    /*
    * In all this service, "items" are flow items corresponding to graph nodes
    *
    * Several selection strategies (single items selectec at a time, etc)
    * Selection strategies are also responsible for adding highlighting
    * (not for removing it as for now as we always do before calling then)
    *
    * A selection strategy implements:
    * - onItemClick(nodeId, event)
    * - clearSelection()
    */
    const svc = this;

    let selectedItems = [];

    function _isSelected(item) {
        return selectedItems.includes(item);
    }

    function _hasOnlyZonesOrNone(item) {
        return (_isZone(item) && selectedItems.find(elem => !_isZone(elem)) === undefined) || (!_isZone(item) && selectedItems.find(elem => _isZone(elem)) === undefined);
    }

    function _clearSelection() {
        const element = FlowGraph.getDOMElement();
        if (!element) {
            return; //Too early
        }
        selectedItems.forEach(it => it.selected = false);
        $('#flow-graph').removeClass('has-selection');
        d3.selectAll(".zone_cluster.clusterHighlight").each(function() {this.style = null;}).classed("clusterHighlight", false);
        d3.selectAll(".zone_cluster.selected").each(function() {this.style = null;});
        d3.selectAll(element.find('svg .selected')).classed("selected", false);
        selectedItems = [];
    }

    function _addToSelection(items) {
        items = items.filter(it => !_isSelected(it));
        //For nodes used in multiple zones, we need to use a flag to know which one is truely selected
        items.forEach(it => it.selected = true);
        var realIdsSelected = items.map(it => it.realId);
        selectedItems = selectedItems.filter(it => !it.realId || !realIdsSelected.includes(it.realId));
        if (!items.length) {
            return;
        }

        const selector = items.map(it => _isZoned(it) ? `svg [data-node-id="${it.realId}"]` : _isZone(it) ? `svg [id="cluster_${it.id}"]` : `svg [data-id="${it.id}"]`).join(', ');
        d3.selectAll(selector).each(function() {
            const type = this.getAttribute('data-type');
            let key = this.getAttribute('data-id');
            if (type === "ZONE") {
                key = key.replace("cluster_", "");
                FlowGraphHighlighting.highlightZoneCluster(this)
            }
            selectedItems.push(FlowGraph.node(key));
        }).classed("selected", true);

        if (selectedItems.length) {
            $('#flow-graph').addClass('has-selection');
        }
        FlowGraphHighlighting.removeHighlights();
    }

    function _isZoned(item) {
        return item.id && item.realId && item.id !== item.realId;
    }

    function _isZone(item) {
        return item && item.nodeType === 'ZONE';
    }

    function _removeFromSelection(item) {
        const items = _isZoned(item) ? selectedItems.filter(it => it.realId === item.realId) : [item];
        items.forEach(item => {
            item.selected = false;
            const index = selectedItems.indexOf(item);
            if (index > -1) {
                if (_isZone(item)) {
                    d3.select(`g[data-id="${item.id}"]`)[0][0].style = null;
                    FlowGraph.d3ZoneNodeWithId(item.id).classed("selected", false);
                } else {
                    FlowGraph.d3NodeWithId(item.id).classed("selected", false);
                }
                selectedItems.splice(index, 1);
            }
        });

        if (!selectedItems.length) {
            $('#flow-graph').removeClass('has-selection');
        }
    }


    /* Selects one item at a time
    * highlights the predecessors and successors of the selected item
    */
    const singleItemSelectionStrategy = {
        onItemClick: function(item, evt) {
            _clearSelection();
            _addToSelection([item]);
            if (!item.filterRemove) {
                FlowGraphHighlighting.highlightPredecessors(item);
                FlowGraphHighlighting.highlightSuccessors(item);
                if (svc.hasSuccessorsInOtherZone(item)) {
                    FlowGraphHighlighting.highlightUsedZones(item);
                }
                if (_hasOnlyZonesOrNone(item)) {
                    FlowGraphHighlighting.highlightZoneElements(item.name);
                }
            }
        }
    }

    /*
    * Select n items at a time
    */
    const simpleMultiItemSelectionStrategy = {
        onItemClick: function(item, evt) {
            if (!_isSelected(item) && _hasOnlyZonesOrNone(item)) {
                _addToSelection([item]);
            } else {
                _removeFromSelection(item);
            }
            if (_hasOnlyZonesOrNone(item) && !_isZone(item)) {
                d3.selectAll(".zone_cluster.clusterHighlight").each(function() { this.style = null;});
            }
            if (selectedItems.length === 1 && !selectedItems[0].filterRemove && selectedItems[0].id === item.id) {
                FlowGraphHighlighting.highlightPredecessors(item);
                FlowGraphHighlighting.highlightSuccessors(item);
            }
            selectedItems.filter(_isZone).forEach(it => FlowGraphHighlighting.highlightZoneElements(it.name));
        }
    }

    function withAllPredecessorsOrSuccessorsMultiItemSelectionStrategy(mode) {
        if (mode != 'predecessors' && mode != 'successors') {
            throw new Error("mode should be either 'predecessors' or 'successors'")
        }
        return {
            onItemClick: function(item, evt) {
                // For performance we list and then select them all at once:
                const itemsToSelect = this._listPredecessorsOrSuccessors(item).map(FlowGraph.node);
                _addToSelection(itemsToSelect);
            },

            _listPredecessorsOrSuccessors: function(item, list) {
                list = list || [];

                if (list.includes(item.id)) {
                    // Avoid loops
                    return list;
                }
                list.push(item.id);

                const that = this;

                if (_isZoned(item) && !(mode == "predecessors" && item.usedByZones.length == 0)) {
                    let zoneNode = FlowGraph.node("zone_" + (item.usedByZones[0] || item.ownerZone));
                    if (zoneNode) {
                        $.each(zoneNode[mode], function (index, otherZoneNodeId) {
                            const otherNodeId = graphVizEscape((mode == "predecessors" ? `zone_${item.ownerZone}` : otherZoneNodeId));
                            const otherNode = FlowGraph.node(otherNodeId + "__" + item.realId);
                            if (otherNode) {
                                list = that._listPredecessorsOrSuccessors(otherNode, list);
                            }
                        });
                    }
                }

                $.each(item[mode], function (index, otherNodeId) {
                    const otherNode = FlowGraph.node(otherNodeId);
                    list = that._listPredecessorsOrSuccessors(otherNode, list);
                });
                return list;
            }
        }
    }

    const selectionStrategies = {
        'SINGLE': singleItemSelectionStrategy,
        'MULTI': simpleMultiItemSelectionStrategy,
        'MULTI_WITH_SUCCESSORS': withAllPredecessorsOrSuccessorsMultiItemSelectionStrategy('successors'),
        'MULTI_WITH_PREDECESSORS': withAllPredecessorsOrSuccessorsMultiItemSelectionStrategy('predecessors')
    };

    let activeStrategy = singleItemSelectionStrategy;

    this.onItemClick = function(item, evt) {
      if (activeStrategy !== selectionStrategies['DISABLED']) {
            if (evt && (evt.shiftKey || evt.metaKey || evt.ctrlKey)) {
                simpleMultiItemSelectionStrategy.onItemClick(item, evt);
            } else {
                activeStrategy.onItemClick(item, evt);
            }
            d3.selectAll('svg .node:not(.highlight), svg .edge:not(.highlight)').classed('fade-out', true);
        }
        $rootScope.$emit('flowSelectionUpdated');
        $rootScope.$emit('flowDisplayUpdated');
        $rootScope.$emit('flowItemClicked', evt, item);
    };

    this.clearSelection = function() {
        if (selectedItems.length) {
            FlowGraphHighlighting.removeHighlights();
            _clearSelection();

            $rootScope.$emit('flowSelectionUpdated');
            $rootScope.$emit('flowDisplayUpdated');
        }
    };

    // We need to call this after a new serialized graph has been fetched and rendered
    this.refreshStyle = function(redoSelection = false) {
        const element = FlowGraph.getDOMElement();
        if (!element) {
            return; //Too early
        }
        d3.selectAll(element.find('svg .selected')).classed("selected", false);
        if (selectedItems.length) {
            // Selected items are nodes, if they are part of the old graph they should be replaced by their new version
            selectedItems = selectedItems.map(it => Object.assign({}, FlowGraph.node(it.id), {selected: it.selected})).filter(x => !!x && x.id);
            const selector = selectedItems.map(it => _isZoned(it) ? `svg [data-node-id="${it.realId}"]` : _isZone(it) ? `svg [id="cluster_${it.id}"]` : `svg [data-id="${it.id}"]`).join(', ');
            if (selector.length) {
                d3.selectAll(selector).each(function() {
                    const type = this.getAttribute('data-type');
                    if (type === "ZONE") {
                        FlowGraphHighlighting.highlightZoneCluster(this)
                    }
                }).classed("selected", true);
            }
            if (redoSelection) {
                const oldSelection = [...selectedItems.filter(it => it.selected)];
                const strategy = selectionStrategies[oldSelection.length > 1 ? 'MULTI' : 'SINGLE'];
                oldSelection.forEach(item => {
                    strategy.onItemClick(item); // Deselect in multi
                    if (oldSelection.length > 1) {
                        strategy.onItemClick(item); // Select in multi
                    }
                });
            }
        }
        $rootScope.$emit('flowSelectionUpdated');
    };

    function select(predicate1) {
        return function(predicate) {
            let toSelect = Object.values(FlowGraph.get().nodes);
            if (predicate1) {
                toSelect = toSelect.filter(predicate1);
            }
            if (predicate) {
                toSelect = toSelect.filter(predicate);
            }

            toSelect = toSelect.filter((node) => !FlowGraphFolding.isNodeFolded(node.id));
            _clearSelection();
            _addToSelection(toSelect);
            selectedItems.filter(_isZone).forEach(it => FlowGraphHighlighting.highlightZoneElements(it.name));
            $rootScope.$emit('flowSelectionUpdated');
        };
    }

    /* These functions allow to select items based on a predicate
    * (User code does NOT provide items, they are read from FlowGraph)
     */
    this.select = select();
    this.selectAllByType = taggableType => {
        select(it => !it.filterRemove && TaggableObjectsUtils.fromNodeType(it.nodeType) == taggableType)();
    };

    this.filterByTaggableType = function(taggableType) {
        const selectedBefore = selectedItems.length;

        const toRemove = selectedItems.filter(it => TaggableObjectsUtils.fromNodeType(it.nodeType) != taggableType);
        toRemove.forEach(_removeFromSelection);

        const selectedAfter = selectedItems.length;
        if (selectedAfter != selectedBefore) {
            $rootScope.$emit('flowSelectionUpdated');
        }
    };

    this.getSelectedNodes = function() {
        return selectedItems.filter(it => it.selected);
    };

    this.getSelectedTaggableObjectRefs = function() {
        return svc.getSelectedNodes().map(TaggableObjectsUtils.fromNode);
    };

    this.setSelectionStrategy = function(name='SINGLE') {
        if (typeof name === 'string') {
            // strategy by name
            if (selectionStrategies[name]) {
                WT1.event("flow-graph-set-selection-strategy", { strategy: name });
                _clearSelection();
                activeStrategy = selectionStrategies[name];
            } else {
                throw new Error("Selection strategy does not exist: " + name)
            }
        } else {
            // custom strategy
            activeStrategy = name;
        }
    };

    this.selectSuccessors = function(item, evt) {
        $('.select-preview').removeClass('select-preview'); //remove preview styling
        selectionStrategies['MULTI_WITH_SUCCESSORS'].onItemClick(item, evt);
        $rootScope.$emit('flowSelectionUpdated');
    };
    this.selectPredecessors = function(item, evt) {
        $('.select-preview').removeClass('select-preview');
        selectionStrategies['MULTI_WITH_PREDECESSORS'].onItemClick(item, evt);
        $rootScope.$emit('flowSelectionUpdated');
    };

    this.hasPredecessorsInOtherZone = function(item) {
        return item.usedByZones.length > 0;
    };
    this.hasSuccessorsInOtherZone = function(item) {
        let hasSuccessors = false;
        if (_isZoned(item)) {
            let zoneNode = FlowGraph.node("zone_" + item.ownerZone);
            if (zoneNode) {
                $.each(zoneNode["successors"], function (index, otherZoneNodeId) {
                    const otherNode = FlowGraph.node(graphVizEscape(otherZoneNodeId) + "__" + item.realId);
                    if (otherNode) {
                        hasSuccessors = true;
                        return false;
                    }
                });
            }
        }
        return hasSuccessors;
    }
});


app.service('FlowGraphHighlighting', function(FlowGraph) {

    function removeHighlights() {
        d3.selectAll('.highlight, .fade-out').classed('highlight', false).classed('fade-out', false);
    }

   function removeFiltersRemoved() {
        d3.selectAll('.filter-remove').classed('fade-out--no-filter', false).classed('filter-remove', false);
    }
    function highlightPredecessors(item) {
        let element;
        let nodeElt;
        function _highlightPredecessorsRecursive(nodeType, nodeId) {
            nodeElt = nodeType === 'ZONE' ? FlowGraph.d3ZoneNodeWithId(nodeId) : FlowGraph.d3NodeWithId(nodeId);
            if (!nodeElt || !nodeElt.node()) {
                console.debug('Graph node not found', nodeId)
                return;
            }
            if (nodeElt.classed('filter-remove')) {
                return;
            }

            if (!nodeElt.classed('highlight')) {
                // prevents cycles and dreadful infinite loops
                nodeElt.classed('highlight', true).classed('fade-out', false);
                // highlight nodes
                FlowGraph.rawEdgesWithToId(nodeId).forEach(function (elt) {
                    d3.select(elt).classed('highlight', true).classed('fade-out', false);
                });
                // highlight former nodes
                $.each(FlowGraph.node(nodeId).predecessors, function (index, id) {
                    _highlightPredecessorsRecursive(nodeType, id);
                });
            }
        }
        try {
            element = FlowGraph.getDOMElement();
            _highlightPredecessorsRecursive(item.nodeType, item.id);
            d3.selectAll('svg .node:not(.highlight), svg .edge:not(.highlight)').classed('fade-out', true);
        } catch (e) {
            console.error("Failed to highlight items", nodeElt, e); // NOSONAR: OK to use console.
        }
    }

    function highlightSuccessors(item) {
        let element;
        let nodeElt;
        function _highlightSuccessorsRecursive(nodeType, nodeId, force) {
            nodeElt = nodeType === 'ZONE' ? FlowGraph.d3ZoneNodeWithId(nodeId) : FlowGraph.d3NodeWithId(nodeId);
            if (!nodeElt || !nodeElt.node()) {
                console.debug('Graph node not found', nodeId)
                return;
            }
            if (nodeElt.classed('filter-remove')) {
                return;
            }

            if (force || !nodeElt.classed('highlight')) {
                // prevents cycles and dreadful infinite loops
                nodeElt.classed('highlight', true).classed('fade-out', false);
                // highlight nodes
                FlowGraph.rawEdgesWithFromId(nodeId).forEach(function (elt) {
                    d3.select(elt).classed('highlight', true).classed('fade-out', false);
                });
                // highlight former nodes
                $.each(FlowGraph.node(nodeId).successors, function (index, successorNodeId) {
                    _highlightSuccessorsRecursive(nodeType, successorNodeId, false);
                });
            }
        }

        try {
            element = FlowGraph.getDOMElement();
            _highlightSuccessorsRecursive(item.nodeType, item.id, true);
            d3.selectAll('svg .node:not(.highlight), svg .edge:not(.highlight)').classed('fade-out', true);
        } catch (e) {
            console.error("Failed to highlight items", nodeElt, e); // NOSONAR: OK to use console.
        }
    }

    function highlightZoneElements(zoneId) {
        let svg = FlowGraph.getSvg();
        svg.find('g[data-zone-id="' + zoneId + '"]').each(function() {
            highlight(this.id);
        });
    }

    function highlightUsedZones(item) {
        let zoneId = 'zone_' + (item.usedByZones[0] || item.ownerZone);
        let zoneNode = FlowGraph.node(zoneId);
        highlightZoneCluster(d3.select(`g[id="cluster_${zoneId}"]`)[0][0]);
        if (item.usedByZones.length) {
            zoneNode.predecessors.forEach(function(otherZoneId) {
                if (!FlowGraph.node(`${graphVizEscape(otherZoneId)}__${item.realId}`)) return;
                d3.select(`g[data-from="${otherZoneId}"][data-to="${zoneId}"]`).classed('highlight',true);
                highlightZoneCluster(d3.select(`g[id="cluster_${otherZoneId}"]`)[0][0]);
            });
        } else {
            zoneNode.successors.forEach(function(otherZoneId) {
                if (!FlowGraph.node(`${graphVizEscape(otherZoneId)}__${item.realId}`)) return;
                d3.select(`g[data-to="${otherZoneId}"][data-from="${zoneId}"]`).classed('highlight',true);
                highlightZoneCluster(d3.select(`g[id="cluster_${otherZoneId}"]`)[0][0]);
            });
        }
    }

    function highlightZoneCluster(cluster, forcedColor) {
        let node = FlowGraph.node(cluster.getAttribute("data-id"));
        const color = d3.rgb(forcedColor || node.customData.color);
        let zoneTitleColor = (color.r*0.299 + color.g*0.587 + color.b*0.114) >= 128 ? "#000" : "#FFF"; //black or white depending on the zone color
        $(cluster).toggleClass('clusterHighlight',true);
        cluster.style = `color:${zoneTitleColor};background-color:${color.toString()};stroke:${color.toString()}`
    }

        // Highligh one or more nodes
        function highlight(nodesId) {
            let element;
            let nodeElt;
            function _highlightOne(nodeId) {
                nodeElt = FlowGraph.d3NodeWithId(nodeId);
                if (!nodeElt || !nodeElt.node()) {
                    console.debug('Graph node not found', nodeId);
                    return;
                }

                if (nodeElt.classed('filter-remove')) {
                    return;
                }

                if (!nodeElt.classed('highlight')) {
                    // prevents cycles and dreadful infinite loops
                    nodeElt.classed('highlight', true).classed('fade-out', false);
                    // highlight nodes
                    element.find('svg [data-to="' + nodeId + '"]').each(function () {
                        d3.select(this).classed('highlight', true).classed('fade-out', false);
                    });
                }
            }
            try {
                element = FlowGraph.getDOMElement();
                if (Object.prototype.toString.call(nodesId) == '[object Array]') {
                    nodesId.forEach(function(nodeId) {
                        _highlightOne(nodeId);
                    });
                } else {
                    _highlightOne(nodesId);
                }
            } catch (e) {
                console.error("Failed to highlight items", nodeElt, e); // NOSONAR: OK to use console.
            }
        }

        return {
            removeHighlights: removeHighlights,
            removeFiltersRemoved: removeFiltersRemoved,
            highlightPredecessors: highlightPredecessors,
            highlightSuccessors: highlightSuccessors,
            highlightZoneElements: highlightZoneElements,
            highlightUsedZones: highlightUsedZones,
            highlightZoneCluster: highlightZoneCluster,
            highlight: highlight
        }
});


app.directive('highlightDependenciesOnHover', function($rootScope, $timeout, FlowGraphSelection, FlowGraphHighlighting, FlowGraph) {
    return {
        link: function(scope, element) {
            let cur = null;

            element.on('mouseenter', 'svg [class~=node]', function (e) {
                if (FlowGraphSelection.getSelectedNodes().length) {
                    return; // Some items are selected, disable highlight on hover
                }
                let node = $(this);
                if (cur) $timeout.cancel(cur);
                cur = $timeout(function() {
                    const nodeId = node.attr('data-id');
                    const item = FlowGraph.node(nodeId);
                    if (!item || item.filterRemove) {
                        return;
                    }
                    FlowGraphHighlighting.highlightPredecessors(item);
                    FlowGraphHighlighting.highlightSuccessors(item);
                    cur = null;
                }, 100);
            });

            element.on('mouseleave', 'svg [class~=node]', function (e) {
                if (scope.rightColumnItem) {
                    return; // An item is selected, disable highlight
                }

                if (cur) $timeout.cancel(cur);
                FlowGraphHighlighting.removeHighlights();
            });
        }
    };
});

})();

(function() {
    'use strict';

    /**
     * This file contains the functionality for folding and unfolding branches of the flow
     * The UI allows you to select any node in the flow (referred to as the rootItem) and fold the branch
     * upstream (FoldDirection.predecessors) or downstream (FoldDirection.successors)
     *
     * The underlying SVG flowgraph produced by GraphViz on the server is not changed when folding.
     * Instead, the folding is achieved by manipulating the browser DOM directly.  Mostly this involves tagging nodes
     * and edges as folded using the CSS classes: folded-node and folded-edge
     *
     * To unfold a node you click on a + symbol alongside folded node.  This symbol is created by inserting
     * SVG elements into the most appropriate edge from the folded node.  The most appropriate edge is currently
     * the line that leaves the node at the most horizontal angle - which is calculated by decomposing the SVG path
     * path that GraphViz created for the line, and doing some dodgy trigonometry to determine the angle of the last
     * section of the path.
     *
     * The elements inserted to form a 'boundary marker' look something like:
     *  <g class="folded-icon" data-folded-node-id="..." data-folded-direction="successors">
     *    <path d="...." class="folded-boundary-marker-line"></path>
     *    <g>
     *        <circle cx="0" cy="0" r="16" class="folded-boundary-marker-circle"></circle>
     *        <path d="M0,-11 V11 M-11,0 H11" stroke="#000000" fill="none" class="folded-boundary-marker-plus"></path>
     *     </g>
     *  </g>
     *
     *  data-folded-node-id indicates the node to be unfolded when the boundary marker clicked.  The direction
     *  indicated by data-folded-direction.
     *
     * Boundary markers are also needed where ever the folded branches have an edge linked to a node outside the branch.
     *
     * We need to flag boundary markers that are hidden when the branch they are in has been folded -
     * these are called 'nested boundary edges' and marked with CSS class folded-nested.
     *
     * To achieve a consistent behaviour when folding and unfolding nodes in different orders, and when refreshing
     * the page, we remember the state as a sequence of fold requests.  An unfold command simply removes a previous
     * fold command from the state.  This fold state is held in the GraphZoomTrackerService.
     *
     * The processing of a fold/unfold command is made as follows:
     * 1.  Update the fold state held in the GraphZoomTrackerService.
     * 2.  Retrieve the full fold state from the service. This consists entirely of 'fold' commands - there are no
     *     'unfold' commands.
     * 3.  Build a complete logical view of the fold state of the flow by looping through each fold command (FoldCommand)
     *     in the fold state and calling buildFoldReqst to calculate the impact of the command.  This logical view is
     *     held in the FoldReqst object.
     * 4.  The FoldReqst object is passed to applyFoldReqstToDom, which make the necessary
     *     DOM changes based on the contents of the object via D3.
     * 5.  Since the FoldReqst object tracks the active elements, we need to also be able to remove previous DOM
     *     updates that are unnecessary (i.e. we 'reshow items').  This appears to be slightly beyond what D3 can achieve
     *     (happy to hear to the contrary!), so we keep track of which DOM elements we have updated in the FoldDomStatus
     *     object. Each new FoldReqst object is applied to the FoldDomStatus object, and a list of elements to 'reshow'
     *     is generated.
     * 6.  The list of items to reshow is processed via reShowFoldedDomItems.
     *
     * The previewing of folding, unfolding and branch selection uses much the same sequences of steps, but is
     * lighter-weight since it only changes the CSS classes on nodes and edges.  It does not change boundary markers.
     *
     * * NB: Anytime the doc mentions an 'activated' node, it means that the node has been manipulated by the flow_folding system
     * (to hide it or to change its appearance in the case of boundaryEdges)
     *
     */

    const app = angular.module('dataiku.flow.project');

    const FoldDirections = {
        predecessors: 'predecessors',
        successors: 'successors',
        getOpposite(val) {
            return (val == this.predecessors ? this.successors : this.predecessors);
        }
    };

    const FoldActions = {
        fold: 'fold',
        unfold: 'unfold'
    };

    app.service('FlowGraphFolding', function ($rootScope, WT1, TaggableObjectsUtils, FlowGraph, FlowGraphHighlighting, GraphZoomTrackerService, $timeout, LoggerProvider) {

        const Logger = LoggerProvider.getLogger('FlowGraphFolding');

        const svc = this;

        let foldedNodeCount = 0; // tracks the fold status to drive a 'hidden items' count on the flow view
        let activeFoldDomStatus; // maps of every DOM manipulation we've map so far

        const FoldDomStatusMapIdx = {
            node: 0,
            edge: 1,
            nestedBoundaryEdge: 2,
            boundaryEdge: 3
        }

        function getSelectorByIdFromList (list) {
            const sel = list.map(
                id => `svg [id="${id}"]`).join(', ');
            return sel == "" ? [] : sel;
        }

        let FoldDomStatus = function(){
            return {
                // Four maps for: nodes, edges, nestedBoundaryEdges, boundaryEdges
                maps:[{},{},{},{}],

                /**
                 * Takes the new list of ids which are part of the complete fold and
                 * compares these with the 'FoldDomStatus' map of currently 'activated' DOM ids.
                 * The function updates the 'FoldDomStatus' map of DOM ids which are 'activated',
                 * and returns a list of ids to be deactivated.
                 *
                 * @param newIdsList - array of Ids now be 'activated'
                 * @param mapIdx - 0, 1, 2, or 3 depending on which type of item we want to update (0 to update the nodes map, 1 for the edges one, etc.)
                 * @returns a list of existing activated DOM items to be de-
                 */
                updateStatusList: function (newIdsList, mapIdx) {

                    // flag all the items which need to be kept, so we can see which don't
                    const existingItemsMap = this.maps[mapIdx];
                    newIdsList.forEach(id => {
                        existingItemsMap[id] = true; // we need to keep this entry, or we add new entry
                    });

                    let newItemsMap = {};
                    let deactivateList = [];

                    Object.keys(existingItemsMap).forEach(id => {
                        if (existingItemsMap[id]) {
                            newItemsMap[id] = false;
                        }
                        else  {
                            deactivateList.push(id);
                        }
                    });

                    this.maps[mapIdx] = newItemsMap; // update map with new items
                    return deactivateList; // return list of items to deactivate
                },

                /**
                 * Update all the FoldDomStatus' maps of acticate DOM elements.
                 * @param listofListOfIds - array of four lists of IDs, corresponding to the four maps held in FoldDomStatus.
                 *                          This param represents the new foldState to be applied
                 * @returns - array of fours lists containing Ids of DOM items to be 'deactivated' - loosely speaking 'unfolded'
                 */
                update: function (listofListOfIds) {
                    const unFoldInfo = [];
                    listofListOfIds.forEach((list, i) => unFoldInfo.push(this.updateStatusList(list, i)));
                    return unFoldInfo;
                },

                previewStatusList: function (newIdsList, mapIdx) {

                    // flag all the items which need to be kept, so we can see which don't
                    const existingItemsMap = this.maps[mapIdx];
                    const differencesMap = angular.copy(existingItemsMap);

                    // flag all matching items as true, add missing items as false.
                    // result is all differences are marked false
                    newIdsList.forEach(id => {
                        if (differencesMap.hasOwnProperty(id)){
                            differencesMap[id] = true; // we need to keep this entry,
                        }
                         else {
                            differencesMap[id] = false; // new entry
                        }
                    });

                    let differencesList = [];

                    Object.keys(differencesMap).forEach(id => {
                        if (!differencesMap[id]) {
                            differencesList.push(id);
                        }
                    });

                    return differencesList;
                },

                getPreviewItems : function (listofListOfIds) {
                    const itemsToActivate = [];
                    listofListOfIds.forEach((list, i) => itemsToActivate.push(this.previewStatusList(list, i)));
                    return itemsToActivate;
                }
            };
        }

        /**
         * FoldReqst - returns the structure that defines the DOM operations required to perform a sequence of
         * fold commands
         * @param rootItem: the item which is being folded to unfolded
         * @param direction: a value of FoldDirections i.e. upstream (predecessors) or downstream (successors)
         * @returns a structure describing who are the DOM elements that need to be manipulated
         *
         */
        let FoldReqst = function (rootItem, direction, isUseCssTransitions) {
            return {
                direction: direction,
                rootItem: rootItem,
                idsToRemainShownList: [],       // list of ids of items that we do not want to hide with the folding
                                                // e.g. an item we are zooming to, or on the hidden end of a +  sign
                                                // we are trying to unfold
                nodeIdMap: {},                  // id=>element map of all the node elements being folded/unfolded. Used to detect loops
                nodeEls: [],                    // array of all the node elements being folded/unfolded

                edgeEls: [],                    // array of edge elements to fold/unfold
                edgeIdMap: {},
                branchEdgeIdMap: {},            // id=>element map of all the edges in the core branch being manipulated. Used to validate potential boundary markers

                boundaryEdges: [],              // array of edges (Flow item structures not SCG elements) which are boundary makers for the fold
                boundaryEdgeMap: {},
                boundaryEdgeMapByNode: {},

                nestedBoundaryEdgeIds: [],      // boundary edges from earlier folds that must now be hidden
                nestedBoundaryEdgeIdMap: {},
 
                isUseCssTransitions: isUseCssTransitions,

                copyFoldStateData: function(from, to) {
                    ['nodeIdMap', 'edgeIdMap', 'branchEdgeIdMap', 'boundaryEdgeMap', 'boundaryEdgeMapByNode', 'nestedBoundaryEdgeIdMap'].forEach(key => {
                        to[key] = Object.assign({}, from[key]);
                    });

                    ['nodeEls', 'edgeEls', 'boundaryEdges', 'nestedBoundaryEdgeIds'].forEach(key => {
                        to[key] = from[key].slice();
                    });

                    return to;
                },

                backupFoldState: function() {
                    this.foldStateBackup  = this.copyFoldStateData(this, {});
                },

                restoreFoldState: function() {
                    this.copyFoldStateData(this.foldStateBackup, this);
                },

                getRootNode: function () {
                    return FlowGraph.rawNodeWithId(this.rootItem.Id);
                },

                getBoundaryEdgeDescr: function (edgeId) {
                    return this.boundaryEdgeMap.hasOwnProperty(edgeId) ? this.boundaryEdgeMap[edgeId] : undefined;
                },

                getBoundaryEdges: function () {
                    return this.boundaryEdges.map(it => it.el);
                },

                getNestedBoundaryEdgesSelector: function () {
                    return getSelectorByIdFromList(this.nestedBoundaryEdgeIds);
                },

                isNodeFolded: function (nodeId) {
                    return this.nodeIdMap.hasOwnProperty(nodeId);
                },

                isEdgeFolded: function (edgeId) {
                    return this.edgeIdMap.hasOwnProperty(edgeId);
                },

                isBoundaryEdge: function (edgeId) {
                    return this.boundaryEdgeMap.hasOwnProperty(edgeId);
                },

                addNode: function(el, item) {
                    if (this.nodeIdMap[el.id]) return;

                    this.idsToRemainShownList.forEach(idToRemainShown => {
                        if (idToRemainShown == item.id) {
                            this.isItemToRemainShownWillBeHidden = true;
                        }
                    });

                    this.nodeEls.push(el);
                    this.nodeIdMap[item.id] = item;
                },

                addEdge: function(el, isMainBranch) {
                    if (this.edgeIdMap[el.id]) return;

                    this.edgeEls.push(el);
                    this.edgeIdMap[el.id] = el;
                    if (isMainBranch) this.branchEdgeIdMap[el.id] = el;
                },

                addBoundaryEdge: function(newEdgeDescr) {
                    const mapKey = newEdgeDescr.boundaryNodeId + this.rootItem.id + this.direction;

                    if (this.boundaryEdgeMapByNode.hasOwnProperty(mapKey)) return;

                    newEdgeDescr.rootItemId = this.rootItem.id;
                    newEdgeDescr.direction = this.direction;
                    this.boundaryEdgeMap[newEdgeDescr.el.id] = newEdgeDescr;
                    this.boundaryEdgeMapByNode[mapKey] = newEdgeDescr;
                    this.boundaryEdges.push(newEdgeDescr);

                    // these should always be hidden edges
                    this.addEdge(newEdgeDescr.el);
                },

                addNestedBoundaryEdge: function(edge) {
                    if (this.nestedBoundaryEdgeIds.hasOwnProperty(edge.id)) return;

                    this.nestedBoundaryEdgeIds.push(edge.id);
                    this.nestedBoundaryEdgeIdMap[edge.id] = edge;
                },

                isEdgeNeedsProcessing: function(edge) {
                    return !this.edgeIdMap[edge.id];
                }
            };
        }

        /**
         * Fold command - a structure to describe a fold or unfold operation.
         * An array of these are saved in the GraphZoomTrackerService to enable the fold statue to be restored
         */
        const FoldCommand = function (nodeId, direction, action) {
            return {
                nodeId: nodeId,
                direction: direction,
                action: action
            }
        }

        /**
         * lineAnalyser - a set of functions for processing edge (SVG path) information and help us determine the new
         * path we will add from the node to the boundary marker circle.
         */
        const lineAnalyser = {

            /**
             * addXyDeltasToLineInfo: enrich a line description which is in global co-ordinates to
             * give the relative change in X and Y co-ordinates (dX, dY)
             *
             * @param lineInfo: the line description to be enriched
             * @returns enriched lineInfo with dX and dY
             */
            addXyDeltasToLineInfo: function (lineInfo) {
                lineInfo.dX = lineInfo.endPoint.x - lineInfo.ctlPoint.x;
                lineInfo.dY = lineInfo.endPoint.y - lineInfo.ctlPoint.y;
                return lineInfo;
            },

            /**
             * addTrigToLineInfo: enrich a line description (dX, dY calculated already) to contain the length
             * if the line (hypot) and the angle of the line (angle) in radians
             *
             * @param lineInfo: the line description to be enriched
             * @returns enriched lineInfo with hypot and angle
             */
            addTrigToLineInfo: function (lineInfo) {
                this.addXyDeltasToLineInfo(lineInfo);
                lineInfo.hypot = Math.sqrt(Math.pow(lineInfo.dX, 2) + Math.pow(lineInfo.dY, 2));
                lineInfo.angle = Math.asin(lineInfo.dY / lineInfo.hypot);
                return lineInfo;
            },

            /**
             * findIconCentre: calculate the centre of the + sign in boundary marker.
             *
             *
             * @param lineInfo: a fully enriched line description
             * @param distXFromEnd: how far the centre should be from the end of the line along the X axis.
             * @returns an {x,y) co-ord structure
             */
            findIconCentre: function (lineInfo, distXFromEnd) {
                // some shockingly sloppy geometry.  This is not proper trig but near enough for a short line
                const scalingFactor = distXFromEnd / lineInfo.hypot;
                return {
                    x: lineInfo.endPoint.x - lineInfo.dX * scalingFactor,
                    y: lineInfo.endPoint.y - lineInfo.dY * scalingFactor
                };
            },

            /**
             * extendEndPoint: extend the length of a line that will be a boundary marker
             *
             * We need to do this because the line path we base our marker on doesn't actually go all the way to the
             * node at the end with the 'arrow'.  It stops shorts to give room for said arrow (actually a circle).
             *
             * @param lineInfo: a fully enriched line description
             * @param extendBy: how far you extend the line by
             * @returns lineInfo enriched with endPoint co-ordinate record
             */
            extendEndPoint: function (lineInfo, extendBy) {
                lineInfo.endPoint.x = lineInfo.endPoint.x + extendBy * Math.cos(lineInfo.angle);
                lineInfo.endPoint.y = lineInfo.endPoint.y + extendBy * Math.sin(lineInfo.angle);
                return lineInfo;
            },

            /**
             * extractFoldingInfoFromEdgePath: extract a description of the last section of the SVG path that
             * represents a curved edge between nodes.  We use this line as the basis for the edge from the node to the
             * boundary marker circle.  Ultimately a new path will be added from the node to the boundary circle which
             * uses the same start point and angle as the line we extract here.
             *
             * @param el: the edge SVG element
             * @param direction: which end of the curve we want to look at
             * @returns lineInfo fully enriched with trig info
             */
            extractFoldingInfoFromEdgePath: function (el, direction) {
                let info = {};

                const dAttr = el.firstElementChild.getAttribute("d");

                //extract end point and direct from the end of a Bezier cubic curve definition
                // PATH d attribute has format:
                //  d="M<start-x>,<start-y>C<ctl-point-x1>,<ctl-point-y1> <ctl-point-x2>,<ctl-point-y2> ... <end-x><end-y>"

                let tokens = dAttr.split(/[ MC]/);
                if (tokens.length < 2) return undefined;

                function buildCoord(s) { //expect string of format 123456,456789,
                    const tokens = s.split(",");
                    return (tokens.length > 1) ? {x: parseInt(tokens[0], 10), y: parseInt(tokens[1], 10)} : undefined;
                }

                if (direction == FoldDirections.successors)
                    info = {endPoint: buildCoord(tokens[1]), ctlPoint: buildCoord(tokens[2])};
                else
                    info = {endPoint: buildCoord(tokens.pop()), ctlPoint: buildCoord(tokens.pop())};

                return this.addTrigToLineInfo(info);
            },

            /**
             * initBoundaryEdgeData = the externally-called function to build the description of the boundary marker
             * @param el: the SVG element which is the edge we are aligning our boundary marker with.
             * @param direction: which end of the edge lement we want to put the boundar marker
             * @returns a structure which defines the new path we will create for the boundary marker
             */
            initBoundaryEdgeData: function (el, direction) {
                const distPlusIconFromEnd = 60; // how far the + icon is from the end of the line.
                const arrowTipWidth = 5; // the arrow tip is actually a circle.

                //get the first PATH statement, and then extract end point and last ctl-point.
                let info = this.extractFoldingInfoFromEdgePath(el, direction);

                if (direction != FoldDirections.successors) info = this.extendEndPoint(info, arrowTipWidth); //extend lines when folding upstream to account for 'arrow' circle on end of line

                info.iconCentre = this.findIconCentre(info, distPlusIconFromEnd);
                return info;
            },

            /**
             * getEdgeLineAngleForEl:calculate an indicator of the steepness of the line, ignoring direction
             * @param el: the edge SVG element to be analyzed
             * @param direction: the end of the edge we are interested in
             * @returns the modulus of the angle ie. ignoring its sign
             */
             getEdgeLineAngleForEl: function (el, direction) {
                let info = this.extractFoldingInfoFromEdgePath(el, direction);
                return info.angle < 0 ? -info.angle : info.angle;
            }
        };


        /**
         * applyPreviewCssChangesToDom
         * Apply CSS class to all highlight all nodes and edges affected by the preview
         * @param previewItemsInfo - array of lists of DSS ids of items beinb previewed.
         * @param previewClass - class to apply to DOM objects being preview
         */
        function applyPreviewCssChangesToDom(previewItemsInfo, previewClass) {
            d3.selectAll(previewItemsInfo[FoldDomStatusMapIdx.node].map(id => FlowGraph.rawNodeWithId(id)))  // id values for nodes are actually data-id= values
                .classed(previewClass, true);

            [FoldDomStatusMapIdx.edge, FoldDomStatusMapIdx.nestedBoundaryEdge].forEach( i =>
                d3.selectAll(getSelectorByIdFromList(previewItemsInfo[i]))
                    .classed(previewClass, true)
            )
        }

        function removeAllPreviewStyling() {
            $('.fold-preview').removeClass('fold-preview');
            $('.unfold-preview').removeClass('unfold-preview');
            $('.select-preview').removeClass('select-preview');
        }

        /**
         * applyPreviewFoldReqstToDom
         * Action all the DOM changes for a preview
         * @param previewFoldReqst - FoldReqst structure for preview
         * @param previewClass - CSS class to be applied
         */
        function applyPreviewFoldReqstToDom (previewFoldReqst, previewClass) {

            const itemsToPreview = activeFoldDomStatus.getPreviewItems(
                [previewFoldReqst.nodeEls.map(el => el.getAttribute('data-id')),
                 previewFoldReqst.edgeEls.map(el => el.id),
                 previewFoldReqst.nestedBoundaryEdgeIds]
            );
            applyPreviewCssChangesToDom(itemsToPreview, previewClass);
        }

        /**
         * reShowFoldedDomItems
         * Remove CSS and other DOM changes previously applied but no longer needed
         * @param itemsToReShow - array of id lists for items affected
         */
        function reShowFoldedDomItems(itemsToReShow) {

            d3.selectAll(itemsToReShow[FoldDomStatusMapIdx.node].map(id => FlowGraph.rawNodeWithId(id))).classed('folded-node', false); //node Ids are actually data-ids, which are slow to select.  use element lookup instead
            d3.selectAll(getSelectorByIdFromList(itemsToReShow[FoldDomStatusMapIdx.edge])).classed('folded-edge', false);
            d3.selectAll(getSelectorByIdFromList(itemsToReShow[FoldDomStatusMapIdx.nestedBoundaryEdge])).classed('folded-nested', false);

            d3.selectAll(getSelectorByIdFromList(itemsToReShow[FoldDomStatusMapIdx.boundaryEdge]))
                .classed('folded-boundary-edge', false)
                .attr('data-folded-boundary-node-id', null)
                .select('g.folded-icon')
                    .remove();  // the folded-icon group containing + sign
        }

        /**
         * applyFoldReqstToDom: use a fully built FoldReqst structure to make
         * the changes to the DOM necessary to execute a fold command.
         * @param foldReqst: a built FoldReqst structure
         */
        function applyFoldReqstToDom(foldReqst) {
            const radiusPlusIcon = 16; // radius of + icon
            const lenPlusArm = 11; // length of each arm of plus path

            if (!activeFoldDomStatus) activeFoldDomStatus = new FoldDomStatus();  // this remembers our DOM updates

            removeAllPreviewStyling();

            // hide nodes in branch
            d3.selectAll(foldReqst.nodeEls)
                .classed('folded-node', true)
                .classed('fold-transition', foldReqst.isUseCssTransitions);

            // hide edges in branch
            d3.selectAll(foldReqst.edgeEls)
                .classed('folded-edge', true)
                .classed('fold-transition', foldReqst.isUseCssTransitions);

            // hide nested boundary markers
            d3.selectAll(foldReqst.getNestedBoundaryEdgesSelector())
                .classed('folded-nested', true)
                .classed('fold-transition', foldReqst.isUseCssTransitions);

            // sort out hidden edges going to other nodes
            let boundaryEdges = foldReqst.boundaryEdges.map(item => {
                item.data = lineAnalyser.initBoundaryEdgeData(item.el, item.direction);
                return item
            });

            // find boundary edges that haven't been treated yet and add '+' indicator
            let boundaryEdgesSelectionNew =
                d3.selectAll(foldReqst.getBoundaryEdges())
                .filter(":not(.folded-boundary-edge)")
                    .data(boundaryEdges, function (d) {
                        return d ? d.el.id : this.id;
                    });

            // existing boundary makers need to bew processed - their rootItem data sometimes changes
            let boundaryEdgesSelectionExisting =
                d3.selectAll(foldReqst.getBoundaryEdges())
                    .filter(".folded-boundary-edge")
                    .data(boundaryEdges, function (d) {
                        return d ? d.el.id : this.id;
                    });

            boundaryEdgesSelectionNew
                .classed('folded-boundary-edge', true)
                .attr('data-folded-boundary-node-id', d => d.boundaryNodeId);

            //make sure existing boundary markers are updated
            boundaryEdgesSelectionExisting.select("g.folded-icon")  // .select forces the propagation of the updated data binding to the children
                .attr('data-folded-node-id', d => d.rootItemId)
                .attr('data-folded-direction', d => d.direction)
                .attr('data-folded-hidden-node-id', d => d.hiddenNodeId); // the hidden node on the end of the edge

            //create marker DOM elements for new ones
            //bundle it all in a <g> for easy removal
            const boundaryEdgeMarker = boundaryEdgesSelectionNew
                .append('g')
                .classed('folded-icon', true)
                .attr('data-folded-node-id', d => d.rootItemId)
                .attr('data-folded-direction', d => d.direction)
                .attr('data-folded-hidden-node-id', d => d.hiddenNodeId);

            // add the short line to the boundary marker
            const drawLine = d3.svg.line()
                .x(function (d) {
                    return d.x;
                })
                .y(function (d) {
                    return d.y;
                })
                .interpolate('linear');

            boundaryEdgeMarker
                .append('path')
                .attr('d', d => drawLine([d.data.iconCentre, d.data.endPoint]))
                .attr('stroke', '#000000')
                .attr('fill', 'none')
                .classed('folded-boundary-marker-line', true);

            // add a <g> to hold the plus-in-a-circle - mainly so we can
            // transform the co-ordinates to make centering the contents trivial
            const boundaryEdgeMarkerIconG = boundaryEdgeMarker
                .append('g')
                .attr('transform', d => {
                    return 'translate(' + d.data.iconCentre.x + ',' + d.data.iconCentre.y + ')'
                })

            // add a boundary marker circle
            boundaryEdgeMarkerIconG
                .append('circle')
                .attr('cx', 0)
                .attr('cy', 0)
                .attr('r', radiusPlusIcon)
                .attr('class', 'folded-boundary-marker-circle')
                .on('mouseover', d => {
                    const elG = $(d.el).find("g.folded-icon");
                    return svc.previewUnfold(FlowGraph.node(elG.attr('data-folded-node-id')), elG.attr('data-folded-direction'), elG.attr('data-folded-hidden-node-id'));
                    // by pulling the attributes dynamically, it is easier to handle boundarymarkers that change their rootItemId.
                })
                .on('mouseleave', d => svc.endPreviewBranch());

            // add the + sign as a <path>
            boundaryEdgeMarkerIconG
                .append('path')
                .attr("d", `M0,-${lenPlusArm} V${lenPlusArm} M-${lenPlusArm},0 H${lenPlusArm}`)
                .attr('stroke', '#000000')
                .attr('fill', 'none')
                .classed('folded-boundary-marker-plus', true);

            // re-show all the DOM stuff we no longer want hidden
            const itemsToReShow = activeFoldDomStatus.update(
                [foldReqst.nodeEls.map(el => el.getAttribute('data-id')),
                foldReqst.edgeEls.map(el => el.id),
                foldReqst.nestedBoundaryEdgeIds,
                foldReqst.boundaryEdges.map(item => item.el.id)]
            );

            reShowFoldedDomItems(itemsToReShow);

            // zap the CSS transition classes once we are done with them
            $timeout(_ => {
                $('.fold-transition').removeClass('fold-transition');
            }, 2000);

        }

        function getFuncEdgesAwayFromRoot (direction) {
            // edges on the side of the node further from the root item
            return direction == FoldDirections.successors ? FlowGraph.rawEdgesWithFromId : FlowGraph.rawEdgesWithToId;
        }

        function getFuncEdgesTowardRoot (direction) {
            // edges on the side of the node nearer the root item
            return direction == FoldDirections.successors ? FlowGraph.rawEdgesWithToId : FlowGraph.rawEdgesWithFromId;
        }

        function isEdgeSuitableAsBoundaryMarker(foldReqst, edge) {
            const existingDescr = foldReqst.getBoundaryEdgeDescr(edge.id);
            return !existingDescr || existingDescr.rootItemId == foldReqst.rootItem.id;
        }

        function getDirectionForEdgeEl(foldReqst, edge) {
            const existingDescr = foldReqst.getBoundaryEdgeDescr(edge.id);
            return existingDescr ? existingDescr.direction : undefined;
        }

        function updateMostLevelEdge(edge, mostLevelEdge, direction) {
            edge.angle = lineAnalyser.getEdgeLineAngleForEl(edge, direction);
            if (!mostLevelEdge || mostLevelEdge.angle > edge.angle) {
                mostLevelEdge = edge;
            }
            return mostLevelEdge;
        }

        /**
         * buildFoldReqst - build a FoldReqst structure for a fold command
         * This is the real engine of the folding logic.  It loops through elements starting form the rootItem in a
         * recursive pattern following the same pattern as the FlowSelection logic. However, it is made much more
         * complicated because of:
         * a) Nested folding
         * b) The need to define boundary markers for every element in the flow that loses an input or output edge
         *    due to the folding.
         * c) The ability to unfold in different order from the folding.
         * d) Loops in the graph
         *
         * The processing of a fold and unfold are broadly similarly, with some specific logic where necesssary.
         *
         * @param foldReqst: a single FoldReqst structure being built up throughout the recursive calls
         * @param item: item to process.  If undefined, then assume use the rootItem. Is set for the 'next' item in a recursive call
         * @param idsToRemainShownList: list of ids of items that we do not want hidden.  We flag if this foldReqst would hide an item
         * @returns the completed FoldReqst structure
         */

        function buildFoldReqst(foldReqst, item, idsToRemainShownList) {

            let isRootItem = false;
            if (typeof item === 'undefined') {
                item = foldReqst.rootItem;
                isRootItem = true;
            }

            foldReqst.idsToRemainShownList = idsToRemainShownList || [];

            let inValidContext = (!item || !item.id);
            inValidContext = inValidContext || (foldReqst.nodeIdMap && foldReqst.nodeIdMap.hasOwnProperty(item.id)); //reprocessing non-rootItem
            inValidContext = inValidContext || (!isRootItem && foldReqst.rootItem.id == item.id); //reprocessing rootItem - usually a looping flow

            if (inValidContext) {
                return foldReqst;
            }

            const fEdgesAwayFromRoot = getFuncEdgesAwayFromRoot(foldReqst.direction); // edges on the side of the node further from the root item
            const fEdgesTowardRoot = getFuncEdgesTowardRoot(foldReqst.direction); // edges on the side of the node nearer the root item
            const boundaryEdgeNodeAttr = 'data-' + (foldReqst.direction == FoldDirections.successors ? 'from' : 'to');
            const boundaryEdgeHiddenNodeAttr = 'data-' + (foldReqst.direction == FoldDirections.successors ? 'to' : 'from');
            const oppositeDirection = FoldDirections.getOpposite(foldReqst.direction);

            if (isRootItem) {
                const rootEdgesArray = fEdgesAwayFromRoot(foldReqst.rootItem.id);
                let mostLevelEdge;
                foldReqst.isChangeMadeForCommand = false;

                rootEdgesArray.forEach(
                    edge => {
                        if (foldReqst.isEdgeNeedsProcessing(edge)) {
                            foldReqst.isChangeMadeForCommand = true;
                            foldReqst.addEdge(edge);

                            //fold - we only want a single boundary marker added per node
                            // The most horizontal line looks visually tidiest
                            // but with unfold-strategy=rootitem we need to find an edge that is not already a boundary marker.
                            if (isEdgeSuitableAsBoundaryMarker(foldReqst, edge)) {
                                mostLevelEdge = updateMostLevelEdge(edge, mostLevelEdge, foldReqst.direction)
                            }
                        }
                    }
                );

                if (mostLevelEdge) {
                    foldReqst.addBoundaryEdge({el: mostLevelEdge, data: {},
                        boundaryNodeId: foldReqst.rootItem.id,
                        hiddenNodeId: mostLevelEdge.getAttribute(boundaryEdgeHiddenNodeAttr),

                    });
                }
            }
            else {
                //non-root item on the branch
                foldReqst.addNode(FlowGraph.rawNodeWithId(item.id), item);

                // we want boundary markers on all nodes that are left hanging: side branches of this branch
                fEdgesTowardRoot(item.id).forEach(
                    edge => {

                        const remoteNodeId = edge.getAttribute(boundaryEdgeNodeAttr);
                        const isBoundaryMarkerForNodeAlreadyBeingAdded =
                                    foldReqst.boundaryEdges.find(boundaryEdge =>
                                            boundaryEdge.el.id != edge.id &&
                                            boundaryEdge.boundaryNodeId == remoteNodeId &&
                                            boundaryEdge.direction == foldReqst.direction);

                        if (!isBoundaryMarkerForNodeAlreadyBeingAdded) {
                            //case of boundary marker pointing back upstream that need to be nested/hidden
                            if (getDirectionForEdgeEl(foldReqst, edge) == oppositeDirection){
                                foldReqst.addNestedBoundaryEdge(edge);
                            }

                            if (!foldReqst.isEdgeFolded(edge.id)) { //don't show new boundaries for edges already hidden
                                foldReqst.addBoundaryEdge({el: edge, data: {},
                                    boundaryNodeId: remoteNodeId,
                                    hiddenNodeId: item.id
                                });
                            }
                        }
                        else {
                            // we have a second edge on a boundary node.  We only want one edge to show the + sign,
                            // so we don't add to boundary edges list, but we still need to hide the edge so we
                            // add to edges list.  This is not an edge on the main branch though, so we don't add to
                            // branchEdgeIdMap
                            foldReqst.addEdge(edge);
                        }
                    });

                let isItemFolded = foldReqst.isNodeFolded(item.id);
                fEdgesAwayFromRoot(item.id).forEach( // edges on the branch being folded
                    edge => {
                        // we need to hide any boundary markers now nested in this fold.
                        if (foldReqst.isBoundaryEdge(edge.id) || isItemFolded) { //<<<<< extra conditional test only
                            foldReqst.addNestedBoundaryEdge(edge);
                        }

                        foldReqst.addEdge(edge, true);
                    });
            }

            $.each(item[foldReqst.direction], function (index, otherNodeId) {
                if (!foldReqst.isNodeFolded(otherNodeId)) {
                    const otherNode = FlowGraph.node(otherNodeId);
                    if (otherNode) foldReqst = buildFoldReqst(foldReqst, otherNode, idsToRemainShownList);
                }
            });

            // boundary edges cannot be edges inside the folded branch
            foldReqst.boundaryEdges = foldReqst.boundaryEdges.filter(item => !foldReqst.branchEdgeIdMap.hasOwnProperty(item.el.id))

            return foldReqst;
        }

        /**
         * tidyFoldState - ensure we clear down the restore state if things do awry.
         */
        function tidyFoldState(foldReqst) {
            const allFoldedNodes = $('.folded-node');
            foldedNodeCount = allFoldedNodes.length;

            if (foldedNodeCount==0) {
                GraphZoomTrackerService.resetFoldState();
            } else if (foldReqst && !foldReqst.isChangeMadeForCommand) {
                // check if the last command did nothing.  If so, we remove from state list
                // This can happened when build close alread-yclosed nodes and would lead to
                // unfolds that appear to do nothing.
                GraphZoomTrackerService.removeLastFoldCommand();
            }
        }

        /**
         * cleanRestoreState
         * Takes the restore state and removes any fold commands that reference flow items that don't exist anymore
         * @param commands - list of fold commands
         * @returns {*}
         */
        function cleanRestoreState(commands) {
            let origLen = commands.length;

            commands = commands.filter(cmd => !!FlowGraph.node(cmd.nodeId))
            if (origLen!=commands.length) {
                GraphZoomTrackerService.resetFoldState(commands);
            }
            return commands;
        }

        function applyFoldCommandToReqst (foldReqst, foldCommand, idsToRemainShownList) {
            // build total action into single foldReqst to apply at once
            const rootItem = FlowGraph.node(foldCommand.nodeId);

            foldReqst.rootItem = rootItem;
            foldReqst.direction = foldCommand.direction;
            foldReqst.action = foldCommand.action;
            foldReqst.isItemToRemainShownWillBeHidden = false;

            return buildFoldReqst(foldReqst, undefined, idsToRemainShownList);
        }

        /**
         * buildFoldReqstForCompleteState
         * Create a FoldReqst object that represents the complete sequence of fold commands.
         * This is called for previews, page refreshes, and user-driven folding / unfolding
         * @param commands - list of fold commands
         * @param isInteractiveReqst - if is a user-driven fold change, rather than a page refresh.  This determines if
         *        a CSS transition is used
         * @returns {FoldReqst}
         */
        function buildFoldReqstForCompleteState(commands, isInteractiveReqst, idsToRemainShownList) {
            let foldReqst = new FoldReqst(null, FoldDirections.successors, isInteractiveReqst);
            let foldCmdsApplied = [];
            let isCmdSkipped = false;

            cleanRestoreState(commands).forEach(cmd => {
                foldReqst.backupFoldState();
                foldReqst = applyFoldCommandToReqst (foldReqst, cmd, idsToRemainShownList);

                if (foldReqst.isItemToRemainShownWillBeHidden) {
                    foldReqst.restoreFoldState()
                    isCmdSkipped = true;
                }
                else {
                    foldCmdsApplied.push(cmd)
                }
            });

            if (isCmdSkipped) foldReqst.revisedFoldCmds = foldCmdsApplied;
            return foldReqst;
        }

        /**
         * applyFoldState
         * Apply the foldstate to the DOM.
         * This is called for pages refreshes and and user-driven folding / unfolding, but not previews
         * @param commands - the fold state
         * @param isInteractiveReqst - if is a user-driven fold change, rather than a page refresh.  This determines if
         *        a CSS transition is used
         */
        function applyFoldState(commands, isInteractiveReqst, idsToRemainShownList) {
            const foldReqst = buildFoldReqstForCompleteState(commands, isInteractiveReqst, idsToRemainShownList);

            applyFoldReqstToDom(foldReqst);
            $rootScope.$emit('flowSelectionUpdated');

            if (foldReqst.revisedFoldCmds) GraphZoomTrackerService.resetFoldState(foldReqst.revisedFoldCmds)
            tidyFoldState(foldReqst);
        }

        /**
         * foldMultiItems - action a fold command
         * @param rootItem: the item being folded/unfolded
         * @param direction: a value of FoldDirections, successor or predecessor
         * @param action: a value of FoldActions, fold or unfold
         * @param idsToRemainShownList: list of ids node that must be visible after unfolding.  For example, when you press
         *          a + you want something to shown on the end of that edge or it seems like nothing happened!
         */
        function foldMultiItems(rootItem, direction, action, idsToRemainShownList) {
            trackFoldCommand(rootItem.id, direction, action);
            applyFoldState(GraphZoomTrackerService.getFoldState(), true, idsToRemainShownList);
        }

        /**
         * trackFoldCommand - Update the GraphZoomTrackerService's list of active fold commands
         * @param nodeId - id of rootItem
         * @param direction: a value of FoldDirections, successor or predecessor
         * @param action: a value of FoldActions, fold or unfold
         */
        function trackFoldCommand(nodeId, direction, action) {
            Logger.debug(action.toString().toUpperCase() + " - " + direction.toUpperCase() + " " + nodeId);

            GraphZoomTrackerService.setFoldCommand(new FoldCommand(nodeId, direction, action));
        }

        // We only want to restore the fold status when the SVG graph has been reloaded.
        let foldStateRestored = false;
        $rootScope.$on('graphRendered', function() {
            foldStateRestored = false;
        });

        /* public methods */

        /**
         * unfoldNode: Unfold a folded node
         * @param unfoldEl: the boundary marker element (circle with a +) to unfold
         * */
        this.unfoldNode = function (unFoldEl) {
            const nodeId = unFoldEl.getAttribute('data-folded-node-id');
            const direction = unFoldEl.getAttribute('data-folded-direction');
            const idMustBeShown = unFoldEl.getAttribute('data-folded-hidden-node-id');
            foldMultiItems(FlowGraph.node(nodeId), direction, FoldActions.unfold, [idMustBeShown, nodeId]);
        };

        /**
         * foldSuccessors: fold a node downstream
         * @param item: a DSS flow data object (not a DOM element)
         */
        this.foldSuccessors = function (item) {
            foldMultiItems(item, FoldDirections.successors, FoldActions.fold);
        };

        /**
         * foldPredecessors: fold a node upstream
         * @param item: a DSS flow data object (not a DOM element)
         */
        this.foldPredecessors = function (item) {
            foldMultiItems(item, FoldDirections.predecessors, FoldActions.fold);
        };

        /**
         * previewSelect
         * Highlights the nodes / edges that will be affected by a 'Select all upstream/downstream' operation
         */
        this.previewSelect = function (item, direction) {
            const previewSelectReqst = buildFoldReqst(new FoldReqst(item, direction, true));
            if (previewSelectReqst) applyPreviewFoldReqstToDom(previewSelectReqst, 'select-preview');
        };

        /**
         * previewFoldOrUnfoldAction
         * Highlights the nodes / edges that will be affected by a 'Hide all upstream/downstream' operation
         * or display the nodes that will reappear when clicking on a boundaryEdgeMarkerIcon
         */
        function previewFoldOrUnfoldAction(item, direction, action, idsMustRemainShownList) {
            const previewFoldState = GraphZoomTrackerService.getPreviewFoldState(new FoldCommand(item.id, direction, action));
            const previewFoldReqst = buildFoldReqstForCompleteState(previewFoldState, true, idsMustRemainShownList);
            if (previewFoldReqst) applyPreviewFoldReqstToDom(previewFoldReqst, action + '-preview');
        }

        /**
         * previewFold
         * Highlights the nodes / edges that will be affected by a 'Hide all upstream/downstream' operation
         */
        this.previewFold = function (item, direction) {
            previewFoldOrUnfoldAction(item, direction, FoldActions.fold);
        };

        /**
         * previewUnfold
         * Display the nodes that will reappear when clicking on a boundaryEdgeMarkerIcon
         * For intuitive results, we need to ensure both the node we are unfolding appears incases it is nested in a
         * fold, and that the node on the end of the edge being unfolded appears, else it can seem like nothing
         * happened.
         */
        this.previewUnfold = function (item, direction, idsMustRemainShownList) {
            previewFoldOrUnfoldAction(item, direction, FoldActions.unfold, [idsMustRemainShownList, item.id]);
        };

        this.endPreviewBranch = function () {
            removeAllPreviewStyling();
        };

        /**
         * restoreState: restore the active sequence of fold/unfold commands
         * We only need to do this when the SVG graph is reloaded, not on
         * all resizes, but we need the node maps created by the graph resize
         *  to have been prepared, hence we trigger form the resize, but
         *  only action if we have not restored the state since the last
         *  draw_graph call.
         * @param commands: array of FoldCommands
         */
        this.restoreState = function (commands) {
            if (!foldStateRestored) {
                applyFoldState(commands, false);
                foldStateRestored = true;
            }
        };

        this.clearFoldState = function() {
            GraphZoomTrackerService.resetFoldState();
            foldStateRestored = false;
        };

        this.unfoldAll = function() {
            GraphZoomTrackerService.resetFoldState();
            $rootScope.$emit('drawGraph', {ignoreCache:true});
            tidyFoldState();
        }

        /**
         * ensureNodeNotFolded
         * called when the flow view tries to focus on an item. We need the item to be visible.
         * We re-apply the fold state, but specify the id is to remain shown, resulting in and
         * fold commands that contradict this are removed from the fold state.
         * @param idsToRemainShownList - list of ids of items that needs to be visible
         */
        //
        this.ensureNodesNotFolded = function (idsToRemainShownList) {
            applyFoldState(GraphZoomTrackerService.getFoldState(), true, idsToRemainShownList);
        }

        this.isNodeFolded = function(nodeId) {
            return activeFoldDomStatus
                && activeFoldDomStatus.maps[FoldDomStatusMapIdx.node].hasOwnProperty(nodeId);
        }

        this.getFoldedNodeCount = function () {
            return foldedNodeCount;
        }

    })

})();

(function() {
'use strict';

/**
* Search function in main flow
*/

var app = angular.module('dataiku.flow.project');


app.directive('flowSearchPopover', function($stateParams, $rootScope, ContextualMenu, ListFilter, DataikuAPI, StateUtils, FlowGraphSelection) {
    return {
        restrict : 'A',
        scope : true,
        templateUrl : '/templates/flow-editor/search-popover.html',

        link : function($scope, element, attrs) {
            /************************** SHOW / Hide logic ******************* */

            function hide() {
                //$scope.removeHighlights();
                element.hide();
                $("html").unbind("click", hide);
                shown=false;
                $scope.shown = false;
            };

            function show() {
                shown = true;
                $scope.shown = true;
                $(".flow-search-popover", element).css("left", $("#flow-search-input input").offset().left);
                $(element).show();
                element.off("click.dku-pop-over").on("click.dku-pop-over", function(e) {
                    // Let "a" flow
                    if ($(e.target).parents(".directlink").length) return;
                    e.stopPropagation();
                });
                $("#flow-search-input").off("click.dku-pop-over").on("click.dku-pop-over", function(e) {
                    e.stopPropagation();
                });
                window.setTimeout(function() { $("html").on("click.dku-pop-over", hide); }, 0);
            }

            $scope.pommef = function() {
                $("#flow-search-input").focus();
            };

            $scope.hidePopover = function() {
                if (shown) {
                    hide();
                }
            };

            var shown = false;
            $(element).hide();

            $scope.$on("$destroy", function() {
                $("html").off("click.dku-pop-over", hide);
            })
            $scope.$watch("flowSearch.pattern", function(nv, ov) {
                if (shown && (!nv || nv.length === 0)) {
                    hide();
                }
                if (!shown && nv && nv.length > 0) {
                    show();
                }
            });
            $("#flow-search-input input").on("focus", function() {
                if (!shown && $scope.flowSearch && $scope.flowSearch.pattern.length) {
                    show();
                }
            });

            /************************** Execution ******************* */

            $scope.$watch("flowSearch.pattern", function() {
                $scope.onFlowSearchQueryChange();
            });

            var extraneous = [];
            var formerPattern;

            function isInZone(node, zoneId) {
                if (!zoneId) {
                    return true;
                }
                return node.id.startsWith(`zone__${zoneId}`)
            }
            const isInOwnerZone = node => node && node.ownerZone && node.ownerZone !== "" && node.id.startsWith('zone') && node.id.startsWith(`zone__${node.ownerZone}__`);
            const getNode = (realId, nodes, zoneId) => {
                let node = nodes[realId];
                if (node) {
                    return node;
                }
                for (let key in nodes) {
                    node = nodes[key];
                    if (node.realId === realId && (!zoneId ? isInOwnerZone(node) : isInZone(node, zoneId))) {
                        return node;
                    }
                }
                return undefined;
            }
            $scope.onFlowSearchQueryChange = function() {
                if (!$scope.flowSearch) return;
                function getDatasets() {
                    if (!filteredDatasets) return [];
                    //First get local datasets
                    var results = ListFilter.filter(filteredDatasets.items, $scope.flowSearch.pattern);
                    $.map(results, function(item) {
                        item.nodeType = 'DATASET';
                        const potentialId = graphVizEscape("dataset_" + item.projectKey + "." + item.name);
                        const foundNode = getNode(potentialId, $scope.nodesGraph.nodes, $stateParams.zoneId);
                        item.id = foundNode ? foundNode.id : potentialId;
                    });
                    results = results.filter(node => isInZone(node, $stateParams.zoneId));
                    // Add foreign datasets
                    results = results.concat(getItemsFromGraph("FOREIGN_DATASET"));
                    return results;
                }

                function getItemsFromGraph(type) {
                    if (!$scope.nodesGraph) return [];
                    var result = [];
                    for (var key in $scope.nodesGraph.nodes) {
                        const node = $scope.nodesGraph.nodes[key];
                        if (node.nodeType.endsWith(type) && isInZone(node, $stateParams.zoneId)) {
                            if (isInOwnerZone(node, $stateParams.zoneId) || node.ownerZone === undefined) {
                                // No ownerZone when the graph does not have zones
                                result.push(node);
                            }
                        }
                    }
                    return ListFilter.filter(result, $scope.flowSearch.pattern);
                }

                if(formerPattern != $scope.flowSearch.pattern) {
                    formerPattern = $scope.flowSearch.pattern;
                    const datasets = getDatasets(),
                        recipes = getItemsFromGraph("RECIPE"),
                        folders = getItemsFromGraph("FOLDER"),
                        models = getItemsFromGraph("MODEL"),
                        zones = getItemsFromGraph("ZONE").map(item => Object.assign(item, {zoneId: item.id.split('_').splice(1).join('')}));
                    $scope.flowSearch.nbDatasets = datasets.length;
                    $scope.flowSearch.nbRecipes = recipes.length;
                    $scope.flowSearch.nbFolders = folders.length;
                    $scope.flowSearch.nbModels = models.length;
                    $scope.flowSearch.items = datasets.concat(recipes).concat(folders).concat(models).concat(zones).sort(function(a,b) {
                        var aIsGood = a.name.startsWith($scope.flowSearch.pattern.toLowerCase())?'0':'1';
                        var bIsGood = b.name.startsWith($scope.flowSearch.pattern.toLowerCase())?'0':'1';
                        return (aIsGood + a.name).localeCompare(bIsGood + b.name);
                    });
                }
                $scope.flowSearch.index = -1;
                $scope.currentlyDisplayedItems = 20;
            };

            $scope.currentlyDisplayedItems = 20;
            $scope.loadMoreItems = function() {
                $scope.currentlyDisplayedItems += 20;
            };

            let filteredDatasets;
            DataikuAPI.datasets.listHeads($stateParams.projectKey, $rootScope.tagFilter || {}, false).success(function(data){
                filteredDatasets = data;
            }).error(setErrorInScope.bind($scope));

            /*************************** Navigation **************** */

            $scope.flowSearchSelectPrevious = function($event) {
                if (!shown || !$scope.flowSearch.items.length) {
                    return;
                }
                $scope.flowSearchSelectIndex(Math.max(0, $scope.flowSearch.index-1));
                if ($event) $event.stopPropagation();
                const el = $("li", element)[$scope.flowSearch.index];
                if (el) {
                    const parent = $("ul", element).parent();
                    ensureVisible(el, parent);
                }
            };

            $scope.flowSearchSelectNext = function($event) {
                if (!shown || !$scope.flowSearch.items.length) {
                    return;
                }
                $scope.flowSearchSelectIndex(Math.min($scope.flowSearch.items.length - 1, $scope.flowSearch.index+1));
                if ($event) $event.stopPropagation();
                const el = $("li", element)[$scope.flowSearch.index];
                if (el) {
                    const parent = $("ul", element).parent();
                    ensureVisible(el, parent);
                }
            };

            $scope.flowSearchSelectIndex = function(index) {
                if (!shown) return;
                if (!$scope.nodesGraph || !$scope.nodesGraph.nodes) return;
                $scope.flowSearch.index = index;
                /* Highlight on selection */
                //$scope.removeHighlights();
                const item = $scope.flowSearch.items[$scope.flowSearch.index]
                const id = item.id;
                FlowGraphSelection.clearSelection($scope.nodesGraph.nodes[id]);
                FlowGraphSelection.onItemClick($scope.nodesGraph.nodes[id], null);
                $scope.zoomGraph(id, item.nodeType=="RECIPE" ? 5 : 3, item); //recipe nodes don't have names, so bbox ends up smaller
            };

            $scope.flowSearchGo = function() {
                if (!shown) return;
                if ($scope.flowSearch.index < 0) {
                    //No match
                    return;
                }
                if($scope.flowSearch.items.length) {
                    var item = $scope.flowSearch.items[$scope.flowSearch.index];
                    if (item.nodeType.endsWith("DATASET")) {
                        StateUtils.go.dataset(item.name, item.projectKey)
                    } else if (item.nodeType.endsWith("RECIPE")) {
                        StateUtils.go.recipe(item.name)
                    } else if (item.nodeType.endsWith("MODEL")) {
                        StateUtils.go.savedModel(item.name, item.projectKey)
                    } else if (item.nodeType.endsWith("EVALUATION_STORE")) {
                        StateUtils.go.modelEvaluationStore(item.name, item.projectKey)
                    } else if (item.nodeType.endsWith("FOLDER")) {
                        StateUtils.go.managedFolder(item.name, item.projectKey)
                    } else {
                        StateUtils.go.dssObject(item.nodeType, item.name)
                    }
                    $scope.flowSearch.pattern = "";
                    hide();
                    $("#flow-search-input").blur();
                }
            };

            $scope.contextMenu = function(idx, $event) {
                var x = $event.pageX;
                var y = $event.pageY;
                var newScope = $scope.$new();
                var item = $scope.flowSearch.items[idx];
                newScope.object = angular.copy(item);
                var menuParams = {
                    scope: newScope,
                    template: "/templates/flow-editor/dataset-contextual-menu.html"
                };
                var menu = new ContextualMenu(menuParams);
                menu.openAtXY(x, y);
            };

            $scope.onFlowSearchQueryChange();
        }
    };
});


})();


(function() {
'use strict';

const app = angular.module('dataiku.flow.graph');

app.controller("FlowZonesDetailsController", function ($scope, $rootScope, $filter, $state, StateUtils) {
    $scope.StateUtils = StateUtils;
    $scope.getObjectIcon = function(object) {
        switch(object.type) {
            case 'SAVED_MODEL':            return 'icon-machine_learning_regression saved-model';
            case 'MODEL_EVALUATION_STORE': return 'icon-model-evaluation-store';
            case 'MANAGED_FOLDER':         return 'icon-folder-open managed-folder';
            default:                       return $filter('datasetTypeToIcon')(object.type) + ' dataset';
        }
    };

    $scope.getObjectLink = function(object) {
        switch(object.type) {
            case 'SAVED_MODEL':            return StateUtils.href.savedModel(object.id, object.projectKey);
            case 'MODEL_EVALUATION_STORE': return StateUtils.href.modelEvaluationStore(object.id, object.projectKey);
            case 'MANAGED_FOLDER':         return StateUtils.href.managedFolder(object.id, object.projectKey);
            default:                       return StateUtils.href.dataset(object.id);
        }
    };
});

app.directive('zoneRightColumnSummary', function($controller, $rootScope, $state, $stateParams, DataikuAPI, Logger, CreateModalFromTemplate, TaggableObjectsUtils, FlowGraph, ActivityIndicator) {
    return {
        templateUrl: '/templates/zones/right-column-summary.html',

        link: function(scope, element, attrs) {

            $controller('_TaggableObjectsMassActions', {$scope: scope});
            $controller('_TaggableObjectsCapabilities', {$scope: scope});

            scope.$stateParams = $stateParams;

            scope.zoomOnZone = zoneId => {
                $state.go('projects.project.flow', Object.assign({}, $stateParams, { zoneId }))
            };

            scope.zoomOutOfZone = (id = null) => {
                $state.go('projects.project.flow', Object.assign({}, $stateParams, { zoneId: null, id}))
            }

            scope.$on("objectSummaryEdited", function() {
                const zone = scope.zoneFullInfo.zone;
                const tor = {type: 'FLOW_ZONE', projectKey: $stateParams.projectKey, id: zone.id};
                DataikuAPI.taggableObjects.getMetadata(tor).success(function(metadata) {
                    metadata.tags = zone.tags;
                    DataikuAPI.taggableObjects.setMetaData(tor, metadata).success(function() {
                        ActivityIndicator.success("Saved");
                    });
                }).error(setErrorInScope.bind(scope));
            });

            scope.editZone = () => {
                CreateModalFromTemplate("/templates/zones/edit-zone-box.html", scope, null, function(newScope){
                    newScope.zoneName = scope.selection.selectedObject.name;
                    newScope.uiState = {
                        stockColors: ["#C82423","#8C2DA7","#31439C","#087ABF","#0F786B","#4B8021","#F9BE40","#C54F00","#D03713","#465A64"],
                        newColor: scope.selection.selectedObject.color,
                        newName: scope.selection.selectedObject.name
                    };

                    newScope.pickStockColor = color => {
                        newScope.uiState.newColor = color;
                    };

                    newScope.go = function(){
                        DataikuAPI.flow.zones.edit($stateParams.projectKey, scope.selection.selectedObject.id, newScope.uiState.newName, newScope.uiState.newColor).success(function () {
                            scope.$emit('reloadGraph');
                            if ($stateParams.zoneId) {
                                $rootScope.$emit("zonesListChanged", newScope.uiState.newName);
                            }
                            newScope.dismiss()
                        }).error(setErrorInScope.bind(newScope));
                    }
                });
            }

            scope.refreshData = function() {
                DataikuAPI.zones.getFullInfo(scope.selection.selectedObject.projectKey, scope.selection.selectedObject.cleanId).success(function(data) {
                    data.zone.cleanId = data.zone.id
                    scope.zoneFullInfo = data;
                    // check that the selection didn't change while getFullInfo was called
                    if (scope.selection.selectedObject && scope.selection.selectedObject.cleanId === data.zone.cleanId) {
                        scope.selection.selectedObject = data.zone;
                        scope.selection.selectedObject.isCollapsed = scope.collapsedZones.find(it => it === data.zone.id) !== undefined;
                    }
                }).error(setErrorInScope.bind(scope));
            };

            scope.deleteZone = () => {
                let items = scope.getSelectedTaggableObjectRefs();
                let success = undefined;
                if ($stateParams.zoneId) {
                    items = [TaggableObjectsUtils.fromNode(scope.nodesGraph.nodes[`zone_${$stateParams.zoneId}`])];
                    success = () => scope.zoomOutOfZone();
                }
                scope.deleteSelected(items, success);
            };

            scope.collapseAllZones = () => {
                const allFlowZones = Object.values(FlowGraph.get().nodes).filter(it => TaggableObjectsUtils.fromNodeType(it.nodeType) === 'FLOW_ZONE');
                scope.toggleZoneCollapse(allFlowZones.map(TaggableObjectsUtils.fromNode), 'collapseAll');
            }

            scope.expandAllZones = () => {
                const allFlowZones = Object.values(FlowGraph.get().nodes).filter(it => TaggableObjectsUtils.fromNodeType(it.nodeType) === 'FLOW_ZONE');
                scope.toggleZoneCollapse(allFlowZones.map(TaggableObjectsUtils.fromNode), 'expandAll');
            }

            scope.$watch("selection.selectedObject",function(nv) {
                if (!scope.selection) scope.selection = {};
                scope.zoneFullInfo = {zone: scope.selection.selectedObject, timeline: {}}; // display temporary (incomplete) data
            });

            scope.$watch("selection.confirmedItem", function(nv, ov) {
                if (!nv) return;
                scope.selection.selectedObject.cleanId = scope.selection.selectedObject.id.split('_')[1];
                scope.refreshData();
            });

            const zonesListChangedListener = $rootScope.$on("zonesListChanged", scope.refreshData);
            scope.$on('$destroy',zonesListChangedListener);

        }
    }
});

})();
(function() {
'use strict';

const app = angular.module('dataiku.flow.tools', []);


app.service('FlowToolsRegistry', function() {
    const flowViews = {};
    const flowTools = {};

    this.registerView = function(service) {
        let def = service.getDefinition();
        def.isTool = false;
        flowViews[def.getName()] = def;
    };
    this.registerFlowTool = function(service) {
        let def = service.getDefinition();
        def.isTool = true;
        flowTools[def.getName()] = def;
    };

    this.getDef = function(name) {
        return flowViews[name] || flowTools[name];
    };
    this.getFlowViews = function() {
        return Object.values(flowViews);
    };
});


app.service('FlowToolsLoader', function(FlowToolsRegistry,
    FlowZonesView, TagsView, CustomFieldsView, ConnectionsView, FileformatsView, RecipesEnginesView, RecipesCodeEnvsView,
    PipelinesView, ImpalaWriteModeView, HiveModeView, SparkConfigView, SparkEngineView,
    PartitioningView, PartitionsView, ScenariosView, WatchView, CountOfRecordsView, FilesizeView,
    CreationView, LastModifiedView, LastBuildView, LastBuildDurationView,
    RecentActivityView, DatasetMetricsView, DatasetChecksView,
    CopyFlowTool, PropagateSchemaFlowTools, CheckConsistencyFlowTool) {

    FlowToolsRegistry.registerView(FlowZonesView);
    FlowToolsRegistry.registerView(TagsView);
    FlowToolsRegistry.registerView(CustomFieldsView);

    FlowToolsRegistry.registerView(ConnectionsView);
    FlowToolsRegistry.registerView(RecipesEnginesView);
    FlowToolsRegistry.registerView(RecipesCodeEnvsView);

    FlowToolsRegistry.registerView(ImpalaWriteModeView);
    FlowToolsRegistry.registerView(HiveModeView);
    FlowToolsRegistry.registerView(SparkConfigView);
    FlowToolsRegistry.registerView(SparkEngineView);
    FlowToolsRegistry.registerView(PipelinesView.getService("SPARK_PIPELINES"));
    FlowToolsRegistry.registerView(PipelinesView.getService("SQL_PIPELINES"));

    FlowToolsRegistry.registerView(CreationView);
    FlowToolsRegistry.registerView(LastModifiedView);
    FlowToolsRegistry.registerView(LastBuildView);
    FlowToolsRegistry.registerView(LastBuildDurationView);
    FlowToolsRegistry.registerView(RecentActivityView);

    FlowToolsRegistry.registerView(PartitioningView);
    FlowToolsRegistry.registerView(PartitionsView);
    FlowToolsRegistry.registerView(ScenariosView);

    FlowToolsRegistry.registerView(DatasetMetricsView);
    FlowToolsRegistry.registerView(DatasetChecksView);
    FlowToolsRegistry.registerView(CountOfRecordsView);
    FlowToolsRegistry.registerView(FilesizeView);
    FlowToolsRegistry.registerView(FileformatsView);

    FlowToolsRegistry.registerView(WatchView);

    FlowToolsRegistry.registerFlowTool(CopyFlowTool);
    FlowToolsRegistry.registerFlowTool(CheckConsistencyFlowTool);
    FlowToolsRegistry.registerFlowTool(PropagateSchemaFlowTools);
});


/*
* Note that for now, flow views are simply flow tools
*/
app.service('FlowTool', function($rootScope, Assert, Logger, FlowToolsRegistry) {
    const svc = this;
    let currentTool = {};

    this.setCurrent = function(tool)  {
        currentTool = tool;
        if (tool.def) {
            $('#flow-graph').addClass('with-flow-view-focus');
        } else {
            $('#flow-graph').removeClass('with-flow-view-focus');
        }
    };

    this.getCurrent = function(tool)  {
        return currentTool;
    };

    this.unactivateCurrentTool = function(redraw = true) {
        if (!currentTool.def) return; // None active
        if (currentTool.def.destroyFlowTool) {
            currentTool.def.destroyFlowTool();
        }
        svc.setCurrent({});
        if (redraw) {
            $rootScope.$emit('drawGraph');
        }
        return currentTool;
    };

    this.activateTool = function(currentToolSession) {
        Assert.trueish(currentToolSession, 'no currentToolSession');

        Logger.info("Activating tool", currentToolSession, FlowToolsRegistry.registry);

        svc.unactivateCurrentTool(false);

        let def = FlowToolsRegistry.getDef(currentToolSession.type);
        Assert.trueish(def, 'no tool def');
        svc.setCurrent({
            drawHooks: {},
            actionHooks: {},
            type: currentToolSession.type,
            currentSession: currentToolSession,
            def: def
        });

        def.initFlowTool(currentTool);
        return currentTool;
    };

    $rootScope.$on('flowDisplayUpdated', function() {
        if (currentTool.drawHooks && currentTool.drawHooks.updateFlowToolDisplay) {
            currentTool.drawHooks.updateFlowToolDisplay();
        }
    });

    $rootScope.$on('refreshFlowState', function() {
        if (currentTool && currentTool.refreshState && currentTool.projectKey == $rootScope.$stateParams.projectKey) {
            currentTool.refreshState();
        }
    });

    $rootScope.$on('flowItemClicked', function(evt, evt2, item) {
        if (currentTool.actionHooks && currentTool.actionHooks.onItemClick) {
            currentTool.actionHooks.onItemClick(item, evt2);
        }
    });
});


app.service('FlowViewsUtils', function($stateParams, WT1, DataikuAPI, Logger, MonoFuture, ProgressStackMessageBuilder,
    FlowGraph, FlowGraphSelection, FlowGraphFiltering, FlowGraphFolding) {

    this.addFocusBehavior = function(tool) {


        function isItemSelectedbyId(itemId) {

            let val = tool.user.state.valueByNode[itemId];
            if (val === undefined) {
                return false;
            }
            // Multi-valued view (tags, scenarios)
            if (angular.isArray(tool.getRepr(val))) {
                for (let v of tool.getRepr(val)) {
                    if (tool.user.state.focusMap[v]) {
                        return true;
                    }
                }
                return false;
            }
            // Single-valued view
            return tool.user.state.focusMap[tool.getRepr(val)];
        }

        function isItemSelected(item) {
            return isItemSelectedbyId(item.realId);
        }

        function getSelectedIdsList() {
            const selectedIdslist = [];
            Object.keys(tool.user.state.valueByNode).forEach (itemId => {
                if (isItemSelectedbyId(itemId))  selectedIdslist.push(itemId);
            });
            return selectedIdslist;
        }

        tool.user.isFocused = function(val) {
            // Disable focus when in continuous mode
            if (typeof tool.colorScale == 'function' && tool.colorScale().continuous) {
                return true;
            }

            const repr = tool.getRepr(val);
            if (angular.isArray(repr)) {
                let any = false;
                repr.forEach(function(it) {
                    if (tool.user.state.focusMap[it]) {
                        any = true;
                    }
                });
                return any;
            } else {
                return tool.user.state.focusMap[repr];
            }
        };

        tool.user.getFocusedAsList = function() {
            if (!tool.user.state) return []; //Too early
            const ret = [];
            for (let val in tool.user.state.focusMap) {
                if(tool.user.state.focusMap[val]) {
                    ret.push(val);
                }
            }
            return ret;
        };

        //TODO @flow deprecated
        tool.user.getSingleFocused = function() {
            for (let val in tool.user.state.focusMap) {
                if(tool.user.state.focusMap[val]) {
                    return val;
                }
            }
        };

        tool.user.zoomToFocused = function() {
            FlowGraphFolding.ensureNodesNotFolded(getSelectedIdsList());
            let scope = $('#flow-graph').scope();
            if($('#flow-graph svg .focus').length) {
                scope.zoomToBbox(FlowGraphFiltering.getBBoxFromSelector(scope.svg, '.focus'), 1.2);
            } else {
                scope.zoomToBbox(FlowGraphFiltering.getBBoxFromSelector(scope.svg, '.node'), 1.2);
            }
        };

        tool.user.selectFocused = function() {
            WT1.event("flow-view-select-focused", {tool: tool.def.name});
            FlowGraphFolding.ensureNodesNotFolded(getSelectedIdsList());
            FlowGraphSelection.select(isItemSelected);
        };
    };

    //TODO @flow move or rename service
    this.addAsynchronousStateComputationBehavior = function(tool) {
        tool.user.update = function(scope) {
            tool.user.updateStatus.updating = true;
            tool.user.firstUpdateDone = true;
            return MonoFuture(scope).wrap(DataikuAPI.flow.tools.startUpdate)($stateParams.projectKey, tool.def.getName(), tool.user.updateOptions)
            .success(function(data) {
                tool.user.state = data.result;
                tool.drawHooks.updateFlowToolDisplay();
                tool.user.updateStatus.updating = false;
            }).error(function(a,b,c) {
                tool.user.updateStatus.updating = false;
                setErrorInScope.bind(scope)(a,b,c);
            }).update(function(data) {
                tool.user.updateStatus.progress = data.progress;
                tool.user.updateStatus.totalPercent = ProgressStackMessageBuilder.getPercentage(data.progress);
            });
        };
    };

});


app.service('FlowToolsUtils', function(Logger, FlowGraph) {
    const svc = this;

    this.notSoGrey = function(node, elt) {
        svc.colorNode(node, elt, '#ACACAC');
    },

    this.greyOutNode = function(node, elt) {
        svc.colorNode(node, elt, '#DADADA');
    },

    this.colorNode = function(node, elt, color) {
        try {
            if (node.nodeType == 'LOCAL_DATASET' || node.nodeType == 'FOREIGN_DATASET') {
                elt.style('fill', color);
                if (node.neverBuilt) {
                    elt.select('.never-built-computable .main-dataset-rectangle').style('stroke', color);
                    elt.select('.never-built-computable .nodeicon').style('color', color);
                    elt.select('.never-built-computable .nodelabel-wrapper').style('color', color);
                }
            } else if (node.nodeType == 'LOCAL_MANAGED_FOLDER'  || node.nodeType == 'FOREIGN_MANAGED_FOLDER') {
                elt.style('fill', color);
            } else if (node.nodeType == 'LOCAL_STREAMING_ENDPOINT') {
                elt.style('fill', color);
            } else if (node.nodeType == 'LOCAL_SAVEDMODEL' || node.nodeType == 'FOREIGN_SAVEDMODEL') {
                elt.style('fill', color);
            } else if (node.nodeType == 'LOCAL_MODELEVALUATIONSTORE' || node.nodeType == 'FOREIGN_MODELEVALUATIONSTORE') {
                elt.style('fill', color);
            } else if (node.nodeType == 'RECIPE') {
                elt.select('.bzicon').style('fill', color);
            } else if (node.nodeType == 'ZONE') {
                elt.style('background-color', color);
                elt.style('stroke', color);
                const rgbColor = d3.rgb(color);
                const titleColor = (rgbColor.r*0.299 + rgbColor.g*0.587 + rgbColor.b*0.114) >= 128 ? "#000" : "#FFF";
                elt.style('color', titleColor);
            } else {
                Logger.warn("Cannot color node", node);
            }
            elt.select("g, rect").attr("color", color); //text color
        } catch (e) {
            Logger.error("Failed to color node", e);
        }
    }

    // Bottom right colored indicator
    // There might be several (Ex: tags, so there is an index)
    const RADIUS = 6;
    this.addSimpleZone = function(elt, color='rgba(0,0,0,0)', idx = 0, onClick) {
        let tsz = elt.select(".tool-simple-zone");

        if (!tsz.empty()) {
            if (idx == 0) {
                tsz.selectAll("*").remove();
            }
            let tszHeight = tsz.attr("data-height");
            tsz.append("circle")
                .attr("cx", RADIUS + 2)
                .attr("cy", tszHeight - RADIUS - idx * (RADIUS*2 + 2))
                .attr("r", RADIUS)
                .attr("fill", color)
                .on("click", onClick)
                ;
        }
    }
});

app.directive('flowToolSupport', function($rootScope, $stateParams, Assert, WT1, Logger, DataikuAPI, Dialogs, FlowToolsRegistry, FlowTool,FlowGraph) {
    return {
        restrict: 'A',
        link : function(scope, element, attrs) {
            function activateFromStateIfNeeded() {
                Assert.trueish(scope.toolsState, 'no tool state');
                scope.toolsState.otherActive = {}
                $.each(scope.toolsState.active, function(k, v) {
                    if (k != scope.toolsState.currentId) {
                        scope.toolsState.hasOtherActive = true;
                        scope.toolsState.otherActive[k] = v;
                    }
                });

                if (scope.toolsState.currentId) {
                    scope.tool = FlowTool.activateTool(scope.toolsState.active[scope.toolsState.currentId]);
                } else {
                    scope.tool = FlowTool.unactivateCurrentTool();
                }
            }

            scope.getgetToolDisplayName = function(toolState) {
                return FlowToolsRegistry.registry[toolState.type].getToolDisplayName(toolState);
            };

            scope.refreshToolsState = function() {
                DataikuAPI.flow.tools.getSessions($stateParams.projectKey).success(function(data) {
                    scope.toolsState = data;
                    activateFromStateIfNeeded();
                }).error(setErrorInScope.bind(scope));
            };

            scope.startTool = function(type, data) {
                WT1.event("flow-tool-start", {tool: type});

                scope.drawZones.drawZones = true;
                DataikuAPI.flow.tools.start($stateParams.projectKey, type, data).success(function(data) {
                    scope.toolsState = data;
                    activateFromStateIfNeeded();
                }).error(setErrorInScope.bind(scope));
            };

            scope.$on('projectTagsUpdated', function (e, args) {
                if (scope.tool && scope.tool.type=="TAGS") {
                    scope.tool.refreshState(false, args.updateGraphTags);
                }
            });

            scope.stopCurrentTool = function() {
                const currentId = scope.toolsState.currentId;
                Assert.trueish(currentId, 'no active tool, cannot stop');

                $.each(FlowGraph.get().nodes, function (nodeId, node) {
                    const nodeElt = FlowGraph.d3NodeWithId(nodeId);
                    nodeElt.classed('focus', false).classed('out-of-focus', false);
                });
                if (scope.tool.type == "PROPAGATE_SCHEMA") { //reset paths colors applied on
                    FlowGraph.getSvg().find('.grey-out-path').each(function () {
                        d3.select(this).classed('grey-out-path', false);
                    });
                }
                scope.tool = FlowTool.unactivateCurrentTool();
                DataikuAPI.flow.tools.stop($stateParams.projectKey, currentId).success(function(data) {
                    scope.toolsState = data;
                    scope.drawZones.drawZones = true;
                    activateFromStateIfNeeded();
                }).error(setErrorInScope.bind(scope));
            };

            scope.activateDefaultTool = function() {
                DataikuAPI.flow.tools.setDefaultActive($stateParams.projectKey).success(function(data) {
                    scope.toolsState = data;
                    activateFromStateIfNeeded();
                }).error(setErrorInScope.bind(scope));
            };

            scope.activateTool = function(toolId) {
                 DataikuAPI.flow.tools.setActive($stateParams.projectKey, toolId).success(function(data) {
                    scope.toolsState = data;
                    activateFromStateIfNeeded();
                }).error(setErrorInScope.bind(scope));
            };

            const h = $rootScope.$on('stopCurrentTool', scope.stopCurrentTool);
            scope.$on('$destroy', h);

            scope.refreshToolsState();
        }
    }
});


app.directive("flowToolFacetElt", function() {
    return {
        template:
            `<label class="horizontal-flex" ng-class="{'single-focused': states[key]}">
                <input type="checkbox" ng-if="!singleFocused" ng-model="states[key]" ng-click="$event.stopPropagation()"/>
                <span class="dib flex horizontal-flex" ng-click="click(key, $event)">
                    <span class="bullet noflex" style="background-color: {{color}};" />
                    <span class="text flex">
                        <span ng-if="!displayGlobalTags">{{displayName ? displayName : (isNumber(key) ? (key | number) : key) }}</span>
                        <span ng-if="displayGlobalTags" ui-global-tag="displayName ? displayName : (isNumber(key) ? (key | number) : key)" object-type="'TAGGABLE_OBJECT'"/>
                    </span>
                    <span class="number noflex">{{number}}</span>
                </span>
            </label>`,
        scope: {
            color: '=',
            key: '=',
            displayName: '=',
            number: '=',
            singleFocused: '=',
            states: '=',
            displayGlobalTags: '='
        },
        link: function(scope, element, attr) {
            scope.click = function(key, evt) {
                if (!scope.states) return;
                $.each(scope.states, function(k) {
                    scope.states[k] = false;
                });
                scope.states[key] = true;
                evt.preventDefault();
                evt.stopPropagation();
            };
            scope.isNumber = n  => angular.isNumber(n);
        }
    }
});

const keepLogValue = function(value) {
    let v = value;
    while (v > 9 && v % 10 == 0) {
        v /= 10;
    }
    return v == 1;
};

const formatValue = function(domain, log = false, scaleUnit = undefined) {
    const sizes = ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y', 'N', 'X', 'XK', 'XM', 'XG', 'XT', 'XP', 'XE', 'XZ', 'XY', 'XN', 'bX', 'bXK'];

    // determine if we should display the tick value of the very first and very last ticks, even if they are not power of 10
    // The rule is that if the last tick is more than 10% of the scale beyond the last 'normal' tick, we display it
    const makeLogTickOpt = () => {
        // the log range of the scale (how many powers of 10 are shown)
        const totalRange = Math.log10(domain[1]) - Math.log10(domain[0]); 

        // keep top tick if more that 10% of the scale is over the top 10**x tick
        const topPow10Tick = Math.pow(10, Math.floor(Math.log10(domain[1]))); // the higest tick in the sacle
        const topTick = Math.floor(domain[1] / topPow10Tick) * topPow10Tick;
        const keepTopTick = Math.log10(topTick) - Math.log10(topPow10Tick) > 0.1 * totalRange; 

        // keep bottom tick if more that 10% of the scale is under the lowest 10**x tick
        const bottomPow10Tick = Math.pow(10, Math.ceil(Math.log10(domain[0])));
        const bottomTick = Math.ceil(domain[0] / (bottomPow10Tick/10)) * (bottomPow10Tick/10); // the lowest tick on the scale
        const keepBottomTick = Math.log10(bottomPow10Tick) - Math.log10(bottomTick) > 0.1 * totalRange;

        return {
            topTick, keepTopTick,
            bottomTick, keepBottomTick,
        };
    }

    const logTickOpt = log ? makeLogTickOpt() : undefined;

    return function(value) {
        if (log && 
            !(logTickOpt.bottomTick == value && logTickOpt.keepBottomTick) &&
            !(logTickOpt.topTick == value && logTickOpt.keepTopTick) && 
            !keepLogValue(value)) {
            return;
        }
        if (value == 0) {
            return '0' + (scaleUnit === 'FILESIZE' ? ' B' : '');
        }
        switch(scaleUnit) {
            case 'FILESIZE': {
                let i = Math.floor(Math.log(value) / Math.log(1024)) + 1;
                return '~ ' + parseFloat((value / Math.pow(1024, i)).toPrecision(1)) + ' ' + sizes[i] + 'B';
            }
            case 'DURATION': {
                if(value < 1000) return value + 'ms';
                return durationHHMMSS(value / 1000);
            }
            default: {
                let i = Math.floor(Math.log(value) / Math.log(1000));
                return parseFloat((value / Math.pow(1000, i)).toFixed(4)) + ' ' + sizes[i];
            }
        }
    }
};

const applyContinuousScale = function(colorScale, scaleUnit, urlPath) {
    const w = 120, h = 200;
    const range = colorScale.range;
    const domain = colorScale.domain;
    const log = colorScale.log;

    d3.select("continuous-color-scale-legend svg").remove();
    const svg = d3.select("continuous-color-scale-legend").append("svg").attr("width", w).attr("height", h);

    const legend = svg.append("defs").append("svg:linearGradient").attr("id", "gradient").attr("x1", "100%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%").attr("spreadMethod", "pad");
    for (let i = 0; i < range.length; i++) {
        legend.append("stop").attr("offset", ((i / (range.length - 1)) * 100) + "%").attr("stop-color", range[range.length - i - 1]).attr("stop-opacity", 1);
    }

    svg.append("rect").attr("width", w - 100).attr("height", h).style("fill", "url(" + (urlPath || "") + "#gradient)").attr("transform", "translate(0,10)").attr("x", 20);
    const y = ( log ? d3.scale.log() : d3.scale.linear() ).range([h, 0]).domain([domain[0], domain[domain.length - 1]]);
    // build yAxis with format function for ticks
    const yAxis = d3.svg.axis().scale(y).orient("right").tickFormat(formatValue(domain, log, scaleUnit));
    svg.append("g").attr("class", "y axis").attr("transform", "translate(41,10)").call(yAxis);
};

app.directive('continuousColorScaleLegend', function($location) {
    return {
        scope: {
            tool: '=',
        },
        link: function(scope, element, attrs) {
            scope.$watch("tool", function() {
                applyContinuousScale(scope.tool.colorScale(), scope.tool.scaleUnit, $location.$$path);
            }, true);
        }
    };
});

})();

(function() {
'use strict';

/*
* This file defines a set of "Standard" flow views
*
* They implement a common API, in particular they are essentially a mapping: node -> single value
* (the single value can be structured but will be displayed as a single value as opposed to multi-valued views like tags)
*
*/
const app = angular.module('dataiku.flow.tools');


const WARN_LEVEL_COLORS = {
    OK: '#81C241',
    WARN: 'darkorange',
    ERROR: 'red'
};


app.service('WatchView', function(StandardFlowViews) {
    this.getDefinition = function() {
        return StandardFlowViews.getDefinition('WATCH', 'Watched and starred items', {
            getRepr: val => val.w ? 'Watching' : undefined,
            colorMap: repr => repr == 'Watching' ? 'green' : '#e9e9e9',
            totem: function(val) {
                return {
                    class: val.s ? 'icon-star' : '',
                    style: val.s ? 'color: gold; font-size: 32px;' : ''
                }
            }
        });
    }
});


app.service('SparkConfigView', function(ColorPalettesService, StandardFlowViews) {
    this.getDefinition = function() {
        const colorPalette = ColorPalettesService.fixedColorsPalette('spark-config-flow-view');

        return StandardFlowViews.getDefinition('SPARK_CONFIG', 'Spark configurations', {
            colorMap: colorPalette,
            getRepr: val => val.inheritConf,
            totem: function(val) {
                return {
                    class: val.conf.length ? 'icon-plus flow-totem-ok' : '',
                    style: ''
                }
            },
            tooltipTemplate: '/templates/flow-editor/tools/spark-config-view-tooltip.html',
            helpLink: 'spark/configuration.html'
        });
    }
});


app.service('ConnectionsView', function(ColorPalettesService, StandardFlowViews) {
    this.getDefinition = function() {
        const colorPalette = ColorPalettesService.fixedColorsPalette('connections-flow-view');

        return StandardFlowViews.getDefinition('CONNECTIONS', 'Connections', {
            getRepr: val => val.connection,
            colorMap: function(connection) {
                if (connection == 'No connection') {
                    return '#333333';
                }
                return colorPalette(connection);
            },
            listValuesForLegend: function(list, tool) {
                let sorted = angular.copy(list);
                return sorted.sort(function(a, b) {
                    if (a == 'No connection') {
                        return 1;
                    }
                    if (b == 'No connection') {
                        return -1;
                    }
                    return tool.user.state.countByValue[b] - tool.user.state.countByValue[a];
                });
            },
            tooltipTemplate: '/templates/flow-editor/tools/connections-view-tooltip.html',
            helpLink: 'connecting/index.html'
        });
    }
});

app.service('FlowZonesView', function(ColorPalettesService, StandardFlowViews, FlowGraphFolding, FlowGraphSelection, WT1, FlowGraphFiltering) {

    this.getDefinition = function() {
        var zonesMap = new Map();

        return StandardFlowViews.getDefinition('FLOW_ZONES', 'Flow Zones', {

            getRepr: function(val) {
                return val.id;
            },
            colorMap: function(zoneId) {
                let color = zonesMap[zoneId].color;
                const rgbColor = d3.rgb(color);
                const darkerColor = rgbColor.darker(2).toString();
                color = (rgbColor.r*0.299 + rgbColor.g*0.587 + rgbColor.b*0.114) >= 250 ? darkerColor : color;
                return color;
            },
            listValuesForLegend: function(list, tool) {
                zonesMap = tool.user.state.zonesMap;
                let sorted = angular.copy(Object.keys(zonesMap));
                return sorted.sort(function(a, b) {
                    return (tool.user.state.countByValue[b] || 0) - (tool.user.state.countByValue[a] || 0);
                });
            },
            postInit: function(tool){
                tool.zonesMap = zonesMap;
                if (tool.currentSession.options.drawZones === false) {
                    Object.keys(tool.user.state.countByValue).forEach(zoneName => {
                        tool.user.state.countByValue[zoneName] = Math.max(0, tool.user.state.countByValue[zoneName] - 1);
                    });
                }
                function isItemSelectedbyId(itemId) {
                    var val = undefined;
                    if (tool.currentSession.options.drawZones === false || itemId.startsWith("zone_")) {
                        val = tool.user.state.valueByNode[itemId];
                    }
                    if (val === undefined) {
                        return false;
                    }
                    // Multi-valued view (tags, scenarios)
                    if (angular.isArray(tool.getRepr(val))) {
                        for (let v of tool.getRepr(val)) {
                            if (tool.user.state.focusMap[v]) {
                                return true;
                            }
                        }
                        return false;
                    }
                    // Single-valued view
                    return tool.user.state.focusMap[tool.getRepr(val)];
                }

                function isItemSelected(item) {
                    return isItemSelectedbyId(item.realId);
                }

                function getSelectedIdsList() {
                    const selectedIdslist = [];
                    Object.keys(tool.user.state.valueByNode).forEach(itemId => {
                        if (isItemSelectedbyId(itemId)) {
                            selectedIdslist.push(itemId);
                        }
                    });
                    return selectedIdslist;
                }
                tool.user.selectFocused = () => {
                    WT1.event("flow-view-select-focused", {tool: tool.def.getName()});
                    FlowGraphFolding.ensureNodesNotFolded(getSelectedIdsList());
                    FlowGraphSelection.select(isItemSelected);
                }

                tool.user.needFocusClass = (val, itemId) => {
                    if (itemId && tool.currentSession.options.drawZones !== false && !itemId.startsWith("zone_")) {
                        return false;
                    }
                    return tool.user.state.focusMap[tool.getRepr(val)];
                };
            },
            tooltipTemplate: '/templates/flow-editor/tools/flow-zones-view-tooltip.html',
            settingsTemplate: '/templates/flow-editor/tools/flow-zones-settings.html'
        });
    }
});

/*
* Note that the tag view is a multi-valued one (each node has several labels)
*/
app.service('TagsView', function($rootScope, $filter, $stateParams,
    DataikuAPI, CreateModalFromTemplate, TaggableObjectsUtils, TaggingService,
    FlowTool, FlowGraph, FlowToolsUtils, StandardFlowViews) {

    this.getDefinition = function() {
        return StandardFlowViews.getDefinition('TAGS', 'Tags', {
            postInit: function(tool) {
                tool.manageTags = function() {
                    CreateModalFromTemplate("/templates/widgets/edit-tags-modal.html", $rootScope, null, function(modalScope) {
                        modalScope.tagsDirty = angular.copy(TaggingService.getProjectTags());

                        modalScope.save = function() {
                            TaggingService.saveToBackend(modalScope.tagsDirty)
                                .success(modalScope.resolveModal)
                                .error(FlowGraph.setError());
                        };
                        modalScope.cancel = function() {modalScope.dismiss();};
                    });
                };
                tool.displayGlobalTags = true;
            },
            getRepr: function(val) {
                return val;
            },
            colorMap: function(repr, tool) {
                if (typeof repr == 'string') {
                    // called for a value, not a node (for legend)
                    return $filter('tagToColor')(repr);
                } else if (angular.isArray(repr)) {
                    const focused = tool.user.getFocusedAsList();
                    // if only one tag matches, make sure to use that tag color
                    const matchedTags = repr.filter(_ => focused.indexOf(_) !== -1);
                    if (matchedTags.length === 1) {
                        const tag = matchedTags[0];
                        return $filter('tagToColor')(tag);
                    }
                    return '#333'
                }
            },
            listValuesForLegend: function(list, tool) {
                return list.sort(function(a, b) {
                    return tool.user.state.countByValue[b] - tool.user.state.countByValue[a];
                });
            },
            postProcessNode: function(tags, nodeElt, tool) {
                if (!tags) return;
                tags.forEach(function(tag, idx) {
                    function onClick() {
                        tool.user.focus(tag);
                        $rootScope.$digest();
                        d3.event.stopPropagation();
                        d3.event.preventDefault();
                    }
                    FlowToolsUtils.addSimpleZone(nodeElt, $filter('tagToColor')(tag), idx, onClick);
                });
            },
            actions: {
                setTags: function(tags, nodes, mode) { // mode = TOGGLE, ADD or REMOVE
                    const request = {
                        elements: nodes.map(TaggableObjectsUtils.fromNode),
                        operations: [{mode: mode, tags: tags}]
                    };

                    DataikuAPI.taggableObjects.applyTagging($stateParams.projectKey, request).success(function(data) {
                        TaggingService.bcastTagUpdate(false, true);
                    }).error(FlowGraph.setError());
                }
            },
            autoSelectFirstOnly: true,
            tooltipTemplate: '/templates/flow-editor/tools/tags-view-tooltip.html',
            settingsTemplate: '/templates/flow-editor/tools/tags-settings.html'
        });
    }
});


app.service('CustomFieldsView', function($rootScope, $stateParams, FlowTool, StandardFlowViews, objectTypeFromNodeFlowType, localStorageService) {
    let refreshOverriden = false;

    function getLocalStorageKey() {
        return 'CustomFieldsFlowView.' + $stateParams.projectKey;
    }

    function getSelectedOption(value, fromLabel) {
        let selectedCustomField = FlowTool.getCurrent().currentSession.options.selectedCustomField;
        if (!selectedCustomField) {
            return null;
        }
        for (let taggableType in $rootScope.appConfig.customFieldsMap) {
            if ($rootScope.appConfig.customFieldsMap.hasOwnProperty(taggableType)) {
                let componentList = $rootScope.appConfig.customFieldsMap[taggableType];
                for (let i = 0; i < componentList.length; i++) {
                    let paramDesc = (componentList[i].customFields.filter(cf => cf.type == 'SELECT' && cf.selectChoices) || []).find(cf => cf.name == selectedCustomField);
                    if (paramDesc) {
                        let selOpt = (paramDesc.selectChoices || []).find(function(choice) {
                            if (fromLabel) {
                                return value && choice.label == value;
                            } else {
                                return value ? choice.value == value : (paramDesc.defaultValue && choice.value == paramDesc.defaultValue);
                            }
                        });
                        if (selOpt) {
                            return selOpt;
                        }
                    }
                }
            }
        }
        return null;
    }

    this.getDefinition = function() {
        return StandardFlowViews.getDefinition('CUSTOM_FIELDS', 'Metadata fields', {
            getRepr: function(val) {
                let selOpt = getSelectedOption(val);
                return (selOpt && (selOpt.label || selOpt.value)) || val;
            },
            postInit: function(tool) {
                tool.objectTypeFromNodeFlowType = objectTypeFromNodeFlowType;
                // override refreshStateLater in order to save the field in local storage
                if (!refreshOverriden) {
                    let refreshStateLater = FlowTool.getCurrent().refreshStateLater;
                    FlowTool.getCurrent().refreshStateLater = function() {
                        let selectedCustomField = FlowTool.getCurrent().currentSession.options.selectedCustomField;
                        localStorageService.set(getLocalStorageKey(), selectedCustomField);
                        refreshStateLater();
                    };
                    refreshOverriden = true;
                }

                // build selectable fields
                let selFields = [];
                for (let taggableType in $rootScope.appConfig.customFieldsMap) {
                    if (['DATASET', 'MANAGED_FOLDER', 'STREAMING_ENDPOINT', 'SAVED_MODEL', 'MODEL_EVALUATION_STORE', 'RECIPE'].includes(taggableType) && $rootScope.appConfig.customFieldsMap.hasOwnProperty(taggableType)) {
                        let componentList = $rootScope.appConfig.customFieldsMap[taggableType];
                        for (let i = 0; i < componentList.length; i++) {
                            selFields = selFields.concat(componentList[i].customFields.filter(cf => cf.type == 'SELECT' && !selFields.find(sf => sf.name == cf.name))
                                .map(paramDesc => ({name: paramDesc.name, label: componentList[i].meta.label + ' - ' + paramDesc.label})));
                        }
                    }
                }
                tool.selectableFields = selFields;

                // get the previously selected field in storge if it exists
                let storedSelectedCustomField = localStorageService.get(getLocalStorageKey());
                let hasToChange = storedSelectedCustomField && tool.currentSession.options.selectedCustomField != storedSelectedCustomField;
                if (hasToChange) {
                    tool.currentSession.options.selectedCustomField = storedSelectedCustomField;
                    tool.refreshStateLater();
                } else if (!tool.currentSession.options.selectedCustomField) {
                    tool.currentSession.options.selectedCustomField = (tool.selectableFields[0] || {}).name;
                    tool.refreshStateLater();
                }
            },
            colorMap: function(repr, tool) {
                let selOpt = getSelectedOption(repr, true);
                return (selOpt && selOpt.color) || '#333';
            },
            listValuesForLegend: function(list, tool) {
                return list.sort(function(a, b) {
                    return tool.user.state.countByValue[b] - tool.user.state.countByValue[a];
                });
            },
            tooltipTemplate: '/templates/flow-editor/tools/custom-fields-view-tooltip.html',
            settingsTemplate: '/templates/flow-editor/tools/custom-fields-settings.html'
        });
    };
});


/*
* Note that the scenarios view is a multi-valued one (each node has several labels)
*/
app.service('ScenariosView', function($rootScope, $filter, ColorPalettesService, FlowToolsUtils, StandardFlowViews) {
    const ACTIONS = {
        'build_flowitem': 'Build',
        'clear_items': 'Clear',
        'check_dataset': 'Run checks',
        'compute_metrics': 'Compute metrics',
        'sync_hive': 'Synchronize Hive',
        'update_from_hive': 'Update from Hive'
    };

    this.getDefinition = function() {
        const colorPalette = ColorPalettesService.fixedColorsPalette('scenarios-flow-view');

        return StandardFlowViews.getDefinition('SCENARIOS', 'Scenarios', {
            getRepr: function(uses) {
                return uses.map(use => use.scenarioName+' ('+use.scenarioId+')');
            },
            colorMap: function(repr, tool) {
                if (typeof repr == 'string') {
                    // called for a value, not a node (for legend)
                    return colorPalette(repr);
                } else if (angular.isArray(repr)) {
                    const focused = tool.user.getFocusedAsList();
                    if (focused.length == 1) {
                        const scenarioId = focused[0];
                        return colorPalette(scenarioId);
                    }
                    return '#333';
                }
            },
            listValuesForLegend: function(list, tool) {
                return list.sort(function(a, b) {
                    return tool.user.state.countByValue[b] - tool.user.state.countByValue[a];
                });
            },
            postProcessNode: function(uses, nodeElt, tool) {
                if (!uses) return;
                uses.forEach(function(use, idx) {
                    function onClick() {
                        tool.user.focus(use);
                        $rootScope.$digest();
                        d3.event.stopPropagation();
                        d3.event.preventDefault();
                    }
                    const fullId = use.scenarioName+' ('+use.scenarioId+')';
                    FlowToolsUtils.addSimpleZone(nodeElt, colorPalette(fullId), idx, onClick);
                });
            },
            actions: {
                getActionsNames(actions) {
                    if (!actions) return;
                    return actions.map(a => ACTIONS[a]);
                }
            },
            autoSelectFirstOnly: true,
            tooltipTemplate: '/templates/flow-editor/tools/scenarios-view-tooltip.html',
            helpLink: 'scenarios/definitions.html'
        });
    }
});


app.service('FileformatsView', function(ColorPalettesService, StandardFlowViews) {
    this.getDefinition = function() {
        const colorPalette = ColorPalettesService.fixedColorsPalette('fileformat-flow-view');

        return StandardFlowViews.getDefinition('FILEFORMATS', 'File format', {
            getRepr: val => val.formatType,
            colorMap: function(connection) {
                return colorPalette(connection);
            },
            listValuesForLegend: function(list, tool) {
                return list.sort();
            },
            tooltipTemplate: '/templates/flow-editor/tools/fileformats-view-tooltip.html',
        });
    }
});


app.service('PipelinesView', function(ColorPalettesService, StandardFlowViews) {
    this.getService = function(toolName) {
        let displayName;
        let helpLink;
        if (toolName === "SPARK_PIPELINES") {
            displayName = "Spark pipelines";
            helpLink = "spark/pipelines.html"
        } else if (toolName === "SQL_PIPELINES") {
            displayName = "SQL pipelines";
            helpLink = "sql/pipelines/index.html"
        }
        return {
            getDefinition: function() {

                const colorPalette = ColorPalettesService.fixedColorsPalette('pipelines-flow-view');
                for (let i = 1; i <= 12; i++) {
                    colorPalette('Pipeline '+i); //Force the order or the colors since the palette is optimized for using first colors
                }

                return StandardFlowViews.getDefinition(toolName,  displayName, {
                    getRepr: function(val) {
                        if (val.pipelineId) {
                            return val.pipelineId
                        }
                        if (val.virtualizable) {
                            return null;// Dataset
                        }
                        return;
                    },
                    listValuesForLegend: function(list) {
                        return list.map( (x, idx) => 'Pipeline '+(idx+1));
                    },
                    colorMap: colorPalette,
                    colorSuccessorsWithSameColor: true,
                    totem: function(val) {
                        return {
                            class: val.virtualizable ? 'icon-forward flow-totem-ok' : '',
                            style: ''
                        }
                    },
                    tooltipTemplate: '/templates/flow-editor/tools/pipeline-view-tooltip.html',
                    helpLink: helpLink
                });
            }
        }
    };
});


app.service('ImpalaWriteModeView', function(StandardFlowViews) {
    this.getDefinition = function() {
        return StandardFlowViews.getDefinition('IMPALA_WRITE_MODE', 'Impala write mode', {
            getRepr: val => val,
            colorMap: function(flag) {
                return {
                    'Stream': '#00CC00',
                    'Impala write': '#0000CC',
                    'ERROR': '#333333',
                }[flag];
            },
            helpLink: 'hadoop/impala.html#using-impala-to-write-outputs'
        });
    }
});


app.service('HiveModeView', function(StandardFlowViews) {
    this.getDefinition = function() {
        return StandardFlowViews.getDefinition('HIVE_MODE', 'Hive mode', {
            getRepr: function(val) {
                if (val == "HIVECLI_LOCAL") return "Hive CLI (isolated metastore)";
                if (val == "HIVECLI_GLOBAL") return "Hive CLI (global metastore)";
                if (val == "HIVESERVER2") return "HiveServer2";
                return val;
            },
            colorMap: function(flag) {
                return {
                    'Hive CLI (isolated metastore)': 'blue',
                    'Hive CLI (global metastore)': 'pink',
                    'HiveServer2': 'purple',
                    'ERROR': 'red',
                }[flag];
            },
            helpLink: 'hadoop/hive.html#recipes'
        });
    }
});

app.service('SparkEngineView', function(StandardFlowViews) {
    this.getDefinition = function() {
        return StandardFlowViews.getDefinition('SPARK_ENGINE', 'Spark execution engine', {
            getRepr: function(val) {
                if (val == "SPARK_SUBMIT") return "CLI (spark-submit)";
                if (val == "LIVY_BATCH") return "Livy";
                return val;
            },
            colorMap: function(flag) {
                return {
                    'CLI (spark-submit)': 'blue',
                    'Livy': 'purple',
                    'ERROR': 'red',
                }[flag];
            },
            helpLink: 'spark/usage.html'
        });
    }
});


app.service('PartitioningView', function(ColorPalettesService, StandardFlowViews) {
    this.getDefinition = function() {
        const colorPalette = ColorPalettesService.fixedColorsPalette('partitioning-flow-view');

        return StandardFlowViews.getDefinition('PARTITIONING',  'Partitioning schemes', {
            getRepr: function(val) {
                if (val.dimensions.length) {
                    return val.dimensions.map(x => x.name).sort().join(', ');
                } else {
                    return 'Not partitioned';
                }
            },
            colorMap: function(repr) {
                if (repr == 'Not partitioned') {
                    return '#333';
                }
                return colorPalette(repr);
            },
            helpLink: 'partitions/index.html',
            tooltipTemplate: '/templates/flow-editor/tools/partitioning-view-tooltip.html',
        });
    }
});


app.service('PartitionsView', function($filter, StandardFlowViews) {
    let colorScale;

    this.getDefinition = function() {
        return StandardFlowViews.getDefinition('PARTITIONS', 'Partitions count', {
            getRepr: function(val) {
                return val;
            },
            postInit: function(tool) {
                const DISCRETE_THRESHOLD = 6; // A change of 1 can be significant: for low cardinality, we use discrete map
                const LOG_SCALE_THRESHOLD = 20; // In continuous mode, if max/min > LOG_SCALE_THRESHOLD, we use log color scale
                colorScale = makeSmartIntegerColorScale(tool, DISCRETE_THRESHOLD, LOG_SCALE_THRESHOLD);
            },
            colorMap: function(repr, tool) {
                return applySmartColorScale(repr, tool, colorScale);
            },
            helpLink: 'partitions/index.html',
            tooltipTemplate: '/templates/flow-editor/tools/partitions-view-tooltip.html',
        });
    }
});


app.service('DatasetMetricsView', function($filter, StandardFlowViews) {
    let colorScale;

    this.getDefinition = function() {
        return StandardFlowViews.getDefinition('METRICS', 'Metrics', {

        });
    }
});


app.service('DatasetChecksView', function($filter, StandardFlowViews) {
    let colorScale;

    this.getDefinition = function() {
        return StandardFlowViews.getDefinition('CHECKS', 'Checks', {

        });
    }
});


app.service('RecentActivityView', function(StandardFlowViews) {
    let colorScale;

    this.getDefinition = function() {
        return StandardFlowViews.getDefinition('RECENT_ACTIVITY', 'Recent modifications', {
            getRepr: function(val) {
                return val.numberOfModifications;
            },
            postInit: function(tool) {
                if (!tool.currentSession.options.since) {
                    const lastWeek = new Date(new Date().getTime()-7*24*3600*1000);
                    tool.currentSession.options.since = lastWeek;
                }
                const DISCRETE_THRESHOLD = 6; // Don't use discrete color map
                const LOG_SCALE_THRESHOLD = 20; // In continuous mode, if max/min > LOG_SCALE_THRESHOLD, we use log color scale
                colorScale = makeSmartIntegerColorScale(tool, DISCRETE_THRESHOLD, LOG_SCALE_THRESHOLD);
            },
            colorMap: function(repr, tool) {
                return applySmartColorScale(repr, tool, colorScale);
            },
            tooltipTemplate: '/templates/flow-editor/tools/recent-activity-view-tooltip.html',
            settingsTemplate: '/templates/flow-editor/tools/recent-activity-settings.html'
        });
    }
});


app.service('FilesizeView', function($filter, StandardFlowViews) {
    let colorScale;

    this.getDefinition = function() {
        return StandardFlowViews.getDefinition('FILESIZE', 'File size', {
            scaleUnit: 'FILESIZE',
            getRepr: function(val) {
                let totalValue = parseFloat(val.size.totalValue);
                if (isNaN(totalValue) || totalValue <= 0) {
                    return 'Unknown';
                }
                return totalValue;
            },
            postInit: function(tool) {
                const DISCRETE_THRESHOLD = 0; // Don't use discrete color map
                const LOG_SCALE_THRESHOLD = 20; // In continuous mode, if max/min > LOG_SCALE_THRESHOLD, we use log color scale
                colorScale = makeSmartIntegerColorScale(tool, DISCRETE_THRESHOLD, LOG_SCALE_THRESHOLD);
            },
            colorMap: function(repr, tool) {
                return applySmartColorScale(repr, tool, colorScale);
            },
            colorScale: function() {
                return colorScale;
            },
            tooltipTemplate: '/templates/flow-editor/tools/filesize-view-tooltip.html',
        });
    }
});


app.service('CountOfRecordsView', function(StandardFlowViews) {
    let colorScale;
    let values;
    this.getDefinition = function() {
        return StandardFlowViews.getDefinition('COUNT_OF_RECORDS', 'Count of records', {
            getRepr: function(val) {
                let totalValue = parseFloat(val.countOfRecords.totalValue);
                if (totalValue == -1) {
                    return 'Unknown';
                }
                return totalValue;
            },
            postInit: function(tool) {
                const DISCRETE_THRESHOLD = 6; // A change of 1 can be significant: for low cardinality, we use discrete map
                const LOG_SCALE_THRESHOLD = 20; // In continuous mode, if max/min > LOG_SCALE_THRESHOLD, we use log color scale
                colorScale = makeSmartIntegerColorScale(tool, DISCRETE_THRESHOLD, LOG_SCALE_THRESHOLD);
            },
            colorMap: function(repr, tool) {
                return applySmartColorScale(repr, tool, colorScale);
            },
            totem: function(val) {
                return {
                    class: 'icon-refresh '+(val.autoCompute ? 'flow-totem-ok' : 'flow-totem-disabled'),
                    style: ''
                }
            },
            colorScale: function() {
                return colorScale;
            },
            tooltipTemplate: '/templates/flow-editor/tools/count-of-records-view-tooltip.html',
        });
    }
});



const DATE_REPR = [
    'Just now',
    'Past hour',
    'Past 24h',
    'Past week',
    'Past month',
    'Past year',
    'More than a year ago',
    'Unknown'
];
function simpleTimeDelta(timestamp) {
    if (typeof timestamp == 'string' && !isNaN(parseFloat(timestamp))) { //TODO @flow dirty
        timestamp = parseFloat(timestamp);
    }
    if (!timestamp || typeof timestamp != 'number') {
        return DATE_REPR[7];
    }
    const seconds = (new Date().getTime() - timestamp)/1000;
    if (seconds < 60) {
        return DATE_REPR[0];
    }
    if (seconds < 3600) {
        return DATE_REPR[1];
    }
    if (seconds < 3600*24) {
        return DATE_REPR[2];
    }
    if (seconds < 3600*24*7) {
        return DATE_REPR[3];
    }
    if (seconds < 3600*24*30) {
        return DATE_REPR[4];
    }
    if (seconds < 3600*24*365) {
        return DATE_REPR[5];
    }
    return DATE_REPR[6];
}



app.service('CreationView', function($filter, StandardFlowViews, UserImageUrl, Fn, FlowTool, ColorPalettesService) {

    const colorPalette = ColorPalettesService.fixedColorsPalette('creation-flow-view');
    const viewByUser = {
        getRepr: function(val) {
            return val.userLogin;
        },
        listValuesForLegend: function(list) {
            return list;
        },
        colorMap: function(repr, tool) {
            return colorPalette(repr);
        }
    };
    const viewByDate = {
        getRepr: function(val) {
            const time = parseFloat(val.time);
            return simpleTimeDelta(time);
        },
        listValuesForLegend: function(list) {
            return DATE_REPR.filter(x => list.includes(x));
        },
        colorMap: function(repr, tool) {
            const idx = tool.user.state.values.indexOf(repr);
            if (idx < 0) {
                throw new Error("Value not listed");
            }
            const values = tool.user.state.values.filter(v => v != 'Unknown');
            const scale = makeDiscreteBlueScale(values.length);
            return scale[idx];
        }
    };

    function getSubview() {
        const mode = FlowTool.getCurrent().currentSession.options.mode;
        if (mode == 'BY_USER') {
            return viewByUser;
        }
        return viewByDate;
    }

    this.getDefinition = function() {
        return StandardFlowViews.getDefinition('CREATION', 'Creation', {
            postInit: function(tool) {
                tool.currentSession.options.mode = tool.currentSession.options.mode || 'BY_DATE';
            },
            getRepr: function(val) {
                if (!val) return;
                return getSubview().getRepr(val);
            },
            listValuesForLegend: function(list) {
                return getSubview().listValuesForLegend(list);
            },
            colorMap: function(repr, tool) {
                return getSubview().colorMap(repr, tool);
            },
            totem: function(val) {
                return {
                    class: 'avatar32',
                    style: "background-image: url('"+UserImageUrl(val.userLogin, 128)+"')"
                };
            },
            tooltipTemplate: '/templates/flow-editor/tools/creation-view-tooltip.html',
            settingsTemplate: '/templates/flow-editor/tools/creation-view-settings.html'
        });
    };
});


app.service('LastModifiedView', function($filter, StandardFlowViews, UserImageUrl, Fn, FlowTool, ColorPalettesService) {

    const colorPalette = ColorPalettesService.fixedColorsPalette('creation-flow-view');
    const viewByUser = {
        getRepr: function(val) {
            return val.userLogin;
        },
        listValuesForLegend: function(list) {
            return list;
        },
        colorMap: function(repr, tool) {
            return colorPalette(repr);
        }
    };
    const viewByDate = {
        getRepr: function(val) {
            const time = parseFloat(val.time);
            return simpleTimeDelta(time);
        },
        listValuesForLegend: function(list) {
            return DATE_REPR.filter(x => list.includes(x));
        },
        colorMap: function(repr, tool) {
            const idx = tool.user.state.values.indexOf(repr);
            if (idx < 0) {
                throw new Error("Value not listed");
            }
            const values = tool.user.state.values.filter(v => v != 'Unknown');
            const scale = makeDiscreteBlueScale(values.length);
            return scale[idx];
        }
    };

    function getSubview() {
        const mode = FlowTool.getCurrent().currentSession.options.mode;
        if (mode == 'BY_USER') {
            return viewByUser;
        }
        return viewByDate;
    }

    this.getDefinition = function() {
        return StandardFlowViews.getDefinition('LAST_MODIFICATION', 'Last modification', {
            postInit: function(tool) {
                tool.currentSession.options.mode = tool.currentSession.options.mode || 'BY_DATE';
            },
            getRepr: function(val) {
                if (!val) return;
                return getSubview().getRepr(val);
            },
            listValuesForLegend: function(list) {
                return getSubview().listValuesForLegend(list);
            },
            colorMap: function(repr, tool) {
                return getSubview().colorMap(repr, tool);
            },
            totem: function(val) {
                return {
                    class: 'avatar32',
                    style: "background-image: url('"+UserImageUrl(val.userLogin, 128)+"')"
                };
            },
            tooltipTemplate: '/templates/flow-editor/tools/last-modification-view-tooltip.html',
            settingsTemplate: '/templates/flow-editor/tools/last-modification-view-settings.html',
        });
    };
});


app.service('LastBuildView', function($filter, StandardFlowViews, Fn) {

    this.getDefinition = function() {
        return StandardFlowViews.getDefinition('LAST_BUILD', 'Last build', {
            getRepr: function(val) {
                if (!val) return;
                const time = parseFloat(val.buildEndTime);
                return simpleTimeDelta(time);
            },
            listValuesForLegend: function(list) {
                return DATE_REPR.filter(x => list.includes(x));
            },
            totem: function(val) {
                return {
                    class: val.buildSuccess ? 'icon-ok flow-totem-ok' : 'icon-remove flow-totem-error',
                    style: ''
                }
            },
            colorMap: function(repr, tool) {
                const idx = tool.user.state.values.indexOf(repr);
                if (idx < 0) {
                    throw new Error("Value not listed");
                }
                const values = tool.user.state.values.filter(v => v != 'Unknown');
                const scale = makeDiscreteBlueScale(values.length);
                return scale[idx];
            },
            tooltipTemplate: '/templates/flow-editor/tools/last-build-view-tooltip.html',
        });
    };
});


app.service('LastBuildDurationView', function(StandardFlowViews, FlowTool) {
    let lastSelectedScale = 'LINEAR';
    let linearColorScale, logColorScale;
    const getColorScale = () => FlowTool.getCurrent().currentSession.options.scale === 'LINEAR' ? linearColorScale : logColorScale;

    this.getDefinition = function() {
        return StandardFlowViews.getDefinition('LAST_BUILD_DURATION', 'Last build duration', {
            scaleUnit: 'DURATION',
            getRepr: function(val) {
                if (val < 0) return;
                return val;
            },
            postInit: function(tool) {
                tool.currentSession.options.scale = tool.currentSession.options.scale || lastSelectedScale;
                lastSelectedScale = tool.currentSession.options.scale;
                linearColorScale = makeSmartIntegerColorScale(tool, 0, Infinity, timeColorRange);
                logColorScale = makeSmartIntegerColorScale(tool, 0, 0, timeColorRange);
            },
            colorMap: function(repr, tool) {
                return applySmartColorScale(repr, tool, getColorScale());
            },
            colorScale: function() {
                return getColorScale();
            },
            colorSuccessorsWithSameColor: true,
            tooltipTemplate: '/templates/flow-editor/tools/last-build-duration-view-tooltip.html',
            settingsTemplate: '/templates/flow-editor/tools/last-build-duration-view-settings.html',
        });
    };
});

app.service('RecipesEnginesView', function($filter, StandardFlowViews) {
    const COLORS = { //Keep this in order of display
        Spark: '#f28c38',
        Impala: '#795548',
        Hive: '#f9bd38',
        'Hadoop mapreduce': '#bfcd31',
        Pig: '#f48fb1',
        'S3 to redshift': '#c85dcb',
        Sql: '#28aadd',

        DSS: '#2ab1ac',

        'Docker/kubernetes': '#386fde',
        'User code in container': '#4E77B1',

        'User code': '#607d8b',
        'Plugin code': '#8541aa',

        Other: '#333333',
        Error: '#ff0000'
    };

    this.getDefinition = function() {
        return StandardFlowViews.getDefinition('RECIPES_ENGINES', 'Recipe engines', {
            colorSuccessorsWithSameColor: true,
            colorMap: engineType => COLORS[engineType],
            getRepr: function(engineStatus) {
                if (engineStatus.type == 'DSS') {
                    return 'DSS';
                } else {
                    return $filter('capitalize')(engineStatus.type.toLowerCase().replace('_', ' '));
                }
            },
            listValuesForLegend: function(list) {
                return Object.keys(COLORS).filter(x => list.includes(x));
            },

            totem: function(val) {
                return {
                    class: val.statusWarnLevel == 'ERROR' ? 'icon-remove flow-totem-error' : '',
                    style: ''
                }
            },
            tooltipTemplate: '/templates/flow-editor/tools/recipes-engines-view-tooltip.html'
        });
    }
});

app.service('RecipesCodeEnvsView', function($filter, StandardFlowViews, ColorPalettesService) {
    const colorPalette = ColorPalettesService.fixedColorsPalette('code-envs-flow-view');
    this.getDefinition = function() {
        return StandardFlowViews.getDefinition('RECIPES_CODE_ENVS', 'Recipe code environments', {
            colorMap: function(repr) {
                if (repr === 'DSS builtin env') {
                    return '#4d4d4d';
                } else {
                    return colorPalette(repr);
                }
            },
            getRepr: function(codeEnvState) {
                return codeEnvState.selectedEnvName || codeEnvState.envName || 'DSS builtin env';
            },

            totem: function(val) {
                return {
                    class: val.preventedByProjectSettings ? 'icon-remove flow-totem-error' : '',
                    style: ''
                }
            },
            tooltipTemplate: '/templates/flow-editor/tools/recipes-code-envs-view-tooltip.html',
            helpLink: 'code-envs/index.html'
        });
    }
});

app.service('StandardFlowViews', function($stateParams, $rootScope, Debounce, DataikuAPI, FlowToolsUtils, FlowViewsUtils, FlowGraph, FlowGraphHighlighting, Logger) {
this.getDefinition = function(name, displayName, {
        getRepr,
        listValuesForLegend,
        colorMap,
        colorScale,
        colorSuccessorsWithSameColor,
        totem,
        autoSelectFirstOnly,
        tooltipTemplate,
        settingsTemplate,
        helpLink,
        postInit,
        postProcessNode,
        actions,
        scaleUnit, // (optional) allows to choose how the tool scale will be lableled. Options are 'FILESIZE', 'DURATION', anything else will display the value as a number.
    }) {

    return {
        getName: () => name,
        getToolDisplayName: () => displayName,

        initFlowTool : function(tool) {
            tool.user = {};
            tool.projectKey = $stateParams.projectKey;

            tool.refreshState = function(needToResetFocused, needToUpdateGraphTags) {
                DataikuAPI.flow.tools.getState($stateParams.projectKey, name, tool.currentSession.options).success(function(data) {
                    tool.user.state = data;
                    if (needToResetFocused) {
                        tool.user.state.focused = tool.user.state.values;
                    } else {
                        tool.currentSession.options.mode = tool.user.state.mode;
                    }

                    if (needToUpdateGraphTags) {
                        FlowGraph.updateTagsFromFlowTool(tool.user.state.valueByNode);
                    }

                    const countByValue = {};
                    $.each(tool.user.state.valueByNode, function(nodeId, val) {
                        const repr = getRepr(val);
                        if (angular.isArray(repr)) {
                            repr.forEach(function(it) {
                                countByValue[it] = (countByValue[it] || 0) + 1;
                            });
                        } else if (repr !== null && repr !== undefined) {
                            countByValue[repr] = (countByValue[repr] || 0) + 1;
                        }
                    });
                    tool.user.state.countByValue = countByValue;
                    tool.user.state.values = Object.keys(countByValue);
                    if (listValuesForLegend) { // The order of values is not standard
                        tool.user.state.values = listValuesForLegend(tool.user.state.values, tool);
                    } else {
                        tool.user.state.values.sort();
                    }

                    tool.user.state.focusMap = {};
                    try {
                        if (!tool.user.state.focused || !tool.user.state.focused.length) {
                            if (autoSelectFirstOnly) {
                                if (tool.user.state.values.length) {
                                    const first = listValuesForLegend(tool.user.state.values, tool)[0];
                                    tool.user.state.focusMap[first] = true;
                                }
                            } else {
                                tool.user.state.values.forEach(function(v) {
                                    tool.user.state.focusMap[v] = true;
                                });
                            }
                        } else {
                            tool.user.state.focused.forEach(function(v) {
                                tool.user.state.focusMap[v] = true;
                            })
                        }
                    } catch (e) {
                        Logger.error(e);
                    }

                    if (postInit) {
                        postInit(tool);
                    }

                    tool.drawHooks.updateFlowToolDisplay();
                }).error(FlowGraph.setError());
            };

            tool.refreshStateLater = Debounce().withDelay(400, 400).wrap(tool.refreshState);

            FlowViewsUtils.addFocusBehavior(tool, true);

            tool.user.getColor = function(repr) {
                if (repr == 'Unknown') {
                    return '#333';
                }
                return colorMap(repr, tool);
            };

            function colorNode(nodeId, node, val) {
                const isZone = node.nodeType === 'ZONE';
                const nodeElt = isZone ? FlowGraph.d3ZoneNodeWithId(nodeId) : FlowGraph.d3NodeWithId(nodeId);
                const focused = tool.user.needFocusClass ? tool.user.needFocusClass(val, node.realId) : true;
                nodeElt.classed('focus', focused).classed('out-of-focus', false);
                const repr = getRepr(val);
                if (repr === null) {
                    return;
                }
                const color = tool.user.getColor(repr);
                if (!color) {
                    Logger.debug('No color');
                    return;
                }
                FlowToolsUtils.colorNode(node, nodeElt, color);
            }

            tool.drawHooks.updateFlowToolDisplay = function() {
                if (!tool.user.state) return; // protect against slow state fetching
                if (!FlowGraph.ready()) return; // protect against slow graph fetching

                // TODO @flow too slow?
                $.each(FlowGraph.get().nodes, function(nodeId, node) {
                    let realNodeId = node.realId || nodeId;
                    if (tool.user.state.valueByNode[realNodeId] === undefined) {
                        const nodeElt = FlowGraph.d3NodeWithId(nodeId);
                        nodeElt.classed('focus', false).classed('out-of-focus', true);
                        $('.node-totem span', nodeElt[0]).removeAttr('style').removeClass();
                        $('.never-built-computable *', nodeElt[0]).removeAttr('style');
                    }
                });

                $('.tool-simple-zone', FlowGraph.getSvg()).empty();

                // We first iterate over all non-recipes then on recipes,
                // This is because in some cases, recipes color their outputs
                function styleNodes(recipesOnly) {
                    $.each(FlowGraph.get().nodes, function(nodeId, node) {
                        let val = tool.user.state.valueByNode[node.realId];
                        if (!node) { // If some nodes are broken, they might not be rendered in the flow
                            return;
                        }
                        const isRecipe = node.nodeType == 'RECIPE';
                        if (recipesOnly != isRecipe) {
                            return;
                        }
                        const isZone = node.nodeType == "ZONE";
                        if (isZone && tool.user.state.focusMap[node.name] && !$stateParams.zoneId) {
                            FlowGraphHighlighting.highlightZoneCluster(d3.select(`g[id=cluster_zone_${node.name}]`)[0][0], colorMap(node.name));
                        }
                        if (val !== undefined) {
                            const nodeElt = isZone ? FlowGraph.d3ZoneNodeWithId(nodeId) : FlowGraph.d3NodeWithId(nodeId);
                            if (tool.user.isFocused(val)) {
                                colorNode(nodeId, node, val);
                                if (recipesOnly && colorSuccessorsWithSameColor) {
                                    $.each(node.successors, function(index, nodeId2) {
                                        colorNode(nodeId2, FlowGraph.node(nodeId2), val);
                                    });
                                }
                            } else {
                                nodeElt.classed('focus', false).classed('out-of-focus', true);
                            }

                            const nodeTotem = $('.node-totem span', nodeElt[0]);
                            nodeTotem.removeAttr('style').removeClass();
                            if (totem && totem(val)) {
                                nodeTotem.attr('style', totem(val).style).addClass(totem(val).class);
                            }

                            if (postProcessNode) {
                                postProcessNode(val, nodeElt, tool);
                            }
                        }
                    });
                }
                d3.selectAll(".zone_cluster.clusterHighlight").each(function() {
                    this.style.backgroundColor = null;
                    this.style.color = "#000"; // Because default background is whitish
                }).classed("clusterHighlight", false);
                styleNodes(false);
                styleNodes(true);
            };

            tool.drawHooks.setupTootip = function(node) {
                if (!tool.user || !tool.user.state) return;
                const tooltip = {};
                tooltip.val = tool.user.state.valueByNode[node.realId];
                tooltip.template = tooltipTemplate || '/templates/flow-editor/tools/default-view-tooltip.html';
                if (!tooltip.val || getRepr(tooltip.val) == null) {
                    return tooltip;
                }
                const repr = getRepr(tooltip.val);
                let bulletText = tool.type == "FLOW_ZONES" ? tooltip.val.name : repr;
                tooltip.bullets = [{text: bulletText, color: tool.user.getColor(repr)}];
                return tooltip;
            };

            tool.saveFocus = function() {
                const focusedList = [];
                $.each(tool.user.state.focusMap, function (val, f) {
                    if (f) {
                        focusedList.push(val);
                    }
                });
                DataikuAPI.flow.tools.setFocused($stateParams.projectKey, focusedList, tool.currentSession.options.mode).error(FlowGraph.setError());
            };

            tool.helpLink = helpLink;
            tool.getRepr = getRepr;
            tool.colorScale = colorScale;
            tool.def.settingsTemplate = settingsTemplate;
            tool.currentSession.options = {};
            tool.actions = actions;
            tool.scaleUnit = scaleUnit;

            tool.refreshState();
        },

        template: '/templates/flow-editor/tools/standard-flow-view.html'
    };
};

function makeForeignObject(attrs, jq) {
    const el = makeSVG('foreignObject', attrs)
    $(el).append(jq);
    return el;
}
});


app.controller("StandardFlowViewsMainController", function($scope, FlowTool) {
    $scope.tool = FlowTool.getCurrent();
});

function makeDiscreteBlueScale(cardinality) {
    if (!(cardinality > -1 && cardinality < 8)) {
        throw new Error("Color scales can only be 0 to 7 colors. Got "+cardinality);
    }
    return [
        [],
        ['#5479D5'],
        ['#5479D5','#94CEF9'],
        ['#304389','#5479D5','#94CEF9'],
        ['#304389','#3E58B2','#6B9DED','#94CEF9',],
        ['#304389','#3E58B2','#6B9DED','#94CEF9','#B3E7FC'],
        ['#304389','#3E58B2','#5479D5','#6B9DED','#94CEF9','#B3E7FC'],
        ['#1C2D71','#304389','#3E58B2','#5479D5','#6B9DED','#94CEF9','#B3E7FC'],
    ][cardinality]
}

const viridisRange = ["#440154","#440256","#450457","#450559","#46075a","#46085c","#460a5d","#460b5e",
                    "#470d60","#470e61","#471063","#471164","#471365","#481467","#481668","#481769",
                    "#48186a","#481a6c","#481b6d","#481c6e","#481d6f","#481f70","#482071","#482173",
                    "#482374","#482475","#482576","#482677","#482878","#482979","#472a7a","#472c7a",
                    "#472d7b","#472e7c","#472f7d","#46307e","#46327e","#46337f","#463480","#453581",
                    "#453781","#453882","#443983","#443a83","#443b84","#433d84","#433e85","#423f85",
                    "#424086","#424186","#414287","#414487","#404588","#404688","#3f4788","#3f4889",
                    "#3e4989","#3e4a89","#3e4c8a","#3d4d8a","#3d4e8a","#3c4f8a","#3c508b","#3b518b",
                    "#3b528b","#3a538b","#3a548c","#39558c","#39568c","#38588c","#38598c","#375a8c",
                    "#375b8d","#365c8d","#365d8d","#355e8d","#355f8d","#34608d","#34618d","#33628d",
                    "#33638d","#32648e","#32658e","#31668e","#31678e","#31688e","#30698e","#306a8e",
                    "#2f6b8e","#2f6c8e","#2e6d8e","#2e6e8e","#2e6f8e","#2d708e","#2d718e","#2c718e",
                    "#2c728e","#2c738e","#2b748e","#2b758e","#2a768e","#2a778e","#2a788e","#29798e",
                    "#297a8e","#297b8e","#287c8e","#287d8e","#277e8e","#277f8e","#27808e","#26818e",
                    "#26828e","#26828e","#25838e","#25848e","#25858e","#24868e","#24878e","#23888e",
                    "#23898e","#238a8d","#228b8d","#228c8d","#228d8d","#218e8d","#218f8d","#21908d",
                    "#21918c","#20928c","#20928c","#20938c","#1f948c","#1f958b","#1f968b","#1f978b",
                    "#1f988b","#1f998a","#1f9a8a","#1e9b8a","#1e9c89","#1e9d89","#1f9e89","#1f9f88",
                    "#1fa088","#1fa188","#1fa187","#1fa287","#20a386","#20a486","#21a585","#21a685",
                    "#22a785","#22a884","#23a983","#24aa83","#25ab82","#25ac82","#26ad81","#27ad81",
                    "#28ae80","#29af7f","#2ab07f","#2cb17e","#2db27d","#2eb37c","#2fb47c","#31b57b",
                    "#32b67a","#34b679","#35b779","#37b878","#38b977","#3aba76","#3bbb75","#3dbc74",
                    "#3fbc73","#40bd72","#42be71","#44bf70","#46c06f","#48c16e","#4ac16d","#4cc26c",
                    "#4ec36b","#50c46a","#52c569","#54c568","#56c667","#58c765","#5ac864","#5cc863",
                    "#5ec962","#60ca60","#63cb5f","#65cb5e","#67cc5c","#69cd5b","#6ccd5a","#6ece58",
                    "#70cf57","#73d056","#75d054","#77d153","#7ad151","#7cd250","#7fd34e","#81d34d",
                    "#84d44b","#86d549","#89d548","#8bd646","#8ed645","#90d743","#93d741","#95d840",
                    "#98d83e","#9bd93c","#9dd93b","#a0da39","#a2da37","#a5db36","#a8db34","#aadc32",
                    "#addc30","#b0dd2f","#b2dd2d","#b5de2b","#b8de29","#bade28","#bddf26","#c0df25",
                    "#c2df23","#c5e021","#c8e020","#cae11f","#cde11d","#d0e11c","#d2e21b","#d5e21a",
                    "#d8e219","#dae319","#dde318","#dfe318","#e2e418","#e5e419","#e7e419","#eae51a",
                    "#ece51b","#efe51c","#f1e51d","#f4e61e","#f6e620","#f8e621","#fbe723","#fde725"].reverse();

const timeColorRange = ["#D2030E", "#D3090E", "#D40F0F", "#D51610", "#D71D11", "#D82311", "#D92912",
                        "#DA3013", "#DB3613", "#DD3C14", "#DE4115", "#DE4415", "#DF4716", "#E04B17",
                        "#E14E18", "#E15118", "#E25419", "#E3581A", "#E45B1B", "#E45E1B", "#E5621C",
                        "#E6651D", "#E7681E", "#E76B1E", "#E86F1F", "#E97320", "#E97721", "#EA7A22",
                        "#EB7E23", "#EB8124", "#EC8525", "#ED8926", "#ED8C27", "#EE9028", "#EF9429",
                        "#EF982A", "#F09B2B", "#F09E2C", "#F1A22D", "#F1A52E", "#F1A82F", "#F2AC30",
                        "#F2AF31", "#F3B232", "#F3B633", "#F3B934", "#F4BD35", "#F4C036", "#F0C03B",
                        "#E5BE47", "#DDBB52", "#D4B95C", "#CBB765", "#C2B570", "#B9B27B", "#AFB086",
                        "#A7AE90", "#9EAB9A", "#94A9A5", "#8BA7AF", "#83A5B9", "#7AA2C4", "#70A0CF",
                        "#699DD6", "#669BD4", "#6498D3", "#6296D1", "#5F93CF", "#5D90CD", "#5B8DCC",
                        "#588BCA", "#5688C8", "#5485C7", "#5182C5", "#4F80C3", "#4D7EC2", "#4A7BC0",
                        "#4879BE", "#4577BC", "#4374BB", "#4072B9", "#3E70B7", "#3B6DB6", "#396BB4",
                        "#3668B2", "#3466B1", "#3265B0", "#3063AE", "#2E62AD", "#2C60AC", "#2A5EAB",
                        "#285DAA", "#265BA9", "#245AA7", "#2258A6", "#1F56A5", "#1D55A4", "#1B53A3",
                        "#1952A2", "#1750A1"].reverse();

function makeSmartScale(range, domain, log = false) {
    const minValue = domain[0];
    const maxValue = domain[1];
    return function(val) {
        const n = range.length;
        let t = log ? (Math.log10(val) - Math.log10(minValue)) / (Math.log10(maxValue) - Math.log10(minValue)) : ((val - minValue) / (maxValue - minValue));
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
    };
}

function makeSmartIntegerColorScale(tool, discreteThreshold, logScaleThreshold, range = viridisRange) {
    const colorScale = {};

    // convert to number (when possible)
    tool.user.state.values = tool.user.state.values.map(x => !isNaN(parseFloat(x)) ? parseFloat(x) : x);
    tool.user.state.values.sort((a,b) => typeof a == 'number' && typeof b == 'number' ? b - a : -1);

    const numberValues = tool.user.state.values.filter(x => typeof x == 'number');
    const maxValue = Math.max.apply(null, numberValues);
    const minValue = Math.min.apply(null, numberValues);
    if (maxValue == -Infinity) {
        colorScale.mode = 'ERROR';
    } else if (tool.user.state.values.length < discreteThreshold) {
        colorScale.mode = 'DISCRETE';
        colorScale.domain = [0, Math.max(numberValues.length - 1, 1)];
    } else {
        const nonZeroValues = tool.user.state.values.filter(x => typeof x == 'number' && x > 0);
        const nonZeroMaxValue = Math.max.apply(null, nonZeroValues);
        const nonZeroMinValue = Math.min.apply(null, nonZeroValues);
        if (nonZeroMaxValue != -Infinity && nonZeroMaxValue != nonZeroMinValue && nonZeroMaxValue / nonZeroMinValue > logScaleThreshold) {
            colorScale.mode = 'CONTINUOUS_LOG';
            colorScale.continuous = true;
            colorScale.log = true;
            // domain size is not 0
            colorScale.domain = [nonZeroMinValue, nonZeroMaxValue];
        } else {
            colorScale.mode = 'CONTINUOUS_LINEAR';
            colorScale.continuous = true;
            colorScale.log = false;
            colorScale.domain = [minValue, maxValue];
            if (colorScale.domain[0] == colorScale.domain[1]) {
                colorScale.domain[0] = 0; // todo check if its okay
            }
        }
    }
    if (colorScale.mode != 'ERROR') {
        colorScale.range = range;
        colorScale.scale = makeSmartScale(colorScale.range, colorScale.domain, !!colorScale.log);
    }

    return colorScale;
}

function applySmartColorScale(repr, tool, colorScale) {
    if (colorScale.mode == 'DISCRETE') {
        const numberValues = tool.user.state.values.filter(x => typeof x == 'number');
        numberValues.sort((a,b) => typeof a == 'number' && typeof b == 'number' ? a - b : -1);
        return colorScale.scale(numberValues.indexOf(repr));
    } else if (colorScale.mode == 'CONTINUOUS_LINEAR') {
        return colorScale.scale(repr);
    } else if (colorScale.mode == 'CONTINUOUS_LOG') {
        if (repr == 0) {
            return colorScale.range[0]; // Log scale can't handle 0, fallback to edge of range
        }
        return colorScale.scale(repr);
    }
}

})();

(function() {
'use strict';

const app = angular.module('dataiku.flow.tools');


app.service('CopyFlowTool', function($rootScope, $stateParams,
    DataikuAPI, ContextualMenu, LoggerProvider,
    FlowToolsUtils, FlowViewsUtils, FlowGraph) {

    const Logger = LoggerProvider.getLogger('flow.tools.copy');
    const NAME = 'COPY';
    const DISPLAY_NAME = 'Copy';

    this.getDefinition = function() {
        return {
            getName: () => NAME,
            getToolDisplayName: () => DISPLAY_NAME,

            initFlowTool: function(tool) {
                tool.user = {
                    updateOptions: {
                        recheckAll: false,
                        datasets: {
                            consistencyWithData: true
                        },
                        recipes: {
                            schemaConsistency: true,
                            otherExpensiveChecks: true
                        }
                    },
                    updateStatus: {
                        updating: false
                    }
                };

                /*
                * Since the items to copy is not he user selection (we force recipes outputs, etc)
                * we maintain a user selection and recompute the list to copy when updated
                * to be sure that the graph updates don't change the nodes objects, and break the lists lookups
                * we only keep ids there
                */

                function updateNodeStates() {
                    tool.user.state.stateByNode = {};
                    tool.user.state.countByState = {REQUESTED: 0, REQUIRED: 0, REUSED: 0}
                    const stateByNode = tool.user.state.stateByNode;

                    // select the requested items
                    $.each(FlowGraph.get().nodes, function(nodeId, node) {
                        if (tool.user.state.requested[nodeId]) {
                            if (node.projectKey === $stateParams.projectKey) {
                                stateByNode[nodeId] = 'REQUESTED';
                            } else {
                                stateByNode[nodeId] = 'REUSED'; //Can't deep copy a foreign dataset
                            }
                        }
                    });
                    // By default, don't copy the sources of the subflow, reuse them, copy only if forced
                    $.each(FlowGraph.get().nodes, function(nodeId, node) {
                        if (tool.user.state.requested[nodeId] === 'REQUESTED' && node.nodeType !== 'RECIPE') {
                            for (let p of node.predecessors) {
                                if (stateByNode[p]) {
                                    return; //A predecessor is requested => not a source for the subflow
                                }
                            }
                            let anyCopiedSuccessor = false;
                            for (let p of node.successors) {
                                if (stateByNode[p]) {
                                    anyCopiedSuccessor = true;
                                    break;
                                }
                            }
                            if (!anyCopiedSuccessor) {
                                return; //Isolated node, the user probably actually want to copy it
                            }
                            stateByNode[nodeId] = 'REUSED';
                        }
                    });
                    // select the non requested but required items
                    $.each(FlowGraph.get().nodes, function(nodeId, node) {
                        if (stateByNode[nodeId]) {
                            if (node.nodeType === 'RECIPE') {
                                $.each(node.successors, function(index, nodeId2) {
                                    if (!stateByNode[nodeId2]) {
                                        stateByNode[nodeId2] = 'REQUIRED';
                                    }
                                });
                            } else if (node.nodeType === 'LOCAL_SAVEDMODEL'){
                                $.each(node.predecessors, function(index, nodeId2) {
                                    if (!stateByNode[nodeId2]) {
                                        stateByNode[nodeId2] = 'REQUIRED';
                                    }
                                });
                            }
                        }
                    });
                    // select the non requested, non required but reused items
                    $.each(FlowGraph.get().nodes, function(nodeId, node) {
                        if (stateByNode[nodeId]) {
                            if (node.nodeType === 'RECIPE' ) {
                                $.each(node.predecessors, function(index, nodeId2) {
                                    if (!stateByNode[nodeId2]) {
                                        stateByNode[nodeId2] = 'REUSED';
                                    }
                                });
                            } else if (node.nodeType === 'LOCAL_SAVEDMODEL'){
                                $.each(node.predecessors, function (index, nodeId2) {
                                    //reuse train recipe sources
                                    $.each(FlowGraph.get().nodes[nodeId2].predecessors, function (datasetIndex, datasetId) {
                                        if (!stateByNode[datasetId]) {
                                            stateByNode[datasetId] = 'REUSED';
                                        }
                                    });
                                });
                            }
                        }
                    });

                    $.each(FlowGraph.get().nodes, function(nodeId, node) {
                        const nodeState = stateByNode[nodeId];
                        if (nodeState) {
                            tool.user.state.countByState[nodeState]++;
                        }
                    });
                }

                const COLORS = {
                    'REQUESTED': 'green',
                    'REQUIRED': '#41f544',
                    'REUSED': '#ffc500'
                };

                function colorNodes() {
                    $.each(FlowGraph.get().nodes, function(nodeId, node) {
                        const nodeElt = node.nodeType === 'ZONE' ? FlowGraph.d3ZoneNodeWithId(nodeId) : FlowGraph.d3NodeWithId(nodeId);
                        const nodeState = tool.user.state.stateByNode[nodeId];

                        //TODO @flow factorize cleanNode
                        nodeElt.classed('focus', false).classed('out-of-focus', false);
                        $('.tool-simple-zone', FlowGraph.getSvg()).empty();
                        $('.node-totem span', nodeElt[0]).removeAttr('style').removeClass();
                        $('.never-built-computable *', nodeElt[0]).removeAttr('style');

                        const color = COLORS[nodeState] || '#e2e2e2';
                        FlowToolsUtils.colorNode(node, nodeElt, color);

                    });
                }

                tool.drawHooks.updateFlowToolDisplay = function() {
                    if (!tool.user.state) return; // protect against slow state fetching
                    if (!FlowGraph.ready()) return; // protect against slow graph fetching

                    updateNodeStates();
                    colorNodes();
                }

                DataikuAPI.flow.tools.getState($stateParams.projectKey, NAME, {}).success(function(data) {
                    tool.user.state = data;
                    tool.user.state.requested = tool.user.state.requested || [];

                    if (tool.user.state.preselectedNodes) {
                        tool.user.state.preselectedNodes.forEach(function(nodeId) {
                            tool.user.state.requested[nodeId] = 'REQUESTED';
                        });
                    }

                    tool.drawHooks.updateFlowToolDisplay();
                }).error(FlowGraph.setError());;
            },

            template: "/templates/flow-editor/tools/tool-copy.html"
        };
    };
});

app.controller("CopyToolController", function($scope, $stateParams, Assert, DataikuAPI, TaggableObjectsUtils, FlowGraphSelection, FlowGraph, FlowToolsUtils, SubFlowCopyService) {
    Assert.inScope($scope, 'tool');

    $scope.addSelected = function(forceAdd) {
        const statesBefore = angular.copy($scope.tool.user.state.stateByNode);
        const requested = $scope.tool.user.state.requested;
        FlowGraphSelection.getSelectedNodes().forEach(function(it) {
            if(requested[it.id] != 'FORCED') {
                requested[it.id] = forceAdd ? 'FORCED' : 'REQUESTED';
            }
        });
        $scope.tool.drawHooks.updateFlowToolDisplay();

        // This had no effect, try with force
        if (!forceAdd && angular.equals($scope.tool.user.state.stateByNode, statesBefore)) {
            $scope.addSelected(true);
        }
    };

    $scope.removeSelected = function() {
        const requested = $scope.tool.user.state.requested;
        FlowGraphSelection.getSelectedNodes().forEach(function(it) {
            delete requested[it.id];
        });
        $scope.tool.drawHooks.updateFlowToolDisplay();
    };

    $scope.reset = function() {
        $scope.tool.user.state.requested = [];
        $scope.tool.drawHooks.updateFlowToolDisplay();
    };

    function getSelectedTaggableObjectRefs() {
        const items = [];
        const itemsByZones = new Map();
        $.each(FlowGraph.get().nodes, function(nodeId, node) {
            if (nodeId.startsWith("zone__") && node.nodeType !== 'ZONE' && (!node.isSource || node.isSink)) {
                const zoneId = nodeId.substring("zone__".length, node.id.length - node.realId.length - 2);
                if (node.ownerZone === zoneId) {
                    if (!itemsByZones.has(zoneId)) {
                        itemsByZones.set(zoneId, []);
                    }
                    const zoneContent = itemsByZones.get(zoneId);
                    zoneContent.push(TaggableObjectsUtils.fromNode(node));
                }
            }
            if (['REQUESTED', 'REQUIRED'].includes($scope.tool.user.state.stateByNode[nodeId])) {
                items.push(TaggableObjectsUtils.fromNode(node));
            }
        });
        return {selectedTaggableObjectRefs: items, itemsByZones};
    }

    $scope.go = function() {
        const { selectedTaggableObjectRefs, itemsByZones } = getSelectedTaggableObjectRefs();
        SubFlowCopyService.start(selectedTaggableObjectRefs, itemsByZones);
    };
});

})();
(function() {
'use strict';

const app = angular.module('dataiku.flow.tools');


app.service('PropagateSchemaFlowTools', function($rootScope, $stateParams,
    DataikuAPI, ContextualMenu, Logger,
    FlowGraph, FlowViewsUtils, FlowToolsUtils, $q, ComputableSchemaRecipeSave) {

    const NAME = 'PROPAGATE_SCHEMA';

    this.getDefinition = function() {
        return {
            getName: () => NAME,
            getToolDisplayName: function(toolDef) {
                return "Check schema from " + toolDef.toolInitialData.datasetName;
            },

            initFlowTool: function(tool) {

                tool.user = {
                    updateStatus: {
                        updating: false
                    },
                    updateOptions: {
                        performExpensive: true,
                        doAnyRebuildingReqd: false,
                        doBuildAll: false,
                        recheckAll: false,
                        alwaysRebuildInputOfRecipesUsuallyComputingOutputSchemaBasedOnData: true,
                        alwaysRebuildOutputOfRecipesUsuallyComputingOutputSchemaAtRuntime: true
                    }
                };

                tool.user.canMarkRecipeAsOK = function(recipeName) {
                    let nodeId = graphVizEscape("recipe_" + recipeName);
                    if (tool.user.state &&  tool.user.state.stateByNode[nodeId]) {
                        return tool.user.state.stateByNode[nodeId].state != "OK";
                    } else {
                        return false;
                    }
                }

                tool.user.markRecipeAsOK = function(recipeName) {
                    DataikuAPI.flow.tools.propagateSchema.markRecipeAsOKForced($stateParams.projectKey, recipeName).success(function(data) {
                        tool.user.state = data;
                        tool.drawHooks.updateFlowToolDisplay();
                    })
                }

                tool.drawHooks.updateFlowToolDisplay = function() {
                    if (!tool.user.state) return; // protect against slow state fetching
                    if (!FlowGraph.ready()) return; // protect against slow graph fetching

                    let svg = FlowGraph.getSvg();
                    tool.user.state.itemsToRebuild = [];

                    $.each(FlowGraph.get().nodes, function(nodeId, node) {
                        const nodeElt = FlowGraph.d3NodeWithId(nodeId);
                        const nodeState = tool.user.state.stateByNode[node.realId];

                        //TODO @flow factorize cleanNode
                        nodeElt.classed('focus', false).classed('out-of-focus', false);
                        $('.tool-simple-zone', FlowGraph.getSvg()).empty();
                        $('.node-totem span', nodeElt[0]).removeAttr('style').removeClass();
                        $('.never-built-computable *', nodeElt[0]).removeAttr('style');

                        Logger.info("NodeState: ", nodeId, nodeState);
                        if (!nodeState) {
                            const color = "#E9E9E9";
                            // Node is not involved in this
                            FlowToolsUtils.colorNode(node, nodeElt, color);

                            svg.find('[data-to="' + nodeId + '"]').each(function () {
                                d3.select(this).classed('grey-out-path',true).selectAll("path, ellipse").classed('grey-out-path',true);
                            });
                            svg.find('[data-from="' + nodeId + '"]').each(function () {
                                d3.select(this).classed('grey-out-path',true).selectAll("path, ellipse").classed('grey-out-path',true);
                            });
                        } else if (nodeState.state == "DATASET_NEEDS_REBUILD") {
                            node.partitioning = nodeState.partitioning;
                            node.buildPartitions = nodeState.buildPartitions;
                            tool.user.state.itemsToRebuild.push({type: 'DATASET', node: node});
                            FlowToolsUtils.colorNode(node, nodeElt, "orange");
                        } else if (nodeState.state == "UNCHECKABLE") {
                            FlowToolsUtils.colorNode(node, nodeElt, "orange");
                        } else if (nodeState.state == "EXCLUDED") {
                            FlowToolsUtils.colorNode(node, nodeElt, "lightgrey");
                        } else if (nodeState.state == "UNCHECKED") {
                            FlowToolsUtils.colorNode(node, nodeElt, "grey");
                        } else if (nodeState.state == "OK") {
                            FlowToolsUtils.colorNode(node, nodeElt, "green");
                        } else if (nodeState.state == "NOK") {
                            FlowToolsUtils.colorNode(node, nodeElt, "red");
                         } else if (nodeState.state == "FAILED_CHECK") {
                            FlowToolsUtils.colorNode(node, nodeElt, "purple");
                        }
                    });
                }

                tool.user.ignoreAllSuggestionsWithState = function(parentScope, state) {
                    var promises = [];

                    $.each(FlowGraph.get().nodes, function(nodeId, node) {
                        const nodeElt = FlowGraph.d3NodeWithId(nodeId);
                        const nodeState = tool.user.state.stateByNode[node.realId];

                        if (nodeState && nodeState.state == state) {
                            Logger.info("Ignoring suggestion on node", nodeId);
                            const recipeName = node.name;

                            var deferred = $q.defer();
                            DataikuAPI.flow.tools.propagateSchema.markRecipeAsOKForced($stateParams.projectKey, recipeName).success(function(data) {
                                deferred.resolve();
                            }).error(FlowGraph.setError());
                            promises.push(deferred.promise);
                        }
                    });
                    Logger.info("Waiting on ", promises.length, "promises")
                    $q.all(promises).then(function() {
                        Logger.info("Done Waiting on ", promises.length, "promises");
                        parentScope.update();
                    });
                }

                tool.user.acceptAllRecipeSuggestions = function(parentScope){
                    var promises = [];

                    $.each(FlowGraph.get().nodes, function(nodeId, node) {
                        const nodeElt = FlowGraph.d3NodeWithId(nodeId);
                        const nodeState = tool.user.state.stateByNode[node.realId];

                        if (nodeState && nodeState.state == "NOK") {
                            Logger.info("Accepting suggestion on node", nodeId);
                            const recipeName = node.name;

                            var deferred = $q.defer();

                            ComputableSchemaRecipeSave.handleSchemaUpdateWithPrecomputedUnattended(parentScope,
                                nodeState.updateSolution).then(function() {
                                Logger.info("Acceptance done on ", recipeName)
                                DataikuAPI.flow.tools.propagateSchema.markRecipeAsOKAfterUpdate($stateParams.projectKey, recipeName).success(function(data) {
                                    Logger.info("recipe marked as done, resolving deferred")
                                    deferred.resolve();
                                }).error(FlowGraph.setError());
                            });
                            promises.push(deferred.promise);
                        }
                     });
                    Logger.info("Waiting on ", promises.length, "promises")
                    $q.all(promises).then(function() {
                        Logger.info("Done Waiting on ", promises.length, "promises")
                        parentScope.update();
                    });
                }

                tool.actionHooks.onItemClick = function(node, evt) {
                    if (!tool.user.state) return; // protect against slow state fetching
                    let nodeState = tool.user.state.stateByNode[node.realId];

                    Logger.info("onItemClick nodeState ", nodeState);

                    ContextualMenu.prototype.closeAny();

                    if (nodeState && ["NOK", "FAILED_CHECK", "UNCHECKABLE"].indexOf(nodeState.state) >=0) {
                        let menuScope = $rootScope.$new();
                        menuScope.nodeState = nodeState;
                        menuScope.node = node;

                        new ContextualMenu({
                            template: "/templates/flow-editor/tools/propagate-schema-item-popup.html",
                            scope: menuScope,
                            contextual: false,
                            controller: "FlowToolPropagateItemPopupController"
                        }).openAtEventLoc(evt);
                    } else if (nodeState && nodeState.state == "DATASET_NEEDS_REBUILD") {
                        let menuScope = $rootScope.$new();
                        menuScope.nodeState = nodeState;
                        menuScope.node = node;

                        new ContextualMenu({
                            template: "/templates/flow-editor/tools/propagate-dataset-needs-rebuild-popup.html",
                            scope: menuScope,
                            contextual: false,
                            controller: "FlowToolPropagateDatasetNeedsRebuildPopupController"
                        }).openAtEventLoc(evt);
                    }
                };

                FlowViewsUtils.addAsynchronousStateComputationBehavior(tool);

                DataikuAPI.flow.tools.getState($stateParams.projectKey, NAME, {}).success(function(data) {
                    tool.user.state = data;
                    tool.drawHooks.updateFlowToolDisplay();
                }).error(FlowGraph.setError());
            },

            template: "/templates/flow-editor/tools/tool-propagate-schema.html"
        };
    };
});


app.controller("PropagateSchemaFlowToolMainController", function($scope, $q, Logger, DataikuAPI, $timeout, $stateParams, ActivityIndicator, Assert,
                                                                 JobDefinitionComputer, ComputableSchemaRecipeSave, PartitionSelection, CreateModalFromTemplate, $filter, AnyLoc) {

    checkChangesBeforeLeaving($scope, function () {return $scope.tool.user.updateStatus.multiPhaseUpdating;}, "Schema propagation in progress.  Leaving will abort the operation");

    function getCountOfProblemItems() {
        let sum = $scope.tool.user.state.summary;
        return sum.NOK + sum.UNCHECKABLE + sum.UNCHECKED + sum.DATASET_NEEDS_REBUILD + sum.FAILED_CHECK;
    }

    function isAnyRebuildingReqd() {
        return $scope.tool.user.updateOptions.doAnyRebuildingReqd || $scope.tool.user.updateOptions.doBuildAll;
    }

    function getItemToRebuild (toDoList, doneList) {
        let item =  toDoList.find( (item) => {
            return !doneList.includes(item.node.id);
        });
        if (item) {doneList.push(item.node.id)}
        return item;
    }

    function showIndicator(txt, isSuccess) {
        Logger.info("Showing indicator text:", txt, "success:", isSuccess);
        $scope.updateText = txt;
        if (isSuccess) {$timeout(() => $scope.updateText = "", 4000);}
    }

    function markDatasetAsOK(datasetName) {
        return DataikuAPI.flow.tools.propagateSchema.markDatasetAsBeingRebuilt($stateParams.projectKey, datasetName);
    }

    /**
     * Rebuild a dataset, marking as OK when done.
     * Returns promise to wait on for completion
     */
    function buildDataset(node) {
        const deferred = $q.defer();

        let jd = JobDefinitionComputer.computeJobDefForSingleDataset($stateParams.projectKey, "RECURSIVE_BUILD", node, node.buildPartitions ? node.buildPartitions : {});
        if (!$scope.isAborting) {
            $scope.startedJob = {nodeType:'DATASET', nodeName: node.name, nodeId: node.id};
            DataikuAPI.flow.jobs.start(jd).then((data) => {
                $scope.startedJob.jobId = data.data.id;
                waitForEndOfStartedJob().then (() => {
                    showIndicator("Marking dataset as OK: " + $scope.startedJob.nodeName);
                    let stateInfo = $scope.tool.user.state.stateByNode[node.realId];
                    if (stateInfo && stateInfo.state==="OK") {
                        deferred.resolve();
                    }else {
                        markDatasetAsOK($scope.startedJob.nodeName).finally(() => {
                            deferred.resolve();
                        });
                    }
                }, deferred.reject);
            }, (data) => {
                setErrorInScope.bind($scope)(data.data, data.status, data.headers);
                deferred.reject();
            });
        }
        return deferred.promise;
    }

    function rebuildNextAsReqd() {
        Logger.info("Making next step of auto-progress");
        if ($scope.isAborting) {return false;}
        if ($scope.tool.user.state.summary.UNCHECKABLE > 0) {
            Logger.info("I have some uncheckables, marking them as OK");
            showIndicator("Marking all uncheckable as OK");
            $scope.tool.user.ignoreAllSuggestionsWithState($scope, "UNCHECKABLE");
            return true;
        }
        if ($scope.tool.user.state.summary.NOK > 0) {
            Logger.info("I have some NOK, accepting suggestions");
            showIndicator("Accepting all suggestings");
            $scope.tool.user.acceptAllRecipeSuggestions($scope);
            return true;
        }
        else {
            Logger.info("No NOK nor UNCHECKABLE, building items that need to be built");
            return startRebuildNextItem();
        }
    }

    function startRebuildNextItem() {
        if (!$scope.itemsRebuildAttempted) {$scope.itemsRebuildAttempted = [];}

        const item = getItemToRebuild($scope.tool.user.state.itemsToRebuild, $scope.itemsRebuildAttempted);
        if (!item) {
            return false;
        } else {
            Assert.trueish(item.type === 'DATASET'); // We don't rebuild other stuff at the moment
            showIndicator("Rebuilding dataset " + item.node.name);
            buildDataset(item.node).finally($scope.update);
            return true;
        }
    }

    function markRecipeAsOK(recipeName, nodeId) {
        const nodeState = $scope.tool.user.state.stateByNode[nodeId];

        if (nodeState) {
            Logger.info("Accepting node after update", nodeId);

            let deferred = $q.defer();
            if (nodeState.state == "OK") {
                deferred.resolve();
            } else {
                ComputableSchemaRecipeSave.handleSchemaUpdateWithPrecomputedUnattended($scope,
                    nodeState.updateSolution).then(function () {
                    Logger.info("Acceptance done on ", recipeName)
                    DataikuAPI.flow.tools.propagateSchema.markRecipeAsOKAfterUpdate($stateParams.projectKey, recipeName).success(function (data) {
                        Logger.info("recipe marked as done, resolving deferred")
                        deferred.resolve();
                    }).error(setErrorInScope.bind($scope));
                });
            }
            return deferred.promise;
        }
    }

    function waitForEndOfStartedJob() {
        const deferred = $q.defer();

        function poll() {
            DataikuAPI.flow.jobs.getJobStatus($stateParams.projectKey, $scope.startedJob.jobId).then(function (data) {
                $scope.startedJob.jobStatus = data.data;
                let status = $scope.startedJob.jobStatus.baseStatus.state;

                if (status != "DONE" && status != "ABORTED" && status != "FAILED" && !$scope.isAborting) {
                    $scope.jobCheckTimer = $timeout(function () {
                        poll();
                    }, 2000);
                } else if (status == "DONE") {
                    deferred.resolve();
                } else {
                    deferred.reject();
                }
            }, setErrorInScope.bind($scope));
        }

        poll();
        return deferred.promise;
    }

    function getBuildAllJobDef() {
        var outputs = $scope.computables.filter(d => !d.removed).map(function(d) {
            const fullId = graphIdFor(d.type, AnyLoc.makeLoc(d.projectKey, d.id).fullId);
            const nodeFound = $scope.tool.user.state.stateByNode[fullId];
            if (d.type === 'DATASET') {
                return JobDefinitionComputer.computeOutputForDataset(d.serializedDataset, nodeFound ? nodeFound.buildPartitions : PartitionSelection.getBuildPartitions(d.serializedDataset.partitioning));
            } else if (d.type === 'MANAGED_FOLDER') {
                return JobDefinitionComputer.computeOutputForBox(d.box, nodeFound ? nodeFound.buildPartitions : PartitionSelection.getBuildPartitions(d.box.partitioning));
            } else {
                return { "targetDataset": d.id, "targetDatasetProjectKey": d.projectKey, "type": d.type };
            }
        });

        return {
            "type": "RECURSIVE_BUILD",
            "refreshHiveMetastore":true,
            "projectKey": $stateParams.projectKey,
            "outputs": outputs
        };
    }

    function startBuildAllJob(computables) {
        if ($scope.isAborting) {return;}

        $scope.computables = computables;
        showIndicator("Starting to build all...");
        DataikuAPI.flow.jobs.start(getBuildAllJobDef()).then((data) => {
            $scope.startedJob = {"jobId": data.data.id};
            showIndicator("Build all started...");
            waitForEndOfStartedJob().then (() => {
                    showIndicator("Build all completed", true);
                    $scope.tool.user.updateStatus.multiPhaseUpdating = false;
                }, () => {
                    showIndicator("Build all failed", true);
                    $scope.tool.user.updateStatus.multiPhaseUpdating = false;})
        }, setErrorInScope.bind($scope));
    }

    $scope.update = function(isStart) {
        const deferred = $q.defer();
        if (isStart) {
            $scope.isAborting = false;
            $scope.itemsRebuildAttempted = [];
            $scope.tool.user.updateOptions.recheckAll = (getCountOfProblemItems() == 0);
            $scope.tool.user.partitionedObjects = Object.values($scope.tool.user.state.stateByNode).filter(e => e.partitioning).map(e => Object.assign(e, {buildPartitions: [], name: AnyLoc.getLocFromSmart($stateParams.projectKey, e.fullId).localId }));
            if ($scope.tool.user.partitionedObjects && $scope.tool.user.partitionedObjects.length > 0 && $scope.tool.user.updateOptions.doAnyRebuildingReqd) {
                CreateModalFromTemplate("templates/flow-editor/tools/tool-propagate-schema-partitioning.html", $scope, null, function(newScope) {
                    newScope.computables = $scope.tool.user.partitionedObjects;
                    newScope.getIcon = computable => {
                        switch(computable.type) {
                            case 'DATASET':            return 'dataset ' + $filter('datasetTypeToIcon')(computable.subType);
                            case 'MANAGED_FOLDER':     return 'icon-folder-open';
                            case 'SAVED_MODEL':        return 'icon-machine_learning_regression';
                        }
                    };

                    newScope.continue = () => {
                        newScope.dismiss();
                        deferred.resolve();
                    }
                });
            } else {
                deferred.resolve();
            }
        } else {
            $scope.tool.user.updateOptions.recheckAll = false;
            deferred.resolve();
        }
        deferred.promise.finally(() => {
            if (!$scope.tool.user.updateStatus.multiPhaseUpdating) {
                $scope.tool.user.updateStatus.multiPhaseUpdating = isAnyRebuildingReqd();
                $scope.totalItemsToProcess = getCountOfProblemItems();
            }
            $scope.tool.user.updateStatus.totalPercent = 0;
            showIndicator("Propagating schema");
            $scope.tool.user.update($scope).then(() => {
                let multiPhase = false;
                for (const partitionedObject of $scope.tool.user.partitionedObjects) {
                    const escapedId = graphIdFor(partitionedObject.type, partitionedObject.fullId);
                    // Try with the index and fallback on slow search in case we missed a specific case for graphIds
                    let node = $scope.tool.user.state.stateByNode[escapedId];
                    if (node === undefined) {
                        node = Object.values($scope.tool.user.state.stateByNode).find(n => n.type === partitionedObject.type && n.fullId === partitionedObject.fullId)
                    }
                    if (node) {
                        node.buildPartitions = partitionedObject.buildPartitions;
                        node.partitioning = partitionedObject.partitioning;
                    }
                }
                $scope.tool.drawHooks.updateFlowToolDisplay()

                if ($scope.tool.user.updateOptions.recheckAll) {
                    $scope.totalItemsToProcess = getCountOfProblemItems();
                }

                if (isAnyRebuildingReqd()) {
                    multiPhase = rebuildNextAsReqd();
                }

                if (!multiPhase) {
                    if ($scope.tool.user.updateOptions.doBuildAll && !$scope.isAborting ) {
                        $scope.buildAll();
                        multiPhase = true;
                    }
                    else {
                        showIndicator($scope.isAborting ? "Schema propagation aborted ": "Schema propagation complete", true);
                    }
                }
                $scope.tool.user.updateStatus.multiPhaseUpdating = multiPhase;
            });

            $scope.tool.drawHooks.updateFlowToolDisplay();
        });
    };

    $scope.$watch('tool.user.updateOptions.doBuildAll', function (newVal) {
        let newRebuild = true;
        if (newVal) {
            $scope.prevRebuild = $scope.tool.user.updateOptions.doAnyRebuildingReqd;
        }
        else {
            newRebuild = $scope.prevRebuild;
        }
        $scope.tool.user.updateOptions.doAnyRebuildingReqd = newRebuild;
    });

    $scope.acceptAllRecipeSuggestions = function(){
         $scope.tool.user.acceptAllRecipeSuggestions($scope);
    };

    $scope.ignoreAllRecipeSuggestions = function(){
         $scope.tool.user.ignoreAllSuggestionsWithState($scope, "NOK");
    };

    $scope.markAllUncheckableAsOK = function(){
        $scope.tool.user.ignoreAllSuggestionsWithState($scope, "UNCHECKABLE");
    };

    $scope.getTotalPercent = function() {
        if ($scope.tool.user.updateStatus.multiPhaseUpdating) {
            let fixedItemsToDo = 1 + ($scope.tool.user.updateOptions.doBuildAll || 0); // '1 +' is allow us to show some progress from the start - gives positive feedback to user
            return 100 * (1+ $scope.totalItemsToProcess - getCountOfProblemItems()) / (fixedItemsToDo + Math.max($scope.totalItemsToProcess,1));
        }
        else {
            return $scope.tool.user.updateStatus.totalPercent;
        }
    };

    $scope.abortUpdate = function () {
        $scope.isAborting = true;
        if ($scope.startedJob && $scope.startedJob.jobId) {
            DataikuAPI.flow.jobs.abort($stateParams.projectKey, $scope.startedJob.jobId).error(setErrorInScope.bind($scope));
        }
        $scope.tool.user.updateStatus.multiPhaseUpdating = false;
        $scope.tool.user.updateStatus.updating = false;
        ActivityIndicator.hide();
    };

    $scope.buildAll = function () {
        DataikuAPI.flow.listDownstreamComputables($stateParams.projectKey, {computable: $scope.tool.currentSession.toolInitialData.datasetName})
            .success((computables) => {
                startBuildAllJob(computables);
            })
            .error(setErrorInScope.bind($scope));
    };
});

app.controller("FlowToolPropagateItemPopupController", function($scope, $controller, Assert, DataikuAPI, $stateParams, ComputableSchemaRecipeSave) {
    $controller('StandardFlowViewsMainController', {$scope: $scope});

    Assert.inScope($scope, 'tool');
    let recipeName = $scope.node.name;

    $scope.reviewSuggestion = function() {
        ComputableSchemaRecipeSave.handleSchemaUpdateWithPrecomputed($scope,
            $scope.nodeState.updateSolution).then(function() {
                DataikuAPI.flow.tools.propagateSchema.markRecipeAsOKAfterUpdate($stateParams.projectKey, recipeName).success(function(data) {
                    $scope.tool.user.state = data;
                    $scope.tool.drawHooks.updateFlowToolDisplay();
                })
            });
    }

    $scope.ignoreSuggestion = function() {
        let recipeName = $scope.node.name;

        DataikuAPI.flow.tools.propagateSchema.markRecipeAsOKForced($stateParams.projectKey, recipeName).success(function(data) {
            $scope.tool.user.state = data;
            $scope.tool.drawHooks.updateFlowToolDisplay();
        })
    }
});


app.controller("FlowToolPropagateDatasetNeedsRebuildPopupController", function($scope, $controller, Assert, DataikuAPI, $stateParams, ActivityIndicator, CreateModalFromTemplate) {
    $controller('StandardFlowViewsMainController', {$scope: $scope});
    Assert.inScope($scope, 'tool');
    let datasetName = $scope.node.name;

    $scope.build = function() {
        DataikuAPI.datasets.get($stateParams.projectKey, datasetName, $stateParams.projectKey).success(function(dataset) {
            CreateModalFromTemplate("/templates/datasets/build-dataset-modal.html", $scope, "BuildDatasetController", function(modalScope) {
                modalScope.dataset = dataset;
                modalScope.computeMode = "RECURSIVE_BUILD";
            }, "build-dataset-modal");

            $scope.$on("datasetBuildStarted", function() {
                ActivityIndicator.success("Dataset build started ... Please wait for end before continuing propagation");
            });

            DataikuAPI.flow.tools.propagateSchema.markDatasetAsBeingRebuilt($stateParams.projectKey, datasetName).success(function(data) {
                $scope.tool.user.state = data;
                $scope.tool.drawHooks.updateFlowToolDisplay();
            });
        });
    };

    $scope.ignoreSuggestion = function() {
        DataikuAPI.flow.tools.propagateSchema.markDatasetAsBeingRebuilt($stateParams.projectKey, datasetName).success(function(data) {
            $scope.tool.user.state = data;
            $scope.tool.drawHooks.updateFlowToolDisplay();
        })
    };
});


})();
(function() {
'use strict';

const app = angular.module('dataiku.flow.tools');


app.service('CheckConsistencyFlowTool', function($rootScope, $stateParams,
    DataikuAPI, ContextualMenu, LoggerProvider,
    FlowToolsUtils, FlowViewsUtils, FlowGraph) {

    const Logger = LoggerProvider.getLogger('flow.tools');
    const NAME = 'CHECK_CONSISTENCY';
    const DISPLAY_NAME = 'Check consistency';

    this.getDefinition = function() {
        return {
            getName: () => NAME,
            getToolDisplayName: () => DISPLAY_NAME,

            initFlowTool: function(tool) {
                tool.user = {
                    updateOptions: {
                        recheckAll: false,
                        datasets: {
                            consistencyWithData: true
                        },
                        recipes: {
                            schemaConsistency: true,
                            otherExpensiveChecks: true
                        }
                    },
                    updateStatus: {
                        updating: false
                    }
                };

                tool.user.markAsOK = function(nodes) {
                    const nodeIds = nodes.map(n => n.realId);
                    DataikuAPI.flow.tools.checkConsistency.markAsOK($stateParams.projectKey, nodeIds).success(function(data) {
                        tool.user.state = data;
                        tool.drawHooks.updateFlowToolDisplay();
                    })
                };

                tool.user.recheck = function(nodes) {
                    const nodeIds = nodes.map(n => n.realId);
                    DataikuAPI.flow.tools.checkConsistency.recheck($stateParams.projectKey, nodeIds).success(function(data) {
                        tool.user.state = data;
                        tool.drawHooks.updateFlowToolDisplay();
                    })
                };

                tool.user.canRecheck = function(nodes) {
                    if (tool.user.state == null) return false; // protect against slow state fetching
                    return !!nodes.filter(n => tool.user.state.stateByNode[n.realId] != 'UNCHECKED').length;
                };


                function colorFromMessageHolder(holder, node, sel) {
                    if (holder.maxSeverity == "ERROR") {
                        FlowToolsUtils.colorNode(node, sel, "red");
                    } else if (holder.maxSeverity == "WARNING") {
                        FlowToolsUtils.colorNode(node, sel, "orange");
                    } else if (holder.maxSeverity == "INFO") {
                        FlowToolsUtils.colorNode(node, sel, "lightblue");
                    } else {
                        FlowToolsUtils.colorNode(node, sel, "green");
                    }
                }

                function needsPopup(nodeState) {
                    if (nodeState.state == "FAILED_CHECK") return true;
                    if (nodeState.state == "CHECKED") {
                        if (nodeState.recipeCheckResult && nodeState.recipeCheckResult.maxSeverity) return true;
                        if (nodeState.datasetCheckResult && nodeState.datasetCheckResult.maxSeverity) return true;
                    }
                    return false;
                }

                tool.drawHooks.updateFlowToolDisplay = function() {
                    if (!tool.user.state) return; // protect against slow state fetching
                    if (!FlowGraph.ready()) return; // protect against slow graph fetching

                    $.each(FlowGraph.get().nodes, function(nodeId, node) {
                        const nodeElt = FlowGraph.d3NodeWithId(nodeId);
                        const nodeState = tool.user.state.stateByNode[node.realId];

                        //TODO @flow factorize cleanNode
                        nodeElt.classed('focus', false).classed('out-of-focus', false);
                        $('.tool-simple-zone', FlowGraph.getSvg()).empty();
                        $('.node-totem span', nodeElt[0]).removeAttr('style').removeClass();
                        $('.never-built-computable *', nodeElt[0]).removeAttr('style');

                        if (!nodeState) {
                            // Node is not involved in this
                            FlowToolsUtils.colorNode(node, nodeElt, "#ccc");
                        } else if (nodeState.state == "UNCHECKED") {
                            FlowToolsUtils.colorNode(node, nodeElt, "#808080");
                        } else if (nodeState.state == "CHECKED") {
                            if (nodeState.recipeCheckResult) {
                                nodeState.errorHolder = nodeState.recipeCheckResult;

                                colorFromMessageHolder(nodeState.recipeCheckResult, node, nodeElt);
                            } else if (nodeState.datasetCheckResult) {
                                nodeState.errorHolder = nodeState.datasetCheckResult;
                                colorFromMessageHolder(nodeState.datasetCheckResult, node, nodeElt);
                            }
                        } else if (nodeState.state == "FAILED_CHECK") {
                            FlowToolsUtils.colorNode(node, nodeElt, "purple");
                        }
                    });
                }

                tool.actionHooks.onItemClick = function(node, evt) {
                    if (!tool.user.state) return; // protect against slow state fetching
                    let nodeState = tool.user.state.stateByNode[node.realId];

                    ContextualMenu.prototype.closeAny();

                    if (nodeState && needsPopup(nodeState)) {
                        let menuScope = $rootScope.$new();

                        menuScope.nodeState = nodeState;
                        menuScope.node = node;
                        menuScope.tool = tool;

                        let menuParams = {
                            template: "/templates/flow-editor/tools/consistency-item-popup.html",
                            scope: menuScope,
                            contextual: false
                        };
                        let menu = new ContextualMenu(menuParams);
                        menu.openAtEventLoc(evt);
                    }
                }

                FlowViewsUtils.addAsynchronousStateComputationBehavior(tool);

                DataikuAPI.flow.tools.getState($stateParams.projectKey, NAME, {}).success(function(data) {
                    tool.user.state = data;
                    tool.drawHooks.updateFlowToolDisplay();
                }).error(FlowGraph.setError());
            },

            template: "/templates/flow-editor/tools/tool-check-consistency.html"
        };
    };
});


app.controller("ConsistencyFlowToolMainController", function($scope, Assert, DataikuAPI, $stateParams) {
    Assert.inScope($scope, 'tool');
    $scope.update = $scope.tool.user.update;
});


})();
var FlowFilterParser=function(t){var e={};function r(n){if(e[n])return e[n].exports;var i=e[n]={i:n,l:!1,exports:{}};return t[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=t,r.c=e,r.d=function(t,e,n){r.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:n})},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=112)}([function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0}),e.NotNull=function(t,e,r){},e.Nullable=function(t,e,r){},e.Override=function(t,e,r){},e.SuppressWarnings=function(t){return(t,e,r)=>{}}},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0}),function(t){const e=0;function r(t=e){return t}function n(t,e){null==e?e=0:"string"==typeof e?e=function(t){let e=t.length;if(0===e)return 0;let r=0;for(let n=0;n<e;n++){let e=t.charCodeAt(n);r=(r<<5>>>0)-r+e,r|=0}return r}(e):"object"==typeof e&&(e=e.hashCode());let r=e;return r=(r=Math.imul(r,3432918353))<<15|r>>>17,t=(t^=r=Math.imul(r,461845907))<<13|t>>>19,4294967295&(t=Math.imul(t,5)+3864292196)}function i(t,e){return t^=4*e,t^=t>>>16,t=Math.imul(t,2246822507),t^=t>>>13,t=Math.imul(t,3266489909),t^=t>>>16}t.initialize=r,t.update=n,t.finish=i,t.hashCode=function(t,o=e){let s=r(o),l=0;for(let e of t)s=n(s,e),l++;return s=i(s,l)}}(e.MurmurHash||(e.MurmurHash={}))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0});const n=r(22);!function(t){t.INVALID_TYPE=0,t.EPSILON=-2,t.MIN_USER_TOKEN_TYPE=1,t.EOF=n.IntStream.EOF,t.DEFAULT_CHANNEL=0,t.HIDDEN_CHANNEL=1,t.MIN_USER_CHANNEL_VALUE=2}(e.Token||(e.Token={}))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(0),o=1e3;class s{constructor(t,e){this.a=t,this.b=e}static get INVALID(){return s._INVALID}static of(t,e){return t!==e||t<0||t>o?new s(t,e):(null==s.cache[t]&&(s.cache[t]=new s(t,t)),s.cache[t])}get length(){return this.b<this.a?0:this.b-this.a+1}equals(t){if(t===this)return!0;if(!(t instanceof s))return!1;let e=t;return this.a===e.a&&this.b===e.b}hashCode(){let t=23;return t=31*(t=31*t+this.a)+this.b}startsBeforeDisjoint(t){return this.a<t.a&&this.b<t.a}startsBeforeNonDisjoint(t){return this.a<=t.a&&this.b>=t.a}startsAfter(t){return this.a>t.a}startsAfterDisjoint(t){return this.a>t.b}startsAfterNonDisjoint(t){return this.a>t.a&&this.a<=t.b}disjoint(t){return this.startsBeforeDisjoint(t)||this.startsAfterDisjoint(t)}adjacent(t){return this.a===t.b+1||this.b===t.a-1}properlyContains(t){return t.a>=this.a&&t.b<=this.b}union(t){return s.of(Math.min(this.a,t.a),Math.max(this.b,t.b))}intersection(t){return s.of(Math.max(this.a,t.a),Math.min(this.b,t.b))}differenceNotProperlyContained(t){let e;return t.startsBeforeNonDisjoint(this)?e=s.of(Math.max(this.a,t.b+1),this.b):t.startsAfterNonDisjoint(this)&&(e=s.of(this.a,t.a-1)),e}toString(){return this.a+".."+this.b}}s._INVALID=new s(-1,-2),s.cache=new Array(o+1),n([i.Override],s.prototype,"equals",null),n([i.Override],s.prototype,"hashCode",null),n([i.Override],s.prototype,"toString",null),e.Interval=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(20),s=r(10),l=r(37),a=r(1),u=r(0),c=r(40),h=r(5),p=1;class d{constructor(t){this.cachedHashCode=t}static calculateEmptyHashCode(){let t=a.MurmurHash.initialize(p);return t=a.MurmurHash.finish(t,0)}static calculateSingleHashCode(t,e){let r=a.MurmurHash.initialize(p);return r=a.MurmurHash.update(r,t),r=a.MurmurHash.update(r,e),r=a.MurmurHash.finish(r,2)}static calculateHashCode(t,e){let r=a.MurmurHash.initialize(p);for(let e of t)r=a.MurmurHash.update(r,e);for(let t of e)r=a.MurmurHash.update(r,t);return r=a.MurmurHash.finish(r,2*t.length)}static fromRuleContext(t,e,r=!0){if(e.isEmpty)return r?d.EMPTY_FULL:d.EMPTY_LOCAL;let n;n=e._parent?d.fromRuleContext(t,e._parent,r):r?d.EMPTY_FULL:d.EMPTY_LOCAL;let i=t.states[e.invokingState].transition(0);return n.getChild(i.followState.stateNumber)}static addEmptyContext(t){return t.addEmptyContext()}static removeEmptyContext(t){return t.removeEmptyContext()}static join(t,e,r=c.PredictionContextCache.UNCACHED){if(t==e)return t;if(t.isEmpty)return d.isEmptyLocal(t)?t:d.addEmptyContext(e);if(e.isEmpty)return d.isEmptyLocal(e)?e:d.addEmptyContext(t);let n=t.size,i=e.size;if(1===n&&1===i&&t.getReturnState(0)===e.getReturnState(0)){let n=r.join(t.getParent(0),e.getParent(0));return n===t.getParent(0)?t:n===e.getParent(0)?e:n.getChild(t.getReturnState(0))}let o=0,s=new Array(n+i),l=new Array(s.length),a=0,u=0,p=!0,f=!0;for(;a<n&&u<i;)t.getReturnState(a)===e.getReturnState(u)?(s[o]=r.join(t.getParent(a),e.getParent(u)),l[o]=t.getReturnState(a),p=p&&s[o]===t.getParent(a),f=f&&s[o]===e.getParent(u),a++,u++):t.getReturnState(a)<e.getReturnState(u)?(s[o]=t.getParent(a),l[o]=t.getReturnState(a),f=!1,a++):(h(e.getReturnState(u)<t.getReturnState(a)),s[o]=e.getParent(u),l[o]=e.getReturnState(u),p=!1,u++),o++;for(;a<n;)s[o]=t.getParent(a),l[o]=t.getReturnState(a),a++,f=!1,o++;for(;u<i;)s[o]=e.getParent(u),l[o]=e.getReturnState(u),u++,p=!1,o++;return p?t:f?e:(o<s.length&&(s=s.slice(0,o),l=l.slice(0,o)),0===s.length?d.EMPTY_FULL:1===s.length?new y(s[0],l[0]):new g(s,l))}static isEmptyLocal(t){return t===d.EMPTY_LOCAL}static getCachedContext(t,e,r){if(t.isEmpty)return t;let n=r.get(t);if(n)return n;if(n=e.get(t))return r.put(t,n),n;let i,o=!1,s=new Array(t.size);for(let n=0;n<s.length;n++){let i=d.getCachedContext(t.getParent(n),e,r);if(o||i!==t.getParent(n)){if(!o){s=new Array(t.size);for(let e=0;e<t.size;e++)s[e]=t.getParent(e);o=!0}s[n]=i}}if(!o)return n=e.putIfAbsent(t,t),r.put(t,null!=n?n:t),t;if(1===s.length)i=new y(s[0],t.getReturnState(0));else{let e=new Array(t.size);for(let r=0;r<t.size;r++)e[r]=t.getReturnState(r);i=new g(s,e,t.hashCode())}return n=e.putIfAbsent(i,i),r.put(i,n||i),r.put(t,n||i),i}appendSingleContext(t,e){return this.appendContext(d.EMPTY_FULL.getChild(t),e)}getChild(t){return new y(this,t)}hashCode(){return this.cachedHashCode}toStrings(t,e,r=d.EMPTY_FULL){let n=[];t:for(let i=0;;i++){let o=0,s=!0,l=this,a=e,u="";for(u+="[";!l.isEmpty&&l!==r;){let e=0;if(l.size>0){let t=1;for(;1<<t>>>0<l.size;)t++;if(e=i>>o&(1<<t>>>0)-1,s=s&&e>=l.size-1,e>=l.size)continue t;o+=t}if(t){u.length>1&&(u+=" ");let e=t.atn.states[a];u+=t.ruleNames[e.ruleIndex]}else l.getReturnState(e)!==d.EMPTY_FULL_STATE_KEY&&(l.isEmpty||(u.length>1&&(u+=" "),u+=l.getReturnState(e)));a=l.getReturnState(e),l=l.getParent(e)}if(u+="]",n.push(u),s)break}return n}}n([u.Override],d.prototype,"hashCode",null),n([i(0,u.NotNull),i(1,u.NotNull),i(2,u.NotNull)],d,"join",null),n([i(0,u.NotNull),i(1,u.NotNull),i(2,u.NotNull)],d,"getCachedContext",null),e.PredictionContext=d;class f extends d{constructor(t){super(d.calculateEmptyHashCode()),this.fullContext=t}get isFullContext(){return this.fullContext}addEmptyContext(){return this}removeEmptyContext(){throw new Error("Cannot remove the empty context from itself.")}getParent(t){throw new Error("index out of bounds")}getReturnState(t){throw new Error("index out of bounds")}findReturnState(t){return-1}get size(){return 0}appendSingleContext(t,e){return e.getChild(this,t)}appendContext(t,e){return t}get isEmpty(){return!0}get hasEmpty(){return!0}equals(t){return this===t}toStrings(t,e,r){return["[]"]}}n([u.Override],f.prototype,"addEmptyContext",null),n([u.Override],f.prototype,"removeEmptyContext",null),n([u.Override],f.prototype,"getParent",null),n([u.Override],f.prototype,"getReturnState",null),n([u.Override],f.prototype,"findReturnState",null),n([u.Override],f.prototype,"size",null),n([u.Override],f.prototype,"appendSingleContext",null),n([u.Override],f.prototype,"appendContext",null),n([u.Override],f.prototype,"isEmpty",null),n([u.Override],f.prototype,"hasEmpty",null),n([u.Override],f.prototype,"equals",null),n([u.Override],f.prototype,"toStrings",null);let g=class t extends d{constructor(t,e,r){super(r||d.calculateHashCode(t,e)),h(t.length===e.length),h(e.length>1||e[0]!==d.EMPTY_FULL_STATE_KEY,"Should be using PredictionContext.EMPTY instead."),this.parents=t,this.returnStates=e}getParent(t){return this.parents[t]}getReturnState(t){return this.returnStates[t]}findReturnState(t){return l.Arrays.binarySearch(this.returnStates,t)}get size(){return this.returnStates.length}get isEmpty(){return!1}get hasEmpty(){return this.returnStates[this.returnStates.length-1]===d.EMPTY_FULL_STATE_KEY}addEmptyContext(){if(this.hasEmpty)return this;let e=this.parents.slice(0),r=this.returnStates.slice(0);return e.push(d.EMPTY_FULL),r.push(d.EMPTY_FULL_STATE_KEY),new t(e,r)}removeEmptyContext(){if(!this.hasEmpty)return this;if(2===this.returnStates.length)return new y(this.parents[0],this.returnStates[0]);{let e=this.parents.slice(0,this.parents.length-1),r=this.returnStates.slice(0,this.returnStates.length-1);return new t(e,r)}}appendContext(e,r){return t.appendContextImpl(this,e,new d.IdentityHashMap)}static appendContextImpl(e,r,n){if(r.isEmpty){if(d.isEmptyLocal(r)){if(e.hasEmpty)return d.EMPTY_LOCAL;throw new Error("what to do here?")}return e}if(1!==r.size)throw new Error("Appending a tree suffix is not yet supported.");let i=n.get(e);if(!i){if(e.isEmpty)i=r;else{let o=e.size;e.hasEmpty&&o--;let s=new Array(o),l=new Array(o);for(let t=0;t<o;t++)l[t]=e.getReturnState(t);for(let i=0;i<o;i++)s[i]=t.appendContextImpl(e.getParent(i),r,n);1===s.length?i=new y(s[0],l[0]):(h(s.length>1),i=new t(s,l)),e.hasEmpty&&(i=d.join(i,r))}n.put(e,i)}return i}equals(e){if(this===e)return!0;if(!(e instanceof t))return!1;if(this.hashCode()!==e.hashCode())return!1;let r=e;return this.equalsImpl(r,new s.Array2DHashSet)}equalsImpl(t,e){let r=[],n=[];for(r.push(this),n.push(t);;){let t=r.pop(),i=n.pop();if(!t||!i)break;let o=new c.PredictionContextCache.IdentityCommutativePredictionContextOperands(t,i);if(!e.add(o))continue;let s=o.x.size;if(0!==s){if(s!==o.y.size)return!1;for(let t=0;t<s;t++){if(o.x.getReturnState(t)!==o.y.getReturnState(t))return!1;let e=o.x.getParent(t),i=o.y.getParent(t);if(e.hashCode()!==i.hashCode())return!1;e!==i&&(r.push(e),n.push(i))}}else if(!o.x.equals(o.y))return!1}return!0}};n([u.NotNull],g.prototype,"parents",void 0),n([u.NotNull],g.prototype,"returnStates",void 0),n([u.Override],g.prototype,"getParent",null),n([u.Override],g.prototype,"getReturnState",null),n([u.Override],g.prototype,"findReturnState",null),n([u.Override],g.prototype,"size",null),n([u.Override],g.prototype,"isEmpty",null),n([u.Override],g.prototype,"hasEmpty",null),n([u.Override],g.prototype,"addEmptyContext",null),n([u.Override],g.prototype,"removeEmptyContext",null),n([u.Override],g.prototype,"appendContext",null),n([u.Override],g.prototype,"equals",null),g=n([i(0,u.NotNull)],g);let y=class t extends d{constructor(t,e){super(d.calculateSingleHashCode(t,e)),this.parent=t,this.returnState=e}getParent(t){return this.parent}getReturnState(t){return this.returnState}findReturnState(t){return this.returnState===t?0:-1}get size(){return 1}get isEmpty(){return!1}get hasEmpty(){return!1}appendContext(t,e){return e.getChild(this.parent.appendContext(t,e),this.returnState)}addEmptyContext(){let t=[this.parent,d.EMPTY_FULL],e=[this.returnState,d.EMPTY_FULL_STATE_KEY];return new g(t,e)}removeEmptyContext(){return this}equals(e){if(e===this)return!0;if(!(e instanceof t))return!1;let r=e;return this.hashCode()===r.hashCode()&&(this.returnState===r.returnState&&this.parent.equals(r.parent))}};n([u.NotNull],y.prototype,"parent",void 0),n([u.Override],y.prototype,"getParent",null),n([u.Override],y.prototype,"getReturnState",null),n([u.Override],y.prototype,"findReturnState",null),n([u.Override],y.prototype,"size",null),n([u.Override],y.prototype,"isEmpty",null),n([u.Override],y.prototype,"hasEmpty",null),n([u.Override],y.prototype,"appendContext",null),n([u.Override],y.prototype,"addEmptyContext",null),n([u.Override],y.prototype,"removeEmptyContext",null),n([u.Override],y.prototype,"equals",null),y=n([i(0,u.NotNull)],y),e.SingletonPredictionContext=y,function(t){t.EMPTY_LOCAL=new f(!1),t.EMPTY_FULL=new f(!0),t.EMPTY_LOCAL_STATE_KEY=-2147483648,t.EMPTY_FULL_STATE_KEY=2147483647;t.IdentityHashMap=class extends o.Array2DHashMap{constructor(){super(e.INSTANCE)}};class e{IdentityEqualityComparator(){}hashCode(t){return t.hashCode()}equals(t,e){return t===e}}e.INSTANCE=new e,n([u.Override],e.prototype,"hashCode",null),n([u.Override],e.prototype,"equals",null),t.IdentityEqualityComparator=e}(d=e.PredictionContext||(e.PredictionContext={}))},function(t,e,r){"use strict";(function(e){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function n(t,e){if(t===e)return 0;for(var r=t.length,n=e.length,i=0,o=Math.min(r,n);i<o;++i)if(t[i]!==e[i]){r=t[i],n=e[i];break}return r<n?-1:n<r?1:0}function i(t){return e.Buffer&&"function"==typeof e.Buffer.isBuffer?e.Buffer.isBuffer(t):!(null==t||!t._isBuffer)}var o=r(67),s=Object.prototype.hasOwnProperty,l=Array.prototype.slice,a="foo"===function(){}.name;function u(t){return Object.prototype.toString.call(t)}function c(t){return!i(t)&&("function"==typeof e.ArrayBuffer&&("function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(t):!!t&&(t instanceof DataView||!!(t.buffer&&t.buffer instanceof ArrayBuffer))))}var h=t.exports=_,p=/\s*function\s+([^\(\s]*)\s*/;function d(t){if(o.isFunction(t)){if(a)return t.name;var e=t.toString().match(p);return e&&e[1]}}function f(t,e){return"string"==typeof t?t.length<e?t:t.slice(0,e):t}function g(t){if(a||!o.isFunction(t))return o.inspect(t);var e=d(t);return"[Function"+(e?": "+e:"")+"]"}function y(t,e,r,n,i){throw new h.AssertionError({message:r,actual:t,expected:e,operator:n,stackStartFunction:i})}function _(t,e){t||y(t,!0,e,"==",h.ok)}function m(t,e,r,s){if(t===e)return!0;if(i(t)&&i(e))return 0===n(t,e);if(o.isDate(t)&&o.isDate(e))return t.getTime()===e.getTime();if(o.isRegExp(t)&&o.isRegExp(e))return t.source===e.source&&t.global===e.global&&t.multiline===e.multiline&&t.lastIndex===e.lastIndex&&t.ignoreCase===e.ignoreCase;if(null!==t&&"object"==typeof t||null!==e&&"object"==typeof e){if(c(t)&&c(e)&&u(t)===u(e)&&!(t instanceof Float32Array||t instanceof Float64Array))return 0===n(new Uint8Array(t.buffer),new Uint8Array(e.buffer));if(i(t)!==i(e))return!1;var a=(s=s||{actual:[],expected:[]}).actual.indexOf(t);return-1!==a&&a===s.expected.indexOf(e)||(s.actual.push(t),s.expected.push(e),function(t,e,r,n){if(null===t||void 0===t||null===e||void 0===e)return!1;if(o.isPrimitive(t)||o.isPrimitive(e))return t===e;if(r&&Object.getPrototypeOf(t)!==Object.getPrototypeOf(e))return!1;var i=T(t),s=T(e);if(i&&!s||!i&&s)return!1;if(i)return t=l.call(t),e=l.call(e),m(t,e,r);var a,u,c=E(t),h=E(e);if(c.length!==h.length)return!1;for(c.sort(),h.sort(),u=c.length-1;u>=0;u--)if(c[u]!==h[u])return!1;for(u=c.length-1;u>=0;u--)if(a=c[u],!m(t[a],e[a],r,n))return!1;return!0}(t,e,r,s))}return r?t===e:t==e}function T(t){return"[object Arguments]"==Object.prototype.toString.call(t)}function S(t,e){if(!t||!e)return!1;if("[object RegExp]"==Object.prototype.toString.call(e))return e.test(t);try{if(t instanceof e)return!0}catch(t){}return!Error.isPrototypeOf(e)&&!0===e.call({},t)}function x(t,e,r,n){var i;if("function"!=typeof e)throw new TypeError('"block" argument must be a function');"string"==typeof r&&(n=r,r=null),i=function(t){var e;try{t()}catch(t){e=t}return e}(e),n=(r&&r.name?" ("+r.name+").":".")+(n?" "+n:"."),t&&!i&&y(i,r,"Missing expected exception"+n);var s="string"==typeof n,l=!t&&o.isError(i),a=!t&&i&&!r;if((l&&s&&S(i,r)||a)&&y(i,r,"Got unwanted exception"+n),t&&i&&r&&!S(i,r)||!t&&i)throw i}h.AssertionError=function(t){var e;this.name="AssertionError",this.actual=t.actual,this.expected=t.expected,this.operator=t.operator,t.message?(this.message=t.message,this.generatedMessage=!1):(this.message=f(g((e=this).actual),128)+" "+e.operator+" "+f(g(e.expected),128),this.generatedMessage=!0);var r=t.stackStartFunction||y;if(Error.captureStackTrace)Error.captureStackTrace(this,r);else{var n=new Error;if(n.stack){var i=n.stack,o=d(r),s=i.indexOf("\n"+o);if(s>=0){var l=i.indexOf("\n",s+1);i=i.substring(l+1)}this.stack=i}}},o.inherits(h.AssertionError,Error),h.fail=y,h.ok=_,h.equal=function(t,e,r){t!=e&&y(t,e,r,"==",h.equal)},h.notEqual=function(t,e,r){t==e&&y(t,e,r,"!=",h.notEqual)},h.deepEqual=function(t,e,r){m(t,e,!1)||y(t,e,r,"deepEqual",h.deepEqual)},h.deepStrictEqual=function(t,e,r){m(t,e,!0)||y(t,e,r,"deepStrictEqual",h.deepStrictEqual)},h.notDeepEqual=function(t,e,r){m(t,e,!1)&&y(t,e,r,"notDeepEqual",h.notDeepEqual)},h.notDeepStrictEqual=function t(e,r,n){m(e,r,!0)&&y(e,r,n,"notDeepStrictEqual",t)},h.strictEqual=function(t,e,r){t!==e&&y(t,e,r,"===",h.strictEqual)},h.notStrictEqual=function(t,e,r){t===e&&y(t,e,r,"!==",h.notStrictEqual)},h.throws=function(t,e,r){x(!0,t,e,r)},h.doesNotThrow=function(t,e,r){x(!1,t,e,r)},h.ifError=function(t){if(t)throw t};var E=Object.keys||function(t){var e=[];for(var r in t)s.call(t,r)&&e.push(r);return e}}).call(e,r(66))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(0);class o{hashCode(t){return null==t?0:t.hashCode()}equals(t,e){return null==t?null==e:t.equals(e)}}o.INSTANCE=new o,n([i.Override],o.prototype,"hashCode",null),n([i.Override],o.prototype,"equals",null),e.ObjectEqualityComparator=o},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(20),s=r(69),l=r(14),a=r(55),u=r(72),c=r(0),h=r(6),p=r(4),d=r(2),f=r(5);let g=class{constructor(t,e){this.states=[],this.decisionToState=[],this.modeNameToStartState=new Map,this.modeToStartState=[],this.contextCache=new o.Array2DHashMap(h.ObjectEqualityComparator.INSTANCE),this.decisionToDFA=[],this.modeToDFA=[],this.LL1Table=new Map,this.grammarType=t,this.maxTokenType=e}clearDFA(){this.decisionToDFA=new Array(this.decisionToState.length);for(let t=0;t<this.decisionToDFA.length;t++)this.decisionToDFA[t]=new s.DFA(this.decisionToState[t],t);this.modeToDFA=new Array(this.modeToStartState.length);for(let t=0;t<this.modeToDFA.length;t++)this.modeToDFA[t]=new s.DFA(this.modeToStartState[t]);this.contextCache.clear(),this.LL1Table.clear()}get contextCacheSize(){return this.contextCache.size}getCachedContext(t){return p.PredictionContext.getCachedContext(t,this.contextCache,new p.PredictionContext.IdentityHashMap)}getDecisionToDFA(){return f(null!=this.decisionToDFA&&this.decisionToDFA.length===this.decisionToState.length),this.decisionToDFA}nextTokens(t,e){if(e){return new u.LL1Analyzer(this).LOOK(t,e)}return t.nextTokenWithinRule?t.nextTokenWithinRule:(t.nextTokenWithinRule=this.nextTokens(t,p.PredictionContext.EMPTY_LOCAL),t.nextTokenWithinRule.setReadonly(!0),t.nextTokenWithinRule)}addState(t){t.atn=this,t.stateNumber=this.states.length,this.states.push(t)}removeState(t){let e=new a.InvalidState;e.atn=this,e.stateNumber=t.stateNumber,this.states[t.stateNumber]=e}defineMode(t,e){this.modeNameToStartState.set(t,e),this.modeToStartState.push(e),this.modeToDFA.push(new s.DFA(e)),this.defineDecisionState(e)}defineDecisionState(t){return this.decisionToState.push(t),t.decision=this.decisionToState.length-1,this.decisionToDFA.push(new s.DFA(t,t.decision)),t.decision}getDecisionState(t){if(this.decisionToState.length>0)return this.decisionToState[t]}get numberOfDecisions(){return this.decisionToState.length}getExpectedTokens(t,e){if(t<0||t>=this.states.length)throw new RangeError("Invalid state number.");let r=e,n=this.states[t],i=this.nextTokens(n);if(!i.contains(d.Token.EPSILON))return i;let o=new l.IntervalSet;for(o.addAll(i),o.remove(d.Token.EPSILON);null!=r&&r.invokingState>=0&&i.contains(d.Token.EPSILON);){let t=this.states[r.invokingState].transition(0);i=this.nextTokens(t.followState),o.addAll(i),o.remove(d.Token.EPSILON),r=r._parent}return i.contains(d.Token.EPSILON)&&o.add(d.Token.EOF),o}};n([c.NotNull],g.prototype,"states",void 0),n([c.NotNull],g.prototype,"decisionToState",void 0),n([c.NotNull],g.prototype,"modeNameToStartState",void 0),n([c.NotNull],g.prototype,"modeToStartState",void 0),n([c.NotNull],g.prototype,"decisionToDFA",void 0),n([c.NotNull],g.prototype,"modeToDFA",void 0),n([c.NotNull],g.prototype,"nextTokens",null),n([i(0,c.NotNull)],g.prototype,"removeState",null),n([i(0,c.NotNull),i(1,c.NotNull)],g.prototype,"defineMode",null),n([i(0,c.NotNull)],g.prototype,"defineDecisionState",null),n([c.NotNull],g.prototype,"getExpectedTokens",null),g=n([i(0,c.NotNull)],g),e.ATN=g,function(t){t.INVALID_ALT_NUMBER=0}(g=e.ATN||(e.ATN={})),e.ATN=g},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0}),e.escapeWhitespace=function(t,e){return e?t.replace(/ /,"·"):t.replace(/\t/,"\\t").replace(/\n/,"\\n").replace(/\r/,"\\r")},e.join=function(t,e){let r="",n=!0;for(let i of t)n?n=!1:r+=e,r+=i;return r},e.equals=function(t,e){return t===e||null!=t&&null!=e&&t.equals(e)},e.toMap=function(t){let e=new Map;for(let r=0;r<t.length;r++)e.set(t[r],r);return e},e.toCharArray=function(t){let e=new Uint16Array(t.length);for(let r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e}},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(0);let s=class{constructor(t){if(null==t)throw new Error("target cannot be null.");this.target=t}get isEpsilon(){return!1}get label(){}};s.serializationNames=["INVALID","EPSILON","RANGE","RULE","PREDICATE","ATOM","ACTION","SET","NOT_SET","WILDCARD","PRECEDENCE"],n([o.NotNull],s.prototype,"target",void 0),s=n([i(0,o.NotNull)],s),e.Transition=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(5),s=r(51),l=r(0),a=r(13),u=r(1),c=16,h=.75;class p{constructor(t,e=c){if(this.n=0,this.threshold=Math.floor(c*h),t instanceof p){this.comparator=t.comparator,this.buckets=t.buckets.slice(0);for(let t=0;t<this.buckets.length;t++){let e=this.buckets[t];e&&(this.buckets[t]=e.slice(0))}this.n=t.n,this.threshold=t.threshold}else this.comparator=t||s.DefaultEqualityComparator.INSTANCE,this.buckets=this.createBuckets(e)}getOrAdd(t){return this.n>this.threshold&&this.expand(),this.getOrAddImpl(t)}getOrAddImpl(t){let e=this.getBucket(t),r=this.buckets[e];if(!r)return r=[t],this.buckets[e]=r,this.n++,t;for(let e=0;e<r.length;e++){let n=r[e];if(this.comparator.equals(n,t))return n}return r.push(t),this.n++,t}get(t){if(null==t)return t;let e=this.getBucket(t),r=this.buckets[e];if(r)for(let e of r)if(this.comparator.equals(e,t))return e}getBucket(t){return this.comparator.hashCode(t)&this.buckets.length-1}hashCode(){let t=u.MurmurHash.initialize();for(let e of this.buckets)if(null!=e)for(let r of e){if(null==r)break;t=u.MurmurHash.update(t,this.comparator.hashCode(r))}return t=u.MurmurHash.finish(t,this.size)}equals(t){if(t===this)return!0;if(!(t instanceof p))return!1;if(t.size!==this.size)return!1;return this.containsAll(t)}expand(){let t=this.buckets,e=2*this.buckets.length,r=this.createBuckets(e);this.buckets=r,this.threshold=Math.floor(e*h);let n=this.size;for(let e of t)if(e)for(let t of e){let e=this.getBucket(t),r=this.buckets[e];r||(r=[],this.buckets[e]=r),r.push(t)}o(this.n===n)}add(t){return this.getOrAdd(t)===t}get size(){return this.n}get isEmpty(){return 0===this.n}contains(t){return this.containsFast(this.asElementType(t))}containsFast(t){return null!=t&&null!=this.get(t)}iterator(){return new d(this.toArray(),this)}toArray(t){(!t||t.length<this.size)&&(t=new Array(this.size));let e=0;for(let r of this.buckets)if(null!=r)for(let n of r){if(null==n)break;t[e++]=n}return t}remove(t){return this.removeFast(this.asElementType(t))}removeFast(t){if(null==t)return!1;let e=this.getBucket(t),r=this.buckets[e];if(!r)return!1;for(let e=0;e<r.length;e++){let n=r[e];if(this.comparator.equals(n,t))return r.copyWithin(e,e+1),r.length--,this.n--,!0}return!1}containsAll(t){if(t instanceof p){let e=t;for(let t of e.buckets)if(null!=t)for(let e of t){if(null==e)break;if(!this.containsFast(this.asElementType(e)))return!1}}else for(let e of a.asIterable(t))if(!this.containsFast(this.asElementType(e)))return!1;return!0}addAll(t){let e=!1;for(let r of a.asIterable(t)){this.getOrAdd(r)!==r&&(e=!0)}return e}retainAll(t){let e=0;for(let r of this.buckets){if(null==r)continue;let n,i;for(n=0,i=0;n<r.length&&null!=r[n];n++)t.contains(r[n])&&(n!==i&&(r[i]=r[n]),i++,e++);e+=i,r.length=i}let r=e!=this.n;return this.n=e,r}removeAll(t){let e=!1;for(let r of a.asIterable(t))this.removeFast(this.asElementType(r))&&(e=!0);return e}clear(){this.buckets=this.createBuckets(c),this.n=0,this.threshold=Math.floor(c*h)}toString(){if(0===this.size)return"{}";let t="{",e=!0;for(let r of this.buckets)if(null!=r)for(let n of r){if(null==n)break;e?e=!1:t+=", ",t+=n.toString()}return t+="}"}toTableString(){let t="";for(let e of this.buckets){if(null==e){t+="null\n";continue}t+="[";let r=!0;for(let n of e)r?r=!1:t+=" ",t+=null==n?"_":n.toString();t+="]\n"}return t}asElementType(t){return t}createBuckets(t){return new Array(t)}}n([l.NotNull],p.prototype,"comparator",void 0),n([l.Override],p.prototype,"hashCode",null),n([l.Override],p.prototype,"equals",null),n([l.Override],p.prototype,"add",null),n([l.Override],p.prototype,"size",null),n([l.Override],p.prototype,"isEmpty",null),n([l.Override],p.prototype,"contains",null),n([i(0,l.Nullable)],p.prototype,"containsFast",null),n([l.Override],p.prototype,"iterator",null),n([l.Override],p.prototype,"toArray",null),n([l.Override],p.prototype,"remove",null),n([i(0,l.Nullable)],p.prototype,"removeFast",null),n([l.Override],p.prototype,"containsAll",null),n([l.Override],p.prototype,"addAll",null),n([l.Override],p.prototype,"retainAll",null),n([l.Override],p.prototype,"removeAll",null),n([l.Override],p.prototype,"clear",null),n([l.Override],p.prototype,"toString",null),n([l.SuppressWarnings("unchecked")],p.prototype,"asElementType",null),n([l.SuppressWarnings("unchecked")],p.prototype,"createBuckets",null),e.Array2DHashSet=p;class d{constructor(t,e){this.data=t,this.set=e,this.nextIndex=0,this.removed=!0}hasNext(){return this.nextIndex<this.data.length}next(){if(this.nextIndex>=this.data.length)throw new RangeError("Attempted to iterate past end.");return this.removed=!1,this.data[this.nextIndex++]}remove(){if(this.removed)throw new Error("This entry has already been removed");this.set.remove(this.data[this.nextIndex-1]),this.removed=!0}}},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(0);class o{constructor(){this.stateNumber=o.INVALID_STATE_NUMBER,this.ruleIndex=0,this.epsilonOnlyTransitions=!1,this.transitions=[],this.optimizedTransitions=this.transitions}getStateNumber(){return this.stateNumber}get nonStopStateNumber(){return this.getStateNumber()}hashCode(){return this.stateNumber}equals(t){return t instanceof o&&this.stateNumber===t.stateNumber}get isNonGreedyExitState(){return!1}toString(){return String(this.stateNumber)}getTransitions(){return this.transitions.slice(0)}get numberOfTransitions(){return this.transitions.length}addTransition(t,e){if(0===this.transitions.length)this.epsilonOnlyTransitions=t.isEpsilon;else if(this.epsilonOnlyTransitions!==t.isEpsilon)throw this.epsilonOnlyTransitions=!1,new Error("ATN state "+this.stateNumber+" has both epsilon and non-epsilon transitions.");this.transitions.splice(void 0!==e?e:this.transitions.length,0,t)}transition(t){return this.transitions[t]}setTransition(t,e){this.transitions[t]=e}removeTransition(t){return this.transitions.splice(t,1)[0]}get onlyHasEpsilonTransitions(){return this.epsilonOnlyTransitions}setRuleIndex(t){this.ruleIndex=t}get isOptimized(){return this.optimizedTransitions!==this.transitions}get numberOfOptimizedTransitions(){return this.optimizedTransitions.length}getOptimizedTransition(t){return this.optimizedTransitions[t]}addOptimizedTransition(t){this.isOptimized||(this.optimizedTransitions=new Array),this.optimizedTransitions.push(t)}setOptimizedTransition(t,e){if(!this.isOptimized)throw new Error("This ATNState is not optimized.");this.optimizedTransitions[t]=e}removeOptimizedTransition(t){if(!this.isOptimized)throw new Error("This ATNState is not optimized.");this.optimizedTransitions.splice(t,1)}}o.serializationNames=["INVALID","BASIC","RULE_START","BLOCK_START","PLUS_BLOCK_START","STAR_BLOCK_START","TOKEN_START","RULE_STOP","BLOCK_END","STAR_LOOP_BACK","STAR_LOOP_ENTRY","PLUS_LOOP_BACK","LOOP_END"],n([i.Override],o.prototype,"hashCode",null),n([i.Override],o.prototype,"equals",null),n([i.Override],o.prototype,"toString",null),e.ATNState=o,function(t){t.INVALID_STATE_NUMBER=-1}(o=e.ATNState||(e.ATNState={}))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0});const n=r(67),i=r(1),o=new Uint16Array(0);function s(t){return t>>>4}function l(t){return 16*t}function a(t){let e=1;for(let r=0;r<16;r++){if(0!=(t&e))return r;e=e<<1>>>0}throw new RangeError("No specified bit found")}function u(t){let e=32768;for(let r=15;r>=0;r--){if(0!=(t&e))return r;e>>>=1}throw new RangeError("No specified bit found")}function c(t,e){return(t&=15)===(e&=15)?1<<t>>>0:65535>>>15-e^65535>>>16-t}const h=new Uint8Array(65536);for(let t=0;t<16;t++){const e=1<<t>>>0;let r=0;for(;r<h.length;){r+=e;for(let t=0;t<e;t++)h[r]++,r++}}class p{constructor(t){if(t)if("number"==typeof t){if(t<0)throw new RangeError("nbits cannot be negative");this.data=new Uint16Array(s(t-1)+1)}else if(t instanceof p)this.data=t.data.slice(0);else{let e=-1;for(let r of t)e<r&&(e=r);this.data=new Uint16Array(s(e-1)+1);for(let e of t)this.set(e)}else this.data=o}and(t){const e=this.data,r=t.data,n=Math.min(e.length,r.length);let i=-1;for(let t=0;t<n;t++)0!=(e[t]&=r[t])&&(i=t);-1===i&&(this.data=o),i<e.length-1&&(this.data=e.slice(0,i+1))}andNot(t){const e=this.data,r=t.data,n=Math.min(e.length,r.length);let i=-1;for(let t=0;t<n;t++)0!=(e[t]&=65535^r[t])&&(i=t);-1===i&&(this.data=o),i<e.length-1&&(this.data=e.slice(0,i+1))}cardinality(){if(this.isEmpty)return 0;const t=this.data,e=t.length;let r=0;for(let n=0;n<e;n++)r+=h[t[n]];return r}clear(t,e){null==t?this.data.fill(0):null==e?this.set(t,!1):this.set(t,e,!1)}flip(t,e){if(null==e&&(e=t),t<0||e<t)throw new RangeError;let r=s(t);const n=s(e);if(r===n)this.data[r]^=c(t,e);else{for(this.data[r++]^=c(t,15);r<n;)this.data[r++]^=65535;this.data[r++]^=c(0,e)}}get(t,e){if(void 0===e)return!!(this.data[s(t)]&c(t,t));{let r=new p(e+1);for(let n=t;n<=e;n++)r.set(n,this.get(n));return r}}intersects(t){let e=Math.min(this.length(),t.length());if(0===e)return!1;let r=s(e-1);for(let e=0;e<=r;e++)if(0!=(this.data[e]&t.data[e]))return!0;return!1}get isEmpty(){return 0===this.length()}length(){return this.data.length?this.previousSetBit(l(this.data.length)-1)+1:0}nextClearBit(t){if(t<0)throw new RangeError("fromIndex cannot be negative");const e=this.data,r=e.length;let n=s(t);if(n>r)return-1;let i=65535^c(t,15);if(65535==(e[n]|i)){for(n++,i=0;n<r&&65535===e[n];n++);if(n===r)return-1}return l(n)+a(65535^(e[n]|i))}nextSetBit(t){if(t<0)throw new RangeError("fromIndex cannot be negative");const e=this.data,r=e.length;let n=s(t);if(n>r)return-1;let i=c(t,15);if(0==(e[n]&i)){for(n++,i=65535;n<r&&0===e[n];n++);if(n>=r)return-1}return l(n)+a(e[n]&i)}or(t){const e=this.data,r=t.data,n=Math.min(e.length,r.length),i=Math.max(e.length,r.length),s=e.length===i?e:new Uint16Array(i);let l=-1;for(let t=0;t<n;t++)0!=(s[t]=e[t]|r[t])&&(l=t);const a=e.length>r.length?e:r;for(let t=n;t<i;t++)0!==(s[t]=a[t])&&(l=t);-1===l?this.data=o:s.length===l+1?this.data=s:this.data=s.slice(0,l)}previousClearBit(t){if(t<0)throw new RangeError("fromIndex cannot be negative");const e=this.data,r=e.length;let n=s(t);n>=r&&(n=r-1);let i=65535^c(0,t);if(65535==(e[n]|i)){for(i=0,n--;n>=0&&65535===e[n];n--);if(n<0)return-1}return l(n)+u(65535^(e[n]|i))}previousSetBit(t){if(t<0)throw new RangeError("fromIndex cannot be negative");const e=this.data,r=e.length;let n=s(t);n>=r&&(n=r-1);let i=c(0,t);if(0==(e[n]&i)){for(n--,i=65535;n>=0&&0===e[n];n--);if(n<0)return-1}return l(n)+u(e[n]&i)}set(t,e,r){if(void 0===e?(e=t,r=!0):"boolean"==typeof e&&(r=e,e=t),void 0===r&&(r=!0),t<0||t>e)throw new RangeError;let n=s(t),i=s(e);if(r&&i>=this.data.length){var o=new Uint16Array(i+1);this.data.forEach((t,e)=>o[e]=t),this.data=o}else if(!r){if(n>=this.data.length)return;i>=this.data.length&&(i=this.data.length-1,e=16*this.data.length-1)}if(n===i)this._setBits(n,r,c(t,e));else{for(this._setBits(n++,r,c(t,15));n<i;)this.data[n++]=r?65535:0;this._setBits(n,r,c(0,e))}}_setBits(t,e,r){e?this.data[t]|=r:this.data[t]&=65535^r}get size(){return 8*this.data.byteLength}hashCode(){return i.MurmurHash.hashCode(this.data,22)}equals(t){if(t===this)return!0;if(!(t instanceof p))return!1;const e=this.length();if(e!==t.length())return!1;if(0===e)return!0;let r=s(e-1);for(let e=0;e<=r;e++)if(this.data[e]!==t.data[e])return!1;return!0}toString(){let t="{",e=!0;for(let r=this.nextSetBit(0);r>=0;r=this.nextSetBit(r+1))e?e=!1:t+=", ",t+=r;return t+="}"}xor(t){const e=this.data,r=t.data,n=Math.min(e.length,r.length),i=Math.max(e.length,r.length),s=e.length===i?e:new Uint16Array(i);let l=-1;for(let t=0;t<n;t++)0!=(s[t]=e[t]^r[t])&&(l=t);const a=e.length>r.length?e:r;for(let t=n;t<i;t++)0!==(s[t]=a[t])&&(l=t);-1===l?this.data=o:s.length===l+1?this.data=s:this.data=s.slice(0,l+1)}clone(){return new p(this)}[Symbol.iterator](){return new d(this.data)}[n.inspect.custom](){return"BitSet "+this.toString()}}e.BitSet=p;class d{constructor(t){this.data=t,this.index=0,this.mask=65535}next(){for(;this.index<this.data.length;){const t=this.data[this.index]&this.mask;if(0!==t){const e=l(this.index)+a(t);return this.mask=c(e+1,15),{done:!1,value:e}}this.index++,this.mask=65535}return{done:!0,value:-1}}[Symbol.iterator](){return this}}},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0}),e.asIterable=function(t){return t[Symbol.iterator]?t:new n(t)};class n{constructor(t){this.collection=t}[Symbol.iterator](){return this._iterator=this.collection.iterator(),this}next(){return this._iterator.hasNext()?{done:!1,value:this._iterator.next()}:{done:!0,value:void 0}}}},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(26),s=r(36),l=r(3),a=r(19),u=r(1),c=r(0),h=r(2);class p{constructor(t){this.readonly=!1,this._intervals=null!=t?t.slice(0):[]}static get COMPLETE_CHAR_SET(){return void 0===p._COMPLETE_CHAR_SET&&(p._COMPLETE_CHAR_SET=p.of(a.Lexer.MIN_CHAR_VALUE,a.Lexer.MAX_CHAR_VALUE),p._COMPLETE_CHAR_SET.setReadonly(!0)),p._COMPLETE_CHAR_SET}static get EMPTY_SET(){return null==p._EMPTY_SET&&(p._EMPTY_SET=new p,p._EMPTY_SET.setReadonly(!0)),p._EMPTY_SET}static of(t,e=t){let r=new p;return r.add(t,e),r}clear(){if(this.readonly)throw new Error("can't alter readonly IntervalSet");this._intervals.length=0}add(t,e=t){this.addRange(l.Interval.of(t,e))}addRange(t){if(this.readonly)throw new Error("can't alter readonly IntervalSet");if(!(t.b<t.a)){for(let e=0;e<this._intervals.length;e++){let r=this._intervals[e];if(t.equals(r))return;if(t.adjacent(r)||!t.disjoint(r)){let n=t.union(r);for(this._intervals[e]=n;e<this._intervals.length-1;){e++;let t=this._intervals[e];if(!n.adjacent(t)&&n.disjoint(t))break;this._intervals.splice(e,1),e--,this._intervals[e]=n.union(t)}return}if(t.startsBeforeDisjoint(r))return void this._intervals.splice(e,0,t)}this._intervals.push(t)}}static or(t){let e=new p;for(let r of t)e.addAll(r);return e}addAll(t){if(null==t)return this;if(t instanceof p){let e=t,r=e._intervals.length;for(let t=0;t<r;t++){let r=e._intervals[t];this.add(r.a,r.b)}}else for(let e of t.toList())this.add(e);return this}complementRange(t,e){return this.complement(p.of(t,e))}complement(t){if(t.isNil)return p.EMPTY_SET;let e;return t instanceof p?e=t:(e=new p).addAll(t),e.subtract(this)}subtract(t){if(null==t||t.isNil)return new p(this._intervals);if(t instanceof p)return p.subtract(this,t);let e=new p;return e.addAll(t),p.subtract(this,e)}static subtract(t,e){if(t.isNil)return new p;let r=new p(t._intervals);if(e.isNil)return r;let n=0,i=0;for(;n<r._intervals.length&&i<e._intervals.length;){let t,o,s=r._intervals[n],a=e._intervals[i];if(a.b<s.a)i++;else if(a.a>s.b)n++;else if(a.a>s.a&&(t=new l.Interval(s.a,a.a-1)),a.b<s.b&&(o=new l.Interval(a.b+1,s.b)),t){if(o){r._intervals[n]=t,r._intervals.splice(n+1,0,o),n++,i++;continue}r._intervals[n]=t,n++}else o?(r._intervals[n]=o,i++):r._intervals.splice(n,1)}return r}or(t){let e=new p;return e.addAll(this),e.addAll(t),e}and(t){if(t.isNil)return new p;let e,r=this._intervals,n=t._intervals,i=r.length,o=n.length,s=0,l=0;for(;s<i&&l<o;){let t=r[s],i=n[l];t.startsBeforeDisjoint(i)?s++:i.startsBeforeDisjoint(t)?l++:t.properlyContains(i)?(e||(e=new p),e.addRange(t.intersection(i)),l++):i.properlyContains(t)?(e||(e=new p),e.addRange(t.intersection(i)),s++):t.disjoint(i)||(e||(e=new p),e.addRange(t.intersection(i)),t.startsAfterNonDisjoint(i)?l++:i.startsAfterNonDisjoint(t)&&s++)}return e||new p}contains(t){let e=this._intervals.length;for(let r=0;r<e;r++){let e=this._intervals[r],n=e.a,i=e.b;if(t<n)break;if(t>=n&&t<=i)return!0}return!1}get isNil(){return null==this._intervals||0===this._intervals.length}getSingleElement(){if(null!=this._intervals&&1===this._intervals.length){let t=this._intervals[0];if(t.a===t.b)return t.a}return h.Token.INVALID_TYPE}get maxElement(){if(this.isNil)return h.Token.INVALID_TYPE;return this._intervals[this._intervals.length-1].b}get minElement(){return this.isNil?h.Token.INVALID_TYPE:this._intervals[0].a}get intervals(){return this._intervals}hashCode(){let t=u.MurmurHash.initialize();for(let e of this._intervals)t=u.MurmurHash.update(t,e.a),t=u.MurmurHash.update(t,e.b);return t=u.MurmurHash.finish(t,2*this._intervals.length)}equals(t){return null!=t&&t instanceof p&&o.ArrayEqualityComparator.INSTANCE.equals(this._intervals,t._intervals)}toString(t=!1){let e="";if(null==this._intervals||0===this._intervals.length)return"{}";this.size>1&&(e+="{");let r=!0;for(let n of this._intervals){r?r=!1:e+=", ";let i=n.a,o=n.b;i===o?i==h.Token.EOF?e+="<EOF>":e+=t?"'"+String.fromCharCode(i)+"'":i:e+=t?"'"+String.fromCharCode(i)+"'..'"+String.fromCharCode(o)+"'":i+".."+o}return this.size>1&&(e+="}"),e}toStringVocabulary(t){if(null==this._intervals||0===this._intervals.length)return"{}";let e="";this.size>1&&(e+="{");let r=!0;for(let n of this._intervals){r?r=!1:e+=", ";let i=n.a,o=n.b;if(i===o)e+=this.elementName(t,i);else for(let r=i;r<=o;r++)r>i&&(e+=", "),e+=this.elementName(t,r)}return this.size>1&&(e+="}"),e}elementName(t,e){return e===h.Token.EOF?"<EOF>":e===h.Token.EPSILON?"<EPSILON>":t.getDisplayName(e)}get size(){let t=0,e=this._intervals.length;if(1==e){let t=this._intervals[0];return t.b-t.a+1}for(let r=0;r<e;r++){let e=this._intervals[r];t+=e.b-e.a+1}return t}toIntegerList(){let t=new s.IntegerList(this.size),e=this._intervals.length;for(let r=0;r<e;r++){let e=this._intervals[r],n=e.a,i=e.b;for(let e=n;e<=i;e++)t.add(e)}return t}toList(){let t=new Array,e=this._intervals.length;for(let r=0;r<e;r++){let e=this._intervals[r],n=e.a,i=e.b;for(let e=n;e<=i;e++)t.push(e)}return t}toSet(){let t=new Set;for(let e of this._intervals){let r=e.a,n=e.b;for(let e=r;e<=n;e++)t.add(e)}return t}toArray(){return this.toList()}remove(t){if(this.readonly)throw new Error("can't alter readonly IntervalSet");let e=this._intervals.length;for(let r=0;r<e;r++){let e=this._intervals[r],n=e.a,i=e.b;if(t<n)break;if(t===n&&t===i){this._intervals.splice(r,1);break}if(t===n){this._intervals[r]=l.Interval.of(e.a+1,e.b);break}if(t===i){this._intervals[r]=l.Interval.of(e.a,e.b-1);break}if(t>n&&t<i){let n=e.b;this._intervals[r]=l.Interval.of(e.a,t-1),this.add(t+1,n)}}}get isReadonly(){return this.readonly}setReadonly(t){if(this.readonly&&!t)throw new Error("can't alter readonly IntervalSet");this.readonly=t}}n([c.Override],p.prototype,"addAll",null),n([c.Override],p.prototype,"complement",null),n([c.Override],p.prototype,"subtract",null),n([c.Override],p.prototype,"or",null),n([c.Override],p.prototype,"and",null),n([c.Override],p.prototype,"contains",null),n([c.Override],p.prototype,"isNil",null),n([c.Override],p.prototype,"getSingleElement",null),n([c.Override],p.prototype,"hashCode",null),n([c.Override],p.prototype,"equals",null),n([i(0,c.NotNull)],p.prototype,"toStringVocabulary",null),n([c.NotNull,i(0,c.NotNull)],p.prototype,"elementName",null),n([c.Override],p.prototype,"size",null),n([c.Override],p.prototype,"toList",null),n([c.Override],p.prototype,"remove",null),n([c.NotNull],p,"of",null),n([c.NotNull],p,"subtract",null),e.IntervalSet=p},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0});const n=r(11);e.DecisionState=class extends n.ATNState{constructor(){super(...arguments),this.decision=-1,this.nonGreedy=!1,this.sll=!1}}},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(88),o=r(3),s=r(0),l=r(89),a=r(63);class u extends l.RuleContext{constructor(t,e){null==e?super():super(t,e)}static emptyContext(){return u.EMPTY}copyFrom(t){if(this._parent=t._parent,this.invokingState=t.invokingState,this._start=t._start,this._stop=t._stop,t.children){this.children=[];for(let e of t.children)e instanceof i.ErrorNode&&(this.children.push(e),e._parent=this)}}enterRule(t){}exitRule(t){}addChild(t){let e;return t instanceof a.TerminalNode||t instanceof l.RuleContext||((t=new a.TerminalNode(t))._parent=this,e=t),this.children?this.children.push(t):this.children=[t],e}removeLastChild(){this.children&&this.children.pop()}addErrorNode(t){let e=new i.ErrorNode(t);return this.addChild(e),e._parent=this,e}get parent(){let t=super.parent;if(void 0===t||t instanceof u)return t;throw new TypeError("Invalid parent type for ParserRuleContext")}getChild(t,e){if(!this.children||t<0||t>=this.children.length)throw new RangeError("index parameter must be between >= 0 and <= number of children.");if(null==e)return this.children[t];let r=this.tryGetChild(t,e);if(void 0===r)throw new Error("The specified node does not exist");return r}tryGetChild(t,e){if(!this.children||t<0||t>=this.children.length)return;let r=-1;for(let n of this.children)if(n instanceof e&&++r===t)return n}getToken(t,e){let r=this.tryGetToken(t,e);if(void 0===r)throw new Error("The specified token does not exist");return r}tryGetToken(t,e){if(!this.children||e<0||e>=this.children.length)return;let r=-1;for(let n of this.children)if(n instanceof a.TerminalNode){if(n.symbol.type===t&&++r===e)return n}}getTokens(t){let e=[];if(!this.children)return e;for(let r of this.children)if(r instanceof a.TerminalNode){r.symbol.type===t&&e.push(r)}return e}get ruleContext(){return this}getRuleContext(t,e){return this.getChild(t,e)}tryGetRuleContext(t,e){return this.tryGetChild(t,e)}getRuleContexts(t){let e=[];if(!this.children)return e;for(let r of this.children)r instanceof t&&e.push(r);return e}get childCount(){return this.children?this.children.length:0}get sourceInterval(){return this._start?!this._stop||this._stop.tokenIndex<this._start.tokenIndex?o.Interval.of(this._start.tokenIndex,this._start.tokenIndex-1):o.Interval.of(this._start.tokenIndex,this._stop.tokenIndex):o.Interval.INVALID}get start(){return this._start}get stop(){return this._stop}toInfoString(t){return"ParserRuleContext"+t.getRuleInvocationStack(this).reverse()+"{start="+this._start+", stop="+this._stop+"}"}}u.EMPTY=new u,n([s.Override],u.prototype,"parent",null),n([s.Override],u.prototype,"childCount",null),n([s.Override],u.prototype,"sourceInterval",null),e.ParserRuleContext=u},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0});e.RecognitionException=class extends Error{constructor(t,e,r,n){super(n),this._offendingState=-1,this._recognizer=t,this.input=e,this.ctx=r,t&&(this._offendingState=t.state)}get offendingState(){return this._offendingState}setOffendingState(t){this._offendingState=t}get expectedTokens(){if(this._recognizer)return this._recognizer.atn.getExpectedTokens(this._offendingState,this.ctx)}get context(){return this.ctx}get inputStream(){return this.input}getOffendingToken(t){if(!t||t===this._recognizer)return this.offendingToken}setOffendingToken(t,e){t===this._recognizer&&(this.offendingToken=e)}get recognizer(){return this._recognizer}}},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(10),s=r(26),l=r(1),a=r(0),u=r(6),c=r(8);class h{static get NONE(){return void 0===h._NONE&&(h._NONE=new h.Predicate),h._NONE}evalPrecedence(t,e){return this}static and(t,e){if(!t||t===h.NONE)return e;if(e===h.NONE)return t;let r=new h.AND(t,e);return 1===r.opnds.length?r.opnds[0]:r}static or(t,e){if(!t)return e;if(t===h.NONE||e===h.NONE)return h.NONE;let r=new h.OR(t,e);return 1===r.opnds.length?r.opnds[0]:r}}e.SemanticContext=h,function(t){function e(e){let r=[];for(let n=0;n<e.length;n++){let i=e[n];i instanceof t.PrecedencePredicate&&(r.push(i),e.splice(n,1),n--)}return r}class r extends t{constructor(t=-1,e=-1,r=!1){super(),this.ruleIndex=t,this.predIndex=e,this.isCtxDependent=r}eval(t,e){let r=this.isCtxDependent?e:void 0;return t.sempred(r,this.ruleIndex,this.predIndex)}hashCode(){let t=l.MurmurHash.initialize();return t=l.MurmurHash.update(t,this.ruleIndex),t=l.MurmurHash.update(t,this.predIndex),t=l.MurmurHash.update(t,this.isCtxDependent?1:0),t=l.MurmurHash.finish(t,3)}equals(t){return t instanceof r&&(this===t||this.ruleIndex===t.ruleIndex&&this.predIndex===t.predIndex&&this.isCtxDependent===t.isCtxDependent)}toString(){return"{"+this.ruleIndex+":"+this.predIndex+"}?"}}n([a.Override],r.prototype,"eval",null),n([a.Override],r.prototype,"hashCode",null),n([a.Override],r.prototype,"equals",null),n([a.Override],r.prototype,"toString",null),t.Predicate=r;class h extends t{constructor(t){super(),this.precedence=t}eval(t,e){return t.precpred(e,this.precedence)}evalPrecedence(e,r){return e.precpred(r,this.precedence)?t.NONE:void 0}compareTo(t){return this.precedence-t.precedence}hashCode(){let t=1;return t=31*t+this.precedence}equals(t){return t instanceof h&&(this===t||this.precedence===t.precedence)}toString(){return"{"+this.precedence+">=prec}?"}}n([a.Override],h.prototype,"eval",null),n([a.Override],h.prototype,"evalPrecedence",null),n([a.Override],h.prototype,"compareTo",null),n([a.Override],h.prototype,"hashCode",null),n([a.Override],h.prototype,"equals",null),n([a.Override],h.prototype,"toString",null),t.PrecedencePredicate=h;class p extends t{}t.Operator=p;let d=class r extends p{constructor(t,n){super();let i=new o.Array2DHashSet(u.ObjectEqualityComparator.INSTANCE);t instanceof r?i.addAll(t.opnds):i.add(t),n instanceof r?i.addAll(n.opnds):i.add(n),this.opnds=i.toArray();let s=function(t){let e;for(let r of t)void 0!==e?e.compareTo(r)>0&&(e=r):e=r;return e}(e(this.opnds));s&&this.opnds.push(s)}get operands(){return this.opnds}equals(t){return this===t||t instanceof r&&s.ArrayEqualityComparator.INSTANCE.equals(this.opnds,t.opnds)}hashCode(){return l.MurmurHash.hashCode(this.opnds,40363613)}eval(t,e){for(let r of this.opnds)if(!r.eval(t,e))return!1;return!0}evalPrecedence(e,r){let n=!1,i=[];for(let o of this.opnds){let s=o.evalPrecedence(e,r);if(n=n||s!==o,null==s)return;s!==t.NONE&&i.push(s)}if(!n)return this;if(0===i.length)return t.NONE;let o=i[0];for(let e=1;e<i.length;e++)o=t.and(o,i[e]);return o}toString(){return c.join(this.opnds,"&&")}};n([a.Override],d.prototype,"operands",null),n([a.Override],d.prototype,"equals",null),n([a.Override],d.prototype,"hashCode",null),n([a.Override],d.prototype,"eval",null),n([a.Override],d.prototype,"evalPrecedence",null),n([a.Override],d.prototype,"toString",null),d=n([i(0,a.NotNull),i(1,a.NotNull)],d),t.AND=d;let f=class r extends p{constructor(t,n){super();let i=new o.Array2DHashSet(u.ObjectEqualityComparator.INSTANCE);t instanceof r?i.addAll(t.opnds):i.add(t),n instanceof r?i.addAll(n.opnds):i.add(n),this.opnds=i.toArray();let s=function(t){let e;for(let r of t)void 0!==e?e.compareTo(r)<0&&(e=r):e=r;return e}(e(this.opnds));s&&this.opnds.push(s)}get operands(){return this.opnds}equals(t){return this===t||t instanceof r&&s.ArrayEqualityComparator.INSTANCE.equals(this.opnds,t.opnds)}hashCode(){return l.MurmurHash.hashCode(this.opnds,486279973)}eval(t,e){for(let r of this.opnds)if(r.eval(t,e))return!0;return!1}evalPrecedence(e,r){let n=!1,i=[];for(let o of this.opnds){let s=o.evalPrecedence(e,r);if(n=n||s!==o,s===t.NONE)return t.NONE;s&&i.push(s)}if(!n)return this;if(0===i.length)return;let o=i[0];for(let e=1;e<i.length;e++)o=t.or(o,i[e]);return o}toString(){return c.join(this.opnds,"||")}};n([a.Override],f.prototype,"operands",null),n([a.Override],f.prototype,"equals",null),n([a.Override],f.prototype,"hashCode",null),n([a.Override],f.prototype,"eval",null),n([a.Override],f.prototype,"evalPrecedence",null),n([a.Override],f.prototype,"toString",null),f=n([i(0,a.NotNull),i(1,a.NotNull)],f),t.OR=f}(h=e.SemanticContext||(e.SemanticContext={}))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(52),o=r(53),s=r(3),l=r(22),a=r(39),u=r(58),c=r(0),h=r(29),p=r(2);class d extends h.Recognizer{constructor(t){super(),this._factory=i.CommonTokenFactory.DEFAULT,this._tokenStartCharIndex=-1,this._tokenStartLine=0,this._tokenStartCharPositionInLine=0,this._hitEOF=!1,this._channel=0,this._type=0,this._modeStack=new o.IntegerStack,this._mode=d.DEFAULT_MODE,this._input=t,this._tokenFactorySourcePair={source:this,stream:t}}static get DEFAULT_TOKEN_CHANNEL(){return p.Token.DEFAULT_CHANNEL}static get HIDDEN(){return p.Token.HIDDEN_CHANNEL}reset(t){void 0!==t&&!0!==t||this._input.seek(0),this._token=void 0,this._type=p.Token.INVALID_TYPE,this._channel=p.Token.DEFAULT_CHANNEL,this._tokenStartCharIndex=-1,this._tokenStartCharPositionInLine=-1,this._tokenStartLine=-1,this._text=void 0,this._hitEOF=!1,this._mode=d.DEFAULT_MODE,this._modeStack.clear(),this.interpreter.reset()}nextToken(){if(null==this._input)throw new Error("nextToken requires a non-null input stream.");let t=this._input.mark();try{t:for(;;){if(this._hitEOF)return this.emitEOF();this._token=void 0,this._channel=p.Token.DEFAULT_CHANNEL,this._tokenStartCharIndex=this._input.index,this._tokenStartCharPositionInLine=this.interpreter.charPositionInLine,this._tokenStartLine=this.interpreter.line,this._text=void 0;do{let t;this._type=p.Token.INVALID_TYPE;try{t=this.interpreter.match(this._input,this._mode)}catch(e){if(!(e instanceof u.LexerNoViableAltException))throw e;this.notifyListeners(e),this.recover(e),t=d.SKIP}if(this._input.LA(1)===l.IntStream.EOF&&(this._hitEOF=!0),this._type===p.Token.INVALID_TYPE&&(this._type=t),this._type===d.SKIP)continue t}while(this._type===d.MORE);return null==this._token?this.emit():this._token}}finally{this._input.release(t)}}skip(){this._type=d.SKIP}more(){this._type=d.MORE}mode(t){this._mode=t}pushMode(t){a.LexerATNSimulator.debug&&console.log("pushMode "+t),this._modeStack.push(this._mode),this.mode(t)}popMode(){if(this._modeStack.isEmpty)throw new Error("EmptyStackException");return a.LexerATNSimulator.debug&&console.log("popMode back to "+this._modeStack.peek()),this.mode(this._modeStack.pop()),this._mode}get tokenFactory(){return this._factory}set tokenFactory(t){this._factory=t}set inputStream(t){this.reset(!1),this._input=t,this._tokenFactorySourcePair={source:this,stream:this._input}}get sourceName(){return this._input.sourceName}get inputStream(){return this._input}emit(t){return t||(t=this._factory.create(this._tokenFactorySourcePair,this._type,this._text,this._channel,this._tokenStartCharIndex,this.charIndex-1,this._tokenStartLine,this._tokenStartCharPositionInLine)),this._token=t,t}emitEOF(){let t=this.charPositionInLine,e=this.line,r=this._factory.create(this._tokenFactorySourcePair,p.Token.EOF,void 0,p.Token.DEFAULT_CHANNEL,this._input.index,this._input.index-1,e,t);return this.emit(r),r}get line(){return this.interpreter.line}get charPositionInLine(){return this.interpreter.charPositionInLine}set line(t){this.interpreter.line=t}set charPositionInLine(t){this.interpreter.charPositionInLine=t}get charIndex(){return this._input.index}get text(){return null!=this._text?this._text:this.interpreter.getText(this._input)}set text(t){this._text=t}get token(){return this._token}set token(t){this._token=t}set type(t){this._type=t}get type(){return this._type}set channel(t){this._channel=t}get channel(){return this._channel}getAllTokens(){let t=[],e=this.nextToken();for(;e.type!=p.Token.EOF;)t.push(e),e=this.nextToken();return t}notifyListeners(t){let e=this._input.getText(s.Interval.of(this._tokenStartCharIndex,this._input.index)),r="token recognition error at: '"+this.getErrorDisplay(e)+"'",n=this.getErrorListenerDispatch();n.syntaxError&&n.syntaxError(this,void 0,this._tokenStartLine,this._tokenStartCharPositionInLine,r,t)}getErrorDisplay(t){if("number"==typeof t){switch(t){case p.Token.EOF:return"<EOF>";case 10:return"\\n";case 9:return"\\t";case 13:return"\\r"}return String.fromCharCode(t)}return t.replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/\r/g,"\\r")}getCharErrorDisplay(t){return"'"+this.getErrorDisplay(t)+"'"}recover(t){t instanceof u.LexerNoViableAltException?this._input.LA(1)!=l.IntStream.EOF&&this.interpreter.consume(this._input):this._input.consume()}}d.DEFAULT_MODE=0,d.MORE=-2,d.SKIP=-3,d.MIN_CHAR_VALUE=0,d.MAX_CHAR_VALUE=65535,n([c.Override],d.prototype,"nextToken",null),n([c.Override],d.prototype,"tokenFactory",null),n([c.Override],d.prototype,"sourceName",null),n([c.Override],d.prototype,"inputStream",null),n([c.Override],d.prototype,"line",null),n([c.Override],d.prototype,"charPositionInLine",null),e.Lexer=d},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0});const n=r(10),i=r(13),o=r(51);class s{constructor(t){this.keyComparator=t}hashCode(t){return this.keyComparator.hashCode(t.key)}equals(t,e){return this.keyComparator.equals(t.key,e.key)}}class l{constructor(t){this.backingStore=t instanceof l?new n.Array2DHashSet(t.backingStore):new n.Array2DHashSet(new s(t))}clear(){this.backingStore.clear()}containsKey(t){return this.backingStore.contains({key:t})}containsValue(t){return this.values().contains(t)}entrySet(){return new a(this,this.backingStore)}get(t){let e=this.backingStore.get({key:t});if(e)return e.value}get isEmpty(){return this.backingStore.isEmpty}keySet(){return new u(this,this.backingStore)}put(t,e){let r,n=this.backingStore.get({key:t,value:e});return n?(r=n.value,n.value=e):this.backingStore.add({key:t,value:e}),r}putIfAbsent(t,e){let r,n=this.backingStore.get({key:t,value:e});return n?r=n.value:this.backingStore.add({key:t,value:e}),r}putAll(t){for(let e of i.asIterable(t.entrySet()))this.put(e.getKey(),e.getValue())}remove(t){let e=this.get(t);return this.backingStore.remove({key:t}),e}get size(){return this.backingStore.size}values(){return new c(this,this.backingStore)}hashCode(){return this.backingStore.hashCode()}equals(t){return t instanceof l&&this.backingStore.equals(t.backingStore)}}e.Array2DHashMap=l;class a{constructor(t,e){this.map=t,this.backingStore=e}add(t){throw new Error("Not implemented")}addAll(t){throw new Error("Not implemented")}clear(){this.map.clear()}contains(t){throw new Error("Not implemented")}containsAll(t){for(let e of i.asIterable(t))if(!this.contains(e))return!1;return!0}equals(t){return t===this||t instanceof a&&this.backingStore.equals(t.backingStore)}hashCode(){return this.backingStore.hashCode()}get isEmpty(){return this.backingStore.isEmpty}iterator(){throw new Error("Not implemented")}remove(t){throw new Error("Not implemented")}removeAll(t){let e=!1;for(let r of i.asIterable(t))e=this.remove(r)||e;return e}retainAll(t){throw new Error("Not implemented")}get size(){return this.backingStore.size}toArray(t){throw new Error("Not implemented")}}class u{constructor(t,e){this.map=t,this.backingStore=e}add(t){throw new Error("Not supported")}addAll(t){throw new Error("Not supported")}clear(){this.map.clear()}contains(t){return this.backingStore.contains({key:t})}containsAll(t){for(let e of i.asIterable(t))if(!this.contains(e))return!1;return!0}equals(t){return t===this||t instanceof u&&this.backingStore.equals(t.backingStore)}hashCode(){return this.backingStore.hashCode()}get isEmpty(){return this.backingStore.isEmpty}iterator(){throw new Error("Not implemented")}remove(t){return this.backingStore.remove({key:t})}removeAll(t){let e=!1;for(let r of i.asIterable(t))e=this.remove(r)||e;return e}retainAll(t){throw new Error("Not implemented")}get size(){return this.backingStore.size}toArray(t){throw new Error("Not implemented")}}class c{constructor(t,e){this.map=t,this.backingStore=e}add(t){throw new Error("Not supported")}addAll(t){throw new Error("Not supported")}clear(){this.map.clear()}contains(t){for(let e of i.asIterable(this.backingStore))if(o.DefaultEqualityComparator.INSTANCE.equals(t,e.value))return!0;return!1}containsAll(t){for(let e of i.asIterable(t))if(!this.contains(e))return!1;return!0}equals(t){return t===this||t instanceof c&&this.backingStore.equals(t.backingStore)}hashCode(){return this.backingStore.hashCode()}get isEmpty(){return this.backingStore.isEmpty}iterator(){let t=this.backingStore.iterator();return{hasNext:()=>t.hasNext(),next:()=>t.next().value,remove(){throw new Error("Not supported")}}}remove(t){throw new Error("Not implemented")}removeAll(t){let e=!1;for(let r of i.asIterable(t))e=this.remove(r)||e;return e}retainAll(t){throw new Error("Not implemented")}get size(){return this.backingStore.size}toArray(t){(void 0===t||t.length<this.backingStore.size)&&(t=new Array(this.backingStore.size));let e=0;for(let r of i.asIterable(this.backingStore))t[e++]=r.value;return t}}},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(0),o=r(2);class s{constructor(t,e,r){this.literalNames=t,this.symbolicNames=e,this.displayNames=r,this._maxTokenType=Math.max(this.displayNames.length,Math.max(this.literalNames.length,this.symbolicNames.length))-1}get maxTokenType(){return this._maxTokenType}getLiteralName(t){if(t>=0&&t<this.literalNames.length)return this.literalNames[t]}getSymbolicName(t){return t>=0&&t<this.symbolicNames.length?this.symbolicNames[t]:t===o.Token.EOF?"EOF":void 0}getDisplayName(t){if(t>=0&&t<this.displayNames.length){let e=this.displayNames[t];if(e)return e}let e=this.getLiteralName(t);if(e)return e;let r=this.getSymbolicName(t);return r||String(t)}}s.EMPTY_VOCABULARY=new s([],[],[]),n([i.NotNull],s.prototype,"literalNames",void 0),n([i.NotNull],s.prototype,"symbolicNames",void 0),n([i.NotNull],s.prototype,"displayNames",void 0),n([i.Override],s.prototype,"maxTokenType",null),n([i.Override],s.prototype,"getLiteralName",null),n([i.Override],s.prototype,"getSymbolicName",null),n([i.Override,i.NotNull],s.prototype,"getDisplayName",null),n([i.NotNull],s,"EMPTY_VOCABULARY",void 0),e.VocabularyImpl=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0}),function(t){t.EOF=-1,t.UNKNOWN_SOURCE_NAME="<unknown>"}(e.IntStream||(e.IntStream={}))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(20),o=r(10),s=r(26),l=r(7),a=r(27),u=r(12),c=r(13),h=r(0),p=r(6),d=r(4),f=r(40),g=r(18),y=r(5),_=r(8);class m{hashCode(t){return t.state^t.alt}equals(t,e){return t.state===e.state&&t.alt===e.alt}}function T(t){return t?new i.Array2DHashMap(t):new i.Array2DHashMap(m.INSTANCE)}m.INSTANCE=new m;class S{constructor(t,e){this._uniqueAlt=0,this._hasSemanticContext=!1,this._dipsIntoOuterContext=!1,this.outermostConfigSet=!1,this.cachedHashCode=-1,t?(e?(this.mergedConfigs=void 0,this.unmerged=void 0):t.isReadOnly?(this.mergedConfigs=T(),this.unmerged=[]):(this.mergedConfigs=T(t.mergedConfigs),this.unmerged=t.unmerged.slice(0)),this.configs=t.configs.slice(0),this._dipsIntoOuterContext=t._dipsIntoOuterContext,this._hasSemanticContext=t._hasSemanticContext,this.outermostConfigSet=t.outermostConfigSet,!e&&t.isReadOnly||(this._uniqueAlt=t._uniqueAlt,this._conflictInfo=t._conflictInfo)):(this.mergedConfigs=T(),this.unmerged=[],this.configs=[],this._uniqueAlt=l.ATN.INVALID_ALT_NUMBER)}getRepresentedAlternatives(){if(null!=this._conflictInfo)return this._conflictInfo.conflictedAlts.clone();let t=new u.BitSet;for(let e of c.asIterable(this))t.set(e.alt);return t}get isReadOnly(){return null==this.mergedConfigs}get isOutermostConfigSet(){return this.outermostConfigSet}set isOutermostConfigSet(t){if(this.outermostConfigSet&&!t)throw new Error("IllegalStateException");y(!t||!this._dipsIntoOuterContext),this.outermostConfigSet=t}getStates(){let t=new o.Array2DHashSet(p.ObjectEqualityComparator.INSTANCE);for(let e of this.configs)t.add(e.state);return t}optimizeConfigs(t){if(0!==this.configs.length)for(let e=0;e<this.configs.length;e++){let r=this.configs[e];r.context=t.atn.getCachedContext(r.context)}}clone(t){let e=new S(this,t);return!t&&this.isReadOnly&&e.addAll(this.configs),e}get size(){return this.configs.length}get isEmpty(){return 0===this.configs.length}contains(t){if(!(t instanceof a.ATNConfig))return!1;if(this.mergedConfigs&&this.unmerged){let e=t,r=this.getKey(e),n=this.mergedConfigs.get(r);if(null!=n&&this.canMerge(e,r,n))return n.contains(e);for(let e of this.unmerged)if(e.contains(t))return!0}else for(let e of this.configs)if(e.contains(t))return!0;return!1}iterator(){return new x(this,this.configs)}toArray(t){if(!t||t.length<this.configs.length)return this.configs;for(let e=0;e<this.configs.length;e++)t[e]=this.configs[e];return t}add(t,e){if(this.ensureWritable(),!this.mergedConfigs||!this.unmerged)throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");let r;y(!this.outermostConfigSet||!t.reachesIntoOuterContext),null==e&&(e=f.PredictionContextCache.UNCACHED);let n=this.getKey(t),i=this.mergedConfigs.get(n);if(r=null==i,null!=i&&this.canMerge(t,n,i)){i.outerContextDepth=Math.max(i.outerContextDepth,t.outerContextDepth),t.isPrecedenceFilterSuppressed&&(i.isPrecedenceFilterSuppressed=!0);let r=d.PredictionContext.join(i.context,t.context,e);return this.updatePropertiesForMergedConfig(t),i.context==r?!1:(i.context=r,!0)}for(let i=0;i<this.unmerged.length;i++){let o=this.unmerged[i];if(this.canMerge(t,n,o)){o.outerContextDepth=Math.max(o.outerContextDepth,t.outerContextDepth),t.isPrecedenceFilterSuppressed&&(o.isPrecedenceFilterSuppressed=!0);let s=d.PredictionContext.join(o.context,t.context,e);return this.updatePropertiesForMergedConfig(t),o.context==s?!1:(o.context=s,r&&(this.mergedConfigs.put(n,o),this.unmerged.splice(i,1)),!0)}}return this.configs.push(t),r?this.mergedConfigs.put(n,t):this.unmerged.push(t),this.updatePropertiesForAddedConfig(t),!0}updatePropertiesForMergedConfig(t){this._dipsIntoOuterContext=this._dipsIntoOuterContext||t.reachesIntoOuterContext,y(!this.outermostConfigSet||!this._dipsIntoOuterContext)}updatePropertiesForAddedConfig(t){1===this.configs.length?this._uniqueAlt=t.alt:this._uniqueAlt!==t.alt&&(this._uniqueAlt=l.ATN.INVALID_ALT_NUMBER),this._hasSemanticContext=this._hasSemanticContext||!g.SemanticContext.NONE.equals(t.semanticContext),this._dipsIntoOuterContext=this._dipsIntoOuterContext||t.reachesIntoOuterContext,y(!this.outermostConfigSet||!this._dipsIntoOuterContext)}canMerge(t,e,r){return t.state.stateNumber==r.state.stateNumber&&(e.alt===r.alt&&t.semanticContext.equals(r.semanticContext))}getKey(t){return{state:t.state.stateNumber,alt:t.alt}}containsAll(t){for(let e of c.asIterable(t)){if(!(e instanceof a.ATNConfig))return!1;if(!this.contains(e))return!1}return!0}addAll(t,e){this.ensureWritable();let r=!1;for(let n of c.asIterable(t))this.add(n,e)&&(r=!0);return r}retainAll(t){throw this.ensureWritable(),new Error("Not supported yet.")}removeAll(t){throw this.ensureWritable(),new Error("Not supported yet.")}clear(){if(this.ensureWritable(),!this.mergedConfigs||!this.unmerged)throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");this.mergedConfigs.clear(),this.unmerged.length=0,this.configs.length=0,this._dipsIntoOuterContext=!1,this._hasSemanticContext=!1,this._uniqueAlt=l.ATN.INVALID_ALT_NUMBER,this._conflictInfo=void 0}equals(t){return this===t||t instanceof S&&(this.outermostConfigSet==t.outermostConfigSet&&_.equals(this._conflictInfo,t._conflictInfo)&&s.ArrayEqualityComparator.INSTANCE.equals(this.configs,t.configs))}hashCode(){if(this.isReadOnly&&-1!=this.cachedHashCode)return this.cachedHashCode;let t=1;return t=5*(t=5*t^(this.outermostConfigSet?1:0))^s.ArrayEqualityComparator.INSTANCE.hashCode(this.configs),this.isReadOnly&&(this.cachedHashCode=t),t}toString(t){null==t&&(t=!1);let e="",r=this.configs.slice(0);r.sort((t,e)=>t.alt!=e.alt?t.alt-e.alt:t.state.stateNumber!=e.state.stateNumber?t.state.stateNumber-e.state.stateNumber:t.semanticContext.toString().localeCompare(e.semanticContext.toString())),e+="[";for(let n=0;n<r.length;n++)n>0&&(e+=", "),e+=r[n].toString(void 0,!0,t);return e+="]",this._hasSemanticContext&&(e+=",hasSemanticContext="+this._hasSemanticContext),this._uniqueAlt!==l.ATN.INVALID_ALT_NUMBER&&(e+=",uniqueAlt="+this._uniqueAlt),null!=this._conflictInfo&&(e+=",conflictingAlts="+this._conflictInfo.conflictedAlts,this._conflictInfo.isExact||(e+="*")),this._dipsIntoOuterContext&&(e+=",dipsIntoOuterContext"),e.toString()}get uniqueAlt(){return this._uniqueAlt}get hasSemanticContext(){return this._hasSemanticContext}set hasSemanticContext(t){this.ensureWritable(),this._hasSemanticContext=t}get conflictInfo(){return this._conflictInfo}set conflictInfo(t){this.ensureWritable(),this._conflictInfo=t}get conflictingAlts(){if(null!=this._conflictInfo)return this._conflictInfo.conflictedAlts}get isExactConflict(){return null!=this._conflictInfo&&this._conflictInfo.isExact}get dipsIntoOuterContext(){return this._dipsIntoOuterContext}get(t){return this.configs[t]}remove(t){if(this.ensureWritable(),!this.mergedConfigs||!this.unmerged)throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");if("number"!=typeof t)throw new Error("Not supported yet");let e=t,r=this.configs[e];this.configs.splice(e,1);let n=this.getKey(r);if(this.mergedConfigs.get(n)===r)this.mergedConfigs.remove(n);else for(let t=0;t<this.unmerged.length;t++)if(this.unmerged[t]===r)return void this.unmerged.splice(t,1)}ensureWritable(){if(this.isReadOnly)throw new Error("This ATNConfigSet is read only.")}}n([h.NotNull],S.prototype,"getRepresentedAlternatives",null),n([h.Override],S.prototype,"size",null),n([h.Override],S.prototype,"isEmpty",null),n([h.Override],S.prototype,"contains",null),n([h.Override],S.prototype,"iterator",null),n([h.Override],S.prototype,"toArray",null),n([h.Override],S.prototype,"containsAll",null),n([h.Override],S.prototype,"retainAll",null),n([h.Override],S.prototype,"removeAll",null),n([h.Override],S.prototype,"clear",null),n([h.Override],S.prototype,"equals",null),n([h.Override],S.prototype,"hashCode",null),e.ATNConfigSet=S;class x{constructor(t,e){this.index=-1,this.removed=!1,this.configs=e}hasNext(){return this.index+1<this.configs.length}next(){if(!this.hasNext())throw new Error("NoSuchElementException");return this.index++,this.removed=!1,this.configs[this.index]}remove(){if(this.removed||this.index<0||this.index>=this.configs.length)throw new Error("IllegalStateException");this.set.remove(this.index),this.removed=!0}}n([h.Override],x.prototype,"hasNext",null),n([h.Override],x.prototype,"next",null),n([h.Override],x.prototype,"remove",null)},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(11),o=r(0);class s extends i.ATNState{get nonStopStateNumber(){return-1}get stateType(){return 7}}n([o.Override],s.prototype,"nonStopStateNumber",null),n([o.Override],s.prototype,"stateType",null),e.RuleStopState=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(0);let s=class{constructor(t,e,r,n,i,o){this.decision=t,this.fullCtx=o,this.stopIndex=i,this.input=r,this.startIndex=n,this.state=e}};n([o.NotNull],s.prototype,"input",void 0),s=n([i(2,o.NotNull)],s),e.DecisionEventInfo=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(0),o=r(1),s=r(6);class l{hashCode(t){return null==t?0:o.MurmurHash.hashCode(t,0)}equals(t,e){if(null==t)return null==e;if(null==e)return!1;if(t.length!==e.length)return!1;for(let r=0;r<t.length;r++)if(!s.ObjectEqualityComparator.INSTANCE.equals(t[r],e[r]))return!1;return!0}}l.INSTANCE=new l,n([i.Override],l.prototype,"hashCode",null),n([i.Override],l.prototype,"equals",null),e.ArrayEqualityComparator=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(20),s=r(15),l=r(1),a=r(0),u=r(6),c=r(4),h=r(18),p=r(5);let d=class t{constructor(t,e,r){"number"==typeof e?(p((16777215&e)==e),this._state=t,this.altAndOuterContextDepth=e,this._context=r):(this._state=t,this.altAndOuterContextDepth=e.altAndOuterContextDepth,this._context=r)}static create(e,r,n,i=h.SemanticContext.NONE,o){return i!=h.SemanticContext.NONE?null!=o?new y(o,i,e,r,n,!1):new f(i,e,r,n):null!=o?new g(o,e,r,n,!1):new t(e,r,n)}get state(){return this._state}get alt(){return 16777215&this.altAndOuterContextDepth}get context(){return this._context}set context(t){this._context=t}get reachesIntoOuterContext(){return 0!==this.outerContextDepth}get outerContextDepth(){return this.altAndOuterContextDepth>>>24&127}set outerContextDepth(t){p(t>=0),t=Math.min(t,127),this.altAndOuterContextDepth=t<<24|(-2130706433&this.altAndOuterContextDepth)>>>0}get lexerActionExecutor(){}get semanticContext(){return h.SemanticContext.NONE}get hasPassedThroughNonGreedyDecision(){return!1}clone(){return this.transform(this.state,!1)}transform(t,e,r){return null==r?this.transformImpl(t,this._context,this.semanticContext,e,this.lexerActionExecutor):r instanceof c.PredictionContext?this.transformImpl(t,r,this.semanticContext,e,this.lexerActionExecutor):r instanceof h.SemanticContext?this.transformImpl(t,this._context,r,e,this.lexerActionExecutor):this.transformImpl(t,this._context,this.semanticContext,e,r)}transformImpl(e,r,n,i,o){let s=i&&t.checkNonGreedyDecision(this,e);return n!=h.SemanticContext.NONE?null!=o||s?new y(o,n,e,this,r,s):new f(n,e,this,r):null!=o||s?new g(o,e,this,r,s):new t(e,this,r)}static checkNonGreedyDecision(t,e){return t.hasPassedThroughNonGreedyDecision||e instanceof s.DecisionState&&e.nonGreedy}appendContext(t,e){if("number"==typeof t){let r=this.context.appendSingleContext(t,e);return this.transform(this.state,!1,r)}{let r=this.context.appendContext(t,e);return this.transform(this.state,!1,r)}}contains(t){if(this.state.stateNumber!==t.state.stateNumber||this.alt!==t.alt||!this.semanticContext.equals(t.semanticContext))return!1;let e=[],r=[];for(e.push(this.context),r.push(t.context);;){let t=e.pop(),n=r.pop();if(!t||!n)break;if(t===n)return!0;if(t.size<n.size)return!1;if(n.isEmpty)return t.hasEmpty;for(let i=0;i<n.size;i++){let o=t.findReturnState(n.getReturnState(i));if(o<0)return!1;e.push(t.getParent(o)),r.push(n.getParent(i))}}return!1}get isPrecedenceFilterSuppressed(){return 0!=(2147483648&this.altAndOuterContextDepth)}set isPrecedenceFilterSuppressed(t){t?this.altAndOuterContextDepth|=2147483648:this.altAndOuterContextDepth&=2147483647}equals(e){return this===e||e instanceof t&&(this.state.stateNumber==e.state.stateNumber&&this.alt==e.alt&&this.reachesIntoOuterContext==e.reachesIntoOuterContext&&this.context.equals(e.context)&&this.semanticContext.equals(e.semanticContext)&&this.isPrecedenceFilterSuppressed==e.isPrecedenceFilterSuppressed&&this.hasPassedThroughNonGreedyDecision==e.hasPassedThroughNonGreedyDecision&&u.ObjectEqualityComparator.INSTANCE.equals(this.lexerActionExecutor,e.lexerActionExecutor))}hashCode(){let t=l.MurmurHash.initialize(7);return t=l.MurmurHash.update(t,this.state.stateNumber),t=l.MurmurHash.update(t,this.alt),t=l.MurmurHash.update(t,this.reachesIntoOuterContext?1:0),t=l.MurmurHash.update(t,this.context),t=l.MurmurHash.update(t,this.semanticContext),t=l.MurmurHash.update(t,this.hasPassedThroughNonGreedyDecision?1:0),t=l.MurmurHash.update(t,this.lexerActionExecutor),t=l.MurmurHash.finish(t,7)}toDotString(){let t="";t+="digraph G {\n",t+="rankdir=LR;\n";let e=new o.Array2DHashMap(c.PredictionContext.IdentityEqualityComparator.INSTANCE),r=[];function n(t){let n=e.size,i=e.putIfAbsent(t,n);return null!=i?i:(r.push(t),n)}for(r.push(this.context),e.put(this.context,0);;){let e=r.pop();if(!e)break;for(let r=0;r<e.size;r++)t+="  s"+n(e),t+="->",t+="s"+n(e.getParent(r)),t+='[label="'+e.getReturnState(r)+'"];\n'}return(t+="}\n").toString()}toString(t,e,r){null==r&&(r=null!=e),null==e&&(e=!0);let n,i="";n=r?this.context.toStrings(t,this.state.stateNumber):["?"];let o=!0;for(let t of n)o?o=!1:i+=", ",i+="(",i+=this.state,e&&(i+=",",i+=this.alt),this.context&&(i+=",",i+=t),this.semanticContext!==h.SemanticContext.NONE&&(i+=",",i+=this.semanticContext),this.reachesIntoOuterContext&&(i+=",up="+this.outerContextDepth),i+=")";return i.toString()}};n([a.NotNull],d.prototype,"_state",void 0),n([a.NotNull],d.prototype,"_context",void 0),n([a.NotNull],d.prototype,"state",null),n([a.NotNull,i(0,a.NotNull)],d.prototype,"context",null),n([a.NotNull],d.prototype,"semanticContext",null),n([a.Override],d.prototype,"clone",null),n([i(0,a.NotNull),i(2,a.NotNull)],d.prototype,"transformImpl",null),n([a.Override],d.prototype,"equals",null),n([a.Override],d.prototype,"hashCode",null),n([i(0,a.NotNull),i(3,a.NotNull)],d,"create",null),d=n([i(0,a.NotNull),i(2,a.NotNull)],d),e.ATNConfig=d;let f=class extends d{constructor(t,e,r,n){super(e,r,n),this._semanticContext=t}get semanticContext(){return this._semanticContext}};n([a.NotNull],f.prototype,"_semanticContext",void 0),n([a.Override],f.prototype,"semanticContext",null),f=n([i(1,a.NotNull),i(2,a.NotNull)],f);let g=class extends d{constructor(t,e,r,n,i){if("number"==typeof r)super(e,r,n);else if(super(e,r,n),r.semanticContext!==h.SemanticContext.NONE)throw new Error("Not supported");this._lexerActionExecutor=t,this.passedThroughNonGreedyDecision=i}get lexerActionExecutor(){return this._lexerActionExecutor}get hasPassedThroughNonGreedyDecision(){return this.passedThroughNonGreedyDecision}};n([a.Override],g.prototype,"lexerActionExecutor",null),n([a.Override],g.prototype,"hasPassedThroughNonGreedyDecision",null),g=n([i(1,a.NotNull),i(2,a.NotNull)],g);let y=class extends f{constructor(t,e,r,n,i,o){super(e,r,n,i),this._lexerActionExecutor=t,this.passedThroughNonGreedyDecision=o}get lexerActionExecutor(){return this._lexerActionExecutor}get hasPassedThroughNonGreedyDecision(){return this.passedThroughNonGreedyDecision}};n([a.Override],y.prototype,"lexerActionExecutor",null),n([a.Override],y.prototype,"hasPassedThroughNonGreedyDecision",null),y=n([i(1,a.NotNull),i(2,a.NotNull)],y)},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(23),s=r(41),l=r(0),a=r(4);let u=class t{constructor(t){this.atn=t}static get ERROR(){return t._ERROR||(t._ERROR=new s.DFAState(new o.ATNConfigSet),t._ERROR.stateNumber=a.PredictionContext.EMPTY_FULL_STATE_KEY),t._ERROR}clearDFA(){this.atn.clearDFA()}};n([l.NotNull],u.prototype,"atn",void 0),n([l.NotNull],u,"ERROR",null),u=n([i(0,l.NotNull)],u),e.ATNSimulator=u,u=e.ATNSimulator||(e.ATNSimulator={}),e.ATNSimulator=u},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(71),s=r(54),l=r(0),a=r(2),u=r(8);class c{constructor(){this._listeners=[o.ConsoleErrorListener.INSTANCE],this._stateNumber=-1}getTokenTypeMap(){let t=this.vocabulary,e=c.tokenTypeMapCache.get(t);if(null==e){let r=new Map;for(let e=0;e<=this.atn.maxTokenType;e++){let n=t.getLiteralName(e);null!=n&&r.set(n,e);let i=t.getSymbolicName(e);null!=i&&r.set(i,e)}r.set("EOF",a.Token.EOF),e=Object.freeze(r),c.tokenTypeMapCache.set(t,e)}return e}getRuleIndexMap(){let t=this.ruleNames;if(null==t)throw new Error("The current recognizer does not provide a list of rule names.");let e=c.ruleIndexMapCache.get(t);return null==e&&(e=Object.freeze(u.toMap(t)),c.ruleIndexMapCache.set(t,e)),e}getTokenType(t){let e=this.getTokenTypeMap().get(t);return null!=e?e:a.Token.INVALID_TYPE}get serializedATN(){throw new Error("there is no serialized ATN")}get atn(){return this._interp.atn}get interpreter(){return this._interp}get parseInfo(){}set interpreter(t){this._interp=t}getErrorHeader(t){let e=t.getOffendingToken();return e?"line "+e.line+":"+e.charPositionInLine:""}addErrorListener(t){if(!t)throw new TypeError("listener must not be null");this._listeners.push(t)}removeErrorListener(t){let e=this._listeners.indexOf(t);-1!==e&&this._listeners.splice(e,1)}removeErrorListeners(){this._listeners.length=0}getErrorListeners(){return this._listeners.slice(0)}getErrorListenerDispatch(){return new s.ProxyErrorListener(this.getErrorListeners())}sempred(t,e,r){return!0}precpred(t,e){return!0}action(t,e,r){}get state(){return this._stateNumber}set state(t){this._stateNumber=t}}c.EOF=-1,c.tokenTypeMapCache=new WeakMap,c.ruleIndexMapCache=new WeakMap,n([l.SuppressWarnings("serial"),l.NotNull],c.prototype,"_listeners",void 0),n([l.NotNull],c.prototype,"getTokenTypeMap",null),n([l.NotNull],c.prototype,"getRuleIndexMap",null),n([l.NotNull],c.prototype,"serializedATN",null),n([l.NotNull],c.prototype,"atn",null),n([l.NotNull,i(0,l.NotNull)],c.prototype,"interpreter",null),n([l.NotNull,i(0,l.NotNull)],c.prototype,"getErrorHeader",null),n([i(0,l.NotNull)],c.prototype,"addErrorListener",null),n([i(0,l.NotNull)],c.prototype,"removeErrorListener",null),n([l.NotNull],c.prototype,"getErrorListeners",null),e.Recognizer=c},function(t,e,r){"use strict";(function(t){
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(8),s=r(59),l=r(47),a=r(49),u=r(53),c=r(19),h=r(0),p=r(101),d=r(29),f=r(2);class g{constructor(t,e){this.ruleNames=t,this.tokenStream=e}enterEveryRule(t){console.log("enter   "+this.ruleNames[t.ruleIndex]+", LT(1)="+this.tokenStream.LT(1).text)}exitEveryRule(t){console.log("exit    "+this.ruleNames[t.ruleIndex]+", LT(1)="+this.tokenStream.LT(1).text)}visitErrorNode(t){}visitTerminal(t){let e=t.parent.ruleContext,r=t.symbol;console.log("consume "+r+" rule "+this.ruleNames[e.ruleIndex])}}n([h.Override],g.prototype,"enterEveryRule",null),n([h.Override],g.prototype,"exitEveryRule",null),n([h.Override],g.prototype,"visitErrorNode",null),n([h.Override],g.prototype,"visitTerminal",null);class y extends d.Recognizer{constructor(t){super(),this._errHandler=new a.DefaultErrorStrategy,this._precedenceStack=new u.IntegerStack,this._buildParseTrees=!0,this._parseListeners=[],this._syntaxErrors=0,this.matchedEOF=!1,this._precedenceStack.push(0),this.inputStream=t}reset(t){void 0!==t&&!0!==t||this.inputStream.seek(0),this._errHandler.reset(this),this._ctx=void 0,this._syntaxErrors=0,this.matchedEOF=!1,this.isTrace=!1,this._precedenceStack.clear(),this._precedenceStack.push(0);let e=this.interpreter;null!=e&&e.reset()}match(t){let e=this.currentToken;return e.type===t?(t===f.Token.EOF&&(this.matchedEOF=!0),this._errHandler.reportMatch(this),this.consume()):(e=this._errHandler.recoverInline(this),this._buildParseTrees&&-1===e.tokenIndex&&this._ctx.addErrorNode(e)),e}matchWildcard(){let t=this.currentToken;return t.type>0?(this._errHandler.reportMatch(this),this.consume()):(t=this._errHandler.recoverInline(this),this._buildParseTrees&&-1==t.tokenIndex&&this._ctx.addErrorNode(t)),t}set buildParseTree(t){this._buildParseTrees=t}get buildParseTree(){return this._buildParseTrees}getParseListeners(){return this._parseListeners}addParseListener(t){if(null==t)throw new TypeError("listener cannot be null");this._parseListeners.push(t)}removeParseListener(t){let e=this._parseListeners.findIndex(e=>e===t);-1!=e&&this._parseListeners.splice(e,1)}removeParseListeners(){this._parseListeners.length=0}triggerEnterRuleEvent(){for(let t of this._parseListeners)t.enterEveryRule&&t.enterEveryRule(this._ctx),this._ctx.enterRule(t)}triggerExitRuleEvent(){for(let t=this._parseListeners.length-1;t>=0;t--){let e=this._parseListeners[t];this._ctx.exitRule(e),e.exitEveryRule&&e.exitEveryRule(this._ctx)}}get numberOfSyntaxErrors(){return this._syntaxErrors}get tokenFactory(){return this._input.tokenSource.tokenFactory}getATNWithBypassAlts(){let t=this.serializedATN;if(null==t)throw new Error("The current parser does not support an ATN with bypass alternatives.");let e=y.bypassAltsAtnCache.get(t);if(null==e){let r=new s.ATNDeserializationOptions;r.isGenerateRuleBypassTransitions=!0,e=new l.ATNDeserializer(r).deserialize(o.toCharArray(t)),y.bypassAltsAtnCache.set(t,e)}return e}compileParseTreePattern(t,e,r){if(!r){if(this.inputStream){let t=this.inputStream.tokenSource;t instanceof c.Lexer&&(r=t)}if(!r)throw new Error("Parser can't discover a lexer to use")}throw new Error("Not implemented")}get errorHandler(){return this._errHandler}set errorHandler(t){this._errHandler=t}get inputStream(){return this._input}set inputStream(t){this.reset(!1),this._input=t}get currentToken(){return this._input.LT(1)}notifyErrorListeners(t,e,r){void 0===e?e=this.currentToken:null===e&&(e=void 0),this._syntaxErrors++;let n=-1,i=-1;null!=e&&(n=e.line,i=e.charPositionInLine);let o=this.getErrorListenerDispatch();o.syntaxError&&o.syntaxError(this,e,n,i,t,r)}consume(){let t=this.currentToken;t.type!=y.EOF&&this.inputStream.consume();let e=0!==this._parseListeners.length;if(this._buildParseTrees||e)if(this._errHandler.inErrorRecoveryMode(this)){let r=this._ctx.addErrorNode(t);if(e)for(let t of this._parseListeners)t.visitErrorNode&&t.visitErrorNode(r)}else{let r=this._ctx.addChild(t);if(e)for(let t of this._parseListeners)t.visitTerminal&&t.visitTerminal(r)}return t}addContextToParseTree(){let t=this._ctx._parent;null!=t&&t.addChild(this._ctx)}enterRule(t,e,r){this.state=e,this._ctx=t,this._ctx._start=this._input.LT(1),this._buildParseTrees&&this.addContextToParseTree(),this.triggerEnterRuleEvent()}enterLeftFactoredRule(t,e,r){if(this.state=e,this._buildParseTrees){let e=this._ctx.getChild(this._ctx.childCount-1);this._ctx.removeLastChild(),e._parent=t,t.addChild(e)}this._ctx=t,this._ctx._start=this._input.LT(1),this._buildParseTrees&&this.addContextToParseTree(),this.triggerEnterRuleEvent()}exitRule(){this.matchedEOF?this._ctx._stop=this._input.LT(1):this._ctx._stop=this._input.tryLT(-1),this.triggerExitRuleEvent(),this.state=this._ctx.invokingState,this._ctx=this._ctx._parent}enterOuterAlt(t,e){if(t.altNumber=e,this._buildParseTrees&&this._ctx!==t){let e=this._ctx._parent;null!=e&&(e.removeLastChild(),e.addChild(t))}this._ctx=t}get precedence(){return this._precedenceStack.isEmpty?-1:this._precedenceStack.peek()}enterRecursionRule(t,e,r,n){this.state=e,this._precedenceStack.push(n),this._ctx=t,this._ctx._start=this._input.LT(1),this.triggerEnterRuleEvent()}pushNewRecursionContext(t,e,r){let n=this._ctx;n._parent=t,n.invokingState=e,n._stop=this._input.tryLT(-1),this._ctx=t,this._ctx._start=n._start,this._buildParseTrees&&this._ctx.addChild(n),this.triggerEnterRuleEvent()}unrollRecursionContexts(t){this._precedenceStack.pop(),this._ctx._stop=this._input.tryLT(-1);let e=this._ctx;if(this._parseListeners.length>0)for(;this._ctx!==t;)this.triggerExitRuleEvent(),this._ctx=this._ctx._parent;else this._ctx=t;e._parent=t,this._buildParseTrees&&null!=t&&t.addChild(e)}getInvokingContext(t){let e=this._ctx;for(;e&&e.ruleIndex!==t;)e=e._parent;return e}get context(){return this._ctx}set context(t){this._ctx=t}precpred(t,e){return e>=this._precedenceStack.peek()}getErrorListenerDispatch(){return new p.ProxyParserErrorListener(this.getErrorListeners())}inContext(t){return!1}isExpectedToken(t){let e=this.interpreter.atn,r=this._ctx,n=e.states[this.state],i=e.nextTokens(n);if(i.contains(t))return!0;if(!i.contains(f.Token.EPSILON))return!1;for(;null!=r&&r.invokingState>=0&&i.contains(f.Token.EPSILON);){let n=e.states[r.invokingState].transition(0);if((i=e.nextTokens(n.followState)).contains(t))return!0;r=r._parent}return!(!i.contains(f.Token.EPSILON)||t!=f.Token.EOF)}get isMatchedEOF(){return this.matchedEOF}getExpectedTokens(){return this.atn.getExpectedTokens(this.state,this.context)}getExpectedTokensWithinCurrentRule(){let t=this.interpreter.atn,e=t.states[this.state];return t.nextTokens(e)}getRuleIndex(t){let e=this.getRuleIndexMap().get(t);return null!=e?e:-1}get ruleContext(){return this._ctx}getRuleInvocationStack(t=this._ctx){let e=t,r=this.ruleNames,n=[];for(;null!=e;){let t=e.ruleIndex;t<0?n.push("n/a"):n.push(r[t]),e=e._parent}return n}getDFAStrings(){let t=[];for(let e=0;e<this._interp.atn.decisionToDFA.length;e++){let r=this._interp.atn.decisionToDFA[e];t.push(r.toString(this.vocabulary,this.ruleNames))}return t}dumpDFA(){let e=!1;for(let r=0;r<this._interp.atn.decisionToDFA.length;r++){let n=this._interp.atn.decisionToDFA[r];n.isEmpty||(e&&console.log(),console.log("Decision "+n.decision+":"),t.stdout.write(n.toString(this.vocabulary,this.ruleNames)),e=!0)}}get sourceName(){return this._input.sourceName}get parseInfo(){throw new Error("Not implemented")}setProfile(t){throw new Error("Not implemented")}set isTrace(t){t?(this._tracer?this.removeParseListener(this._tracer):this._tracer=new g(this.ruleNames,this._input),this.addParseListener(this._tracer)):this._tracer&&(this.removeParseListener(this._tracer),this._tracer=void 0)}get isTrace(){return null!=this._tracer}}y.bypassAltsAtnCache=new Map,n([h.NotNull],y.prototype,"_errHandler",void 0),n([h.NotNull],y.prototype,"match",null),n([h.NotNull],y.prototype,"matchWildcard",null),n([h.NotNull],y.prototype,"getParseListeners",null),n([i(0,h.NotNull)],y.prototype,"addParseListener",null),n([h.NotNull],y.prototype,"getATNWithBypassAlts",null),n([h.NotNull,i(0,h.NotNull)],y.prototype,"errorHandler",null),n([h.Override],y.prototype,"inputStream",null),n([h.NotNull],y.prototype,"currentToken",null),n([i(0,h.NotNull)],y.prototype,"enterRule",null),n([h.Override,i(0,h.Nullable)],y.prototype,"precpred",null),n([h.Override],y.prototype,"getErrorListenerDispatch",null),n([h.NotNull],y.prototype,"getExpectedTokens",null),n([h.NotNull],y.prototype,"getExpectedTokensWithinCurrentRule",null),n([h.Override],y.prototype,"parseInfo",null),e.Parser=y}).call(e,r(48))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0});const n=r(15);e.BlockStartState=class extends n.DecisionState{}},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(68),s=r(60),l=r(10),a=r(37),u=r(13),c=r(7),h=r(27),p=r(23),d=r(28),f=r(61),g=r(12),y=r(87),_=r(15),m=r(41),T=r(36),S=r(3),x=r(22),E=r(0),N=r(43),O=r(46),v=r(6),b=r(16),A=r(4),C=r(40),R=r(91),I=r(24),P=r(45),D=r(18),k=r(44),L=r(64),w=r(2),M=r(21),F=r(5);let j=class t extends d.ATNSimulator{constructor(t,e){super(t),this.predictionMode=R.PredictionMode.LL,this.force_global_context=!1,this.always_try_local_context=!0,this.enable_global_context_dfa=!1,this.optimize_unique_closure=!0,this.optimize_ll1=!0,this.optimize_tail_calls=!0,this.tail_call_preserves_sll=!0,this.treat_sllk1_conflict_as_ambiguity=!1,this.reportAmbiguities=!1,this.userWantsCtxSensitive=!0,this._parser=e}getPredictionMode(){return this.predictionMode}setPredictionMode(t){this.predictionMode=t}reset(){}adaptivePredict(e,r,n,i){void 0===i&&(i=!1);let o,s=this.atn.decisionToDFA[r];if(F(null!=s),this.optimize_ll1&&!s.isPrecedenceDfa&&!s.isEmpty){let t=e.LA(1);if(t>=0&&t<=65535){let e=(r<<16>>>0)+t,n=this.atn.LL1Table.get(e);if(null!=n)return n}}this.dfa=s,this.force_global_context?i=!0:this.always_try_local_context||(i=i||s.isContextSensitive),this.userWantsCtxSensitive=i||this.predictionMode!==R.PredictionMode.SLL&&null!=n&&!this.atn.decisionToState[r].sll,null==n&&(n=b.ParserRuleContext.emptyContext()),s.isEmpty||(o=this.getStartState(s,e,n,i)),null==o&&(null==n&&(n=b.ParserRuleContext.emptyContext()),t.debug&&console.log("ATN decision "+s.decision+" exec LA(1)=="+this.getLookaheadName(e)+", outerContext="+n.toString(this._parser)),o=this.computeStartState(s,n,i));let l=e.mark(),a=e.index;try{let r=this.execDFA(s,e,a,o);return t.debug&&console.log("DFA after predictATN: "+s.toString(this._parser.vocabulary,this._parser.ruleNames)),r}finally{this.dfa=void 0,e.seek(a),e.release(l)}}getStartState(t,e,r,n){if(!n){if(t.isPrecedenceDfa){let e=t.getPrecedenceStartState(this._parser.precedence,!1);if(null==e)return;return new L.SimulatorState(r,e,!1,r)}if(null==t.s0)return;return new L.SimulatorState(r,t.s0,!1,r)}if(!this.enable_global_context_dfa)return;let i,o=r;for(F(null!=r),i=t.isPrecedenceDfa?t.getPrecedenceStartState(this._parser.precedence,!0):t.s0full;null!=o&&null!=i&&i.isContextSensitive;)o=this.skipTailCalls(o),i=i.getContextTarget(this.getReturnState(o)),o.isEmpty?F(null==i||!i.isContextSensitive):o=o.parent;return null!=i?new L.SimulatorState(r,i,n,o):void 0}execDFA(e,r,n,i){let o=i.outerContext;t.dfa_debug&&console.log("DFA decision "+e.decision+" exec LA(1)=="+this.getLookaheadName(r)+", outerContext="+o.toString(this._parser)),t.dfa_debug&&console.log(e.toString(this._parser.vocabulary,this._parser.ruleNames));let s=i.s0,l=r.LA(1),a=i.remainingOuterContext;for(;;){if(t.dfa_debug&&console.log("DFA state "+s.stateNumber+" LA(1)=="+this.getLookaheadName(r)),i.useContext)for(;s.isContextSymbol(l);){let t;if(null!=a&&(a=this.skipTailCalls(a),t=s.getContextTarget(this.getReturnState(a))),null==t){let t=new L.SimulatorState(i.outerContext,s,i.useContext,a);return this.execATN(e,r,n,t)}F(null!=a),a=a.parent,s=t}if(this.isAcceptState(s,i.useContext)){null!=s.predicates?t.dfa_debug&&console.log("accept "+s):t.dfa_debug&&console.log("accept; predict "+s.prediction+" in state "+s.stateNumber);break}F(!this.isAcceptState(s,i.useContext));let u=this.getExistingTargetState(s,l);if(null==u){let u;if(t.dfa_debug&&l>=0&&console.log("no edge for "+this._parser.vocabulary.getDisplayName(l)),t.dfa_debug){let t=S.Interval.of(n,this._parser.inputStream.index);console.log("ATN exec upon "+this._parser.inputStream.getText(t)+" at DFA state "+s.stateNumber)}let c=new L.SimulatorState(o,s,i.useContext,a);return u=this.execATN(e,r,n,c),t.dfa_debug&&console.log("back from DFA update, alt="+u+", dfa=\n"+e.toString(this._parser.vocabulary,this._parser.ruleNames)),t.dfa_debug&&console.log("DFA decision "+e.decision+" predicts "+u),u}if(u===d.ATNSimulator.ERROR){let t=new L.SimulatorState(o,s,i.useContext,a);return this.handleNoViableAlt(r,n,t)}s=u,this.isAcceptState(s,i.useContext)||l===x.IntStream.EOF||(r.consume(),l=r.LA(1))}if(!i.useContext&&null!=s.configs.conflictInfo&&e.atnStartState instanceof _.DecisionState&&!(!this.userWantsCtxSensitive||!s.configs.dipsIntoOuterContext&&s.configs.isExactConflict||this.treat_sllk1_conflict_as_ambiguity&&r.index===n)){let t;F(!i.useContext);let l=s.predicates;if(null!=l){let e=r.index;if(e!==n&&r.seek(n),1===(t=this.evalSemanticContext(l,o,!0)).cardinality())return t.nextSetBit(0);e!==n&&r.seek(e)}if(this.reportAmbiguities){let l=new L.SimulatorState(o,s,i.useContext,a);this.reportAttemptingFullContext(e,t,l,n,r.index)}return r.seek(n),this.adaptivePredict(r,e.decision,o,!0)}let u=s.predicates;if(null!=u){let t=r.index;n!==t&&r.seek(n);let i=this.evalSemanticContext(u,o,this.reportAmbiguities&&this.predictionMode===R.PredictionMode.LL_EXACT_AMBIG_DETECTION);switch(i.cardinality()){case 0:throw this.noViableAlt(r,o,s.configs,n);case 1:return i.nextSetBit(0);default:return n!==t&&r.seek(t),this.reportAmbiguity(e,s,n,t,s.configs.isExactConflict,i,s.configs),i.nextSetBit(0)}}return t.dfa_debug&&console.log("DFA decision "+e.decision+" predicts "+s.prediction),s.prediction}isAcceptState(t,e){return!!t.isAcceptState&&(null==t.configs.conflictingAlts||(!e||this.predictionMode!==R.PredictionMode.LL_EXACT_AMBIG_DETECTION||t.configs.isExactConflict))}execATN(e,r,n,i){t.debug&&console.log("execATN decision "+e.decision+" exec LA(1)=="+this.getLookaheadName(r));let o=i.outerContext,s=i.useContext,l=r.LA(1),a=i,u=new C.PredictionContextCache;for(;;){let i=this.computeReachSet(e,a,l,u);if(null==i)return this.setDFAEdge(a.s0,r.LA(1),d.ATNSimulator.ERROR),this.handleNoViableAlt(r,n,a);let h=i.s0;if(F(h.isAcceptState||h.prediction===c.ATN.INVALID_ALT_NUMBER),F(h.isAcceptState||null==h.configs.conflictInfo),this.isAcceptState(h,s)){let a=h.configs.conflictingAlts,u=null==a?h.prediction:c.ATN.INVALID_ALT_NUMBER;if(u!==c.ATN.INVALID_ALT_NUMBER){if(this.optimize_ll1&&r.index===n&&!e.isPrecedenceDfa&&i.outerContext===i.remainingOuterContext&&e.decision>=0&&!h.configs.hasSemanticContext&&l>=0&&l<=65535){let t=(e.decision<<16>>>0)+l;this.atn.LL1Table.set(t,u)}s&&this.always_try_local_context&&this.reportContextSensitivity(e,u,i,n,r.index)}u=h.prediction;let p=null!=a&&this.userWantsCtxSensitive;if(p&&(p=!s&&(h.configs.dipsIntoOuterContext||!h.configs.isExactConflict)&&(!this.treat_sllk1_conflict_as_ambiguity||r.index!==n)),h.configs.hasSemanticContext){let t=h.predicates;if(null!=t){let e=r.index;switch(e!==n&&r.seek(n),(a=this.evalSemanticContext(t,o,p||this.reportAmbiguities)).cardinality()){case 0:throw this.noViableAlt(r,o,h.configs,n);case 1:return a.nextSetBit(0)}e!==n&&r.seek(e)}}if(p){F(!s),F(this.isAcceptState(h,!1)),t.debug&&console.log("RETRY with outerContext="+o);let l=this.computeStartState(e,o,!0);return this.reportAmbiguities&&this.reportAttemptingFullContext(e,a,i,n,r.index),r.seek(n),this.execATN(e,r,n,l)}return null!=a&&(this.reportAmbiguities&&a.cardinality()>1&&this.reportAmbiguity(e,h,n,r.index,h.configs.isExactConflict,a,h.configs),u=a.nextSetBit(0)),u}a=i,l!==x.IntStream.EOF&&(r.consume(),l=r.LA(1))}}handleNoViableAlt(t,e,r){if(null!=r.s0){let n=new g.BitSet,i=0;for(let t of u.asIterable(r.s0.configs))(t.reachesIntoOuterContext||t.state instanceof I.RuleStopState)&&(n.set(t.alt),i=Math.max(i,t.alt));switch(n.cardinality()){case 0:break;case 1:return n.nextSetBit(0);default:if(!r.s0.configs.hasSemanticContext)return n.nextSetBit(0);let o=new p.ATNConfigSet;for(let t of u.asIterable(r.s0.configs))(t.reachesIntoOuterContext||t.state instanceof I.RuleStopState)&&o.add(t);let s=this.getPredsForAmbigAlts(n,o,i);if(null!=s){let i=this.getPredicatePredictions(n,s);if(null!=i){let n=t.index;try{t.seek(e);let o=this.evalSemanticContext(i,r.outerContext,!1);if(!o.isEmpty)return o.nextSetBit(0)}finally{t.seek(n)}}}return n.nextSetBit(0)}}throw this.noViableAlt(t,r.outerContext,r.s0.configs,e)}computeReachSet(t,e,r,n){let i=e.useContext,o=e.remainingOuterContext,s=e.s0;if(i)for(;s.isContextSymbol(r);){let t;if(null!=o&&(o=this.skipTailCalls(o),t=s.getContextTarget(this.getReturnState(o))),null==t)break;F(null!=o),o=o.parent,s=t}if(F(!this.isAcceptState(s,i)),this.isAcceptState(s,i))return new L.SimulatorState(e.outerContext,s,i,o);let l=s,a=this.getExistingTargetState(l,r);if(null==a){let e=this.computeTargetState(t,l,o,r,i,n);a=e[0],o=e[1]}return a!==d.ATNSimulator.ERROR?(F(!i||!a.configs.dipsIntoOuterContext),new L.SimulatorState(e.outerContext,a,i,o)):void 0}getExistingTargetState(t,e){return t.getTarget(e)}computeTargetState(e,r,n,i,o,s){let l,a,u=r.configs.toArray(),h=new p.ATNConfigSet;do{let e=!o||null!=n;e||(h.isOutermostConfigSet=!0);let r,d=new p.ATNConfigSet;for(let e of u){if(t.debug&&console.log("testing "+this.getTokenName(i)+" at "+e.toString()),e.state instanceof I.RuleStopState){F(e.context.isEmpty),(o&&!e.reachesIntoOuterContext||i===x.IntStream.EOF)&&(null==r&&(r=[]),r.push(e));continue}let n=e.state.numberOfOptimizedTransitions;for(let t=0;t<n;t++){let r=e.state.getOptimizedTransition(t),n=this.getReachableTarget(e,r,i);null!=n&&d.add(e.transform(n,!1),s)}}if(this.optimize_unique_closure&&null==r&&i!==w.Token.EOF&&d.uniqueAlt!==c.ATN.INVALID_ALT_NUMBER){d.isOutermostConfigSet=h.isOutermostConfigSet,h=d;break}let f=!1,g=i===w.Token.EOF;if(this.closure(d,h,f,e,s,g),a=h.dipsIntoOuterContext,i===x.IntStream.EOF&&(h=this.removeAllConfigsNotInRuleStopState(h,s)),!(null==r||o&&R.PredictionMode.hasConfigInRuleStopState(h))){F(r.length>0);for(let t of r)h.add(t,s)}if(o&&a){h.clear(),n=n,n=this.skipTailCalls(n);let t=this.getReturnState(n);if(null==l&&(l=new T.IntegerList),n=n.isEmpty?void 0:n.parent,l.add(t),t!==A.PredictionContext.EMPTY_FULL_STATE_KEY)for(let e=0;e<u.length;e++)u[e]=u[e].appendContext(t,s)}}while(o&&a);return h.isEmpty?(this.setDFAEdge(r,i,d.ATNSimulator.ERROR),[d.ATNSimulator.ERROR,n]):[this.addDFAEdge(e,r,i,l,h,s),n]}removeAllConfigsNotInRuleStopState(t,e){if(R.PredictionMode.allConfigsInRuleStopStates(t))return t;let r=new p.ATNConfigSet;for(let n of u.asIterable(t))n.state instanceof I.RuleStopState&&r.add(n,e);return r}computeStartState(t,e,r){let n=t.isPrecedenceDfa?t.getPrecedenceStartState(this._parser.precedence,r):r?t.s0full:t.s0;if(null!=n){if(!r)return new L.SimulatorState(e,n,r,e);n.setContextSensitive(this.atn)}t.decision;let i=t.atnStartState,o=0,s=e,l=r?A.PredictionContext.EMPTY_FULL:A.PredictionContext.EMPTY_LOCAL,a=new C.PredictionContextCache;if(r){if(!this.enable_global_context_dfa)for(;null!=s;)s.isEmpty?(o=A.PredictionContext.EMPTY_FULL_STATE_KEY,s=void 0):(o=this.getReturnState(s),l=l.appendSingleContext(o,a),s=s.parent);for(;null!=n&&n.isContextSensitive&&null!=s;){let t;if((s=this.skipTailCalls(s)).isEmpty?(t=n.getContextTarget(A.PredictionContext.EMPTY_FULL_STATE_KEY),o=A.PredictionContext.EMPTY_FULL_STATE_KEY,s=void 0):(o=this.getReturnState(s),t=n.getContextTarget(o),l=l.appendSingleContext(o,a),s=s.parent),null==t)break;n=t}}if(null!=n&&!n.isContextSensitive)return new L.SimulatorState(e,n,r,s);let u=new p.ATNConfigSet;for(;;){let c=new p.ATNConfigSet,d=i.numberOfTransitions;for(let t=0;t<d;t++){let e=i.transition(t).target;c.add(h.ATNConfig.create(e,t+1,l))}let f=null!=s;f||(u.isOutermostConfigSet=!0);let g=!0;this.closure(c,u,g,f,a,!1);let y,_=u.dipsIntoOuterContext;if(r&&!this.enable_global_context_dfa){n=this.addDFAState(t,u,a);break}if(null==n?t.isPrecedenceDfa?(u=this.applyPrecedenceFilter(u,e,a),y=this.addDFAState(t,u,a),t.setPrecedenceStartState(this._parser.precedence,r,y)):(y=this.addDFAState(t,u,a),r?t.s0full?y=t.s0full:t.s0full=y:t.s0?y=t.s0:t.s0=y):(t.isPrecedenceDfa&&(u=this.applyPrecedenceFilter(u,e,a)),y=this.addDFAState(t,u,a),n.setContextTarget(o,y)),n=y,!r||!_)break;y.setContextSensitive(this.atn),s=s,u.clear(),s=this.skipTailCalls(s);let m=this.getReturnState(s);s=s.isEmpty?void 0:s.parent,m!==A.PredictionContext.EMPTY_FULL_STATE_KEY&&(l=l.appendSingleContext(m,a)),o=m}return new L.SimulatorState(e,n,r,s)}applyPrecedenceFilter(t,e,r){let n=new Map,i=new p.ATNConfigSet;for(let o of u.asIterable(t)){if(1!==o.alt)continue;let t=o.semanticContext.evalPrecedence(this._parser,e);null!=t&&(n.set(o.state.stateNumber,o.context),t!==o.semanticContext?i.add(o.transform(o.state,!1,t),r):i.add(o,r))}for(let e of u.asIterable(t))if(1!==e.alt){if(!e.isPrecedenceFilterSuppressed){let t=n.get(e.state.stateNumber);if(null!=t&&t.equals(e.context))continue}i.add(e,r)}return i}getReachableTarget(t,e,r){if(e.matches(r,0,this.atn.maxTokenType))return e.target}predicateDFAState(e,r,n){let i=this.getConflictingAltsFromConfigSet(r);if(!i)throw new Error("This unhandled scenario is intended to be unreachable, but I'm currently not sure of why we know that's the case.");t.debug&&console.log("predicateDFAState "+e);let o,s=this.getPredsForAmbigAlts(i,r,n);return null!=s&&(o=this.getPredicatePredictions(i,s),e.predicates=o),o}getPredsForAmbigAlts(e,r,n){let i=new Array(n+1),o=i.length;for(let t of u.asIterable(r))e.get(t.alt)&&(i[t.alt]=D.SemanticContext.or(i[t.alt],t.semanticContext));let s=0;for(let t=0;t<o;t++)null==i[t]?i[t]=D.SemanticContext.NONE:i[t]!==D.SemanticContext.NONE&&s++;let l=i;return 0===s&&(l=void 0),t.debug&&console.log("getPredsForAmbigAlts result "+(l?a.Arrays.toString(l):"undefined")),l}getPredicatePredictions(t,e){let r=[],n=!1;for(let i=1;i<e.length;i++){let o=e[i];F(null!=o),null!=t&&t.get(i)&&o===D.SemanticContext.NONE?r.push(new m.DFAState.PredPrediction(o,i)):o!==D.SemanticContext.NONE&&(n=!0,r.push(new m.DFAState.PredPrediction(o,i)))}if(n)return r}evalSemanticContext(e,r,n){let i=new g.BitSet;for(let o of e){if(o.pred===D.SemanticContext.NONE){if(i.set(o.alt),!n)break;continue}let e=this.evalSemanticContextImpl(o.pred,r,o.alt);if((t.debug||t.dfa_debug)&&console.log("eval pred "+o+"="+e),e&&((t.debug||t.dfa_debug)&&console.log("PREDICT "+o.alt),i.set(o.alt),!n))break}return i}evalSemanticContextImpl(t,e,r){return t.eval(this._parser,e)}closure(t,e,r,n,i,o){null==i&&(i=C.PredictionContextCache.UNCACHED);let s=t,a=new l.Array2DHashSet(v.ObjectEqualityComparator.INSTANCE);for(;s.size>0;){let t=new p.ATNConfigSet;for(let l of u.asIterable(s))this.closureImpl(l,e,t,a,r,n,i,0,o);s=t}}closureImpl(e,r,n,i,o,l,a,u,c){if(t.debug&&console.log("closure("+e.toString(this._parser,!0)+")"),e.state instanceof I.RuleStopState)if(e.context.isEmpty){if(!l)return void r.add(e,a);t.debug&&console.log("FALLING off rule "+this.getRuleName(e.state.ruleIndex)),e.context===A.PredictionContext.EMPTY_FULL?e=e.transform(e.state,!1,A.PredictionContext.EMPTY_LOCAL):!e.reachesIntoOuterContext&&A.PredictionContext.isEmptyLocal(e.context)&&r.add(e,a)}else{let t=e.context.hasEmpty,s=e.context.size-(t?1:0);for(let t=0;t<s;t++){let s=e.context.getParent(t),p=this.atn.states[e.context.getReturnState(t)],d=h.ATNConfig.create(p,e.alt,s,e.semanticContext);d.outerContextDepth=e.outerContextDepth,d.isPrecedenceFilterSuppressed=e.isPrecedenceFilterSuppressed,F(u>-2147483648),this.closureImpl(d,r,n,i,o,l,a,u-1,c)}if(!t||!l)return;e=e.transform(e.state,!1,A.PredictionContext.EMPTY_LOCAL)}let p=e.state;p.onlyHasEpsilonTransitions||(r.add(e,a),t.debug&&console.log("added config "+r));for(let h=0;h<p.numberOfOptimizedTransitions;h++){if(0===h&&10===p.stateType&&p.precedenceRuleDecision&&!e.context.hasEmpty){let t=p,r=!0;for(let n=0;n<e.context.size;n++)if(!t.precedenceLoopbackStates.get(e.context.getReturnState(n))){r=!1;break}if(r)continue}let d=p.getOptimizedTransition(h),f=!(d instanceof s.ActionTransition)&&o,g=this.getEpsilonTarget(e,d,f,0===u,a,c);if(null!=g){if(d instanceof P.RuleTransition&&null!=n&&!o){n.add(g,a);continue}if(!d.isEpsilon&&!i.add(g))continue;let s=u;if(e.state instanceof I.RuleStopState){if(!i.add(g))continue;if(null!=this.dfa&&this.dfa.isPrecedenceDfa){d.outermostPrecedenceReturn==this.dfa.atnStartState.ruleIndex&&(g.isPrecedenceFilterSuppressed=!0)}g.outerContextDepth=g.outerContextDepth+1,F(s>-2147483648),s--,t.debug&&console.log("dips into outer ctx: "+g)}else d instanceof P.RuleTransition&&(!this.optimize_tail_calls||!d.optimizedTailCall||this.tail_call_preserves_sll&&A.PredictionContext.isEmptyLocal(e.context)?s>=0&&s++:(F(g.context===e.context),0===s&&(s--,!this.tail_call_preserves_sll&&A.PredictionContext.isEmptyLocal(e.context)&&(g.outerContextDepth=g.outerContextDepth+1))));this.closureImpl(g,r,n,i,f,l,a,s,c)}}}getRuleName(t){return null!=this._parser&&t>=0?this._parser.ruleNames[t]:"<rule "+t+">"}getEpsilonTarget(t,e,r,n,i,o){switch(e.serializationType){case 3:return this.ruleTransition(t,e,i);case 10:return this.precedenceTransition(t,e,r,n);case 4:return this.predTransition(t,e,r,n);case 6:return this.actionTransition(t,e);case 1:return t.transform(e.target,!1);case 5:case 2:case 7:return o&&e.matches(w.Token.EOF,0,1)?t.transform(e.target,!1):void 0;default:return}}actionTransition(e,r){return t.debug&&console.log("ACTION edge "+r.ruleIndex+":"+r.actionIndex),e.transform(r.target,!1)}precedenceTransition(e,r,n,i){let o;if(t.debug&&(console.log("PRED (collectPredicates="+n+") "+r.precedence+">=_p, ctx dependent=true"),null!=this._parser&&console.log("context surrounding pred is "+this._parser.getRuleInvocationStack())),n&&i){let t=D.SemanticContext.and(e.semanticContext,r.predicate);o=e.transform(r.target,!1,t)}else o=e.transform(r.target,!1);return t.debug&&console.log("config from pred transition="+o),o}predTransition(e,r,n,i){let o;if(t.debug&&(console.log("PRED (collectPredicates="+n+") "+r.ruleIndex+":"+r.predIndex+", ctx dependent="+r.isCtxDependent),null!=this._parser&&console.log("context surrounding pred is "+this._parser.getRuleInvocationStack())),n&&(!r.isCtxDependent||r.isCtxDependent&&i)){let t=D.SemanticContext.and(e.semanticContext,r.predicate);o=e.transform(r.target,!1,t)}else o=e.transform(r.target,!1);return t.debug&&console.log("config from pred transition="+o),o}ruleTransition(e,r,n){t.debug&&console.log("CALL rule "+this.getRuleName(r.target.ruleIndex)+", ctx="+e.context);let i,o=r.followState;return i=!this.optimize_tail_calls||!r.optimizedTailCall||this.tail_call_preserves_sll&&A.PredictionContext.isEmptyLocal(e.context)?null!=n?n.getChild(e.context,o.stateNumber):e.context.getChild(o.stateNumber):e.context,e.transform(r.target,!1,i)}isConflicted(e,r){if(e.uniqueAlt!==c.ATN.INVALID_ALT_NUMBER||e.size<=1)return;let n=e.toArray();n.sort(t.STATE_ALT_SORT_COMPARATOR);let i=!e.dipsIntoOuterContext,o=new g.BitSet,s=n[0].alt;o.set(s);let l,a=n[0].state.nonStopStateNumber;for(let t of n){let e=t.state.nonStopStateNumber;if(e!==a){if(t.alt!==s)return;a=e}}if(i){a=n[0].state.nonStopStateNumber,l=new g.BitSet;let t=s;for(let e of n){if(e.state.nonStopStateNumber!=a)break;let r=e.alt;l.set(r),t=r}a=n[0].state.nonStopStateNumber;let e=s;for(let r of n){let n=r.state.nonStopStateNumber,o=r.alt;if(n!==a){if(e!==t){i=!1;break}a=n,e=s}else if(o!==e){if(o!==l.nextSetBit(e+1)){i=!1;break}e=o}}}a=n[0].state.nonStopStateNumber;let u=0,h=0,p=n[0].context;for(let t=1;t<n.length;t++){let e=n[t];if(e.alt!==s)break;if(e.state.nonStopStateNumber!==a)break;h=t,p=r.join(p,n[t].context)}for(let t=h+1;t<n.length;t++){let e=n[t],l=e.state;if(o.set(e.alt),l.nonStopStateNumber!==a){a=l.nonStopStateNumber,u=t,h=t,p=e.context;for(let t=u+1;t<n.length;t++){let e=n[t];if(e.alt!==s)break;if(e.state.nonStopStateNumber!==a)break;h=t,p=r.join(p,e.context)}t=h;continue}let c=e.context,d=e.alt,f=t;for(let t=f+1;t<n.length;t++){let e=n[t];if(e.alt!==d)break;if(e.state.nonStopStateNumber!==a)break;f=t,c=r.join(c,e.context)}t=f;let g=r.join(p,c);if(!p.equals(g))return;i=i&&p.equals(c)}return new y.ConflictInfo(o,i)}getConflictingAltsFromConfigSet(t){let e=t.conflictingAlts;return null==e&&t.uniqueAlt!==c.ATN.INVALID_ALT_NUMBER&&(e=new g.BitSet).set(t.uniqueAlt),e}getTokenName(t){if(t===w.Token.EOF)return"EOF";let e=(null!=this._parser?this._parser.vocabulary:M.VocabularyImpl.EMPTY_VOCABULARY).getDisplayName(t);return e===String(t)?e:e+"<"+t+">"}getLookaheadName(t){return this.getTokenName(t.LA(1))}dumpDeadEndConfigs(t){console.log("dead end configs: ");let e=t.deadEndConfigs;if(e)for(let t of u.asIterable(e)){let e="no edges";if(t.state.numberOfOptimizedTransitions>0){let r=t.state.getOptimizedTransition(0);if(r instanceof f.AtomTransition)e="Atom "+this.getTokenName(r._label);else if(r instanceof k.SetTransition){e=(r instanceof N.NotSetTransition?"~":"")+"Set "+r.set.toString()}}console.log(t.toString(this._parser,!0)+":"+e)}}noViableAlt(t,e,r,n){return new O.NoViableAltException(this._parser,t,t.get(n),t.LT(1),r,e)}getUniqueAlt(t){let e=c.ATN.INVALID_ALT_NUMBER;for(let r of u.asIterable(t))if(e===c.ATN.INVALID_ALT_NUMBER)e=r.alt;else if(r.alt!==e)return c.ATN.INVALID_ALT_NUMBER;return e}configWithAltAtStopState(t,e){for(let r of u.asIterable(t))if(r.alt===e&&r.state instanceof I.RuleStopState)return!0;return!1}addDFAEdge(e,r,n,i,o,s){F(null==i||i.isEmpty||e.isContextSensitive);let l=r,a=this.addDFAState(e,o,s);if(null!=i)for(let t of i.toArray()){if(t===A.PredictionContext.EMPTY_FULL_STATE_KEY&&l.configs.isOutermostConfigSet)continue;l.setContextSensitive(this.atn),l.setContextSymbol(n);let r=l.getContextTarget(t);null==r?(r=this.addDFAContextState(e,l.configs,t,s),F(t!==A.PredictionContext.EMPTY_FULL_STATE_KEY||r.configs.isOutermostConfigSet),l.setContextTarget(t,r),l=r):l=r}return t.debug&&console.log("EDGE "+l+" -> "+a+" upon "+this.getTokenName(n)),this.setDFAEdge(l,n,a),t.debug&&console.log("DFA=\n"+e.toString(null!=this._parser?this._parser.vocabulary:M.VocabularyImpl.EMPTY_VOCABULARY,null!=this._parser?this._parser.ruleNames:void 0)),a}setDFAEdge(t,e,r){null!=t&&t.setTarget(e,r)}addDFAContextState(t,e,r,n){if(r!==A.PredictionContext.EMPTY_FULL_STATE_KEY){let i=new p.ATNConfigSet;for(let t of u.asIterable(e))i.add(t.appendContext(r,n));return this.addDFAState(t,i,n)}return F(!e.isOutermostConfigSet,"Shouldn't be adding a duplicate edge."),(e=e.clone(!0)).isOutermostConfigSet=!0,this.addDFAState(t,e,n)}addDFAState(e,r,n){let i=this.enable_global_context_dfa||!r.isOutermostConfigSet;if(i){r.isReadOnly||r.optimizeConfigs(this);let t=this.createDFAState(e,r),n=e.states.get(t);if(null!=n)return n}r.isReadOnly||null==r.conflictInfo&&(r.conflictInfo=this.isConflicted(r,n));let s=this.createDFAState(e,r.clone(!0)),l=this.atn.getDecisionState(e.decision),a=this.getUniqueAlt(r);if(a!==c.ATN.INVALID_ALT_NUMBER)s.acceptStateInfo=new o.AcceptStateInfo(a);else if(null!=r.conflictingAlts){let t=r.conflictingAlts;t&&(s.acceptStateInfo=new o.AcceptStateInfo(t.nextSetBit(0)))}if(s.isAcceptState&&r.hasSemanticContext&&this.predicateDFAState(s,r,l.numberOfTransitions),!i)return s;let u=e.addState(s);return t.debug&&u===s&&console.log("adding new DFA state: "+s),u}createDFAState(t,e){return new m.DFAState(e)}reportAttemptingFullContext(e,r,n,i,o){if(t.debug||t.retry_debug){let t=S.Interval.of(i,o);console.log("reportAttemptingFullContext decision="+e.decision+":"+n.s0.configs+", input="+this._parser.inputStream.getText(t))}if(null!=this._parser){let t=this._parser.getErrorListenerDispatch();t.reportAttemptingFullContext&&t.reportAttemptingFullContext(this._parser,e,i,o,r,n)}}reportContextSensitivity(e,r,n,i,o){if(t.debug||t.retry_debug){let t=S.Interval.of(i,o);console.log("reportContextSensitivity decision="+e.decision+":"+n.s0.configs+", input="+this._parser.inputStream.getText(t))}if(null!=this._parser){let t=this._parser.getErrorListenerDispatch();t.reportContextSensitivity&&t.reportContextSensitivity(this._parser,e,i,o,r,n)}}reportAmbiguity(e,r,n,i,o,s,l){if(t.debug||t.retry_debug){let t=S.Interval.of(n,i);console.log("reportAmbiguity "+s+":"+l+", input="+this._parser.inputStream.getText(t))}if(null!=this._parser){let t=this._parser.getErrorListenerDispatch();t.reportAmbiguity&&t.reportAmbiguity(this._parser,e,n,i,o,s,l)}}getReturnState(t){if(t.isEmpty)return A.PredictionContext.EMPTY_FULL_STATE_KEY;return this.atn.states[t.invokingState].transition(0).followState.stateNumber}skipTailCalls(t){if(!this.optimize_tail_calls)return t;for(;!t.isEmpty;){let e=this.atn.states[t.invokingState];if(F(1===e.numberOfTransitions&&3===e.transition(0).serializationType),!e.transition(0).tailCall)break;t=t.parent}return t}get parser(){return this._parser}};j.debug=!1,j.dfa_debug=!1,j.retry_debug=!1,j.STATE_ALT_SORT_COMPARATOR=((t,e)=>{let r=t.state.nonStopStateNumber-e.state.nonStopStateNumber;return 0!==r?r:0!==(r=t.alt-e.alt)?r:0}),n([E.NotNull],j.prototype,"predictionMode",void 0),n([E.NotNull],j.prototype,"getPredictionMode",null),n([i(0,E.NotNull)],j.prototype,"setPredictionMode",null),n([E.Override],j.prototype,"reset",null),n([i(0,E.NotNull)],j.prototype,"adaptivePredict",null),n([i(0,E.NotNull),i(1,E.NotNull),i(2,E.NotNull)],j.prototype,"getStartState",null),n([i(0,E.NotNull),i(1,E.NotNull),i(3,E.NotNull)],j.prototype,"execDFA",null),n([i(0,E.NotNull),i(1,E.NotNull),i(3,E.NotNull)],j.prototype,"execATN",null),n([i(0,E.NotNull),i(2,E.NotNull)],j.prototype,"handleNoViableAlt",null),n([i(0,E.NotNull)],j.prototype,"getExistingTargetState",null),n([E.NotNull,i(0,E.NotNull),i(1,E.NotNull)],j.prototype,"computeTargetState",null),n([E.NotNull,i(0,E.NotNull)],j.prototype,"removeAllConfigsNotInRuleStopState",null),n([E.NotNull],j.prototype,"computeStartState",null),n([E.NotNull,i(0,E.NotNull)],j.prototype,"applyPrecedenceFilter",null),n([i(0,E.NotNull),i(1,E.NotNull)],j.prototype,"getReachableTarget",null),n([i(0,E.NotNull),i(1,E.NotNull)],j.prototype,"getPredsForAmbigAlts",null),n([i(0,E.NotNull)],j.prototype,"evalSemanticContext",null),n([i(0,E.NotNull)],j.prototype,"evalSemanticContextImpl",null),n([i(1,E.NotNull),i(4,E.Nullable)],j.prototype,"closure",null),n([i(0,E.NotNull),i(1,E.NotNull),i(2,E.Nullable),i(3,E.NotNull),i(6,E.NotNull)],j.prototype,"closureImpl",null),n([E.NotNull],j.prototype,"getRuleName",null),n([i(0,E.NotNull),i(1,E.NotNull)],j.prototype,"getEpsilonTarget",null),n([E.NotNull,i(0,E.NotNull),i(1,E.NotNull)],j.prototype,"actionTransition",null),n([E.Nullable,i(0,E.NotNull),i(1,E.NotNull)],j.prototype,"precedenceTransition",null),n([E.Nullable,i(0,E.NotNull),i(1,E.NotNull)],j.prototype,"predTransition",null),n([E.NotNull,i(0,E.NotNull),i(1,E.NotNull),i(2,E.Nullable)],j.prototype,"ruleTransition",null),n([i(0,E.NotNull)],j.prototype,"isConflicted",null),n([E.NotNull],j.prototype,"getTokenName",null),n([i(0,E.NotNull)],j.prototype,"dumpDeadEndConfigs",null),n([E.NotNull,i(0,E.NotNull),i(1,E.NotNull),i(2,E.NotNull)],j.prototype,"noViableAlt",null),n([i(0,E.NotNull)],j.prototype,"getUniqueAlt",null),n([i(0,E.NotNull)],j.prototype,"configWithAltAtStopState",null),n([E.NotNull,i(0,E.NotNull),i(1,E.NotNull),i(4,E.NotNull)],j.prototype,"addDFAEdge",null),n([i(0,E.Nullable),i(2,E.Nullable)],j.prototype,"setDFAEdge",null),n([E.NotNull,i(0,E.NotNull),i(1,E.NotNull)],j.prototype,"addDFAContextState",null),n([E.NotNull,i(0,E.NotNull),i(1,E.NotNull)],j.prototype,"addDFAState",null),n([E.NotNull,i(0,E.NotNull),i(1,E.NotNull)],j.prototype,"createDFAState",null),n([i(0,E.NotNull),i(2,E.NotNull)],j.prototype,"reportAttemptingFullContext",null),n([i(0,E.NotNull),i(2,E.NotNull)],j.prototype,"reportContextSensitivity",null),n([i(0,E.NotNull),i(5,E.NotNull),i(6,E.NotNull)],j.prototype,"reportAmbiguity",null),j=n([i(0,E.NotNull)],j),e.ParserATNSimulator=j},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(17),s=r(0),l=r(50);let a=class t extends o.RecognitionException{constructor(e,r,n){super(e,e.inputStream,e.context,t.formatMessage(r,n));let i=e.interpreter.atn.states[e.state].transition(0);i instanceof l.PredicateTransition?(this._ruleIndex=i.ruleIndex,this._predicateIndex=i.predIndex):(this._ruleIndex=0,this._predicateIndex=0),this._predicate=r,super.setOffendingToken(e,e.currentToken)}get ruleIndex(){return this._ruleIndex}get predicateIndex(){return this._predicateIndex}get predicate(){return this._predicate}static formatMessage(t,e){return e||`failed predicate: {${t}}?`}};n([s.NotNull],a,"formatMessage",null),a=n([i(0,s.NotNull)],a),e.FailedPredicateException=a},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0});const n=r(9);e.AbstractPredicateTransition=class extends n.Transition{constructor(t){super(t)}}},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(17);let s=class extends o.RecognitionException{constructor(t){super(t,t.inputStream,t.context),super.setOffendingToken(t,t.currentToken)}};s=n([i(0,r(0).NotNull)],s),e.InputMismatchException=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(37),o=r(0),s=new Int32Array(0),l=4,a=2147483639;class u{constructor(t){if(t)if(t instanceof u)this._data=t._data.slice(0),this._size=t._size;else if("number"==typeof t)0===t?(this._data=s,this._size=0):(this._data=new Int32Array(t),this._size=0);else{this._data=s,this._size=0;for(let e of t)this.add(e)}else this._data=s,this._size=0}add(t){this._data.length===this._size&&this.ensureCapacity(this._size+1),this._data[this._size]=t,this._size++}addAll(t){if(Array.isArray(t))this.ensureCapacity(this._size+t.length),this._data.subarray(this._size,this._size+t.length).set(t),this._size+=t.length;else if(t instanceof u)this.ensureCapacity(this._size+t._size),this._data.subarray(this._size,this._size+t.size).set(t._data),this._size+=t._size;else{this.ensureCapacity(this._size+t.size);let e=0;for(let r=t.iterator();r.hasNext();)this._data[this._size+e]=r.next(),e++;this._size+=t.size}}get(t){if(t<0||t>=this._size)throw RangeError();return this._data[t]}contains(t){for(let e=0;e<this._size;e++)if(this._data[e]===t)return!0;return!1}set(t,e){if(t<0||t>=this._size)throw RangeError();let r=this._data[t];return this._data[t]=e,r}removeAt(t){let e=this.get(t);return this._data.copyWithin(t,t+1,this._size),this._data[this._size-1]=0,this._size--,e}removeRange(t,e){if(t<0||e<0||t>this._size||e>this._size)throw RangeError();if(t>e)throw RangeError();this._data.copyWithin(e,t,this._size),this._data.fill(0,this._size-(e-t),this._size),this._size-=e-t}get isEmpty(){return 0===this._size}get size(){return this._size}trimToSize(){this._data.length!==this._size&&(this._data=this._data.slice(0,this._size))}clear(){this._data.fill(0,0,this._size),this._size=0}toArray(){return 0===this._size?[]:Array.from(this._data.subarray(0,this._size))}sort(){this._data.subarray(0,this._size).sort()}equals(t){if(t===this)return!0;if(!(t instanceof u))return!1;if(this._size!==t._size)return!1;for(let e=0;e<this._size;e++)if(this._data[e]!==t._data[e])return!1;return!0}hashCode(){let t=1;for(let e=0;e<this._size;e++)t=31*t+this._data[e];return t}toString(){return this._data.toString()}binarySearch(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this._size),e<0||r<0||e>this._size||r>this._size)throw new RangeError;if(e>r)throw new RangeError;return i.Arrays.binarySearch(this._data,t,e,r)}ensureCapacity(t){if(t<0||t>a)throw new RangeError;let e;for(e=0===this._data.length?l:this._data.length;e<t;)((e*=2)<0||e>a)&&(e=a);let r=new Int32Array(e);r.set(this._data),this._data=r}}n([o.NotNull],u.prototype,"_data",void 0),n([o.Override],u.prototype,"equals",null),n([o.Override],u.prototype,"hashCode",null),n([o.Override],u.prototype,"toString",null),e.IntegerList=u},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0}),function(t){t.binarySearch=function(t,e,r,n){return function(t,e,r,n){let i=e,o=r-1;for(;i<=o;){let e=i+o>>>1,r=t[e];if(r<n)i=e+1;else{if(!(r>n))return e;o=e-1}}return-(i+1)}(t,void 0!==r?r:0,void 0!==n?n:t.length,e)},t.toString=function(t){let e="[",r=!0;for(let n=0;n<t.length;n++){r?r=!1:e+=", ";let i=t[n];e+=null===i?"null":void 0===i?"undefined":i}return e+="]"}}(e.Arrays||(e.Arrays={}))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(3),s=r(0),l=r(2);let a=class t{constructor(e,r,n=t.EMPTY_SOURCE,i=l.Token.DEFAULT_CHANNEL,o=0,s=0){this._line=0,this._charPositionInLine=-1,this._channel=l.Token.DEFAULT_CHANNEL,this.index=-1,this._text=r,this._type=e,this.source=n,this._channel=i,this.start=o,this.stop=s,null!=n.source&&(this._line=n.source.line,this._charPositionInLine=n.source.charPositionInLine)}static fromToken(e){let r=new t(e.type,void 0,t.EMPTY_SOURCE,e.channel,e.startIndex,e.stopIndex);return r._line=e.line,r.index=e.tokenIndex,r._charPositionInLine=e.charPositionInLine,e instanceof t?(r._text=e.text,r.source=e.source):(r._text=e.text,r.source={source:e.tokenSource,stream:e.inputStream}),r}get type(){return this._type}set line(t){this._line=t}get text(){if(null!=this._text)return this._text;let t=this.inputStream;if(null==t)return;let e=t.size;return this.start<e&&this.stop<e?t.getText(o.Interval.of(this.start,this.stop)):"<EOF>"}set text(t){this._text=t}get line(){return this._line}get charPositionInLine(){return this._charPositionInLine}set charPositionInLine(t){this._charPositionInLine=t}get channel(){return this._channel}set channel(t){this._channel=t}set type(t){this._type=t}get startIndex(){return this.start}set startIndex(t){this.start=t}get stopIndex(){return this.stop}set stopIndex(t){this.stop=t}get tokenIndex(){return this.index}set tokenIndex(t){this.index=t}get tokenSource(){return this.source.source}get inputStream(){return this.source.stream}toString(t){let e="";this._channel>0&&(e=",channel="+this._channel);let r=this.text;r=null!=r?(r=(r=r.replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/\t/g,"\\t"):"<no text>";let n=String(this._type);return t&&(n=t.vocabulary.getDisplayName(this._type)),"[@"+this.tokenIndex+","+this.start+":"+this.stop+"='"+r+"',<"+n+">"+e+","+this._line+":"+this.charPositionInLine+"]"}};a.EMPTY_SOURCE={source:void 0,stream:void 0},n([s.NotNull],a.prototype,"source",void 0),n([s.Override],a.prototype,"type",null),n([s.Override],a.prototype,"text",null),n([s.Override],a.prototype,"line",null),n([s.Override],a.prototype,"charPositionInLine",null),n([s.Override],a.prototype,"channel",null),n([s.Override],a.prototype,"startIndex",null),n([s.Override],a.prototype,"stopIndex",null),n([s.Override],a.prototype,"tokenIndex",null),n([s.Override],a.prototype,"tokenSource",null),n([s.Override],a.prototype,"inputStream",null),n([s.Override],a.prototype,"toString",null),n([i(0,s.NotNull)],a,"fromToken",null),a=n([i(2,s.NotNull)],a),e.CommonToken=a},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(68),s=r(13),l=r(7),a=r(27),u=r(23),c=r(28),h=r(41),p=r(3),d=r(22),f=r(19),g=r(73),y=r(58),_=r(0),m=r(75),T=r(4),S=r(24),x=r(2),E=r(5);let N=class t extends c.ATNSimulator{constructor(e,r){super(e),this.optimize_tail_calls=!0,this.startIndex=-1,this._line=1,this._charPositionInLine=0,this.mode=f.Lexer.DEFAULT_MODE,this.prevAccept=new t.SimState,this.recog=r}copyState(t){this._charPositionInLine=t.charPositionInLine,this._line=t._line,this.mode=t.mode,this.startIndex=t.startIndex}match(e,r){t.match_calls++,this.mode=r;let n=e.mark();try{this.startIndex=e.index,this.prevAccept.reset();let t=this.atn.modeToDFA[r].s0;return null==t?this.matchATN(e):this.execATN(e,t)}finally{e.release(n)}}reset(){this.prevAccept.reset(),this.startIndex=-1,this._line=1,this._charPositionInLine=0,this.mode=f.Lexer.DEFAULT_MODE}matchATN(e){let r=this.atn.modeToStartState[this.mode];t.debug&&console.log(`matchATN mode ${this.mode} start: ${r}`);let n=this.mode,i=this.computeStartState(e,r),o=i.hasSemanticContext;o&&(i.hasSemanticContext=!1);let s=this.addDFAState(i);if(!o){let t=this.atn.modeToDFA[this.mode];t.s0?s=t.s0:t.s0=s}let l=this.execATN(e,s);return t.debug&&console.log(`DFA after matchATN: ${this.atn.modeToDFA[n].toLexerString()}`),l}execATN(e,r){t.debug&&console.log(`start state closure=${r.configs}`),r.isAcceptState&&this.captureSimState(this.prevAccept,e,r);let n=e.LA(1),i=r;for(;;){t.debug&&console.log(`execATN loop starting closure: ${i.configs}`);let r=this.getExistingTargetState(i,n);if(null==r&&(r=this.computeTargetState(e,i,n)),r===c.ATNSimulator.ERROR)break;if(n!==d.IntStream.EOF&&this.consume(e),r.isAcceptState&&(this.captureSimState(this.prevAccept,e,r),n===d.IntStream.EOF))break;n=e.LA(1),i=r}return this.failOrAccept(this.prevAccept,e,i.configs,n)}getExistingTargetState(e,r){let n=e.getTarget(r);return t.debug&&null!=n&&console.log("reuse state "+e.stateNumber+" edge to "+n.stateNumber),n}computeTargetState(t,e,r){let n=new m.OrderedATNConfigSet;return this.getReachableConfigSet(t,e.configs,n,r),n.isEmpty?(n.hasSemanticContext||this.addDFAEdge(e,r,c.ATNSimulator.ERROR),c.ATNSimulator.ERROR):this.addDFAEdge(e,r,n)}failOrAccept(t,e,r,n){if(null!=t.dfaState){let r=t.dfaState.lexerActionExecutor;return this.accept(e,r,this.startIndex,t.index,t.line,t.charPos),t.dfaState.prediction}if(n===d.IntStream.EOF&&e.index===this.startIndex)return x.Token.EOF;throw new y.LexerNoViableAltException(this.recog,e,this.startIndex,r)}getReachableConfigSet(e,r,n,i){let o=l.ATN.INVALID_ALT_NUMBER;for(let l of s.asIterable(r)){let r=l.alt===o;if(r&&l.hasPassedThroughNonGreedyDecision)continue;t.debug&&console.log(`testing ${this.getTokenName(i)} at ${l.toString(this.recog,!0)}`);let s=l.state.numberOfOptimizedTransitions;for(let t=0;t<s;t++){let s=l.state.getOptimizedTransition(t),a=this.getReachableTarget(s,i);if(null!=a){let t,s=l.lexerActionExecutor;null!=s?(s=s.fixOffsetBeforeMatch(e.index-this.startIndex),t=l.transform(a,!0,s)):(E(null==l.lexerActionExecutor),t=l.transform(a,!0));let u=i===d.IntStream.EOF;if(this.closure(e,t,n,r,!0,u)){o=l.alt;break}}}}}accept(e,r,n,i,o,s){t.debug&&console.log(`ACTION ${r}`),e.seek(i),this._line=o,this._charPositionInLine=s,null!=r&&null!=this.recog&&r.execute(this.recog,e,n)}getReachableTarget(t,e){if(t.matches(e,f.Lexer.MIN_CHAR_VALUE,f.Lexer.MAX_CHAR_VALUE))return t.target}computeStartState(t,e){let r=T.PredictionContext.EMPTY_FULL,n=new m.OrderedATNConfigSet;for(let i=0;i<e.numberOfTransitions;i++){let o=e.transition(i).target,s=a.ATNConfig.create(o,i+1,r);this.closure(t,s,n,!1,!1,!1)}return n}closure(e,r,n,i,o,s){if(t.debug&&console.log("closure("+r.toString(this.recog,!0)+")"),r.state instanceof S.RuleStopState){t.debug&&(null!=this.recog?console.log(`closure at ${this.recog.ruleNames[r.state.ruleIndex]} rule stop ${r}`):console.log(`closure at rule stop ${r}`));let l=r.context;if(l.isEmpty)return n.add(r),!0;l.hasEmpty&&(n.add(r.transform(r.state,!0,T.PredictionContext.EMPTY_FULL)),i=!0);for(let t=0;t<l.size;t++){let a=l.getReturnState(t);if(a==T.PredictionContext.EMPTY_FULL_STATE_KEY)continue;let u=l.getParent(t),c=this.atn.states[a],h=r.transform(c,!1,u);i=this.closure(e,h,n,i,o,s)}return i}r.state.onlyHasEpsilonTransitions||i&&r.hasPassedThroughNonGreedyDecision||n.add(r);let l=r.state;for(let t=0;t<l.numberOfOptimizedTransitions;t++){let a=l.getOptimizedTransition(t),u=this.getEpsilonTarget(e,r,a,n,o,s);null!=u&&(i=this.closure(e,u,n,i,o,s))}return i}getEpsilonTarget(e,r,n,i,o,s){let l;switch(n.serializationType){case 3:let a=n;if(this.optimize_tail_calls&&a.optimizedTailCall&&!r.context.hasEmpty)l=r.transform(n.target,!0);else{let t=r.context.getChild(a.followState.stateNumber);l=r.transform(n.target,!0,t)}break;case 10:throw new Error("Precedence predicates are not supported in lexers.");case 4:let u=n;t.debug&&console.log("EVAL rule "+u.ruleIndex+":"+u.predIndex),i.hasSemanticContext=!0,l=this.evaluatePredicate(e,u.ruleIndex,u.predIndex,o)?r.transform(n.target,!0):void 0;break;case 6:if(r.context.hasEmpty){let t=g.LexerActionExecutor.append(r.lexerActionExecutor,this.atn.lexerActions[n.actionIndex]);l=r.transform(n.target,!0,t);break}l=r.transform(n.target,!0);break;case 1:l=r.transform(n.target,!0);break;case 5:case 2:case 7:if(s&&n.matches(d.IntStream.EOF,f.Lexer.MIN_CHAR_VALUE,f.Lexer.MAX_CHAR_VALUE)){l=r.transform(n.target,!1);break}l=void 0;break;default:l=void 0}return l}evaluatePredicate(t,e,r,n){if(null==this.recog)return!0;if(!n)return this.recog.sempred(void 0,e,r);let i=this._charPositionInLine,o=this._line,s=t.index,l=t.mark();try{return this.consume(t),this.recog.sempred(void 0,e,r)}finally{this._charPositionInLine=i,this._line=o,t.seek(s),t.release(l)}}captureSimState(t,e,r){t.index=e.index,t.line=this._line,t.charPos=this._charPositionInLine,t.dfaState=r}addDFAEdge(e,r,n){if(n instanceof u.ATNConfigSet){let t=n.hasSemanticContext;t&&(n.hasSemanticContext=!1);let i=this.addDFAState(n);return t?i:(this.addDFAEdge(e,r,i),i)}t.debug&&console.log("EDGE "+e+" -> "+n+" upon "+String.fromCharCode(r)),null!=e&&e.setTarget(r,n)}addDFAState(t){E(!t.hasSemanticContext);let e=new h.DFAState(t),r=this.atn.modeToDFA[this.mode].states.get(e);if(null!=r)return r;t.optimizeConfigs(this);let n=new h.DFAState(t.clone(!0)),i=void 0;for(let e of s.asIterable(t))if(e.state instanceof S.RuleStopState){i=e;break}if(null!=i){let t=this.atn.ruleToTokenType[i.state.ruleIndex],e=i.lexerActionExecutor;n.acceptStateInfo=new o.AcceptStateInfo(t,e)}return this.atn.modeToDFA[this.mode].addState(n)}getDFA(t){return this.atn.modeToDFA[t]}getText(t){return t.getText(p.Interval.of(this.startIndex,t.index-1))}get line(){return this._line}set line(t){this._line=t}get charPositionInLine(){return this._charPositionInLine}set charPositionInLine(t){this._charPositionInLine=t}consume(t){t.LA(1)=="\n".charCodeAt(0)?(this._line++,this._charPositionInLine=0):this._charPositionInLine++,t.consume()}getTokenName(t){return-1===t?"EOF":"'"+String.fromCharCode(t)+"'"}};N.match_calls=0,n([_.NotNull],N.prototype,"prevAccept",void 0),n([i(0,_.NotNull)],N.prototype,"copyState",null),n([i(0,_.NotNull)],N.prototype,"match",null),n([_.Override],N.prototype,"reset",null),n([i(0,_.NotNull)],N.prototype,"matchATN",null),n([i(0,_.NotNull),i(1,_.NotNull)],N.prototype,"execATN",null),n([i(0,_.NotNull)],N.prototype,"getExistingTargetState",null),n([_.NotNull,i(0,_.NotNull),i(1,_.NotNull)],N.prototype,"computeTargetState",null),n([i(0,_.NotNull),i(1,_.NotNull),i(2,_.NotNull)],N.prototype,"getReachableConfigSet",null),n([i(0,_.NotNull)],N.prototype,"accept",null),n([_.NotNull,i(0,_.NotNull),i(1,_.NotNull)],N.prototype,"computeStartState",null),n([i(0,_.NotNull),i(1,_.NotNull),i(2,_.NotNull)],N.prototype,"closure",null),n([i(0,_.NotNull),i(1,_.NotNull),i(2,_.NotNull),i(3,_.NotNull)],N.prototype,"getEpsilonTarget",null),n([i(0,_.NotNull)],N.prototype,"evaluatePredicate",null),n([i(0,_.NotNull),i(1,_.NotNull),i(2,_.NotNull)],N.prototype,"captureSimState",null),n([_.NotNull,i(0,_.NotNull)],N.prototype,"addDFAState",null),n([_.NotNull],N.prototype,"getDFA",null),n([_.NotNull,i(0,_.NotNull)],N.prototype,"getText",null),n([i(0,_.NotNull)],N.prototype,"consume",null),n([_.NotNull],N.prototype,"getTokenName",null),N=n([i(0,_.NotNull)],N),e.LexerATNSimulator=N,function(t){t.debug=!1,t.dfa_debug=!1;t.SimState=class{constructor(){this.index=-1,this.line=0,this.charPos=-1}reset(){this.index=-1,this.line=0,this.charPos=-1,this.dfaState=void 0}}}(N=e.LexerATNSimulator||(e.LexerATNSimulator={})),e.LexerATNSimulator=N},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(20),o=r(0),s=r(6),l=r(4),a=r(5);class u{constructor(t=!0){this.contexts=new i.Array2DHashMap(s.ObjectEqualityComparator.INSTANCE),this.childContexts=new i.Array2DHashMap(s.ObjectEqualityComparator.INSTANCE),this.joinContexts=new i.Array2DHashMap(s.ObjectEqualityComparator.INSTANCE),this.enableCache=t}getAsCached(t){if(!this.enableCache)return t;let e=this.contexts.get(t);return e||(e=t,this.contexts.put(t,t)),e}getChild(t,e){if(!this.enableCache)return t.getChild(e);let r=new u.PredictionContextAndInt(t,e),n=this.childContexts.get(r);return n||(n=t.getChild(e),n=this.getAsCached(n),this.childContexts.put(r,n)),n}join(t,e){if(!this.enableCache)return l.PredictionContext.join(t,e,this);let r=new u.IdentityCommutativePredictionContextOperands(t,e),n=this.joinContexts.get(r);return n||(n=l.PredictionContext.join(t,e,this),n=this.getAsCached(n),this.joinContexts.put(r,n),n)}}u.UNCACHED=new u(!1),e.PredictionContextCache=u,function(t){class e{constructor(t,e){this.obj=t,this.value=e}equals(t){if(!(t instanceof e))return!1;if(t==this)return!0;let r=t;return this.value===r.value&&(this.obj===r.obj||null!=this.obj&&this.obj.equals(r.obj))}hashCode(){let t=5;return t=7*(t=7*t+(null!=this.obj?this.obj.hashCode():0))+this.value}}n([o.Override],e.prototype,"equals",null),n([o.Override],e.prototype,"hashCode",null),t.PredictionContextAndInt=e;class r{constructor(t,e){a(null!=t),a(null!=e),this._x=t,this._y=e}get x(){return this._x}get y(){return this._y}equals(t){if(!(t instanceof r))return!1;if(this===t)return!0;let e=t;return this._x===e._x&&this._y===e._y||this._x===e._y&&this._y===e._x}hashCode(){return this._x.hashCode()^this._y.hashCode()}}n([o.Override],r.prototype,"equals",null),n([o.Override],r.prototype,"hashCode",null),t.IdentityCommutativePredictionContextOperands=r}(u=e.PredictionContextCache||(e.PredictionContextCache={}))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(7),s=r(12),l=r(1),a=r(0),u=r(4),c=r(5);class h{constructor(t){this.stateNumber=-1,this.configs=t,this.edges=new Map,this.contextEdges=new Map}get isContextSensitive(){return!!this.contextSymbols}isContextSymbol(t){return!!this.isContextSensitive&&this.contextSymbols.get(t)}setContextSymbol(t){c(this.isContextSensitive),this.contextSymbols.set(t)}setContextSensitive(t){c(!this.configs.isOutermostConfigSet),this.isContextSensitive||this.contextSymbols||(this.contextSymbols=new s.BitSet)}get acceptStateInfo(){return this._acceptStateInfo}set acceptStateInfo(t){this._acceptStateInfo=t}get isAcceptState(){return!!this._acceptStateInfo}get prediction(){return this._acceptStateInfo?this._acceptStateInfo.prediction:o.ATN.INVALID_ALT_NUMBER}get lexerActionExecutor(){if(this._acceptStateInfo)return this._acceptStateInfo.lexerActionExecutor}getTarget(t){return this.edges.get(t)}setTarget(t,e){this.edges.set(t,e)}getEdgeMap(){return this.edges}getContextTarget(t){return t===u.PredictionContext.EMPTY_FULL_STATE_KEY&&(t=-1),this.contextEdges.get(t)}setContextTarget(t,e){if(!this.isContextSensitive)throw new Error("The state is not context sensitive.");t===u.PredictionContext.EMPTY_FULL_STATE_KEY&&(t=-1),this.contextEdges.set(t,e)}getContextEdgeMap(){let t=new Map(this.contextEdges),e=t.get(-1);if(void 0!==e){if(1===t.size){let t=new Map;return t.set(u.PredictionContext.EMPTY_FULL_STATE_KEY,e),t}t.delete(-1),t.set(u.PredictionContext.EMPTY_FULL_STATE_KEY,e)}return t}hashCode(){let t=l.MurmurHash.initialize(7);return t=l.MurmurHash.update(t,this.configs.hashCode()),t=l.MurmurHash.finish(t,1)}equals(t){if(this===t)return!0;if(!(t instanceof h))return!1;let e=t;return this.configs.equals(e.configs)}toString(){let t="";return t+=this.stateNumber+":"+this.configs,this.isAcceptState&&(t+="=>",this.predicates?t+=this.predicates:t+=this.prediction),t.toString()}}n([a.NotNull],h.prototype,"configs",void 0),n([a.NotNull],h.prototype,"edges",void 0),n([a.NotNull],h.prototype,"contextEdges",void 0),n([a.Override],h.prototype,"hashCode",null),n([a.Override],h.prototype,"equals",null),n([a.Override],h.prototype,"toString",null),e.DFAState=h,function(t){let e=class{constructor(t,e){this.alt=e,this.pred=t}toString(){return"("+this.pred+", "+this.alt+")"}};n([a.NotNull],e.prototype,"pred",void 0),n([a.Override],e.prototype,"toString",null),e=n([i(0,a.NotNull)],e),t.PredPrediction=e}(h=e.DFAState||(e.DFAState={}))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(12),o=r(15),s=r(0);class l extends o.DecisionState{constructor(){super(...arguments),this.precedenceRuleDecision=!1,this.precedenceLoopbackStates=new i.BitSet}get stateType(){return 10}}n([s.Override],l.prototype,"stateType",null),e.StarLoopEntryState=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(0),s=r(44);let l=class extends s.SetTransition{constructor(t,e){super(t,e)}get serializationType(){return 8}matches(t,e,r){return t>=e&&t<=r&&!super.matches(t,e,r)}toString(){return"~"+super.toString()}};n([o.Override],l.prototype,"serializationType",null),n([o.Override],l.prototype,"matches",null),n([o.Override],l.prototype,"toString",null),l=n([i(0,o.NotNull),i(1,o.Nullable)],l),e.NotSetTransition=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(14),s=r(0),l=r(2),a=r(9);let u=class extends a.Transition{constructor(t,e){super(t),null==e&&(e=o.IntervalSet.of(l.Token.INVALID_TYPE)),this.set=e}get serializationType(){return 7}get label(){return this.set}matches(t,e,r){return this.set.contains(t)}toString(){return this.set.toString()}};n([s.NotNull],u.prototype,"set",void 0),n([s.Override],u.prototype,"serializationType",null),n([s.Override,s.NotNull],u.prototype,"label",null),n([s.Override],u.prototype,"matches",null),n([s.Override,s.NotNull],u.prototype,"toString",null),u=n([i(0,s.NotNull),i(1,s.Nullable)],u),e.SetTransition=u},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(0),s=r(9);let l=class extends s.Transition{constructor(t,e,r,n){super(t),this.tailCall=!1,this.optimizedTailCall=!1,this.ruleIndex=e,this.precedence=r,this.followState=n}get serializationType(){return 3}get isEpsilon(){return!0}matches(t,e,r){return!1}};n([o.NotNull],l.prototype,"followState",void 0),n([o.Override],l.prototype,"serializationType",null),n([o.Override],l.prototype,"isEpsilon",null),n([o.Override],l.prototype,"matches",null),l=n([i(0,o.NotNull),i(3,o.NotNull)],l),e.RuleTransition=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(30),o=r(17),s=r(0);class l extends o.RecognitionException{constructor(t,e,r,n,o,s){t instanceof i.Parser&&(void 0===e&&(e=t.inputStream),void 0===r&&(r=t.currentToken),void 0===n&&(n=t.currentToken),void 0===s&&(s=t.context)),super(t,e,s),this._deadEndConfigs=o,this._startToken=r,this.setOffendingToken(t,n)}get startToken(){return this._startToken}get deadEndConfigs(){return this._deadEndConfigs}}n([s.NotNull],l.prototype,"_startToken",void 0),e.NoViableAltException=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(60),s=r(10),l=r(7),a=r(59),u=r(61),c=r(76),h=r(56),p=r(12),d=r(77),f=r(31),g=r(15),y=r(69),_=r(78),m=r(14),T=r(55),S=r(79),x=r(80),E=r(81),N=r(82),O=r(83),v=r(84),b=r(85),A=r(86),C=r(62),R=r(0),I=r(43),P=r(32),D=r(92),k=r(93),L=r(94),w=r(50),M=r(95),F=r(96),j=r(24),z=r(45),U=r(44),H=r(97),B=r(98),V=r(42),q=r(2),Y=r(99),W=r(100),K=r(57);class G{constructor(t){null==t&&(t=a.ATNDeserializationOptions.defaultOptions),this.deserializationOptions=t}static get SERIALIZED_VERSION(){return 3}isFeatureSupported(t,e){let r=G.SUPPORTED_UUIDS.findIndex(e=>e.equals(t));return!(r<0)&&G.SUPPORTED_UUIDS.findIndex(t=>t.equals(e))>=r}deserialize(t){t=t.slice(0);for(let e=1;e<t.length;e++)t[e]=t[e]-2&65535;let e=0,r=G.toInt(t[e++]);if(r!=G.SERIALIZED_VERSION){let t=`Could not deserialize ATN with version ${r} (expected ${G.SERIALIZED_VERSION}).`;throw new Error(t)}let n=G.toUUID(t,e);if(e+=8,G.SUPPORTED_UUIDS.findIndex(t=>t.equals(n))<0){let t=`Could not deserialize ATN with UUID ${n} (expected ${G.SERIALIZED_UUID} or a legacy UUID).`;throw new Error(t)}let i=this.isFeatureSupported(G.ADDED_LEXER_ACTIONS,n),a=G.toInt(t[e++]),p=G.toInt(t[e++]),g=new l.ATN(a,p),m=[],S=[],E=G.toInt(t[e++]);for(let r=0;r<E;r++){let r=G.toInt(t[e++]);if(0===r){g.addState(new T.InvalidState);continue}let n=G.toInt(t[e++]);65535===n&&(n=-1);let i=this.stateFactory(r,n);if(12===r){let r=G.toInt(t[e++]);m.push([i,r])}else if(i instanceof f.BlockStartState){let r=G.toInt(t[e++]);S.push([i,r])}g.addState(i)}for(let t of m)t[0].loopBackState=g.states[t[1]];for(let t of S)t[0].endState=g.states[t[1]];let N=G.toInt(t[e++]);for(let r=0;r<N;r++){let r=G.toInt(t[e++]);g.states[r].nonGreedy=!0}let O=G.toInt(t[e++]);for(let r=0;r<O;r++){let r=G.toInt(t[e++]);g.states[r].sll=!0}let v=G.toInt(t[e++]);for(let r=0;r<v;r++){let r=G.toInt(t[e++]);g.states[r].isPrecedenceRule=!0}let b=G.toInt(t[e++]);0===g.grammarType&&(g.ruleToTokenType=new Int32Array(b)),g.ruleToStartState=new Array(b);for(let r=0;r<b;r++){let i=G.toInt(t[e++]),o=g.states[i];if(o.leftFactored=0!=G.toInt(t[e++]),g.ruleToStartState[r]=o,0===g.grammarType){let i=G.toInt(t[e++]);if(65535===i&&(i=q.Token.EOF),g.ruleToTokenType[r]=i,!this.isFeatureSupported(G.ADDED_LEXER_ACTIONS,n)){let r=G.toInt(t[e++]);65535===r&&(r=-1)}}}g.ruleToStopState=new Array(b);for(let t of g.states)t instanceof j.RuleStopState&&(g.ruleToStopState[t.ruleIndex]=t,g.ruleToStartState[t.ruleIndex].stopState=t);let A=G.toInt(t[e++]);for(let r=0;r<A;r++){let r=G.toInt(t[e++]);g.modeToStartState.push(g.states[r])}g.modeToDFA=new Array(A);for(let t=0;t<A;t++)g.modeToDFA[t]=new y.DFA(g.modeToStartState[t]);let R=[];e=this.readSets(t,e,R,!1),this.isFeatureSupported(G.ADDED_UNICODE_SMP,n)&&(e=this.readSets(t,e,R,!0));let I=G.toInt(t[e++]);for(let r=0;r<I;r++){let r=G.toInt(t[e]),n=G.toInt(t[e+1]),i=G.toInt(t[e+2]),o=G.toInt(t[e+3]),s=G.toInt(t[e+4]),l=G.toInt(t[e+5]),a=this.edgeFactory(g,i,r,n,o,s,l,R);g.states[r].addTransition(a),e+=6}let P=new s.Array2DHashSet({hashCode:t=>t.stopState^t.returnState^t.outermostPrecedenceReturn,equals:function(t,e){return t.stopState===e.stopState&&t.returnState===e.returnState&&t.outermostPrecedenceReturn===e.outermostPrecedenceReturn}}),L=[];for(let t of g.states){let e=t.ruleIndex>=0&&g.ruleToStartState[t.ruleIndex].leftFactored;for(let r=0;r<t.numberOfTransitions;r++){let n=t.transition(r);if(!(n instanceof z.RuleTransition))continue;let i=n;if(!g.ruleToStartState[i.target.ruleIndex].leftFactored&&e)continue;let o=-1;g.ruleToStartState[i.target.ruleIndex].isPrecedenceRule&&0===i.precedence&&(o=i.target.ruleIndex);let s={stopState:i.target.ruleIndex,returnState:i.followState.stateNumber,outermostPrecedenceReturn:o};P.add(s)&&L.push(s)}}for(let t of L){let e=new _.EpsilonTransition(g.states[t.returnState],t.outermostPrecedenceReturn);g.ruleToStopState[t.stopState].addTransition(e)}for(let t of g.states){if(t instanceof f.BlockStartState){if(null==t.endState)throw new Error("IllegalStateException");if(null!=t.endState.startState)throw new Error("IllegalStateException");t.endState.startState=t}if(t instanceof k.PlusLoopbackState){let e=t;for(let t=0;t<e.numberOfTransitions;t++){let r=e.transition(t).target;r instanceof D.PlusBlockStartState&&(r.loopBackState=e)}}else if(t instanceof B.StarLoopbackState){let e=t;for(let t=0;t<e.numberOfTransitions;t++){let r=e.transition(t).target;r instanceof V.StarLoopEntryState&&(r.loopBackState=e)}}}let w=G.toInt(t[e++]);for(let r=1;r<=w;r++){let n=G.toInt(t[e++]),i=g.states[n];g.decisionToState.push(i),i.decision=r-1}if(0===g.grammarType)if(i){g.lexerActions=new Array(G.toInt(t[e++]));for(let r=0;r<g.lexerActions.length;r++){let n=G.toInt(t[e++]),i=G.toInt(t[e++]);65535==i&&(i=-1);let o=G.toInt(t[e++]);65535==o&&(o=-1);let s=this.lexerActionFactory(n,i,o);g.lexerActions[r]=s}}else{let t=[];for(let e of g.states)for(let r=0;r<e.numberOfTransitions;r++){let n=e.transition(r);if(!(n instanceof o.ActionTransition))continue;let i=n.ruleIndex,s=n.actionIndex,l=new x.LexerCustomAction(i,s);e.setTransition(r,new o.ActionTransition(n.target,i,t.length,!1)),t.push(l)}g.lexerActions=t}this.markPrecedenceDecisions(g),g.decisionToDFA=new Array(w);for(let t=0;t<w;t++)g.decisionToDFA[t]=new y.DFA(g.decisionToState[t],t);if(this.deserializationOptions.isVerifyATN&&this.verifyATN(g),this.deserializationOptions.isGenerateRuleBypassTransitions&&1===g.grammarType){g.ruleToTokenType=new Int32Array(g.ruleToStartState.length);for(let t=0;t<g.ruleToStartState.length;t++)g.ruleToTokenType[t]=g.maxTokenType+t+1;for(let t=0;t<g.ruleToStartState.length;t++){let e=new c.BasicBlockStartState;e.ruleIndex=t,g.addState(e);let r,n,i=new d.BlockEndState;if(i.ruleIndex=t,g.addState(i),e.endState=i,g.defineDecisionState(e),i.startState=e,g.ruleToStartState[t].isPrecedenceRule){r=void 0;for(let e of g.states){if(e.ruleIndex!==t)continue;if(!(e instanceof V.StarLoopEntryState))continue;let n=e.transition(e.numberOfTransitions-1).target;if(n instanceof C.LoopEndState&&(n.epsilonOnlyTransitions&&n.transition(0).target instanceof j.RuleStopState)){r=e;break}}if(!r)throw new Error("Couldn't identify final state of the precedence rule prefix section.");n=r.loopBackState.transition(0)}else r=g.ruleToStopState[t];for(let t of g.states)for(let e=0;e<t.numberOfTransitions;e++){let o=t.transition(e);o!==n&&(o.target===r&&(o.target=i))}for(;g.ruleToStartState[t].numberOfTransitions>0;){let r=g.ruleToStartState[t].removeTransition(g.ruleToStartState[t].numberOfTransitions-1);e.addTransition(r)}g.ruleToStartState[t].addTransition(new _.EpsilonTransition(e)),i.addTransition(new _.EpsilonTransition(r));let o=new h.BasicState;g.addState(o),o.addTransition(new u.AtomTransition(i,g.ruleToTokenType[t])),e.addTransition(new _.EpsilonTransition(o))}this.deserializationOptions.isVerifyATN&&this.verifyATN(g)}if(this.deserializationOptions.isOptimize){for(;;){let t=0;t+=G.inlineSetRules(g),t+=G.combineChainedEpsilons(g);let e=0===g.grammarType;if(0===(t+=G.optimizeSets(g,e)))break}this.deserializationOptions.isVerifyATN&&this.verifyATN(g)}return G.identifyTailCalls(g),g}readSets(t,e,r,n){let i=G.toInt(t[e++]);for(let o=0;o<i;o++){let i=G.toInt(t[e]);e++;let o=new m.IntervalSet;if(r.push(o),0!=G.toInt(t[e++])&&o.add(-1),n)for(let r=0;r<i;r++)o.add(G.toInt32(t,e),G.toInt32(t,e+2)),e+=4;else for(let r=0;r<i;r++)o.add(G.toInt(t[e]),G.toInt(t[e+1])),e+=2}return e}markPrecedenceDecisions(t){let e=new Map;for(let r of t.states)if(r instanceof V.StarLoopEntryState&&t.ruleToStartState[r.ruleIndex].isPrecedenceRule){let n=r.transition(r.numberOfTransitions-1).target;n instanceof C.LoopEndState&&n.epsilonOnlyTransitions&&n.transition(0).target instanceof j.RuleStopState&&(e.set(r.ruleIndex,r),r.precedenceRuleDecision=!0,r.precedenceLoopbackStates=new p.BitSet(t.states.length))}for(let r of e)for(let e of t.ruleToStopState[r[0]].getTransitions()){if(1!==e.serializationType)continue;-1===e.outermostPrecedenceReturn&&r[1].precedenceLoopbackStates.set(e.target.stateNumber)}}verifyATN(t){for(let e of t.states)if(this.checkCondition(null!=e,"ATN states should not be null."),0!==e.stateType){if(this.checkCondition(e.onlyHasEpsilonTransitions||e.numberOfTransitions<=1),e instanceof D.PlusBlockStartState&&this.checkCondition(null!=e.loopBackState),e instanceof V.StarLoopEntryState){let t=e;if(this.checkCondition(null!=t.loopBackState),this.checkCondition(2===t.numberOfTransitions),t.transition(0).target instanceof H.StarBlockStartState)this.checkCondition(t.transition(1).target instanceof C.LoopEndState),this.checkCondition(!t.nonGreedy);else{if(!(t.transition(0).target instanceof C.LoopEndState))throw new Error("IllegalStateException");this.checkCondition(t.transition(1).target instanceof H.StarBlockStartState),this.checkCondition(t.nonGreedy)}}if(e instanceof B.StarLoopbackState&&(this.checkCondition(1===e.numberOfTransitions),this.checkCondition(e.transition(0).target instanceof V.StarLoopEntryState)),e instanceof C.LoopEndState&&this.checkCondition(null!=e.loopBackState),e instanceof F.RuleStartState&&this.checkCondition(null!=e.stopState),e instanceof f.BlockStartState&&this.checkCondition(null!=e.endState),e instanceof d.BlockEndState&&this.checkCondition(null!=e.startState),e instanceof g.DecisionState){let t=e;this.checkCondition(t.numberOfTransitions<=1||t.decision>=0)}else this.checkCondition(e.numberOfTransitions<=1||e instanceof j.RuleStopState)}}checkCondition(t,e){if(!t)throw new Error("IllegalStateException: "+e)}static inlineSetRules(t){let e=0,r=new Array(t.ruleToStartState.length);for(let e=0;e<t.ruleToStartState.length;e++){let n=t.ruleToStartState[e];for(;n.onlyHasEpsilonTransitions&&1===n.numberOfOptimizedTransitions&&1===n.getOptimizedTransition(0).serializationType;)n=n.getOptimizedTransition(0).target;if(1!==n.numberOfOptimizedTransitions)continue;let i=n.getOptimizedTransition(0),o=i.target;if(!i.isEpsilon&&o.onlyHasEpsilonTransitions&&1===o.numberOfOptimizedTransitions&&o.getOptimizedTransition(0).target instanceof j.RuleStopState)switch(i.serializationType){case 5:case 2:case 7:r[e]=i;break;case 8:case 9:default:continue}}for(let n=0;n<t.states.length;n++){let i,o=t.states[n];if(!(o.ruleIndex<0)){for(let n=0;n<o.numberOfOptimizedTransitions;n++){let s=o.getOptimizedTransition(n);if(!(s instanceof z.RuleTransition)){null!=i&&i.push(s);continue}let l=s,a=r[l.target.ruleIndex];if(null==a){null!=i&&i.push(s);continue}if(null==i){i=[];for(let t=0;t<n;t++)i.push(o.getOptimizedTransition(n))}e++;let c=l.followState,p=new h.BasicState;switch(p.setRuleIndex(c.ruleIndex),t.addState(p),i.push(new _.EpsilonTransition(p)),a.serializationType){case 5:p.addTransition(new u.AtomTransition(c,a._label));break;case 2:p.addTransition(new M.RangeTransition(c,a.from,a.to));break;case 7:p.addTransition(new U.SetTransition(c,a.label));break;default:throw new Error("UnsupportedOperationException")}}if(null!=i){if(o.isOptimized)for(;o.numberOfOptimizedTransitions>0;)o.removeOptimizedTransition(o.numberOfOptimizedTransitions-1);for(let t of i)o.addOptimizedTransition(t)}}}return P.ParserATNSimulator.debug&&console.log("ATN runtime optimizer removed "+e+" rule invocations by inlining sets."),e}static combineChainedEpsilons(t){let e=0;for(let r of t.states){if(!r.onlyHasEpsilonTransitions||r instanceof j.RuleStopState)continue;let t;t:for(let n=0;n<r.numberOfOptimizedTransitions;n++){let i=r.getOptimizedTransition(n),o=i.target;if(1===i.serializationType&&-1===i.outermostPrecedenceReturn&&1===o.stateType&&o.onlyHasEpsilonTransitions){for(let e=0;e<o.numberOfOptimizedTransitions;e++)if(1!==o.getOptimizedTransition(e).serializationType||-1!==o.getOptimizedTransition(e).outermostPrecedenceReturn){null!=t&&t.push(i);continue t}if(e++,null==t){t=[];for(let e=0;e<n;e++)t.push(r.getOptimizedTransition(e))}for(let e=0;e<o.numberOfOptimizedTransitions;e++){let r=o.getOptimizedTransition(e).target;t.push(new _.EpsilonTransition(r))}}else null!=t&&t.push(i)}if(null!=t){if(r.isOptimized)for(;r.numberOfOptimizedTransitions>0;)r.removeOptimizedTransition(r.numberOfOptimizedTransitions-1);for(let e of t)r.addOptimizedTransition(e)}}return P.ParserATNSimulator.debug&&console.log("ATN runtime optimizer removed "+e+" transitions by combining chained epsilon transitions."),e}static optimizeSets(t,e){if(e)return 0;let r=0,n=t.decisionToState;for(let e of n){let n=new m.IntervalSet;for(let t=0;t<e.numberOfOptimizedTransitions;t++){let r=e.getOptimizedTransition(t);if(!(r instanceof _.EpsilonTransition))continue;if(1!==r.target.numberOfOptimizedTransitions)continue;let i=r.target.getOptimizedTransition(0);i.target instanceof d.BlockEndState&&(i instanceof I.NotSetTransition||(i instanceof u.AtomTransition||i instanceof M.RangeTransition||i instanceof U.SetTransition)&&n.add(t))}if(n.size<=1)continue;let i=[];for(let t=0;t<e.numberOfOptimizedTransitions;t++)n.contains(t)||i.push(e.getOptimizedTransition(t));let o,s=e.getOptimizedTransition(n.minElement).target.getOptimizedTransition(0).target,l=new m.IntervalSet;for(let t=0;t<n.intervals.length;t++){let r=n.intervals[t];for(let t=r.a;t<=r.b;t++){let r=e.getOptimizedTransition(t).target.getOptimizedTransition(0);if(r instanceof I.NotSetTransition)throw new Error("Not yet implemented.");l.addAll(r.label)}}if(1===l.intervals.length)if(1===l.size)o=new u.AtomTransition(s,l.minElement);else{let t=l.intervals[0];o=new M.RangeTransition(s,t.a,t.b)}else o=new U.SetTransition(s,l);let a=new h.BasicState;if(a.setRuleIndex(e.ruleIndex),t.addState(a),a.addTransition(o),i.push(new _.EpsilonTransition(a)),r+=e.numberOfOptimizedTransitions-i.length,e.isOptimized)for(;e.numberOfOptimizedTransitions>0;)e.removeOptimizedTransition(e.numberOfOptimizedTransitions-1);for(let t of i)e.addOptimizedTransition(t)}return P.ParserATNSimulator.debug&&console.log("ATN runtime optimizer removed "+r+" paths by collapsing sets."),r}static identifyTailCalls(t){for(let e of t.states){for(let r=0;r<e.numberOfTransitions;r++){let n=e.transition(r);n instanceof z.RuleTransition&&(n.tailCall=this.testTailCall(t,n,!1),n.optimizedTailCall=this.testTailCall(t,n,!0))}if(e.isOptimized)for(let r=0;r<e.numberOfOptimizedTransitions;r++){let n=e.getOptimizedTransition(r);n instanceof z.RuleTransition&&(n.tailCall=this.testTailCall(t,n,!1),n.optimizedTailCall=this.testTailCall(t,n,!0))}}}static testTailCall(t,e,r){if(!r&&e.tailCall)return!0;if(r&&e.optimizedTailCall)return!0;let n=new p.BitSet(t.states.length),i=[];for(i.push(e.followState);;){let t=i.pop();if(!t)break;if(n.get(t.stateNumber))continue;if(t instanceof j.RuleStopState)continue;if(!t.onlyHasEpsilonTransitions)return!1;let e=r?t.numberOfOptimizedTransitions:t.numberOfTransitions;for(let n=0;n<e;n++){let e=r?t.getOptimizedTransition(n):t.transition(n);if(1!==e.serializationType)return!1;i.push(e.target)}}return!0}static toInt(t){return t}static toInt32(t,e){return(t[e]|t[e+1]<<16)>>>0}static toUUID(t,e){let r=G.toInt32(t,e),n=G.toInt32(t,e+2),i=G.toInt32(t,e+4),o=G.toInt32(t,e+6);return new W.UUID(o,i,n,r)}edgeFactory(t,e,r,n,i,s,l,a){let c=t.states[n];switch(e){case 1:return new _.EpsilonTransition(c);case 2:return 0!==l?new M.RangeTransition(c,q.Token.EOF,s):new M.RangeTransition(c,i,s);case 3:return new z.RuleTransition(t.states[i],s,l,c);case 4:return new w.PredicateTransition(c,i,s,0!==l);case 10:return new L.PrecedencePredicateTransition(c,i);case 5:return 0!==l?new u.AtomTransition(c,q.Token.EOF):new u.AtomTransition(c,i);case 6:return new o.ActionTransition(c,i,s,0!==l);case 7:return new U.SetTransition(c,a[i]);case 8:return new I.NotSetTransition(c,a[i]);case 9:return new K.WildcardTransition(c)}throw new Error("The specified transition type is not valid.")}stateFactory(t,e){let r;switch(t){case 0:return new T.InvalidState;case 1:r=new h.BasicState;break;case 2:r=new F.RuleStartState;break;case 3:r=new c.BasicBlockStartState;break;case 4:r=new D.PlusBlockStartState;break;case 5:r=new H.StarBlockStartState;break;case 6:r=new Y.TokensStartState;break;case 7:r=new j.RuleStopState;break;case 8:r=new d.BlockEndState;break;case 9:r=new B.StarLoopbackState;break;case 10:r=new V.StarLoopEntryState;break;case 11:r=new k.PlusLoopbackState;break;case 12:r=new C.LoopEndState;break;default:let e=`The specified state type ${t} is not valid.`;throw new Error(e)}return r.ruleIndex=e,r}lexerActionFactory(t,e,r){switch(t){case 0:return new S.LexerChannelAction(e);case 1:return new x.LexerCustomAction(e,r);case 2:return new E.LexerModeAction(e);case 3:return N.LexerMoreAction.INSTANCE;case 4:return O.LexerPopModeAction.INSTANCE;case 5:return new v.LexerPushModeAction(e);case 6:return b.LexerSkipAction.INSTANCE;case 7:return new A.LexerTypeAction(e);default:let n=`The specified lexer action type ${t} is not valid.`;throw new Error(n)}}}G.BASE_SERIALIZED_UUID=W.UUID.fromString("E4178468-DF95-44D0-AD87-F22A5D5FB6D3"),G.ADDED_LEXER_ACTIONS=W.UUID.fromString("AB35191A-1603-487E-B75A-479B831EAF6D"),G.ADDED_UNICODE_SMP=W.UUID.fromString("59627784-3BE5-417A-B9EB-8131A7286089"),G.SUPPORTED_UUIDS=[G.BASE_SERIALIZED_UUID,G.ADDED_LEXER_ACTIONS,G.ADDED_UNICODE_SMP],G.SERIALIZED_UUID=G.ADDED_UNICODE_SMP,n([R.NotNull],G.prototype,"deserializationOptions",void 0),n([i(0,R.NotNull)],G.prototype,"deserialize",null),n([i(0,R.NotNull)],G.prototype,"markPrecedenceDecisions",null),n([R.NotNull,i(0,R.NotNull)],G.prototype,"edgeFactory",null),e.ATNDeserializer=G},function(t,e){var r,n,i=t.exports={};function o(){throw new Error("setTimeout has not been defined")}function s(){throw new Error("clearTimeout has not been defined")}function l(t){if(r===setTimeout)return setTimeout(t,0);if((r===o||!r)&&setTimeout)return r=setTimeout,setTimeout(t,0);try{return r(t,0)}catch(e){try{return r.call(null,t,0)}catch(e){return r.call(this,t,0)}}}!function(){try{r="function"==typeof setTimeout?setTimeout:o}catch(t){r=o}try{n="function"==typeof clearTimeout?clearTimeout:s}catch(t){n=s}}();var a,u=[],c=!1,h=-1;function p(){c&&a&&(c=!1,a.length?u=a.concat(u):h=-1,u.length&&d())}function d(){if(!c){var t=l(p);c=!0;for(var e=u.length;e;){for(a=u,u=[];++h<e;)a&&a[h].run();h=-1,e=u.length}a=null,c=!1,function(t){if(n===clearTimeout)return clearTimeout(t);if((n===s||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(t);try{n(t)}catch(e){try{return n.call(null,t)}catch(e){return n.call(this,t)}}}(t)}}function f(t,e){this.fun=t,this.array=e}function g(){}i.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];u.push(new f(t,e)),1!==u.length||c||l(d)},f.prototype.run=function(){this.fun.apply(null,this.array)},i.title="browser",i.browser=!0,i.env={},i.argv=[],i.version="",i.versions={},i.on=g,i.addListener=g,i.once=g,i.off=g,i.removeListener=g,i.removeAllListeners=g,i.emit=g,i.prependListener=g,i.prependOnceListener=g,i.listeners=function(t){return[]},i.binding=function(t){throw new Error("process.binding is not supported")},i.cwd=function(){return"/"},i.chdir=function(t){throw new Error("process.chdir is not supported")},i.umask=function(){return 0}},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(33),s=r(35),l=r(14),a=r(46),u=r(4),c=r(2),h=r(0);class p{constructor(){this.errorRecoveryMode=!1,this.lastErrorIndex=-1}reset(t){this.endErrorCondition(t)}beginErrorCondition(t){this.errorRecoveryMode=!0}inErrorRecoveryMode(t){return this.errorRecoveryMode}endErrorCondition(t){this.errorRecoveryMode=!1,this.lastErrorStates=void 0,this.lastErrorIndex=-1}reportMatch(t){this.endErrorCondition(t)}reportError(t,e){this.inErrorRecoveryMode(t)||(this.beginErrorCondition(t),e instanceof a.NoViableAltException?this.reportNoViableAlternative(t,e):e instanceof s.InputMismatchException?this.reportInputMismatch(t,e):e instanceof o.FailedPredicateException?this.reportFailedPredicate(t,e):(console.error(`unknown recognition error type: ${e}`),this.notifyErrorListeners(t,e.toString(),e)))}notifyErrorListeners(t,e,r){let n=r.getOffendingToken(t);void 0===n&&(n=null),t.notifyErrorListeners(e,n,r)}recover(t,e){this.lastErrorIndex===t.inputStream.index&&this.lastErrorStates&&this.lastErrorStates.contains(t.state)&&t.consume(),this.lastErrorIndex=t.inputStream.index,this.lastErrorStates||(this.lastErrorStates=new l.IntervalSet),this.lastErrorStates.add(t.state);let r=this.getErrorRecoverySet(t);this.consumeUntil(t,r)}sync(t){let e=t.interpreter.atn.states[t.state];if(this.inErrorRecoveryMode(t))return;let r=t.inputStream.LA(1),n=t.atn.nextTokens(e);if(!n.contains(c.Token.EPSILON)&&!n.contains(r))switch(e.stateType){case 3:case 5:case 4:case 10:if(this.singleTokenDeletion(t))return;throw new s.InputMismatchException(t);case 11:case 9:this.reportUnwantedToken(t);let r=t.getExpectedTokens().or(this.getErrorRecoverySet(t));this.consumeUntil(t,r)}}reportNoViableAlternative(t,e){let r,n=t.inputStream;r=n?e.startToken.type===c.Token.EOF?"<EOF>":n.getTextFromRange(e.startToken,e.getOffendingToken()):"<unknown input>";let i="no viable alternative at input "+this.escapeWSAndQuote(r);this.notifyErrorListeners(t,i,e)}reportInputMismatch(t,e){let r=e.expectedTokens,n=r?r.toStringVocabulary(t.vocabulary):"",i="mismatched input "+this.getTokenErrorDisplay(e.getOffendingToken(t))+" expecting "+n;this.notifyErrorListeners(t,i,e)}reportFailedPredicate(t,e){let r="rule "+t.ruleNames[t.context.ruleIndex]+" "+e.message;this.notifyErrorListeners(t,r,e)}reportUnwantedToken(t){if(this.inErrorRecoveryMode(t))return;this.beginErrorCondition(t);let e=t.currentToken,r="extraneous input "+this.getTokenErrorDisplay(e)+" expecting "+this.getExpectedTokens(t).toStringVocabulary(t.vocabulary);t.notifyErrorListeners(r,e,void 0)}reportMissingToken(t){if(this.inErrorRecoveryMode(t))return;this.beginErrorCondition(t);let e=t.currentToken,r="missing "+this.getExpectedTokens(t).toStringVocabulary(t.vocabulary)+" at "+this.getTokenErrorDisplay(e);t.notifyErrorListeners(r,e,void 0)}recoverInline(t){let e=this.singleTokenDeletion(t);if(e)return t.consume(),e;if(this.singleTokenInsertion(t))return this.getMissingSymbol(t);throw new s.InputMismatchException(t)}singleTokenInsertion(t){let e=t.inputStream.LA(1),r=t.interpreter.atn.states[t.state].transition(0).target,n=t.interpreter.atn;return!!n.nextTokens(r,u.PredictionContext.fromRuleContext(n,t.context)).contains(e)&&(this.reportMissingToken(t),!0)}singleTokenDeletion(t){let e=t.inputStream.LA(2);if(this.getExpectedTokens(t).contains(e)){this.reportUnwantedToken(t),t.consume();let e=t.currentToken;return this.reportMatch(t),e}}getMissingSymbol(t){let e,r=t.currentToken,n=this.getExpectedTokens(t).minElement;e=n===c.Token.EOF?"<missing EOF>":"<missing "+t.vocabulary.getDisplayName(n)+">";let i=r,o=t.inputStream.tryLT(-1);return i.type===c.Token.EOF&&null!=o&&(i=o),this.constructToken(t.inputStream.tokenSource,n,e,i)}constructToken(t,e,r,n){let i=t.tokenFactory,o=n.tokenSource,s=o?o.inputStream:void 0;return i.create({source:t,stream:s},e,r,c.Token.DEFAULT_CHANNEL,-1,-1,n.line,n.charPositionInLine)}getExpectedTokens(t){return t.getExpectedTokens()}getTokenErrorDisplay(t){if(!t)return"<no token>";let e=this.getSymbolText(t);return e||(e=this.getSymbolType(t)===c.Token.EOF?"<EOF>":`<${this.getSymbolType(t)}>`),this.escapeWSAndQuote(e)}getSymbolText(t){return t.text}getSymbolType(t){return t.type}escapeWSAndQuote(t){return"'"+(t=(t=(t=t.replace("\n","\\n")).replace("\r","\\r")).replace("\t","\\t"))+"'"}getErrorRecoverySet(t){let e=t.interpreter.atn,r=t.context,n=new l.IntervalSet;for(;r&&r.invokingState>=0;){let t=e.states[r.invokingState].transition(0),i=e.nextTokens(t.followState);n.addAll(i),r=r._parent}return n.remove(c.Token.EPSILON),n}consumeUntil(t,e){let r=t.inputStream.LA(1);for(;r!==c.Token.EOF&&!e.contains(r);)t.consume(),r=t.inputStream.LA(1)}}n([h.Override],p.prototype,"reset",null),n([i(0,h.NotNull)],p.prototype,"beginErrorCondition",null),n([h.Override],p.prototype,"inErrorRecoveryMode",null),n([i(0,h.NotNull)],p.prototype,"endErrorCondition",null),n([h.Override],p.prototype,"reportMatch",null),n([h.Override],p.prototype,"reportError",null),n([i(0,h.NotNull)],p.prototype,"notifyErrorListeners",null),n([h.Override],p.prototype,"recover",null),n([h.Override],p.prototype,"sync",null),n([i(0,h.NotNull),i(1,h.NotNull)],p.prototype,"reportNoViableAlternative",null),n([i(0,h.NotNull),i(1,h.NotNull)],p.prototype,"reportInputMismatch",null),n([i(0,h.NotNull),i(1,h.NotNull)],p.prototype,"reportFailedPredicate",null),n([i(0,h.NotNull)],p.prototype,"reportUnwantedToken",null),n([i(0,h.NotNull)],p.prototype,"reportMissingToken",null),n([h.Override],p.prototype,"recoverInline",null),n([i(0,h.NotNull)],p.prototype,"singleTokenInsertion",null),n([i(0,h.NotNull)],p.prototype,"singleTokenDeletion",null),n([h.NotNull,i(0,h.NotNull)],p.prototype,"getMissingSymbol",null),n([h.NotNull,i(0,h.NotNull)],p.prototype,"getExpectedTokens",null),n([i(0,h.NotNull)],p.prototype,"getSymbolText",null),n([i(0,h.NotNull)],p.prototype,"getSymbolType",null),n([h.NotNull,i(0,h.NotNull)],p.prototype,"escapeWSAndQuote",null),n([h.NotNull,i(0,h.NotNull)],p.prototype,"getErrorRecoverySet",null),n([i(0,h.NotNull),i(1,h.NotNull)],p.prototype,"consumeUntil",null),e.DefaultErrorStrategy=p},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(34),s=r(0),l=r(18);let a=class extends o.AbstractPredicateTransition{constructor(t,e,r,n){super(t),this.ruleIndex=e,this.predIndex=r,this.isCtxDependent=n}get serializationType(){return 4}get isEpsilon(){return!0}matches(t,e,r){return!1}get predicate(){return new l.SemanticContext.Predicate(this.ruleIndex,this.predIndex,this.isCtxDependent)}toString(){return"pred_"+this.ruleIndex+":"+this.predIndex}};n([s.Override],a.prototype,"serializationType",null),n([s.Override],a.prototype,"isEpsilon",null),n([s.Override],a.prototype,"matches",null),n([s.Override,s.NotNull],a.prototype,"toString",null),a=n([i(0,s.NotNull)],a),e.PredicateTransition=a},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(0),o=r(1),s=r(6);class l{hashCode(t){return null==t?0:"string"==typeof t||"number"==typeof t?o.MurmurHash.hashCode([t]):s.ObjectEqualityComparator.INSTANCE.hashCode(t)}equals(t,e){return null==t?null==e:"string"==typeof t||"number"==typeof t?t===e:s.ObjectEqualityComparator.INSTANCE.equals(t,e)}}l.INSTANCE=new l,n([i.Override],l.prototype,"hashCode",null),n([i.Override],l.prototype,"equals",null),e.DefaultEqualityComparator=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(38),o=r(3),s=r(0);class l{constructor(t=!1){this.copyText=t}create(t,e,r,n,s,l,a,u){let c=new i.CommonToken(e,r,t,n,s,l);return c.line=a,c.charPositionInLine=u,null==r&&this.copyText&&null!=t.stream&&(c.text=t.stream.getText(o.Interval.of(s,l))),c}createSimple(t,e){return new i.CommonToken(t,e)}}n([s.Override],l.prototype,"create",null),n([s.Override],l.prototype,"createSimple",null),e.CommonTokenFactory=l,function(t){t.DEFAULT=new t}(l=e.CommonTokenFactory||(e.CommonTokenFactory={}))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0});const n=r(36);e.IntegerStack=class extends n.IntegerList{constructor(t){super(t)}push(t){this.add(t)}pop(){return this.removeAt(this.size-1)}peek(){return this.get(this.size-1)}}},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(0);class s{constructor(t){if(this.delegates=t,!t)throw new Error("Invalid delegates")}getDelegates(){return this.delegates}syntaxError(t,e,r,n,i,o){this.delegates.forEach(s=>{s.syntaxError&&s.syntaxError(t,e,r,n,i,o)})}}n([o.Override,i(0,o.NotNull),i(4,o.NotNull)],s.prototype,"syntaxError",null),e.ProxyErrorListener=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(56),o=r(0);class s extends i.BasicState{get stateType(){return 0}}n([o.Override],s.prototype,"stateType",null),e.InvalidState=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(11),o=r(0);class s extends i.ATNState{get stateType(){return 1}}n([o.Override],s.prototype,"stateType",null),e.BasicState=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(0),s=r(9);let l=class extends s.Transition{constructor(t){super(t)}get serializationType(){return 9}matches(t,e,r){return t>=e&&t<=r}toString(){return"."}};n([o.Override],l.prototype,"serializationType",null),n([o.Override],l.prototype,"matches",null),n([o.Override,o.NotNull],l.prototype,"toString",null),l=n([i(0,o.NotNull)],l),e.WildcardTransition=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(17),s=r(0),l=r(3),a=r(8);let u=class extends o.RecognitionException{constructor(t,e,r,n){super(t,e),this._startIndex=r,this._deadEndConfigs=n}get startIndex(){return this._startIndex}get deadEndConfigs(){return this._deadEndConfigs}get inputStream(){return super.inputStream}toString(){let t="";return this._startIndex>=0&&this._startIndex<this.inputStream.size&&(t=this.inputStream.getText(l.Interval.of(this._startIndex,this._startIndex)),t=a.escapeWhitespace(t,!1)),`LexerNoViableAltException('${t}')`}};n([s.Override],u.prototype,"inputStream",null),n([s.Override],u.prototype,"toString",null),u=n([i(1,s.NotNull)],u),e.LexerNoViableAltException=u},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(0);class o{constructor(t){this.readOnly=!1,t?(this.verifyATN=t.verifyATN,this.generateRuleBypassTransitions=t.generateRuleBypassTransitions,this.optimize=t.optimize):(this.verifyATN=!0,this.generateRuleBypassTransitions=!1,this.optimize=!0)}static get defaultOptions(){return null==o._defaultOptions&&(o._defaultOptions=new o,o._defaultOptions.makeReadOnly()),o._defaultOptions}get isReadOnly(){return this.readOnly}makeReadOnly(){this.readOnly=!0}get isVerifyATN(){return this.verifyATN}set isVerifyATN(t){this.throwIfReadOnly(),this.verifyATN=t}get isGenerateRuleBypassTransitions(){return this.generateRuleBypassTransitions}set isGenerateRuleBypassTransitions(t){this.throwIfReadOnly(),this.generateRuleBypassTransitions=t}get isOptimize(){return this.optimize}set isOptimize(t){this.throwIfReadOnly(),this.optimize=t}throwIfReadOnly(){if(this.isReadOnly)throw new Error("The object is read only.")}}n([i.NotNull],o,"defaultOptions",null),e.ATNDeserializationOptions=o},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(0),s=r(9);let l=class extends s.Transition{constructor(t,e,r=-1,n=!1){super(t),this.ruleIndex=e,this.actionIndex=r,this.isCtxDependent=n}get serializationType(){return 6}get isEpsilon(){return!0}matches(t,e,r){return!1}toString(){return"action_"+this.ruleIndex+":"+this.actionIndex}};n([o.Override],l.prototype,"serializationType",null),n([o.Override],l.prototype,"isEpsilon",null),n([o.Override],l.prototype,"matches",null),n([o.Override],l.prototype,"toString",null),l=n([i(0,o.NotNull)],l),e.ActionTransition=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(14),s=r(0),l=r(9);let a=class extends l.Transition{constructor(t,e){super(t),this._label=e}get serializationType(){return 5}get label(){return o.IntervalSet.of(this._label)}matches(t,e,r){return this._label===t}toString(){return String(this.label)}};n([s.Override],a.prototype,"serializationType",null),n([s.Override,s.NotNull],a.prototype,"label",null),n([s.Override],a.prototype,"matches",null),n([s.Override,s.NotNull],a.prototype,"toString",null),a=n([i(0,s.NotNull)],a),e.AtomTransition=a},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(11),o=r(0);class s extends i.ATNState{get stateType(){return 12}}n([o.Override],s.prototype,"stateType",null),e.LoopEndState=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(3),o=r(0),s=r(2);class l{constructor(t){this._symbol=t}getChild(t){throw new RangeError("Terminal Node has no children.")}get symbol(){return this._symbol}get parent(){return this._parent}get payload(){return this._symbol}get sourceInterval(){let t=this._symbol.tokenIndex;return new i.Interval(t,t)}get childCount(){return 0}accept(t){return t.visitTerminal(this)}get text(){return this._symbol.text||""}toStringTree(t){return this.toString()}toString(){return this._symbol.type===s.Token.EOF?"<EOF>":this._symbol.text||""}}n([o.Override],l.prototype,"getChild",null),n([o.Override],l.prototype,"parent",null),n([o.Override],l.prototype,"payload",null),n([o.Override],l.prototype,"sourceInterval",null),n([o.Override],l.prototype,"childCount",null),n([o.Override],l.prototype,"accept",null),n([o.Override],l.prototype,"text",null),n([o.Override],l.prototype,"toStringTree",null),n([o.Override],l.prototype,"toString",null),e.TerminalNode=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(0),s=r(16);let l=class{constructor(t,e,r,n){this.outerContext=null!=t?t:s.ParserRuleContext.emptyContext(),this.s0=e,this.useContext=r,this.remainingOuterContext=n}};l=n([i(1,o.NotNull)],l),e.SimulatorState=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */function n(t){for(var r in t)e.hasOwnProperty(r)||(e[r]=t[r])}Object.defineProperty(e,"__esModule",{value:!0}),n(r(113)),n(r(116)),n(r(103)),n(r(38)),n(r(52)),n(r(119)),n(r(71)),n(r(49)),n(r(120)),n(r(121)),n(r(33)),n(r(35)),n(r(104)),n(r(22)),n(r(19)),n(r(122)),n(r(58)),n(r(123)),n(r(46)),n(r(30)),n(r(124)),n(r(16)),n(r(54)),n(r(101)),n(r(17)),n(r(29)),n(r(89)),n(r(125)),n(r(126)),n(r(105)),n(r(2)),n(r(127)),n(r(21))},function(t,e){var r;r=function(){return this}();try{r=r||Function("return this")()||(0,eval)("this")}catch(t){"object"==typeof window&&(r=window)}t.exports=r},function(t,e,r){(function(t,n){var i=/%[sdj%]/g;e.format=function(t){if(!_(t)){for(var e=[],r=0;r<arguments.length;r++)e.push(l(arguments[r]));return e.join(" ")}r=1;for(var n=arguments,o=n.length,s=String(t).replace(i,function(t){if("%%"===t)return"%";if(r>=o)return t;switch(t){case"%s":return String(n[r++]);case"%d":return Number(n[r++]);case"%j":try{return JSON.stringify(n[r++])}catch(t){return"[Circular]"}default:return t}}),a=n[r];r<o;a=n[++r])g(a)||!S(a)?s+=" "+a:s+=" "+l(a);return s},e.deprecate=function(r,i){if(m(t.process))return function(){return e.deprecate(r,i).apply(this,arguments)};if(!0===n.noDeprecation)return r;var o=!1;return function(){if(!o){if(n.throwDeprecation)throw new Error(i);n.traceDeprecation?console.trace(i):console.error(i),o=!0}return r.apply(this,arguments)}};var o,s={};function l(t,r){var n={seen:[],stylize:u};return arguments.length>=3&&(n.depth=arguments[2]),arguments.length>=4&&(n.colors=arguments[3]),f(r)?n.showHidden=r:r&&e._extend(n,r),m(n.showHidden)&&(n.showHidden=!1),m(n.depth)&&(n.depth=2),m(n.colors)&&(n.colors=!1),m(n.customInspect)&&(n.customInspect=!0),n.colors&&(n.stylize=a),c(n,t,n.depth)}function a(t,e){var r=l.styles[e];return r?"["+l.colors[r][0]+"m"+t+"["+l.colors[r][1]+"m":t}function u(t,e){return t}function c(t,r,n){if(t.customInspect&&r&&N(r.inspect)&&r.inspect!==e.inspect&&(!r.constructor||r.constructor.prototype!==r)){var i=r.inspect(n,t);return _(i)||(i=c(t,i,n)),i}var o=function(t,e){if(m(e))return t.stylize("undefined","undefined");if(_(e)){var r="'"+JSON.stringify(e).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return t.stylize(r,"string")}if(y(e))return t.stylize(""+e,"number");if(f(e))return t.stylize(""+e,"boolean");if(g(e))return t.stylize("null","null")}(t,r);if(o)return o;var s=Object.keys(r),l=function(t){var e={};return t.forEach(function(t,r){e[t]=!0}),e}(s);if(t.showHidden&&(s=Object.getOwnPropertyNames(r)),E(r)&&(s.indexOf("message")>=0||s.indexOf("description")>=0))return h(r);if(0===s.length){if(N(r)){var a=r.name?": "+r.name:"";return t.stylize("[Function"+a+"]","special")}if(T(r))return t.stylize(RegExp.prototype.toString.call(r),"regexp");if(x(r))return t.stylize(Date.prototype.toString.call(r),"date");if(E(r))return h(r)}var u,S="",O=!1,v=["{","}"];(d(r)&&(O=!0,v=["[","]"]),N(r))&&(S=" [Function"+(r.name?": "+r.name:"")+"]");return T(r)&&(S=" "+RegExp.prototype.toString.call(r)),x(r)&&(S=" "+Date.prototype.toUTCString.call(r)),E(r)&&(S=" "+h(r)),0!==s.length||O&&0!=r.length?n<0?T(r)?t.stylize(RegExp.prototype.toString.call(r),"regexp"):t.stylize("[Object]","special"):(t.seen.push(r),u=O?function(t,e,r,n,i){for(var o=[],s=0,l=e.length;s<l;++s)A(e,String(s))?o.push(p(t,e,r,n,String(s),!0)):o.push("");return i.forEach(function(i){i.match(/^\d+$/)||o.push(p(t,e,r,n,i,!0))}),o}(t,r,n,l,s):s.map(function(e){return p(t,r,n,l,e,O)}),t.seen.pop(),function(t,e,r){if(t.reduce(function(t,e){return 0,e.indexOf("\n")>=0&&0,t+e.replace(/\u001b\[\d\d?m/g,"").length+1},0)>60)return r[0]+(""===e?"":e+"\n ")+" "+t.join(",\n  ")+" "+r[1];return r[0]+e+" "+t.join(", ")+" "+r[1]}(u,S,v)):v[0]+S+v[1]}function h(t){return"["+Error.prototype.toString.call(t)+"]"}function p(t,e,r,n,i,o){var s,l,a;if((a=Object.getOwnPropertyDescriptor(e,i)||{value:e[i]}).get?l=a.set?t.stylize("[Getter/Setter]","special"):t.stylize("[Getter]","special"):a.set&&(l=t.stylize("[Setter]","special")),A(n,i)||(s="["+i+"]"),l||(t.seen.indexOf(a.value)<0?(l=g(r)?c(t,a.value,null):c(t,a.value,r-1)).indexOf("\n")>-1&&(l=o?l.split("\n").map(function(t){return"  "+t}).join("\n").substr(2):"\n"+l.split("\n").map(function(t){return"   "+t}).join("\n")):l=t.stylize("[Circular]","special")),m(s)){if(o&&i.match(/^\d+$/))return l;(s=JSON.stringify(""+i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(s=s.substr(1,s.length-2),s=t.stylize(s,"name")):(s=s.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),s=t.stylize(s,"string"))}return s+": "+l}function d(t){return Array.isArray(t)}function f(t){return"boolean"==typeof t}function g(t){return null===t}function y(t){return"number"==typeof t}function _(t){return"string"==typeof t}function m(t){return void 0===t}function T(t){return S(t)&&"[object RegExp]"===O(t)}function S(t){return"object"==typeof t&&null!==t}function x(t){return S(t)&&"[object Date]"===O(t)}function E(t){return S(t)&&("[object Error]"===O(t)||t instanceof Error)}function N(t){return"function"==typeof t}function O(t){return Object.prototype.toString.call(t)}function v(t){return t<10?"0"+t.toString(10):t.toString(10)}e.debuglog=function(t){if(m(o)&&(o=n.env.NODE_DEBUG||""),t=t.toUpperCase(),!s[t])if(new RegExp("\\b"+t+"\\b","i").test(o)){var r=n.pid;s[t]=function(){var n=e.format.apply(e,arguments);console.error("%s %d: %s",t,r,n)}}else s[t]=function(){};return s[t]},e.inspect=l,l.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},l.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},e.isArray=d,e.isBoolean=f,e.isNull=g,e.isNullOrUndefined=function(t){return null==t},e.isNumber=y,e.isString=_,e.isSymbol=function(t){return"symbol"==typeof t},e.isUndefined=m,e.isRegExp=T,e.isObject=S,e.isDate=x,e.isError=E,e.isFunction=N,e.isPrimitive=function(t){return null===t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||"symbol"==typeof t||void 0===t},e.isBuffer=r(114);var b=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function A(t,e){return Object.prototype.hasOwnProperty.call(t,e)}e.log=function(){var t,r;console.log("%s - %s",(t=new Date,r=[v(t.getHours()),v(t.getMinutes()),v(t.getSeconds())].join(":"),[t.getDate(),b[t.getMonth()],r].join(" ")),e.format.apply(e,arguments))},e.inherits=r(115),e._extend=function(t,e){if(!e||!S(e))return t;for(var r=Object.keys(e),n=r.length;n--;)t[r[n]]=e[r[n]];return t}}).call(e,r(66),r(48))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0});e.AcceptStateInfo=class{constructor(t,e){this._prediction=t,this._lexerActionExecutor=e}get prediction(){return this._prediction}get lexerActionExecutor(){return this._lexerActionExecutor}}},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(10),s=r(23),l=r(70),a=r(41),u=r(117),c=r(0),h=r(6),p=r(42),d=r(21);let f=class{constructor(t,e=0){if(this.states=new o.Array2DHashSet(h.ObjectEqualityComparator.INSTANCE),this.nextStateNumber=0,!t.atn)throw new Error("The ATNState must be associated with an ATN");this.atnStartState=t,this.atn=t.atn,this.decision=e;let r=!1;t instanceof p.StarLoopEntryState&&t.precedenceRuleDecision&&(r=!0,this.s0=new a.DFAState(new s.ATNConfigSet),this.s0full=new a.DFAState(new s.ATNConfigSet)),this.precedenceDfa=r}get isPrecedenceDfa(){return this.precedenceDfa}getPrecedenceStartState(t,e){if(!this.isPrecedenceDfa)throw new Error("Only precedence DFAs may contain a precedence start state.");return e?this.s0full.getTarget(t):this.s0.getTarget(t)}setPrecedenceStartState(t,e,r){if(!this.isPrecedenceDfa)throw new Error("Only precedence DFAs may contain a precedence start state.");t<0||(e?this.s0full.setTarget(t,r):this.s0.setTarget(t,r))}get isEmpty(){return this.isPrecedenceDfa?0===this.s0.getEdgeMap().size&&0===this.s0full.getEdgeMap().size:null==this.s0&&null==this.s0full}get isContextSensitive(){return this.isPrecedenceDfa?this.s0full.getEdgeMap().size>0:null!=this.s0full}addState(t){return t.stateNumber=this.nextStateNumber++,this.states.getOrAdd(t)}toString(t,e){if(t||(t=d.VocabularyImpl.EMPTY_VOCABULARY),!this.s0)return"";let r;return(r=e?new l.DFASerializer(this,t,e,this.atnStartState.atn):new l.DFASerializer(this,t)).toString()}toLexerString(){if(!this.s0)return"";return new u.LexerDFASerializer(this).toString()}};n([c.NotNull],f.prototype,"states",void 0),n([c.NotNull],f.prototype,"atnStartState",void 0),n([c.NotNull],f.prototype,"atn",void 0),f=n([i(0,c.NotNull)],f),e.DFA=f},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(13),o=r(28),s=r(0),l=r(4),a=r(29),u=r(21);class c{constructor(t,e,r,n){e instanceof a.Recognizer?(r=e.ruleNames,n=e.atn,e=e.vocabulary):e||(e=u.VocabularyImpl.EMPTY_VOCABULARY),this.dfa=t,this.vocabulary=e,this.ruleNames=r,this.atn=n}toString(){if(!this.dfa.s0)return"";let t="";if(this.dfa.states){let e=new Array(...this.dfa.states.toArray());e.sort((t,e)=>t.stateNumber-e.stateNumber);for(let r of e){let e=r.getEdgeMap(),n=[...e.keys()].sort((t,e)=>t-e),i=r.getContextEdgeMap(),s=[...i.keys()].sort((t,e)=>t-e);for(let i of n){let n=e.get(i);if((null==n||n===o.ATNSimulator.ERROR)&&!r.isContextSymbol(i))continue;let s=!1;t+=this.getStateString(r)+"-"+this.getEdgeLabel(i)+"->",r.isContextSymbol(i)&&(t+="!",s=!0);let l=n;l&&l.stateNumber!==o.ATNSimulator.ERROR.stateNumber?t+=this.getStateString(l)+"\n":s&&(t+="ctx\n")}if(r.isContextSensitive)for(let e of s)t+=this.getStateString(r)+"-"+this.getContextLabel(e)+"->"+this.getStateString(i.get(e))+"\n"}}let e=t;return 0===e.length?"":e}getContextLabel(t){if(t===l.PredictionContext.EMPTY_FULL_STATE_KEY)return"ctx:EMPTY_FULL";if(t===l.PredictionContext.EMPTY_LOCAL_STATE_KEY)return"ctx:EMPTY_LOCAL";if(this.atn&&t>0&&t<=this.atn.states.length){let e=this.atn.states[t].ruleIndex;if(this.ruleNames&&e>=0&&e<this.ruleNames.length)return"ctx:"+String(t)+"("+this.ruleNames[e]+")"}return"ctx:"+String(t)}getEdgeLabel(t){return this.vocabulary.getDisplayName(t)}getStateString(t){if(t===o.ATNSimulator.ERROR)return"ERROR";let e=t.stateNumber,r="s"+e;if(t.isAcceptState&&(r=t.predicates?":s"+e+"=>"+t.predicates:":s"+e+"=>"+t.prediction),t.isContextSensitive){r+="*";for(let e of i.asIterable(t.configs))if(e.reachesIntoOuterContext){r+="*";break}}return r}}n([s.NotNull],c.prototype,"dfa",void 0),n([s.NotNull],c.prototype,"vocabulary",void 0),n([s.Override],c.prototype,"toString",null),e.DFASerializer=c},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0});class n{syntaxError(t,e,r,n,i,o){console.error(`line ${r}:${n} ${i}`)}}n.INSTANCE=new n,e.ConsoleErrorListener=n},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(34),s=r(10),l=r(27),a=r(12),u=r(14),c=r(0),h=r(43),p=r(6),d=r(4),f=r(24),g=r(45),y=r(2),_=r(57);let m=class t{constructor(t){this.atn=t}getDecisionLookahead(e){if(null==e)return;let r=new Array(e.numberOfTransitions);for(let n=0;n<e.numberOfTransitions;n++){let i=new u.IntervalSet;r[n]=i;let o=new s.Array2DHashSet(p.ObjectEqualityComparator.INSTANCE),l=!1;this._LOOK(e.transition(n).target,void 0,d.PredictionContext.EMPTY_LOCAL,i,o,new a.BitSet,l,!1),(0===i.size||i.contains(t.HIT_PRED))&&(i=void 0,r[n]=i)}return r}LOOK(t,e,r){if(void 0===r){if(null==t.atn)throw new Error("Illegal state");r=t.atn.ruleToStopState[t.ruleIndex]}else null===r&&(r=void 0);let n=new u.IntervalSet;return this._LOOK(t,r,e,n,new s.Array2DHashSet,new a.BitSet,!0,!0),n}_LOOK(e,r,n,i,s,a,c,p){let m=l.ATNConfig.create(e,0,n);if(!s.add(m))return;if(e===r){if(d.PredictionContext.isEmptyLocal(n))return void i.add(y.Token.EPSILON);if(n.isEmpty)return void(p&&i.add(y.Token.EOF))}if(e instanceof f.RuleStopState){if(n.isEmpty&&!d.PredictionContext.isEmptyLocal(n))return void(p&&i.add(y.Token.EOF));let t=a.get(e.ruleIndex);try{a.clear(e.ruleIndex);for(let t=0;t<n.size;t++){if(n.getReturnState(t)===d.PredictionContext.EMPTY_FULL_STATE_KEY)continue;let e=this.atn.states[n.getReturnState(t)];this._LOOK(e,r,n.getParent(t),i,s,a,c,p)}}finally{t&&a.set(e.ruleIndex)}}let T=e.numberOfTransitions;for(let l=0;l<T;l++){let d=e.transition(l);if(d instanceof g.RuleTransition){if(a.get(d.ruleIndex))continue;let t=n.getChild(d.followState.stateNumber);try{a.set(d.ruleIndex),this._LOOK(d.target,r,t,i,s,a,c,p)}finally{a.clear(d.ruleIndex)}}else if(d instanceof o.AbstractPredicateTransition)c?this._LOOK(d.target,r,n,i,s,a,c,p):i.add(t.HIT_PRED);else if(d.isEpsilon)this._LOOK(d.target,r,n,i,s,a,c,p);else if(d instanceof _.WildcardTransition)i.addAll(u.IntervalSet.of(y.Token.MIN_USER_TOKEN_TYPE,this.atn.maxTokenType));else{let t=d.label;null!=t&&(d instanceof h.NotSetTransition&&(t=t.complement(u.IntervalSet.of(y.Token.MIN_USER_TOKEN_TYPE,this.atn.maxTokenType))),i.addAll(t))}}}};m.HIT_PRED=y.Token.INVALID_TYPE,n([c.NotNull],m.prototype,"atn",void 0),n([c.NotNull,i(0,c.NotNull),i(1,c.NotNull)],m.prototype,"LOOK",null),n([i(0,c.NotNull),i(2,c.NotNull),i(3,c.NotNull),i(4,c.NotNull),i(5,c.NotNull)],m.prototype,"_LOOK",null),m=n([i(0,c.NotNull)],m),e.LL1Analyzer=m},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(26),s=r(74),l=r(1),a=r(0);let u=class t{constructor(t){this._lexerActions=t;let e=l.MurmurHash.initialize();for(let r of t)e=l.MurmurHash.update(e,r);this.cachedHashCode=l.MurmurHash.finish(e,t.length)}static append(e,r){if(!e)return new t([r]);let n=e._lexerActions.slice(0);return n.push(r),new t(n)}fixOffsetBeforeMatch(e){let r;for(let t=0;t<this._lexerActions.length;t++)!this._lexerActions[t].isPositionDependent||this._lexerActions[t]instanceof s.LexerIndexedCustomAction||(r||(r=this._lexerActions.slice(0)),r[t]=new s.LexerIndexedCustomAction(e,this._lexerActions[t]));return r?new t(r):this}get lexerActions(){return this._lexerActions}execute(t,e,r){let n=!1,i=e.index;try{for(let o of this._lexerActions){if(o instanceof s.LexerIndexedCustomAction){let t=o.offset;e.seek(r+t),o=o.action,n=r+t!==i}else o.isPositionDependent&&(e.seek(i),n=!1);o.execute(t)}}finally{n&&e.seek(i)}}hashCode(){return this.cachedHashCode}equals(e){return e===this||e instanceof t&&(this.cachedHashCode===e.cachedHashCode&&o.ArrayEqualityComparator.INSTANCE.equals(this._lexerActions,e._lexerActions))}};n([a.NotNull],u.prototype,"_lexerActions",void 0),n([a.NotNull],u.prototype,"lexerActions",null),n([i(0,a.NotNull)],u.prototype,"execute",null),n([a.Override],u.prototype,"hashCode",null),n([a.Override],u.prototype,"equals",null),n([a.NotNull,i(1,a.NotNull)],u,"append",null),u=n([i(0,a.NotNull)],u),e.LexerActionExecutor=u},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(1),s=r(0);let l=class t{constructor(t,e){this._offset=t,this._action=e}get offset(){return this._offset}get action(){return this._action}get actionType(){return this._action.actionType}get isPositionDependent(){return!0}execute(t){this._action.execute(t)}hashCode(){let t=o.MurmurHash.initialize();return t=o.MurmurHash.update(t,this._offset),t=o.MurmurHash.update(t,this._action),o.MurmurHash.finish(t,2)}equals(e){return e===this||e instanceof t&&(this._offset===e._offset&&this._action.equals(e._action))}};n([s.NotNull],l.prototype,"action",null),n([s.Override],l.prototype,"actionType",null),n([s.Override],l.prototype,"isPositionDependent",null),n([s.Override],l.prototype,"execute",null),n([s.Override],l.prototype,"hashCode",null),n([s.Override],l.prototype,"equals",null),l=n([i(1,s.NotNull)],l),e.LexerIndexedCustomAction=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(23),o=r(0);class s extends i.ATNConfigSet{constructor(t,e){null!=t&&null!=e?super(t,e):super()}clone(t){let e=new s(this,t);return!t&&this.isReadOnly&&e.addAll(this),e}getKey(t){return{state:0,alt:t.hashCode()}}canMerge(t,e,r){return t.equals(r)}}n([o.Override],s.prototype,"clone",null),n([o.Override],s.prototype,"getKey",null),n([o.Override],s.prototype,"canMerge",null),e.OrderedATNConfigSet=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(31),o=r(0);class s extends i.BlockStartState{get stateType(){return 3}}n([o.Override],s.prototype,"stateType",null),e.BasicBlockStartState=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(11),o=r(0);class s extends i.ATNState{get stateType(){return 8}}n([o.Override],s.prototype,"stateType",null),e.BlockEndState=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(0),s=r(9);let l=class extends s.Transition{constructor(t,e=-1){super(t),this._outermostPrecedenceReturn=e}get outermostPrecedenceReturn(){return this._outermostPrecedenceReturn}get serializationType(){return 1}get isEpsilon(){return!0}matches(t,e,r){return!1}toString(){return"epsilon"}};n([o.Override],l.prototype,"serializationType",null),n([o.Override],l.prototype,"isEpsilon",null),n([o.Override],l.prototype,"matches",null),n([o.Override,o.NotNull],l.prototype,"toString",null),l=n([i(0,o.NotNull)],l),e.EpsilonTransition=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(1),s=r(0);class l{constructor(t){this._channel=t}get channel(){return this._channel}get actionType(){return 0}get isPositionDependent(){return!1}execute(t){t.channel=this._channel}hashCode(){let t=o.MurmurHash.initialize();return t=o.MurmurHash.update(t,this.actionType),t=o.MurmurHash.update(t,this._channel),o.MurmurHash.finish(t,2)}equals(t){return t===this||t instanceof l&&this._channel===t._channel}toString(){return`channel(${this._channel})`}}n([s.Override],l.prototype,"actionType",null),n([s.Override],l.prototype,"isPositionDependent",null),n([s.Override,i(0,s.NotNull)],l.prototype,"execute",null),n([s.Override],l.prototype,"hashCode",null),n([s.Override],l.prototype,"equals",null),n([s.Override],l.prototype,"toString",null),e.LexerChannelAction=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(1),s=r(0);class l{constructor(t,e){this._ruleIndex=t,this._actionIndex=e}get ruleIndex(){return this._ruleIndex}get actionIndex(){return this._actionIndex}get actionType(){return 1}get isPositionDependent(){return!0}execute(t){t.action(void 0,this._ruleIndex,this._actionIndex)}hashCode(){let t=o.MurmurHash.initialize();return t=o.MurmurHash.update(t,this.actionType),t=o.MurmurHash.update(t,this._ruleIndex),t=o.MurmurHash.update(t,this._actionIndex),o.MurmurHash.finish(t,3)}equals(t){return t===this||t instanceof l&&(this._ruleIndex===t._ruleIndex&&this._actionIndex===t._actionIndex)}}n([s.Override],l.prototype,"actionType",null),n([s.Override],l.prototype,"isPositionDependent",null),n([s.Override,i(0,s.NotNull)],l.prototype,"execute",null),n([s.Override],l.prototype,"hashCode",null),n([s.Override],l.prototype,"equals",null),e.LexerCustomAction=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(1),s=r(0);class l{constructor(t){this._mode=t}get mode(){return this._mode}get actionType(){return 2}get isPositionDependent(){return!1}execute(t){t.mode(this._mode)}hashCode(){let t=o.MurmurHash.initialize();return t=o.MurmurHash.update(t,this.actionType),t=o.MurmurHash.update(t,this._mode),o.MurmurHash.finish(t,2)}equals(t){return t===this||t instanceof l&&this._mode===t._mode}toString(){return`mode(${this._mode})`}}n([s.Override],l.prototype,"actionType",null),n([s.Override],l.prototype,"isPositionDependent",null),n([s.Override,i(0,s.NotNull)],l.prototype,"execute",null),n([s.Override],l.prototype,"hashCode",null),n([s.Override],l.prototype,"equals",null),n([s.Override],l.prototype,"toString",null),e.LexerModeAction=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(1),s=r(0);class l{constructor(){}get actionType(){return 3}get isPositionDependent(){return!1}execute(t){t.more()}hashCode(){let t=o.MurmurHash.initialize();return t=o.MurmurHash.update(t,this.actionType),o.MurmurHash.finish(t,1)}equals(t){return t===this}toString(){return"more"}}n([s.Override],l.prototype,"actionType",null),n([s.Override],l.prototype,"isPositionDependent",null),n([s.Override,i(0,s.NotNull)],l.prototype,"execute",null),n([s.Override],l.prototype,"hashCode",null),n([s.Override],l.prototype,"equals",null),n([s.Override],l.prototype,"toString",null),e.LexerMoreAction=l,function(t){t.INSTANCE=new t}(l=e.LexerMoreAction||(e.LexerMoreAction={}))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(1),s=r(0);class l{constructor(){}get actionType(){return 4}get isPositionDependent(){return!1}execute(t){t.popMode()}hashCode(){let t=o.MurmurHash.initialize();return t=o.MurmurHash.update(t,this.actionType),o.MurmurHash.finish(t,1)}equals(t){return t===this}toString(){return"popMode"}}n([s.Override],l.prototype,"actionType",null),n([s.Override],l.prototype,"isPositionDependent",null),n([s.Override,i(0,s.NotNull)],l.prototype,"execute",null),n([s.Override],l.prototype,"hashCode",null),n([s.Override],l.prototype,"equals",null),n([s.Override],l.prototype,"toString",null),e.LexerPopModeAction=l,function(t){t.INSTANCE=new t}(l=e.LexerPopModeAction||(e.LexerPopModeAction={}))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(1),s=r(0);class l{constructor(t){this._mode=t}get mode(){return this._mode}get actionType(){return 5}get isPositionDependent(){return!1}execute(t){t.pushMode(this._mode)}hashCode(){let t=o.MurmurHash.initialize();return t=o.MurmurHash.update(t,this.actionType),t=o.MurmurHash.update(t,this._mode),o.MurmurHash.finish(t,2)}equals(t){return t===this||t instanceof l&&this._mode===t._mode}toString(){return`pushMode(${this._mode})`}}n([s.Override],l.prototype,"actionType",null),n([s.Override],l.prototype,"isPositionDependent",null),n([s.Override,i(0,s.NotNull)],l.prototype,"execute",null),n([s.Override],l.prototype,"hashCode",null),n([s.Override],l.prototype,"equals",null),n([s.Override],l.prototype,"toString",null),e.LexerPushModeAction=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(1),s=r(0);class l{constructor(){}get actionType(){return 6}get isPositionDependent(){return!1}execute(t){t.skip()}hashCode(){let t=o.MurmurHash.initialize();return t=o.MurmurHash.update(t,this.actionType),o.MurmurHash.finish(t,1)}equals(t){return t===this}toString(){return"skip"}}n([s.Override],l.prototype,"actionType",null),n([s.Override],l.prototype,"isPositionDependent",null),n([s.Override,i(0,s.NotNull)],l.prototype,"execute",null),n([s.Override],l.prototype,"hashCode",null),n([s.Override],l.prototype,"equals",null),n([s.Override],l.prototype,"toString",null),e.LexerSkipAction=l,function(t){t.INSTANCE=new t}(l=e.LexerSkipAction||(e.LexerSkipAction={}))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(1),s=r(0);class l{constructor(t){this._type=t}get type(){return this._type}get actionType(){return 7}get isPositionDependent(){return!1}execute(t){t.type=this._type}hashCode(){let t=o.MurmurHash.initialize();return t=o.MurmurHash.update(t,this.actionType),t=o.MurmurHash.update(t,this._type),o.MurmurHash.finish(t,2)}equals(t){return t===this||t instanceof l&&this._type===t._type}toString(){return`type(${this._type})`}}n([s.Override],l.prototype,"actionType",null),n([s.Override],l.prototype,"isPositionDependent",null),n([s.Override,i(0,s.NotNull)],l.prototype,"execute",null),n([s.Override],l.prototype,"hashCode",null),n([s.Override],l.prototype,"equals",null),n([s.Override],l.prototype,"toString",null),e.LexerTypeAction=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(0),o=r(8);class s{constructor(t,e){this._conflictedAlts=t,this.exact=e}get conflictedAlts(){return this._conflictedAlts}get isExact(){return this.exact}equals(t){return t===this||t instanceof s&&(this.isExact===t.isExact&&o.equals(this.conflictedAlts,t.conflictedAlts))}hashCode(){return this.conflictedAlts.hashCode()}}n([i.Override],s.prototype,"equals",null),n([i.Override],s.prototype,"hashCode",null),e.ConflictInfo=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(0),o=r(63);class s extends o.TerminalNode{constructor(t){super(t)}accept(t){return t.visitErrorNode(this)}}n([i.Override],s.prototype,"accept",null),e.ErrorNode=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(7),o=r(29),s=r(90),l=r(3),a=r(0),u=r(118),c=r(16);class h extends s.RuleNode{constructor(t,e){super(),this._parent=t,this.invokingState=null!=e?e:-1}static getChildContext(t,e){return new h(t,e)}depth(){let t=0,e=this;for(;e;)e=e._parent,t++;return t}get isEmpty(){return-1===this.invokingState}get sourceInterval(){return l.Interval.INVALID}get ruleContext(){return this}get parent(){return this._parent}get payload(){return this}get text(){if(0===this.childCount)return"";let t="";for(let e=0;e<this.childCount;e++)t+=this.getChild(e).text;return t.toString()}get ruleIndex(){return-1}get altNumber(){return i.ATN.INVALID_ALT_NUMBER}set altNumber(t){}getChild(t){throw new RangeError("i must be greater than or equal to 0 and less than childCount")}get childCount(){return 0}accept(t){return t.visitChildren(this)}toStringTree(t){return u.Trees.toStringTree(this,t)}toString(t,e){const r=t instanceof o.Recognizer?t.ruleNames:t;e=e||c.ParserRuleContext.emptyContext();let n="",i=this;for(n+="[";i&&i!==e;){if(r){let t=i.ruleIndex;n+=t>=0&&t<r.length?r[t]:t.toString()}else i.isEmpty||(n+=i.invokingState);!i._parent||!r&&i._parent.isEmpty||(n+=" "),i=i._parent}return(n+="]").toString()}}n([a.Override],h.prototype,"sourceInterval",null),n([a.Override],h.prototype,"ruleContext",null),n([a.Override],h.prototype,"parent",null),n([a.Override],h.prototype,"payload",null),n([a.Override],h.prototype,"text",null),n([a.Override],h.prototype,"getChild",null),n([a.Override],h.prototype,"childCount",null),n([a.Override],h.prototype,"accept",null),n([a.Override],h.prototype,"toStringTree",null),e.RuleContext=h},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0});e.RuleNode=class{}},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});r(20);const i=r(13),o=r(1),s=r(0),l=r(24);!function(t){t[t.SLL=0]="SLL",t[t.LL=1]="LL",t[t.LL_EXACT_AMBIG_DETECTION=2]="LL_EXACT_AMBIG_DETECTION"}(e.PredictionMode||(e.PredictionMode={})),function(t){class e{AltAndContextConfigEqualityComparator(){}hashCode(t){let e=o.MurmurHash.initialize(7);return e=o.MurmurHash.update(e,t.state.stateNumber),e=o.MurmurHash.update(e,t.context),e=o.MurmurHash.finish(e,2)}equals(t,e){return t===e||null!=t&&null!=e&&(t.state.stateNumber==e.state.stateNumber&&t.context.equals(e.context))}}e.INSTANCE=new e,n([s.Override],e.prototype,"hashCode",null),n([s.Override],e.prototype,"equals",null),t.hasConfigInRuleStopState=function(t){for(let e of i.asIterable(t))if(e.state instanceof l.RuleStopState)return!0;return!1},t.allConfigsInRuleStopStates=function(t){for(let e of i.asIterable(t))if(!(e.state instanceof l.RuleStopState))return!1;return!0}}(e.PredictionMode||(e.PredictionMode={}))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(31),o=r(0);class s extends i.BlockStartState{get stateType(){return 4}}n([o.Override],s.prototype,"stateType",null),e.PlusBlockStartState=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(15),o=r(0);class s extends i.DecisionState{get stateType(){return 11}}n([o.Override],s.prototype,"stateType",null),e.PlusLoopbackState=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(34),s=r(0),l=r(18);let a=class extends o.AbstractPredicateTransition{constructor(t,e){super(t),this.precedence=e}get serializationType(){return 10}get isEpsilon(){return!0}matches(t,e,r){return!1}get predicate(){return new l.SemanticContext.PrecedencePredicate(this.precedence)}toString(){return this.precedence+" >= _p"}};n([s.Override],a.prototype,"serializationType",null),n([s.Override],a.prototype,"isEpsilon",null),n([s.Override],a.prototype,"matches",null),n([s.Override],a.prototype,"toString",null),a=n([i(0,s.NotNull)],a),e.PrecedencePredicateTransition=a},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(14),s=r(0),l=r(9);let a=class extends l.Transition{constructor(t,e,r){super(t),this.from=e,this.to=r}get serializationType(){return 2}get label(){return o.IntervalSet.of(this.from,this.to)}matches(t,e,r){return t>=this.from&&t<=this.to}toString(){return"'"+String.fromCharCode(this.from)+"'..'"+String.fromCharCode(this.to)+"'"}};n([s.Override],a.prototype,"serializationType",null),n([s.Override,s.NotNull],a.prototype,"label",null),n([s.Override],a.prototype,"matches",null),n([s.Override,s.NotNull],a.prototype,"toString",null),a=n([i(0,s.NotNull)],a),e.RangeTransition=a},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(11),o=r(0);class s extends i.ATNState{constructor(){super(...arguments),this.isPrecedenceRule=!1,this.leftFactored=!1}get stateType(){return 2}}n([o.Override],s.prototype,"stateType",null),e.RuleStartState=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(31),o=r(0);class s extends i.BlockStartState{get stateType(){return 5}}n([o.Override],s.prototype,"stateType",null),e.StarBlockStartState=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(11),o=r(0);class s extends i.ATNState{get loopEntryState(){return this.transition(0).target}get stateType(){return 9}}n([o.Override],s.prototype,"stateType",null),e.StarLoopbackState=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(15),o=r(0);class s extends i.DecisionState{get stateType(){return 6}}n([o.Override],s.prototype,"stateType",null),e.TokensStartState=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0});const n=r(1);class i{constructor(t,e,r,n){this.data=new Uint32Array(4),this.data[0]=t,this.data[1]=e,this.data[2]=r,this.data[3]=n}static fromString(t){if(!/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.test(t))throw new Error("Incorrectly formatted UUID");let e=t.split("-"),r=parseInt(e[0],16),n=(parseInt(e[1],16)<<16>>>0)+parseInt(e[2],16),o=(parseInt(e[3],16)<<16>>>0)+parseInt(e[4].substr(0,4),16),s=parseInt(e[4].substr(-8),16);return new i(r,n,o,s)}hashCode(){return n.MurmurHash.hashCode([this.data[0],this.data[1],this.data[2],this.data[3]])}equals(t){return t===this||t instanceof i&&(this.data[0]===t.data[0]&&this.data[1]===t.data[1]&&this.data[2]===t.data[2]&&this.data[3]===t.data[3])}toString(){return("00000000"+this.data[0].toString(16)).substr(-8)+"-"+("0000"+(this.data[1]>>>16).toString(16)).substr(-4)+"-"+("0000"+this.data[1].toString(16)).substr(-4)+"-"+("0000"+(this.data[2]>>>16).toString(16)).substr(-4)+"-"+("0000"+this.data[2].toString(16)).substr(-4)+("00000000"+this.data[3].toString(16)).substr(-8)}}e.UUID=i},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(54),o=r(0);class s extends i.ProxyErrorListener{constructor(t){super(t)}reportAmbiguity(t,e,r,n,i,o,s){this.getDelegates().forEach(l=>{l.reportAmbiguity&&l.reportAmbiguity(t,e,r,n,i,o,s)})}reportAttemptingFullContext(t,e,r,n,i,o){this.getDelegates().forEach(s=>{s.reportAttemptingFullContext&&s.reportAttemptingFullContext(t,e,r,n,i,o)})}reportContextSensitivity(t,e,r,n,i,o){this.getDelegates().forEach(s=>{s.reportContextSensitivity&&s.reportContextSensitivity(t,e,r,n,i,o)})}}n([o.Override],s.prototype,"reportAmbiguity",null),n([o.Override],s.prototype,"reportAttemptingFullContext",null),n([o.Override],s.prototype,"reportContextSensitivity",null),e.ProxyParserErrorListener=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0});e.ParseCancellationException=class extends Error{constructor(t){super(t.message),this.cause=t,this.stack=t.stack}getCause(){return this.cause}}},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(5),s=r(38),l=r(3),a=r(19),u=r(0),c=r(2);let h=class{constructor(t){if(this.tokens=[],this.p=-1,this.fetchedEOF=!1,null==t)throw new Error("tokenSource cannot be null");this._tokenSource=t}get tokenSource(){return this._tokenSource}get index(){return this.p}mark(){return 0}release(t){}seek(t){this.lazyInit(),this.p=this.adjustSeekIndex(t)}get size(){return this.tokens.length}consume(){let t;if(!(t=this.p>=0&&(this.fetchedEOF?this.p<this.tokens.length-1:this.p<this.tokens.length))&&this.LA(1)===c.Token.EOF)throw new Error("cannot consume EOF");this.sync(this.p+1)&&(this.p=this.adjustSeekIndex(this.p+1))}sync(t){o(t>=0);let e=t-this.tokens.length+1;if(e>0){return this.fetch(e)>=e}return!0}fetch(t){if(this.fetchedEOF)return 0;for(let e=0;e<t;e++){let t=this.tokenSource.nextToken();if(this.isWritableToken(t)&&(t.tokenIndex=this.tokens.length),this.tokens.push(t),t.type===c.Token.EOF)return this.fetchedEOF=!0,e+1}return t}get(t){if(t<0||t>=this.tokens.length)throw new RangeError("token index "+t+" out of range 0.."+(this.tokens.length-1));return this.tokens[t]}getRange(t,e){if(t<0||e<0)return[];this.lazyInit();let r=new Array;e>=this.tokens.length&&(e=this.tokens.length-1);for(let n=t;n<=e;n++){let t=this.tokens[n];if(t.type===c.Token.EOF)break;r.push(t)}return r}LA(t){let e=this.LT(t);return e?e.type:c.Token.INVALID_TYPE}tryLB(t){if(!(this.p-t<0))return this.tokens[this.p-t]}LT(t){let e=this.tryLT(t);if(void 0===e)throw new RangeError("requested lookback index out of range");return e}tryLT(t){if(this.lazyInit(),0===t)throw new RangeError("0 is not a valid lookahead index");if(t<0)return this.tryLB(-t);let e=this.p+t-1;return this.sync(e),e>=this.tokens.length?this.tokens[this.tokens.length-1]:this.tokens[e]}adjustSeekIndex(t){return t}lazyInit(){-1===this.p&&this.setup()}setup(){this.sync(0),this.p=this.adjustSeekIndex(0)}set tokenSource(t){this._tokenSource=t,this.tokens.length=0,this.p=-1,this.fetchedEOF=!1}getTokens(t,e,r){if(this.lazyInit(),t=t||0,e=e||this.tokens.length-1,t<0||e>=this.tokens.length||e<0||t>=this.tokens.length)throw new RangeError("start "+t+" or stop "+e+" not in 0.."+(this.tokens.length-1));if(0===t&&e===this.tokens.length-1)return this.tokens;if(t>e)return[];if(null==r)return this.tokens.slice(t,e+1);"number"==typeof r&&(r=(new Set).add(r));let n=r,i=this.tokens.slice(t,e+1);return i=i.filter(t=>n.has(t.type))}nextTokenOnChannel(t,e){if(this.sync(t),t>=this.size)return this.size-1;let r=this.tokens[t];for(;r.channel!==e;){if(r.type===c.Token.EOF)return t;t++,this.sync(t),r=this.tokens[t]}return t}previousTokenOnChannel(t,e){if(this.sync(t),t>=this.size)return this.size-1;for(;t>=0;){let r=this.tokens[t];if(r.type===c.Token.EOF||r.channel===e)return t;t--}return t}getHiddenTokensToRight(t,e=-1){if(this.lazyInit(),t<0||t>=this.tokens.length)throw new RangeError(t+" not in 0.."+(this.tokens.length-1));let r,n=this.nextTokenOnChannel(t+1,a.Lexer.DEFAULT_TOKEN_CHANNEL),i=t+1;return r=-1===n?this.size-1:n,this.filterForChannel(i,r,e)}getHiddenTokensToLeft(t,e=-1){if(this.lazyInit(),t<0||t>=this.tokens.length)throw new RangeError(t+" not in 0.."+(this.tokens.length-1));if(0===t)return[];let r=this.previousTokenOnChannel(t-1,a.Lexer.DEFAULT_TOKEN_CHANNEL);if(r===t-1)return[];let n=r+1,i=t-1;return this.filterForChannel(n,i,e)}filterForChannel(t,e,r){let n=new Array;for(let i=t;i<=e;i++){let t=this.tokens[i];-1===r?t.channel!==a.Lexer.DEFAULT_TOKEN_CHANNEL&&n.push(t):t.channel===r&&n.push(t)}return n}get sourceName(){return this.tokenSource.sourceName}getText(t){void 0===t?t=l.Interval.of(0,this.size-1):t instanceof l.Interval||(t=t.sourceInterval);let e=t.a,r=t.b;if(e<0||r<0)return"";this.fill(),r>=this.tokens.length&&(r=this.tokens.length-1);let n="";for(let t=e;t<=r;t++){let e=this.tokens[t];if(e.type===c.Token.EOF)break;n+=e.text}return n.toString()}getTextFromRange(t,e){return this.isToken(t)&&this.isToken(e)?this.getText(l.Interval.of(t.tokenIndex,e.tokenIndex)):""}fill(){this.lazyInit();for(;;){if(this.fetch(1e3)<1e3)return}}isWritableToken(t){return t instanceof s.CommonToken}isToken(t){return t instanceof s.CommonToken}};n([u.NotNull],h.prototype,"_tokenSource",void 0),n([u.Override],h.prototype,"tokenSource",null),n([u.Override],h.prototype,"index",null),n([u.Override],h.prototype,"mark",null),n([u.Override],h.prototype,"release",null),n([u.Override],h.prototype,"seek",null),n([u.Override],h.prototype,"size",null),n([u.Override],h.prototype,"consume",null),n([u.Override],h.prototype,"get",null),n([u.Override],h.prototype,"LA",null),n([u.NotNull,u.Override],h.prototype,"LT",null),n([u.Override],h.prototype,"sourceName",null),n([u.NotNull,u.Override],h.prototype,"getText",null),n([u.NotNull,u.Override],h.prototype,"getTextFromRange",null),h=n([i(0,u.NotNull)],h),e.BufferedTokenStream=h},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(0),o=r(16);class s extends o.ParserRuleContext{constructor(t,e,r){void 0!==r?super(e,r):super(),this._ruleIndex=t}get ruleIndex(){return this._ruleIndex}}n([i.Override],s.prototype,"ruleIndex",null),e.InterpreterRuleContext=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0}),e.RuleVersion=function(t){return function(t,e,r){}}},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(25),s=r(0);let l=class extends o.DecisionEventInfo{constructor(t,e,r,n,i,o){super(t,e,n,i,o,e.useContext),this.ambigAlts=r}get ambiguousAlternatives(){return this.ambigAlts}};n([s.NotNull],l.prototype,"ambigAlts",void 0),n([s.NotNull],l.prototype,"ambiguousAlternatives",null),l=n([i(1,s.NotNull),i(2,s.NotNull),i(3,s.NotNull)],l),e.AmbiguityInfo=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(25),s=r(0);let l=class extends o.DecisionEventInfo{constructor(t,e,r,n,i){super(t,e,r,n,i,!0)}};l=n([i(1,s.NotNull),i(2,s.NotNull)],l),e.ContextSensitivityInfo=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(0);class o{constructor(t){this.invocations=0,this.timeInPrediction=0,this.SLL_TotalLook=0,this.SLL_MinLook=0,this.SLL_MaxLook=0,this.LL_TotalLook=0,this.LL_MinLook=0,this.LL_MaxLook=0,this.contextSensitivities=[],this.errors=[],this.ambiguities=[],this.predicateEvals=[],this.SLL_ATNTransitions=0,this.SLL_DFATransitions=0,this.LL_Fallback=0,this.LL_ATNTransitions=0,this.LL_DFATransitions=0,this.decision=t}toString(){return"{decision="+this.decision+", contextSensitivities="+this.contextSensitivities.length+", errors="+this.errors.length+", ambiguities="+this.ambiguities.length+", SLL_lookahead="+this.SLL_TotalLook+", SLL_ATNTransitions="+this.SLL_ATNTransitions+", SLL_DFATransitions="+this.SLL_DFATransitions+", LL_Fallback="+this.LL_Fallback+", LL_lookahead="+this.LL_TotalLook+", LL_ATNTransitions="+this.LL_ATNTransitions+"}"}}n([i.Override],o.prototype,"toString",null),e.DecisionInfo=o},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(25),s=r(0);let l=class extends o.DecisionEventInfo{constructor(t,e,r,n,i){super(t,e,r,n,i,e.useContext)}};l=n([i(1,s.NotNull),i(2,s.NotNull)],l),e.ErrorInfo=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(25);let s=class extends o.DecisionEventInfo{constructor(t,e,r,n,i,o,s){super(t,e,n,i,o,s),this.predictedAlt=r}};s=n([i(3,r(0).NotNull)],s),e.LookaheadEventInfo=s},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(25),s=r(0);let l=class extends o.DecisionEventInfo{constructor(t,e,r,n,i,o,s,l){super(e,t,r,n,i,t.useContext),this.semctx=o,this.evalResult=s,this.predictedAlt=l}};l=n([i(0,s.NotNull),i(2,s.NotNull),i(5,s.NotNull)],l),e.PredicateEvalInfo=l},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.suggestTokens=e.ErrorListener=void 0;const n=r(65),i=r(128),o=r(129),s=r(130);class l{syntaxError(t,e,r,n,i,o){this.offeringSymbol=e}}e.ErrorListener=l,e.suggestTokens=function(t){let e=new n.ANTLRInputStream(t),r=new i.FlowFilterLexer(e),a=new n.CommonTokenStream(r),u=new o.FlowFilterParser(a);r.removeErrorListeners(),u.removeErrorListeners();let c=new s.CodeCompletionCore(u),h=new l;u.addErrorListener(h),u.parse();let p=c.collectCandidates(h.offeringSymbol&&h.offeringSymbol.type!=n.Token.EOF?a.size-2:a.size);function d(t){return t.filter(t=>t>0).map(t=>r.vocabulary.getDisplayName(t)).map(t=>t.replace(/^\'|\'$/g,"")).filter(t=>" "!==t)}return{tokens:d(a.getTokens().map(t=>t.type)),suggestions:d(Array.from(p.tokens.keys()).sort()),offeringSymbol:h.offeringSymbol?h.offeringSymbol.text:null}}},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(5),o=r(0),s=r(22);class l{constructor(t){this.p=0,this.data=t,this.n=t.length}reset(){this.p=0}consume(){if(this.p>=this.n)throw i(this.LA(1)===s.IntStream.EOF),new Error("cannot consume EOF");this.p<this.n&&this.p++}LA(t){return 0===t?0:t<0&&(t++,this.p+t-1<0)?s.IntStream.EOF:this.p+t-1>=this.n?s.IntStream.EOF:this.data.charCodeAt(this.p+t-1)}LT(t){return this.LA(t)}get index(){return this.p}get size(){return this.n}mark(){return-1}release(t){}seek(t){if(t<=this.p)this.p=t;else for(t=Math.min(t,this.n);this.p<t;)this.consume()}getText(t){let e=t.a,r=t.b;r>=this.n&&(r=this.n-1);let n=r-e+1;return e>=this.n?"":this.data.substr(e,n)}get sourceName(){return this.name?this.name:s.IntStream.UNKNOWN_SOURCE_NAME}toString(){return this.data}}n([o.Override],l.prototype,"consume",null),n([o.Override],l.prototype,"LA",null),n([o.Override],l.prototype,"index",null),n([o.Override],l.prototype,"size",null),n([o.Override],l.prototype,"mark",null),n([o.Override],l.prototype,"release",null),n([o.Override],l.prototype,"seek",null),n([o.Override],l.prototype,"getText",null),n([o.Override],l.prototype,"sourceName",null),n([o.Override],l.prototype,"toString",null),e.ANTLRInputStream=l},function(t,e){t.exports=function(t){return t&&"object"==typeof t&&"function"==typeof t.copy&&"function"==typeof t.fill&&"function"==typeof t.readUInt8}},function(t,e){"function"==typeof Object.create?t.exports=function(t,e){t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}})}:t.exports=function(t,e){t.super_=e;var r=function(){};r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t}},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(49),o=r(35),s=r(0),l=r(102);class a extends i.DefaultErrorStrategy{recover(t,e){for(let r=t.context;r;r=r.parent)r.exception=e;throw new l.ParseCancellationException(e)}recoverInline(t){let e=new o.InputMismatchException(t);for(let r=t.context;r;r=r.parent)r.exception=e;throw new l.ParseCancellationException(e)}sync(t){}}n([s.Override],a.prototype,"recover",null),n([s.Override],a.prototype,"recoverInline",null),n([s.Override],a.prototype,"sync",null),e.BailErrorStrategy=a},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(70),s=r(0),l=r(21);let a=class extends o.DFASerializer{constructor(t){super(t,l.VocabularyImpl.EMPTY_VOCABULARY)}getEdgeLabel(t){return"'"+String.fromCharCode(t)+"'"}};n([s.Override,s.NotNull],a.prototype,"getEdgeLabel",null),a=n([i(0,s.NotNull)],a),e.LexerDFASerializer=a},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(7),s=r(38),l=r(88),a=r(0),u=r(30),c=r(16),h=r(90),p=r(63),d=r(2),f=r(8);class g{static toStringTree(t,e){let r;r=e instanceof u.Parser?e.ruleNames:e;let n=f.escapeWhitespace(this.getNodeText(t,r),!1);if(0==t.childCount)return n;let i="";i+="(",i+=n=f.escapeWhitespace(this.getNodeText(t,r),!1),i+=" ";for(let e=0;e<t.childCount;e++)e>0&&(i+=" "),i+=this.toStringTree(t.getChild(e),r);return i+=")"}static getNodeText(t,e){let r;if(e instanceof u.Parser)r=e.ruleNames;else{if(!e){let e=t.payload;return"string"==typeof e.text?e.text:t.payload.toString()}r=e}if(t instanceof h.RuleNode){let e=t.ruleContext,n=r[e.ruleIndex],i=e.altNumber;return i!==o.ATN.INVALID_ALT_NUMBER?n+":"+i:n}if(t instanceof l.ErrorNode)return t.toString();if(t instanceof p.TerminalNode){return t.symbol.text||""}throw new TypeError("Unexpected node type")}static getChildren(t){let e=[];for(let r=0;r<t.childCount;r++)e.push(t.getChild(r));return e}static getAncestors(t){let e=[],r=t.parent;for(;r;)e.unshift(r),r=r.parent;return e}static isAncestorOf(t,e){if(!t||!e||!t.parent)return!1;let r=e.parent;for(;r;){if(t===r)return!0;r=r.parent}return!1}static findAllTokenNodes(t,e){return g.findAllNodes(t,e,!0)}static findAllRuleNodes(t,e){return g.findAllNodes(t,e,!1)}static findAllNodes(t,e,r){let n=[];return g._findAllNodes(t,e,r,n),n}static _findAllNodes(t,e,r,n){r&&t instanceof p.TerminalNode?t.symbol.type===e&&n.push(t):!r&&t instanceof c.ParserRuleContext&&t.ruleIndex===e&&n.push(t);for(let i=0;i<t.childCount;i++)g._findAllNodes(t.getChild(i),e,r,n)}static getDescendants(t){let e=[];return function t(r){e.push(r);const n=r.childCount;for(let e=0;e<n;e++)t(r.getChild(e))}(t),e}static getRootOfSubtreeEnclosingRegion(t,e,r){let n=t.childCount;for(let i=0;i<n;i++){let n=t.getChild(i),o=g.getRootOfSubtreeEnclosingRegion(n,e,r);if(o)return o}if(t instanceof c.ParserRuleContext){let n=t.stop;if(e>=t.start.tokenIndex&&(null==n||r<=n.tokenIndex))return t}}static stripChildrenOutOfRange(t,e,r,n){if(!t)return;let i=t.childCount;for(let o=0;o<i;o++){let i=t.getChild(o),l=i.sourceInterval;if(i instanceof c.ParserRuleContext&&(l.b<r||l.a>n)&&g.isAncestorOf(i,e)){let e=new s.CommonToken(d.Token.INVALID_TYPE,"...");t.children[o]=new p.TerminalNode(e)}}}}n([i(0,a.NotNull)],g,"toStringTree",null),n([a.NotNull,i(0,a.NotNull)],g,"getAncestors",null),n([i(0,a.NotNull)],g,"getRootOfSubtreeEnclosingRegion",null),e.Trees=g},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(103),s=r(0),l=r(2);let a=class extends o.BufferedTokenStream{constructor(t,e=l.Token.DEFAULT_CHANNEL){super(t),this.channel=e}adjustSeekIndex(t){return this.nextTokenOnChannel(t,this.channel)}tryLB(t){if(this.p-t<0)return;let e=this.p,r=1;for(;r<=t&&e>0;)e=this.previousTokenOnChannel(e-1,this.channel),r++;return e<0?void 0:this.tokens[e]}tryLT(t){if(this.lazyInit(),0===t)throw new RangeError("0 is not a valid lookahead index");if(t<0)return this.tryLB(-t);let e=this.p,r=1;for(;r<t;)this.sync(e+1)&&(e=this.nextTokenOnChannel(e+1,this.channel)),r++;return this.tokens[e]}getNumberOfOnChannelTokens(){let t=0;this.fill();for(let e=0;e<this.tokens.length;e++){let r=this.tokens[e];if(r.channel===this.channel&&t++,r.type===l.Token.EOF)break}return t}};n([s.Override],a.prototype,"adjustSeekIndex",null),n([s.Override],a.prototype,"tryLB",null),n([s.Override],a.prototype,"tryLT",null),a=n([i(0,s.NotNull)],a),e.CommonTokenStream=a},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0}),function(t){t[t.SELF=0]="SELF",t[t.PARENTS=1]="PARENTS",t[t.CHILDREN=2]="CHILDREN",t[t.ANCESTORS=3]="ANCESTORS",t[t.DESCENDANTS=4]="DESCENDANTS",t[t.SIBLINGS=5]="SIBLINGS",t[t.PRECEEDING_SIBLINGS=6]="PRECEEDING_SIBLINGS",t[t.FOLLOWING_SIBLINGS=7]="FOLLOWING_SIBLINGS",t[t.PRECEEDING=8]="PRECEEDING",t[t.FOLLOWING=9]="FOLLOWING"}(e.Dependents||(e.Dependents={}))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(12),s=r(0),l=r(3),a=r(13);class u{constructor(t=!0){this.exactOnly=t,this.exactOnly=t}reportAmbiguity(t,e,r,n,i,o,s){if(this.exactOnly&&!i)return;let a=`reportAmbiguity d=${this.getDecisionDescription(t,e)}: ambigAlts=${this.getConflictingAlts(o,s)}, input='${t.inputStream.getText(l.Interval.of(r,n))}'`;t.notifyErrorListeners(a)}reportAttemptingFullContext(t,e,r,n,i,o){let s=`reportAttemptingFullContext d=${this.getDecisionDescription(t,e)}, input='${t.inputStream.getText(l.Interval.of(r,n))}'`;t.notifyErrorListeners(s)}reportContextSensitivity(t,e,r,n,i,o){let s=`reportContextSensitivity d=${this.getDecisionDescription(t,e)}, input='${t.inputStream.getText(l.Interval.of(r,n))}'`;t.notifyErrorListeners(s)}getDecisionDescription(t,e){let r=e.decision,n=e.atnStartState.ruleIndex,i=t.ruleNames;if(n<0||n>=i.length)return r.toString();let o=i[n];return o?`${r} (${o})`:r.toString()}getConflictingAlts(t,e){if(null!=t)return t;let r=new o.BitSet;for(let t of a.asIterable(e))r.set(t.alt);return r}}n([s.Override,i(0,s.NotNull),i(1,s.NotNull),i(6,s.NotNull)],u.prototype,"reportAmbiguity",null),n([s.Override,i(0,s.NotNull),i(1,s.NotNull),i(5,s.NotNull)],u.prototype,"reportAttemptingFullContext",null),n([s.Override,i(0,s.NotNull),i(1,s.NotNull),i(5,s.NotNull)],u.prototype,"reportContextSensitivity",null),n([i(0,s.NotNull),i(1,s.NotNull)],u.prototype,"getDecisionDescription",null),n([s.NotNull,i(1,s.NotNull)],u.prototype,"getConflictingAlts",null),e.DiagnosticErrorListener=u},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(19),s=r(39),l=r(0),a=r(0);let u=class extends o.Lexer{constructor(t,e,r,n,i,o){if(super(o),0!=i.grammarType)throw new Error("IllegalArgumentException: The ATN must be a lexer ATN.");this._grammarFileName=t,this._atn=i,this._ruleNames=n.slice(0),this._modeNames=r.slice(0),this._vocabulary=e,this._interp=new s.LexerATNSimulator(i,this)}get atn(){return this._atn}get grammarFileName(){return this._grammarFileName}get ruleNames(){return this._ruleNames}get modeNames(){return this._modeNames}get vocabulary(){return this._vocabulary}};n([l.NotNull],u.prototype,"_vocabulary",void 0),n([a.Override],u.prototype,"atn",null),n([a.Override],u.prototype,"grammarFileName",null),n([a.Override],u.prototype,"ruleNames",null),n([a.Override],u.prototype,"modeNames",null),n([a.Override],u.prototype,"vocabulary",null),u=n([i(1,l.NotNull)],u),e.LexerInterpreter=u},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(52),s=r(0),l=r(2);let a=class{constructor(t,e){if(this.i=0,this._factory=o.CommonTokenFactory.DEFAULT,null==t)throw new Error("tokens cannot be null");this.tokens=t,this._sourceName=e}get charPositionInLine(){if(this.i<this.tokens.length)return this.tokens[this.i].charPositionInLine;if(null!=this.eofToken)return this.eofToken.charPositionInLine;if(this.tokens.length>0){let t=this.tokens[this.tokens.length-1],e=t.text;if(null!=e){let t=e.lastIndexOf("\n");if(t>=0)return e.length-t-1}return t.charPositionInLine+t.stopIndex-t.startIndex+1}return 0}nextToken(){if(this.i>=this.tokens.length){if(null==this.eofToken){let t=-1;if(this.tokens.length>0){let e=this.tokens[this.tokens.length-1].stopIndex;-1!==e&&(t=e+1)}let e=Math.max(-1,t-1);this.eofToken=this._factory.create({source:this,stream:this.inputStream},l.Token.EOF,"EOF",l.Token.DEFAULT_CHANNEL,t,e,this.line,this.charPositionInLine)}return this.eofToken}let t=this.tokens[this.i];return this.i===this.tokens.length-1&&t.type===l.Token.EOF&&(this.eofToken=t),this.i++,t}get line(){if(this.i<this.tokens.length)return this.tokens[this.i].line;if(null!=this.eofToken)return this.eofToken.line;if(this.tokens.length>0){let t=this.tokens[this.tokens.length-1],e=t.line,r=t.text;if(null!=r)for(let t=0;t<r.length;t++)"\n"==r.charAt(t)&&e++;return e}return 1}get inputStream(){return this.i<this.tokens.length?this.tokens[this.i].inputStream:null!=this.eofToken?this.eofToken.inputStream:this.tokens.length>0?this.tokens[this.tokens.length-1].inputStream:void 0}get sourceName(){if(this._sourceName)return this._sourceName;let t=this.inputStream;return null!=t?t.sourceName:"List"}set tokenFactory(t){this._factory=t}get tokenFactory(){return this._factory}};n([s.Override],a.prototype,"charPositionInLine",null),n([s.Override],a.prototype,"nextToken",null),n([s.Override],a.prototype,"line",null),n([s.Override],a.prototype,"inputStream",null),n([s.Override],a.prototype,"sourceName",null),n([s.Override,s.NotNull,i(0,s.NotNull)],a.prototype,"tokenFactory",null),a=n([i(0,s.NotNull)],a),e.ListTokenSource=a},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(11),s=r(12),l=r(33),a=r(35),u=r(104),c=r(62),h=r(0),p=r(0),d=r(30),f=r(32),g=r(17),y=r(42),_=r(2);let m=class t extends d.Parser{constructor(e,r,n,i,o){if(super(e instanceof t?e.inputStream:o),this._parentContextStack=[],this.overrideDecision=-1,this.overrideDecisionInputIndex=-1,this.overrideDecisionAlt=-1,this.overrideDecisionReached=!1,this._overrideDecisionRoot=void 0,e instanceof t){let t=e;this._grammarFileName=t._grammarFileName,this._atn=t._atn,this.pushRecursionContextStates=t.pushRecursionContextStates,this._ruleNames=t._ruleNames,this._vocabulary=t._vocabulary,this.interpreter=new f.ParserATNSimulator(this._atn,this)}else{r=r,n=n,i=i,this._grammarFileName=e,this._atn=i,this._ruleNames=n.slice(0),this._vocabulary=r,this.pushRecursionContextStates=new s.BitSet(i.states.length);for(let t of i.states)t instanceof y.StarLoopEntryState&&t.precedenceRuleDecision&&this.pushRecursionContextStates.set(t.stateNumber);this.interpreter=new f.ParserATNSimulator(i,this)}}reset(t){void 0===t?super.reset():super.reset(t),this.overrideDecisionReached=!1,this._overrideDecisionRoot=void 0}get atn(){return this._atn}get vocabulary(){return this._vocabulary}get ruleNames(){return this._ruleNames}get grammarFileName(){return this._grammarFileName}parse(t){let e=this._atn.ruleToStartState[t];for(this._rootContext=this.createInterpreterRuleContext(void 0,o.ATNState.INVALID_STATE_NUMBER,t),e.isPrecedenceRule?this.enterRecursionRule(this._rootContext,e.stateNumber,t,0):this.enterRule(this._rootContext,e.stateNumber,t);;){let t=this.atnState;switch(t.stateType){case 7:if(this._ctx.isEmpty){if(e.isPrecedenceRule){let t=this._ctx,e=this._parentContextStack.pop();return this.unrollRecursionContexts(e[0]),t}return this.exitRule(),this._rootContext}this.visitRuleStopState(t);break;default:try{this.visitState(t)}catch(e){if(!(e instanceof g.RecognitionException))throw e;this.state=this._atn.ruleToStopState[t.ruleIndex].stateNumber,this.context.exception=e,this.errorHandler.reportError(this,e),this.recover(e)}}}}enterRecursionRule(t,e,r,n){this._parentContextStack.push([this._ctx,t.invokingState]),super.enterRecursionRule(t,e,r,n)}get atnState(){return this._atn.states[this.state]}visitState(t){let e=1;t.numberOfTransitions>1&&(e=this.visitDecisionState(t));let r=t.transition(e-1);switch(r.serializationType){case 1:if(this.pushRecursionContextStates.get(t.stateNumber)&&!(r.target instanceof c.LoopEndState)){let e=this._parentContextStack[this._parentContextStack.length-1],r=this.createInterpreterRuleContext(e[0],e[1],this._ctx.ruleIndex);this.pushNewRecursionContext(r,this._atn.ruleToStartState[t.ruleIndex].stateNumber,this._ctx.ruleIndex)}break;case 5:this.match(r._label);break;case 2:case 7:case 8:r.matches(this._input.LA(1),_.Token.MIN_USER_TOKEN_TYPE,65535)||this.recoverInline(),this.matchWildcard();break;case 9:this.matchWildcard();break;case 3:let e=r.target,n=e.ruleIndex,i=this.createInterpreterRuleContext(this._ctx,t.stateNumber,n);e.isPrecedenceRule?this.enterRecursionRule(i,e.stateNumber,n,r.precedence):this.enterRule(i,r.target.stateNumber,n);break;case 4:let o=r;if(!this.sempred(this._ctx,o.ruleIndex,o.predIndex))throw new l.FailedPredicateException(this);break;case 6:let s=r;this.action(this._ctx,s.ruleIndex,s.actionIndex);break;case 10:if(!this.precpred(this._ctx,r.precedence)){let t=r.precedence;throw new l.FailedPredicateException(this,`precpred(_ctx, ${t})`)}break;default:throw new Error("UnsupportedOperationException: Unrecognized ATN transition type.")}this.state=r.target.stateNumber}visitDecisionState(t){let e;this.errorHandler.sync(this);let r=t.decision;return r!==this.overrideDecision||this._input.index!==this.overrideDecisionInputIndex||this.overrideDecisionReached?e=this.interpreter.adaptivePredict(this._input,r,this._ctx):(e=this.overrideDecisionAlt,this.overrideDecisionReached=!0),e}createInterpreterRuleContext(t,e,r){return new u.InterpreterRuleContext(r,t,e)}visitRuleStopState(t){if(this._atn.ruleToStartState[t.ruleIndex].isPrecedenceRule){let t=this._parentContextStack.pop();this.unrollRecursionContexts(t[0]),this.state=t[1]}else this.exitRule();let e=this._atn.states[this.state].transition(0);this.state=e.followState.stateNumber}addDecisionOverride(t,e,r){this.overrideDecision=t,this.overrideDecisionInputIndex=e,this.overrideDecisionAlt=r}get overrideDecisionRoot(){return this._overrideDecisionRoot}recover(t){let e=this._input.index;if(this.errorHandler.recover(this,t),this._input.index===e){let e=t.getOffendingToken();if(!e)throw new Error("Expected exception to have an offending token");let r=e.tokenSource,n={source:r,stream:void 0!==r?r.inputStream:void 0};if(t instanceof a.InputMismatchException){let r=t.expectedTokens;if(void 0===r)throw new Error("Expected the exception to provide expected tokens");let i=r.minElement,o=this.tokenFactory.create(n,i,e.text,_.Token.DEFAULT_CHANNEL,-1,-1,e.line,e.charPositionInLine);this._ctx.addErrorNode(o)}else{e.tokenSource;let t=this.tokenFactory.create(n,_.Token.INVALID_TYPE,e.text,_.Token.DEFAULT_CHANNEL,-1,-1,e.line,e.charPositionInLine);this._ctx.addErrorNode(t)}}}recoverInline(){return this._errHandler.recoverInline(this)}get rootContext(){return this._rootContext}};n([h.NotNull],m.prototype,"_vocabulary",void 0),n([p.Override],m.prototype,"reset",null),n([p.Override],m.prototype,"atn",null),n([p.Override],m.prototype,"vocabulary",null),n([p.Override],m.prototype,"ruleNames",null),n([p.Override],m.prototype,"grammarFileName",null),n([p.Override],m.prototype,"enterRecursionRule",null),m=n([i(1,h.NotNull)],m),e.ParserInterpreter=m},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(7),o=r(0),s=r(16);class l extends s.ParserRuleContext{constructor(t,e){void 0!==e?super(t,e):super(),this._altNumber=i.ATN.INVALID_ALT_NUMBER}get altNumber(){return this._altNumber}set altNumber(t){this._altNumber=t}}n([o.Override],l.prototype,"altNumber",null),e.RuleContextWithAltNum=l},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0}),e.RuleDependency=function(t){return function(t,e,r){}}},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0});const i=r(3),o=r(0),s=r(2);class l{constructor(t){this.tokens=t,this.programs=new Map,this.programs.set(l.DEFAULT_PROGRAM_NAME,[]),this.lastRewriteTokenIndexes=new Map}getTokenStream(){return this.tokens}rollback(t,e=l.DEFAULT_PROGRAM_NAME){let r=this.programs.get(e);null!=r&&this.programs.set(e,r.slice(l.MIN_TOKEN_INDEX,t))}deleteProgram(t=l.DEFAULT_PROGRAM_NAME){this.rollback(l.MIN_TOKEN_INDEX,t)}insertAfter(t,e,r=l.DEFAULT_PROGRAM_NAME){let n;n="number"==typeof t?t:t.tokenIndex;let i=new c(this.tokens,n,e),o=this.getProgram(r);i.instructionIndex=o.length,o.push(i)}insertBefore(t,e,r=l.DEFAULT_PROGRAM_NAME){let n;n="number"==typeof t?t:t.tokenIndex;let i=new u(this.tokens,n,e),o=this.getProgram(r);i.instructionIndex=o.length,o.push(i)}replaceSingle(t,e){this.replace(t,t,e)}replace(t,e,r,n=l.DEFAULT_PROGRAM_NAME){if("number"!=typeof t&&(t=t.tokenIndex),"number"!=typeof e&&(e=e.tokenIndex),t>e||t<0||e<0||e>=this.tokens.size)throw new RangeError(`replace: range invalid: ${t}..${e}(size=${this.tokens.size})`);let i=new h(this.tokens,t,e,r),o=this.getProgram(n);i.instructionIndex=o.length,o.push(i)}delete(t,e,r=l.DEFAULT_PROGRAM_NAME){void 0===e&&(e=t),this.replace(t,e,void 0,r)}getLastRewriteTokenIndex(t=l.DEFAULT_PROGRAM_NAME){let e=this.lastRewriteTokenIndexes.get(t);return null==e?-1:e}setLastRewriteTokenIndex(t,e){this.lastRewriteTokenIndexes.set(t,e)}getProgram(t){let e=this.programs.get(t);return null==e&&(e=this.initializeProgram(t)),e}initializeProgram(t){let e=[];return this.programs.set(t,e),e}getText(t,e=l.DEFAULT_PROGRAM_NAME){let r;r=t instanceof i.Interval?t:i.Interval.of(0,this.tokens.size-1),"string"==typeof t&&(e=t);let n=this.programs.get(e),o=r.a,a=r.b;if(a>this.tokens.size-1&&(a=this.tokens.size-1),o<0&&(o=0),null==n||0===n.length)return this.tokens.getText(r);let u=[],c=this.reduceToSingleOperationPerIndex(n),h=o;for(;h<=a&&h<this.tokens.size;){let t=c.get(h);c.delete(h);let e=this.tokens.get(h);null==t?(e.type!==s.Token.EOF&&u.push(String(e.text)),h++):h=t.execute(u)}if(a===this.tokens.size-1)for(let t of c.values())t.index>=this.tokens.size-1&&(u+=t.text);return u.join("")}reduceToSingleOperationPerIndex(t){for(let e=0;e<t.length;e++){let r=t[e];if(null==r)continue;if(!(r instanceof h))continue;let n=r,i=this.getKindOfOps(t,u,e);for(let e of i)e.index==n.index?(t[e.instructionIndex]=void 0,n.text=e.text.toString()+(null!=n.text?n.text.toString():"")):e.index>n.index&&e.index<=n.lastIndex&&(t[e.instructionIndex]=void 0);let o=this.getKindOfOps(t,h,e);for(let e of o){if(e.index>=n.index&&e.lastIndex<=n.lastIndex){t[e.instructionIndex]=void 0;continue}let r=e.lastIndex<n.index||e.index>n.lastIndex;if(null!=e.text||null!=n.text||r){if(!r)throw new Error(`replace op boundaries of ${n} overlap with previous ${e}`)}else t[e.instructionIndex]=void 0,n.index=Math.min(e.index,n.index),n.lastIndex=Math.max(e.lastIndex,n.lastIndex)}}for(let e=0;e<t.length;e++){let r=t[e];if(null==r)continue;if(!(r instanceof u))continue;let n=r,i=this.getKindOfOps(t,u,e);for(let e of i)e.index===n.index&&(e instanceof c?(n.text=this.catOpText(e.text,n.text),t[e.instructionIndex]=void 0):e instanceof u&&(n.text=this.catOpText(n.text,e.text),t[e.instructionIndex]=void 0));let o=this.getKindOfOps(t,h,e);for(let r of o)if(n.index!=r.index){if(n.index>=r.index&&n.index<=r.lastIndex)throw new Error(`insert op ${n} within boundaries of previous ${r}`)}else r.text=this.catOpText(n.text,r.text),t[e]=void 0}let e=new Map;for(let r=0;r<t.length;r++){let n=t[r];if(null!=n){if(null!=e.get(n.index))throw new Error("should only be one op per index");e.set(n.index,n)}}return e}catOpText(t,e){let r="",n="";return null!=t&&(r=t.toString()),null!=e&&(n=e.toString()),r+n}getKindOfOps(t,e,r){let n=[];for(let i=0;i<r&&i<t.length;i++){let r=t[i];null!=r&&(r instanceof e&&n.push(r))}return n}}l.DEFAULT_PROGRAM_NAME="default",l.PROGRAM_INIT_SIZE=100,l.MIN_TOKEN_INDEX=0,e.TokenStreamRewriter=l;class a{constructor(t,e,r){this.tokens=t,this.index=e,this.text=r}execute(t){return this.index}toString(){let t=this.constructor.name,e=t.indexOf("$");return"<"+(t=t.substring(e+1,t.length))+"@"+this.tokens.get(this.index)+':"'+this.text+'">'}}n([o.Override],a.prototype,"toString",null),e.RewriteOperation=a;class u extends a{constructor(t,e,r){super(t,e,r)}execute(t){return t.push(this.text),this.tokens.get(this.index).type!==s.Token.EOF&&t.push(String(this.tokens.get(this.index).text)),this.index+1}}n([o.Override],u.prototype,"execute",null);class c extends u{constructor(t,e,r){super(t,e+1,r)}}class h extends a{constructor(t,e,r,n){super(t,e,n),this.lastIndex=r}execute(t){return null!=this.text&&t.push(this.text),this.lastIndex+1}toString(){return null==this.text?"<DeleteOp@"+this.tokens.get(this.index)+".."+this.tokens.get(this.lastIndex)+">":"<ReplaceOp@"+this.tokens.get(this.index)+".."+this.tokens.get(this.lastIndex)+':"'+this.text+'">'}}n([o.Override],h.prototype,"execute",null),n([o.Override],h.prototype,"toString",null)},function(t,e,r){"use strict";var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0}),e.FlowFilterLexer=void 0;const i=r(47),o=r(19),s=r(39),l=r(0),a=r(0),u=r(21),c=r(8);class h extends o.Lexer{constructor(t){super(t),this._interp=new s.LexerATNSimulator(h._ATN,this)}get vocabulary(){return h.VOCABULARY}get grammarFileName(){return"FlowFilter.g4"}get ruleNames(){return h.ruleNames}get serializedATN(){return h._serializedATN}get modeNames(){return h.modeNames}static get _ATN(){return h.__ATN||(h.__ATN=(new i.ATNDeserializer).deserialize(c.toCharArray(h._serializedATN))),h.__ATN}}h.T__0=1,h.LPAREN=2,h.RPAREN=3,h.AND=4,h.OR=5,h.NOT=6,h.PAST_HOUR=7,h.PAST_DAY=8,h.PAST_WEEK=9,h.PAST_MONTH=10,h.PAST_YEAR=11,h.DATETIME=12,h.DATE=13,h.TIME=14,h.VALUE=15,h.NAME=16,h.TAG=17,h.TYPE=18,h.DATASET_TYPE=19,h.RECIPE_TYPE=20,h.USER=21,h.CREATED=22,h.CREATED_ON=23,h.CREATED_BETWEEN=24,h.CREATED_FROM=25,h.CREATED_TO=26,h.DOWNSTREAM_FROM=27,h.MODIFIED=28,h.MODIFIED_ON=29,h.MODIFIED_BETWEEN=30,h.MODIFIED_FROM=31,h.MODIFIED_TO=32,h.WS=33,h.SPACE=34,h.ESCAPED_TEXT=35,h.modeNames=["DEFAULT_MODE"],h.ruleNames=["T__0","LPAREN","RPAREN","AND","OR","NOT","PAST_HOUR","PAST_DAY","PAST_WEEK","PAST_MONTH","PAST_YEAR","DATETIME","DATE","TIME","VALUE","NAME","TAG","TYPE","DATASET_TYPE","RECIPE_TYPE","USER","CREATED","CREATED_ON","CREATED_BETWEEN","CREATED_FROM","CREATED_TO","DOWNSTREAM_FROM","MODIFIED","MODIFIED_ON","MODIFIED_BETWEEN","MODIFIED_FROM","MODIFIED_TO","WS","SPACE","ESCAPED_TEXT"],h._LITERAL_NAMES=[void 0,"'/'","'('","')'","'AND'","'OR'","'NOT'","'PAST_HOUR'","'PAST_DAY'","'PAST_WEEK'","'PAST_MONTH'","'PAST_YEAR'",void 0,void 0,void 0,void 0,"'name:'","'tag:'","'type:'","'datasetType:'","'recipeType:'","'user:'","'created:'","'createdOn:'","'createdBetween:'","'createdFrom:'","'createdTo:'","'downstreamFrom:'","'modified:'","'modifiedOn:'","'modifiedBetween:'","'modifiedFrom:'","'modifiedTo:'",void 0,"' '"],h._SYMBOLIC_NAMES=[void 0,void 0,"LPAREN","RPAREN","AND","OR","NOT","PAST_HOUR","PAST_DAY","PAST_WEEK","PAST_MONTH","PAST_YEAR","DATETIME","DATE","TIME","VALUE","NAME","TAG","TYPE","DATASET_TYPE","RECIPE_TYPE","USER","CREATED","CREATED_ON","CREATED_BETWEEN","CREATED_FROM","CREATED_TO","DOWNSTREAM_FROM","MODIFIED","MODIFIED_ON","MODIFIED_BETWEEN","MODIFIED_FROM","MODIFIED_TO","WS","SPACE","ESCAPED_TEXT"],h.VOCABULARY=new u.VocabularyImpl(h._LITERAL_NAMES,h._SYMBOLIC_NAMES,[]),h._serializedATN='꽯茠䞝띜䢀ᘅᤜꬷ%Ŵ\b\t\t\t\t\t\t\b\t\b\t\t\t\n\t\n\v\t\v\f\t\f\r\t\r\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t !\t!"\t"#\t#$\t$\b\b\b\b\b\b\b\b\b\b\t\t\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n\v\v\v\v\v\v\v\v\v\v\v\f\f\f\f\f\f\f\f\f\f\r\r\r\r£\n\r¤              !!!!!!!!!!!!""""##$$$$$Ů\n$\f$$ű\v$$$%\t\v\r\b\t\n\v\f\r!#%\')+-/13579;= ?!A"C#E$G%2;\b\v\f""$$*+<<\v\f""$$Ŷ\t\v\r!#%\')+-/13579;=?ACEGIKM\tO\vS\rVZdmw¢!¦#¬%±\'·)Ä+Ð-Ö/ß1ê3ú5ć7Ē9Ģ;Ĭ=ĸ?ŉAŗCţEŧGũIJ1JKL*LMN+N\bOPCPQPQRFR\nSTQTUTU\fVWPWXQXYVYZ[R[\\C\\]U]^V^_a_`J`aQabWbcTcdeRefCfgUghVhiaijFjkCkl[lmnRnoCopUpqVqrarsYstGtuGuvMvwxRxyCyzUz{V{|a|}O}~Q~PVJRCUVa[GCT"\t\t\t\t/\t\t/\t\t\t\t<\t \t ¡£\n¢¡£¤¤¢¤¥¥ ¦§p§¨c¨©o©ªgª«<«"¬­v­®c®¯i¯°<°$±²v²³{³´r´µgµ¶<¶&·¸f¸¹c¹ºvº»c»¼u¼½g½¾v¾¿V¿À{ÀÁrÁÂgÂÃ<Ã(ÄÅtÅÆgÆÇeÇÈkÈÉrÉÊgÊËVËÌ{ÌÍrÍÎgÎÏ<Ï*ÐÑwÑÒuÒÓgÓÔtÔÕ<Õ,Ö×e×ØtØÙgÙÚcÚÛvÛÜgÜÝfÝÞ<Þ.ßàeàátáâgâãcãäväågåæfæçQçèpèé<é0êëeëìtìígíîcîïvïðgðñfñòDòógóôvôõyõögö÷g÷øpøù<ù2úûeûütüýgýþcþÿvÿĀgĀāfāĂHĂătăĄqĄąoąĆ<Ć4ćĈeĈĉtĉĊgĊċcċČvČčgčĎfĎďVďĐqĐđ<đ6ĒēfēĔqĔĕyĕĖpĖėuėĘvĘętęĚgĚěcěĜoĜĝHĝĞtĞğqğĠoĠġ<ġ8ĢģoģĤqĤĥfĥĦkĦħhħĨkĨĩgĩĪfĪī<ī:ĬĭoĭĮqĮįfįİkİıhıĲkĲĳgĳĴfĴĵQĵĶpĶķ<ķ<ĸĹoĹĺqĺĻfĻļkļĽhĽľkľĿgĿŀfŀŁDŁłgłŃvŃńyńŅgŅņgņŇpŇň<ň>ŉŊoŊŋqŋŌfŌōkōŎhŎŏkŏŐgŐőfőŒHŒœtœŔqŔŕoŕŖ<Ŗ@ŗŘoŘřqřŚfŚśkśŜhŜŝkŝŞgŞşfşŠVŠšqšŢ<ŢBţŤ\tŤťťŦ\b"ŦDŧŨ"ŨFũů$Ūū^ūŮ$ŬŮ\nŭŪŭŬŮűůŭůŰŰŲűůŲų$ųH¤ŭů\b',n([a.Override,l.NotNull],h.prototype,"vocabulary",null),n([a.Override],h.prototype,"grammarFileName",null),n([a.Override],h.prototype,"ruleNames",null),n([a.Override],h.prototype,"serializedATN",null),n([a.Override],h.prototype,"modeNames",null),e.FlowFilterLexer=h},function(t,e,r){"use strict";var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s};Object.defineProperty(e,"__esModule",{value:!0}),e.FloatingTimeRangeContext=e.ModificationDateTimeRangeContext=e.DateTimeRangeContext=e.DateTimeContext=e.DateContext=e.SelectorModificationDateValueContext=e.SelectorDateValueContext=e.SelectorTextValueContext=e.StringValueContext=e.EscapedTextValueContext=e.SpaceOperatorContext=e.AndOperatorContext=e.OrOperatorContext=e.OperatorContext=e.SelectorWithModificationDateExpressionContext=e.SelectorWithTextExpressionContext=e.ParenExpressionContext=e.NotExpressionContext=e.SelectorWithModificationDateRangeExpressionContext=e.SelectorWithDateRangeExpressionContext=e.SelectorWithFloatingDateExpressionContext=e.SelectorWithFloatingModificationDateExpressionContext=e.SelectorWithDateExpressionContext=e.BinaryExpressionContext=e.ExpressionContext=e.ParseContext=e.FlowFilterParser=void 0;const i=r(7),o=r(47),s=r(33),l=r(0),a=r(46),u=r(0),c=r(30),h=r(16),p=r(32),d=r(17),f=r(105),g=r(2),y=r(21),_=r(8);class m extends c.Parser{constructor(t){super(t),this._interp=new p.ParserATNSimulator(m._ATN,this)}get vocabulary(){return m.VOCABULARY}get grammarFileName(){return"FlowFilter.g4"}get ruleNames(){return m.ruleNames}get serializedATN(){return m._serializedATN}parse(){let t,e=new T(this._ctx,this.state);this.enterRule(e,0,m.RULE_parse);try{this.enterOuterAlt(e,1),this.state=27,this._errHandler.sync(this),0==((t=this._input.LA(1))-2&-32)&&0!=(1<<t-2&(1<<m.LPAREN-2|1<<m.NOT-2|1<<m.NAME-2|1<<m.TAG-2|1<<m.TYPE-2|1<<m.DATASET_TYPE-2|1<<m.RECIPE_TYPE-2|1<<m.USER-2|1<<m.CREATED-2|1<<m.CREATED_ON-2|1<<m.CREATED_BETWEEN-2|1<<m.CREATED_FROM-2|1<<m.CREATED_TO-2|1<<m.DOWNSTREAM_FROM-2|1<<m.MODIFIED-2|1<<m.MODIFIED_ON-2|1<<m.MODIFIED_BETWEEN-2|1<<m.MODIFIED_FROM-2|1<<m.MODIFIED_TO-2))&&(this.state=26,this.expression(0)),this.state=29,this.match(m.EOF)}catch(t){if(!(t instanceof d.RecognitionException))throw t;e.exception=t,this._errHandler.reportError(this,t),this._errHandler.recover(this,t)}finally{this.exitRule()}return e}expression(t){void 0===t&&(t=0);let e,r=this._ctx,n=this.state,o=new S(this._ctx,n),l=o;this.enterRecursionRule(o,2,m.RULE_expression,t);try{let t;switch(this.enterOuterAlt(o,1),this.state=52,this._errHandler.sync(this),this._input.LA(1)){case m.LPAREN:o=new C(o),this._ctx=o,l=o,this.state=32,this.match(m.LPAREN),this.state=33,this.expression(0),this.state=34,this.match(m.RPAREN);break;case m.NOT:o=new A(o),this._ctx=o,l=o,this.state=36,this.match(m.NOT),this.state=37,o._expr=this.expression(9);break;case m.NAME:case m.TAG:case m.TYPE:case m.DATASET_TYPE:case m.RECIPE_TYPE:case m.USER:case m.DOWNSTREAM_FROM:o=new R(o),this._ctx=o,l=o,this.state=38,o._key=this._input.LT(1),0!=(-32&(e=this._input.LA(1)))||0==(1<<e&(1<<m.NAME|1<<m.TAG|1<<m.TYPE|1<<m.DATASET_TYPE|1<<m.RECIPE_TYPE|1<<m.USER|1<<m.DOWNSTREAM_FROM))?o._key=this._errHandler.recoverInline(this):(this._input.LA(1)===g.Token.EOF&&(this.matchedEOF=!0),this._errHandler.reportMatch(this),this.consume()),this.state=39,o._value=this.selectorTextValue();break;case m.CREATED_ON:case m.CREATED_FROM:case m.CREATED_TO:o=new E(o),this._ctx=o,l=o,this.state=40,o._key=this._input.LT(1),0!=(-32&(e=this._input.LA(1)))||0==(1<<e&(1<<m.CREATED_ON|1<<m.CREATED_FROM|1<<m.CREATED_TO))?o._key=this._errHandler.recoverInline(this):(this._input.LA(1)===g.Token.EOF&&(this.matchedEOF=!0),this._errHandler.reportMatch(this),this.consume()),this.state=41,o._value=this.selectorDateValue();break;case m.CREATED_BETWEEN:o=new v(o),this._ctx=o,l=o,this.state=42,o._key=this.match(m.CREATED_BETWEEN),this.state=43,o._value=this.dateTimeRange();break;case m.CREATED:o=new O(o),this._ctx=o,l=o,this.state=44,o._key=this.match(m.CREATED),this.state=45,o._value=this.floatingTimeRange();break;case m.MODIFIED_ON:case m.MODIFIED_FROM:case m.MODIFIED_TO:o=new I(o),this._ctx=o,l=o,this.state=46,o._key=this._input.LT(1),0!=((e=this._input.LA(1))-29&-32)||0==(1<<e-29&(1<<m.MODIFIED_ON-29|1<<m.MODIFIED_FROM-29|1<<m.MODIFIED_TO-29))?o._key=this._errHandler.recoverInline(this):(this._input.LA(1)===g.Token.EOF&&(this.matchedEOF=!0),this._errHandler.reportMatch(this),this.consume()),this.state=47,o._value=this.selectorModificationDateValue();break;case m.MODIFIED_BETWEEN:o=new b(o),this._ctx=o,l=o,this.state=48,o._key=this.match(m.MODIFIED_BETWEEN),this.state=49,o._value=this.modificationDateTimeRange();break;case m.MODIFIED:o=new N(o),this._ctx=o,l=o,this.state=50,o._key=this.match(m.MODIFIED),this.state=51,o._value=this.floatingTimeRange();break;default:throw new a.NoViableAltException(this)}for(this._ctx._stop=this._input.tryLT(-1),this.state=60,this._errHandler.sync(this),t=this.interpreter.adaptivePredict(this._input,2,this._ctx);2!==t&&t!==i.ATN.INVALID_ALT_NUMBER;){if(1===t){if(null!=this._parseListeners&&this.triggerExitRuleEvent(),l=o,(o=new x(new S(r,n)))._left=l,this.pushNewRecursionContext(o,2,m.RULE_expression),this.state=54,!this.precpred(this._ctx,8))throw new s.FailedPredicateException(this,"this.precpred(this._ctx, 8)");this.state=55,o._op=this.operator(),this.state=56,o._right=this.expression(9)}this.state=62,this._errHandler.sync(this),t=this.interpreter.adaptivePredict(this._input,2,this._ctx)}}catch(t){if(!(t instanceof d.RecognitionException))throw t;o.exception=t,this._errHandler.reportError(this,t),this._errHandler.recover(this,t)}finally{this.unrollRecursionContexts(r)}return o}operator(){let t,e=new P(this._ctx,this.state);this.enterRule(e,4,m.RULE_operator);try{switch(this.state=71,this._errHandler.sync(this),this._input.LA(1)){case m.AND:e=new k(e),this.enterOuterAlt(e,1),this.state=63,this.match(m.AND);break;case m.OR:e=new D(e),this.enterOuterAlt(e,2),this.state=64,this.match(m.OR);break;case m.LPAREN:case m.NOT:case m.NAME:case m.TAG:case m.TYPE:case m.DATASET_TYPE:case m.RECIPE_TYPE:case m.USER:case m.CREATED:case m.CREATED_ON:case m.CREATED_BETWEEN:case m.CREATED_FROM:case m.CREATED_TO:case m.DOWNSTREAM_FROM:case m.MODIFIED:case m.MODIFIED_ON:case m.MODIFIED_BETWEEN:case m.MODIFIED_FROM:case m.MODIFIED_TO:case m.SPACE:for(e=new L(e),this.enterOuterAlt(e,3),this.state=68,this._errHandler.sync(this),t=this._input.LA(1);t===m.SPACE;)this.state=65,this.match(m.SPACE),this.state=70,this._errHandler.sync(this),t=this._input.LA(1);break;default:throw new a.NoViableAltException(this)}}catch(t){if(!(t instanceof d.RecognitionException))throw t;e.exception=t,this._errHandler.reportError(this,t),this._errHandler.recover(this,t)}finally{this.exitRule()}return e}escapedTextValue(){let t=new w(this._ctx,this.state);this.enterRule(t,6,m.RULE_escapedTextValue);try{this.enterOuterAlt(t,1),this.state=73,this.match(m.ESCAPED_TEXT)}catch(e){if(!(e instanceof d.RecognitionException))throw e;t.exception=e,this._errHandler.reportError(this,e),this._errHandler.recover(this,e)}finally{this.exitRule()}return t}stringValue(){let t=new M(this._ctx,this.state);this.enterRule(t,8,m.RULE_stringValue);try{this.enterOuterAlt(t,1),this.state=75,this.match(m.VALUE)}catch(e){if(!(e instanceof d.RecognitionException))throw e;t.exception=e,this._errHandler.reportError(this,e),this._errHandler.recover(this,e)}finally{this.exitRule()}return t}selectorTextValue(){let t=new F(this._ctx,this.state);this.enterRule(t,10,m.RULE_selectorTextValue);try{switch(this.state=79,this._errHandler.sync(this),this._input.LA(1)){case m.VALUE:this.enterOuterAlt(t,1),this.state=77,this.stringValue();break;case m.ESCAPED_TEXT:this.enterOuterAlt(t,2),this.state=78,this.escapedTextValue();break;default:throw new a.NoViableAltException(this)}}catch(e){if(!(e instanceof d.RecognitionException))throw e;t.exception=e,this._errHandler.reportError(this,e),this._errHandler.recover(this,e)}finally{this.exitRule()}return t}selectorDateValue(){let t=new j(this._ctx,this.state);this.enterRule(t,12,m.RULE_selectorDateValue);try{switch(this.state=83,this._errHandler.sync(this),this._input.LA(1)){case m.DATE:this.enterOuterAlt(t,1),this.state=81,this.date();break;case m.DATETIME:this.enterOuterAlt(t,2),this.state=82,this.dateTime();break;default:throw new a.NoViableAltException(this)}}catch(e){if(!(e instanceof d.RecognitionException))throw e;t.exception=e,this._errHandler.reportError(this,e),this._errHandler.recover(this,e)}finally{this.exitRule()}return t}selectorModificationDateValue(){let t=new z(this._ctx,this.state);this.enterRule(t,14,m.RULE_selectorModificationDateValue);try{switch(this.state=87,this._errHandler.sync(this),this._input.LA(1)){case m.DATE:this.enterOuterAlt(t,1),this.state=85,this.date();break;case m.DATETIME:this.enterOuterAlt(t,2),this.state=86,this.dateTime();break;default:throw new a.NoViableAltException(this)}}catch(e){if(!(e instanceof d.RecognitionException))throw e;t.exception=e,this._errHandler.reportError(this,e),this._errHandler.recover(this,e)}finally{this.exitRule()}return t}date(){let t=new U(this._ctx,this.state);this.enterRule(t,16,m.RULE_date);try{this.enterOuterAlt(t,1),this.state=89,this.match(m.DATE)}catch(e){if(!(e instanceof d.RecognitionException))throw e;t.exception=e,this._errHandler.reportError(this,e),this._errHandler.recover(this,e)}finally{this.exitRule()}return t}dateTime(){let t=new H(this._ctx,this.state);this.enterRule(t,18,m.RULE_dateTime);try{this.enterOuterAlt(t,1),this.state=91,this.match(m.DATETIME)}catch(e){if(!(e instanceof d.RecognitionException))throw e;t.exception=e,this._errHandler.reportError(this,e),this._errHandler.recover(this,e)}finally{this.exitRule()}return t}dateTimeRange(){let t=new B(this._ctx,this.state);this.enterRule(t,20,m.RULE_dateTimeRange);try{this.enterOuterAlt(t,1),this.state=93,t._from=this.dateTime(),this.state=94,this.match(m.T__0),this.state=95,t._to=this.dateTime()}catch(e){if(!(e instanceof d.RecognitionException))throw e;t.exception=e,this._errHandler.reportError(this,e),this._errHandler.recover(this,e)}finally{this.exitRule()}return t}modificationDateTimeRange(){let t=new V(this._ctx,this.state);this.enterRule(t,22,m.RULE_modificationDateTimeRange);try{this.enterOuterAlt(t,1),this.state=97,t._from=this.dateTime(),this.state=98,this.match(m.T__0),this.state=99,t._to=this.dateTime()}catch(e){if(!(e instanceof d.RecognitionException))throw e;t.exception=e,this._errHandler.reportError(this,e),this._errHandler.recover(this,e)}finally{this.exitRule()}return t}floatingTimeRange(){let t,e=new q(this._ctx,this.state);this.enterRule(e,24,m.RULE_floatingTimeRange);try{this.enterOuterAlt(e,1),this.state=101,0!=(-32&(t=this._input.LA(1)))||0==(1<<t&(1<<m.PAST_HOUR|1<<m.PAST_DAY|1<<m.PAST_WEEK|1<<m.PAST_MONTH|1<<m.PAST_YEAR))?this._errHandler.recoverInline(this):(this._input.LA(1)===g.Token.EOF&&(this.matchedEOF=!0),this._errHandler.reportMatch(this),this.consume())}catch(t){if(!(t instanceof d.RecognitionException))throw t;e.exception=t,this._errHandler.reportError(this,t),this._errHandler.recover(this,t)}finally{this.exitRule()}return e}sempred(t,e,r){switch(e){case 1:return this.expression_sempred(t,r)}return!0}expression_sempred(t,e){switch(e){case 0:return this.precpred(this._ctx,8)}return!0}static get _ATN(){return m.__ATN||(m.__ATN=(new o.ATNDeserializer).deserialize(_.toCharArray(m._serializedATN))),m.__ATN}}m.T__0=1,m.LPAREN=2,m.RPAREN=3,m.AND=4,m.OR=5,m.NOT=6,m.PAST_HOUR=7,m.PAST_DAY=8,m.PAST_WEEK=9,m.PAST_MONTH=10,m.PAST_YEAR=11,m.DATETIME=12,m.DATE=13,m.TIME=14,m.VALUE=15,m.NAME=16,m.TAG=17,m.TYPE=18,m.DATASET_TYPE=19,m.RECIPE_TYPE=20,m.USER=21,m.CREATED=22,m.CREATED_ON=23,m.CREATED_BETWEEN=24,m.CREATED_FROM=25,m.CREATED_TO=26,m.DOWNSTREAM_FROM=27,m.MODIFIED=28,m.MODIFIED_ON=29,m.MODIFIED_BETWEEN=30,m.MODIFIED_FROM=31,m.MODIFIED_TO=32,m.WS=33,m.SPACE=34,m.ESCAPED_TEXT=35,m.RULE_parse=0,m.RULE_expression=1,m.RULE_operator=2,m.RULE_escapedTextValue=3,m.RULE_stringValue=4,m.RULE_selectorTextValue=5,m.RULE_selectorDateValue=6,m.RULE_selectorModificationDateValue=7,m.RULE_date=8,m.RULE_dateTime=9,m.RULE_dateTimeRange=10,m.RULE_modificationDateTimeRange=11,m.RULE_floatingTimeRange=12,m.ruleNames=["parse","expression","operator","escapedTextValue","stringValue","selectorTextValue","selectorDateValue","selectorModificationDateValue","date","dateTime","dateTimeRange","modificationDateTimeRange","floatingTimeRange"],m._LITERAL_NAMES=[void 0,"'/'","'('","')'","'AND'","'OR'","'NOT'","'PAST_HOUR'","'PAST_DAY'","'PAST_WEEK'","'PAST_MONTH'","'PAST_YEAR'",void 0,void 0,void 0,void 0,"'name:'","'tag:'","'type:'","'datasetType:'","'recipeType:'","'user:'","'created:'","'createdOn:'","'createdBetween:'","'createdFrom:'","'createdTo:'","'downstreamFrom:'","'modified:'","'modifiedOn:'","'modifiedBetween:'","'modifiedFrom:'","'modifiedTo:'",void 0,"' '"],m._SYMBOLIC_NAMES=[void 0,void 0,"LPAREN","RPAREN","AND","OR","NOT","PAST_HOUR","PAST_DAY","PAST_WEEK","PAST_MONTH","PAST_YEAR","DATETIME","DATE","TIME","VALUE","NAME","TAG","TYPE","DATASET_TYPE","RECIPE_TYPE","USER","CREATED","CREATED_ON","CREATED_BETWEEN","CREATED_FROM","CREATED_TO","DOWNSTREAM_FROM","MODIFIED","MODIFIED_ON","MODIFIED_BETWEEN","MODIFIED_FROM","MODIFIED_TO","WS","SPACE","ESCAPED_TEXT"],m.VOCABULARY=new y.VocabularyImpl(m._LITERAL_NAMES,m._SYMBOLIC_NAMES,[]),m._serializedATN='꽯茠䞝띜䢀ᘅᤜꬷ%j\t\t\t\t\t\t\b\t\b\t\t\t\n\t\n\v\t\v\f\t\f\r\t\r\t\n7\n=\n\f@\vE\n\fH\vJ\nR\n\b\b\bV\n\b\t\t\tZ\n\t\n\n\v\v\f\f\f\f\r\r\r\r\b\n\f!"\t\rl6I\bK\nM\fQUY[]_cg  !"\b"##$$%%7&\'\b\'7\v()\t)7\f*+\t+7\b,--7\f.//701\t17\t23 37\r45576!6&6(6*6,6.6062647>89\f\n9::;\v;=<8=@><>??@>AJBJCE$DCEHFDFGGJHFIAIBIFJKL%L\tMNN\vOR\nPR\bQOQPR\rSV\nTV\vUSUTVWZ\nXZ\vYWYXZ[\\\\]^^_`\v`aab\vbcd\vdeef\vfgh\th\n6>FIQUY',n([u.Override,l.NotNull],m.prototype,"vocabulary",null),n([u.Override],m.prototype,"grammarFileName",null),n([u.Override],m.prototype,"ruleNames",null),n([u.Override],m.prototype,"serializedATN",null),n([f.RuleVersion(0)],m.prototype,"parse",null),n([f.RuleVersion(0)],m.prototype,"expression",null),n([f.RuleVersion(0)],m.prototype,"operator",null),n([f.RuleVersion(0)],m.prototype,"escapedTextValue",null),n([f.RuleVersion(0)],m.prototype,"stringValue",null),n([f.RuleVersion(0)],m.prototype,"selectorTextValue",null),n([f.RuleVersion(0)],m.prototype,"selectorDateValue",null),n([f.RuleVersion(0)],m.prototype,"selectorModificationDateValue",null),n([f.RuleVersion(0)],m.prototype,"date",null),n([f.RuleVersion(0)],m.prototype,"dateTime",null),n([f.RuleVersion(0)],m.prototype,"dateTimeRange",null),n([f.RuleVersion(0)],m.prototype,"modificationDateTimeRange",null),n([f.RuleVersion(0)],m.prototype,"floatingTimeRange",null),e.FlowFilterParser=m;class T extends h.ParserRuleContext{EOF(){return this.getToken(m.EOF,0)}expression(){return this.tryGetRuleContext(0,S)}constructor(t,e){super(t,e)}get ruleIndex(){return m.RULE_parse}}n([u.Override],T.prototype,"ruleIndex",null),e.ParseContext=T;class S extends h.ParserRuleContext{constructor(t,e){void 0!==t&&void 0!==e?super(t,e):super()}get ruleIndex(){return m.RULE_expression}copyFrom(t){super.copyFrom(t)}}n([u.Override],S.prototype,"ruleIndex",null),e.ExpressionContext=S;class x extends S{constructor(t){super(),this.copyFrom(t)}expression(t){return void 0===t?this.getRuleContexts(S):this.getRuleContext(t,S)}operator(){return this.getRuleContext(0,P)}}e.BinaryExpressionContext=x;class E extends S{constructor(t){super(),this.copyFrom(t)}selectorDateValue(){return this.getRuleContext(0,j)}CREATED_FROM(){return this.tryGetToken(m.CREATED_FROM,0)}CREATED_TO(){return this.tryGetToken(m.CREATED_TO,0)}CREATED_ON(){return this.tryGetToken(m.CREATED_ON,0)}}e.SelectorWithDateExpressionContext=E;class N extends S{constructor(t){super(),this.copyFrom(t)}MODIFIED(){return this.getToken(m.MODIFIED,0)}floatingTimeRange(){return this.getRuleContext(0,q)}}e.SelectorWithFloatingModificationDateExpressionContext=N;class O extends S{constructor(t){super(),this.copyFrom(t)}CREATED(){return this.getToken(m.CREATED,0)}floatingTimeRange(){return this.getRuleContext(0,q)}}e.SelectorWithFloatingDateExpressionContext=O;class v extends S{constructor(t){super(),this.copyFrom(t)}CREATED_BETWEEN(){return this.getToken(m.CREATED_BETWEEN,0)}dateTimeRange(){return this.getRuleContext(0,B)}}e.SelectorWithDateRangeExpressionContext=v;class b extends S{constructor(t){super(),this.copyFrom(t)}MODIFIED_BETWEEN(){return this.getToken(m.MODIFIED_BETWEEN,0)}modificationDateTimeRange(){return this.getRuleContext(0,V)}}e.SelectorWithModificationDateRangeExpressionContext=b;class A extends S{constructor(t){super(),this.copyFrom(t)}NOT(){return this.getToken(m.NOT,0)}expression(){return this.getRuleContext(0,S)}}e.NotExpressionContext=A;class C extends S{LPAREN(){return this.getToken(m.LPAREN,0)}expression(){return this.getRuleContext(0,S)}RPAREN(){return this.getToken(m.RPAREN,0)}constructor(t){super(),this.copyFrom(t)}}e.ParenExpressionContext=C;class R extends S{constructor(t){super(),this.copyFrom(t)}selectorTextValue(){return this.getRuleContext(0,F)}NAME(){return this.tryGetToken(m.NAME,0)}TYPE(){return this.tryGetToken(m.TYPE,0)}TAG(){return this.tryGetToken(m.TAG,0)}USER(){return this.tryGetToken(m.USER,0)}DOWNSTREAM_FROM(){return this.tryGetToken(m.DOWNSTREAM_FROM,0)}DATASET_TYPE(){return this.tryGetToken(m.DATASET_TYPE,0)}RECIPE_TYPE(){return this.tryGetToken(m.RECIPE_TYPE,0)}}e.SelectorWithTextExpressionContext=R;class I extends S{constructor(t){super(),this.copyFrom(t)}selectorModificationDateValue(){return this.getRuleContext(0,z)}MODIFIED_FROM(){return this.tryGetToken(m.MODIFIED_FROM,0)}MODIFIED_TO(){return this.tryGetToken(m.MODIFIED_TO,0)}MODIFIED_ON(){return this.tryGetToken(m.MODIFIED_ON,0)}}e.SelectorWithModificationDateExpressionContext=I;class P extends h.ParserRuleContext{constructor(t,e){void 0!==t&&void 0!==e?super(t,e):super()}get ruleIndex(){return m.RULE_operator}copyFrom(t){super.copyFrom(t)}}n([u.Override],P.prototype,"ruleIndex",null),e.OperatorContext=P;class D extends P{OR(){return this.getToken(m.OR,0)}constructor(t){super(),this.copyFrom(t)}}e.OrOperatorContext=D;class k extends P{AND(){return this.getToken(m.AND,0)}constructor(t){super(),this.copyFrom(t)}}e.AndOperatorContext=k;class L extends P{SPACE(t){return void 0===t?this.getTokens(m.SPACE):this.getToken(m.SPACE,t)}constructor(t){super(),this.copyFrom(t)}}e.SpaceOperatorContext=L;class w extends h.ParserRuleContext{ESCAPED_TEXT(){return this.getToken(m.ESCAPED_TEXT,0)}constructor(t,e){super(t,e)}get ruleIndex(){return m.RULE_escapedTextValue}}n([u.Override],w.prototype,"ruleIndex",null),e.EscapedTextValueContext=w;class M extends h.ParserRuleContext{VALUE(){return this.getToken(m.VALUE,0)}constructor(t,e){super(t,e)}get ruleIndex(){return m.RULE_stringValue}}n([u.Override],M.prototype,"ruleIndex",null),e.StringValueContext=M;class F extends h.ParserRuleContext{stringValue(){return this.tryGetRuleContext(0,M)}escapedTextValue(){return this.tryGetRuleContext(0,w)}constructor(t,e){super(t,e)}get ruleIndex(){return m.RULE_selectorTextValue}}n([u.Override],F.prototype,"ruleIndex",null),e.SelectorTextValueContext=F;class j extends h.ParserRuleContext{date(){return this.tryGetRuleContext(0,U)}dateTime(){return this.tryGetRuleContext(0,H)}constructor(t,e){super(t,e)}get ruleIndex(){return m.RULE_selectorDateValue}}n([u.Override],j.prototype,"ruleIndex",null),e.SelectorDateValueContext=j;class z extends h.ParserRuleContext{date(){return this.tryGetRuleContext(0,U)}dateTime(){return this.tryGetRuleContext(0,H)}constructor(t,e){super(t,e)}get ruleIndex(){return m.RULE_selectorModificationDateValue}}n([u.Override],z.prototype,"ruleIndex",null),e.SelectorModificationDateValueContext=z;class U extends h.ParserRuleContext{DATE(){return this.getToken(m.DATE,0)}constructor(t,e){super(t,e)}get ruleIndex(){return m.RULE_date}}n([u.Override],U.prototype,"ruleIndex",null),e.DateContext=U;class H extends h.ParserRuleContext{DATETIME(){return this.getToken(m.DATETIME,0)}constructor(t,e){super(t,e)}get ruleIndex(){return m.RULE_dateTime}}n([u.Override],H.prototype,"ruleIndex",null),e.DateTimeContext=H;class B extends h.ParserRuleContext{constructor(t,e){super(t,e)}dateTime(t){return void 0===t?this.getRuleContexts(H):this.getRuleContext(t,H)}get ruleIndex(){return m.RULE_dateTimeRange}}n([u.Override],B.prototype,"ruleIndex",null),e.DateTimeRangeContext=B;class V extends h.ParserRuleContext{constructor(t,e){super(t,e)}dateTime(t){return void 0===t?this.getRuleContexts(H):this.getRuleContext(t,H)}get ruleIndex(){return m.RULE_modificationDateTimeRange}}n([u.Override],V.prototype,"ruleIndex",null),e.ModificationDateTimeRangeContext=V;class q extends h.ParserRuleContext{PAST_HOUR(){return this.tryGetToken(m.PAST_HOUR,0)}PAST_DAY(){return this.tryGetToken(m.PAST_DAY,0)}PAST_WEEK(){return this.tryGetToken(m.PAST_WEEK,0)}PAST_MONTH(){return this.tryGetToken(m.PAST_MONTH,0)}PAST_YEAR(){return this.tryGetToken(m.PAST_YEAR,0)}constructor(t,e){super(t,e)}get ruleIndex(){return m.RULE_floatingTimeRange}}n([u.Override],q.prototype,"ruleIndex",null),e.FloatingTimeRangeContext=q},function(t,e,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r),Object.defineProperty(t,n,{enumerable:!0,get:function(){return e[r]}})}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),i=this&&this.__exportStar||function(t,e){for(var r in t)"default"===r||e.hasOwnProperty(r)||n(e,t,r)};Object.defineProperty(e,"__esModule",{value:!0}),i(r(131),e),i(r(142),e)},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.CodeCompletionCore=e.CandidatesCollection=void 0;const n=r(65),i=r(132),o=r(139);class s{constructor(){this.tokens=new Map,this.rules=new Map}}e.CandidatesCollection=s;class l{constructor(){this.path=[],this.following=[]}}class a{}class u{constructor(t){this.showResult=!1,this.showDebugOutput=!1,this.debugOutputWithTransitions=!1,this.showRuleStack=!1,this.tokenStartIndex=0,this.statesProcessed=0,this.shortcutMap=new Map,this.candidates=new s,this.atnStateTypeMap=["invalid","basic","rule start","block start","plus block start","star block start","token start","rule stop","block end","star loop back","star loop entry","plus loop back","loop end"],this.parser=t,this.atn=t.atn,this.vocabulary=t.vocabulary,this.ruleNames=t.ruleNames,this.ignoredTokens=new Set,this.preferredRules=new Set}collectCandidates(t,e){this.shortcutMap.clear(),this.candidates.rules.clear(),this.candidates.tokens.clear(),this.statesProcessed=0,this.tokenStartIndex=e?e.start.tokenIndex:0;let r=this.parser.inputStream,i=r.index;r.seek(this.tokenStartIndex),this.tokens=[];let o=1;for(;;){let e=r.LT(o++);if(this.tokens.push(e.type),e.tokenIndex>=t||e.type==n.Token.EOF)break}r.seek(i);let s=e?e.ruleIndex:0;if(this.processRule(this.atn.ruleToStartState[s],0,[],""),this.showResult&&console.log("States processed: "+this.statesProcessed),this.showResult){console.log("\n\nCollected rules:\n");for(let t of this.candidates.rules){let e="";for(let r of t[1])e+=this.ruleNames[r]+" ";console.log(this.ruleNames[t[0]]+", path: ",e)}let t=new Set;for(let e of this.candidates.tokens){let r=this.vocabulary.getDisplayName(e[0]);for(let t of e[1])r+=" "+this.vocabulary.getDisplayName(t);t.add(r)}console.log("\n\nCollected tokens:\n");for(let e of t)console.log(e);console.log("\n\n")}return this.candidates}checkPredicate(t){return t.predicate.eval(this.parser,n.ParserRuleContext.emptyContext())}translateToRuleIndex(t){if(0==this.preferredRules.size)return!1;for(let e=0;e<t.length;++e)if(this.preferredRules.has(t[e])){let r=t.slice(0,e),n=!0;for(let i of this.candidates.rules)if(i[0]==t[e]&&i[1].length==r.length&&r.every((t,e)=>t===i[1][e])){n=!1;break}return n&&(this.candidates.rules.set(t[e],r),this.showDebugOutput&&console.log("=====> collected: ",this.ruleNames[e])),!0}return!1}getFollowingTokens(t){let e=[],r=[t.target];for(;r.length>0;){let t=r.pop();for(let n of t.getTransitions())if(5==n.serializationType)if(n.isEpsilon)r.push(n.target);else{let t=n.label.toList();1!=t.length||this.ignoredTokens.has(t[0])||(e.push(t[0]),r.push(n.target))}}return e}determineFollowSets(t,e){let r=[],n=new Set;return this.collectFollowSets(t,e,r,n,[]),r}collectFollowSets(t,e,r,i,s){if(!i.has(t)){if(i.add(t),t==e||7==t.stateType){let t=new l;return t.intervals=o.IntervalSet.of(n.Token.EPSILON),t.path=s.slice(),void r.push(t)}for(let a of t.getTransitions())if(3==a.serializationType){let t=a;if(-1!=s.indexOf(t.target.ruleIndex))continue;s.push(t.target.ruleIndex),this.collectFollowSets(a.target,e,r,i,s),s.pop()}else if(4==a.serializationType)this.checkPredicate(a)&&this.collectFollowSets(a.target,e,r,i,s);else if(a.isEpsilon)this.collectFollowSets(a.target,e,r,i,s);else if(9==a.serializationType){let t=new l;t.intervals=o.IntervalSet.of(n.Token.MIN_USER_TOKEN_TYPE,this.atn.maxTokenType),t.path=s.slice(),r.push(t)}else{let t=a.label;if(t&&t.size>0){8==a.serializationType&&(t=t.complement(o.IntervalSet.of(n.Token.MIN_USER_TOKEN_TYPE,this.atn.maxTokenType)));let e=new l;e.intervals=t,e.path=s.slice(),e.following=this.getFollowingTokens(a),r.push(e)}}}}processRule(t,e,r,i){let s=this.shortcutMap.get(t.ruleIndex);if(s){if(s.has(e))return this.showDebugOutput&&console.log("=====> shortcut"),s.get(e)}else s=new Map,this.shortcutMap.set(t.ruleIndex,s);let l=new Set,c=u.followSetsByATN.get(this.parser.constructor.name);c||(c=new Map,u.followSetsByATN.set(this.parser.constructor.name,c));let h=c.get(t.stateNumber);if(!h){h=new a,c.set(t.stateNumber,h);let e=this.atn.ruleToStopState[t.ruleIndex];h.sets=this.determineFollowSets(t,e);let r=new o.IntervalSet;for(let t of h.sets)r.addAll(t.intervals);h.combined=r}r.push(t.ruleIndex);let p=this.tokens[e];if(e>=this.tokens.length-1){if(this.preferredRules.has(t.ruleIndex))this.translateToRuleIndex(r);else for(let t of h.sets){let e=r.slice();if(e.push(...t.path),!this.translateToRuleIndex(e))for(let e of t.intervals.toList())this.ignoredTokens.has(e)||(this.showDebugOutput&&console.log("=====> collected: ",this.vocabulary.getDisplayName(e)),this.candidates.tokens.has(e)?this.candidates.tokens.get(e)!=t.following&&this.candidates.tokens.set(e,[]):this.candidates.tokens.set(e,t.following))}return r.pop(),l}if(!h.combined.contains(n.Token.EPSILON)&&!h.combined.contains(p))return r.pop(),l;let d,f=[];for(f.push({state:t,tokenIndex:e});f.length>0;){d=f.pop(),++this.statesProcessed,p=this.tokens[d.tokenIndex];let t=d.tokenIndex>=this.tokens.length-1;switch(this.showDebugOutput&&(this.printDescription(i,d.state,this.generateBaseDescription(d.state),d.tokenIndex),this.showRuleStack&&this.printRuleState(r)),d.state.stateType){case 2:i+="  ";break;case 7:l.add(d.tokenIndex);continue}let e=d.state.getTransitions();for(let s of e)switch(s.serializationType){case 3:{let t=this.processRule(s.target,d.tokenIndex,r,i);for(let e of t)f.push({state:s.followState,tokenIndex:e});break}case 4:this.checkPredicate(s)&&f.push({state:s.target,tokenIndex:d.tokenIndex});break;case 9:if(t){if(!this.translateToRuleIndex(r))for(let t of o.IntervalSet.of(n.Token.MIN_USER_TOKEN_TYPE,this.atn.maxTokenType).toList())this.ignoredTokens.has(t)||this.candidates.tokens.set(t,[])}else f.push({state:s.target,tokenIndex:d.tokenIndex+1});break;default:{if(s.isEpsilon){f.push({state:s.target,tokenIndex:d.tokenIndex});continue}let e=s.label;if(e&&e.size>0)if(8==s.serializationType&&(e=e.complement(o.IntervalSet.of(n.Token.MIN_USER_TOKEN_TYPE,this.atn.maxTokenType))),t){if(!this.translateToRuleIndex(r)){let t=e.toList(),r=1==t.length;for(let e of t)this.ignoredTokens.has(e)||(this.showDebugOutput&&console.log("=====> collected: ",this.vocabulary.getDisplayName(e)),r?this.candidates.tokens.set(e,this.getFollowingTokens(s)):this.candidates.tokens.set(e,[]))}}else e.contains(p)&&(this.showDebugOutput&&console.log("=====> consumed: ",this.vocabulary.getDisplayName(p)),f.push({state:s.target,tokenIndex:d.tokenIndex+1}))}}}return r.pop(),s.set(e,l),l}generateBaseDescription(t){return"["+(t.stateNumber==i.ATNState.INVALID_STATE_NUMBER?"Invalid":t.stateNumber)+" "+this.atnStateTypeMap[t.stateType]+"] in "+this.ruleNames[t.ruleIndex]}printDescription(t,e,r,n){let i=t,o="";if(this.debugOutputWithTransitions)for(let r of e.getTransitions()){let e="",n=r.label?r.label.toList():[];if(n.length>2)e=this.vocabulary.getDisplayName(n[0])+" .. "+this.vocabulary.getDisplayName(n[n.length-1]);else for(let t of n)e.length>0&&(e+=", "),e+=this.vocabulary.getDisplayName(t);0==e.length&&(e="ε"),o+="\n"+t+"\t("+e+") ["+r.target.stateNumber+" "+this.atnStateTypeMap[r.target.stateType]+"] in "+this.ruleNames[r.target.ruleIndex]}n>=this.tokens.length-1?i+="<<"+this.tokenStartIndex+n+">> ":i+="<"+this.tokenStartIndex+n+"> ",console.log(i+"Current state: "+r+o)}printRuleState(t){if(0!=t.length)for(let e of t)console.log(this.ruleNames[e]);else console.log("<empty stack>")}}e.CodeCompletionCore=u,u.followSetsByATN=new Map},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */function n(t){for(var r in t)e.hasOwnProperty(r)||(e[r]=t[r])}Object.defineProperty(e,"__esModule",{value:!0}),n(r(34)),n(r(60)),n(r(106)),n(r(7)),n(r(27)),n(r(23)),n(r(59)),n(r(47)),n(r(28)),n(r(11)),n(r(133)),n(r(134)),n(r(61)),n(r(76)),n(r(56)),n(r(77)),n(r(31)),n(r(87)),n(r(107)),n(r(25)),n(r(108)),n(r(15)),n(r(78)),n(r(109)),n(r(55)),n(r(73)),n(r(135)),n(r(39)),n(r(79)),n(r(80)),n(r(74)),n(r(81)),n(r(82)),n(r(83)),n(r(84)),n(r(85)),n(r(86)),n(r(72)),n(r(110)),n(r(62)),n(r(43)),n(r(75)),n(r(136)),n(r(32)),n(r(92)),n(r(93)),n(r(94)),n(r(111)),n(r(50)),n(r(4)),n(r(40)),n(r(91)),n(r(137)),n(r(95)),n(r(96)),n(r(24)),n(r(45)),n(r(18)),n(r(44)),n(r(64)),n(r(97)),n(r(98)),n(r(42)),n(r(99)),n(r(9)),n(r(138)),n(r(57))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0}),function(t){t[t.INVALID_TYPE=0]="INVALID_TYPE",t[t.BASIC=1]="BASIC",t[t.RULE_START=2]="RULE_START",t[t.BLOCK_START=3]="BLOCK_START",t[t.PLUS_BLOCK_START=4]="PLUS_BLOCK_START",t[t.STAR_BLOCK_START=5]="STAR_BLOCK_START",t[t.TOKEN_START=6]="TOKEN_START",t[t.RULE_STOP=7]="RULE_STOP",t[t.BLOCK_END=8]="BLOCK_END",t[t.STAR_LOOP_BACK=9]="STAR_LOOP_BACK",t[t.STAR_LOOP_ENTRY=10]="STAR_LOOP_ENTRY",t[t.PLUS_LOOP_BACK=11]="PLUS_LOOP_BACK",t[t.LOOP_END=12]="LOOP_END"}(e.ATNStateType||(e.ATNStateType={}))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0}),function(t){t[t.LEXER=0]="LEXER",t[t.PARSER=1]="PARSER"}(e.ATNType||(e.ATNType={}))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0}),function(t){t[t.CHANNEL=0]="CHANNEL",t[t.CUSTOM=1]="CUSTOM",t[t.MODE=2]="MODE",t[t.MORE=3]="MORE",t[t.POP_MODE=4]="POP_MODE",t[t.PUSH_MODE=5]="PUSH_MODE",t[t.SKIP=6]="SKIP",t[t.TYPE=7]="TYPE"}(e.LexerActionType||(e.LexerActionType={}))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(0);let s=class{constructor(t){this.atnSimulator=t}getDecisionInfo(){return this.atnSimulator.getDecisionInfo()}getLLDecisions(){let t=this.atnSimulator.getDecisionInfo(),e=[];for(let r=0;r<t.length;r++){t[r].LL_Fallback>0&&e.push(r)}return e}getTotalTimeInPrediction(){let t=this.atnSimulator.getDecisionInfo(),e=0;for(let r=0;r<t.length;r++)e+=t[r].timeInPrediction;return e}getTotalSLLLookaheadOps(){let t=this.atnSimulator.getDecisionInfo(),e=0;for(let r=0;r<t.length;r++)e+=t[r].SLL_TotalLook;return e}getTotalLLLookaheadOps(){let t=this.atnSimulator.getDecisionInfo(),e=0;for(let r=0;r<t.length;r++)e+=t[r].LL_TotalLook;return e}getTotalSLLATNLookaheadOps(){let t=this.atnSimulator.getDecisionInfo(),e=0;for(let r=0;r<t.length;r++)e+=t[r].SLL_ATNTransitions;return e}getTotalLLATNLookaheadOps(){let t=this.atnSimulator.getDecisionInfo(),e=0;for(let r=0;r<t.length;r++)e+=t[r].LL_ATNTransitions;return e}getTotalATNLookaheadOps(){let t=this.atnSimulator.getDecisionInfo(),e=0;for(let r=0;r<t.length;r++)e+=t[r].SLL_ATNTransitions,e+=t[r].LL_ATNTransitions;return e}getDFASize(t){if(t){return this.atnSimulator.atn.decisionToDFA[t].states.size}{let t=0,e=this.atnSimulator.atn.decisionToDFA;for(let r=0;r<e.length;r++)t+=this.getDFASize(r);return t}}};n([o.NotNull],s.prototype,"getDecisionInfo",null),n([o.NotNull],s.prototype,"getLLDecisions",null),s=n([i(0,o.NotNull)],s),e.ParseInfo=s},function(t,e,r){"use strict";(function(t){
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
var n=this&&this.__decorate||function(t,e,r,n){var i,o=arguments.length,s=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,n);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(s=(o<3?i(s):o>3?i(e,r,s):i(e,r))||s);return o>3&&s&&Object.defineProperty(e,r,s),s},i=this&&this.__param||function(t,e){return function(r,n){e(r,n,t)}};Object.defineProperty(e,"__esModule",{value:!0});const o=r(106),s=r(7),l=r(28),a=r(107),u=r(108),c=r(109),h=r(0),p=r(110),d=r(32),f=r(111),g=r(18),y=r(64);class _ extends d.ParserATNSimulator{constructor(t){super(t.interpreter.atn,t),this._startIndex=0,this._sllStopIndex=0,this._llStopIndex=0,this.currentDecision=0,this.conflictingAltResolvedBySLL=0,this.optimize_ll1=!1,this.reportAmbiguities=!0,this.numDecisions=this.atn.decisionToState.length,this.decisions=[];for(let t=0;t<this.numDecisions;t++)this.decisions.push(new u.DecisionInfo(t))}adaptivePredict(e,r,n){try{this._input=e,this._startIndex=e.index,this._sllStopIndex=this._startIndex-1,this._llStopIndex=-1,this.currentDecision=r,this.currentState=void 0,this.conflictingAltResolvedBySLL=s.ATN.INVALID_ALT_NUMBER;let i=t.hrtime(),o=super.adaptivePredict(e,r,n),l=t.hrtime(),a=1e9*(l[0]-i[0]);0===a?a=l[1]-i[1]:a+=1e9-i[1]+l[1],this.decisions[r].timeInPrediction+=a,this.decisions[r].invocations++;let u=this._sllStopIndex-this._startIndex+1;if(this.decisions[r].SLL_TotalLook+=u,this.decisions[r].SLL_MinLook=0===this.decisions[r].SLL_MinLook?u:Math.min(this.decisions[r].SLL_MinLook,u),u>this.decisions[r].SLL_MaxLook&&(this.decisions[r].SLL_MaxLook=u,this.decisions[r].SLL_MaxLookEvent=new p.LookaheadEventInfo(r,void 0,o,e,this._startIndex,this._sllStopIndex,!1)),this._llStopIndex>=0){let t=this._llStopIndex-this._startIndex+1;this.decisions[r].LL_TotalLook+=t,this.decisions[r].LL_MinLook=0==this.decisions[r].LL_MinLook?t:Math.min(this.decisions[r].LL_MinLook,t),t>this.decisions[r].LL_MaxLook&&(this.decisions[r].LL_MaxLook=t,this.decisions[r].LL_MaxLookEvent=new p.LookaheadEventInfo(r,void 0,o,e,this._startIndex,this._llStopIndex,!0))}return o}finally{this._input=void 0,this.currentDecision=-1}}getStartState(t,e,r,n){let i=super.getStartState(t,e,r,n);return this.currentState=i,i}computeStartState(t,e,r){let n=super.computeStartState(t,e,r);return this.currentState=n,n}computeReachSet(t,e,r,n){if(void 0===this._input)throw new Error("Invalid state");let i=super.computeReachSet(t,e,r,n);return null==i&&this.decisions[this.currentDecision].errors.push(new c.ErrorInfo(this.currentDecision,e,this._input,this._startIndex,this._input.index)),this.currentState=i,i}getExistingTargetState(t,e){if(void 0===this.currentState||void 0===this._input)throw new Error("Invalid state");this.currentState.useContext?this._llStopIndex=this._input.index:this._sllStopIndex=this._input.index;let r=super.getExistingTargetState(t,e);if(null!=r&&(this.currentState=new y.SimulatorState(this.currentState.outerContext,r,this.currentState.useContext,this.currentState.remainingOuterContext),this.currentState.useContext?this.decisions[this.currentDecision].LL_DFATransitions++:this.decisions[this.currentDecision].SLL_DFATransitions++,r===l.ATNSimulator.ERROR)){let e=new y.SimulatorState(this.currentState.outerContext,t,this.currentState.useContext,this.currentState.remainingOuterContext);this.decisions[this.currentDecision].errors.push(new c.ErrorInfo(this.currentDecision,e,this._input,this._startIndex,this._input.index))}return r}computeTargetState(t,e,r,n,i,o){let s=super.computeTargetState(t,e,r,n,i,o);return i?this.decisions[this.currentDecision].LL_ATNTransitions++:this.decisions[this.currentDecision].SLL_ATNTransitions++,s}evalSemanticContextImpl(t,e,r){if(void 0===this.currentState||void 0===this._input)throw new Error("Invalid state");let n=super.evalSemanticContextImpl(t,e,r);if(!(t instanceof g.SemanticContext.PrecedencePredicate)){let e=this._llStopIndex>=0?this._llStopIndex:this._sllStopIndex;this.decisions[this.currentDecision].predicateEvals.push(new f.PredicateEvalInfo(this.currentState,this.currentDecision,this._input,this._startIndex,e,t,n,r))}return n}reportContextSensitivity(t,e,r,n,i){if(void 0===this._input)throw new Error("Invalid state");e!==this.conflictingAltResolvedBySLL&&this.decisions[this.currentDecision].contextSensitivities.push(new a.ContextSensitivityInfo(this.currentDecision,r,this._input,n,i)),super.reportContextSensitivity(t,e,r,n,i)}reportAttemptingFullContext(t,e,r,n,i){this.conflictingAltResolvedBySLL=null!=e?e.nextSetBit(0):r.s0.configs.getRepresentedAlternatives().nextSetBit(0),this.decisions[this.currentDecision].LL_Fallback++,super.reportAttemptingFullContext(t,e,r,n,i)}reportAmbiguity(t,e,r,n,i,l,u){if(void 0===this.currentState||void 0===this._input)throw new Error("Invalid state");let c;c=null!=l?l.nextSetBit(0):u.getRepresentedAlternatives().nextSetBit(0),this.conflictingAltResolvedBySLL!==s.ATN.INVALID_ALT_NUMBER&&c!==this.conflictingAltResolvedBySLL&&this.decisions[this.currentDecision].contextSensitivities.push(new a.ContextSensitivityInfo(this.currentDecision,this.currentState,this._input,r,n)),this.decisions[this.currentDecision].ambiguities.push(new o.AmbiguityInfo(this.currentDecision,this.currentState,l,this._input,r,n)),super.reportAmbiguity(t,e,r,n,i,l,u)}getDecisionInfo(){return this.decisions}getCurrentState(){return this.currentState}}n([h.Override],_.prototype,"adaptivePredict",null),n([h.Override],_.prototype,"getStartState",null),n([h.Override],_.prototype,"computeStartState",null),n([h.Override],_.prototype,"computeReachSet",null),n([h.Override],_.prototype,"getExistingTargetState",null),n([h.Override],_.prototype,"computeTargetState",null),n([h.Override],_.prototype,"evalSemanticContextImpl",null),n([h.Override],_.prototype,"reportContextSensitivity",null),n([h.Override],_.prototype,"reportAttemptingFullContext",null),n([h.Override,i(0,h.NotNull),i(5,h.NotNull),i(6,h.NotNull)],_.prototype,"reportAmbiguity",null),e.ProfilingATNSimulator=_}).call(e,r(48))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0}),function(t){t[t.EPSILON=1]="EPSILON",t[t.RANGE=2]="RANGE",t[t.RULE=3]="RULE",t[t.PREDICATE=4]="PREDICATE",t[t.ATOM=5]="ATOM",t[t.ACTION=6]="ACTION",t[t.SET=7]="SET",t[t.NOT_SET=8]="NOT_SET",t[t.WILDCARD=9]="WILDCARD",t[t.PRECEDENCE=10]="PRECEDENCE"}(e.TransitionType||(e.TransitionType={}))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */function n(t){for(var r in t)e.hasOwnProperty(r)||(e[r]=t[r])}Object.defineProperty(e,"__esModule",{value:!0}),n(r(20)),n(r(26)),n(r(140)),n(r(10)),n(r(37)),n(r(12)),n(r(51)),n(r(36)),n(r(53)),n(r(3)),n(r(14)),n(r(141)),n(r(1)),n(r(6)),n(r(102)),n(r(8)),n(r(100))},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0}),e.notNull=function(t,e){if(null==e)throw new TypeError(t+" cannot be null.")}},function(t,e,r){"use strict";
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */Object.defineProperty(e,"__esModule",{value:!0});e.MultiMap=class extends Map{constructor(){super()}map(t,e){let r=super.get(t);r||(r=[],super.set(t,r)),r.push(e)}getPairs(){let t=[];return this.forEach((e,r)=>{e.forEach(e=>{t.push([r,e])})}),t}}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.SymbolTable=e.SystemVariableSymbol=e.UserVariableSymbol=e.CollationSymbol=e.CharsetSymbol=e.LogfileGroupSymbol=e.TableSpaceSymbol=e.EngineSymbol=e.UdfSymbol=e.TriggerSymbol=e.StoredRoutineSymbol=e.ForeignKeySymbol=e.PrimaryKeySymbol=e.IndexSymbol=e.ColumnSymbol=e.EventSymbol=e.ViewSymbol=e.TableSymbol=e.SchemaSymbol=e.CatalogSymbol=e.ArrayType=e.ClassSymbol=e.FieldSymbol=e.MethodSymbol=e.MethodFlags=e.RoutineSymbol=e.ParameterSymbol=e.LiteralSymbol=e.VariableSymbol=e.NamespaceSymbol=e.ScopedSymbol=e.TypeAlias=e.TypedSymbol=e.Symbol=e.FundamentalType=e.ReferenceKind=e.TypeKind=e.MemberVisibility=e.DuplicateSymbolError=void 0;class n extends Error{}var i,o,s,l;e.DuplicateSymbolError=n,function(t){t[t.Invalid=-1]="Invalid",t[t.Public=0]="Public",t[t.Protected=1]="Protected",t[t.Private=2]="Private",t[t.Library=3]="Library"}(i=e.MemberVisibility||(e.MemberVisibility={})),function(t){t[t.Integer=0]="Integer",t[t.Float=1]="Float",t[t.String=2]="String",t[t.Boolean=3]="Boolean",t[t.Date=4]="Date",t[t.Class=5]="Class",t[t.Array=6]="Array",t[t.Alias=7]="Alias"}(o=e.TypeKind||(e.TypeKind={})),function(t){t[t.Irrelevant=0]="Irrelevant",t[t.Pointer=1]="Pointer",t[t.Reference=2]="Reference",t[t.Instance=3]="Instance"}(s=e.ReferenceKind||(e.ReferenceKind={}));class a{constructor(t,e,r){this.name=t,this.typeKind=e,this.referenceKind=r}get baseTypes(){return[]}get kind(){return this.typeKind}get reference(){return this.referenceKind}}e.FundamentalType=a,a.integerType=new a("int",o.Integer,s.Instance),a.floatType=new a("float",o.Float,s.Instance),a.stringType=new a("string",o.String,s.Instance),a.boolType=new a("bool",o.Boolean,s.Instance),a.dateType=new a("date",o.Date,s.Instance);class u{constructor(t=""){this.name="",this.name=t}setParent(t){this.parent=t}getParent(){return this.parent}removeFromParent(){this.parent instanceof h&&(this.parent.removeSymbol(this),this.parent=void 0)}getRoot(){let t=this.parent;for(;t;){if(!t.parent||t.parent instanceof m)return t;t=t.parent}return t}getSymbolTable(){if(this instanceof m)return this;let t=this.parent;for(;t;){if(t instanceof m)return t;t=t.parent}}getParentOfType(t){let e=this.parent;for(;e;){if(e instanceof t)return e;e=e.parent}}getSymbolPath(){let t=[],e=this;for(;e&&(t.push(e),e.parent);)e=e.parent;return t}qualifiedName(t=".",e=!1,r=!1){if(!r&&0==this.name.length)return"";let n=0==this.name.length?"<anonymous>":this.name,i=this.parent;for(;i&&(!(r||i.name.length>0)||(n=(0==i.name.length?"<anonymous>":i.name)+t+n,e&&i.parent));)i=i.parent;return n}}e.Symbol=u;class c extends u{constructor(t,e){super(t),this.type=e}}e.TypedSymbol=c;e.TypeAlias=class extends u{constructor(t,e){super(t),this.targetType=e}get baseTypes(){return[this.targetType]}get kind(){return o.Alias}get reference(){return s.Irrelevant}};class h extends u{constructor(t=""){super(t),this.children=[]}addSymbol(t){t.removeFromParent();let e=this.getSymbolTable();if(!e||!e.options.allowDuplicateSymbols)for(let e of this.children)if(e==t||t.name.length>0&&e.name==t.name){let e=t.name;throw 0==e.length&&(e="<anonymous>"),new n("Attempt to add duplicate symbol '"+e+"'")}this.children.push(t),t.setParent(this)}removeSymbol(t){let e=this.children.indexOf(t);e>-1&&(this.children.splice(e,1),t.setParent(void 0))}getSymbolsOfType(t){let e=[];for(let r of this.children)r instanceof t&&e.push(r);return e}getNestedSymbolsOfType(t){let e=[];for(let r of this.children)r instanceof t&&e.push(r),r instanceof h&&e.push(...r.getNestedSymbolsOfType(t));return e}getAllNestedSymbols(){let t=[];for(let e of this.children)t.push(e),e instanceof h&&t.push(...e.getAllNestedSymbols());return t}getAllSymbols(t,e=!1){let r=[];for(let e of this.children)e instanceof t&&r.push(e),e instanceof p&&r.push(...e.getAllSymbols(t,!0));return e||this.parent&&this.parent instanceof h&&r.push(...this.parent.getAllSymbols(t)),r}resolve(t,e=!1){for(let e of this.children)if(e.name==t)return e;if(!e&&this.parent&&this.parent instanceof h)return this.parent.resolve(t,!1)}getTypedSymbols(t=!0){let e=[];for(let t of this.children)t instanceof c&&e.push(t);if(!t&&this.parent instanceof h){let t=this.parent.getTypedSymbols(!0);e.push(...t)}return e}getTypedSymbolNames(t=!0){let e=[];for(let t of this.children)t instanceof c&&e.push(t.name);if(!t&&this.parent instanceof h){let t=this.parent.getTypedSymbolNames(!0);e.push(...t)}return e}getDirectScopes(){return this.getSymbolsOfType(h)}symbolFromPath(t,e="."){let r=t.split(e),n=0;r[0]!=this.name&&0!=r[0].length||++n;let i=this;for(;n<r.length;){if(!(i instanceof h))return;let t=i.children.find(t=>t.name==r[n]);if(!t)return;i=t,++n}return i}}e.ScopedSymbol=h;class p extends h{}e.NamespaceSymbol=p;class d extends c{constructor(t,e,r){super(t,r),this.value=e}}e.VariableSymbol=d;e.LiteralSymbol=class extends c{constructor(t,e,r){super(t,r),this.value=e}};class f extends d{}e.ParameterSymbol=f;class g extends h{constructor(t,e){super(t),this.returnType=e}getVariables(t=!0){return this.getSymbolsOfType(d)}getParameters(t=!0){return this.getSymbolsOfType(f)}}e.RoutineSymbol=g,function(t){t[t.None=0]="None",t[t.Virtual=1]="Virtual",t[t.Const=2]="Const",t[t.Overwritten=4]="Overwritten",t[t.SetterOrGetter=8]="SetterOrGetter",t[t.Explicit=16]="Explicit"}(l=e.MethodFlags||(e.MethodFlags={}));class y extends g{constructor(t,e){super(t,e),this.methodFlags=l.None,this.visibility=i.Invalid}}e.MethodSymbol=y;class _ extends d{constructor(t,e){super(t,e),this.visibility=i.Invalid}}e.FieldSymbol=_;e.ClassSymbol=class extends h{constructor(t,e,...r){super(t),this.isStruct=!1,this.superClasses=[],this.referenceKind=e,this.superClasses.push(...r)}get baseTypes(){return this.superClasses}get kind(){return o.Class}get reference(){return this.referenceKind}getMethods(t=!1){return this.getSymbolsOfType(y)}getFields(t=!1){return this.getSymbolsOfType(_)}};e.ArrayType=class extends u{constructor(t,e,r,n=0){super(t),this.referenceKind=e,this.elementType=r,this.size=n}get baseTypes(){return[]}get kind(){return o.Array}get reference(){return this.referenceKind}};e.CatalogSymbol=class extends h{};e.SchemaSymbol=class extends h{};e.TableSymbol=class extends h{};e.ViewSymbol=class extends h{};e.EventSymbol=class extends h{};e.ColumnSymbol=class extends c{};e.IndexSymbol=class extends u{};e.PrimaryKeySymbol=class extends u{};e.ForeignKeySymbol=class extends u{};e.StoredRoutineSymbol=class extends g{};e.TriggerSymbol=class extends h{};e.UdfSymbol=class extends u{};e.EngineSymbol=class extends u{};e.TableSpaceSymbol=class extends u{};e.LogfileGroupSymbol=class extends u{};e.CharsetSymbol=class extends u{};e.CollationSymbol=class extends u{};e.UserVariableSymbol=class extends d{};e.SystemVariableSymbol=class extends u{};class m extends h{constructor(t,e){super(t),this.options=e,this.dependencies=new Set}clear(){this.dependencies.clear(),this.children=[]}addDependencies(...t){t.forEach((t,e)=>{this.dependencies.add(t)})}removeDependency(t){this.dependencies.has(t)&&this.dependencies.delete(t)}getInfo(){return{dependencyCount:this.dependencies.size,symbolCount:this.children.length}}addNewSymbolOfType(t,e,...r){let n=new t(...r);return e&&e!=this?e.addSymbol(n):this.addSymbol(n),n}addNewNamespaceFromPath(t,e,r="."){let n=e.split(r),i=0,o=void 0==t?this:t;for(;i<n.length-1;){let t=o.resolve(n[i],!0);void 0==t&&(t=this.addNewSymbolOfType(p,o,n[i])),o=t,++i}return this.addNewSymbolOfType(p,o,n[n.length-1])}getAllSymbols(t,e=!1){let r=t||u,n=super.getAllSymbols(r,e);if(!e)for(let r of this.dependencies)n.push(...r.getAllSymbols(t,e));return n}resolve(t,e=!1){let r=super.resolve(t,e);if(!r&&!e)for(let e of this.dependencies)if(r=e.resolve(t,!1))break;return r}}e.SymbolTable=m}]);
(function() {
'use strict';

const app = angular.module('dataiku.recipes', ['dataiku.common.lists']);


app.directive('checkRecipeNameUnique', function(DataikuAPI, $stateParams) {
    return {
        require: 'ngModel',
        link: function(scope, elem, attrs, ngModel) {
            DataikuAPI.flow.recipes.list($stateParams.projectKey).success(function(data) {
                scope.unique_recipes_names = $.map(data, function(recipe) {
                    return recipe.name;
                });
                /* Re-apply validation as soon as we get the list */
                apply_validation(ngModel.$modelValue);
            });
            var initialValue = null, initialValueInitialized = false;
            function apply_validation(value) {
                // Implicitely trust the first value (== our own name)
                if (initialValueInitialized == false && value != undefined && value != null && value.length > 0) {
                    initialValue = value;
                    initialValueInitialized = true;
                }
                // It is fake, but other check will get it.
                if (value == null || value.length === 0) return true;
                // We are back to our name, accept.
                if (initialValueInitialized && value == initialValue) return value;
                var valid = scope.unique_recipes_names ? scope.unique_recipes_names.indexOf(value) === -1 : true;
                ngModel.$setValidity('recipeNameUnique', valid);
                return valid ? value : undefined;
            }
             //For DOM -> model validation
            ngModel.$parsers.unshift(apply_validation);

            //For model -> DOM validation
            ngModel.$formatters.unshift(function(value) {
                apply_validation(value);
                return value;
            });
        }
    };
});

app.filter("buildModeDescription", function(){
    var dict = {
        "NON_RECURSIVE_FORCED_BUILD": "Build only this dataset",
        "RECURSIVE_BUILD": "Build required datasets",
        "RECURSIVE_FORCED_BUILD": "Force-rebuild dataset and dependencies",
        "RECURSIVE_MISSING_ONLY_BUILD": "Build missing dependencies then this one"
    };
    return function(input) {
        return dict[input] || input;
    }
});

app.directive('recipePipelineConfig', function() {
    return {
        restrict: 'E',
        templateUrl: '/templates/recipes/fragments/recipe-pipeline-config.html',
        scope: {
          config: "=",
          anyPipelineTypeEnabled: "&"
        }
    };
});

app.directive('otherActionListItem', function() {
    return {
        restrict: 'E',
        templateUrl: '/templates/recipes/fragments/other-action-list-item.html',
        scope: {
            icon: "@",
            label: "@",
            onClick: '&',
            showCondition: "<?",
            enableCondition: "<?",
            disabledTooltip: "@?"
        },
        link: function(scope) {
            if (scope.showCondition === undefined) {
                scope.showCondition = true;
            }
            if (scope.enableCondition === undefined) {
                scope.enableCondition = true;
            }
        }
    };
});

app.directive("sparkDatasetsReadParamsBehavior", function(Assert, $stateParams, RecipesUtils, Logger, DatasetUtils) {
    return {
        scope: true,
        link: function($scope, element, attrs) {
            Logger.info("Loading spark behavior");
            Assert.inScope($scope, 'recipe');
            let contextProjectKey = $scope.context && $scope.context.projectKey ? $scope.context.projectKey:$scope.recipe.projectKey;

            $scope.readParams = $scope.$eval(attrs.readParams);
            Assert.inScope($scope, 'readParams');

            function autocomplete() {
                RecipesUtils.getFlatInputsList($scope.recipe).forEach(function(input) {
                    Assert.inScope($scope, 'computablesMap');
                    const computable = $scope.computablesMap[input.ref];
                    if (!computable) {
                        throw Error('dataset is not in computablesMap, try reloading the page');
                    }
                    const dataset = computable.dataset;
                    if (dataset && !$scope.readParams.map[input.ref]) {
                        $scope.readParams.map[input.ref] = {
                            repartition: ['HDFS', 'hiveserver2'].includes(dataset.type) ? 1 : 10,
                            cache: false
                        };
                    }
                });
                Logger.info("Updated map", $scope.readParams.map);
            }

            $scope.$watch("recipe.inputs", function(nv, ov) {
                if (nv && $scope.computablesMap) {
                    DatasetUtils.updateRecipeComputables($scope, $scope.recipe, $stateParams.projectKey, contextProjectKey)
                        .then(_ => autocomplete());
                }
            }, true);
            $scope.$watch("computablesMap", function(nv, ov) {
                if (nv) {
                    DatasetUtils.updateRecipeComputables($scope, $scope.recipe, $stateParams.projectKey, contextProjectKey)
                        .then(_ => autocomplete());
                }
            }, true);
        }
    }
});


app.directive("sparkDatasetsReadParams", function(Assert, RecipesUtils) {
    return {
        scope: true,
        templateUrl: "/templates/recipes/fragments/spark-datasets-read-params.html",
        link: function($scope, element, attrs) {
            Assert.inScope($scope, 'recipe');
            $scope.readParams = $scope.$eval(attrs.readParams);
            Assert.inScope($scope, 'readParams');
        }
    };
});


app.service('RecipesCapabilities', function(RecipeDescService, CodeEnvsService, AppConfig, $rootScope) {

    function getRecipeType(recipe) {
        if (recipe) {
            // A bit dirty, we don't know what recipe is (taggableObjectRef, graphNode, listItem...)
            if (recipe.recipeType) {
                return recipe.recipeType;
            } else if (recipe.subType) {
                return recipe.subType;
            } else if (recipe.type) {
                return recipe.type;
            }
        }
        return undefined;
    }

    this.isMultiEngine = function(recipe) {
        const desc = RecipeDescService.getDescriptor(getRecipeType(recipe));
        return !!desc && desc.isMultiEngine;
    };

    this.canEngine = function(recipe, engine) {
        if (!recipe) {
            return false;
        }
        const recipeType = getRecipeType(recipe);
        if (!recipeType) {
            return false;
        }
        if (recipeType.toLowerCase().includes(engine)) {
            return true;
        }
        const desc = RecipeDescService.getDescriptor(recipeType);
        // we can't be sure though...
        return !!(desc && desc.isMultiEngine);
    };

    this.isSparkEnabled = function() {
        return !AppConfig.get() || AppConfig.get().sparkEnabled;
    };

    this.canSpark = function(recipe) {
        return this.isSparkEnabled() && this.canEngine(recipe, 'spark');
    };

    this.canSparkPipeline = function (recipe) {
        return $rootScope.projectSummary.sparkPipelinesEnabled &&
            this.canSpark(recipe) &&
            !(['pyspark', 'sparkr'].includes(getRecipeType(recipe)));
    };

    this.canSqlPipeline = function(recipe) {
        const canEngine = this.canEngine(recipe, 'sql');
        const b = !(['spark_sql_query', 'sql_script'].includes(getRecipeType(recipe)));
        return $rootScope.projectSummary.sqlPipelinesEnabled &&
            canEngine &&
            b;
    };

    this.canChangeSparkPipelineability= function(recipe) {
        if (recipe) {
            // Prediction scoring is supported but there is a bug that prevent the backend to compute the pipelineabilty (Clubhouse #36393)
            if (getRecipeType(recipe) === 'prediction_scoring') {
                return false;
            }
            return this.canSpark(recipe);
        }
        return false;
    };

    this.canChangeSqlPipelineability= function(recipe) {
        const recipeType = getRecipeType(recipe);
        if (recipeType) {
            // The following recipes are the only ones that can run on SQL and be part of a SQL pipeline.
            if (['sync', 'shaker', 'sampling', 'grouping', 'distinct', 'window', 'join', 'split', 'topn', 'sort',
                    'pivot', 'vstack', 'sql_query', 'prediction_scoring'].includes(recipeType)) {
                return true;
            }
        }
        return false;
    };

    this.canImpala = function(recipe) {
        if (recipe) {
            const recipeType = getRecipeType(recipe);
            if (recipeType === 'impala') {
                return true;
            }
            if (AppConfig.get() && !AppConfig.get().sparkEnabled) {
                return false;
            }
            const desc = RecipeDescService.getDescriptor(recipeType);
            if (desc && desc.isMultiEngine) {
                return true; // we can't be sure...
            }
        }
        return false;
    };

    this.canHive = function(recipe) {
        if (recipe) {
            const recipeType = getRecipeType(recipe);
            if (recipeType === 'hive') {
                return true;
            }
            if (AppConfig.get() && !AppConfig.get().sparkEnabled) {
                return false;
            }
            const desc = RecipeDescService.getDescriptor(recipeType);
            if (desc && desc.isMultiEngine) {
                return true; // we can't be sure...
            }
        }
        return false;
    };

    this.canPythonCodeEnv = function(recipe) {
        return CodeEnvsService.canPythonCodeEnv(recipe);
    };

    this.canRCodeEnv = function(recipe) {
        return CodeEnvsService.canRCodeEnv(recipe);
    };
});

app.controller("RecipePageRightColumnActions", async function($controller, $scope, $rootScope, $stateParams, ActiveProjectKey, DataikuAPI) {

    $controller('_TaggableObjectPageRightColumnActions', {$scope: $scope});
    $controller('_RecipeWithEngineBehavior', {$scope: $scope});

    $scope.recipeData = (await DataikuAPI.flow.recipes.getFullInfo(ActiveProjectKey.get(), $stateParams.recipeName)).data;

    $scope.recipe = $scope.recipeData.recipe;
    $scope.recipe.recipeType = $scope.recipe.type;
    $scope.recipe.nodeType = 'RECIPE';
    $scope.recipe.id = $stateParams.recipeName;
    $scope.recipe.interest = $scope.recipeData.interest;

    $scope.selection = {
        selectedObject : $scope.recipe,
        confirmedItem : $scope.recipe
    };

    $scope.updateUserInterests = function() {
        DataikuAPI.interests.getForObject($rootScope.appConfig.login, "RECIPE", ActiveProjectKey.get(), $scope.selection.selectedObject.name)
            .success(function(data){
                $scope.selection.selectedObject.interest = data;
            })
            .error(setErrorInScope.bind($scope));
    }

    const interestsListener = $rootScope.$on('userInterestsUpdated', $scope.updateUserInterests);

    $scope.$on("$destroy", interestsListener);
});


app.directive('recipeRightColumnSummary', function($controller, $stateParams, $state, $rootScope,
        DataikuAPI, Dialogs, CreateModalFromTemplate, Logger, RecipeComputablesService, ActiveProjectKey, RecipeRunJobService, ActivityIndicator, WT1) {
    return {
        templateUrl: '/templates/recipes/right-column-summary.html',

        link: function(scope, element, attrs) {

            $controller('_TaggableObjectsMassActions', {$scope: scope});
            $controller('_TaggableObjectsCapabilities', {$scope: scope});

            var enrichSelectedObject = function (selObj, recipe) {
                selObj.tags = recipe.tags; // for apply-tagging modal
            }

            scope.refreshData = function() {
                DataikuAPI.flow.recipes.getFullInfo(scope.selection.selectedObject.projectKey, scope.selection.selectedObject.name).success(function(data){
                    scope.recipeData = data;
                    scope.recipe = data.recipe;
                    if (/^\s*\{/.test(data.script || '')) {
                        try { // payload may not be JSON; if it is we only need backendType
                            scope.payload = { backendType: JSON.parse(data.script).backendType };
                        } catch (ignored) {}
                    }

                    enrichSelectedObject(scope.selection.selectedObject, scope.recipe);

                    if (scope.selection.selectedObject.continuous) {
                        // update the build indicator on the flow
                        let selObj = scope.selection.selectedObject;
                        let ps = data.continuousState;
                        // the only change that could not be on the flow is when the activity fails
                        if (!selObj.continuousActivityDone) {
                            if (ps && ps.mainLoopState != null && ps.mainLoopState.futureInfo != null && ps.desiredState == "STARTED" && ps.mainLoopState.futureInfo.hasResult) {
                                selObj.continuousActivityDone = true;
                                $rootScope.$broadcast("graphRendered");
                            }
                        }
                    }
                    scope.recipe.zone = (scope.selection.selectedObject.usedByZones || [])[0] || scope.selection.selectedObject.ownerZone;
                }).error(setErrorInScope.bind(scope));
            };

            scope.$on('taggableObjectTagsChanged', () => scope.refreshData());

            /* Auto save when summary is modified */
            scope.$on("objectSummaryEdited", function(){
                DataikuAPI.flow.recipes.save(ActiveProjectKey.get(), scope.recipe, { summaryOnly: true })
                    .success(() => ActivityIndicator.success("Saved"))
                    .error(setErrorInScope.bind(scope));
            });

            scope.$watch("selection.selectedObject", function(nv, ov) {
                if (!nv) return;
                scope.recipeData = {recipe: nv, timeline: {}}; // display temporary (incomplete) data
                if(scope.selection.confirmedItem != scope.selection.selectedObject) {
                    scope.recipe = null;
                }
                scope.recipeType = nv.recipeType || nv.type;
            });

            scope.$watch("selection.confirmedItem", function(nv, ov) {
                if (!nv) {
                    return;
                }
                scope.refreshData();
            });

            scope.saveCustomFields = function(newCustomFields) {
                WT1.event('custom-fields-save', {objectType: 'RECIPE'});
                const oldCustomFields = angular.copy(scope.recipe.customFields);
                scope.recipe.customFields = newCustomFields;
                return DataikuAPI.flow.recipes.save(ActiveProjectKey.get(), scope.recipe, { summaryOnly: true })
                    .success(() => $rootScope.$broadcast('customFieldsSaved', TopNav.getItem(), scope.recipe.customFields))
                    .error((data, status, headers, config, statusText, xhrStatus) => {
                        scope.recipe.customFields = oldCustomFields;
                        setErrorInScope.bind(scope)(data, status, headers, config, statusText, xhrStatus);
                    });
            };

            scope.editCustomFields = function() {
                if (!scope.recipe) {
                    return;
                }
                let modalScope = angular.extend(scope, {objectType: 'RECIPE', objectName: scope.recipe.name, objectCustomFields: scope.recipe.customFields});
                CreateModalFromTemplate("/templates/taggable-objects/custom-fields-edit-modal.html", modalScope).then(function(customFields) {
                    scope.saveCustomFields(customFields);
                });
            };

            scope.buildOutput = function() {
                RecipeComputablesService.getComputablesMap(scope.recipe, scope).then(function(computablesMap){
                    const outputRef = RecipeRunJobService.getOutputAndPartitioning(scope.recipe, computablesMap).output.ref;
                    if (computablesMap && computablesMap[outputRef]) {
                        switch(computablesMap[outputRef].type) {
                            case 'DATASET':
                                DataikuAPI.datasets.get(scope.recipe.projectKey, outputRef, ActiveProjectKey.get())
                                .success(function(dataset) {
                                    CreateModalFromTemplate("/templates/datasets/build-dataset-modal.html", scope, "BuildDatasetController", function(modalScope) {
                                        modalScope.dataset = dataset;
                                    }, "build-dataset-modal");
                                }).error(setErrorInScope.bind(scope));
                                break;
                            case 'SAVED_MODEL':
                                CreateModalFromTemplate("/templates/savedmodels/build-model-modal.html", scope, "BuildSavedModelController", function(modalScope) {
                                    modalScope.modelId = outputRef;
                                });
                                break;
                            case 'MANAGED_FOLDER':
                                    CreateModalFromTemplate("/templates/managedfolder/build-folder-modal.html", scope, "BuildManagedFolderController", function(modalScope) {
                                    modalScope.odbId = outputRef;
                                });
                                break;
                            case 'MODEL_EVALUATION_STORE':
                                    CreateModalFromTemplate("/templates/modelevaluationstores/build-store-modal.html", scope, "BuildModelEvaluationStoreController", function(modalScope) {
                                    modalScope.mesId = outputRef;
                                });
                                break;
                            case 'STREAMING_ENDPOINT':
                                    CreateModalFromTemplate("/templates/streaming-endpoints/build-streaming-endpoint-modal.html", scope, "BuildStreamingEndpointController", function(modalScope) {
                                    modalScope.streamingEndpointId = outputRef;
                                });
                                break;
                        }
                    }
                });
            };

            scope.startContinuous = function() {
                WT1.event("start-continuous", {from:'recipe'})
                CreateModalFromTemplate("/templates/continuous-activities/start-continuous-activity-modal.html", scope, "StartContinuousActivityController", function(newScope) {
                    newScope.recipeId = scope.recipe.name;
                }).then(function(loopParams) {
                    DataikuAPI.continuousActivities.start($stateParams.projectKey, scope.recipe.name, loopParams).success(function(data){
                        scope.refreshData();
                    }).error(setErrorInScope.bind(scope));
                });
            }
            scope.stopContinuous = function(){
                WT1.event("stop-continuous", {from:'recipe'})
                DataikuAPI.continuousActivities.stop($stateParams.projectKey, scope.recipe.name).success(function(data){
                    scope.refreshData();
                }).error(setErrorInScope.bind(scope));
            }
    
            scope.goToCurrentRun = function() {
                let recipeState = scope.recipeData.continuousState || {};
                let mainLoopState = recipeState.mainLoopState || {};
                $state.go("projects.project.continuous-activities.continuous-activity.runs", {continuousActivityId: recipeState.recipeId, runId: mainLoopState.runId, attemptId: mainLoopState.attemptId});
            };

        }
    }
});


app.controller("RecipeDetailsController", function ($scope, $rootScope, $filter, $state, StateUtils) {
    $scope.StateUtils = StateUtils;
    $scope.getObjectIcon = function(object) {
        switch(object.type) {
            case 'SAVED_MODEL':             return 'icon-machine_learning_regression saved-model';
            case 'MANAGED_FOLDER':          return 'icon-folder-open managed-folder';
            case 'MODEL_EVALUATION_STORE':  return 'icon-model-evaluation-store';
            default:                        return $filter('datasetTypeToIcon')(object.type) + ' dataset';
        }
    };

    $scope.getObjectLink = function(object) {
        switch(object.type) {
            case 'SAVED_MODEL':             return StateUtils.href.savedModel(object.id, object.projectKey);
            case 'MANAGED_FOLDER':          return StateUtils.href.managedFolder(object.id, object.projectKey);
            case 'MODEL_EVALUATION_STORE':  return StateUtils.href.modelEvaluationStore(object.id, object.projectKey);
            default:                        return StateUtils.href.dataset(object.id);
        }
    };

    $scope.getObjectType = function(object) {
        switch(object.type) {
            case 'SAVED_MODEL':     return 'SAVED_MODEL';
            case 'MANAGED_FOLDER':  return 'MANAGED_FOLDER';
            default:                return 'DATASET_CONTENT';
        }
    };

    $scope.isOnRecipeObjectPage = function() {
        return $state.includes('projects.project.recipes.recipe');
    }

    $scope.getFlatAggregates = function(values) {
        if (!values) {
            return [];
        }
        var aggregates = [];
        values.forEach(function(value) {
            if (value.customExpr) {
                aggregates.push(value);
            } else {
                angular.forEach(value, function(x, agg) {
                    if (agg.startsWith("__")) return; // temp field
                    if (x === true) {
                        aggregates.push({agg:agg, column:value.column, type:value.type});
                    }
                });
            }
        });
        return aggregates;
    }
});


/**
 * The summary of recipes is managed a bit differently than all other objects.
 * For a recipe, the tabs that are available are depending on the recipe. That's true
 * even for the summary tab (all xxx-recipe-editor.html files include the summary tab)
 *
 * Thus, when we enter this summary controller, we already have the recipe, and we'll
 * reuse the regular save mechanism.
 *
 * Timelines and interests are fetched manually. Also, there is no specific state for the
 * summary tab
 */
app.controller("RecipeSummaryController", function($scope, Assert, DataikuAPI, $rootScope, $stateParams, Logger){
    Assert.inScope($scope, 'recipe');

    // Interests are fetched separately since we already have the recipe at that point
    DataikuAPI.interests.getForObject($rootScope.appConfig.login, "RECIPE", $stateParams.projectKey, $stateParams.recipeName)
        .success(function(data){
            $scope.objectInterest = data;
        })
        .error(setErrorInScope.bind($scope));

    /* Auto save when modified */
    $scope.$on("objectSummaryEdited", function(){
        Logger.info("Recipe summary edited");
        $scope.saveRecipe();
    });

    $scope.$on('customFieldsSummaryEdited', function(event, customFields) {
        $scope.saveCustomFields(customFields);
    });
});

app.controller("RecipeEditorController",
    function ($scope, $rootScope, $timeout, $stateParams, $filter, $location, $state, $q,
    Assert, BigDataService, DataikuAPI, Dialogs, WT1, FutureProgressModal,
    TopNav, PartitionDeps, DKUtils, Logger, HistoryService,
    CreateModalFromTemplate, AnyLoc, JobDefinitionComputer, RecipeComputablesService, RecipesUtils,
    RecipeRunJobService, PartitionSelection, RecipeDescService, InfoMessagesUtils, StateUtils, GraphZoomTrackerService,
    DatasetUtils) {

    $scope.InfoMessagesUtils = InfoMessagesUtils;

    let contextProjectKey = $scope.context && $scope.context.projectKey ? $scope.context.projectKey:$stateParams.projectKey;
	function main(){
        /* Init scope */
        $scope.uiState = {editSummary:false};
        $scope.startedJob = {};
        $scope.recipe = null;
        $scope.recipeStatus = null;
        $scope.payloadRequired = false; // override for recipe specific recipe types. Avoids to get-status before the payload is ready
        $scope.script = {};
        $scope.creation = false;
        $scope.recipeName = { "name" : $scope.$state.params.recipeName };
        $scope.projectKey = $stateParams.projectKey;
        $scope.hooks = $scope.hooks || {};
        GraphZoomTrackerService.setFocusItemByName("recipe", $scope.recipeName.name);
        $scope.RecipesUtils = RecipesUtils

        // Validation context
        $scope.valCtx = {};

        const tabToSelect = StateUtils.defaultTab("settings");
        TopNav.setLocation(TopNav.TOP_FLOW, "recipes", TopNav.TABS_RECIPE, tabToSelect);
        TopNav.setItem(TopNav.ITEM_RECIPE, $stateParams.recipeName);

        $scope.validations = [
            function(){
                return $scope.renaming.recipe_name.$valid && $scope.recipeName.name.length;
            }
        ];

        $scope.PartitionDeps = PartitionDeps;
        addDatasetUniquenessCheck($scope, DataikuAPI, $stateParams.projectKey);

        // DO NOT INITIALIZE IT, IT HELPS CATCH ERRORS
        $scope.computablesMap = null;
        $scope.$broadcast('computablesMapChanged');

        Assert.trueish($scope.recipeName.name, 'no recipe name');

        DataikuAPI.flow.recipes.generic.getVariables($stateParams.projectKey).success(function(data) {
            $scope.recipeVariables = data;
        }).error(setErrorInScope.bind($scope));

        DataikuAPI.flow.recipes.getWithInlineScript($stateParams.projectKey, $scope.recipeName.name).success(function(data) {
            $scope.recipe = data.recipe;
            $scope.script.data = data.script;
            $scope.origRecipe = angular.copy($scope.recipe);
            $scope.origScript = angular.copy($scope.script);

            $scope.recipeDesc = RecipeDescService.getDescriptor($scope.recipe.type);

            TopNav.setItem(TopNav.ITEM_RECIPE, data.recipe.name, {
                recipeType :data.recipe.type,
                name : data.recipe.name,
                inputs: data.recipe.inputs,
                outputs: data.recipe.outputs
            });

            RecipeComputablesService.getComputablesMap($scope.recipe, $scope).then(function(map){
                $scope.setComputablesMap(map);
                DatasetUtils.updateRecipeComputables($scope, $scope.recipe, $stateParams.projectKey, contextProjectKey)
                    .then(_ => {
                                    $scope.onload();
                                    $scope.$broadcast('computablesMapChanged'); // because the schema are there now (they weren't when setComputablesMap() was called)
                                });
            });
            DataikuAPI.flow.zones.getZoneId($stateParams.projectKey, {id: data.recipe.name, type: "RECIPE", projectKey: data.recipe.projectKey}).success(zone => {
                if (zone) {
                    // Put it in zone so the io:getDatasetCreationSettings can find it
                    // and we can target more recipes
                    $scope.zone = zone.id;
                }
            });

        }).error(function(){
            HistoryService.notifyRemoved({
                type: "RECIPE",
                id: $scope.recipeName.name,
                projectKey: $stateParams.projectKey
            });
            setErrorInScope.apply($scope, arguments);
        });

        TopNav.setTab(tabToSelect);
    }
    main();

    function extractWT1EventParams(recipe, payload) {
        if (recipe.type === "prediction_scoring") {
            const recipeParams = JSON.parse(payload.data);
            let eventParams = {
                filterInputColumns: recipeParams.filterInputColumns,
                forceOriginalEngine: recipeParams.forceOriginalEngine,
                outputExplanations: recipeParams.outputExplanations,
                outputProbaPercentiles: recipeParams.outputProbaPercentiles,
                outputProbabilities: recipeParams.outputProbabilities,
            };
            if (eventParams.outputExplanations) {
                eventParams = {
                    individualExplMethod: recipeParams.individualExplanationParams.method,
                    individualExplCount: recipeParams.individualExplanationParams.nbExplanations,
                    ... eventParams
                };
            }
            return eventParams;
        } else {
            return {};
        }
    }

    $scope.recipeWT1Event = function(type, params) {
        if (params == null) params = {};
        params.recipeId = ($scope.recipeName && $scope.recipeName.name) ? $scope.recipeName.name.dkuHashCode() : "unknown";
        params.recipeType = ($scope.recipe ? $scope.recipe.type : "unknown");
        params.creation = $scope.creation;
        if ($scope.recipe && $scope.recipe.type) {
            const extractParams = extractWT1EventParams($scope.recipe, $scope.script);
            params = { ...params, ...extractParams };
        }
        WT1.event(type, params);
    };

    $scope.editThisRecipeInNotebook = function() {
        var editInNotebook = function() {
            DataikuAPI.flow.recipes.editInNotebook($stateParams.projectKey, $stateParams.recipeName, $scope.recipe.params.envSelection, $scope.recipe.params.containerSelection).success(function(data) {
                StateUtils.go.jupyterNotebook(data.id, $stateParams.projectKey);
            }).error(setErrorInScope.bind($scope));
        };
        $scope.saveRecipeIfPossible().then(function() {
            DataikuAPI.flow.recipes.checkNotebookEdition($stateParams.projectKey, $stateParams.recipeName).success(function(data) {
                if (!data || data.conflict !== true || !data.notebook) {
                    editInNotebook();
                } else {
                    Dialogs.openEditInNotebookConflictDialog($scope).then(
                        function(resolutionMethod) {
                            if(resolutionMethod == 'erase') {
                                editInNotebook();
                            } else if(resolutionMethod == 'ignore') {
                                StateUtils.go.jupyterNotebook(data.notebook, $stateParams.projectKey);
                            }
                        }
                    );
                }
            }).error(setErrorInScope.bind($scope));
        }).catch(setErrorInScope.bind($scope));
    };

    $scope.saveCustomFields = function(newCustomFields) {
        WT1.event('custom-fields-save', {objectType: 'RECIPE'});
        let oldCustomFields = angular.copy($scope.recipe.customFields);
        $scope.recipe.customFields = newCustomFields;
        return $scope.hooks.save().then(function() {
                $rootScope.$broadcast('customFieldsSaved', TopNav.getItem(), $scope.recipe.customFields);
            }, function() {
                $scope.recipe.customFields = oldCustomFields;
            });
    };

    $scope.editCustomFields = function() {
        if (!$scope.recipe) {
            return;
        }
        let modalScope = angular.extend($scope, {objectType: 'RECIPE', objectName: $scope.recipe.name, objectCustomFields: $scope.recipe.customFields});
        CreateModalFromTemplate("/templates/taggable-objects/custom-fields-edit-modal.html", modalScope).then(function(customFields) {
            $scope.saveCustomFields(customFields);
        });
    };

    $scope.renameRecipe = function(){
        if ($scope.hooks.recipeIsDirty()) {
            Dialogs.error($scope, "Save the recipe", "You must save the recipe before renaming it");
            return;
        }
        CreateModalFromTemplate("/templates/recipes/rename-recipe-box.html", $scope, null, function(newScope){
            newScope.recipeName = $stateParams.recipeName;
            newScope.uiState = {
                step : "input"
            };

            newScope.go = function(){
                DataikuAPI.flow.recipes.rename($stateParams.projectKey, $stateParams.recipeName, newScope.uiState.newName).success(function() {
                    HistoryService.notifyRenamed({
                        type: "RECIPE",
                        id: $stateParams.recipeName,
                        projectKey: $stateParams.projectKey
                    }, newScope.uiState.newName);
                    newScope.dismiss();
                    newScope.$emit("recipesListChanged");
                    $state.transitionTo($state.current, { projectKey : $stateParams.projectKey, recipeName : newScope.uiState.newName });
                }).error(setErrorInScope.bind(newScope));
            }
        });
    };

    $scope.gotoLine = function(cm, line) {
        if(cm && line>0) {
            var pos = {ch:0,line:line-1};
            cm.scrollIntoView(pos);
            cm.setCursor(pos);
            cm.focus();
        }
    };

    $scope.specificControllerLoadedDeferred = $q.defer();

    /* Method called once recipe is loaded */
    var onloadcalled = false;
    $scope.onload = function() {
        Assert.inScope($scope, 'recipe');
        Assert.trueish(!onloadcalled, 'already loaded');
        onloadcalled = true;
        $scope.fixupPartitionDeps();

        $scope.recipeWT1Event("recipe-open");

        // TODO: Check if still needed
        $scope.ioFilter = {};

        $scope.testRun = {
            build_partitions: {},
            runMode: "NON_RECURSIVE_FORCED_BUILD"
        };

        /* Synchronize the definition of build_partitions for the test run
         * with the partitioning schema of the first partitioned output */
        $scope.$watch("recipe.outputs", function(nv, ov) {
            if (nv != null) {
                clear($scope.testRun.build_partitions);
                DatasetUtils.updateRecipeComputables($scope, $scope.recipe, $stateParams.projectKey, contextProjectKey)
                    .then(_ => {
                        const definingOutputPartitioning = RecipeRunJobService.getOutputAndPartitioning($scope.recipe, $scope.computablesMap).partitioning;
                        if (definingOutputPartitioning && definingOutputPartitioning.dimensions.length) {
                            $scope.outputPartitioning = definingOutputPartitioning;
                            $scope.testRun.build_partitions = PartitionSelection.getBuildPartitions($scope.outputPartitioning);
                        } else {
                            $scope.outputPartitioning = { dimensions: [] };
                        }
                    });
            } else {
                $scope.testRun.build_partitions = null;
            }
        }, true);

        $scope.fixupPartitionDeps();

        /* When the specific recipe controller has finished loading AND we have
         * the computables map, then we call its own onload hook */
        $scope.specificControllerLoadedDeferred.promise.then(function() {
            if ($scope.hooks && $scope.hooks.onRecipeLoaded){
                $scope.hooks.onRecipeLoaded();
            }
        });
    };

    $scope.hooks.getRecipeSerialized = function(){
        var recipeSerialized = angular.copy($scope.recipe);
        PartitionDeps.prepareRecipeForSerialize(recipeSerialized);
        return recipeSerialized;
    };

    $scope.hooks.resetScope = function() {
        clear($scope.startedJob);
        clear($scope.valCtx);
    };

    //Override it to return a string representing the payload
    $scope.hooks.getPayloadData = function() {};

    /* ***************************** Inputs/Outputs *************************** */

    $scope.hasAllRequiredOutputs = function() {
        if (!$scope.recipe || !$scope.recipe.outputs) {
            return false;
        }
        var out = $scope.recipe.outputs;
        //TODO implement for any role
        if(out.main) {
            return !!(out.main.items && out.main.items.length);
        }
        return true;//Other roles: don't know
    };

    $scope.hasPartitionedOutput = function() {
        return $scope.getOutputDimensions().length > 0;
    };

    $scope.hasInvalidPartitionSelection = function() {
        return $scope.getOutputDimensions().some((dimension) => {
            return !$scope.testRun || $scope.testRun.build_partitions[dimension.name] === void 0 || $scope.testRun.build_partitions[dimension.name] === "";
        });
    };

    // This method should be called each time inputs or outputs are modified.
    $scope.fixupPartitionDeps = function(){
        if (!$scope.recipe || !$scope.computablesMap) return;
        var ret = PartitionDeps.fixup($scope.recipe, $scope.computablesMap);
        $scope.outputDimensions = ret[0];
        $scope.outputDimensionsWithNow = ret[1];
    };

    $scope.testPDep = function(inputRef, pdep) {
        PartitionDeps.test($scope.recipe, inputRef, pdep, $scope);
    };

    $scope.refreshDatasetInComputablesMap = function(dataset) {
        var found = null;
        $.each($scope.computablesMap, function(smartName, computable) {
            if (computable.projectKey == dataset.projectKey && computable.name == dataset.name)
                found = computable;
        });
        // the dataset has to be in the computablesMap, otherwise that means it's not even shown in the dataset left pane
        Assert.trueish(found);
        found.dataset = dataset;
    };

    /* Simple recipes that don't want to manage themselves inputs and outputs
     * should enable auto fixup */
    $scope.enableAutoFixup = function() {
        $scope.$watch("recipe.inputs", function() {
            DatasetUtils.updateRecipeComputables($scope, $scope.recipe, $stateParams.projectKey, contextProjectKey)
                    .then(_ => $scope.fixupPartitionDeps());
        }, true);
        $scope.$watch("recipe.outputs", function() {
            DatasetUtils.updateRecipeComputables($scope, $scope.recipe, $stateParams.projectKey, contextProjectKey)
                    .then(_ => $scope.fixupPartitionDeps());
        }, true);
    };

    $scope.$watch("recipe.inputs", function(nv, ov) {
        if (!nv) return;
        if (!$scope.outputDimensions) return;
        DatasetUtils.updateRecipeComputables($scope, $scope.recipe, $stateParams.projectKey, contextProjectKey)
                    .then(_ => {
            RecipesUtils.getFlatInputsList($scope.recipe).forEach(function(input) {
                if (!input.deps) return;
                input.deps.forEach(function(pdep){
                    PartitionDeps.autocomplete(pdep, $scope.outputDimensions, $scope.outputDimensionsWithNow);
                });
            });
        });
    }, true);

    $scope.$watch("recipe.outputs", function() {
        DatasetUtils.updateRecipeComputables($scope, $scope.recipe, $stateParams.projectKey, contextProjectKey);
    }, true);

    $scope.setComputablesMap = function(map) {
        $scope.computablesMap = map;
        $scope.$broadcast('computablesMapChanged');
    };

    $scope.getOutputDimensions = function(){
        if (!$scope.recipe || !$scope.computablesMap) return [];
        return RecipeRunJobService.getOutputDimensions($scope.recipe, $scope.computablesMap);
    };

    $scope.hasAnyPartitioning = function(){
        if (!$scope.recipe || !$scope.computablesMap) return false;
        return RecipesUtils.hasAnyPartitioning($scope.recipe, $scope.computablesMap);
    };


    /* ***************************** Save *************************** */

    $scope.hooks.save = function() {
        return $scope.baseSave($scope.hooks.getRecipeSerialized(), $scope.script ? $scope.script.data : null);
    };
    $scope.hooks.origSaveHook = $scope.hooks.save;

    $scope.baseSave = function(recipeSerialized, payloadData){
        $scope.recipeWT1Event("recipe-save");
        return DataikuAPI.flow.recipes.save($stateParams.projectKey, recipeSerialized,
            payloadData, $scope.currentSaveCommitMessage).success(function(savedRecipe){
            var newVersionTag = savedRecipe.versionTag;
            $scope.origRecipe = angular.copy($scope.recipe);
            $scope.origScript = angular.copy($scope.script);
            $scope.recipe.versionTag = newVersionTag;
            $scope.origRecipe.versionTag = newVersionTag;
            $scope.creation = false;
            $scope.currentSaveCommitMessage = null;
        }).error(setErrorInScope.bind($scope));
    };

    $scope.canSave = function(){
        if (!$scope.creation) return true;
        return $scope.recipeName.name && $scope.recipeName.name.length;
    };

    $scope.hooks.recipeIsDirty = function() {
        if (!$scope.recipe) return false;
        if ($scope.creation) {
            return true;
        } else {
            // compare after fixing up the partition deps, otherwise their change is missed by the dirtyness tracking
            var recipeSerialized = angular.copy($scope.recipe);
            PartitionDeps.prepareRecipeForSerialize(recipeSerialized);
            var origRecipeSerialized = angular.copy($scope.origRecipe);
            PartitionDeps.prepareRecipeForSerialize(origRecipeSerialized, true);

            var dirty = !angular.equals(recipeSerialized, origRecipeSerialized);
            if ($scope.script) {
                dirty = dirty || !angular.equals($scope.origScript, $scope.script);
            }
            return dirty;
        }
    };

    //Don't link to the default recipeIsDirty is function, get the actual one that may be defined later
    checkChangesBeforeLeaving($scope, (function(_scope){return function() {return _scope.hooks.recipeIsDirty(); }})($scope));

    $scope.saveRecipe = function(commitMessage){
        var deferred = $q.defer();

        var saveAfterConflictCheck = function() {
            $scope.currentSaveCommitMessage = commitMessage;
            $scope.hooks.save().then(function() {
                deferred.resolve('recipe saved');
            },function() {
                deferred.reject();
            });
        };

        DataikuAPI.flow.recipes.checkSaveConflict($stateParams.projectKey, $stateParams.recipeName,$scope.recipe).success(function(conflictResult) {
            if(!conflictResult.canBeSaved) {
                Dialogs.openConflictDialog($scope,conflictResult).then(
                        function(resolutionMethod) {
                            if(resolutionMethod == 'erase') {
                                saveAfterConflictCheck();
                            } else if(resolutionMethod == 'ignore') {
                                deferred.reject();
                                DKUtils.reloadState();
                            }
                        }
                );
            } else {
                saveAfterConflictCheck();
            }
        }).error(setErrorInScope.bind($scope));
        return deferred.promise;
    };

    $scope.saveRecipeIfPossible = function(){
        if ($scope.canSave()) {
            return $scope.saveRecipe();
        }
        return $q.defer().promise;
    };

    $scope.displayAllMessagesInModal = function(){
        Dialogs.infoMessagesDisplayOnly($scope, "Recipe validation",
            $scope.valCtx.validationResult.allMessagesForFrontend);
    };

    /* ***************************** Execution *************************** */

    $scope.buildModes = [
        ["NON_RECURSIVE_FORCED_BUILD", "Run only this recipe"],
        ["RECURSIVE_BUILD", "Build required dependent datasets"],
        ["RECURSIVE_FORCED_BUILD", "Force-rebuild all dependent datasets"],
        ["RECURSIVE_MISSING_ONLY_BUILD", "Build missing dependencies and run this recipe"]
    ];

    $scope.jobCheckTimer = null;

    $scope.hooks.preRunValidate = function() {
        var deferred = $q.defer();
        DataikuAPI.flow.recipes.generic.validate($stateParams.projectKey,
            $scope.hooks.getRecipeSerialized()).success(function(data) {
            deferred.resolve(data);
        }).error(function(a,b,c) {
            setErrorInScope.bind($scope)(a,b,c);
            deferred.reject("Validation failed");
        });
        return deferred.promise;
    };

    $scope.editRunOptions = function(){
        CreateModalFromTemplate("/templates/recipes/recipe-run-options-modal.html", $scope);
    };

    $scope.waitForEndOfStartedJob = function() {
        Logger.info("Wait for end of job:", $scope.startedJob.jobId);
        DataikuAPI.flow.jobs.getJobStatus($stateParams.projectKey, $scope.startedJob.jobId).success(function(data) {
            $scope.startedJob.jobStatus = data;
            data.totalWarningsCount = 0;
            if (data.logTail != null) {
                data.logTailHTML = smartLogTailToHTML(data.logTail, false);
            }
            for (var actId in data.baseStatus.activities) {
                var activity = data.baseStatus.activities[actId];
                if (activity.warnings) {
                    data.totalWarningsCount += activity.warnings.totalCount;
                }
            }
            if (data.baseStatus.state != "DONE" && data.baseStatus.state != "ABORTED" &&
                data.baseStatus.state != "FAILED") {
                $scope.jobCheckTimer = $timeout($scope.waitForEndOfStartedJob, 2000);
            } else {
                $scope.recipeWT1Event("recipe-run-finished", {
                    state : data.baseStatus.state
                });
            }
            $timeout(function() {$rootScope.$broadcast("reflow");},50);
        }).error(setErrorInScope.bind($scope));
    };

    $scope.waitForEndOfStartedContinuousActivity = function() {
        Logger.info("Wait for end of continuous activity:", $scope.startedJob.jobId);
        DataikuAPI.continuousActivities.getState($stateParams.projectKey, $stateParams.recipeName).success(function(data) {
            $scope.startedJob.persistent = data;
            $scope.startedJob.current = data.mainLoopState;
            if ($scope.startedJob.current && $scope.startedJob.current.futureInfo && ($scope.startedJob.current.futureInfo.alive || !$scope.startedJob.current.futureInfo.hasResult)) {
                $scope.jobCheckTimer = $timeout($scope.waitForEndOfStartedContinuousActivity, 2000);
            } else {
                // not running anymore
            }
            $timeout(function() {$rootScope.$broadcast("reflow");},50);
        }).error(setErrorInScope.bind($scope));

    };

    $scope.discardStartedJob = function(){
        clear($scope.startedJob);
        if($scope.jobCheckTimer) {
           $timeout.cancel($scope.jobCheckTimer);
           $scope.jobCheckTimer = null;
           $timeout(function() {
               $rootScope.$broadcast('redrawFatTable');
           });
        }
    };

    $scope.abortSingleRecipeExecution = function() {
        Dialogs.confirm($scope, 'Aborting a job','Are you sure you want to abort this job?').then(function() {
            DataikuAPI.flow.jobs.abort($stateParams.projectKey,$scope.startedJob.jobId).success(function(data) {
                $scope.discardStartedJob();
            }).error(function(e) {
                // swallow this error
                Logger.error(e);
            });
            $scope.recipeWT1Event("recipe-running-abort");
        });
    };

    $scope.isJobRunning = function() { return RecipeRunJobService.isRunning($scope.startedJob); };

    $scope.isContinuousActivityRunning = function() { return $scope.startedJob && $scope.startedJob.jobId && $scope.startedJob.current && $scope.startedJob.current.futureInfo && ($scope.startedJob.current.futureInfo.alive || !$scope.startedJob.current.futureInfo.hasResult); };

    //TODO @recipes32 this is a little flawed, there is a short moment between starting and running...
    $scope.isJobRunningOrStarting = function() {
        return $scope.isJobRunning() || !!$scope.startedJob.starting;
    };
    $scope.isContinuousActivityRunningOrStarting = function() {
        return $scope.isContinuousActivityRunning() || !!$scope.startedJob.starting;
    };

    $scope.startSingleRecipeExecution = function(forced) {
        $scope.hooks.resetScope();
        $scope.startedJob.starting = true;

        function doIt() {
            RecipeRunJobService.run($scope.recipe, $scope.computablesMap, $scope.testRun, $scope.startedJob, $scope).then(function(){
                $scope.waitForEndOfStartedJob();
            });
        }

        $scope.saveRecipe().then(function() {
            if (forced) {
                $scope.recipeWT1Event("recipe-run-start-forced");
                doIt();
            } else if ($scope.recipe.params && $scope.recipe.params.skipPrerunValidate) {
                $scope.recipeWT1Event("recipe-run-start-no-validation");
                doIt();
            } else {
                $scope.recipeWT1Event("recipe-run-start");
                $scope.hooks.preRunValidate().then(function(validationResult) {
                    if (validationResult.ok == true || validationResult.error == false || validationResult.allMessagesForFrontend && !validationResult.allMessagesForFrontend.error) {
                        $scope.recipeWT1Event("recipe-run-start-validated");
                        doIt();
                    } else {
                        $scope.startedJob.starting = false;
                        $scope.valCtx.preRunValidationError = validationResult;
                        $scope.recipeWT1Event("recipe-run-start-blocked", {
                            firstError : validationResult.allMessagesForFrontend && validationResult.allMessagesForFrontend.messages.length ? validationResult.allMessagesForFrontend.messages[0].message : "unknown"
                        });
                    }
                }, function(error) {
                    $scope.startedJob.starting = false;
                });
            }
        }, function(error) {
            $scope.startedJob.starting = false;
        });
    };


    $scope.startContinuousActivity = function(forced) {
        $scope.hooks.resetScope();
        $scope.startedJob.starting = true;

        function doIt() {
            const onceLoopParams = { abortAfterCrashes: 0 };
            DataikuAPI.continuousActivities.start($stateParams.projectKey, $stateParams.recipeName, onceLoopParams).success(function(data){
                FutureProgressModal.show($scope, data, "Starting continuous recipe...").then(function(data) {
                    $scope.startedJob.jobId = data.futureId;
                    $scope.waitForEndOfStartedContinuousActivity();
                });
            }).error(setErrorInScope.bind($scope));
        }

        $scope.saveRecipe().then(function() {
            if (forced) {
                $scope.recipeWT1Event("recipe-run-start-forced");
                doIt();
            } else if ($scope.recipe.params && $scope.recipe.params.skipPrerunValidate) {
                $scope.recipeWT1Event("recipe-run-start-no-validation");
                doIt();
            } else {
                $scope.recipeWT1Event("recipe-run-start");
                $scope.hooks.preRunValidate().then(function(validationResult) {
                    if (validationResult.ok == true || validationResult.error == false || !validationResult.allMessagesForFrontend.error) {
                        $scope.recipeWT1Event("recipe-run-start-validated");
                        doIt();
                    } else {
                        $scope.startedJob.starting = false;
                        $scope.valCtx.preRunValidationError = validationResult;
                        $scope.recipeWT1Event("recipe-run-start-blocked", {
                            firstError : validationResult.allMessagesForFrontend && validationResult.allMessagesForFrontend.messages.length ? validationResult.allMessagesForFrontend.messages[0].message : "unknown"
                        });
                    }
                }, function(error) {
                    $scope.startedJob.starting = false;
                });
            }
        }, function(error) {
            $scope.startedJob.starting = false;
        });
    };

    $scope.stopContinuousActivity = function(){
        $scope.continuousActivityState = null;
        DataikuAPI.continuousActivities.stop($stateParams.projectKey, $stateParams.recipeName).success(function(data){
            // TODO - start displaying some useful stuff...
        }).error(setErrorInScope.bind($scope));
    }
    
    $scope.openContinuousActivity = function() {
        $state.go("projects.project.continuous-activities.continuous-activity.runs", {continuousActivityId: $scope.recipe.name});
    }; 

    // Stop the timer at exit
    $scope.$on("$destroy",function() {
       if($scope.jobCheckTimer) {
           $timeout.cancel($scope.jobCheckTimer);
           $scope.jobCheckTimer = null;
       }
       Mousetrap.unbind("@ r u n");
       $scope.hooks = null;
    });

    Mousetrap.bind("@ r u n", function(){
        $scope.startSingleRecipeExecution();
    });

});


app.controller("_RecipeWithEngineBehavior", function($rootScope, $scope, $q, $stateParams, DataikuAPI, Dialogs, PartitionDeps, DKUtils, Logger, CreateModalFromTemplate) {
    $scope.setRecipeStatus = function(data) {
        $scope.recipeStatus = data;

        const engineType = $scope.recipeStatus.selectedEngine.type;
        if (engineType === "SPARK") {
            $scope.anyPipelineTypeEnabled = function() {
                return $rootScope.projectSummary.sparkPipelinesEnabled;
            };
        } else if (engineType === "SQL") {
            $scope.anyPipelineTypeEnabled = function() {
                return $rootScope.projectSummary.sqlPipelinesEnabled;
            };
        }
    };

    $scope.hooks.updateRecipeStatus = function() {};

    var requestsInProgress = 0;
    var sendTime = 0;
    var lastSequenceId = 0;
    var lastPromise;
    // to avoid updating multiple times with same data:
    var lastPayload;
    var lastRequestData;
    var lastRecipeSerialized; //(json string)
    $scope.updateRecipeStatusBase = function(forceUpdate, payload, requestSettings) {
        var recipeCopy = angular.copy($scope.recipe);
        /* Complete the partition deps from the "fixedup" version */
        PartitionDeps.prepareRecipeForSerialize(recipeCopy);
        var recipeSerialized = angular.toJson(recipeCopy);
        var requestData = angular.toJson(requestSettings || {});

        if (!forceUpdate
            && lastPayload == payload
            && lastRequestData == requestData
            && lastRecipeSerialized == recipeSerialized) {
            Logger.info("Update recipe: cache hit, not requesting");
            // We already made this request
            return lastPromise;
        }

        lastPayload = payload;
        lastRequestData = requestData;
        lastRecipeSerialized = recipeSerialized;
        lastSequenceId++;

        requestsInProgress++;
        sendTime = new Date().getTime();
        $scope.recipeStateUpdateInProgress = true;
        lastPromise = DataikuAPI.flow.recipes.generic.getStatus(recipeCopy, payload, lastSequenceId, requestSettings)
            .catch(function(response) {
                setErrorInScope.bind($scope)(response.data, response.status, response.headers);
                //we can't get the sequenceId so wait for all answers to mark as idle
                if (requestsInProgress == 1) {
                    $scope.recipeStateUpdateInProgress = false;
                }
                return response;
            })
            .finally(function(){
                requestsInProgress--;
            })
            .then(function(response) {
                if (parseInt(response.data.sequenceId) < lastSequenceId) {
                    return; //Too late!
                }
                if (new Date().getTime() - sendTime > 1500) {
                    aPreviousCallWasLong = true;
                }
                $scope.recipeStateUpdateInProgress = false;
                $scope.setRecipeStatus(response.data);
                return response.data;
            });
        return lastPromise;
    };

    var timeout;
    $scope.updateRecipeStatusLater = function() {
        clearTimeout(timeout);
        timeout = setTimeout(function() {
            $('.CodeMirror').each(function(idx, el){Logger.debug(el.CodeMirror.refresh())});//Make sure codemirror is always refreshed (#6664 in particular)
            if (!$scope.hooks) return;
            $scope.hooks.updateRecipeStatus();
        }, 400);
    };

    /* this function helps the UI have a more appropriate look when status computation is long (small spinner, etc) */
    var aPreviousCallWasLong = false;
    $scope.expectLongRecipeStatusComputation = function() {
        return !$scope.recipeStatus || !$scope.recipeStatus.selectedEngine || aPreviousCallWasLong;
    };

    $scope.canChangeEngine = function() {
        if(!$scope.recipeStatus || !$scope.recipeStatus.engines) {
            return false;
        }
        if ($scope.isJobRunningOrStarting() || $scope.recipeStateUpdateInProgress) {
            return false;
        }
        return true;
    };

    $scope.convertToQueryRecipe = function(type, label) {
        Dialogs.confirm($scope, "Convert to " + label + " recipe",
                        "Converting the recipe to "+label+" will enable you to edit the query, but you will not be able to use the visual editor anymore."+
                        "<br/><strong>This operation is irreversible.</strong>")
        .then(function() {
            var payloadData = $scope.hooks.getPayloadData();
            var recipeSerialized = angular.copy($scope.recipe);
            PartitionDeps.prepareRecipeForSerialize(recipeSerialized);
            $scope.hooks.save().then(function() {
                DataikuAPI.flow.recipes.visual.convert($stateParams.projectKey, recipeSerialized, payloadData, type)
                .success(function(data) {
                    DKUtils.reloadState();
                }).error(setErrorInScope.bind($scope));
            });
        });
    };

    $scope.showSQLModal = function(){
        var newScope = $scope.$new();
        newScope.convert = $scope.convertToQueryRecipe;
        newScope.uiState = {currentTab: 'query'};
        $scope.hooks.updateRecipeStatus(false, true).then(function(){
            // get the latest values, not the ones of before the updatestatus call
        	newScope.query = $scope.recipeStatus.sql;
        	newScope.engine = $scope.recipeStatus.selectedEngine.type;
        	newScope.executionPlan = $scope.recipeStatus.executionPlan;
        	CreateModalFromTemplate("/templates/recipes/fragments/sql-modal.html", newScope);
        });
    };

    var save = $scope.baseSave;
    $scope.baseSave = function() {
        var p = save.apply(this, arguments);
        p.then($scope.updateRecipeStatusLater);
        return p;
    };

    $scope.$watchCollection("recipe.inputs.main.items", () => {
        //call updateRecipeStatus without args!
        Promise.resolve($scope.hooks.updateRecipeStatus()).catch(() => {
            Logger.info("Failed to updateRecipeStatus. Likely due to result of backend call discarded due to multiple parallel calls.");
        });
    });
    $scope.$watchCollection("recipe.outputs.main.items", () => {
        //call updateRecipeStatus without args!
        Promise.resolve($scope.hooks.updateRecipeStatus()).catch(() => {
            Logger.info("Failed to updateRecipeStatus. Likely due to result of backend call discarded due to multiple parallel calls.");
        });
    });

    $scope.$watch("params.engineParams", $scope.updateRecipeStatusLater, true);
});


app.controller("SqlModalController", function($scope, CodeMirrorSettingService) {

    $scope.editorOptions = CodeMirrorSettingService.get('text/x-sql2');

    // if ($scope.engine == 'HIVE' || $scope.engine == 'IMPALA' || $scope.engine == 'SPARK') {
    //     $scope.editorOptions.mode = 'text/x-hive';
    // }
});


app.directive("recipeEnginesPreferenceConfig", function(){
    return {
        restrict: 'A',
        templateUrl : '/templates/recipes/widgets/recipe-engines-preference-config.html',
        scope: {
            model: '='
        }
    }
});


app.service('RecipesEnginesService', function($rootScope, $q, Assert, CreateModalFromTemplate, DataikuAPI) {
    this.startChangeEngine = function(selectedItems) {
        return CreateModalFromTemplate("/templates/recipes/fragments/change-recipes-engines-modal.html", $rootScope, null, function(modalScope) {
            modalScope.selectedRecipes = selectedItems.filter(it => it.type == 'RECIPE');
            modalScope.options = {};
            modalScope.AUTO = '__AUTO__';

            modalScope.getEngineShortStatus = function(engine) {
                for(let msg of engine.messages.messages) {
                    if (msg.severity == "ERROR") {
                        return msg.details;
                    }
                }
                for(let msg of engine.messages.messages) {
                    if (msg.severity == "WARNING") {
                        return msg.details;
                    }
                }
            };

            DataikuAPI.flow.recipes.massActions.startChangeEngines(modalScope.selectedRecipes).success(function(data) {
                Assert.trueish(data.engines, 'no engines');
                modalScope.availableEngines = data.engines;
                modalScope.options.engine = data.currentEngine;
                modalScope.nUnselectableEngines = data.engines.filter(e => !e.isSelectable).length;
                modalScope.messages = data.messages;
            }).error(function(...args) {
                modalScope.fatalError = true;
                setErrorInScope.apply(modalScope, args);
            });


            modalScope.test = function() {
                const deferred = $q.defer();
                delete modalScope.messages;
                delete modalScope.maxSeverity;
                resetErrorInScope(modalScope);
                DataikuAPI.flow.recipes.massActions.testChangeEngines(modalScope.selectedRecipes, modalScope.options.engine).success(function(data) {
                    modalScope.messages = data.messages;
                    modalScope.maxSeverity = data.maxSeverity || 'OK';
                    if (modalScope.maxSeverity != 'OK') {
                        deferred.reject();
                    } else {
                        deferred.resolve(data)
                    }
                }).error(setErrorInScope.bind(modalScope));
                return deferred.promise;
            };

            modalScope.ok = function(force) {
                if (force || modalScope.options.engine == modalScope.AUTO) { //No need to test AUTO
                    performChange();
                } else {
                    modalScope.test().then(performChange);
                }
            };

            function performChange() {
                DataikuAPI.flow.recipes.massActions.changeEngines(modalScope.selectedRecipes, modalScope.options.engine).success(function(data) {
                    modalScope.resolveModal();
                }).error(setErrorInScope.bind(modalScope));
            }
        });
    };
});


app.directive("codeEnvSelectionForm", function(DataikuAPI, $stateParams){
    return {
        restrict: 'A',
        templateUrl : '/templates/recipes/fragments/code-env-selection-form.html',
        scope: {
            envSelection: '=codeEnvSelectionForm',
            inPlugin: '=',
            isStep: '=',
            envLang: '=',
            selectionLabel: '='
        },
        link: function($scope, element, attrs) {
            if ($scope.inPlugin == true) {
                $scope.envModes = [
                    ['USE_BUILTIN_MODE', 'Use plugin environment'],
                    ['EXPLICIT_ENV', 'Select an environment'],
                ];
            } else {
                $scope.envModes = [
                    ['USE_BUILTIN_MODE', 'Use DSS builtin env'],
                    ['INHERIT', 'Inherit project default'],
                    ['EXPLICIT_ENV', 'Select an environment']
                ];
            }

            function setDefaultValue() {
                if (!$scope.envSelection) { // not ready
                    return;
                }
                if ($scope.envSelection.envMode == "EXPLICIT_ENV" && $scope.envSelection.envName == null && $scope.envNamesWithDescs && $scope.envNamesWithDescs.envs && $scope.envNamesWithDescs.envs.length > 0) {
                    $scope.envSelection.envName = $scope.envNamesWithDescs.envs[0].envName;
                }
            }
            $scope.$watch("envSelection.envMode", setDefaultValue);

            $scope.envNamesWithDescs = [];
            console.info("list", $scope);
            DataikuAPI.codeenvs.listNamesWithDefault($scope.envLang, $stateParams.projectKey).success(function(data) {
                $scope.envNamesWithDescs = data;
                data.envs.forEach(function(x) {
                    if (x.owner) {
                        x.envDesc = x.envName + " (" + x.owner + ")";
                    } else {
                        x.envDesc = x.envName;
                    }
                });
                if (!$scope.inPlugin) {
                    if (data.resolvedInheritDefault == null) {
                        $scope.envModes[1][1] = "Inherit project default (DSS builtin env)"
                    } else {
                        $scope.envModes[1][1] = "Inherit project default (" + data.resolvedInheritDefault + ")";
                    }
                }
                setDefaultValue();
            }).error(setErrorInScope.bind($scope));
        }
    }
});

app.directive("containerSelectionForm", function(DataikuAPI, $stateParams){
        return {
            restrict: 'A',
            templateUrl : '/templates/recipes/fragments/container-selection-form.html',
            scope: {
                containerSelection: '=containerSelectionForm',
                selectionLabel: '=',
                inPlugin: '='
            },
            link: {
                post: function($scope, element, attrs) {
                    $scope.containerModes = [
                        ['NONE', 'None - Use backend to execute'],
                        ['INHERIT', 'Inherit project default'],
                        ['EXPLICIT_CONTAINER', 'Select a container configuration'],
                    ];

                    $scope.containerNames = [];
                    if ($stateParams.projectKey) {
                        DataikuAPI.containers.listNamesWithDefault($stateParams.projectKey).success(function(data) {
                            $scope.containerNames = data.containerNames;
                            if (data.resolvedInheritValue) {
                                $scope.containerModes[1][1] += ' (' + data.resolvedInheritValue + ')';
                            } else {
                                $scope.containerModes[1][1] += ' (local execution)';
                            }
                        }).error(setErrorInScope.bind($scope));
                    } else {
                        DataikuAPI.containers.listNames($stateParams.projectKey).success(function(data) {
                            $scope.containerNames = data;
                        }).error(setErrorInScope.bind($scope));                    
                    }
                }
            }



        }
    });

/**
 * Inputs for specifying the container configuration to apply in the context of the hyperparameter search.
 * @param {object} searchParams: the parameters of the hyperparameter search (either from an analysis or a recipe)
 * @param {function} hasSelectedK8sContainer: tells whether the user has selected a k8s container to run the search
 */
app.component('mlHpDistribution', {
     templateUrl : '/templates/recipes/fragments/ml-hp-distribution.html',
     bindings: {
         searchParams: '=',
         hasSelectedK8sContainer: '<',
         k8sRuntimeEnvTooltip: '@?',
     },
     controller: function() {
         const $ctrl = this;

         $ctrl.getK8sRuntimeEnvTooltip = () => {
             if ($ctrl.k8sRuntimeEnvTooltip) {
                 return $ctrl.k8sRuntimeEnvTooltip;
             }

             return  "Distributed search requires a Kubernetes container configuration to be selected";
         };
     },
});

app.controller("_ContinuousRecipeInitStartedJobBehavior", function ($scope, $stateParams, DataikuAPI, Logger) {
    // get the current state
    DataikuAPI.continuousActivities.getState($stateParams.projectKey, $stateParams.recipeName).success(function(data) {
        $scope.startedJob = $scope.startedJob || {};
        $scope.startedJob.persistent = data;
        $scope.startedJob.current = data.mainLoopState;
        if (data.mainLoopState) {
            if (!data.mainLoopState.futureInfo || !data.mainLoopState.futureInfo.hasResult) {
                $scope.startedJob.jobId = data.mainLoopState.futureId;
                $scope.waitForEndOfStartedContinuousActivity();
            }
        }
    }).error(function() {
        Logger.warn("Recipe " + $stateParams.recipeName + " doesn't have a continuous activity yet")
    });
    
});

})();

(function(){
'use strict';

const app = angular.module('dataiku.recipes');


app.controller("_RecipeCreationControllerBase", function($scope, WT1, Dialogs, PartitionDeps, DataikuAPI, RecipeDescService, Logger) {
    $scope.setComputablesMap = function(map) {
        $scope.computablesMap = map;
        $scope.$broadcast('computablesMapChanged');
    };

    $scope.recipeWT1Event = function(type, params) {
        if (params == null) params = {}
        params.recipeId = ($scope.recipeName && $scope.recipeName.name) ? $scope.recipeName.name.dkuHashCode() : "unknown";
        params.recipeType = ($scope.recipe ? $scope.recipe.type : "unknown");
        params.creation = $scope.creation;
        WT1.event(type, params);
    };

    // Creates the recipe object and sends it to the backend
    // Default generic implementation, override it in the recipe controller for type specific handling
    $scope.doCreateRecipe = function() {
        var recipe = angular.copy($scope.recipe);
        if ($scope.recipeName) {
            recipe.name = $scope.recipeName.name; // TODO @recipes move to backend
        }
        PartitionDeps.prepareRecipeForSerialize(recipe); //TODO @recipes move to backend

        const settings = {
            script: $scope.script
        };
        if ($scope.zone) {
            settings.zone = $scope.zone;
        }

        return DataikuAPI.flow.recipes.generic.create(recipe, settings);
    };

    // launches the recipe creation and triggers associated events
    // for tracking, disabling creation button while the recipe is in creation, etc
    // transitions to the recipe page when it is creations
    $scope.createRecipe = function() {
        $scope.recipeWT1Event("recipe-create-" + $scope.recipeType);
        var p = $scope.doCreateRecipe();
        if (p) {
            $scope.creatingRecipe = true;
            p.success(function(data) {
                $scope.creatingRecipe = false;
                Dialogs.confirmInfoMessages($scope.$parent.$parent, "Recipe creation", data.messages, null, true).then(function(){
                    $scope.$state.go('projects.project.recipes.recipe', {recipeName: data.id});
                })
                $scope.dismiss();


            }).error(function(a, b, c) {
                $scope.creatingRecipe = false;
                setErrorInScope.bind($scope)(a,b,c);
            });
        }
    };

    function updateRecipeDesc() {
        $scope.recipeDesc = RecipeDescService.getDescriptor($scope.recipe.type);
        $scope.isSingleInputRecipe = RecipeDescService.isSingleInputRecipe($scope.recipe.type);
        $scope.isSingleInputRecipe = RecipeDescService.isSingleInputRecipe($scope.recipe.type);
    }

    if ($scope.recipe && $scope.recipe.type) {
        updateRecipeDesc();
    } else {
        $scope.$watch("recipe.type", function(nv) {
            nv && updateRecipeDesc();
        });
    }
});


app.controller("RecipeCopyController", function($scope, $controller, $stateParams,
               Assert, DataikuAPI, DatasetUtils, RecipeComputablesService, RecipeDescService, SavedModelsService, Logger) {
    Assert.inScope($scope, 'recipe');
    Assert.inScope($scope, 'newInputs');
    Assert.inScope($scope, 'newOutputs');

    $controller("_RecipeCreationControllerBase", {$scope: $scope});
    $controller("_RecipeOutputNewManagedBehavior", {$scope:$scope});
    addDatasetUniquenessCheck($scope, DataikuAPI, $stateParams.projectKey);

    // to use the _RecipeOutputNewManagedBehavior fully (when adding a new output)
    $scope.setErrorInTopScope = function(scope) {
        return setErrorInScope.bind($scope);
    };

    $scope.role = null;

    function endEditOutput() {
        $scope.uiState.editingOutput = null;
        $scope.role = null;
    }

    $scope.setupUsableOutputs = function (role, acceptedType) {
        if (!$scope.computablesMap) {
            return;
        }
        Assert.trueish(role, 'no role');

        $scope.role = role;
        var roleName = role.name;
        $scope.noDataset = acceptedType != 'DATASET';
        $scope.noFolder = acceptedType != 'MANAGED_FOLDER';
        $scope.noEvaluationStore = acceptedType != 'MODEL_EVALUATION_STORE';
        $scope.noStreamingEndpoint = acceptedType != 'STREAMING_ENDPOINT';
        if (!$scope.noDataset) {
            $scope.io.newOutputTypeRadio = 'create';
        } else if (!$scope.noFolder) {
            $scope.io.newOutputTypeRadio = 'new-odb';
        } else if (!$scope.noEvaluationStore) {
            $scope.io.newOutputTypeRadio = 'new-mes';
        } else if (!$scope.noStreamingEndpoint) {
            $scope.io.newOutputTypeRadio = 'new-se';
        }

        var outputList = RecipeComputablesService.buildPossibleOutputList($scope.recipe, $scope.computablesMap, $scope.role, $scope.editOutput.filter)
            .filter(function(item) {
                return usableAsOutput(item);
            });

        // Sort possible outputs
        function usableAsOutput(computable) {
            return computable.usableAsOutput[roleName] && computable.usableAsOutput[roleName].usable && !computable.alreadyUsedAsOutputOf;
        }
        outputList.sort(function(a,b) {
            // put usable first
            if (usableAsOutput(a) && !usableAsOutput(b)) {
                return -1;
            }
            if (usableAsOutput(b) && !usableAsOutput(a)) {
                return 1;
            }
            //Otherwise sort by "label" (display name)
            return (a.label || '').localeCompare((b.label || ''));
        });

        $scope.editOutput.usable = outputList;
    };


    $scope.startEditOutput = function(roleName, index) {
        $scope.uiState.backendWarnings = null;
        $scope.uiState.editingOutput = {role: roleName, index: index};
        var outputName = $scope.recipe.outputs[roleName].items[index].ref;
        var computableType = $scope.computablesMap[outputName].type;

        if ($scope.outputRolesIndex == null || !$scope.outputRolesIndex[roleName]) {
            // This should not happen, maybe a new custom type was added and descriptors are not up-to-date
            throw new Error("Role not found in recipe descriptor, try reloading the page");
        }
        $scope.setupUsableOutputs($scope.outputRolesIndex[roleName], computableType);

        // the select element seems to be caching something, and after hiding and showing the
        // create new dataset form a few times (2 times on firefox, 3 on chrome) the option
        // shown to be selected is incorrect ('nothing selected' but the option is not null).
        // it's probably a race condition somewhere, so we solve it the hard way: make the
        // select reinitialize its sate each  time
        $scope.newOutputDataset.connectionOption = null;
        $scope.getManagedDatasetOptions($scope.role.name).then(function(data){
            $scope.setupManagedDatasetOptions(data);
        });
        $scope.getManagedFolderOptions($scope.role.name).then(function(data){
            $scope.setupManagedFolderOptions(data);
        });
        $scope.getModelEvaluationStoreOptions($scope.role.name).then(function(data){
            $scope.setupModelEvaluationStoreOptions(data);
        });
        $scope.getStreamingEndpointOptions($scope.role.name).then(function(data){
            $scope.setupStreamingEndpointOptions(data);
        });
    };

    //Called by a click on close new output
    $scope.cancelAddOutput = function() {
        endEditOutput();
    };

    $scope.acceptEdit = function(computable) {
        var editingOutput = $scope.uiState.editingOutput;
        $scope.newOutputs[editingOutput.role].items[editingOutput.index] = {ref: computable.smartName};
        endEditOutput();
    };

    // We should have a replacement for each input/output
    $scope.formIsValid = function() {
        if ($scope.isSingleOutputRecipe) {
            if ($scope.io.newOutputTypeRadio == 'create') {
                return $scope.newOutputDataset &&
                    $scope.newOutputDataset.name &&
                    $scope.newOutputDataset.connectionOption &&
                    $scope.isDatasetNameUnique($scope.newOutputDataset.name);
            } else if ($scope.io.newOutputTypeRadio == 'new-se') {
                return $scope.newOutputSE &&
                    $scope.newOutputSE.name &&
                    $scope.newOutputSE.connectionOption &&
                    $scope.isStreamingEndpointNameUnique($scope.newOutputSE.name);
            } else if ($scope.io.newOutputTypeRadio == 'select') {
                return $scope.io.existingOutputDataset && $scope.io.existingOutputDataset.length;
            } else {
                return false;
            }
        } else {
            var valid = true;
            $.each($scope.newInputs, function(roleName, role) {
                role.items.forEach(function(input) {
                    if (!input || !input.ref) {
                        valid = false;
                    }
                });
            });
            $.each($scope.newOutputs, function(roleName, role) {
                role.items.forEach(function(output) {
                    if (!output || !output.ref) {
                        valid = false;
                    }
                });
            });
            return valid;
        }
    };

    // Clicked on "create recipe", force=true to ignore warnings
    $scope.copy = function(force) {
        var doIt = function() {
            $scope.recipeWT1Event("recipe-copy-" + $scope.recipe.type);

            $scope.creatingRecipe = true; // for ui, avoids clicking twice on create recipe

            // Single ouput recipes have a simpler UI with different models to store the data
            var copySettings;
            if ($scope.isSingleOutputRecipe) {
                var createOutput = $scope.io.newOutputTypeRadio == 'create';
                var outputName = $scope.io.newOutputTypeRadio == 'create' ? $scope.newOutputDataset.name : ($scope.io.newOutputTypeRadio == 'new-se' ? $scope.newOutputSE.name : $scope.io.existingOutputDataset);
                var singleOutputRoleName = Object.keys($scope.newOutputs)[0];
                var outputs = {}
                outputs[singleOutputRoleName] = {items: [{ref: outputName}]}
                copySettings = {
                    zone: $scope.zone,
                    inputs : $scope.newInputs,
                    outputs : outputs,
                    createOutputDataset : $scope.io.newOutputTypeRadio == 'create',
                    createOutputStreamingEndpoint : $scope.io.newOutputTypeRadio == 'new-se',
                    outputDatasetSettings : $scope.getDatasetCreationSettings(),
                    outputStreamingEndpointSettings : $scope.getStreamingEndpointCreationSettings()
                };
            } else {
                copySettings = {
                    zone: $scope.zone,
                    inputs : $scope.newInputs,
                    outputs : $scope.newOutputs
                };
            }

            DataikuAPI.flow.recipes.generic.copy($stateParams.projectKey,
                                                 $scope.recipe.projectKey,
                                                 $scope.recipe.name,
                                                 copySettings)
            .success(function(data){
                $scope.creatingRecipe = false;
                $scope.dismiss();
                $scope.$state.go('projects.project.recipes.recipe', {
                    recipeName: data.id
                });
            }).error(function(a, b, c) {
                $scope.creatingRecipe = false;
                setErrorInScope.bind($scope)(a,b,c);
            });
        };

        if (!$scope.isSingleOutputRecipe || ['select', 'new-odb', 'new-se'].indexOf($scope.io.newOutputTypeRadio) >= 0 || force) {
            doIt();
        } else {
            DataikuAPI.datasets.checkNameSafety($stateParams.projectKey, $scope.newOutputDataset.name, $scope.getDatasetCreationSettings())
                .success(function(data) {
                    $scope.uiState.backendWarnings = data.messages;
                    if (!data.messages || !data.messages.length) {
                        doIt();
                    }
                })
                .error(function(){
                    Logger.error("Check name failed.", arguments);
                    doIt(); // don't block the creation
                });
        }
    };

    $scope.editOutput = {filter: ''};
    $scope.uiState = $scope.uiState || {};
    $scope.uiState.editingOutput = null;

    var index = RecipeDescService.getRolesIndex($scope.recipe.type);
    $scope.inputRolesIndex = index.inputs;
    $scope.outputRolesIndex = index.outputs;

    // Init new outputs with the same roles as original recipe outputs
    // Also count inputs/outputs to adapt UI
    var nOutputs = 0;
    var nInputs = 0;
    $.each($scope.recipe.outputs, function(roleName, role) {
        $scope.newOutputs[roleName] = {items: $scope.recipe.outputs[roleName].items.map(function(){return null;})};
        nOutputs += role.items.length;
    });
    $.each($scope.recipe.inputs, function(roleName, role) {
        nInputs += role.items.length;
    });

    $scope.hasSingleOutput = nOutputs == 1;
    $scope.hasSingleInput = nInputs == 1;
    $scope.isSingleOutputRecipe = RecipeDescService.isSingleOutputRecipe($scope.recipe.type);

    RecipeComputablesService.getComputablesMap($scope.recipe, $scope).then($scope.setComputablesMap);

    DatasetUtils.listUsabilityInAndOut($scope.recipe.projectKey, $scope.recipe.type).then(function(data) {
        // Compute usable inputs for each role
        $scope.availableInputDatasets = {}
        $scope.availableInputFolders = {};
        $scope.availableInputModels = {};
        $scope.availableInputEndpoints = {};
        $scope.recipeDesc.inputRoles.forEach(function(role) {
            $scope.availableInputDatasets[role.name] = data[0].filter(function(computable) {
                return computable.type == 'DATASET' && computable.usableAsInput[role.name] && computable.usableAsInput[role.name].usable;
            });
            $scope.availableInputFolders[role.name] = data[0].filter(function(computable) {
                return computable.type == 'MANAGED_FOLDER' && computable.usableAsInput[role.name] && computable.usableAsInput[role.name].usable;
            });
            $scope.availableInputModels[role.name] = data[0].filter(function(computable) {
                if (computable.type != 'SAVED_MODEL') {
                    return false;
                }
                if (($scope.recipe.type == 'prediction_scoring' || $scope.recipe.type == 'evaluation') && computable.model.miniTask.taskType != 'PREDICTION') {
                    return false;
                } else if ($scope.recipe.type == 'clustering_scoring' && computable.model.miniTask.taskType != 'CLUSTERING') {
                    return false;
                }
                return computable.usableAsInput[role.name] && computable.usableAsInput[role.name].usable;
            });
            $scope.availableInputEndpoints[role.name] = data[0].filter(function(computable) {
                return computable.type == 'STREAMING_ENDPOINT' && computable.usableAsInput[role.name] && computable.usableAsInput[role.name].usable;
            });
        });
    });

    $scope.$watch("editOutput.filter", function() {
        try {
            if (!$scope.uiState.editingOutput) return;
            var roleName = $scope.uiState.editingOutput.role;
            var index = $scope.uiState.editingOutput.index; //index within role
            var outputName = $scope.recipe.outputs[roleName].items[index].ref;
            var computableType = $scope.computablesMap[outputName].type;
            $scope.setupUsableOutputs($scope.role, computableType);
        } catch (e) {
            Logger.error("Filter output failed", e)
        }
    });
});


app.controller("SingleOutputRecipeCopyController", function($scope, $controller, $stateParams, Assert, DataikuAPI, DatasetUtils, RecipeComputablesService) {
    Assert.inScope($scope, 'recipeDesc');
    Assert.trueish($scope.recipeDesc.outputRoles, 'no output roles');

    $scope.role = $scope.recipeDesc.outputRoles[0];

    var updateUsableOutputs = function() {
        var outputName = $scope.recipe.outputs[$scope.role.name].items[0].ref;
        var computableType = $scope.computablesMap[outputName].type;
        $scope.setupUsableOutputs($scope.role, computableType);
    };

    var updateManagedDatasetOptions = function(forceUpdate) {
        var fakeRecipe = angular.copy($scope.recipe);
        fakeRecipe.projectKey = $stateParams.projectKey;
        fakeRecipe.inputs = $scope.newInputs;
        DataikuAPI.datasets.getManagedDatasetOptions(fakeRecipe, $scope.role.name).success(function(data) {
            $scope.setupManagedDatasetOptions(data, forceUpdate);
        });
        DataikuAPI.datasets.getManagedFolderOptions(fakeRecipe, $scope.role.name).success(function(data) {
            $scope.setupManagedFolderOptions(data, forceUpdate);
        });
        DataikuAPI.datasets.getModelEvaluationStoreOptions(fakeRecipe, $scope.role.name).success(function(data) {
            $scope.setupModelEvaluationStoreOptions(data, forceUpdate);
        });
        DataikuAPI.datasets.getStreamingEndpointOptions(fakeRecipe, $scope.role.name).success(function(data) {
            $scope.setupStreamingEndpointOptions(data, forceUpdate);
        });
    };

    updateUsableOutputs();
    updateManagedDatasetOptions();

    $scope.$watch("sourceRecipe", function(nv) {
        if (!nv) return;
        updateManagedDatasetOptions(true);
    });

    $scope.$watch("computablesMap", function(nv) {
        if (!nv) return;
        updateUsableOutputs();
    });
});


app.controller("SingleOutputDatasetRecipeCreationController", function($scope, Fn, $stateParams, DataikuAPI, $q,Dialogs, DatasetsService, WT1, DatasetUtils, $controller, RecipeComputablesService, Logger, SmartId) {
    $controller("_RecipeCreationControllerBase", {$scope:$scope});
    $controller("_RecipeOutputNewManagedBehavior", {$scope:$scope});

    addDatasetUniquenessCheck($scope, DataikuAPI, $stateParams.projectKey);

    // for safety, to use the _RecipeOutputNewManagedBehavior fully (maybe one day)
    $scope.setErrorInTopScope = function(scope) {
        return setErrorInScope.bind($scope);
    };
    
    $scope.singleOutputRole = {name:"main", arity:"UNARY", acceptsDataset:true};

    var updateManagedDatasetOptions = function(recipeType, inputRef, forceUpdate) {
        var fakeRecipe = {
            type : recipeType,
            projectKey : $stateParams.projectKey,
        }
        if (inputRef) {
            fakeRecipe.inputs = {main : {items : [{ref : inputRef}]}};
        }
        DataikuAPI.datasets.getManagedDatasetOptions(fakeRecipe, "main").success(function(data) {
            $scope.setupManagedDatasetOptions(data, forceUpdate);
        });
        DataikuAPI.datasets.getManagedFolderOptions(fakeRecipe, "main").success(function(data) {
            $scope.setupManagedFolderOptions(data, forceUpdate);
        });
        DataikuAPI.datasets.getModelEvaluationStoreOptions(fakeRecipe, "main").success(function(data) {
            $scope.setupModelEvaluationStoreOptions(data, forceUpdate);
        });
        DataikuAPI.datasets.getStreamingEndpointOptions(fakeRecipe, "main").success(function(data) {
            $scope.setupStreamingEndpointOptions(data, forceUpdate);
        });
    };

    $scope.maybeSetNewDatasetName = function(newName) {
        if ($scope.newOutputDataset && !$scope.newOutputDataset.name && newName) {
            $scope.newOutputDataset.name = newName;
        }
    };

    var makeMainRole = function (refs) {
        return {
            main: {
                items: refs.filter(function(ref) {return !!ref;}).map(function(ref) {return {ref: ref}; })
            }
        }
    };

    // Override to gather recipe type specific settings
    $scope.getCreationSettings = function () {
        return {};
    }

    // Creates the recipe object and sends it to the backend
    $scope.doCreateRecipe = function() {
        var createOutput = $scope.io.newOutputTypeRadio == 'create' || $scope.io.newOutputTypeRadio == 'new-se';
        var outputName = $scope.io.newOutputTypeRadio == 'create' ? $scope.newOutputDataset.name : ($scope.io.newOutputTypeRadio == 'new-se' ? $scope.newOutputSE.name : $scope.io.existingOutputDataset);
        var inputs = $scope.recipe && $scope.recipe.inputs ? $scope.recipe.inputs : makeMainRole([$scope.io.inputDataset]);
        var recipe = {
            type: $scope.recipeType,
            projectKey: $stateParams.projectKey,
            name: "compute_" + outputName, //TODO @recipes remove,

            inputs: inputs,
            outputs: makeMainRole([outputName]),
        };

        const settings = $scope.getCreationSettings();
        if ($scope.zone) {
            settings.zone = $scope.zone;
        }
        settings.createOutputDataset = $scope.io.newOutputTypeRadio == 'create';
        settings.createOutputStreamingEndpoint = $scope.io.newOutputTypeRadio == 'new-se';
        settings.outputDatasetSettings = $scope.getDatasetCreationSettings();
        settings.outputStreamingEndpointSettings = $scope.getStreamingEndpointCreationSettings();

        return DataikuAPI.flow.recipes.generic.create(recipe, settings);
    };

    var createRecipeAndDoStuff = $scope.createRecipe;
    // Called from UI, force means that no check-name-safety call is done
    $scope.createRecipe = function(force) {
        if (['select', 'new-odb', 'new-se'].indexOf($scope.io.newOutputTypeRadio) >= 0 || force) {
            createRecipeAndDoStuff();
        } else {
            DataikuAPI.datasets.checkNameSafety($stateParams.projectKey, $scope.newOutputDataset.name, $scope.getDatasetCreationSettings())
                .success(function(data) {
                    $scope.uiState.backendWarnings = data.messages;
                    if (!data.messages || !data.messages.length) {
                        createRecipeAndDoStuff();
                    }
                })
                .error(function(){
                    Logger.error("Check name failed.", arguments);
                    createRecipeAndDoStuff(); // don't block the creation
                });
        }
    };

    $scope.showOutputPane = function() {
        return !!$scope.io.inputDataset;
    };

    $scope.subFormIsValid = function() { return true; }; // overridable by sub-controllers for additional checks
    $scope.formIsValid = function() {
        if (!$scope.subFormIsValid()) return false;
        if (!($scope.io.inputDataset && $scope.activeSchema && $scope.activeSchema.columns && $scope.activeSchema.columns.length)) return false;
        if ($scope.io.newOutputTypeRadio == 'create') {
            return $scope.newOutputDataset && $scope.newOutputDataset.name && $scope.newOutputDataset.connectionOption && $scope.isDatasetNameUnique($scope.newOutputDataset.name);
        } else if ($scope.io.newOutputTypeRadio == 'new-se') {
            return $scope.newOutputSE && $scope.newOutputSE.name && $scope.newOutputSE.connectionOption && $scope.isStreamingEndpointNameUnique($scope.newOutputSE.name);
        } else if ($scope.io.newOutputTypeRadio == 'select') {
            return $scope.io.existingOutputDataset && $scope.io.existingOutputDataset.length;
        } else {
            return false;
        }
    };
    
    let updateInputDatasetSchema = function() {
        if ($scope.availableInputDatasets == null) return;
        if (!$scope.io.inputDataset) return;
        let resolvedSmartId = SmartId.resolve($scope.io.inputDataset, contextProjectKey);
        // get the object to first assert that we need to grab the schema
        let availableInput = $scope.availableInputDatasets.filter(o => o.name == resolvedSmartId.id && o.projectKey == resolvedSmartId.projectKey)[0];
        if (availableInput == null || availableInput.type == 'DATASET') {
            DataikuAPI.datasets.get(resolvedSmartId.projectKey, resolvedSmartId.id, contextProjectKey).success(function(data){
                $scope.activeSchema = data.schema;
            }).error(setErrorInScope.bind($scope));
        } else if (availableInput.type == 'STREAMING_ENDPOINT') {
            DataikuAPI.streamingEndpoints.get(resolvedSmartId.projectKey, resolvedSmartId.id).success(function(data){
                $scope.activeSchema = data.schema;
            }).error(setErrorInScope.bind($scope));
        } else {
            // other objects don't have a schema
            $scope.activeSchema = {columns:[]};
        }
    };

    var inputsIndex = {};
    DatasetUtils.listDatasetsUsabilityInAndOut($stateParams.projectKey, $scope.recipeType, $scope.datasetsOnly).then(function(data){
        $scope.availableInputDatasets = data[0];
        if ($scope.filterUsableInputsOn) {
            $scope.availableInputDatasets.forEach(function(c) {
                let usability = c.usableAsInput[$scope.filterUsableInputsOn] || {};
                c.usable = usability.usable;
                c.usableReason = usability.reason;
            });
        } else if ($scope.inputDatasetsOnly) {
            $scope.availableInputDatasets = data[0].filter(function(computable){
                return computable.usableAsInput['main'] && computable.usableAsInput['main'].usable;
            });
        }
        $scope.availableOutputDatasets = data[1].filter(function(computable){
            return computable.usableAsOutput['main'] && computable.usableAsOutput['main'].usable && !computable.alreadyUsedAsOutputOf;
        });
        $scope.availableInputDatasets.forEach(function(it) {
            inputsIndex[it.id] = it;
        });
        updateInputDatasetSchema(); // if the inputDataset arrived before the availableInputDatasets
    });

    let contextProjectKey = $scope.context && $scope.context.projectKey ? $scope.context.projectKey:$stateParams.projectKey;
    $scope.$on("preselectInputDataset", function(scope, preselectedInputDataset) {
        $scope.io.inputDataset = preselectedInputDataset;
        $scope.preselectedInputDataset = preselectedInputDataset;
    });
    $scope.$watch("io.inputDataset", Fn.doIfNv(function() {
        if ($scope.preselectedInputDataset && $scope.io.inputDataset != $scope.preselectedInputDataset){
            $scope.zone = null;
        }
        $scope.autosetName();

        updateInputDatasetSchema();
        
        updateManagedDatasetOptions($scope.recipeType, $scope.io.inputDataset, true);
    }));
    $scope.$watch("io.inputDataset2", Fn.doIfNv(function() {
        let resolvedSmartId = SmartId.resolve($scope.io.inputDataset2, contextProjectKey);
        DataikuAPI.datasets.get(resolvedSmartId.projectKey, resolvedSmartId.id, contextProjectKey).success(function(data){
            $scope.activeSchema2 = data.schema;
        }).error(setErrorInScope.bind($scope));
    }));
});


})();
(function() {
'use strict';

const app = angular.module('dataiku.recipes');


/*
    updateStatus : a function, will be called when the status is updated
    canChangeEngine : a function, the modal can only be opened if this returns true
    recipeParams : the recipe parameters in which the engineType will be selected
    recipeStatus : the status object, containing the available engines
*/
app.directive('engineSelectorButton', function(Assert, DataikuAPI, Dialogs, $stateParams, CreateModalFromTemplate){
	return {
		scope: {
            recipeType : '=',
			recipeStatus : '=',
			recipeParams : '=',
			updateStatus : '=',
			canChangeEngine : '=',
            hideStatus : '='
		},
		templateUrl: '/templates/recipes/fragments/recipe-engine-selection-button.html',
        link: function($scope, element, attrs) {
            Assert.inScope($scope, 'recipeParams');

            var modalDisplayed = false;
        	$scope.showEngineSelectionModal = function() {
                if (!modalDisplayed) {
                    modalDisplayed = true;
                    var newScope = $scope.$new();
                    CreateModalFromTemplate("/templates/recipes/fragments/recipe-engines-modal.html", newScope, null, function (modalScope) {
                        modalScope.nUnselectableEngines = modalScope.recipeStatus.engines.filter(e => !e.isSelectable).length;
                        modalScope.options = {};
                        modalScope.resetEngineType = function () {
                            delete $scope.recipeParams.engineType;
                            $scope.updateStatus();
                            modalScope.dismiss();
                        };
                        modalScope.selectEngine = function (engineType) {
                            $scope.recipeParams.engineType = engineType;
                            $scope.updateStatus();
                            modalScope.dismiss();
                        };
                        modalScope.$on("$destroy", _ => modalDisplayed = false);
                    });
                }
	        };
	    }
	}
});

})();
(function() {
    'use strict';
	var app = angular.module('dataiku.recipes');

	app.factory("ComputableSchemaRecipeSave", function(DataikuAPI, CreateModalFromTemplate, $q, $stateParams, ActivityIndicator, Logger, Dialogs) {
		var setFlags = function(datasets, stricter) {
            $.each(datasets, function(idx, val) {
                val.dropAndRecreate = val.incompatibilities.length > 0;
                val.synchronizeMetastore = val.incompatibilities.length > 0 && val.isHDFS;
            });
		}

		var getUpdatePromises = function(computables){
			var promises = [];
            $.each(computables, function(idx, val) {
                let extraOptions = {};
                if (val.type == 'STREAMING_ENDPOINT') {
                    extraOptions.ksqlParams = val.ksqlParams;
                }
                promises.push(DataikuAPI.flow.recipes.saveOutputSchema($stateParams.projectKey,
                    val.type, val.type == "DATASET" ? val.datasetName : val.id, val.newSchema,
                    val.dropAndRecreate, val.synchronizeMetastore, extraOptions));
            });
            return promises;
        }
        var getRecipePromises = function(data){
            var promises = [];
            if (data.updatedRecipe && data.updatedPayload) {
                promises.push(DataikuAPI.flow.recipes.save($stateParams.projectKey,
                    data.updatedRecipe, data.updatedPayload,
                    "Accept recipe update suggestion"));
            }
            return promises;
        }

        var displayPromisesError = function(errRet) {
            var scope = this;
            if (errRet.data) {
                var errDetails = getErrorDetails(errRet.data, errRet.status, errRet.headers, errRet.statusText);
            } else {
                var errDetails = getErrorDetails(errRet[0].data, errRet[0].status, errRet[0].headers, errRet[0].statusText);
            }
            Dialogs.displaySerializedError(scope, errDetails)
        }

		return {
            decorateChangedDatasets: setFlags,
            getUpdatePromises: getUpdatePromises,
            getRecipePromises: getRecipePromises,

			// The scope must be a recipe scope and contain the "doSave" function
			handleSave : function($scope, recipeSerialized, serializedData, deferred) {
	            var doSave = function(){
	                $scope.baseSave(recipeSerialized, serializedData).then(function(){
	                    deferred.resolve("Save done");
	                }, function(error) {
	                	Logger.error("Could not save recipe");
	                	deferred.reject("Could not save recipe");
	                })
	            }

	            DataikuAPI.flow.recipes.getComputableSaveImpact($stateParams.projectKey,
	             recipeSerialized, serializedData).success(function(data) {
	             	var allPreviousSchemasWereEmpty = data.computables.every(x => x.previousSchemaWasEmpty)

	             	if (data.totalIncompatibilities > 0 && allPreviousSchemasWereEmpty) {
						Logger.info("Schema incompatibilites, but all previous schemas were empty, updating and saving");
                        setFlags(data.computables, true);
                        $q.all(getUpdatePromises(data.computables)).then(function() {
                            doSave();
                        }).catch(displayPromisesError.bind($scope));
	             	} else if (data.totalIncompatibilities > 0) {
	             		Logger.info("Schema incompatibilites detected, and some schemas were not empty, displaying modal", data);
	                    $scope.schemaChanges = data;
                        var closedWithButton = false;
	                    CreateModalFromTemplate("/templates/recipes/fragments/recipe-incompatible-schema-multi.html", $scope, null,
	                        function(newScope) {
	                        	setFlags($scope.schemaChanges.computables, false);
	                            newScope.cancelSave = function(){
                                    closedWithButton = true;
	                                newScope.dismiss();
	                                Logger.info("Save cancelled");
	                                deferred.reject("Save cancelled");
	                            };
	                            newScope.updateSchemaFromSuggestion = function() {
                                    closedWithButton = true;
	                                var promises = getUpdatePromises($scope.schemaChanges.computables);
	                                $q.all(promises).then(function() {
	                                    newScope.dismiss();
	                                    doSave();
	                                }).catch(function(data){
	                                	setErrorInScope.bind($scope)(data.data, data.status, data.headers)
	                                });
	                            };
	                            newScope.ignoreSchemaChangeSuggestion = function() {
                                    closedWithButton = true;
	                                newScope.dismiss();
	                                doSave();
	                            };
	                        }
	                    ).then(function(){}, function(){if (!closedWithButton) {deferred.reject("Modal closed impolitely");}});
	                } else {
	                    Logger.info("No incompatible change, saving");
	                    doSave();
	                }
	            }).error(function(data, status, header){
                    Logger.error("Failed to compute recipe save impact");
                    // Failed to compute impact, don't block recipe save but ask user
                    var closedWithButton = false;
                    CreateModalFromTemplate("/templates/recipes/fragments/compute-save-impact-failed.html", $scope, null,
                            function(newScope) {
                                setErrorInScope.bind(newScope)(data, status, header);

                                newScope.cancelSave = function(){
                                    closedWithButton = true;
                                    newScope.dismiss();
                                    Logger.info("Save cancelled");
                                    deferred.reject("Save cancelled");
                                };
                                newScope.saveAnyway = function() {
                                    closedWithButton = true;
                                    newScope.dismiss();
                                    doSave();
                                };
                            }
                        ).then(function(){}, function(){if (!closedWithButton) {deferred.reject("Modal closed impolitely");}});
	            });
			},

			// Specialized version for the Shaker that needs to call a different API
			handleSaveShaker : function($scope, recipeSerialized, shaker, recipeOutputSchema, deferred) {
                const doSave = function(){
                    $scope.baseSave(recipeSerialized, JSON.stringify(shaker)).then(function() {
                        $scope.origShaker = angular.copy(shaker);
                        $scope.schemaDirtiness.dirty = false;
                        deferred.resolve("Save done");
                    });
                }

                $scope.waitAllRefreshesDone().then(function() {
                    DataikuAPI.flow.recipes.getShakerSaveImpact($stateParams.projectKey,
                        $scope.recipe, shaker, $scope.recipeOutputSchema).success(function (data) {

                            var allPreviousSchemasWereEmpty = data.computables.every(x => x.previousSchemaWasEmpty)

                            if (data.totalIncompatibilities > 0 && allPreviousSchemasWereEmpty) {
                                Logger.info("Schema incompatibilites, but all previous schemas were empty, updating and saving");
                                setFlags(data.computables, true);
                                $q.all(getUpdatePromises(data.computables)).then(function () {
                                    doSave();
                                }).catch(displayPromisesError.bind($scope));
                            } else if (data.totalIncompatibilities > 0) {
                                $scope.schemaChanges = data;

                                CreateModalFromTemplate("/templates/recipes/fragments/recipe-incompatible-schema-multi.html", $scope, null,
                                    function (newScope) {
                                        setFlags($scope.schemaChanges.computables, false);
                                        newScope.cancelSave = function () {
                                            newScope.dismiss();
                                            Logger.info("Save cancelled");
                                            deferred.reject("Save cancelled");
                                        }
                                        newScope.updateSchemaFromSuggestion = function () {
                                            var promises = getUpdatePromises($scope.schemaChanges.computables);
                                            $q.all(promises).then(function () {
                                                newScope.dismiss();
                                                doSave();
                                            }).catch(function (data) {
                                                setErrorInScope.bind($scope)(data.data, data.status, data.headers)
                                            });
                                        }
                                        newScope.ignoreSchemaChangeSuggestion = function () {
                                            newScope.dismiss();
                                            doSave();
                                        }
                                    }
                                );
                            } else {
                                Logger.info("No incompatible change, saving");
                                doSave();
                            }
                        }).error(function (data, status, header) {
                            setErrorInScope.bind($scope)(data, status, header);
                            deferred.reject("failed to execute getComputableSaveImpact");
                        });
                });
            },


			handleSchemaUpdateFromAnywhere : function(parentScope, recipeProjectKey, recipeName) {
				var serviceScope = parentScope.$new();
	            DataikuAPI.flow.recipes.getSchemaUpdateResult(recipeProjectKey, recipeName).success(function(data) {
					var allPreviousSchemasWereEmpty = data.computables.every(x => x.previousSchemaWasEmpty)

                   if (data.totalIncompatibilities > 0 && allPreviousSchemasWereEmpty) {
                        Logger.info("Schema incompatibilites, but all previous schemas were empty, updating and saving");
                        setFlags(data.computables, true);
                        $q.all(getUpdatePromises(data.computables)).then(function() {
                            // Nothing to do
                        }).catch(displayPromisesError.bind(parentScope));
	             	}  else if (data.totalIncompatibilities > 0) {
	             		Logger.info("Schema incompatibilites detected, and some schemas were not empty, displaying modal", data);
	                    serviceScope.schemaChanges = data;

	                    CreateModalFromTemplate("/templates/recipes/incompatible-schema-external-modal.html", serviceScope, null,
	                        function(newScope) {
	                        	setFlags(serviceScope.schemaChanges.computables, true);

	                            newScope.updateSchemaFromSuggestion = function() {
	                                var promises = getUpdatePromises(serviceScope.schemaChanges.computables);
	                                $q.all(promises).then(function() {
	                                    newScope.dismiss();
	                                }).catch(function(data){
	                                	setErrorInScope.bind(newScope)(data.data, data.status, data.headers)
	                                });
	                            }
	                            newScope.ignoreSchemaChangeSuggestion = function() {
	                                newScope.dismiss();
	                            }
	                        }
	                    );
	                } else {
	                    ActivityIndicator.success("Schema is already up-to-date");
	                }
	            }).error(function(data, status, header){
	            	CreateModalFromTemplate("/templates/recipes/propagate-schema-changes-failed-modal.html", serviceScope, null,
	                        function(newScope) {
	            		setErrorInScope.bind(newScope)(data, status, header);
	            	});
	            });
			},

            handleSchemaUpdateWithPrecomputedUnattended : function(parentScope, data) {
                var deferred = $q.defer();

                if (data && (data.totalIncompatibilities > 0 || data.recipeChanges.length > 0)) {
                    Logger.info("Schema incompatibilities, unattended mode, updating and saving");
                    setFlags(data.computables, true);
                    $q.all(getUpdatePromises(data.computables).concat(getRecipePromises(data))).then(function() {
                        deferred.resolve({changed:true});
                    }).catch(displayPromisesError.bind(parentScope));
                } else {
                    deferred.resolve({changed:false});
                }
                return deferred.promise;
            },

			handleSchemaUpdateWithPrecomputed : function(parentScope, data) {
				var deferred = $q.defer();
				var serviceScope = parentScope.$new();
                var allPreviousSchemasWereEmpty = data && data.computables.every(x => x.previousSchemaWasEmpty)

	            if (data && data.totalIncompatibilities > 0 && allPreviousSchemasWereEmpty && data.recipeChanges.length == 0) {
                    Logger.info("Schema incompatibilites, but all previous schemas were empty, updating and saving");
                    setFlags(data.computables, true);
                    $q.all(getUpdatePromises(data.computables).concat(getRecipePromises(data))).then(function() {
                        deferred.resolve({changed:true});
                    }).catch(displayPromisesError.bind(parentScope));
             	} else if (data && (data.totalIncompatibilities > 0 || data.recipeChanges.length > 0)) {
             		Logger.info("Schema incompatibilites detected, and some schemas were not empty, displaying modal", data);
                    serviceScope.schemaChanges = data;

                    CreateModalFromTemplate("/templates/recipes/incompatible-schema-external-modal.html", serviceScope, null,
                        function(newScope) {
                        	setFlags(serviceScope.schemaChanges.computables, true);

                            newScope.updateSchemaFromSuggestion = function() {
                                var promises = getUpdatePromises(serviceScope.schemaChanges.computables).concat(getRecipePromises(serviceScope.schemaChanges));
                                $q.all(promises).then(function() {
                                    newScope.dismiss();
                                    deferred.resolve({changed: true});
                                }).catch(function(data){
                                	setErrorInScope.bind(newScope)(data.data, data.status, data.headers)
                                	deferred.reject("Change failed");
                                });
                            }
                            newScope.ignoreSchemaChangeSuggestion = function() {
                                newScope.dismiss();
                                deferred.resolve({changed:false});
                            }
                        }
                    );
                } else {
                	deferred.resolve({changed:false});
                }
                return deferred.promise;
			},
		}
	});

	app.directive('codeRecipeSchemaList', function(DataikuAPI, Dialogs, $stateParams, CreateModalFromTemplate) {
    	return {
	        link : function($scope, element, attrs) {
	        	$scope.beginEditSchema = function(datasetSmartName) {
                    const computable = $scope.computablesMap[datasetSmartName];
                    if (!computable) {
                        throw new Error("Dataset not in computablesMap, try reloading the page");
                    }
	        		const dataset = computable.dataset;
                    DataikuAPI.datasets.get(dataset.projectKey, dataset.name, $stateParams.projectKey)
                        .success(function(data){
    	        			CreateModalFromTemplate("/templates/recipes/code-edit-schema.html", $scope,
    	        				null, function(newScope) {
    	        					newScope.dataset = data;
                                }).then(function(schema) {
                                    dataset.schema = schema;
                                });
    	        		}).error(setErrorInScope.bind($scope));
	        	}
	        }
	    }
	});

	app.directive("schemaEditorBase", function(DatasetUtils, $timeout, CreateModalFromTemplate, ContextualMenu, ExportUtils, ColumnTypeConstants, ActivityIndicator) {
		return {
			scope : true,
			link : function($scope, element, attrs) {
				$scope.columnTypes = ColumnTypeConstants.types;
				$scope.menusState = {meaning:false};
				$scope.startEditName = function(column, $event) {
					$scope.dataset.schema.columns.forEach(function(x){
						x.$editingName = false;
						x.$editingComment = false;
					});

					var grandpa = $($event.target.parentNode.parentNode.parentNode);
					$timeout(function() { grandpa.find("input").focus(); });
				}
				$scope.blur = function(event) {
					$timeout(function() { event.currentTarget.blur(); });
				}
				$scope.setSchemaUserModifiedIfDirty = function() {
					if ($scope.datasetIsDirty && $scope.datasetIsDirty()) {
						$scope.setSchemaUserModified()
					}
				}

				function arrayMove(arr, from, to) {
					arr.splice(to, 0, arr.splice(from, 1)[0]);
				}

				$scope.moveColumnUp = function(column){
					var index = $scope.dataset.schema.columns.indexOf(column);
					if (index > 0) {
						arrayMove($scope.dataset.schema.columns, index, index - 1);
						$scope.setSchemaUserModified();
					}
				}
				$scope.moveColumnDown = function(column){
					var index = $scope.dataset.schema.columns.indexOf(column);
					if (index >= 0 && index < $scope.dataset.schema.columns.length - 1) {
						arrayMove($scope.dataset.schema.columns, index, index + 1);
						$scope.setSchemaUserModified();
					}
				}

				$scope.startEditComment = function(column, $event) {
					$scope.dataset.schema.columns.forEach(function(x){
						x.$editingName = false;
						x.$editingComment = false;
					});
					column.$editingComment = true;
					$timeout(function(){
	        			$($event.target).find("input").focus()
	        		}, 50);
				}
				$scope.addNew = function() {
					if ($scope.dataset.schema == null) {
						$scope.dataset.schema = { "columns" : []};
					}
					if ($scope.dataset.schema.columns == null) {
						$scope.dataset.schema.columns = [];
					}
					$scope.setSchemaUserModified();
					$scope.dataset.schema.columns.push({$editingName : true, name: '', type: 'string', comment: '', maxLength: 1000});
                    $scope.clearFilters();
                    $timeout(function(){
	                    $scope.$broadcast('scrollToLine', -1);
	                });
				}
				$scope.selection.orderQuery = "$idx";

				/** meanings **/
				$scope.openMeaningMenu = function($event, column) {
					$scope.meaningMenu.openAtXY($event.pageX, $event.pageY);
					$scope.meaningColumn = column;
				};

				// use delete instead of '... = null' because when it comes as json, the property is just not there when null
				$scope.setColumnMeaning = function(meaningId) {
					if ($scope.meaningColumn == null) {
	                	$scope.selection.selectedObjects.forEach(function(c) {
							if (meaningId == null) {
								delete c.meaning;
							} else {
			                	c.meaning = meaningId;
							}
	                	});
					} else {
						if (meaningId == null) {
							delete $scope.meaningColumn.meaning;
						} else {
		                	$scope.meaningColumn.meaning = meaningId;
						}
					}
                    $(".code-edit-schema-box").css("display", "block");
                    if ($scope.setSchemaUserModified) $scope.setSchemaUserModified();
                };

                $scope.editColumnUDM = function(){
                    CreateModalFromTemplate("/templates/meanings/column-edit-udm.html", $scope, null, function(newScope){
                    // $(".code-edit-schema-box").css("display", "none");
                    	var columnName;
			if ($scope.meaningColumn == null) {
				columnName = $scope.selection.selectedObjects[0].name;
			} else {
				columnName = $scope.meaningColumn.name;
			}
                        newScope.initModal(columnName, $scope.setColumnMeaning);
                    })
                }

				$scope.exportSchema = function() {
                    if (!$scope.dataset.schema || !$scope.dataset.schema.columns) {
                        ActivityIndicator.error('Empty schema.');
                        return;
                    }
					ExportUtils.exportUIData($scope, {
						name: "Schema of " + $scope.dataset.name,
						columns: [
							{ name: "name", type: "string" },
							{ name: "type", type: "string" },
							{ name: "meaning_id", type: "string" },
							{ name: "description", type: "string" },
							{ name: "max_length", type: "int" }
						],
						data: $scope.dataset.schema.columns.map(function(c){
							return [c.name, c.type, c.meaning, c.comment, c.maxLength >= 0 ? c.maxLength : "" ]
						})
					}, "Export schema");
				}

                $scope.meaningMenu = new ContextualMenu({
                    template: "/templates/shaker/edit-meaning-contextual-menu.html",
                    cssClass : "column-header-meanings-menu pull-right",
                    scope: $scope,
                    contextual: false,
                    onOpen: function() {
                    },
                    onClose: function() {
                    }
                });

                var reNumberColumns = function() {
                	var columns = $scope.$eval(attrs.ngModel);
                	if (!columns) return;
                	// columns.forEach(function(c, i) {c.$idx = i;});
                };

                /** column type **/
                $scope.setColumnsType = function(columnType) {
            		$scope.selection.selectedObjects.forEach(function(c) {
            			c.type = columnType;
            		});
                };
                /** renaming **/
                $scope.doRenameColumns = function(renamings) {
                	renamings.forEach(function(renaming) {
                		$scope.selection.selectedObjects.forEach(function(c) {
                			if (c.name == renaming.from) {
                				c.name = renaming.to;
                			}
                		});
                	});
                };

                $scope.renameColumns = function() {
                	CreateModalFromTemplate('/templates/shaker/modals/shaker-rename-columns.html', $scope, 'MassRenameColumnsController', function(newScope) {
                   		newScope.setColumns($scope.selection.selectedObjects.map(function(c) {return c.name;}));
                   		newScope.doRenameColumns = function(renamings) {
                   			$scope.doRenameColumns(renamings);
                   		};
                    });
                };
                /** data for the right pane **/
                var commonBaseTypeChanged = function() {
                	if (!$scope.selection || !$scope.selection.multiple) return;
                	if (!$scope.multipleSelectionInfo || !$scope.multipleSelectionInfo.commonBaseType) return;
                	var columns = $scope.selection.selectedObjects;
                	columns.forEach(function(column) {column.type = $scope.multipleSelectionInfo.commonBaseType.type;});
                };
                var commonTypeChanged = function() {
                	if (!$scope.selection || !$scope.selection.multiple) return;
                	if (!$scope.multipleSelectionInfo || !$scope.multipleSelectionInfo.commonType) return;
                	var columns = $scope.selection.selectedObjects;
                	var setFullType = function(column, commonType) {
            			column.type = commonType.type;
            			column.maxLength = commonType.maxLength;
            			column.objectFields = commonType.objectFields ? angular.copy(commonType.objectFields) : null;
            			column.arrayContent = commonType.arrayContent ? angular.copy(commonType.arrayContent) : null;
            			column.mapKeys = commonType.mapKeys ? angular.copy(commonType.mapKeys) : null;
            			column.mapValues = commonType.mapValues ? angular.copy(commonType.mapValues) : null;
                	};
                	columns.forEach(function(column) {setFullType(column, $scope.multipleSelectionInfo.commonType);});
                };
                var updateInfoForMultipleTab = function() {
                	if ($scope.commonTypeChangedDeregister) {
                		$scope.commonTypeChangedDeregister();
                		$scope.commonTypeChangedDeregister = null;
                	}
                	if ($scope.commonBaseTypeChangedDeregister) {
                		$scope.commonBaseTypeChangedDeregister();
                		$scope.commonBaseTypeChangedDeregister = null;
                	}
                	if (!$scope.selection || !$scope.selection.multiple) return;
                	var getFullType = function(column) {
                		return {
                			type:column.type ? column.type : null,
                			maxLength:column.maxLength ? column.maxLength : null,
                			objectFields:column.objectFields ? column.objectFields : null,
                			arrayContent:column.arrayContent ? column.arrayContent : null,
                			mapKeys:column.mapKeys ? column.mapKeys : null,
                			mapValues:column.mapValues ? column.mapValues : null
                		};
                	};
                	var columns = $scope.selection.selectedObjects;
                	var names = columns.map(function(column) {return column.name;});
                	var meanings = columns.map(function(column) {return column.meaning;});
                	var types = columns.map(function(column) {return column.type;});
                	var fullTypes = columns.map(function(column) {return getFullType(column);});
                	var firstFullType = fullTypes[0];
                	var sameTypes = fullTypes.map(function(t) {return angular.equals(t, firstFullType);}).reduce(function(a,b) {return a && b;});
                	var commonType = sameTypes ? firstFullType : null;
                	$scope.multipleSelectionInfo = {sameTypes: sameTypes, commonType : commonType, commonBaseType : null};

                    $scope.commonBaseTypeChangedDeregister = $scope.$watch('multipleSelectionInfo.commonBaseType', commonBaseTypeChanged);
                    $scope.commonTypeChangedDeregister = $scope.$watch('multipleSelectionInfo.commonType', commonTypeChanged, true);
                };
                $scope.$watch('selection.multiple', updateInfoForMultipleTab);
                $scope.$watch('selection.selectedObjects', updateInfoForMultipleTab, true);


                $scope.$watch(attrs.ngModel, reNumberColumns); // for when the schema is inferred again (but nothing changes)
                $scope.$watch(attrs.ngModel, reNumberColumns, true);
			}
		}
	});

	app.directive('codeRecipeSchemaEditing', function(DataikuAPI, DatasetUtils, DatasetsService,
		Dialogs, $stateParams, $timeout, Logger){
    	return {
	        link : function($scope, element, attrs) {
	        	$scope.overwriteSchema = function(newSchema) {
	        		$scope.dataset.schema = angular.copy(newSchema);
	        		$scope.schemaJustModified = false;
	        		$scope.consistency = null;
	        	};

	        	$scope.saveSchema = function() {
	        		DataikuAPI.datasets.save($scope.dataset.projectKey, $scope.dataset).success(function(data){
                        $scope.resolveModal($scope.dataset.schema);
	        		}).error(setErrorInScope.bind($scope));
	        	};

	        	$scope.discardConsistencyError= function(){
	        		$scope.consistency = null;
	        	};

	        	$scope.setSchemaUserModified = function() {
            		$scope.schemaJustModified = true;
              		$scope.dataset.schema.userModified = true;
              		$scope.consistency = null;
          		};

                $scope.addColumn = function(){
                    if ($scope.dataset.schema == null) {
                        $scope.dataset.schema = { "columns" : []};
                    }
                    $scope.setSchemaUserModified();
                    $scope.dataset.schema.columns.push({$editingName : true, name: '', type: 'string', comment: '', maxLength: 1000});
                };

	        	$scope.checkConsistency = function () {
			        Logger.info('Checking consistency');
			        $scope.schemaJustModified = false;

			        DataikuAPI.datasets.testSchemaConsistency($scope.dataset).success(function (data) {
            			Logger.info("Got consistency result", data);
            			$scope.consistency = data;
            			$scope.consistency.kind = DatasetUtils.getKindForConsistency($scope.dataset);
            		});
	        	};
	        }
        }
    });
})();

(function() {
'use strict';

const app = angular.module('dataiku.recipes');


app.directive("recipeIoInputs", function(RecipesUtils, RecipeComputablesService, $stateParams) {
    return {
        scope: true,
        templateUrl: function(element, attrs) {
            return '/templates/recipes/io/' + attrs.location + '-inputs.html';
        },
        link: {
        	// pre, because otherwise link is post by default, and executed after its children's link
        	pre : function($scope, element, attrs) {
            	// propagate
            	$scope.roles = $scope.$eval(attrs.roles);
            	$scope.location = attrs.location;
            	$scope.longRoleList = $scope.roles.length > 2;
                $scope.editInputs = [];
            	if ($scope.roles) {
            		$scope.roles.forEach(function(role) {role.editing = false;});
            	}
            	$scope.setErrorInTopScope = function(scope) {
            	    return setErrorInScope.bind($scope.$parent);
            	};

                // Determines if we show explanation for disabled recipe creation button
                $scope.shouldDisplayDisabledCreateExplanation = function () {
                    if (
                        !$scope.roles // No input roles
                        || ($scope.roles.some((role) => role.editing) || $scope.editInputs.length > 0) // Roles are being edited
                    ) { return false; }

                    // Has a specific condition defined in shouldDisplayOutputExplanation
                    if ("shouldDisplayInputExplanation" in $scope) { return $scope.shouldDisplayInputExplanation(); }

                    // Has some unset required input
                    return $scope.roles.some(
                        (role) =>
                            role.required &&
                            (!$scope.recipe.inputs[role.name] || !$scope.recipe.inputs[role.name].items.length)
                    );
                };

                $scope.generateDisabledCreateExplanation = function () {
                    // Has a specific explanation message defined in generateInputExplanation
                    if ("generateInputExplanation" in $scope) { return $scope.generateInputExplanation(); }

                    if ($scope.roles.length === 0) { return ""; }

                    if ($scope.roles.length === 1) {
                        return "This recipe requires at least one input.";
                    } else {
                        const requiredRoles = $scope.roles
                            .filter((role) => role.required)
                            .map((role, inputRoleIdx) => {
                                if (role.name === "main" && !role.label) {
                                    return "main input";
                                } else if (!role.name && !role.label) {
                                    return "input " + (inputRoleIdx + 1); // No label at all => print role index
                                } else {
                                    return '"' + (role.label || role.name) + '"'; // Otherwise print displayed label
                                }
                            });

                        return "This recipe requires at least one input in: "
                            + requiredRoles.slice(0, -1).join(', ')
                            + (requiredRoles.length === 2 ? ' and ' : ', and ')
                            + requiredRoles.slice(-1) + ".";
                    }
                }
            }
        }
    }
});


app.directive("recipeIoOutputs", function(RecipesUtils, RecipeComputablesService, $stateParams){
    return {
        scope: true,
        templateUrl: function(element, attrs) {
            return '/templates/recipes/io/' + attrs.location + '-outputs.html';
        },
        link: {
        	// pre, because otherwise link is post by default, and executed after its children's link
        	pre : function($scope, element, attrs) {
            	// propagate
                $scope.roles = $scope.$eval(attrs.roles);
            	$scope.location = attrs.location;
            	$scope.longRoleList = $scope.roles.length > 2;
                $scope.editOutputs = [];
            	if ($scope.roles) {
            		$scope.roles.forEach(function(role) {role.editing = false;});
            	}
            	$scope.canAppend = function(computable) {
            	    if (computable.noAppend) return false; // no ambiguity here
            	    if (['cpython', 'ksql', 'csync', 'streaming_spark_scala'].indexOf($scope.recipe.type) >= 0) return false; // can't overwrite with continuous activities
            	    if (computable.onlyAppendOnStreamEngine) {
            	        return $scope.recipe == null || $scope.recipe.params == null || $scope.recipe.params.engine == 'DSS';
            	    } else {
            	        return true; // maybe.
            	    }
            	};
                $scope.setErrorInTopScope = function(scope) {
                    return setErrorInScope.bind($scope.$parent);
                };

                // Determines if we show explanation for disabled recipe creation button
                $scope.shouldDisplayDisabledCreateExplanation = function () {
                    if (
                        !$scope.roles // No output roles
                        || ($scope.roles.some((role) => role.editing) || $scope.editOutputs.length > 0) // Roles are being edited
                    ) { return false; }

                    // Has a specific condition defined in shouldDisplayOutputExplanation
                    if ("shouldDisplayOutputExplanation" in $scope) { return $scope.shouldDisplayOutputExplanation(); }

                    // Has some unset required output
                    return $scope.roles.some(
                        (role) =>
                            role.required &&
                            (!$scope.recipe.outputs[role.name] || !$scope.recipe.outputs[role.name].items.length)
                    );
                };

                $scope.generateDisabledCreateExplanation = function () {
                    // Has a specific explanation message defined in generateOutputExplanation
                    if ("generateOutputExplanation" in $scope) { return $scope.generateOutputExplanation(); }

                    if ($scope.roles.length === 0) { return ""; }

                    if ($scope.roles.length === 1) {
                        return "This recipe requires at least one output.";
                    } else {
                        const requiredRoles = $scope.roles
                            .filter((role) => role.required)
                            .map((role, outputRoleIdx) => {
                                if (role.name === "main" && !role.label) {
                                    return "main output";
                                } else if (!role.name && !role.label) {
                                    return "output " + (outputRoleIdx + 1); // No label at all => print role index
                                } else {
                                    return '"' + (role.label || role.name) + '"'; // Otherwise print displayed label
                                }
                            });

                        return "This recipe requires at least one output in: "
                            + requiredRoles.slice(0, -1).join(', ')
                            + (requiredRoles.length === 2 ? ' and ' : ', and ')
                            + requiredRoles.slice(-1) + ".";
                    }
                }
            }
        }
    }
});


// this is more or less a custom ng-repeat, because ngRepeat AND another directive on the same element makes some things
// impossible, like using interpolated attributes for the other directive
app.directive("recipeIoInputList", function(RecipesUtils, RecipeComputablesService, $stateParams, $compile){
    return {
        scope: true,
        restrict: 'E',
        link : function($scope, element, attrs) {
        	var roleElements = [];
        	$scope.roles.forEach(function(role, index){
        		roleElements.push('<div recipe-io-input-display-list role-index="' + index + '" location="' + $scope.location + '"/>');
            	roleElements.push('<div recipe-io-input-add-list role-index="' + index + '"location="' + $scope.location + '"/>');
        	});
        	element.replaceWith($compile(roleElements.join('\n'))($scope));
        }
    }
});


app.directive("recipeIoOutputList", function(RecipesUtils, RecipeComputablesService, $stateParams, $compile, $rootScope){
    return {
        scope: true,
        restrict: 'E',
        link : function($scope, element, attrs) {
        	var roleElements = [];
        	$scope.roles.forEach(function(role, index) {
                if (!$rootScope.featureFlagEnabled('model_evaluation_stores')) {
                    let canOtherThanEvaluationStore = role.acceptsDataset || role.acceptsSavedModel || role.acceptsManagedFolder || role.acceptsStreamingEndpoint;
                    if (!canOtherThanEvaluationStore && role.acceptsModelEvaluationStore) {
                        // skip roles that are only MES
                        return;
                    }
                }
        		roleElements.push('<div recipe-io-output-display-list role-index="' + index + '" location="' + $scope.location + '"/>');
            	roleElements.push('<div recipe-io-output-add-list role-index="' + index + '"location="' + $scope.location + '"/>');
        	});
        	element.replaceWith($compile(roleElements.join('\n'))($scope));
        }
    }
});


app.directive("recipeIoInputDisplayList", function(RecipesUtils, RecipeComputablesService, $stateParams){
    return {
        scope: true,
        replace: true,
        templateUrl: function(element, attrs) {
            return '/templates/recipes/io/' + attrs.location + '-input-display-list.html';
        },
        link : function($scope, element, attrs){
        	$scope.role = $scope.roles[parseInt(attrs.roleIndex)];
            $scope.hasAnyPartitioning = function(){
                if (!$scope.recipe || !$scope.computablesMap) return false;
                return RecipesUtils.hasAnyPartitioning($scope.recipe, $scope.computablesMap);
            }
        }
    }
});


app.directive("recipeIoInputAddList", function(Assert, RecipesUtils, RecipeDescService, RecipeComputablesService, $stateParams, DKUtils, DataikuAPI, $q){
    return {
        scope: true,
        replace: true,
        templateUrl: function(element, attrs) {
            return '/templates/recipes/io/' + attrs.location + '-input-add-list.html';
        },
        link : function($scope, element, attrs) {
        	$scope.role = $scope.roles[parseInt(attrs.roleIndex)];
            $scope.hasAnyPartitioning = function(){
                if (!$scope.recipe || !$scope.computablesMap) return false;
                return RecipesUtils.hasAnyPartitioning($scope.recipe, $scope.computablesMap);
            }

            $scope.addInput = {
                adding : false,
                role:null,
                filter : null
            }
            var beginEdition = function() {
            	$scope.addInput.adding = true;
            	$scope.role.editing = true;
            	$scope.editInputs.push($scope.addInput);
            };

            var endEdition = function() {
            	$scope.addInput.adding = false;
            	$scope.role.editing = false;
            	var idx = $scope.editInputs.indexOf($scope.addInput);
            	if (idx >= 0) $scope.editInputs.splice(idx, 1);
            };

            var setUsable = function(list) {
            	// put usable datasets at the beginning
                var roleName = $scope.role.name;
                list.sort(function(a,b) {
                    var aIsUsable = a.usableAsInput[roleName] && a.usableAsInput[roleName].usable;
                    var bIsUsable = b.usableAsInput[roleName] && b.usableAsInput[roleName].usable;
            		if (aIsUsable && !bIsUsable)
            			return -1;
            		if (!aIsUsable && bIsUsable)
            			return 1;
            		return (a.label || '').localeCompare((b.label || ''));
            	});
            	$scope.addInput.usable = list;
            };
            $scope.$watch("addInput.filter", function(nv){
                if ($scope.recipe && $scope.computablesMap) {
                	setUsable(RecipeComputablesService.buildPossibleInputList(
                        $scope.recipe, $scope.computablesMap, $scope.addInput.role, $scope.addInput.filter));
                }
            });

            $scope.itemsWatchHooked = false;
            var hookItemsWatch = function() {
                $scope.itemsArray = $scope.recipe.inputs[$scope.role.name].items;
                $scope.$watchCollection("itemsArray", function(nv){
                    if ($scope.roleChanged) {
                    	$scope.roleChanged($scope.role.name);
                    }
                });
                $scope.itemsWatchHooked = true;
            };
            if ( $scope.recipe.inputs[$scope.role.name] != null ) {
            	// items can be null in a recipe newly created
            	hookItemsWatch();
            }

            $scope.enterAddInput = function(role) {
                beginEdition();
                $scope.addInput.role = role;
                setUsable(RecipeComputablesService.buildPossibleInputList(
                            $scope.recipe, $scope.computablesMap, role, $scope.addInput.filter));
            }
            $scope.cancelAddInput = function(){
                endEdition();
            }

            $scope.acceptAddInput = function(computable){
                Assert.trueish($scope.addInput.adding, 'not adding inputs');
                var promise = $q.when(null);

                if (attrs.location == "modal") {
                    if ($scope.recipe.inputs[$scope.addInput.role] == null || $scope.role.arity == 'UNARY') {
                        $scope.recipe.inputs[$scope.addInput.role] = { items : []}
                    }
                    $scope.recipe.inputs[$scope.addInput.role].items.push({
                        ref : computable.smartName,
                        deps : []
                    });
                } else {
                    var currentRecipeAndPayload = {
                        recipe : angular.copy($scope.recipe),
                        payload: angular.copy($scope.script.data)
                    }
                    var newRecipeAndPayload = {
                        recipe : angular.copy($scope.recipe),
                        payload: angular.copy($scope.script.data)
                    }
                    if (newRecipeAndPayload.recipe.inputs[$scope.addInput.role] == null || $scope.role.arity == 'UNARY') {
                        newRecipeAndPayload.recipe.inputs[$scope.addInput.role] = { items : []}
                    }
                    newRecipeAndPayload.recipe.inputs[$scope.addInput.role].items.push({
                        ref : computable.smartName,
                        deps : []
                    });
                    promise = DataikuAPI.flow.recipes.getIOChangeResult($stateParams.projectKey, currentRecipeAndPayload, newRecipeAndPayload)
                        .error($scope.setErrorInTopScope($scope))
                        .then(function(resp) {
                            var roleDesc = RecipeDescService.getInputRoleDesc($scope.recipe.type, $scope.addInput.role);
                            $scope.recipe.inputs = resp.data.updated.recipe.inputs;
                            $scope.recipe.outputs = resp.data.updated.recipe.outputs;

                            if (roleDesc.saveAndReloadAfterEditInEditor) {
                                $scope.baseSave($scope.hooks.getRecipeSerialized(), $scope.script ? $scope.script.data : null).then(function(){
                                    DKUtils.reloadState();
                                });
                            }

                            return;
                        });
                }

                promise.then(function(){
                    endEdition();
                    if (!$scope.itemsWatchHooked) {
                  	 hookItemsWatch();
                    }
                });
            }
        }
    }
});


app.controller("_RecipeOutputNewManagedBehavior", function($scope, Logger, DataikuAPI, $stateParams, RecipeComputablesService, $rootScope){
    $scope.newOutputDataset = {};
    $scope.newOutputODB = {};
    $scope.newOutputMES = {};
    $scope.newOutputSE = {};
    $scope.io = $scope.io || {};
    $scope.io.newOutputTypeRadio = "create";
    $scope.forms = {};
    $scope.uiState = $scope.uiState || {};
    delete $scope.uiState.backendWarnings;

    $scope.getManagedDatasetOptions = function(role){
        return DataikuAPI.datasets.getManagedDatasetOptions($scope.recipe, role)
            .then(function(data){return data.data})
            .catch($scope.setErrorInTopScope($scope));
    };

    $scope.setupManagedDatasetOptions = function(data, forceUpdate){
        $scope.managedDatasetOptions = data;
        if (data.connections.length && (!$scope.newOutputDataset.connectionOption || forceUpdate) ){
            $scope.newOutputDataset.connectionOption = data.connections[0];
        }

        $scope.partitioningOptions = [
            {"id" : "NP", "label" : "Not partitioned"}
        ];

        $scope.partitioningOptions = $scope.partitioningOptions
                                        .concat(data.inputPartitionings)
                                        .concat(data.projectPartitionings)

        if (data.inputPartitionings.length) {
            $scope.newOutputDataset.partitioningOption = data.inputPartitionings[0].id
        } else {
            $scope.newOutputDataset.partitioningOption = "NP";
        }
    };

    $scope.getManagedFolderOptions = function(role){
        return DataikuAPI.datasets.getManagedFolderOptions($scope.recipe, role)
            .then(function(data){return data.data})
            .catch($scope.setErrorInTopScope($scope));
    };

    $scope.getModelEvaluationStoreOptions = function(role){
        return DataikuAPI.datasets.getModelEvaluationStoreOptions($scope.recipe, role)
            .then(function(data){return data.data})
            .catch($scope.setErrorInTopScope($scope));
    };

    $scope.getStreamingEndpointOptions = function(role){
        return DataikuAPI.datasets.getStreamingEndpointOptions($scope.recipe, role)
            .then(function(data){return data.data;})
            .catch($scope.setErrorInTopScope($scope));
    };

    var updateFolderConnection = function() {
        if ($scope.newOutputODB.$connection == null) return;
        $scope.newOutputODB.connectionOption = $scope.newOutputODB.$connection.connectionName;
        $scope.newOutputODB.typeOption = $scope.newOutputODB.$connection.fsProviderTypes[0];
    };

    var updateStreamingEndpointConnection = function() {
        if ($scope.newOutputSE.$connection == null) return;
        $scope.newOutputSE.connectionOption = $scope.newOutputSE.$connection.connectionName;
        if ($scope.newOutputSE.$connection.formats && $scope.newOutputSE.$connection.formats.length) {
            $scope.newOutputSE.formatOptionId = $scope.newOutputSE.$connection.formats[0].id;
        }
    };

    $scope.setupManagedFolderOptions = function(data, forceUpdate){
        $scope.managedFolderOptions = data;
        $scope.managedFolderOptions.connections = $scope.managedFolderOptions.connections.filter(function(c) {return c.fsProviderTypes != null;});
        if (data.connections.length && (!$scope.newOutputODB.connectionOption || forceUpdate) ){
            $scope.newOutputODB.$connection = data.connections[0];
            updateFolderConnection();
        }

        $scope.partitioningOptions = [
            {"id" : "NP", "label" : "Not partitioned"}
        ];

        $scope.partitioningOptions = $scope.partitioningOptions
                                        .concat(data.inputPartitionings)
                                        .concat(data.projectPartitionings)

        if (data.inputPartitionings.length) {
            $scope.newOutputODB.partitioningOption = data.inputPartitionings[0].id
        } else {
            $scope.newOutputODB.partitioningOption = "NP";
        }
    };

    $scope.setupModelEvaluationStoreOptions = function(data, forceUpdate){
        $scope.modelEvaluationStoreOptions = data;

        $scope.partitioningOptions = [
            {"id" : "NP", "label" : "Not partitioned"}
        ];

        $scope.partitioningOptions = $scope.partitioningOptions
                                        .concat(data.inputPartitionings)
                                        .concat(data.projectPartitionings)

        //if (data.inputPartitionings.length) {
        //    $scope.newOutputMES.partitioningOption = data.inputPartitionings[0].id
        //} else {
            $scope.newOutputMES.partitioningOption = "NP";
        //}
    };

    $scope.setupStreamingEndpointOptions = function(data, forceUpdate){
        $scope.streamingEndpointOptions = data;
        if (data.connections.length && (!$scope.newOutputSE.connectionOption || forceUpdate) ){
            $scope.newOutputSE.$connection = data.connections[0];
            updateStreamingEndpointConnection();
        }
    };

    $scope.$watch("newOutputDataset.connectionOption", function(nv, ov){
        if (nv && nv.formats && nv.formats.length) {
            $scope.newOutputDataset.formatOptionId = nv.formats[0].id;
        }
        if (nv && nv.fsProviderTypes && nv.fsProviderTypes.length > 1) {
            $scope.newOutputDataset.typeOption = nv.fsProviderTypes[0];
        }
    }, true);

    function doCreateAndUseNewOutputDataset(projectKey, datasetName, settings) {
        Logger.info("Create and use ", $scope);
        DataikuAPI.datasets.newManagedDataset(projectKey, datasetName, settings).success(function(dataset) {
                RecipeComputablesService.getComputablesMap($scope.recipe, $scope).then(function(map){
                    $scope.setComputablesMap(map);

                    $scope.acceptEdit($scope.computablesMap[dataset.name]);

                    // Clear form
                    $scope.newOutputDataset.name = '';
                    $scope.forms.newOutputDatasetForm.$setPristine(true);

                    $rootScope.$emit('datasetsListChangedFromModal'); // communicate with the flow editor (note: don't broadcast)
                });

        }).error($scope.setErrorInTopScope($scope));

        $scope.recipeWT1Event("recipe-create-managed-dataset", {
            connection : $scope.newOutputDataset.connection,
            schemaFrom : $scope.newOutputDataset.schema,
            partitioningFrom : $scope.newOutputDataset.partitioning
        });
    }

    $scope.getDatasetCreationSettings = function() {
        let datasetCreationSetting = {
            connectionId : ($scope.newOutputDataset.connectionOption || {}).id,
            specificSettings : {
                overrideSQLCatalog: $scope.newOutputDataset.overrideSQLCatalog,
                overrideSQLSchema: $scope.newOutputDataset.overrideSQLSchema,
                formatOptionId : $scope.newOutputDataset.formatOptionId,
            },
            partitioningOptionId : $scope.newOutputDataset.partitioningOption,
            inlineDataset : $scope.inlineDataset,
            zone : $scope.zone
        };
        if ($scope.newOutputDataset &&
            $scope.newOutputDataset.connectionOption &&
            $scope.newOutputDataset.connectionOption.fsProviderTypes &&
            $scope.newOutputDataset.connectionOption.fsProviderTypes.length > 1) {
            datasetCreationSetting['typeOptionId'] = $scope.newOutputDataset.typeOption;
        }
        return datasetCreationSetting;
    }

    $scope.getFolderCreationSettings = function() {
        return {
            partitioningOptionId : $scope.newOutputODB.partitioningOption,
            connectionId : $scope.newOutputODB.connectionOption,
            typeOptionId : $scope.newOutputODB.typeOption,
            zone: $scope.zone
        };
    }

    $scope.getEvaluationStoreCreationSettings = function() {
        return {
            partitioningOptionId : $scope.newOutputMES.partitioningOption,
            zone: $scope.zone
        };
    }

    $scope.getStreamingEndpointCreationSettings = function() {
        return {
            connectionId : $scope.newOutputSE.connectionOption,
            formatOptionId : $scope.newOutputSE.formatOptionId,
            typeOptionId : $scope.newOutputSE.typeOption,
            zone: $scope.zone
        };
    }

    $scope.$watch("newOutputODB.$connection", updateFolderConnection);
    $scope.$watch("newOutputSE.$connection", updateStreamingEndpointConnection);


    $scope.createAndUseNewOutputDataset = function(force) {
        var projectKey = $stateParams.projectKey,
            datasetName = $scope.newOutputDataset.name,
            settings = $scope.getDatasetCreationSettings();

        if (force) {
            doCreateAndUseNewOutputDataset(projectKey, datasetName, settings);
        } else {
            DataikuAPI.datasets.checkNameSafety(projectKey, datasetName, settings).success(function(data) {
                $scope.uiState.backendWarnings = data.messages;
                if (!data.messages || !data.messages.length) {
                    doCreateAndUseNewOutputDataset(projectKey, datasetName, settings);
                }
            }).error($scope.setErrorInTopScope($scope));
        }
    };

    $scope.createAndUseManagedFolder = function() {
        Logger.info("Create and use managed folder", $scope);
        var settings = $scope.getFolderCreationSettings();
        DataikuAPI.datasets.newManagedFolder($stateParams.projectKey, $scope.newOutputODB.name, settings).success(function(odb) {

            RecipeComputablesService.getComputablesMap($scope.recipe, $scope).then(function(map){
                $scope.setComputablesMap(map);

                $scope.acceptEdit($scope.computablesMap[odb.id]);

                // Clear form
                $scope.newOutputODB.name = '';
                $scope.forms.newOutputODBForm.$setPristine(true);

                $rootScope.$emit('datasetsListChangedFromModal'); // communicate with the flow editor (note: don't broadcast)
            });

        }).error($scope.setErrorInTopScope($scope));

        $scope.recipeWT1Event("recipe-create-managed-folder", {});
    };
    
    $scope.createAndUseModelEvaluationStore = function() {
        Logger.info("Create and use model evaluation store", $scope);
        var settings = $scope.getEvaluationStoreCreationSettings();
        DataikuAPI.datasets.newModelEvaluationStore($stateParams.projectKey, $scope.newOutputMES.name, settings).success(function(mes) {

            RecipeComputablesService.getComputablesMap($scope.recipe, $scope).then(function(map){
                $scope.setComputablesMap(map);

                $scope.acceptEdit($scope.computablesMap[mes.id]);

                // Clear form
                $scope.newOutputMES.name = '';
                $scope.forms.newOutputMESForm.$setPristine(true);

                $rootScope.$emit('datasetsListChangedFromModal'); // communicate with the flow editor (note: don't broadcast)
            });

        }).error($scope.setErrorInTopScope($scope));

        $scope.recipeWT1Event("recipe-create-model-evaluation-store", {});
    };
    
    $scope.createAndUseStreamingEndpoint = function() {
        Logger.info("Create and use streaming endpoint", $scope);
        var settings = $scope.getStreamingEndpointCreationSettings();
        DataikuAPI.datasets.newStreamingEndpoint($stateParams.projectKey, $scope.newOutputSE.name, settings).success(function(se) {

            RecipeComputablesService.getComputablesMap($scope.recipe, $scope).then(function(map){
                $scope.setComputablesMap(map);

                $scope.acceptEdit($scope.computablesMap[se.id]);

                // Clear form
                $scope.newOutputSE.name = '';
                $scope.forms.newOutputSEForm.$setPristine(true);

                $rootScope.$emit('datasetsListChangedFromModal'); // communicate with the flow editor (note: don't broadcast)
            });

        }).error($scope.setErrorInTopScope($scope));

        $scope.recipeWT1Event("recipe-create-streaming-endpoint", {});
    };
});


app.directive("recipeIoOutputDisplayList", function(RecipesUtils, RecipeComputablesService, $stateParams){
    return {
        scope: true,
        replace: true,
        templateUrl: function(element, attrs) {
            return '/templates/recipes/io/' + attrs.location + '-output-display-list.html';
        },
        link : function($scope, element, attrs){
        	$scope.role = $scope.roles[parseInt(attrs.roleIndex)];
            $scope.hasAnyPartitioning = function(){
                if (!$scope.recipe || !$scope.computablesMap) return false;
                return RecipesUtils.hasAnyPartitioning($scope.recipe, $scope.computablesMap);
            }
        }
    }
});


app.directive("recipeIoOutputAddList", function($controller, Assert, RecipesUtils, RecipeComputablesService, Logger, DataikuAPI,$state, $stateParams, $q) {
    return {
        scope: true,
        replace: true,
        // Not using isolate scope because we need to $eval
        templateUrl: function(element, attrs) {
            return '/templates/recipes/io/' + attrs.location + '-output-add-list.html';
        },
        link : function($scope, elemnt, attrs){
        	$controller("_RecipeOutputNewManagedBehavior", {$scope:$scope});
        	$scope.role = $scope.roles[parseInt(attrs.roleIndex)];

            $scope.hasAnyPartitioning = function(){
                if (!$scope.recipe || !$scope.computablesMap) return false;
                return RecipesUtils.hasAnyPartitioning($scope.recipe, $scope.computablesMap);
            }

            $scope.editOutput = {
                adding : false,
                role:null
            }
            var beginEdition = function() {
            	$scope.editOutput.adding = true;
            	$scope.role.editing = true;
            	$scope.editOutputs.push($scope.editOutput);

            	var selectOption = function(role) {
                	if (role.acceptsDataset) {
                		return "create";
                    } else if (role.acceptsManagedFolder) {
                        return "new-odb";
                    } else if (role.acceptsModelEvaluationStore) {
                        return "new-mes";
                	} else {
                		return "select";
                	}
            	};
            	if ( $scope.io.newOutputTypeRadio == null ) {
            		$scope.io.newOutputTypeRadio = selectOption($scope.role);
            	} else if ( $scope.io.newOutputTypeRadio == "create" && !$scope.role.acceptsDataset ) {
            		$scope.io.newOutputTypeRadio = selectOption($scope.role);
                } else if ( $scope.io.newOutputTypeRadio == "new-odb" && !$scope.role.acceptsManagedFolder ) {
                    $scope.io.newOutputTypeRadio = selectOption($scope.role);
                } else if ( $scope.io.newOutputTypeRadio == "new-mes" && !$scope.role.acceptsModelEvaluationStore ) {
                    $scope.io.newOutputTypeRadio = selectOption($scope.role);
            	}
            };
            var endEdition = function() {
            	$scope.editOutput.adding = false;
            	$scope.role.editing = false;
            	var idx = $scope.editOutputs.indexOf($scope.editOutput);
            	if (idx >= 0) $scope.editOutputs.splice(idx, 1);
            };

            var setUsable = function(list){
               	// put usable datasets at the beginning
               	list.sort(function(a,b) {
               		if (a.usableAsOutput[$scope.role.name] && a.usableAsOutput[$scope.role.name].usable && !a.alreadyUsedAsOutputOf &&
                        (!b.usableAsOutput[$scope.role.name] || !b.usableAsOutput[$scope.role.name].usable || b.alreadyUsedAsOutputOf))
               			return -1;
               		if ((!a.usableAsOutput[$scope.role.name] || !a.usableAsOutput[$scope.role.name].usable || a.alreadyUsedAsOutputOf) &&
                        b.usableAsOutput[$scope.role.name] && b.usableAsOutput[$scope.role.name].usable && !b.alreadyUsedAsOutputOf)
               			return 1;
            		return (a.label || '').localeCompare((b.label || ''));
               	});
               	$scope.editOutput.usable = list;
            };

            $scope.itemsWatchHooked = false;
            var hookItemsWatch = function() {
            	$scope.itemsArray = $scope.recipe.outputs[$scope.role.name].items;
                $scope.$watchCollection("itemsArray", function(nv){
                    if ($scope.roleChanged) {
                    	$scope.roleChanged($scope.role.name);
                    }
                });
                $scope.itemsWatchHooked = true;
            };
            if ( $scope.recipe.outputs[$scope.role.name] != null ) {
            	// items can be null in a recipe newly created
            	hookItemsWatch();
            }

            $scope.$watch("editOutput.filter", function(){
            	setUsable(RecipeComputablesService.buildPossibleOutputList(
            			$scope.recipe, $scope.computablesMap, $scope.editOutput.role, $scope.editOutput.filter));
            });

            $scope.enterAddOutput = function(role) {
                $scope.uiState.backendWarnings = null;
                beginEdition();
                $scope.editOutput.role = role;
                setUsable(RecipeComputablesService.buildPossibleOutputList(
                            $scope.recipe, $scope.computablesMap, role, $scope.editOutput.filter));

                // the select element seems to be caching something, and after hiding and showing the
                // create new dataset form a few times (2 times on firefox, 3 on chrome) the option
                // shown to be selected is incorrect ('nothing selected' but the option is not null).
                // it's probably a race condition somewhere, so we solve it the hard way: make the
                // select reinitialize its sate each  time
                $scope.newOutputDataset.connectionOption = null;
                $scope.getManagedDatasetOptions(role).then(function(data){
                    $scope.setupManagedDatasetOptions(data);
                })
                $scope.getManagedFolderOptions(role).then(function(data){
                    $scope.setupManagedFolderOptions(data);
                })
                $scope.getModelEvaluationStoreOptions(role).then(function(data){
                    $scope.setupModelEvaluationStoreOptions(data);
                })
                $scope.getStreamingEndpointOptions(role).then(function(data){
                    $scope.setupStreamingEndpointOptions(data);
                })
            };

            $scope.cancelAddOutput = function(){
                endEdition();
            };

            $scope.acceptEdit = function(computable){
                Assert.trueish($scope.editOutput.adding, 'not adding inputs');
                var promise = $q.when(null);

                if (attrs.location == "modal") {
                    if ($scope.role.arity == "UNARY") {
                        $scope.recipe.outputs[$scope.role.name] = { items : []};
                    }
                    RecipesUtils.addOutput($scope.recipe, $scope.role.name, computable.smartName);
                } else {
                    var currentRecipeAndPayload = {
                        recipe : angular.copy($scope.recipe),
                        payload: angular.copy($scope.script.data)
                    }
                    var newRecipeAndPayload = {
                        recipe : angular.copy($scope.recipe),
                        payload: angular.copy($scope.script.data)
                    }
                    if ($scope.role.arity == "UNARY") {
                        newRecipeAndPayload.recipe.outputs[$scope.role.name] = { items : []};
                    }
                    RecipesUtils.addOutput(newRecipeAndPayload.recipe, $scope.role.name, computable.smartName);
                    promise = DataikuAPI.flow.recipes.getIOChangeResult($stateParams.projectKey, currentRecipeAndPayload, newRecipeAndPayload)
                        .error($scope.setErrorInTopScope($scope))
                        .then(function(resp){
                            $scope.recipe.inputs = resp.data.updated.recipe.inputs;
                            $scope.recipe.outputs = resp.data.updated.recipe.outputs;
                            return;
                        });
                }

                promise.then(function(){
                    endEdition();
                    if (!$scope.itemsWatchHooked) {
                      	hookItemsWatch();
                    }
                });
            };

            if ($scope.role.arity == 'UNARY' && attrs.location != 'modal') {
                /* Auto enter edit mode if none selected */
                if ($scope.role.required && (!$scope.recipe.outputs[$scope.role.name] || $scope.recipe.outputs[$scope.role.name].items.length == 0)) {
                    beginEdition();
                }
            }
        }
    }
});

})();

(function() {
'use strict';

var app = angular.module('dataiku.recipes');


var PYTHON_SAMPLE_DEPENDENCY = 'def get_dependencies(target_partition_id):\n'
                            + '    return [target_partition_id]';

app.filter('retrievePartitioning', function(){
    return function(computable){
        if (!computable) { return null; }

        switch (computable.type) {
        case 'DATASET':            return computable.dataset.partitioning;
        case 'MANAGED_FOLDER':     return computable.box.partitioning;
        case 'SAVED_MODEL':        return computable.model.partitioning;
        }
        return null;
    };
});

app.directive("partitionedByInfo", function() {
    return {
        templateUrl : '/templates/recipes/io/partitioned-by-info.html',
        scope:true,
        link : function($scope, element, attrs) {
            $scope.lookupRef = $scope.$eval(attrs.ref);
        }
    }
});

app.directive("customPythonDependencyEditor", function(CreateModalFromTemplate,PartitionDeps,DataikuAPI, CodeMirrorSettingService) {
    return {
        restrict:'E',
        template : '<button class="btn" ng-click="openDialog()">Edit</button>',
        scope : {
            pdepIndex : '=',
            recipe : '=',
            input : '='
        },
        link : function(isolatedScope, element, attrs) {
            isolatedScope.openDialog = function() {
                CreateModalFromTemplate("/templates/recipes/fragments/python-dep-editor.html", isolatedScope,null, function(scope) {

                    scope.localRecipe = angular.copy(isolatedScope.recipe);
                    scope.localInput = angular.copy(isolatedScope.input);
                    // replace input in local recipe, to be able to test
                    $.each(isolatedScope.recipe.inputs, function(roleName, inputRole) {
                        var inputIndex = inputRole.items.indexOf(isolatedScope.input);
                        if (inputIndex >= 0) {
                        	scope.localRecipe.inputs[roleName].items[inputIndex] = scope.localInput;
                        }
                    });
                    scope.localPdep = scope.localInput.deps[isolatedScope.pdepIndex];

                    if(!scope.localPdep.params) {
                        scope.localPdep.params = {};
                    }
                    if(!scope.localPdep.params.code) {
                        scope.localPdep.params.code = PYTHON_SAMPLE_DEPENDENCY;
                    }

                    scope.editorOptions = CodeMirrorSettingService.get('text/x-python');

                    scope.saveAndClose = function() {
                        isolatedScope.input.deps[isolatedScope.pdepIndex].params = angular.copy(scope.localPdep.params);
                        scope.dismiss();
                    };

                    scope.test = function() {
                        scope.testResult = undefined;
                        DataikuAPI.flow.recipes.generic.pdepTest(scope.localRecipe, isolatedScope.input.ref, PartitionDeps.prepareForSerialize(scope.localPdep)).success(function(data) {
                            scope.testResults = data;
                        }).error(setErrorInScope.bind(scope));
                    };
                });
            };
        }
    };
});

app.factory("PartitionDeps", function(Assert, DataikuAPI, Logger, RecipesUtils, $filter) {
    function neverNeedsOutput(pdep) {
        return ["values", "all_available", "latest_available"].indexOf(pdep.func) >= 0;
    }
    function mayWorkWithoutOutput(pdep) {
        return ["time_range"].indexOf(pdep.func) >= 0;
    }

    var svc = {
        // Auto fills proper parameters for a single partition dependency
        // This should be called each time the pdep is changed
        autocomplete : function(pdep, outputDimensions, outputDimensionsWithNow) {
            Logger.info("Autocompleting pdep:"  + JSON.stringify(pdep));
            if (pdep.func == "time_range") {
                if (!pdep.params) pdep.params = {};

                if (!pdep.params.fromMode) pdep.params.fromMode = "RELATIVE_OFFSET";
                if (!pdep.params.fromGranularity) pdep.params.fromGranularity = "DAY";
                if (angular.isUndefined(pdep.params.fromOffset)) pdep.params.fromOffset = 0;
                if (!pdep.params.toGranularity) pdep.params.toGranularity = pdep.params.fromGranularity;
                if (angular.isUndefined(pdep.params.toOffset)) pdep.params.toOffset = 0;

                if (pdep.params.fromMode == "FIXED_DATE" && !pdep.params.fromDate) {
                    pdep.params.fromDate = "2014-01-01";
                }

                if (!pdep.$$output) {
                    if (outputDimensions.length) {
                        pdep.$$output = outputDimensions[0];
                    } else {
                        pdep.$$output = outputDimensionsWithNow[0];
                    }
                }
            } else if(pdep.func == 'custom_python') {
                if (!pdep.params) pdep.params = {};
                if (!pdep.params.code) pdep.params.code = PYTHON_SAMPLE_DEPENDENCY;
            }
            Logger.info("Autocompleted pdep:"  + JSON.stringify(pdep));
        },

        // Fixup pdep definitions. This should be called each time inputs or outputs
        // of the recipe are modified.
        // We don't do it with $watch because it actually makes handling corner cases more difficult
        // Returns :
        //  [outputDimensions, outputDimensiosnWithNow]
        fixup : function(recipe, computablesMap) {
            Logger.info("fixup pdep, recipe is ", recipe);
            Assert.trueish(recipe, 'no recipe');
            Assert.trueish(computablesMap, 'no computablesMap');
            RecipesUtils.getFlatInputsList(recipe).forEach(function(input){
                // console.info("CHECKING IF I HAVE " , input.ref, "in", computablesMap);
                Assert.trueish(computablesMap[input.ref], 'input not in computablesMap');
            });
            RecipesUtils.getFlatOutputsList(recipe).forEach(function(output){
                // console.info("CHECKING IF I HAVE " , output.ref, "in", computablesMap);
                Assert.trueish(computablesMap[output.ref], 'output not in computablesMap');
            });
            /* End sanity checks */

            /* Remove pdeps that were only here temporarily.
             * At the moment, it only means empty "values" deps.
             * If they were needed, we'll recreate them later on) */

            RecipesUtils.getFlatInputsList(recipe).forEach(function(input){
                Logger.info("Cleaning up input deps", input.deps);
                input.deps = input.deps.filter(function(dep) {
                    var isTemp =  dep.out == null && dep.func == "values" && !dep.values;
                    return !isTemp;
                });
                Logger.info("cleaned:" , input.deps);
            });

            // Each partition dep points to an (output, odim) couple or to nothing ...
            // So we keep up to date a list of (output, odim) couples
            var outputDimensions = [];
            RecipesUtils.getFlatOutputsList(recipe).forEach(function(output){
                const computable = computablesMap[output.ref];
                const partitioning = $filter('retrievePartitioning')(computable);

                if (partitioning == null) {
                    return;
                }

                partitioning.dimensions.forEach(function(dim) {
                    outputDimensions.push({
                        out: output.ref,
                        odim: dim.name,
                        label: dim.name + " of " + output.ref
                    });
                });
            });

            Logger.info("Valid possible outputs", outputDimensions);

            // Very important: make a shallow copy of the array because the matching
            // of $$output to outputDimensions is not deep
            var outputDimensionsWithNow = outputDimensions.slice();
            var currentTimeDep = {
                "label" :"Current time"
            };
            outputDimensionsWithNow.push(currentTimeDep)

            // Assign in $$output the correct out/odim couple for existing valid dependencies
            RecipesUtils.getFlatInputsList(recipe).forEach(function(input){
                input.deps.forEach(function(pdep) {
                    if (neverNeedsOutput(pdep)) {
                        Logger.info("Pdep does not need an output", pdep);
                        return;
                    }
                	if (pdep.$$output != null) {
                		// try to find it in the 'new' outputDimensions, in case it's
                		// currently being edited
                		var matchingOd;
                		if (pdep.$$output.label == currentTimeDep.label) {
                		    matchingOd = [currentTimeDep];
                		} else {
                            matchingOd = outputDimensions.filter(function(nod) {return nod.out == pdep.$$output.out && nod.odim == pdep.$$output.odim;});
                		}
                		if ( matchingOd.length == 1) {
                			pdep.$$output = matchingOd[0];
                		} else {
                			pdep.$$output = null;
                		}
                	}
                	if (pdep.$$output == null) {
                        for (var i in outputDimensions) {
                            var od = outputDimensions[i];
                            Logger.info("Compare ", od, pdep);
                            if (od.out == pdep.out && od.odim == pdep.odim) {
                                pdep.$$output = od;
                                Logger.info("YES, matches");
                                break;
                            }
                        }
                	}
                    if (!pdep.$$output) {
                        if (mayWorkWithoutOutput(pdep)) {
                            Logger.info("Failed to find a matching output dimension for pdep ", pdep);
                            pdep.$$output = currentTimeDep;
                        } else {
                            Logger.error("Failed to find a matching output dimension for pdep ", pdep);
                        }
                        // This can happen when removing an output ...
                    }
                });
            });

            // Add entries for missing dependencies
            RecipesUtils.getFlatInputsList(recipe).forEach(function(input){
                const computable = computablesMap[input.ref];
                const partitioning = $filter('retrievePartitioning')(computable);

                if (partitioning) {
                    for (var dimIdx in partitioning.dimensions) {
                        var dim = partitioning.dimensions[dimIdx];
                        Logger.info("Searching for pdep setting ", dim.name, "in", angular.copy(input.deps));

                        if ($.grep(input.deps, dep => dep.idim == dim.name).length === 0) {
                            Logger.info("Will add new pdep ...");
                            var recipeFirstOut = RecipesUtils.getFlatOutputsList(recipe)[0];
                            var newPdep = {
                                out: recipeFirstOut ? recipeFirstOut.ref : null,
                                func : 'equals',
                                idim : dim.name
                            };
                            if (newPdep.out && partitioning.dimensions.length) {
                                var outputDimensions = partitioning.dimensions;
                                // try to match with same dimension on the output
                                newPdep.odim = outputDimensions[0].name;
                                outputDimensions.forEach(function(dim) {
                                    if (dim.name == newPdep.idim) {
                                        newPdep.odim = dim.name;
                                        return;
                                    }
                                });
                                // then fetch the $$output
                                for (var i in outputDimensions) {
                                    var od = outputDimensions[i];
                                    if (od.out == newPdep.out && od.odim == newPdep.odim) {
                                        newPdep.$$output = od;
                                        break;
                                    }
                                }
                            } else {
                                newPdep.func = 'values';
                            }

                            Logger.info("Creating missing pdep for " , input, dim.name, angular.copy(newPdep));
                            input.deps.push(newPdep);
                        }
                    }
                }
            });

            /* If we still have some incomplete dependencies, try to fix them.
             * This happens in the following case:
             *  - I0 partitioned by D0, O0 partitioned by D0, equals dep
             *  - Remove O0 as output
             *  - Add a new dep with the same partitioning. Since the pdep
             *    was already here, we didn't create it.
             *
             * The logic is:
             *  - If the pdep needs absolutely an output
             *  - And it does not have a $$output reference
             *  - then: if there is partitioned output dataset, we set the output to it
             *    else: we fallback to a VALUES
             */
            RecipesUtils.getFlatInputsList(recipe).forEach(function(input){
                input.deps.forEach(function(pdep) {
                    if (neverNeedsOutput(pdep)) {
                        Logger.info("Pdep does not need an output", pdep);
                        return;
                    }
                    if (pdep.$$output == null) {
                        Logger.info("Pdep has no valid output", pdep);

                        if (mayWorkWithoutOutput(pdep)) {
                            Logger.info("but it might work without ....");
                            return;
                        }

                        const recipeFirstOut = RecipesUtils.getFlatOutputsList(recipe)[0];
                        const partitioning = $filter('retrievePartitioning')(computablesMap[recipeFirstOut.ref]);

                        if (recipeFirstOut && partitioning.dimensions.length) {
                            pdep.out = recipeFirstOut.ref;
                            pdep.odim = partitioning.dimensions[0].name;
                            Logger.info("Assign as output", pdep);
                            // Assign the $$output
                            for (var i in outputDimensions) {
                                var od = outputDimensions[i];
                                if (od.out == pdep.out && od.odim == pdep.odim) {
                                    pdep.$$output = od;
                                    break;
                                }
                            }
                        } else {
                            pdep.func = 'values';
                        }
                    }
                });
            });

            Logger.info("After fixup, inputs", recipe.inputs, outputDimensions, outputDimensionsWithNow);
            return [outputDimensions, outputDimensionsWithNow];
        },

        /* Rewrite the pdep in serializable form */
        prepareForSerialize : function(pdep, notEdited) {
            var ret = angular.copy(pdep);
            if (ret.$$output) {
                if (ret.$$output.odim) {
                    ret.odim = ret.$$output.odim;
                } else {
                    delete ret.odim;
                }
                if (ret.$$output.out) {
                    ret.out = ret.$$output.out;
                } else {
                    delete ret.out;
                }
                //ret.$$output = null;
            } else if (neverNeedsOutput(ret) || mayWorkWithoutOutput(ret)) {
            } else {
                if (!notEdited) { // under edition => should have the $$output
                    Logger.warn("Saving incomplete pdep", ret);
                }
            }
            if (ret.func != 'values') delete ret.values;
            if (ret.func == 'values' || ret.func == "latest_available" || ret.func == "all_available") {
                delete ret.odim; // Meaningless
            }
            // convert params to string
            if (ret.params) {
                angular.forEach(ret.params, function(value, key) {ret.params[key] = value == null ? null : value.toString();});
            }
            //console.info("Prepare for serialize", pdep, "gives", ret);
            return ret;
        },

        prepareRecipeForSerialize : function(recipe, notEdited) {
            RecipesUtils.getFlatInputsList(recipe).forEach(function(input){
                if (input.deps != null) {
                    input.deps = input.deps.map(function(p) {return svc.prepareForSerialize(p, notEdited);});
                }
            });
            return recipe;
        },

        test : function(recipe, pdepInputRef, pdep, errorScope) {
            var recipeSerialized = angular.copy(recipe);
            svc.prepareRecipeForSerialize(recipeSerialized);
            /* The result of the test is directly written in pdep.$$testResult */
            DataikuAPI.flow.recipes.generic.pdepTest(recipeSerialized,  pdepInputRef, svc.prepareForSerialize(pdep)).success(function(data) {
                pdep.$$testResult = data;
            }).error(setErrorInScope.bind(errorScope));
        },

        timeRangeFromModes : [
            ["RELATIVE_OFFSET", "Offset to reference time"],
            ["FIXED_DATE", "Fixed date"]
        ],
        timeRangeGranularities : [
            ["YEAR", "Year(s)"],
            ["MONTH", "Month(s)"],
            ["DAY", "Day(s)"],
            ["HOUR", "Hour(s)"]
        ],
        depFunctions : [
            ['equals', 'Equals'],
            ['time_range', "Time Range"],
            ['current_week', "Since beginning of week"],
            ['current_month', "Since beginning of month"],
            ['whole_month', "Whole month"],
            ['values', "Explicit values"],
            ['latest_available', 'Latest available'],
            ['all_available', 'All available'],
            ['custom_python','Python dependency function'],
            ['sliding_days', "Sliding days (deprecated, use Time Range)"],

        ],
    }
    return svc;
});

})();
(function(){
'use strict';

var app = angular.module('dataiku.recipes');


app.controller("VisualRecipeEditorController", function ($scope, $stateParams, $q, $controller, DataikuAPI, PartitionDeps, CreateModalFromTemplate,
               ComputableSchemaRecipeSave, Dialogs, DKUtils, DatasetUtils, Logger) {
    $controller("_RecipeWithEngineBehavior", {$scope:$scope});
    var visualCtrl = this;

    $scope.hooks.preRunValidate = function() {
        var deferred = $q.defer();
        $scope.hooks.updateRecipeStatus().then(function(data) {
            if (data && data.invalid) {
                Logger.info("preRunValidate failed",data)
                Dialogs.confirm($scope, "Recipe contains errors", "The recipe contains errors. Are you sure you want to run it?").then(function() {
                    deferred.resolve({ok: true});
                }, function(){
                    deferred.reject("Validation failed");
                });
            } else {
                deferred.resolve({ok: true});
            }
        },
        function(data){
            Logger.error("Error when getting status", data);
            setErrorInScope.bind($scope);
            deferred.reject("Validation failed");
        });
        return deferred.promise;
    };

    var paramsSavedOnServer = undefined;
    visualCtrl.saveServerParams = function() {
        paramsSavedOnServer = angular.copy($scope.hooks.getPayloadData());
    }

    var superRecipeIsDirty = $scope.hooks.recipeIsDirty;
    $scope.hooks.recipeIsDirty = function() {
        var currentPayload = $scope.hooks.getPayloadData();
        if (currentPayload) {
            currentPayload = angular.fromJson(currentPayload);
        }
        var savedPayload = paramsSavedOnServer;
        if (savedPayload) {
            savedPayload = angular.fromJson(savedPayload);
        }
        return superRecipeIsDirty() || !angular.equals(currentPayload, savedPayload);
    };

    $scope.hooks.save = function() {
        var deferred = $q.defer();
        var recipeSerialized = angular.copy($scope.recipe);
        PartitionDeps.prepareRecipeForSerialize(recipeSerialized);
        var payloadData = $scope.hooks.getPayloadData();
        ComputableSchemaRecipeSave.handleSave($scope, recipeSerialized, payloadData, deferred);
        return deferred.promise.then(visualCtrl.saveServerParams);
    };

    $scope.showChangeInputModal = function(virtualInputIndex) {
        var newScope = $scope.$new();
        newScope.virtualInputIndex = virtualInputIndex;
        CreateModalFromTemplate("/templates/recipes/visual-recipes-fragments/visual-recipe-change-input-modal.html", newScope);
    };

    $scope.convert = function(type, label) {
        Dialogs.confirm($scope, "Convert to " + label + " recipe",
                        "Converting the recipe to "+label+" will enable you to edit the query, but you will not be able to use the visual editor anymore."+
                        "<br/><strong>This operation is irreversible.</strong>")
        .then(function() {
            var payloadData = $scope.hooks.getPayloadData();
            var recipeSerialized = angular.copy($scope.recipe);
            PartitionDeps.prepareRecipeForSerialize(recipeSerialized);
            $scope.hooks.save().then(function() {
                DataikuAPI.flow.recipes.visual.convert($stateParams.projectKey, recipeSerialized, payloadData, type)
                .success(function(data) {
                    DKUtils.reloadState();
                }).error(setErrorInScope.bind($scope));
            });
        });
    };

    $scope.showSQLModal = function(){
        var newScope = $scope.$new();
        newScope.convert = $scope.convert;
        newScope.uiState = {currentTab: 'query'};
        $scope.hooks.updateRecipeStatus(false, true).then(function(){
        	// get the latest values, not the ones of before the updatestatus call
        	newScope.query = $scope.recipeStatus.sql;
        	newScope.engine = $scope.recipeStatus.selectedEngine.type;
        	newScope.executionPlan = $scope.recipeStatus.executionPlan;
            newScope.cannotConvert = $scope.hasMultipleOutputs();
            CreateModalFromTemplate("/templates/recipes/fragments/sql-modal.html", newScope);
        });
    };

    $scope.hasMultipleOutputs = function() {
        return $scope.recipeStatus.sqlWithExecutionPlanList && $scope.recipeStatus.sqlWithExecutionPlanList.length > 1;
    };

    $scope.selectOutputForSql = outputName => {
        let sqlWithExecutionPlan = $scope.recipeStatus.sqlWithExecutionPlanList.find(s => s.outputName === outputName);
        if (sqlWithExecutionPlan === undefined) {
            sqlWithExecutionPlan = $scope.recipeStatus.sqlWithExecutionPlanList[0];
        }
        $scope.selectedOutputName = sqlWithExecutionPlan.outputName;
        $scope.recipeStatus.sql = sqlWithExecutionPlan.sql;
        $scope.recipeStatus.executionPlan = sqlWithExecutionPlan.executionPlan;
    };

    $scope.getSingleInputName = function() {
        if ($scope.recipe && $scope.recipe.inputs && $scope.recipe.inputs.main && $scope.recipe.inputs.main.items.length) {
            return $scope.recipe.inputs.main.items[0].ref;
        }
    };

    $scope.getColumns = function(datasetName) {
        var schema = DatasetUtils.getSchema($scope, datasetName || $scope.getSingleInputName());
        return schema ? schema.columns : [];
    };

    $scope.getColumnNames = function(datasetName) {
        return $scope.getColumns(datasetName).map(function(col) {return col.name});
    };

    $scope.getColumn = function(datasetName, name) {
        return $scope.getColumns(datasetName).filter(function(col) {return col.name==name})[0];
    };

    $scope.datasetHasColumn = function(datasetName, columnName) {
        return !!$scope.getColumn(datasetName, columnName);
    };

    $scope.columnTypes = [
        {name:'TINYINT',label:'tinyint (8 bit)'},
        {name:'SMALLINT',label:'smallint (16 bit)'},
        {name:'INT',label:'int'},
        {name:'BIGINT',label:'bigint (64 bit)'},
        {name:'FLOAT',label:'float'},
        {name:'DOUBLE',label:'double'},
        {name:'BOOLEAN',label:'boolean'},
        {name:'STRING',label:'string'},
        {name:'DATE',label:'date'},
        {name:'ARRAY',label:'array<...>'},
        {name:'MAP',label:'map<...>'},
        {name:'OBJECT',label:'object<...>'}
    ];

});


app.controller("ChangeRecipeVirtualInputController", function ($scope, DataikuAPI, $stateParams, DatasetUtils, RecipesUtils) {
    DatasetUtils.listDatasetsUsabilityInAndOut($stateParams.projectKey, "join").then(function(data){
        $scope.availableInputDatasets = data[0];
    });
    $scope.replacement = {};

    $scope.$watch("replacement.name", function(nv) {
        if (nv) {
            var payload = $scope.hooks.getPayloadData();
            var newInputName = nv;
            delete $scope.replacementImapact;
            DataikuAPI.flow.recipes.visual.testInputReplacement($stateParams.projectKey, $scope.recipe, payload, $scope.virtualInputIndex, newInputName).then(function(response){
                $scope.replacementImapact = response.data;
            });
        }
    })

    $scope.ok = function(dismiss) {
        // Add dataset to recipes
        if (RecipesUtils.getInput($scope.recipe, "main", $scope.replacement.name) == null) {
            RecipesUtils.addInput($scope.recipe, "main", $scope.replacement.name);
        }

        $scope.onInputReplaced($scope.replacement, $scope.virtualInputIndex);

        dismiss();
        $scope.hooks.updateRecipeStatus();
    }
});

app.directive('fieldsForFilterDesc', function() {
    return {
        restrict: 'A',
        scope: false,
        link : function($scope, element, attrs) {
            $scope.distinctOptionDisabled=true
            var updateFields = function() {
                if ($scope.params == null || $scope.recipe == null || $scope.computablesMap == null) {
                    return;
                }
                $scope.filterDesc = $scope.params.preFilter;
                $scope.dataset = $scope.recipe.inputs['main'].items[0].ref;
                $scope.schema = $scope.computablesMap[$scope.recipe.inputs['main'].items[0].ref].dataset.schema;
            };
            $scope.$watch('params', updateFields);
            $scope.$watch('recipe', updateFields, true);
            $scope.$watch('computablesMap', updateFields); // not deep => won't react to changes, but hopefully watching the recipe is enough
        }
    };
});

app.directive('baseTypeSelector', function($timeout, ListFilter) {
    return {
        restrict: 'A',
        scope: {
            schemaColumn: '='
        },
        templateUrl: '/templates/recipes/visual-recipes-fragments/base-type-selector.html',
        link : function($scope, element, attrs) {
            $scope.columnTypes = [
                                  {name:'tinyint',label:'tinyint (8 bit)'},
                                  {name:'smallint',label:'smallint (16 bit)'},
                                  {name:'int',label:'int'},
                                  {name:'bigint',label:'bigint (64 bit)'},
                                  {name:'float',label:'float'},
                                  {name:'double',label:'double'},
                                  {name:'boolean',label:'boolean'},
                                  {name:'string',label:'string'},
                                  {name:'date',label:'date'},
                                  {name:'array',label:'array<...>'},
                                  {name:'map',label:'map<...>'},
                                  {name:'object',label:'object<...>'}
                              ];
            $scope.select = function(columnType) {
                $scope.schemaColumn.type = columnType.name;
            };
        }
    };
});

app.directive('aggregateTypeEditor', function() {
    return {
        restrict: 'A',
        scope: {
            schemaColumn: '='
        },
        replace: true,
        templateUrl: '/templates/recipes/visual-recipes-fragments/aggregate-type-editor.html',
        link : function($scope, element, attrs) {
            $scope.addObjectField = function() {
                $scope.schemaColumn.objectFields = $scope.schemaColumn.objectFields || [];
                $scope.schemaColumn.objectFields.push({name:'', type:'string'});
            };
            var ensureSubFields = function() {
                if ($scope.schemaColumn.type == 'array') {
                    $scope.schemaColumn.arrayContent = $scope.schemaColumn.arrayContent || {name:'', type:'string'};
                }
                if ($scope.schemaColumn.type == 'map') {
                    $scope.schemaColumn.mapKeys = $scope.schemaColumn.mapKeys || {name:'', type:'string'};
                    $scope.schemaColumn.mapValues = $scope.schemaColumn.mapValues || {name:'', type:'string'};
                }
                if ($scope.schemaColumn.type == 'object') {
                    $scope.schemaColumn.objectFields = $scope.schemaColumn.objectFields || [];
                }
            };
            $scope.$watch('schemaColumn.type', ensureSubFields);
        }
    };
});

})();
(function() {
    'use strict';
    var app = angular.module('dataiku.recipes');

    app.controller("GroupingRecipeCreationController", function($scope, Fn, $stateParams, DataikuAPI, $controller) {
        $scope.recipeType = "grouping";
        $controller("SingleOutputDatasetRecipeCreationController", {$scope:$scope});

        $scope.autosetName = function() {
            if ($scope.io.inputDataset && $scope.io.targetVariable) {
                var niceInputName = $scope.io.inputDataset.replace(/[A-Z]*\./,"");
                var niceTargetVariable = $scope.io.targetVariable.replace(/[^\w ]+/g,"").replace(/ +/g,"_");
                $scope.maybeSetNewDatasetName(niceInputName + "_by_" + niceTargetVariable);
            }
        };

        $scope.getCreationSettings = function () {
            return {groupKey: $scope.io.targetVariable};
        };

        var superFormIsValid = $scope.formIsValid;
        $scope.formIsValid = function() {
            return !!(superFormIsValid() && $scope.io.targetVariable !== undefined);
        };
        $scope.showOutputPane = function() {
            return !!($scope.io.inputDataset && $scope.io.targetVariable !== undefined);
        };

        $scope.$watch("io.targetVariable", Fn.doIfNv($scope.autosetName));
    });


    app.controller("GroupingRecipeController", function($scope, $stateParams, DataikuAPI, $q, Dialogs, ContextualMenu, PartitionDeps, $rootScope,
     $timeout, DKUtils, Expressions, Logger, $controller,  RecipesUtils, Fn, DatasetUtils) {
        var visualCtrl = $controller('VisualRecipeEditorController', {$scope: $scope}); //Controller inheritance
        this.visualCtrl = visualCtrl;
        $scope.aggregateUsabilityFlag = "usableInGroup";
        let contextProjectKey = $scope.context && $scope.context.projectKey ? $scope.context.projectKey:$stateParams.projectKey;

        $scope.hooks.getPayloadData = function () {
            return angular.toJson($scope.params);
        };

        $scope.hooks.updateRecipeStatus = function(forceUpdate, exactPlan) {
            var payload = $scope.hooks.getPayloadData();
            if (!payload) return $q.reject("payload not ready");
            var deferred = $q.defer();
            $scope.updateRecipeStatusBase(forceUpdate, payload, {reallyNeedsExecutionPlan: exactPlan, exactPlan: exactPlan}).then(function() {
                // $scope.recipeStatus should have been set by updateRecipeStatusBase
                if (!$scope.recipeStatus) return deferred.reject();
                var outputSchema = $scope.recipeStatus.outputSchema;
                var outputSchemaBO = $scope.recipeStatus.outputSchemaBeforeOverride;
                if (outputSchema) {
                    $scope.params.postFilter.$status = $scope.params.postFilter.$status || {};
                    $scope.params.postFilter.$status.schema = outputSchemaBO;
                    // override handling:

                    $scope.params.outputColumnNameOverrides = $scope.params.outputColumnNameOverrides || {};
                    var columnsAO = outputSchema.columns; // after override
                    var columnsBO = (outputSchemaBO&&outputSchemaBO.columns) ? outputSchemaBO.columns : columns; // before override

                    for (var i in columnsAO) {
                        if (columnsAO[i].name != columnsBO[i].name) {$scope.params.outputColumnNameOverrides[columnsBO[i].name] = columnsAO[i].name;}
                        columnsAO[i].$beforeOverride = columnsBO[i].name;
                        columnsAO[i].name = $scope.params.outputColumnNameOverrides[columnsBO[i].name] || columnsBO[i].name;
                    }
                    resyncWithEngine();
                }
                deferred.resolve($scope.recipeStatus);
            });
            return deferred.promise;
        };

        /******  overrides *****/
        $scope.updateColumnNameOverride = function(column) {
            if (column.$beforeOverride != column.name) {
                $scope.params.outputColumnNameOverrides[column.$beforeOverride] = column.name;
            } else {
                delete $scope.params.outputColumnNameOverrides[column.$beforeOverride];
            }
        };


        /******  filters  ******/

        function validateFilters() {
            if (!$scope.params) return;//not ready
            var inputRef = RecipesUtils.getSingleInput($scope.recipe, "main").ref
            var inputSchema = $scope.computablesMap[inputRef].dataset.schema
            validateFilter($scope.params.preFilter, inputSchema);
            validateFilter($scope.params.postFilter);
        }

        function validateFilter(filterDesc, schema) {
            var deferred = $q.defer();
            if (!filterDesc || !filterDesc.enabled) return;
            if (angular.isUndefined(filterDesc.expression)) return;
            Expressions.validateExpression(filterDesc.expression, schema)
                .success(function(data) {
                    if (data.ok && $scope.mustRunInDatabase && !data.fullyTranslated) {
                        data.ok = false;
                    }
                    filterDesc.$status = data;
                    filterDesc.$status.validated = true;
                    deferred.resolve(data);
                })
                .error(function(data) {
                    setErrorInScope.bind($scope);
                    deferred.reject('Error while validating filter');
                });
            return deferred.promise;
        };

        /* callback given to the filter module */
        $scope.onFilterUpdate = $scope.updateRecipeStatusLater;

        /****** computed columns ********/
        function computedColumnListUpdated(computedColumns) {
            $scope.params.computedColumns = angular.copy(computedColumns);
            resyncWithInputSchema();
            $scope.updateRecipeStatusLater();
        }

        /* callback given to the computed columns module */
        $scope.onComputedColumnListUpdate = computedColumnListUpdated;

        $scope.getColumnsWithComputed = function() {
            if (!$scope.uiState.columnsWithComputed) {
                var columns = [].concat($scope.getColumns());
                for (var i = 0; i < (($scope.params || {}).computedColumns || []).length; i++) {
                    var computedCol = $scope.params.computedColumns[i];
                    // do not add computed columns if they are blank
                    if (computedCol.name && columns.map(function(col){return col.name}).indexOf(computedCol.name) == -1) {
                        columns.push({
                            name: computedCol.name,
                            type: computedCol.type
                        });
                    }
                }
                $scope.uiState.columnsWithComputed = columns;
            }
            return $scope.uiState.columnsWithComputed;
        };

        /******  grouping key/values  ********/

        $scope.removeGroupKey = function(col) {
            var idx = $scope.params.keys.indexOf(col);
            if (idx > - 1) {
                $scope.params.keys.splice(idx, 1);
            }
            if (col.column) {
                var presentColumns = $scope.params.values.map(Fn.prop('column'));
                presentColumns.push(col.column);
                var insertIndex = $scope.listColumnsForCumstomColumnsEditor()
                    .filter(Fn.inArray(presentColumns)).indexOf(col.column);
                $scope.params.values.splice(Math.max(insertIndex,0), 0, col);
            }
        };

        $scope.addGroupKey = function(col) {
            if (!col) {
                return;
            }
            const idx = $scope.params.values.map(Fn.prop('column')).indexOf(col.column);
            if (idx === -1) {
                return;
            }
            const key = angular.copy(col);
            key.$selected = false;
            $scope.params.keys.push(key);
            $scope.params.values.splice(idx, 1);
            $scope.hooks.updateRecipeStatus();
        };
        $scope.groupKeyFilter = {};

        $scope.addCustomValue = function(){
            var newVal = {
                customName : userFriendlyTransmogrify('custom_aggr', $scope.params.values.filter(function(v) {return v.column == null;}), 'customName', '_', true),
                customExpr : ''
            }
            $scope.params.values.push(newVal);

            //activate edit mode and focus name field
            $timeout(function(){
                var el = angular.element('[computed-column-editor]').last();
                $timeout(function(){ $('.name-editor', el).focus(); });
                $scope.$apply();
            });
        };
        // /!\ Watch out /!\
        // params comes from a json.parse : if multiple calls are made
        // a $watch(true) won't trigger the copy to realValues, thus makeing object refs
        // used in frontend disconnected from actual data
        $scope.$watchCollection("params.values", function(nv) {
            $scope.realValues = getRealValues();
        });
        var getRealValues = function() {
            var realValues = (!$scope.params||!$scope.params.values) ? [] : $scope.params.values.filter(function(val) { return !!val.column });
            var realValuesNames = realValues.map(function(rv){return rv.column});
            var newRealValues = [];
            var i;
            var oldRVIdx;
            var columns = $scope.getColumns();
            for (i = 0; i < columns.length; i++) {
                var col = columns[i];
                if (col.name && col.name.length > 0) {
                    oldRVIdx = realValuesNames.indexOf(col.name);
                    if (oldRVIdx >= 0) {
                        newRealValues.push(realValues[oldRVIdx]);
                    }
                }
            }
            var newRealValuesNames = newRealValues.map(function(rv){return rv.column});
            var computedColumns = (($scope.params || {}).computedColumns || []);
            for (i = 0; i < computedColumns.length; i++) {
                var compCol = computedColumns[i];
                // make sure that there is no previous value named the same
                if (compCol.name && compCol.name.length > 0 && newRealValuesNames.indexOf(compCol.name) == -1) {
                    oldRVIdx = realValuesNames.indexOf(compCol.name);
                    if (oldRVIdx >= 0) {
                        newRealValues.push(realValues[oldRVIdx]);
                    }
                }
            }
            return newRealValues;
        }
        $scope.getCustomValues = function() {
            if (!$scope.params||!$scope.params.values) { return [] }
            return $scope.params.values.filter(function(val) { return !val.column });
        }

        //This lists the input dataset column names
        $scope.listColumnsForCumstomColumnsEditor = function(){
            return $scope.getColumns().map(function (col) {
                return col.name;
            });
        };

        /********  aggregations selector *******/

        $scope.aggregationTypes =  [
            {name: "countDistinct", opType:"DISTINCT", label: "Distinct", tooltip: "Count distinct values"},
            {name: "min", label: "Min"},
            {name: "max", label : "Max"},

            {name: "avg", label: "Avg"},
            {name: "sum", label: "Sum"},
            {name: "concat", label: "Concat", tooltip: "Concatenate values in one string"},
            {name: "stddev", label: "Std. dev."},

            {name: "count", label: "Count", tooltip: "Count non-null"},
            {name: "first", label: "First"},
            {name: "last", label: "Last"},
        ];

        $scope.columnHasSomeComputation = function (col) {
            var ret = false;
            $scope.aggregationTypes.forEach(function(agg) {
                ret = ret || col[agg.name];
            });
            return ret;
        };

        // Checks if we can perform the specified aggregation on column col
        $scope.colCanAggr = function(col, agg) {
            if (!$scope.engineCanAggr(agg)) return false;
            var opType = agg.opType || agg.name.toUpperCase();
            var aggregability = $scope.recipeStatus.selectedEngine.aggregabilities[opType];
            var typeCategory = {"string":"strings",
                                "date":"dates",
                                "boolean":"booleans",
                                "tinyint":"numerics",
                                "smallint":"numerics",
                                "int":"numerics",
                                "bigint":"numerics",
                                "float":"numerics",
                                "double":"numerics"
                            }[col.type];
            return aggregability && typeCategory && aggregability[typeCategory];
        };

        $scope.engineCanAggrType = function(opType) {
            if (!$scope.recipeStatus || !$scope.recipeStatus.selectedEngine) return false;
            var aggregability = $scope.recipeStatus.selectedEngine.aggregabilities[opType];
            return aggregability && aggregability[$scope.aggregateUsabilityFlag];
        };
        $scope.engineCanAggr = function(agg) {
            if (!$scope.recipeStatus || !$scope.recipeStatus.selectedEngine) return false;
            var opType = agg.opType || agg.name.toUpperCase();
            var aggregability = $scope.recipeStatus.selectedEngine.aggregabilities[opType];
            return aggregability && aggregability[$scope.aggregateUsabilityFlag];
        };

        $scope.initOrderColumn = function(col) {
            var cols = $scope.getColumns();
            col.orderColumn = col.orderColumn || (cols && cols.length ? cols[0].name : undefined);
        };
        // call this in a ng-init when toggling some aggregate triggers the need for more setup. Otherwise
        // the get-status call might exclude the engine because of incomplete setup (typically: the ordercolumn
        // for first/last
        $scope.initColumnExtraFields = function(column) {
            $scope.initOrderColumn(column);
            column.concatSeparator = column.concatSeparator != null ? column.concatSeparator : ',';
            column.concatDistinct = column.concatDistinct || false;
        };

        $scope.aggregation = {'all':{},'some':{},'none':{},'disabled':{}};

        function filterUnused(vals) {
            return vals.filter(function(val){
                return !$scope.uiState.hideUseless || $scope.columnHasSomeComputation(val);
            });
        }

        $scope.selection = {
            'customFilter':filterUnused,
            'customFilterWatch':'uiState.hideUseless',
        }

        $scope.recomputeAggregationStates = function(cols) {
            for (var k in $scope.aggregation) {$scope.aggregation[k]={};}

            cols.forEach(function(column){
                $scope.aggregationTypes.forEach(function(agg) {
                    var colEnabled = $scope.colCanAggr(column, agg);
                    $scope.aggregation.all[agg.name] =
                        ($scope.aggregation.all[agg.name] == undefined ? true : $scope.aggregation.all[agg.name])
                        && (colEnabled ? column[agg.name] : false);
                    $scope.aggregation.some[agg.name] =
                        ($scope.aggregation.some[agg.name] || false)
                        || (colEnabled ? column[agg.name] : false);
                    $scope.aggregation.disabled[agg.name] =
                        ($scope.aggregation.disabled[agg.name] || false)
                        || colEnabled;
                });
            });
            angular.forEach($scope.aggregationTypes,function(agg){
                $scope.aggregation.disabled[agg.name] = !$scope.aggregation.disabled[agg.name];
                $scope.aggregation.some[agg.name] = $scope.aggregation.some[agg.name] && !$scope.aggregation.all[agg.name];
                $scope.aggregation.none[agg.name] = !$scope.aggregation.some[agg.name] && !$scope.aggregation.all[agg.name];
            });
        }

        // Apply/disapply aggregation to all selected columns
        $scope.massAction = function(agg, selectedObjects){
            selectedObjects.forEach(function(val) {
                if ($scope.colCanAggr(val, agg)) {
                    val[agg.name] = $scope.aggregation.all[agg.name];
                }
            });
            // run the orderColumn init before updating the status, otherwise the ng-init will run while the new status is
            // computed and will be overwritten
            if (['first', 'last'].indexOf(agg.name) >= 0) {
                selectedObjects.forEach(function(val) {
                    $scope.initOrderColumn(val);
                });
            }
            $scope.aggregation.some[agg.name] = false;
            $scope.aggregation.none[agg.name] = !$scope.aggregation.all[agg.name];
            $scope.hooks.updateRecipeStatus();
        }

        $scope.massUseAsKeys = function() {
            // add selected values to keys
            $scope.selection.selectedObjects.forEach(function(val) {
                var key = angular.copy(val);
                key.$selected = false;
                $scope.params.keys.push(key);
            });
            //remove from values list
            $scope.params.values = $scope.selection.allObjects.filter(function(val) {
                return !val.$selected;
            });
            $scope.hooks.updateRecipeStatus();
        };

        /********  general init  ********/

        function loadParamsFromScript(scriptData) {
            if (!scriptData) return;
            $scope.params = JSON.parse(scriptData);
            $scope.params.preFilter = $scope.params.preFilter || {};
            $scope.params.computedColumns = $scope.params.computedColumns || [];
            $scope.params.postFilter = $scope.params.postFilter || {};
            $scope.params.outputColumnNameOverrides = $scope.params.outputColumnNameOverrides || {};

            $scope.uiState.computedColumns = angular.copy($scope.params.computedColumns);

            //keep params for dirtyness detection
            visualCtrl.saveServerParams();

            // update recipe according to current schema
            resyncWithInputSchema();

            // update aggragation according to engine capabilities
            resyncWithEngine();

            //Add column types in the grouping values & keys, it will make things easier
            var colsByName = {};
            $scope.getColumns().forEach(function(col){
                colsByName[col.name] = col;
            });
            $scope.params.values.forEach(function(gv){
                if (colsByName[gv.column]) {
                    gv.type = colsByName[gv.column].type;
                }
            });
            $scope.params.keys.forEach(function(gv){
                if (colsByName[gv.column]) {
                    gv.type = colsByName[gv.column].type;
                }
            });
        }

        function resyncWithInputSchema() {
            // in case the dataset schema changed since the recipe creation/last edition
            // reset the calculated columns with computed to force refresh
            $scope.uiState.columnsWithComputed = undefined;
            var inputColumnsWithComputed = $scope.getColumnsWithComputed();
            var inputColumnsWithComputedNames = inputColumnsWithComputed.map(function(col){return col.name});

            var keys = {};
            (($scope.params || {}).keys || []).forEach(function(col, i) {
                col.$$originalIndex = i;
                if (col.column && inputColumnsWithComputedNames.indexOf(col.column) >= 0) {
                    keys[col.column] = col;
                }
            });
            var values = {}, customValues = [];
            (($scope.params || {}).values || []).forEach(function(col) {
                if (col.column) {
                    if (inputColumnsWithComputedNames.indexOf(col.column) >= 0) {
                        values[col.column] = col;
                    }
                } else {
                    customValues.push(col);
                }
            });

            var newKeys = [];
            var newValues = [];
            inputColumnsWithComputed.forEach(function(col){
                var newCol;
                if (keys[col.name]) {
                    newCol = keys[col.name];
                } else if (values[col.name]) {
                    newCol = values[col.name];
                } else {
                    //this is apparently a new column in the dataset. Add an empty value
                    //put everything to false to avoid dirtyness on check/uncheck
                    newCol = {
                        column: col.name,
                        type: col.type
                    };
                }
                angular.extend(newCol, {
                    column: col.name,
                    type: col.type
                });
                $scope.aggregationTypes.forEach(function(agg){
                    newCol[agg.name] = newCol[agg.name] || false;
                });
                if (keys[col.name]) {
                    newKeys.push(newCol);
                } else {
                    newValues.push(newCol);
                }
            });

            customValues.forEach(function(val){
                newValues.push(val);
            });

            // Sorting the keys by origin index to preserve pre-existing order
            newKeys.sort((a, b) => a.$$originalIndex - b.$$originalIndex);

            // remove outdated columns (keep computed columns or column that is in the schema)
            $scope.params = $scope.params || {};
            $scope.params.keys = newKeys;
            $scope.params.values = newValues;

            // call the callback if it exists
            if ($scope.onResyncWithInputSchema) {
                $scope.onResyncWithInputSchema();
            }
        }

        function resyncWithEngine() {
            if (!$scope.recipeStatus || !$scope.recipeStatus.selectedEngine) return; // no aggregability available yet, let's not jump to conclusions and deactivate everything
            //prevent inconsistent aggregations (ex: avg selected for number then type changed to string)
            $scope.params.values.forEach(function(val){
                $scope.aggregationTypes.forEach(function(agg){
                    if (val[agg.name] && !$scope.colCanAggr(val, agg)) {
                        val[agg.name] = false;
                    }
                });
            });
            if ($scope.engineCanAggrType('CONCAT_DISTINCT') != true) {
                $scope.params.values.forEach(function(val){
                    val.concatDistinct = false; // otherwise you never get to click on the checkbox
                });
            }
            if ($scope.engineCanAggrType('FIRST_NOTNULL') != true) {
                $scope.params.values.forEach(function(val){
                    val.firstLastNotNull = false; // otherwise you never get to click on the checkbox
                });
            }
        }

        function onScriptChanged(nv, ov) {
             if (nv) {
                loadParamsFromScript($scope.script.data);
                DKUtils.reflowNext();
                DKUtils.reflowLater();
                $scope.hooks.updateRecipeStatus();
            }
        }

        $scope.uiState = {
            currentStep: 'group',
            outputColumnNamesOverridable: true,
            computedColumns: []
        };

        $scope.hooks.onRecipeLoaded = function(){
            Logger.info("On Recipe Loaded");
            validateFilters();
            $scope.$watch("script.data", onScriptChanged, true); // this will call $scope.hooks.updateRecipeStatus when ready
            $scope.$watchCollection("recipe.inputs.main.items", function() {
                DatasetUtils.updateRecipeComputables($scope, $scope.recipe, $stateParams.projectKey, contextProjectKey)
                    .then(_ => resyncWithInputSchema());
            });
        };

        $scope.$watch('topNav.tab',function(nv){
            if (nv == 'settings') {
                $timeout(function() {
                    $scope.$broadcast('redrawFatTable');
                });
            }
        });

        $scope.enableAutoFixup();
        $scope.specificControllerLoadedDeferred.resolve();
    });
})();

(function() {
    'use strict';
    var app = angular.module('dataiku.recipes');

    app.controller("DistinctRecipeCreationController", function($scope, $controller) {
        $scope.recipeType = "distinct";
        $controller("SingleOutputDatasetRecipeCreationController", {$scope:$scope});

        $scope.autosetName = function() {
            if ($scope.io.inputDataset) {
                var niceInputName = $scope.io.inputDataset.replace(/[A-Z]*\./,"");
                $scope.maybeSetNewDatasetName(niceInputName + "_distinct");
            }
        };
    });


    app.controller("DistinctRecipeController", function($scope, $stateParams, DataikuAPI, $q, Dialogs, ContextualMenu, PartitionDeps, $rootScope,
     $timeout, DKUtils, Expressions, Logger, $controller, DatasetUtils, RecipesUtils) {
        var visualCtrl = $controller('VisualRecipeEditorController', {$scope: $scope}); //Controller inheritance
        this.visualCtrl = visualCtrl;

        let contextProjectKey = $scope.context && $scope.context.projectKey ? $scope.context.projectKey:$stateParams.projectKey;
        /****** distinct column selection *****/
        $scope.selectLine = function(event, col, ignore) {
            event.preventDefault();
            var hasLastSelection = $scope.uiState.columnStatus.filter(function(c) {
                return c.ignore == ignore && !!c.$lastSelection;
            }).length > 0 ;
            if (event.shiftKey && hasLastSelection) {
                var selecting = false;
                for (var i = 0; i < $scope.uiState.columnStatus.length; i++) {
                    var c = $scope.uiState.columnStatus[i];
                    if (c.ignore != ignore) {
                        continue;
                    }
                    var bound = !!c.$lastSelection || c.name === col.name;
                    var firstBound = !selecting && bound;
                    var lastBound = !!selecting && bound;
                    if (firstBound) {
                        selecting = true;
                        c.$selected = true;
                    }
                    c.$selected = selecting;
                    if (lastBound) {
                        selecting = false;
                    }
                }
            } else {
                // refresh the last clicked item
                $scope.uiState.columnStatus
                        .filter(function(c) {
                            return c.ignore == ignore;
                        }).forEach(function(c) {
                            c.$lastSelection = c.name === col.name;
                        });
                // handle meta/ctrl click or normal click
                if (event.metaKey || event.ctrlKey) {
                    col.$selected = !col.$selected;
                } else {
                    $scope.uiState.columnStatus
                        .filter(function(c) {
                            return c.ignore == ignore;
                        }).forEach(function(c) {
                            c.$selected = c.name === col.name;
                        });
                }
            }
        };

        function assignIgnoreSelected(ignore, selected) {
            return function(col) {
                col.ignore = ignore;
                col.$selected = selected;
                col.$lastSelection = false;
            };
        }

        $scope.removeAllDistinctColumns = function() {
            if (!$scope.uiState.columnStatus) {
                return;
            }
            $scope.uiState.columnStatus.forEach(assignIgnoreSelected(true, false));
        };
        $scope.addAllDistinctColumns = function() {
            if (!$scope.uiState.columnStatus) {
                return;
            }
            $scope.uiState.columnStatus.forEach(assignIgnoreSelected(false, false));
        };
        $scope.removeDistinctColumns = function(col) {
            if (col) {
                assignIgnoreSelected(true, false)(col);
            } else if ($scope.uiState.columnStatus) {
                $scope.uiState.columnStatus
                    .filter(function(col) {
                        return !col.ignore && col.$selected;
                    }).forEach(assignIgnoreSelected(true, false));
            }
        };
        $scope.addDistinctColumns = function(col) {
            if (col) {
                assignIgnoreSelected(false, false)(col);
            } else if ($scope.uiState.columnStatus) {
                $scope.uiState.columnStatus
                    .filter(function(col) {
                        return col.ignore && col.$selected;
                    }).forEach(assignIgnoreSelected(false, false));
            }
        };

        /****** recipe related ******/
        $scope.hooks.getPayloadData = function() {
            return angular.toJson($scope.params);
        };

        $scope.hooks.updateRecipeStatus = function(forceUpdate, exactPlan) {
            var payload = $scope.hooks.getPayloadData();
            if (!payload) {
                return $q.reject("payload not ready");
            }
            var deferred = $q.defer();
            $scope.updateRecipeStatusBase(forceUpdate, payload, {reallyNeedsExecutionPlan: exactPlan, exactPlan: exactPlan}).then(function() {
                // $scope.recipeStatus should have been set by updateRecipeStatusBase
                if (!$scope.recipeStatus) {
                    return deferred.reject();
                }
                var outputSchema = $scope.recipeStatus.outputSchema;
                var outputSchemaBO = $scope.recipeStatus.outputSchemaBeforeOverride;
                if (outputSchema) {
                    $scope.params.postFilter.$status = $scope.params.postFilter.$status || {};
                    $scope.params.postFilter.$status.schema = outputSchemaBO;
                    // override handling:

                    $scope.params.outputColumnNameOverrides = $scope.params.outputColumnNameOverrides || {};
                    var columnsAO = outputSchema.columns; // after override
                    var columnsBO = (outputSchemaBO && outputSchemaBO.columns) ? outputSchemaBO.columns : columns; // before override

                    for (var i in columnsAO) {
                        if (columnsAO[i].name != columnsBO[i].name) {
                            $scope.params.outputColumnNameOverrides[columnsBO[i].name] = columnsAO[i].name;
                        }
                        columnsAO[i].$beforeOverride = columnsBO[i].name;
                        columnsAO[i].name = $scope.params.outputColumnNameOverrides[columnsBO[i].name] || columnsBO[i].name;
                    }
                }
                deferred.resolve($scope.recipeStatus);
            });
            return deferred.promise;
        };

        /******  overrides *****/
        $scope.updateColumnNameOverride = function(column) {
            if (column.$beforeOverride != column.name) {
                $scope.params.outputColumnNameOverrides[column.$beforeOverride] = column.name;
            } else {
                delete $scope.params.outputColumnNameOverrides[column.$beforeOverride];
            }
        };

        /******  filters  ******/

        function validateFilters() {
            if (!$scope.params) {
                return;//not ready
            }
            var inputRef = RecipesUtils.getSingleInput($scope.recipe, "main").ref;
            var inputSchema = $scope.computablesMap[inputRef].dataset.schema;
            validateFilter($scope.params.preFilter, inputSchema);
            validateFilter($scope.params.postFilter);
        }

        function validateFilter(filterDesc, schema) {
            var deferred = $q.defer();
            if (!filterDesc.enabled) {
                return;
            }
            if (angular.isUndefined(filterDesc.expression)) {
                return;
            }
            Expressions.validateExpression(filterDesc.expression, schema)
                .success(function(data) {
                    if (data.ok && $scope.mustRunInDatabase && !data.fullyTranslated) {
                        data.ok = false;
                    }
                    filterDesc.$status = data;
                    filterDesc.$status.validated = true;
                    deferred.resolve(data);
                })
                .error(function(data) {
                    setErrorInScope.bind($scope);
                    deferred.reject('Error while validating filter');
                });
            return deferred.promise;
        }

        /* callback given to the filter module */
        $scope.onFilterUpdate = $scope.updateRecipeStatusLater;

        /********  general init  ********/

        function loadParamsFromScript(scriptData) {
            if (!scriptData) {
                return;
            }
            $scope.params = JSON.parse(scriptData);
            $scope.params.keys = $scope.params.keys || [];
            $scope.params.preFilter = $scope.params.preFilter || {};
            $scope.params.postFilter = $scope.params.postFilter || {};
            $scope.params.outputColumnNameOverrides = $scope.params.outputColumnNameOverrides || {};

            $scope.uiState.columnStatus = angular.copy($scope.getColumns());
            $scope.uiState.distinctAllColumns = $scope.params.keys.length == $scope.uiState.columnStatus.length;
            var keyColNames = $scope.params.keys.map(function(k){return k.column});
            $scope.uiState.columnStatus.forEach(function(col) {
                col.ignore = !$scope.uiState.distinctAllColumns && keyColNames.indexOf(col.name) == -1;
            });

            //keep params for dirtyness detection
            visualCtrl.saveServerParams();

            // update recipe according to current schema
            resyncWithInputSchema();
            onColumnStatusChanged();
        }

        function resyncWithInputSchema() {
            // in case the dataset schema changed since the recipe creation/last edition
            var inputColumns = $scope.getColumns();

            var newColumnStatus = [];
            var oldColumnStatusNames = ($scope.uiState.columnStatus || []).map(function(col){return col.name});
            inputColumns.forEach(function(col) {
                var oldCSNIdx = oldColumnStatusNames.indexOf(col.name);
                if (oldCSNIdx >= 0) {
                    newColumnStatus.push(angular.extend($scope.uiState.columnStatus[oldCSNIdx], col));
                } else {
                    newColumnStatus.push(angular.copy(col));
                }
            });
            $scope.uiState.columnStatus = newColumnStatus;
        }

        function onColumnStatusChanged() {
            if (!$scope.params) {
                return;
            }
            $scope.params.keys = ($scope.uiState.columnStatus || [])
                                    .filter(function(col){return !col.ignore})
                                    .map(function(col){return {column:col.name}});
            $scope.updateRecipeStatusLater();
        }

        function onDistinctAllColumnsChanged(nv) {
            if (nv) {
                $scope.addAllDistinctColumns();
            }
            onColumnStatusChanged();
        }

        function onScriptChanged(nv) {
             if (nv) {
                loadParamsFromScript($scope.script.data);
                DKUtils.reflowNext();
                DKUtils.reflowLater();
                $scope.hooks.updateRecipeStatus();
            }
        }

        // UI:
        $scope.uiState = {
            currentStep: 'group',
            outputColumnNamesOverridable: true,
            distinctAllColumns: true
        };

        $scope.hooks.onRecipeLoaded = function(){
            Logger.info("On Recipe Loaded");
            validateFilters();
            $scope.$watch("script.data", onScriptChanged, true); // this will call $scope.hooks.updateRecipeStatus when ready
        };

        $scope.enableAutoFixup();
        $scope.specificControllerLoadedDeferred.resolve();
        $scope.$watchCollection("recipe.inputs.main.items", function() {
            DatasetUtils.updateRecipeComputables($scope, $scope.recipe, $stateParams.projectKey, contextProjectKey)
                .then(_ => resyncWithInputSchema());
        });
        $scope.$watch("uiState.columnStatus", onColumnStatusChanged, true);
        $scope.$watch("uiState.distinctAllColumns", onDistinctAllColumnsChanged, true);
    });
})();

(function() {
    'use strict';
    var app = angular.module('dataiku.recipes');

    app.controller("WindowRecipeCreationController", function($scope, Fn, $stateParams, DataikuAPI, $controller) {
        $scope.recipeType = "window";
        $controller("SingleOutputDatasetRecipeCreationController", {$scope:$scope});

        $scope.autosetName = function() {
            if ($scope.io.inputDataset) {
                var niceInputName = $scope.io.inputDataset.replace(/[A-Z]*\./,"");
                $scope.maybeSetNewDatasetName(niceInputName + "_windows");
            }
        };
    });

    app.controller("WindowRecipeController", function($scope, $stateParams, DataikuAPI, $q,Dialogs, TopNav, ContextualMenu, PartitionDeps, $rootScope,
     $timeout, DKUtils, Expressions, Logger, $controller,  RecipesUtils, CreateModalFromTemplate, Fn) {
        var groupingCtrl = $controller('GroupingRecipeController', {$scope: $scope}); //Controller inheritance
        var visualCtrl = groupingCtrl.visualCtrl; //FIXME ugly: inheritance cannot be expressed this way
        $scope.aggregateUsabilityFlag = "usableInWindow";

        $scope.simpleAggregationTypes =  [
            {name: "value", opType: "RETRIEVE", label: "Retrieve", tooltip: "Retrieve original value"},
            {name: "min", label: "Min"},
            {name: "max", label : "Max"},

            {name: "avg", label: "Avg"},
            {name: "sum", label: "Sum"},
            {name: "concat", label: "Concat", tooltip: "Concatenate values in one string"},
            {name: "stddev", label: "Std. dev."},

            {name: "count", label: "Count", tooltip: "Count non-null"},
            {name: "first", label: "First"},
            {name: "last", label: "Last"},
        ];
        $scope.lagAggregationTypes = [
            {name: "lag", label: "Lag", tooltip: "Value in a previous row"},
            {name: "lagDiff", opType: "LAG_DIFF", label: "LagDiff", tooltip: "Difference with a previous row"},
        ];
        $scope.leadAggregationTypes = [
            {name: "lead", label: "Lead", tooltip: "Value in a following row"},
            {name: "leadDiff", opType: "LEAD_DIFF", label: "LeadDiff", tooltip: "Difference with a following row"},
        ];
        $scope.aggregationTypes = $scope.simpleAggregationTypes.concat($scope.lagAggregationTypes,$scope.leadAggregationTypes);

        function makeSelectionTest(f) {
            return function() {
                if (!$scope.selection||!$scope.selection.allObjects) { return false }
                return $scope.selection.allObjects.map(f).reduce(Fn.OR,false);
            }
        }
        $scope.shouldDisplayDateUnit = makeSelectionTest.call(null,function(o) {return (o.leadDiff || o.lagDiff) && o.type == 'date'});

        $scope.addWindow = function() {
            $scope.params.windows = $scope.params.windows || [];
            $scope.params.windows.push({
                prefix: $scope.params.windows.length ? "w"+($scope.params.windows.length+1) : ""
            });
        };

        $scope.removeWindow = function(index) {
            $scope.params.windows.splice(index,1);
        };

        $scope.allWindowsOrdered = function() {
            var ret = true;
            (($scope.params || {}).windows || []).forEach(function(w){
                ret = w.enableOrdering && w.orders && w.orders.length && ret;
            });
            return ret;
        }

        $scope.addPartitioningColumn = function(win) {
            win.partitioningColumns = win.partitioningColumns || [];
            var columns = $scope.getColumnsWithComputed();
            var colName;
            if (columns) {
                var columnNames = columns.map(function(col){return col.name});
                //TODO smarter autoselect ?
                for (var i = 0; i < columns.length; ++i) {
                    if (win.partitioningColumns.indexOf(columnNames[i]) < 0) {
                        colName = columnNames[i];
                        break;
                    }
                }
                colName = colName || columnNames[0]; //TODO smarter autoselect
            }
            win.partitioningColumns.push(colName);
        };

        $scope.removePartitioningColumn = function(win, index) {
            win.partitioningColumns.splice(index, 1);
        };

        $scope.addOrderColumn = function(win) {
            win.orders = win.orders || [];
            var columns = $scope.getColumnsWithComputed();
            var colName;
            if (columns) {
                var columnNames = columns.map(function(col){return col.name});
                var orderColumns = win.orders.map(function(order){return order.column});
                //TODO smarter autoselect => prefer dates
                for (var i = 0; i < columns.length; ++i) {
                    if (orderColumns.indexOf(columnNames[i]) < 0) {
                        colName = columnNames[i];
                        break;
                    }
                }
                colName = colName || columnNames[0];
            }
            win.orders.push({column: colName});
        };

        $scope.getOrderColumnType = function(win) {
            if (!win.orders || !win.orders.length) {
                return;
            }
            const colName = win.orders[0].column;
            //TODO build index
            const col = $scope.getColumnsWithComputed().find(c => c.name == colName);
            return col && col.type;
        };

        $scope.removeOrderColumn = function(win, index) {
            win.orders.splice(index, 1);
        };

        $scope.onResyncWithInputSchema = function() {
            var inputColumnsWithComputed = $scope.getColumnsWithComputed(true);
            var inputColumnsWithComputedNames = inputColumnsWithComputed.map(function(col){return col.name});

            (($scope.params || {}).windows || []).forEach(function(win) {
                var i = (win.partitioningColumns || []).length;
                while (i--) {
                    if (!win.partitioningColumns[i] || inputColumnsWithComputedNames.indexOf(win.partitioningColumns[i]) == -1) {
                        win.partitioningColumns.splice(i, 1);
                    }
                }
                i = (win.orders || []).length;
                while (i--) {
                    if (!win.orders[i] || !win.orders[i].column || inputColumnsWithComputedNames.indexOf(win.orders[i].column) == -1) {
                        win.orders.splice(i, 1);
                    }
                }
            });
        };

        $scope.isWindowFrameRowsLimitationInvalid = (window) =>  window.limitFollowing && window.limitPreceding && (window.followingRows + window.precedingRows < 0)

        $scope.uiState.currentStep = 'windows';

        $scope.$watch('topNav.tab',function(nv){
            if (nv == 'settings') {
                $timeout(function() {
                    $scope.$broadcast('redrawFatTable');
                });
            }
        });

        $scope.$watch("params.windows", $scope.updateRecipeStatusLater, true);

    });
})();

(function() {
    'use strict';
    var app = angular.module('dataiku.recipes');

    app.controller("SamplingRecipeCreationController", function($scope, Fn, $stateParams, DataikuAPI, $controller) {
        $scope.recipeType = "sampling";
        $controller("SingleOutputDatasetRecipeCreationController", {$scope:$scope});

        $scope.autosetName = function() {
            if ($scope.io.inputDataset) {
                var niceInputName = $scope.io.inputDataset.replace(/[A-Z]*\./,"");
                $scope.maybeSetNewDatasetName(niceInputName + "_filtered");
            }
        };
    });


    // Recipe edition page controller
    app.controller("SamplingRecipeController", function ($scope, $stateParams, $q, DataikuAPI, TopNav, Dialogs, PartitionDeps,
                                                         RecipesUtils, $controller, Logger, SamplingData,
                                                         CreateModalFromTemplate, DatasetUtils, RecipeComputablesService) {
        var visualCtrl = $controller('VisualRecipeEditorController', {$scope: $scope}); //Controller inheritance
        this.visualCtrl = visualCtrl;

        $scope.SamplingData = SamplingData;

        var defaultSampling = {
            "samplingMethod": "FULL",
            "maxRecords": 30000,
            "targetRatio": 0.1
        };

        $scope.hooks.getPayloadData = function() {
            return angular.toJson($scope.filter);
        };

        $scope.hooks.preRunValidate = function() {
            var deferred = $q.defer();
            $scope.hooks.updateRecipeStatus().then(function(data) {
                if (data) {
                    Logger.info("preRunValidate failed",data);
                    var validationData = {error: false, messages: []};
                    if (data.filter.invalid) {
                        validationData.error=true;
                        data.filter.errorMessages.forEach(function(m) {validationData.messages.push({"message":m});});
                    }
                    if (data.output.invalid) {
                        validationData.error=true;
                        data.output.errorMessages.forEach(function(m) {validationData.messages.push({"message":m});});
                    }
                    deferred.resolve(validationData);
                } else {
                    deferred.resolve({error: false});
                }
            },
            function(data){
                Logger.error("Error when getting status", data);
                setErrorInScope.bind($scope);
                deferred.reject("Validation failed");
            });
            return deferred.promise;
        };

        var superSave = $scope.hooks.save;
        $scope.hooks.save = function() {
            return superSave().then(function(){
                origSelection = angular.copy($scope.selection);
            });
        };

        var superRecipeIsDirty = $scope.hooks.recipeIsDirty;
        var origSelection;
        $scope.hooks.recipeIsDirty = function() {
            if (superRecipeIsDirty()) return true;
            // no need to compare the contents of the filter object if it is disabled
            var selectionEquals = angular.equals($scope.selection, origSelection);
            return !selectionEquals;
        };

        $scope.hooks.onRecipeLoaded = function(){
            Logger.info("On Recipe Loaded");
            origSelection = angular.copy($scope.selection);
            //keep params for dirtyness detection
            visualCtrl.saveServerParams();
            $scope.hooks.updateRecipeStatus();
            $scope.$watch("recipe.params",  $scope.updateRecipeStatusLater, true);
            $scope.$watch("filter", $scope.updateRecipeStatusLater, true);
        };

        $scope.hooks.updateRecipeStatus = function() {
            var deferred = $q.defer();
            var payload = $scope.hooks.getPayloadData();
            $scope.updateRecipeStatusBase(false, payload).then(function() {
                // $scope.recipeStatus should have been set by updateRecipeStatusBase
                if (!$scope.recipeStatus) return deferred.reject();
                deferred.resolve($scope.recipeStatus);
            });
            return deferred.promise;
        };

        $scope.resyncSchema = function() {
            Dialogs.confirmPositive($scope,
                'Resynchronize schema',
                'The schema of "'+$scope.recipe.inputs[0]+'" will be copied to "'+$scope.recipe.outputs[0]+'". Are you sure you want to continue ?'
            )
            .then(function() {
                DataikuAPI.flow.recipes.basicResyncSchema($stateParams.projectKey,
                        $scope.hooks.getRecipeSerialized()).error(setErrorInScope.bind($scope));
            });
        };

        $scope.availableOutputDatasets = [];
        $scope.convertToSplitRecipe = function () {
            function doConvertToSplitRecipe(secondOutputDataset) {
                DataikuAPI.flow.recipes.visual.convertSamplingRecipeToSplitRecipe($stateParams.projectKey, $scope.recipe, secondOutputDataset)
                    .then(function () {
                        location.reload();
                    }, setErrorInScope.bind($scope));
            }
            if ($scope.hooks.recipeIsDirty()) {
                $scope.hooks.save();
            }
            CreateModalFromTemplate("/templates/recipes/io/output-selection-modal.html", $scope, null, function(modalScope) {
                $controller("_RecipeOutputNewManagedBehavior", {$scope: modalScope});

                DatasetUtils.listDatasetsUsabilityInAndOut($stateParams.projectKey, $scope.recipe.type).then(function(data) {
                    const alreadyInOutput = function(computable) {
                        if ($scope.recipe && $scope.recipe.outputs && $scope.recipe.outputs.main && $scope.recipe.outputs.main.items) {
                            return $scope.recipe.outputs.main.items.filter(item => item.ref == computable.smartName).length > 0;
                        } else {
                            return false;
                        }
                    };
                    $scope.availableOutputDatasets = data[1].filter(function(computable) {
                        return computable.usableAsOutput['main'].usable && !computable.alreadyUsedAsOutputOf && !alreadyInOutput(computable);
                    });
                });

                DataikuAPI.datasets.getManagedDatasetOptions($scope.recipe, 'main').success(function(data) {
                    modalScope.setupManagedDatasetOptions(data);
                });

                modalScope.ok = function() {
                    if (modalScope.io.newOutputTypeRadio == 'select') {
                        if (!modalScope.io.existingOutputDataset) return;
                        doConvertToSplitRecipe(modalScope.io.existingOutputDataset);
                    } else {
                        const creationSettings = {
                            connectionId : modalScope.newOutputDataset.connectionOption.id,
                            specificSettings : {
                                formatOptionId : modalScope.newOutputDataset.formatOptionId,
                                overrideSQLCatalog: modalScope.newOutputDataset.overrideSQLCatalog,
                                overrideSQLSchema: modalScope.newOutputDataset.overrideSQLSchema
                            },
                            partitioningOptionId : modalScope.newOutputDataset.partitioningOption
                        };
                        DataikuAPI.datasets.newManagedDataset($stateParams.projectKey, modalScope.newOutputDataset.name, creationSettings).success(function(dataset) {
                            RecipeComputablesService.getComputablesMap(modalScope.recipe, modalScope).then(function(map){
                                modalScope.setComputablesMap(map);
                                doConvertToSplitRecipe(dataset.name);
                            }, setErrorInScope.bind(modalScope));
                        }).error(setErrorInScope.bind(modalScope));
                    }
                };
            });
        };

        $scope.filter = {};
        if ($scope.script && $scope.script.data) {
            $scope.filter = JSON.parse($scope.script.data);
        }

        $scope.params = $scope.recipe.params;

        //TODO @sampling, why is this necessary?
        $scope.selection = $scope.recipe.params.selection;
        $scope.$watch("selection", function(nv, ov) {
            Logger.info("Selection changed", nv);
            if (nv) {
                $scope.recipe.params.selection = nv;
            }
        }, true);

        $scope.enableAutoFixup();
        $scope.specificControllerLoadedDeferred.resolve();
    });
})();
(function() {
    'use strict';
    var app = angular.module('dataiku.recipes');

    app.controller("VStackRecipeCreationController", function($scope, $controller, $stateParams, DataikuAPI, Fn, RecipeComputablesService) {
        $scope.recipeType = "vstack";
        $scope.recipe = {
            type: 'vstack',
            projectKey: $stateParams.projectKey,
            inputs: {
                main: {
                    items: []
                }
            },
            outputs: {
                main: {
                    items: []
                }
            }
        };

        RecipeComputablesService.getComputablesMap($scope.recipe, $scope).then(function(map) {
            $scope.setComputablesMap(map);
        });

        $controller("SingleOutputDatasetRecipeCreationController", {$scope:$scope});

        $scope.autosetName = function() {
            if ($scope.io.inputDataset) {
                var niceInputName = $scope.io.inputDataset.replace(/[A-Z]*\./,"");
                $scope.maybeSetNewDatasetName(niceInputName + "_stacked");
            }
        };

        $scope.getCreationSettings = function () {
            return {virtualInputs: $scope.recipe.inputs.main.items.map(input => input.ref)};
        };


        $scope.formIsValid = function() {
            return $scope.recipe.inputs.main.items.length &&
            (
                $scope.io.newOutputTypeRadio == 'create' && $scope.newOutputDataset && $scope.newOutputDataset.name && $scope.newOutputDataset.connectionOption && $scope.isDatasetNameUnique($scope.newOutputDataset.name)
                || $scope.io.newOutputTypeRadio == 'select' && $scope.io.existingOutputDataset
            );
        };

        $scope.showOutputPane = function() {
            return $scope.recipe.inputs.main.items.length > 0;
        };

        $scope.$watchCollection('recipe.inputs.main.items', function(nv) {
            if (nv && nv.length) {
                $scope.io.inputDataset = nv[0].ref;
            }
        })
    });


    app.controller("VStackRecipeController", function ($scope, $controller, $q, $stateParams, DataikuAPI, Dialogs, PartitionDeps,
        CreateModalFromTemplate, RecipesUtils, Logger, DatasetUtils) {
        var visualCtrl = $controller('VisualRecipeEditorController', {$scope: $scope});

        $scope.hooks.updateRecipeStatus = function(forceUpdate, exactPlan) {
            var payload = $scope.hooks.getPayloadData();
            if (!payload) return $q.reject("payload not ready");
            var deferred = $q.defer();
            $scope.updateRecipeStatusBase(forceUpdate, payload, {reallyNeedsExecutionPlan: exactPlan, exactPlan: exactPlan}).then(function() {
                // $scope.recipeStatus should have been set by updateRecipeStatusBase
                if (!$scope.recipeStatus) return deferred.reject();
                if ($scope.recipeStatus.outputSchema) {
                    $scope.params.postFilter = $scope.params.postFilter || {};
                    $scope.params.postFilter.$status = $scope.params.postFilter.$status || {};
                    $scope.params.postFilter.$status.schema = $scope.recipeStatus.outputSchema;
                }
                deferred.resolve($scope.recipeStatus);
            });
            return deferred.promise;
        };

        $scope.hooks.getPayloadData = function () {
            if (!$scope.params) {
                return null;
            }
            var us = $scope.unionSchema || [];
        	if ($scope.params.mode != 'FROM_INDEX' && $scope.params.mode != 'REMAP') {
                $scope.params.selectedColumns = us.filter(function(column){
                    return column.selected;
                })
                .map(function(column) {
                    return column.name
                });
            }
            return angular.toJson($scope.params);
        };

        $scope.showNewInputModal = function() {
            CreateModalFromTemplate("/templates/recipes/fragments/virtual-input-modal.html", $scope);
        };

        $scope.selected = {
        };

        $scope.selectedFromIndex = {
        };

        $scope.addDataset = function(datasetName) {
            if (RecipesUtils.getInput($scope.recipe, "main", datasetName) == null) {
                RecipesUtils.addInput($scope.recipe, "main", datasetName);
            }
            var inputNames = RecipesUtils.getInputsForRole($scope.recipe, "main").map(function(input){return input.ref});
            var inputDesc = {
                index: inputNames.indexOf(datasetName),
                originLabel: datasetName,
                preFilter: {},
                columnsMatch: []
            };
            buildInitialColumnsMatchForInput(inputDesc);
            $scope.params.virtualInputs.push(inputDesc);
            updateUnionSchema();
            $scope.updateColumnsSelection();
            $scope.updateRecipeStatusLater();
        }

        $scope.removeDataset = function(index) {
            removeDatasets([index]);
        };

        $scope.updateSelectAllColumns = function() {
            for (let i = 0; i < $scope.unionSchema.length; i++) {
                if ($scope.unionSchema[i]) {
                    $scope.unionSchema[i].selected = $scope.selected.all;
                }
            }
            $scope.selected.any = $scope.selected.all;
        };

        $scope.updateSelectAllColumnsFromIndex = function() {
            for (let i = 0; i < $scope.getSelectableColumns.length; i++) {
                if (!$scope.selectedColumns[i]) {
                    $scope.selectedColumns[i] = {name: $scope.getSelectableColumns[i][0]};
                }
                $scope.selectedColumns[i].selected = $scope.selectedFromIndex.all;
            }
            $scope.selectedFromIndex.any = $scope.selectedFromIndex.all;
        };

        $scope.updateGlobalSelectionStatus = function() {
            var all = true, any = false;
            for (let i = 0; i < $scope.unionSchema.length; i++) {
                if ($scope.unionSchema[i] && $scope.unionSchema[i].selected) {
                    any = true;
                } else {
                    all = false;
                }
            }
            $scope.selected = {
                all: all, any: any
            };
            all = true;any=false;
            if ($scope.params.mode == 'FROM_INDEX') {
                for (let i = 0 ; i < $scope.getSelectableColumns.length; i++)  {
                    const selectableCol = $scope.getSelectableColumns[i];
                    const selCol = $scope.selectedColumns.find(col => col && selectableCol.indexOf(col.name) >= 0);
                    if (selCol && selCol.selected) {
                        any = true;
                    } else {
                        all = false;
                    }
                }
            } else {
                for (let i = 0 ; i < $scope.selectedColumns.length; i++) {
                    if ($scope.selectedColumns[i] && $scope.selectedColumns[i].selected) {
                        any = true;
                    } else {
                        all = false;
                    }
                }
            }
            $scope.selectedFromIndex = {
                all: all, any: any
            };
        };

        // gets the dataset name from the index within the virtual inputs
        $scope.getDatasetName = function(virtualIndex) {
            var dataset = $scope.params.virtualInputs[virtualIndex];
            return $scope.getDatasetNameFromRecipeInputIndex(dataset.index);
        };

        $scope.getColumnList = function(datasetIndex) {
            var selectedColumns;
            if (datasetIndex != null) {
                selectedColumns = $scope.getColumns($scope.getDatasetNameFromRecipeInputIndex(datasetIndex));
            } else {
                selectedColumns = [];
            }
            return selectedColumns;
        };

        $scope.selectedColumns = [];// Used to decouple from $scope.params.selectedColumns

        $scope.addColumn = function () {
            let newColumnName = null;
            // find a name that has not been used yet
            $scope.params.virtualInputs.forEach(function(virtualInput){
                if (newColumnName) return;
                let inputColumns = $scope.getColumns(virtualInput.originLabel);
                for (const inputColumn of inputColumns) {
                    if (virtualInput.columnsMatch.indexOf(inputColumn.name) == -1) {
                        if (!newColumnName) newColumnName = inputColumn.name;
                        break;
                    }
                }
            });
            if (!newColumnName) { // No valid name found, Col-X instead
                let idx = 1;
                let possibleColName = "Col-" + idx;
                while ($scope.params.selectedColumns.indexOf(possibleColName) != -1) {
                    idx++;
                    possibleColName = "Col-" + idx;
                }
                newColumnName = possibleColName;
            }
            $scope.params.selectedColumns = $scope.params.selectedColumns.slice(); // Will enforce ng2-values-list two-way data binding
            $scope.params.selectedColumns.push(newColumnName);
            $scope.unionSchema.push({'name':newColumnName, 'selected':true });
            $scope.params.virtualInputs.forEach(function(virtualInput) { // building an index based columnsMatch
                let inputColumns = $scope.getColumns(virtualInput.originLabel);
                let inputColumnName = inputColumns.map(function(col){return col.name});
                if (inputColumnName.indexOf(newColumnName) > -1) {
                    virtualInput.columnsMatch.push(newColumnName);
                } else {
                    virtualInput.columnsMatch.push(null);
                }
            });
        };

        $scope.removeColumn = function (columnIndex) {
            // We're not removing the item from params.selectedColumns as editable-list already does it.
            if (columnIndex > -1) {
                const colName = $scope.params.selectedColumns[columnIndex];
                ($scope.unionSchema.find(col => col.name == colName) || {}).selected = false;
                $scope.params.virtualInputs.forEach(virtualInput => {virtualInput.columnsMatch.splice(columnIndex, 1);})
            }
        };

        $scope.reorderColumns = function (event) {
            $scope.params.virtualInputs.forEach(virtualInput => {
                moveItemInArray(virtualInput.columnsMatch, event.previousIndex, event.currentIndex);
            })
        }

        $scope.removeAllColumns = function() {
            $scope.params.selectedColumns = [];
            $scope.params.selectedColumnsIndexes = [];
            $scope.params.virtualInputs.forEach(virtualInput => {virtualInput.columnsMatch = []});
            $scope.unionSchema.forEach(column => { column.selected = false });
        };

        $scope.sortableOptions = {
            stop: function(e, ui) {
                if (ui.item.sortable.dropindex != null) {
                    moveSelectableColumn(ui.item.sortable.index, ui.item.sortable.dropindex);
                }
            },
            axis:'y', cursor: 'move', cancel:'', handle: '.handle-row'
        };

        function moveSelectableColumn(initialIndex, targetIndex) {
            function shiftArray(inputArray, initialIndex, targetIndex) {
                if (inputArray) inputArray.splice(targetIndex, 0, inputArray.splice(initialIndex, 1)[0]);
            }
            shiftArray($scope.params.selectedColumns, initialIndex, targetIndex);
            shiftArray($scope.params.selectedColumnsIndexes, initialIndex, targetIndex);
            shiftArray($scope.selectedColumns, initialIndex, targetIndex);
            for (const virtualInput of $scope.params.virtualInputs) {
                shiftArray(virtualInput.columnsMatch, initialIndex, targetIndex);
            }
        }

        $scope.useAsReference = function(referenceIndex) {
            let selectedColumnsNames = [];
            $scope.params.copySchemaFromDatasetWithName = referenceIndex;
            let selectedColumns = $scope.getColumns($scope.params.copySchemaFromDatasetWithName);
            selectedColumnsNames = selectedColumns.map(col => col.name);
            updateSelectableColumns();
            $scope.params.selectedColumns = selectedColumnsNames;
            $scope.selectedColumns = [];
            $scope.params.selectedColumnsIndexes = [];
            for (let index in selectedColumnsNames) {
                $scope.selectedColumns.push({
                    name:selectedColumnsNames[index],
                    selected:true
                });
                $scope.params.selectedColumnsIndexes.push(index);
            }
            $scope.updateGlobalSelectionStatus();
        }

        $scope.syncSelectedColumns = function() {
            $scope.params.selectedColumns = [];
            $scope.params.selectedColumnsIndexes = [];
            for (let columnIndex = 0 ; columnIndex < $scope.selectedColumns.length; columnIndex++) {
                if (($scope.selectedColumns[columnIndex] || {}).selected) {
                    $scope.selectedColumns[columnIndex].name = $scope.selectedColumns[columnIndex].name || $scope.getSelectableColumns[columnIndex][0];
                    $scope.params.selectedColumns.push($scope.selectedColumns[columnIndex].name);
                    $scope.params.selectedColumnsIndexes.push(columnIndex);
                    $scope.unionSchema[columnIndex].selected = true;
                } else if ($scope.unionSchema[columnIndex]) {
                    $scope.unionSchema[columnIndex].selected = false;
                }
            }
        }

        function syncSelectors() {
            $scope.selectedColumns = [];
            for (let columnIndex in $scope.params.selectedColumns) {
                let targetColumn = $scope.params.selectedColumnsIndexes[columnIndex];
                $scope.selectedColumns[targetColumn] = {};
                $scope.selectedColumns[targetColumn].selected = true;
                $scope.selectedColumns[targetColumn].name = $scope.params.selectedColumns[columnIndex];
            }
        }

        $scope.updateNewSchema = function(obj){
            $scope.params.selectedColumns = [];
        }

        $scope.columnsSelection = {};

        // gets the dataset name from the index within the recipe's inputs
        $scope.getDatasetNameFromRecipeInputIndex = function(index) {
            var input = $scope.recipe.inputs.main.items[index];
            return input ? input.ref : "";
        };

        $scope.getDatasetColorClass = function(datasetIndex) {
            return 'dataset-color-'+(datasetIndex%6);
        };

        $scope.updateColumnsSelection = function() {
            // clear the columnsMatch value in each input if the mode is not REMAP
            if ($scope.params.mode != 'REMAP') {
                $scope.params.virtualInputs.forEach(vi => { delete vi.columnsMatch; });
            }

            if ($scope.params.mode == 'CUSTOM') {
                return;
            } else if ($scope.params.mode == 'UNION') {
                $scope.params.selectedColumns = $scope.unionSchema.map(function(col) {
                    return col.name;
                });
            } else {
                var selectedColumnsNames = [];
                if ($scope.params.mode == 'FROM_DATASET') {
                    $scope.params.copySchemaFromDatasetWithName = $scope.params.copySchemaFromDatasetWithName || $scope.recipe.inputs.main.items[0].ref;
                    let selectedColumns = $scope.getColumns($scope.params.copySchemaFromDatasetWithName);
                    selectedColumnsNames = selectedColumns.map(col => col.name);
                } else if ($scope.params.mode == 'FROM_INDEX') {
                    if ($scope.params.selectedColumnsIndexes && $scope.params.selectedColumns
                        && $scope.params.selectedColumnsIndexes.length == $scope.params.selectedColumns.length) {
                        selectedColumnsNames = $scope.params.selectedColumns;
                    } else {
                        $scope.params.copySchemaFromDatasetWithName = $scope.params.copySchemaFromDatasetWithName || $scope.recipe.inputs.main.items[0].ref;
                        let selectedColumns = $scope.getColumns($scope.params.copySchemaFromDatasetWithName);
                        selectedColumnsNames = selectedColumns.map(col => col.name);
                        $scope.useAsReference($scope.params.copySchemaFromDatasetWithName);
                    }
                    updateSelectableColumns();
                    syncSelectors();
                    let maxColNb = 0;
                    for (let i = 0; i < $scope.recipe.inputs.main.items.length; i++) {
                        maxColNb = Math.max(maxColNb, $scope.getColumns($scope.recipe.inputs.main.items[i].ref).length);
                    }
                    $scope.selectedColumns.forEach((col, idx) => { if (idx >= maxColNb) { col.selected = false; } });
                } else if ($scope.params.mode == 'REMAP') {
                    $scope.params.copySchemaFromDatasetWithName = $scope.params.copySchemaFromDatasetWithName || $scope.recipe.inputs.main.items[0].ref;
                    $scope.columnsSelection.possibleColumnNames = $scope.columnsSelection.possibleColumnNames || []
                    let selectedColumns = $scope.getColumns($scope.params.copySchemaFromDatasetWithName);
                    if ($scope.params.selectedColumns) {
                        selectedColumnsNames = $scope.params.selectedColumns;
                        $scope.unionSchema.forEach(col => { col.selected = false })
                    } else {
                        selectedColumnsNames = selectedColumns.map(col => col.name);
                    }
                    buildInitialColumnsMatch(selectedColumnsNames);
                } else if ($scope.params.mode == 'INTERSECT') {
                    let allInputs = RecipesUtils.getFlatInputsList($scope.recipe);
                    let selectedColumns = $scope.getColumns(allInputs[0].ref);
                    selectedColumnsNames = selectedColumns.map(col => col.name);
                    for (var i = 1; i < allInputs.length; i++) {
                        var columnNames = $scope.getColumns(allInputs[i].ref).map(function(col){return col.name;});
                        for (var c = selectedColumnsNames.length - 1; c >= 0; c--) {
                            if (columnNames.indexOf(selectedColumnsNames[c]) < 0) {
                                selectedColumnsNames.splice(c, 1);
                            }
                        }
                    }
                }
                $scope.params.selectedColumns = selectedColumnsNames;
            }
            updateSelectedColumns();
            $scope.updateGlobalSelectionStatus(); // keep "select all" checkbox synchronised
        };

        $scope.isColumnsMatch = function(referenceColumns, selectedColumns) {
            if (referenceColumns.length != selectedColumns.length) {
                return false;
            } else {
                for (let columnIndex in referenceColumns) {
                    if (!referenceColumns[columnIndex] || !selectedColumns[columnIndex] || !(selectedColumns[columnIndex] === referenceColumns[columnIndex].name)) {
                        return false;
                    }
                }
                return true;
            }
        }

        function updateSelectableColumns(){
            //returns a 2D table containing possible header names for each index
            let selectableColumns = [];
            for (const input of $scope.params.virtualInputs) {
                var inputColumns = $scope.getColumns(input.originLabel);
                for (let columnIndex in inputColumns) {
                    let thisInput = {};
                    if(selectableColumns[columnIndex]) thisInput = selectableColumns[columnIndex];
                    thisInput[inputColumns[columnIndex].name] = 1;
                    selectableColumns[columnIndex] = thisInput;
                }
            }
            $scope.getSelectableColumns = selectableColumns.map(record => {
                let column = [];
                for (var key in record){
                    column.push(key);
                }
                return column;
            });
        }

        function buildInitialColumnsMatch(selectedColumnsNames) {
            for (const input of $scope.params.virtualInputs) {
                const inputColumns = $scope.getColumns(input.originLabel);
                let columnsMatch = [];
                for (let indexColumn in selectedColumnsNames) {
                    if (input.columnsMatch && indexColumn < input.columnsMatch.length) {
                        columnsMatch.push(input.columnsMatch[indexColumn]);
                    } else if (indexColumn < inputColumns.length) {
                        columnsMatch.push(inputColumns[indexColumn].name);
                    } else {
                        columnsMatch.push('');
                    }
                }
                input.columnsMatch = columnsMatch;
            }
        }

        function buildInitialColumnsMatchForInput(input) {
            const inputColumns = $scope.getColumns(input.originLabel);
            let columnsMatch = [];
            for (let indexColumn in $scope.params.selectedColumns) {
                if (indexColumn < inputColumns.length) {
                    columnsMatch.push(inputColumns[indexColumn].name);
                } else {
                    columnsMatch.push('');
                }
            }
            input.columnsMatch = columnsMatch;
        }

        function removeDatasets(virtualIndices) {
            /* removes a dataset from recipe inputs if it not used anymore */
            var updateRecipeInputs = function (index) {
                var used = false;
                $scope.params.virtualInputs.forEach(function(vi) {
                    if (vi.index == index) {
                        used = true;
                    }
                });
                if (!used) {
                    RecipesUtils.removeInput($scope.recipe, "main", $scope.getDatasetNameFromRecipeInputIndex(index));
                    $scope.params.virtualInputs.forEach(function(vi) {
                        if (vi.index > index) {
                            vi.index--;
                        }
                    });
                }
            }

            virtualIndices.sort().reverse();
            virtualIndices.forEach(function(virtualIndex) {
                var recipeInputsIndex = $scope.params.virtualInputs[virtualIndex].index;
                $scope.params.virtualInputs.splice(virtualIndex, 1);
                updateRecipeInputs(recipeInputsIndex);
            });


            updateUnionSchema();
            $scope.updateColumnsSelection();
            if ($scope.params.mode == 'FROM_INDEX') {
                $scope.syncSelectedColumns();
            }
            updateSelectableColumns();
            updateSelectedColumns();
            $scope.hooks.updateRecipeStatus();
        }

        function updateSelectedColumns() {
            if ($scope.params.selectedColumns) {
                $scope.unionSchema.forEach(col => {
                    col.selected = $scope.params.selectedColumns.indexOf(col.name) >= 0;
                });
            }
        }

        function updateUnionSchema () {
            $scope.flatInputRefs = [];

            var columns = [];
            var columnNames = [];
            $scope.unionSchema = $scope.unionSchema || [];
            var previouslySelected = $scope.unionSchema.filter(function(col){
                return col.selected;
            }).map(function(col) {
                return col.name;
            });
            RecipesUtils.getFlatInputsList($scope.recipe).forEach(function(input) {
                $scope.flatInputRefs.push(input.ref);
                $scope.getColumns(input.ref).forEach(function(column) {
                    if (columnNames.indexOf(column.name) < 0) {
                        columns.push(column);
                        columnNames.push(column.name);
                        if (previouslySelected[column.name]) {
                            column.selected = true;
                        }
                    }
                });
            });
            $scope.unionSchema = columns;
        }

        $scope.uiState = {
            currentStep: 'selectedColumns'
        };

        $scope.enableAutoFixup();

        function onScriptChanged(nv, ov) {
            if (nv) {
                if ($scope.script.data) {
                    $scope.params = JSON.parse($scope.script.data);

                    updateUnionSchema();
                    $scope.updateColumnsSelection();
                    updateSelectedColumns();

                    visualCtrl.saveServerParams(); //keep for dirtyness detection

                    $scope.updateGlobalSelectionStatus();
                    $scope.hooks.updateRecipeStatus();
                }
            }
        }

        $scope.hooks.onRecipeLoaded = function(){
            Logger.info("On Recipe Loaded");

            $scope.$watch("script.data", onScriptChanged);
            $scope.$watch("recipe.inputs", function() {
                DatasetUtils.updateRecipeComputables($scope, $scope.recipe, $stateParams.projectKey, $stateParams.projectKey)
                    .then(_ => updateUnionSchema());
            }, true);
            $scope.$watch("params.postFilter", $scope.updateRecipeStatusLater, true);
            $scope.$watch("params.virtualInputs", $scope.updateRecipeStatusLater, true);
            $scope.$watch("params.selectedColumns", $scope.updateRecipeStatusLater, true);
            $scope.$watch("params.mode", updateUnionSchema, true);
            // don't pass $scope.updateRecipeStatus as the callback, because it will get parameters which are absolutely not what is expected:
            $scope.$watch("unionSchema", function(){$scope.updateRecipeStatusLater()}, true); //call updateRecipeStatus without args!
            $scope.$watch("recipe.outputs", function(){
                var outputs = RecipesUtils.getOutputsForRole($scope.recipe, "main");
                if (outputs.length == 1) {
                    $scope.outputDatasetName = outputs[0].ref;
                }
                $scope.updateRecipeStatusLater();
            }, true);

            updateUnionSchema();
            onScriptChanged($scope.script.data);
        };

        $scope.specificControllerLoadedDeferred.resolve();
    });

    app.controller("NewVirtualInputController", function ($scope, $stateParams, DatasetUtils) {
        $scope.newInput = {};

        $scope.isValid = function() {
            return !!$scope.newInput.dataset;
        };

        $scope.addInput = function() {
            $scope.addDataset($scope.newInput.dataset);
        };

        DatasetUtils.listDatasetsUsabilityInAndOut($stateParams.projectKey, "vstack").then(function(data){
            $scope.availableInputDatasets = data[0];
        });
    });

})();

(function(){
    'use strict';

    var services = angular.module('dataiku.services');

    // Service to handle Expressions for Range Splits, which represent one or two bands intervals for types: num & dates
    services.factory('RangeExpressions', function(Expressions) {

        // Available date formats for Ranges with Date columns
        var dateFormats = {
            dateWithTimeFormat: "YYYY-MM-DD HH:mm",
            dateFormat: "YYYY-MM-DD"
        };

        // support for initializing/switching between open (> or <) and close (>= or <=) operators (for range mode in split recipe)
        function switchOpenCloseComparisonOperator(operator) {
            if (!operator) return null;
            if (operator.search('<=') > -1) return operator.replace('<=', '< ');
            if (operator.search('>=') > -1) return operator.replace('>=', '> ');
            if (operator.search('<') > -1) return operator.replace('< ', '<=');
            if (operator.search('>') > -1) return operator.replace('> ', '>=');
            return null;
        }

        function isOpenComparisonOperator(operator) {
            if (!operator) return false;
            return (operator.search("=") == -1);
        }

        function getTypeComparisonOperator(operator) {
            if (!operator) return;
            if (operator.search(">") > -1) return 'min';
            if (operator.search("<") > -1) return 'max';
        }

        function modifyColTypeInComparisonOperator(operator, colType) {
            if (!operator) return;
            return initializeComparisonOperator(colType, getTypeComparisonOperator(operator), isOpenComparisonOperator(operator));
        }

        function initializeComparisonOperator(colType, comparisonType, open) {
            var colGenericType = Expressions.genericType(colType);
            var initOperatorDic = {"min": ">  ","max": "<  "}
            var genericTypeDic = {"num": "number","date": "date"}
            var operator = initOperatorDic[comparisonType] + "["+genericTypeDic[colGenericType]+"]";

            if(!open) {
                operator = switchOpenCloseComparisonOperator(operator);
            }
            return operator;
        }

        function setValuesFromOtherCondition(condition, otherCondition, colType) {
            var colGenericType = Expressions.genericType(colType);
            var valuesToSet = {
                "num": ["num"],
                "date": ["date", "time"]
            }
            var fieldsToSet = valuesToSet[colGenericType];
            if (!fieldsToSet) return;
            fieldsToSet.forEach(function(field) {
                condition[field] = otherCondition[field];
            });
        }

        function indexOfComparisonType(conditions, comparisonType) {
            if(!conditions) return -1;
            for (var i=0; i<conditions.length; i++) {
                var condition = conditions[i];
                if (!condition || !condition.operator) return;
                if (getTypeComparisonOperator(condition.operator) == comparisonType) {
                    return i;
                }
            }
            return -1;
        }


        // Methods particular to organisation of splits ( with filter.uiData.conditions )

        // Retrieve conditions from a split list with an index
        function getRangeConditions(splits, splitIndex) {
            if (!(splits && splits[splitIndex])) return;
            var split = splits[splitIndex];
            if (!(split.filter && split.filter.uiData && split.filter.uiData.conditions)) return;
            return split.filter.uiData.conditions;
        }


        function indexOfMinCond(splits, splitIndex) {
            var conditions = getRangeConditions(splits, splitIndex);
            if (!conditions) return -1;
            return indexOfComparisonType(conditions, "min");
        }

        function getMinCond(splits, splitIndex) {
            var conditions = getRangeConditions(splits, splitIndex);
            var index = indexOfComparisonType(conditions, "min");
            if (index === -1 || !conditions[index]) return;
            return conditions[index];
        }

        function hasMinCond(splits, splitIndex) {
            return (indexOfMinCond(splits, splitIndex) > -1);
        }

        function indexOfMaxCond(splits, splitIndex) {
            var conditions = getRangeConditions(splits, splitIndex);
            if (!conditions) return -1;
            return indexOfComparisonType(conditions, "max");
        }

        function getMaxCond(splits, splitIndex) {
            var conditions = getRangeConditions(splits, splitIndex);
            var index = indexOfComparisonType(conditions, "max");
            if ( index === -1 || !conditions[index]) return;
            return conditions[index];
        }

        function hasMaxCond(splits, splitIndex) {
            return (indexOfMaxCond(splits, splitIndex) > -1);
        }

        function createCondition(isOpen, comparisonType, colType, inputCol) {
            var operator = initializeComparisonOperator(colType, comparisonType, isOpen);
            return {
                "input": inputCol,
                "operator": operator
            };
        }

        function getValuesFromCond(condition, colType) {
            if (!condition) return;
            var colGenericType = Expressions.genericType(colType);
            if (colGenericType == 'num') {
                return condition.num;
            } else if (colGenericType == "date") {
                if (!condition.date || !condition.time) return;
                return moment(condition.date + " " + condition.time, "YYYY-MM-DD HH:mm").toDate()
            }
        }

        return {
            dateFormats,
            switchOpenCloseComparisonOperator,
            isOpenComparisonOperator,
            initializeComparisonOperator,
            modifyColTypeInComparisonOperator,
            setValuesFromOtherCondition,
            getTypeComparisonOperator,
            getRangeConditions,
            indexOfMaxCond,
            indexOfMinCond,
            getMinCond,
            getMaxCond,
            hasMinCond,
            hasMaxCond,
            createCondition,
            getValuesFromCond
        }
    });

    // Service to help build Gauges for shares (RANDOM, RANDOM_COLUMNS, CENTILES) and RANGE modes
    // In particular to compute extent of values and adapt values to scales
    services.factory('GaugeHelper', function(Fn) {

                var spaceToInfinity = 100;
                var spaceMinEqualsMax = 10;
                function getValuesModified(data, index, getValuesFn, min, max) {
                    var values = getValuesFn(data, index);
                    if(!values) return;
                    var minMaxValue = getMinMaxValue(data, getValuesFn, min, max);
                    if (!minMaxValue) return;

                    // Check whether values is array or array of array
                    var isArrayOfArrays = angular.isArray(values[0]);

                    if (!isArrayOfArrays) {
                        return computeValues(values, minMaxValue);
                    } else {
                        return values.map(function(v) { return computeValues(v, minMaxValue);});
                    }
                }

                function computeValues(values, minMaxValue) {
                        var convertedValues = []
                        // Convert Infinity values to work with scale
                        convertedValues[0] = (values[0] == - Infinity) ? minMaxValue.min - spaceToInfinity : values[0];
                        convertedValues[1] =  (values[1] == + Infinity) ? minMaxValue.max + spaceToInfinity : values[1];
                        return convertedValues;
                }

                // utils
                function getMinMaxValue(data, getValuesFn, min, max) {
                    var mustFindMin = true;
                    var mustFindMax = true;
                    var hasInfinityMin = false;
                    var hasInfinityMax = false;
                    var maxValue = null;
                    var minValue = null;
                    if (min != null) {
                        mustFindMin = false;
                        minValue = min;
                    }
                    if (max != null) {
                        mustFindMax = false;
                        maxValue = max;
                    }
                    if (!data) return;

                    if (mustFindMin || mustFindMax) {
                        for (var i=0; i < data.length; i++) {
                            var values = getValuesFn(data, i);
                            if (!values) continue;
                            // Flattening if values is array of arrays
                            values = [].concat.apply([], values);

                            // Checking if has +/- Infinity
                            if (Fn.inArray(values)(-Infinity)){
                                hasInfinityMin = true;
                            }
                            if (Fn.inArray(values)(Infinity)){
                                hasInfinityMax = true;
                            }
                            // Removing +/- Infinity from values
                            values = values.filter(function(v) { return Math.abs(v) != Infinity;});

                            var tmpMax = Math.max(...values);
                            var tmpMin = Math.min(...values);

                            // Testing if must define new maxValues, leave aside Infinite values
                            if (mustFindMax && (maxValue == null || maxValue < tmpMax)) {
                                maxValue = tmpMax;
                            }
                            if (mustFindMin && (minValue == null || minValue > tmpMin)) {
                                minValue = tmpMin;
                            }
                        }
                    }

                    return {
                        min: minValue,
                        max: maxValue,
                        hasInfinityMin: hasInfinityMin,
                        hasInfinityMax: hasInfinityMax
                    };
                }

                function buildScale(extremities, width) {
                    var minValue = extremities.min;
                    var maxValue = extremities.max;

                    // When extremities are equal, artificially spread them
                    if(extremities.min != null && extremities.min == extremities.max) {
                        minValue -= spaceMinEqualsMax;
                        maxValue += spaceMinEqualsMax;
                    }

                    var axisRange = [minValue, maxValue];
                    var range = [0, width];

                    if (extremities.hasInfinityMin) {
                        range.splice(1, 0, width / 4);
                        axisRange.unshift(extremities.min - spaceToInfinity);
                    }
                    if (extremities.hasInfinityMax) {
                        range.splice(-1, 0, 3 * width / 4);
                        axisRange.push(extremities.max + spaceToInfinity);
                    }
                    var scale = d3.scale.linear().domain(axisRange).range(range);
                    return scale;
                }

                return {
                    getValuesModified,
                    getMinMaxValue,
                    buildScale
                };

    });

})();


(function(){
    'use strict';

    var widgets = angular.module('dataiku.directives.widgets');

    widgets.directive("splitSharesSelector", function() {
        return {
            scope: true,
            templateUrl: "/templates/recipes/fragments/split-shares-selector.html",
            link: function($scope, element, attrs) {

                $scope.getSelectedSplits = function() {
                    return $scope.getSplits(attrs.selectedMode);
                }

                $scope.getMaxShare = function(currentIndex) {
                    var splits = $scope.getSelectedSplits();
                    var cumulatedShare = 0;
                    for (var i = 0; i < splits.length ; i++) {
                        if (i != currentIndex) {
                            cumulatedShare += splits[i].share;
                        }
                    }
                    return (cumulatedShare > 100) ? 0 : 100 - cumulatedShare;
                };

                $scope.addShare = function(splitIndex) {
                    var splits = $scope.getSelectedSplits();
                    var share = 100;
                    for (var i=0; i < splitIndex; i++) {
                        share -= splits[i].share;
                    }
                    // ensuring to have a positive share (if user does not respect sum share < 100)
                    share = Math.max(share, 0);
                    splits.splice(splitIndex, 0, {share: share, outputIndex: 0});
                };

                $scope.removeShare = function(splitIndex) {
                    var splits = $scope.getSelectedSplits();
                    splits.splice(splitIndex, 1);
                };

                $scope.getShareFromIndex = function(splits, splitIndex) {
                    if (!splits) return;

                    // Regular Share
                    if (splitIndex > -1 || splits[splitIndex]) {
                        if (splits[splitIndex].share == null) return null;
                        var previousCumulatedShare = 0;
                        for (var i=0; i < splitIndex; i++) {
                            previousCumulatedShare += splits[i].share;
                        }
                        return [previousCumulatedShare, previousCumulatedShare + splits[splitIndex].share];
                    }

                    // splitIndex == -1 => return remaining share
                    if (splitIndex == -1) {
                        var totalShare = splits.reduce(function(memo, split) { return memo + ((split.share != null) ? split.share : 0);}, 0);
                        return (totalShare < 100) ? [[totalShare, 100]] : [[100,100]];
                    }
                };

                $scope.getRemainingShare = function() {
                    var splits = $scope.getSelectedSplits();
                    if (!splits) return;
                    var totalShare = splits.reduce(function(memo, split) { return memo + ((split.share != null) ? split.share : 0);}, 0);
                    return Math.max(100 - totalShare, 0);
                };

                function getShareInInterval(newValue, splits , index) {
                    var totalShareWithoutIndex = splits.reduce(function(mem, split, i){
                        if (i != index) {
                            return mem + split.share;
                        } else {
                            return mem;
                        }
                    }, 0);
                    return Math.max(Math.min(newValue, 100 - totalShareWithoutIndex), 0);
                }

                $scope.updateShareFromIndex = function(splits, splitIndex, min, max) {
                    if (!splits || !splits[splitIndex]) return;

                    var newShare = Math.max(Math.floor(max - min), 0);
                    var previousTotalShare = splits.reduce(function(mem, split){ return mem + split.share;}, 0);
                    var shareToDispatch  = newShare - splits[splitIndex].share;

                    // Update current value
                    splits[splitIndex].share = newShare;

                    // Update following values if new total > 100 or share to dispatch < 0
                    var numImpactedSplits = splits.length - splitIndex - 1;
                    if (numImpactedSplits >= 1 && (previousTotalShare + shareToDispatch > 100 || (shareToDispatch < 0))) {
                        var impactShare = null;
                        if (shareToDispatch > 0) {
                            impactShare = Math.ceil(shareToDispatch / numImpactedSplits);
                        } else {
                            impactShare =  - Math.floor( - shareToDispatch / numImpactedSplits);
                        }
                        var previousShare = null;
                        var cumulatedImpactShare = 0;
                        // update all following values except last to round numbers
                        for (var i = splitIndex + 1; i < splits.length - 1 ; i++) {
                            previousShare = splits[i].share;
                            splits[i].share = getShareInInterval(splits[i].share - impactShare, splits, i);
                            cumulatedImpactShare += (splits[i].share - previousShare);
                        }
                        // update last value
                        splits[splits.length - 1].share = getShareInInterval(splits[splits.length - 1].share - (shareToDispatch - cumulatedImpactShare), splits, splits.length - 1);
                    }
                };
            }
        }
    });

    widgets.directive("rangeBracket", function(RangeExpressions) {
        return {
            scope: {
                type: "=",
                rangeIndex: "=",
                ranges: "=",
                isValidCol: "="
            },
            template: '<button class="btn btn--icon btn--secondary bracket" ng-click="switchExtremity()" ng-if="isOpeningBracket()" title="{{isOpenExtremity() ? \'Exclude\' : \'Include\'}}" data-toggle="tooltip" data-placement="top">[</button>' +
                      '<button class="btn btn--icon btn--secondary bracket" ng-click="switchExtremity()" ng-if="isClosingBracket()" title="{{isOpenExtremity() ? \'Exclude\' : \'Include\'}}" data-toggle="tooltip" data-placement="top">]</button>',
            link: function($scope) {

                function getExtremity() {
                    return getExtremityFromIndexAndType($scope.rangeIndex, $scope.type);
                }

                function getExtremityFromIndexAndType(index, extremityType) {
                    if (extremityType == "min") {
                        return RangeExpressions.getMinCond($scope.ranges, index);
                    }
                    if (extremityType == "max") {
                        return RangeExpressions.getMaxCond($scope.ranges, index);
                    }
                    return null;
                }

                function getConnectedExtremity() {
                    if ($scope.type == "min") {
                        return getExtremityFromIndexAndType($scope.rangeIndex - 1, 'max');
                    }
                    if ($scope.type == "max") {
                        return getExtremityFromIndexAndType($scope.rangeIndex + 1, 'min');
                    }
                    return null;
                }

                function isDefined() {
                    if (!$scope.isValidCol) return false;
                    if ($scope.type == "min") {
                        return RangeExpressions.hasMinCond($scope.ranges, $scope.rangeIndex);
                    }
                    if ($scope.type == "max") {
                        return RangeExpressions.hasMaxCond($scope.ranges, $scope.rangeIndex);
                    }
                }

                $scope.switchExtremity = function() {
                    var extremity = getExtremity();
                    var connectedExtremity = getConnectedExtremity();
                    if(extremity) {
                        extremity.operator = RangeExpressions.switchOpenCloseComparisonOperator(extremity.operator);
                    }
                    if(connectedExtremity) {
                        connectedExtremity.operator = RangeExpressions.switchOpenCloseComparisonOperator(connectedExtremity.operator);
                    }
                };

                $scope.isOpenExtremity = function() {
                    var extremity = getExtremity();
                    return RangeExpressions.isOpenComparisonOperator(extremity.operator);
                };

                $scope.isOpeningBracket = function() {
                    if (!isDefined()) return false;
                    var extremity = getExtremity();
                    var hasExtremity = (extremity && extremity.operator);
                    var isMinClosedExtremity = ($scope.type === "min" && !$scope.isOpenExtremity());
                    var isMaxOpenExtremity = ($scope.type === "max" && $scope.isOpenExtremity());
                    return (hasExtremity && (isMinClosedExtremity || isMaxOpenExtremity));
                };

                $scope.isClosingBracket = function() {
                    if (!isDefined()) return false;
                    var extremity = getExtremity();
                    var hasExtremity = (extremity && extremity.operator);
                    var isMinOpenExtremity = ($scope.type === "min" && $scope.isOpenExtremity());
                    var isMaxClosedExtremity = ($scope.type === "max" && !$scope.isOpenExtremity());
                    return (hasExtremity && (isMinOpenExtremity || isMaxClosedExtremity));
                };

            }
        }
    });

    widgets.directive('splitRangesSelector', function(Assert, Expressions, RangeExpressions) {
        return {
            scope: true,
            templateUrl : "/templates/recipes/fragments/split-ranges-selector.html",
            link : function($scope, element, attrs) {

                $scope.getSelectedSplits = function() {
                    return $scope.getSplits(attrs.selectedMode);
                }

                $scope.getRangeColType = function() {
                    return $scope.getColType($scope.params.column);
                };

                $scope.getRangeColGenericType = function() {
                    return Expressions.genericType($scope.getRangeColType());
                };

                $scope.rangeInputsClass = function() {
                    return "input-"+$scope.getRangeColGenericType();
                };

                $scope.createMinCondition = function(isOpen) {
                    return RangeExpressions.createCondition(isOpen, "min", $scope.getRangeColType(), $scope.params.column);
                };

                $scope.createMaxCondition = function(isOpen) {
                    return RangeExpressions.createCondition(isOpen, "max", $scope.getRangeColType(), $scope.params.column);
                };

                $scope.addRangeSplit = function(splitIndex) {
                    let splits = $scope.getSelectedSplits();
                    let conditions = [];
                    let genericType = $scope.getRangeColGenericType();
                    let maxPreviousCond = null;
                    let isOpenPreviousCond = false;
                    let minCondition;
                    if (genericType === "date") {
                        if (RangeExpressions.hasMaxCond(splits, splitIndex - 1)) {
                            maxPreviousCond = RangeExpressions.getMaxCond(splits, splitIndex - 1);
                            isOpenPreviousCond = (maxPreviousCond && RangeExpressions.isOpenComparisonOperator(maxPreviousCond.operator));
                        }
                        minCondition = $scope.createMinCondition(!isOpenPreviousCond);
                        var maxCondition = $scope.createMaxCondition(false);
                        conditions = [minCondition, maxCondition];

                    } else if (genericType === "num" && splitIndex > 0) {
                        if (!RangeExpressions.hasMaxCond(splits, splitIndex - 1)) {
                            // Create max conditions for previous if do not exist yet
                            maxPreviousCond = $scope.createMaxCondition(false);
                            var previousConditions = RangeExpressions.getRangeConditions(splits, splitIndex - 1);
                            previousConditions.push(maxPreviousCond);
                        } else {
                            maxPreviousCond = RangeExpressions.getMaxCond(splits, splitIndex - 1);
                        }
                        isOpenPreviousCond = (maxPreviousCond && RangeExpressions.isOpenComparisonOperator(maxPreviousCond.operator));
                        minCondition = $scope.createMinCondition(!isOpenPreviousCond);
                        conditions = [minCondition];
                    }

                    let newRange = $scope.getNewRangeSplit(conditions);

                    // Autofill new value if needed
                    if (maxPreviousCond) {
                        RangeExpressions.setValuesFromOtherCondition(minCondition, maxPreviousCond, $scope.getRangeColType());

                        // For dates, set also end of interval to previous max date
                        if(genericType === "date") {
                            RangeExpressions.setValuesFromOtherCondition(maxCondition, maxPreviousCond, $scope.getRangeColType());
                        }
                    } else if (genericType === "date") {
                        Assert.trueish(minCondition, 'minCondition');
                        Assert.trueish(maxCondition, 'maxCondition');
                        // Autofill value to today for first date split
                        let today = moment().format(RangeExpressions.dateFormats["dateFormat"]);
                        let time = "00:00";
                        minCondition.date = today; //NOSONAR not undefined
                        minCondition.time = time; //NOSONAR not undefined
                        maxCondition.date = today; //NOSONAR not undefined
                        maxCondition.date = time; //NOSONAR not undefined
                    }
                    splits.splice(splitIndex, 0, newRange);
                };

                $scope.removeRangeSplit = function(splitIndex) {
                    var splits = $scope.getSelectedSplits();
                    splits.splice(splitIndex, 1);
                };

                $scope.getRangeFromIndex = function(splits, splitIndex) {

                    // Returning normal values for particular index with Infinity if not set
                    if (splitIndex > -1) {
                        var minValue = - Infinity;
                        if (RangeExpressions.hasMinCond(splits,splitIndex)) {
                            var minCond = RangeExpressions.getMinCond(splits, splitIndex);
                            minValue = RangeExpressions.getValuesFromCond(minCond, $scope.getRangeColType());
                            if (minValue == null) {
                                return null;
                            }
                        }
                        var maxValue = Infinity;
                        if (RangeExpressions.hasMaxCond(splits,splitIndex)) {
                            var maxCond = RangeExpressions.getMaxCond(splits, splitIndex);
                            maxValue = RangeExpressions.getValuesFromCond(maxCond, $scope.getRangeColType());
                            if (maxValue == null) {
                                return null;
                            }
                        }
                        if (minValue > maxValue) return null;
                        return [[minValue, maxValue]];
                    }


                    // Returning missing pieces in [-Infinity, Infinity] interval to build Remaining gauge
                    else if (splitIndex == -1) {

                        // First retrieving all values from the ranges
                        var ranges = [];
                        for(var i=0; i < splits.length; i++) {
                            ranges.push($scope.getRangeFromIndex(splits, i));
                        }

                        // Then filter null values && sort the ranges according to their min value
                        ranges = ranges.filter(function(values) { return values != null;})
                                       .map(function(values) { return [].concat.apply([], values);})
                                       .sort(function(v1, v2) { return (v1[0] < v2[0]) ? -1 : 1;});

                        if(ranges.length == 0) return;
                        // Then build disjoint intervals made of unions of intervals that intersect
                        var disjointAggRanges = [];
                        var currentAggRange = ranges[0];
                        for (var j=1; j<ranges.length; j++) {

                            if( currentAggRange[1] >= ranges[j][0] ) {
                                // if must stay in same Adgg Range => Set new upper bound to max of two intervals
                                currentAggRange[1] = Math.max(currentAggRange[1], ranges[j][1]);
                            } else {
                                // Archive AggRange and set new one
                                disjointAggRanges.push(currentAggRange);
                                currentAggRange = ranges[j];
                            }
                        }
                        // Archive last AggRange
                        disjointAggRanges.push(currentAggRange);

                        // Finally, build complement set of intervals
                        var remainingValues = [];

                        // Add [endValue(i), endValue(i+1)]
                        for (var k=0; k < disjointAggRanges.length - 1; k++) {
                            remainingValues.push([disjointAggRanges[k][1], disjointAggRanges[k+1][0]]);
                        }

                        return (remainingValues.length > 0) ? remainingValues : null;
                    }
                };

                // When switching for the first time to RANGE mode with a Date variable
                // must initialize conditions for first split
                var unregisterDateRangeWatch = $scope.$watch(function() {
                    var isDateColumn = Expressions.genericType($scope.getColType($scope.params.column)) === "date";
                    return ($scope.params.mode === "RANGE" && isDateColumn);
                }, function(shouldInitialize) {
                    if (!shouldInitialize) return;

                    var hasMoreThanOneSplit = ($scope.params.rangeSplits && $scope.params.rangeSplits.length > 1);
                    var conditionsOfFirstSplit = RangeExpressions.getRangeConditions($scope.params.rangeSplits, 0);
                    var firstSplitHasConditions = (conditionsOfFirstSplit && conditionsOfFirstSplit.length > 0);
                    if (hasMoreThanOneSplit || firstSplitHasConditions) {
                        unregisterDateRangeWatch();
                        return;
                    }

                    var conditions = $scope.getConditionsForFirstDateSplit($scope.params.column);
                    $scope.params.rangeSplits = [$scope.getNewRangeSplit(conditions)];
                    unregisterDateRangeWatch();
                });

            }
        }
    });

    widgets.directive('rangeInputs', function(Expressions, RangeExpressions, $timeout) {
        return {
            scope: {
                ranges: "=",
                rangeIndex: "=",
                column: "=",
                colType: "=",
                setTime: "=",
                isValidCol: "="
            },
            templateUrl: "/templates/recipes/fragments/range-inputs.html",
            link: function($scope, element) {

                $scope.getDateFormat = function() {
                    if ($scope.setTime) {
                        return RangeExpressions.dateFormats['dateWithTimeFormat'];
                    } else {
                        return RangeExpressions.dateFormats['dateFormat'];
                    }
                };

                $scope.hasMinCond = function() {
                    return RangeExpressions.hasMinCond($scope.ranges, $scope.rangeIndex);
                };

                $scope.getMinCond = function() {
                    return RangeExpressions.getMinCond($scope.ranges, $scope.rangeIndex);
                };

                $scope.getMaxCond = function() {
                    return RangeExpressions.getMaxCond($scope.ranges, $scope.rangeIndex);
                };

                $scope.hasMaxCond = function() {
                    return RangeExpressions.hasMaxCond($scope.ranges, $scope.rangeIndex);
                };

                $scope.getGenericColType = function() {
                    return Expressions.genericType($scope.colType);
                };

                $scope.deleteMinIfNecessary = function(currentValue) {
                    var shouldDeleteMin = ($scope.rangeIndex == 0);
                    if(shouldDeleteMin && (currentValue == null)) {
                        var conditions = RangeExpressions.getRangeConditions($scope.ranges, $scope.rangeIndex);
                        var index = RangeExpressions.indexOfMinCond($scope.ranges, $scope.rangeIndex);
                        if (index > -1) {
                            conditions.splice(index, 1);
                        }
                    }
                };

                $scope.deleteMaxIfNecessary = function(currentValue) {
                    var shouldDeleteMax = ($scope.ranges && ($scope.rangeIndex == $scope.ranges.length - 1));
                    if(shouldDeleteMax && (currentValue == null)) {
                        var conditions = RangeExpressions.getRangeConditions($scope.ranges, $scope.rangeIndex);
                        var index = RangeExpressions.indexOfMaxCond($scope.ranges, $scope.rangeIndex);
                        if (index > -1) {
                            conditions.splice(index, 1);
                        }
                    }
                };

                $scope.createMinCondition = function() {
                    var conditions = RangeExpressions.getRangeConditions($scope.ranges, $scope.rangeIndex);
                    if (!$scope.hasMinCond()) {
                        var minCond = RangeExpressions.createCondition(false, "min", $scope.colType, $scope.column);
                        conditions.unshift(minCond);

                        // Focus on new input Min (with little timeout to let dom create input)
                        $timeout(function() {
                            $("#inputMin"+$scope.rangeIndex).focus();
                        }, 0);
                    }
                };

                $scope.createMaxCondition = function() {
                    var conditions = RangeExpressions.getRangeConditions($scope.ranges, $scope.rangeIndex);
                    if (!$scope.hasMaxCond()) {
                        var maxCond = RangeExpressions.createCondition(true, "max", $scope.colType, $scope.column);
                        conditions.push(maxCond);

                        // Focus on new input Max (with little timeout to let dom create input)
                        $timeout(function() {
                            $("#inputMax"+$scope.rangeIndex).focus();
                        }, 0);
                    }
                };

                function syncFrontDatesWithConditions() {
                    var minCond = $scope.getMinCond();
                    if (minCond && minCond.frontDate) {
                        minCond.date = moment(minCond.frontDate, $scope.getDateFormat()).format("YYYY-MM-DD");
                        minCond.time = $scope.setTime ? moment(minCond.frontDate, $scope.getDateFormat()).format("HH:mm") : "00:00";
                    }
                    var maxCond = $scope.getMaxCond();
                    if (maxCond && maxCond.frontDate) {
                        maxCond.date = moment(maxCond.frontDate, $scope.getDateFormat()).format("YYYY-MM-DD");
                        maxCond.time = $scope.setTime ? moment(maxCond.frontDate, $scope.getDateFormat()).format("HH:mm") : "00:00";
                    }
                }

                function syncConditionsWithFrontDates() {
                    var minCond = $scope.getMinCond();
                    if (minCond && minCond.date && minCond.time) {
                        minCond.frontDate = moment(minCond.date + " " + minCond.time, RangeExpressions.dateFormats["dateWithTimeFormat"]).format($scope.getDateFormat());
                    }
                    var maxCond = $scope.getMaxCond();
                    if (maxCond && maxCond.date && maxCond.time) {
                        maxCond.frontDate = moment(maxCond.date + " " + maxCond.time, RangeExpressions.dateFormats["dateWithTimeFormat"]).format($scope.getDateFormat());
                    }
                }

                // WATCHERS

                $scope.$watch(function() {
                    var toWatch = {};
                    var minCond = $scope.getMinCond();
                    var maxCond = $scope.getMaxCond();
                    if (minCond) {
                        toWatch.min = minCond.frontDate;
                    }
                    if (maxCond) {
                        toWatch.max = maxCond.frontDate;
                    }
                    return toWatch;
                }, syncFrontDatesWithConditions, true);

                // INIT
                syncConditionsWithFrontDates();
            }
        }
    });

    widgets.directive('splitGauge', function(GaugeHelper) {
        return {
            restrict : 'A',
            template : "<svg class='split-gauge'></svg>",
            scope : {
                data : '=',
                getValuesFn : '=',
                index : '=',
                max: "=",
                min: "="
            },
            replace : true,
            link : function($scope, element, attrs) {

                // get the gauge: root of template
                var gaugeSvg = d3.select(element[0]);

                // filling the gauge
                var gaugeG = gaugeSvg.append("g").attr("class", "x brush");

                // Retrieving width and height
                var width = $(element).innerWidth();
                var height = $(element).innerHeight();

                // Building background rect
                gaugeG.append('rect')
                      .attr('class', 'gauge-background')
                      .attr('width', width)
                      .attr('height', height)
                      .attr('fill', "#f0f1f1")

                var xScale = null;

                function buildGauge() {
                    if($scope.data == null || $scope.index == null) return;

                    var rectData = GaugeHelper.getValuesModified($scope.data, $scope.index, $scope.getValuesFn, $scope.min, $scope.max);

                    // Invalid input => delete all rects
                    if (!rectData) {
                        gaugeG.selectAll('.extent').remove();
                        return;
                    }

                    // Update value of width
                    width = $(element).innerWidth();

                    var extremities = GaugeHelper.getMinMaxValue($scope.data, $scope.getValuesFn, $scope.min, $scope.max);

                    // build scale
                    xScale = GaugeHelper.buildScale(extremities, width);

                    // Adding data rects
                    // Enter
                    gaugeG.selectAll('.extent')
                          .data(rectData)
                          .enter()
                          .append('rect')
                          .attr('class', 'extent')
                          .attr("x", function(d) { return xScale(d[0]);})
                          .attr("height", height)
                          .attr('width', function(d) { return xScale(d[1]) - xScale(d[0]); });

                    // Update
                    gaugeG.selectAll('.extent')
                          .data(rectData)
                          .attr("x", function(d) { return xScale(d[0]);})
                          .attr('width', function(d) { return xScale(d[1]) - xScale(d[0]); });

                    // Remove
                    gaugeG.selectAll('.extent')
                          .data(rectData)
                          .exit()
                          .remove();

                    // Adding gradient rects if needed (to render feeling of infinity)
                    // Remove previous gradient rects
                    gaugeSvg.selectAll('.gauge-gradient').remove();

                    // Retrieving values
                    var flattenRowValues = [].concat.apply([], $scope.getValuesFn($scope.data, $scope.index));
                    // Rebuilding new gauge gradients
                    if (Math.min(...flattenRowValues) == - Infinity) {
                        var leftGradient = gaugeSvg.append('defs')
                                                   .append('linearGradient')
                                                   .attr('id', 'leftGradient');

                        leftGradient.append('stop')
                                    .attr('offset', '0%')
                                    .attr('stop-color', "#f0f1f1")
                                    .attr('stop-opacity', 1);
                        leftGradient.append('stop')
                                    .attr('offset', '100%')
                                    .attr('stop-color', "rgba(255, 255, 255, 0)")
                                    .attr('stop-opacity', 1);


                        gaugeSvg.append('rect')
                                .attr('class', 'gauge-gradient')
                                .attr('width', width / 4)
                                .attr('height', height + 2)
                                .attr('fill', "url(#leftGradient)");
                    }
                    if (Math.max(...flattenRowValues) == Infinity) {
                        var rightGradient = gaugeSvg.append('defs')
                                                   .append('linearGradient')
                                                   .attr('id', 'rightGradient');

                        rightGradient.append('stop')
                                    .attr('offset', '0%')
                                    .attr('stop-color', "rgba(255, 255, 255, 0)")
                                    .attr('stop-opacity', 1);
                        rightGradient.append('stop')
                                    .attr('offset', '100%')
                                    .attr('stop-color', "#f0f1f1")
                                    .attr('stop-opacity', 1);


                        gaugeSvg.append('rect')
                                .attr('x', 3 * width / 4)
                                .attr('class', 'gauge-gradient')
                                .attr('width', width / 4)
                                .attr('height', height + 2)
                                .attr('fill', "url(#rightGradient)");
                    }

                };


                // Add watchers
                $scope.$watch('data', function(nv, ov) {
                    if (nv == null) return;
                    buildGauge();
                }, true);
            }
        };
    });

    widgets.directive('movingSplitGauge', function(GaugeHelper) {
        return {
            restrict : 'A',
            template : "<svg class='split-gauge'></svg>",
            scope : {
                data : '=',
                getValuesFn : '=',
                updateValuesFn : '=',
                index : '=',
                max: "=",
                min: "="
            },
            replace : true,
            link : function($scope, element, attrs) {
                var handleWidth = 5;
                var handleHeight = 9;

                // get the gauge: root of template
                var gaugeSvg = d3.select(element[0]);

                // filling the gauge
                var gaugeG = gaugeSvg.append("g").attr("class", "x brush");
                var gaugeHandleG = gaugeSvg.append("g").attr("class", "x gauge-handles"); // the gauge handles (click-through)

                var xScale = null;

                // update the total range, and then the graph
                $scope.refreshRange = function() {
                    if($scope.data == null || $scope.index == null) return;

                    var extentRange = GaugeHelper.getValuesModified($scope.data, $scope.index, $scope.getValuesFn, $scope.min, $scope.max);

                    // Invalid value => remove gauge
                    if (!extentRange) {
                        gaugeG.selectAll('.extent').remove();
                        gaugeHandleG.selectAll('.resize').remove();
                    }

                    // Retrieving width and height
                    var width = $(element).innerWidth();
                    var height = $(element).innerHeight();


                    var extremities = GaugeHelper.getMinMaxValue($scope.data, $scope.getValuesFn, $scope.min, $scope.max);

                    // build scale
                    xScale = GaugeHelper.buildScale(extremities, width);

                    // prepare callbacks
                    // when dragged
                    function brushed() {
                        var extent = gauge.extent();

                        //Verify that east part of brush stays at the east
                        var currentValues = GaugeHelper.getValuesModified($scope.data, $scope.index, $scope.getValuesFn, $scope.min, $scope.max);
                        if (extent[0] < currentValues[0]) { // i.e. when the brush is inverted, what we want to prevent
                            extent = currentValues;
                        }

                        // Modify gauge extent
                        d3.select(this).call(gauge.extent(extent));

                        // Move Handle to new position of gauge
                        var xE = xScale(extent[1]);
                        gaugeHandleG.selectAll(".e").attr("transform", "translate(" + xE + ", 0)");

                        // Update converned values
                        $scope.updateValuesFn($scope.data, $scope.index, extent[0], extent[1]);
                        $scope.$apply();
                    }

                    // add display in resize e if gauge of size 0
                    function addResizeE() {
                        actualGauge.selectAll('.resize.e')
                                   .style('display', 'initial');
                    }


                    if (extentRange && (extentRange[0] != null) && (extentRange[1] != null)) {

                        var gauge = d3.svg.brush()
                                          .x(xScale)
                                          .on('brush', brushed)
                                          .on('brushend', addResizeE)
                                          .extent(extentRange);


                        //Create objects
                        var actualGauge = gaugeG.call(gauge);


                        var xE = xScale(extentRange[1]);

                        //Style the brush
                        actualGauge.selectAll("rect")
                                   .attr("y", 0)
                                   .attr("height", height);

                        actualGauge.selectAll('.extent, .background, .resize')
                                   .attr('pointer-events', 'none');

                        // Create the right handle
                        gaugeHandleG.selectAll('.resize').remove();

                        // Add pointer events
                        actualGauge.selectAll('.resize.e')
                                   .attr('pointer-events', 'all');

                        addResizeE();

                        // Add g for handle
                        gaugeHandleG.append('g').classed('resize', true).classed('e', true).attr("transform", "translate(" + xE + ", 0)");

                        var gh = gaugeHandleG.selectAll(".resize");

                        gh.append("rect")
                          .classed("separator", true)
                          .attr("y", 0)
                          .attr("height", height)
                          .attr("x", -1.5)
                          .attr("width", 3);

                        gh.append("rect")
                          .classed("handle", true)
                          .attr("y", (height - handleHeight) / 2)
                          .attr("height", handleHeight)
                          .attr("x", -(handleWidth/2))
                          .attr("width", handleWidth);
                    }

                };

                // Add watchers
                $scope.$watch('data', function(nv, ov) {
                    if (nv == null) return;
                    $scope.refreshRange();
                }, true);
            }
        };
    });

    widgets.directive('columnsSelect', function(Fn) {
        return {
            scope: {
                title: "=",
                selectedColumns: "=",
                columns: "=",
                getColType: "=",
                hasOrder: "=",
                needsInfo: "=",
                isInfoOpen: "=",
                infoText: "@"
            },
            templateUrl: "/templates/recipes/fragments/columns-select.html",
            link: function($scope) {

                // Manipulate columns : getColumns, add/remove cols from available columns

                $scope.addColumn = function(col) {
                    // Formating column
                    var formatedCol;
                    if ($scope.hasOrder) {
                        formatedCol = {column: col.name, desc: false};
                    } else {
                        formatedCol = col.name;
                    }
                    $scope.selectedColumns.push(formatedCol);
                };

                $scope.getColumn = function(col) {
                    if ($scope.hasOrder) {
                        return col.column;
                    } else {
                        return col;
                    }
                };

                $scope.removeColumn = function(idx) {
                    if (idx > -1) {
                        $scope.selectedColumns.splice(idx, 1);
                    }
                };

                $scope.isInColumns = function(col) {
                    var allColumnsNames = $scope.columns.map(Fn.prop('name'));
                    return Fn.inArray(allColumnsNames)($scope.getColumn(col));
                };

                $scope.filterSelectedColumns = function(col) {
                    var selectedColumnsNames;
                    if ($scope.hasOrder && $scope.selectedColumns) {
                        selectedColumnsNames = $scope.selectedColumns.map(Fn.prop("column"));
                    } else {
                        selectedColumnsNames = $scope.selectedColumns;
                    }
                    return (!selectedColumnsNames || !Fn.inArray(selectedColumnsNames)(col.name));
                };

                function computeTypes() {
                    $scope.types =  $scope.columns.filter($scope.filterSelectedColumns).map(function(column){ return column.type});
                }
                computeTypes();
                $scope.$watch(function() {
                    return $scope.columns.filter($scope.filterSelectedColumns);
                }, computeTypes, true);

                // Defining sortable parameters
                $scope.sortOptions = {
                    axis:'y',
                    cursor: 'move',
                    cancel:'',
                    handle: '.handle-row',
                    disable: !$scope.hasOrder
                };
            }
        };
    });

})();

(function() {
    'use strict';
    var app = angular.module('dataiku.recipes');

    app.controller("SplitRecipeCreationController", function($scope, $stateParams, $state, $controller, $q,
                   Dialogs, DataikuAPI, DatasetsService, WT1, PartitionDeps, RecipesService,
                   RecipeComputablesService, RecipesUtils, DatasetUtils, Fn) {
        $controller("_RecipeCreationControllerBase", {$scope:$scope});
        addDatasetUniquenessCheck($scope, DataikuAPI, $stateParams.projectKey);
        fetchManagedDatasetConnections($scope, DataikuAPI);
        DatasetsService.updateProjectList($stateParams.projectKey);

        $scope.recipe = {
            projectKey : $stateParams.projectKey,
            type: "split",
            inputs : {
                main: {
                    items: [{ref:'', deps: []}]
                }
            },
            outputs : {},
            params: {}
        };

        DatasetUtils.listDatasetsUsabilityInAndOut($stateParams.projectKey, "split").then(function(data){
            $scope.availableInputDatasets = data[0];
        });

        RecipeComputablesService.getComputablesMap($scope.recipe, $scope).then(function(map){
            $scope.setComputablesMap(map);
        });

        $scope.$on("preselectInputDataset", function(scope, preselectedInputDataset) {
            $scope.recipe.inputs.main.items[0].ref = preselectedInputDataset;
            $scope.preselectedInputDataset = preselectedInputDataset;
        });

        $scope.$watch("recipe.inputs.main.items[0].ref", function(nv, ov) {
            if (nv) {
                $scope.recipe.name = "split_" + nv.replace(/[A-Z]*\./,"");
                if ($scope.preselectedInputDataset && nv != $scope.preselectedInputDataset) {
                    $scope.zone = null;
                }
            }
        });
    });


    app.controller("SplitRecipeController", function ($scope, $q, $stateParams, $controller,
                   Assert, DataikuAPI, DKUtils, DatasetUtils, Dialogs, PartitionDeps, RecipeComputablesService,
                   ComputableSchemaRecipeSave, CreateModalFromTemplate, RecipesUtils, Fn, Logger, Expressions, RangeExpressions) {
        $controller("_RecipeOutputNewManagedBehavior", {$scope:$scope});
        var visualCtrl = $controller("VisualRecipeEditorController", {$scope:$scope});

        // for safety, to use the _RecipeOutputNewManagedBehavior fully (maybe one day)
        $scope.setErrorInTopScope = function(scope) {
            return setErrorInScope.bind($scope);
        };

        $scope.hooks.save = function() {
            removeUnusedOutputs();
            var deferred = $q.defer();
            var recipeSerialized = angular.copy($scope.recipe);
            PartitionDeps.prepareRecipeForSerialize(recipeSerialized);
            var serializedScript = $scope.serializeScriptData();
            ComputableSchemaRecipeSave.handleSave($scope, recipeSerialized, serializedScript, deferred);
            return deferred.promise.then(visualCtrl.saveServerParams);
        };

        // Must override convert to be able to removeUnusedOutputs before converting.
        $scope.convert = function(type, label) {
            Dialogs.confirm($scope, "Convert to " + label + " recipe",
                "Converting the recipe to "+label+" will enable you to edit the query, but you will not be able to use the visual editor anymore."+
                "<br/><strong>This operation is irreversible.</strong>")
                .then(function() {
                    removeUnusedOutputs();
                    var payloadData = $scope.hooks.getPayloadData();
                    var recipeSerialized = angular.copy($scope.recipe);
                    PartitionDeps.prepareRecipeForSerialize(recipeSerialized);
                    $scope.hooks.save().then(function() {
                        DataikuAPI.flow.recipes.visual.convert($stateParams.projectKey, recipeSerialized, payloadData, type)
                            .success(function(data) {
                                DKUtils.reloadState();
                            }).error(setErrorInScope.bind($scope));
                    });
                });
        };


        $scope.hooks.getPayloadData = function() {
            return angular.toJson($scope.params);
        };

        $scope.hooks.updateRecipeStatus = function(forceUpdate, exactPlan) {
            var deferred = $q.defer();
            var payload = $scope.hooks.getPayloadData();
            $scope.updateRecipeStatusBase(false, payload, {reallyNeedsExecutionPlan: exactPlan, exactPlan: exactPlan}).then(function() {
                // $scope.recipeStatus should have been set by updateRecipeStatusBase
                if (!$scope.recipeStatus) return deferred.reject();

                // Set sql/execution plan
                $scope.recipeStatus.multipleOutputs = true;
                if ($scope.recipeStatus.sqlWithExecutionPlanList
                    && $scope.recipeStatus.sqlWithExecutionPlanList.length > 0
                    && $scope.recipeStatus.sql === undefined) {
                        $scope.selectOutputForSql($scope.selectedOutputName);
                }
                deferred.resolve($scope.recipeStatus);
            });
            return deferred.promise;
        };

        $scope.serializeScriptData = function () {
            return angular.toJson($scope.params);
        };

        $scope.resyncSchema = function() {
            var input = RecipesUtils.getSingleInput($scope.recipe, "main");
            Dialogs.confirm($scope,
                'Resynchronize schema',
                'The schema of "'+input.ref+'" will be copied to all output datasets. Are you sure you want to continue ?'
            )
            .then(function() {
                DataikuAPI.flow.recipes.basicResyncSchema($stateParams.projectKey, $scope.hooks.getRecipeSerialized()).error(setErrorInScope.bind($scope));
            });
        };

        // UI:

        $scope.addFilterSplit = function() {
            var outputs = $scope.recipe.outputs.main.items;
            $scope.params.filterSplits.push({filter: {enabled: true}, outputIndex: 0});
        };

        $scope.removeFilterSplit = function(splitIndex) {
            $scope.params.filterSplits.splice(splitIndex, 1);
        };

        $scope.addValueSplit = function(splitIndex) {
            $scope.params.valueSplits.splice(splitIndex, 0, {value: "", outputIndex: 0});
        };

        $scope.removeValueSplit = function(splitIndex) {
            $scope.params.valueSplits.splice(splitIndex, 1);
        };

        $scope.onOutputDatasetChange = function(splitIndex) {
            var splits = $scope.getActiveSplits();
            onOutputDatasetChange(splits, splitIndex);
        };

        $scope.initSeed = function(seed){
            if (seed == undefined) {
                seed = null;
            }
        };

        $scope.showSplitModal = function() {
            CreateModalFromTemplate("/templates/recipes/fragments/split-modal.html", $scope);
        };

        $scope.getTooltipTextColumnMode = function() {
            if (!$scope.isInColumns($scope.params.column)) {
                return 'Select a column';
            } else if (!$scope.numericalOrDate($scope.getColumn($scope.params.column))) {
                var type = $scope.getColType($scope.params.column)
                return 'Cannot select ranges with \''+$scope.params.column + '\' (' + type + ')';
            } else {
                return '';
            }
        };

        // Manipulate columns : getColumns, isInColumns

        $scope.isInColumns = function(colName) {
            var allColumnsNames = $scope.getColumns().map(Fn.prop('name'));
            return Fn.inArray(allColumnsNames)(colName);
        };

        var columns = [];
        $scope.inputSchema = {columns: columns};
        $scope.getColumns = function(){
            if (!$scope.computablesMap) {
                Logger.error("Execution function before getting computablesMap");
                return;
            }
            const input = RecipesUtils.getSingleInput($scope.recipe, "main");
            const computable = $scope.computablesMap[input.ref];
            if (!computable) {
                throw new Error('Dataset is not in computablesMap, try reloading the page.');
            }
            Assert.trueish(computable.dataset, 'expected a dataset');
            if (computable.dataset.schema) listCopyContent(columns, computable.dataset.schema.columns);
            if (hasComputedColumns()) {
                $scope.params.computedColumns.forEach(function(cc) {
                    var replaced = false;
                    for(var i = 0; i < columns.length; ++i) {
                        if (columns[i].name == cc.name) {
                            columns.splice(i, 1, cc);
                            replaced = true;
                            break;
                        }
                    }
                    replaced || columns.push(cc);
                });
            }
            return columns;
        };

        $scope.numericalOrDate = function(col) {
            var allowedGenericTypes = ["num", "date"];
            var genericType = Expressions.genericType(col.type);
            return Fn.inArray(allowedGenericTypes)(genericType);
        };

        $scope.hasNumericalOrDateCols = function() {
            return $scope.getColumns().filter($scope.numericalOrDate).length > 0;
        }

        $scope.getColumn = function(name) {
            var columns = $scope.getColumns();
            return columns.filter(function(col){return col.name==name})[0];
        };

        $scope.getColType = function(colName) {
            if (!colName) return;
            var col = $scope.getColumns().filter(function(col){return col.name == colName})[0];
            if (!col) return;
            return col.type;
        };

        $scope.genericType = function(type) {
            return Expressions.genericType(type);
        };

        $scope.initColumn = function() { //init column for value matching
            var col = $scope.getColumn($scope.params.column);
            if (!col) return;
            $scope.currentGenericType = Expressions.genericType(col.type);
        };

        // Updates outputs list (with the None and Other options)
        $scope.updateOutputs = function() {
            var outputs = getOutputsRefs();
            var nOutputs = outputs.length;

            //remove all the invalid output indices
            var allSplits = getAllSplits();
            allSplits.forEach(function(split) {
                if (split.outputIndex >= nOutputs) {
                    split.outputIndex = -1;
                }
            });

            // Fill the outputs lists, which is used for the UI selectors
            $scope.outputsList = [];
            outputs.forEach(function(x, idx){
                $scope.outputsList.push({value: idx, label: x});
            });
            $scope.outputsList.push({value: '$dku_other', label: 'Other dataset...'});
            $scope.outputsList.push({value: -1, label: 'Drop data'});
        };

        $scope.onComputedColumnListUpdate = function(computedColumns) {
            $scope.params.computedColumns = angular.copy(computedColumns);
            syncComputedColumns();
        }

        $scope.getActiveSplits = function() {
            return $scope.getSplits($scope.params.mode);
        };

        $scope.getSplits = function(mode) {
            var splits;
            switch(mode){
                case "FILTERS":
                    splits = $scope.params.filterSplits;
                    break;
                case "VALUES":
                    splits = $scope.params.valueSplits;
                    break;
                case "RANDOM":
                    splits = $scope.params.randomSplits;
                    break;
                case "RANDOM_COLUMNS":
                    splits = $scope.params.randomColumnsSplits;
                    break;
                case "CENTILE":
                    splits = $scope.params.centileSplits;
                    break;
                case "RANGE":
                    splits = $scope.params.rangeSplits;
                    break;
                default:
                    Logger.error("Unknown split mode : "+mode);
            }
            return splits;
        }

        function getAllSplits() {
            var modesNames = $scope.splittingMethods.map(Fn.prop(0));
            var splits = [];
            modesNames.forEach(function(mode) {
                splits.push.apply(splits, $scope.getSplits(mode));
            });
            return splits;
        }

        function syncComputedColumns() { // Updates the schema for all filter splits taking into account input columns and computed columns
            if (!$scope.computablesMap) return;
            var schema = {columns: $scope.getColumns() || []};
            $scope.params.filterSplits.forEach(function(fs) {
                fs.filter.$status = fs.filter.$status || {};
                fs.filter.$status.schema = schema;
            });
            // Check if modifies column selected in VALUES or RANGE mode
            if ($scope.params.column) {
                var columnGenericType = Expressions.genericType($scope.getColType($scope.params.column));
                var columnNotInColumns = !$scope.isInColumns($scope.params.column);
                var genericTypeChanged = (columnGenericType !== $scope.currentGenericType);
                if (columnNotInColumns || genericTypeChanged) {
                    onColumnChange($scope.params.column);
                }
            }
        }

        $scope.getNewRangeSplit = function(conditions) {
            return {
                filter: {
                    "uiData": {
                        "mode": "&&",
                        "conditions": conditions
                    }
                },
                outputIndex: 0
            }
        };

        $scope.getConditionsForFirstDateSplit = function(colName) {
            var minCond = RangeExpressions.createCondition(true, "min", "date", colName);
            minCond.date = moment().format(RangeExpressions.dateFormats["dateFormat"]);
            minCond.frontDate = minCond.date;
            var maxCond = RangeExpressions.createCondition(false, "max", "date", colName);
            maxCond.date = moment().format(RangeExpressions.dateFormats["dateFormat"]);
            maxCond.frontDate = maxCond.date;
            return [minCond, maxCond];
        };

        var valueSplitsSave = {
            num: [{"outputIndex": 0}],
            boolean: [{"value": "true", "outputIndex": 0},{"value": "false", "outputIndex": 1}],
            other: [{"outputIndex": 0}]
        };
        var rangeSplitsSave = {
            num: [$scope.getNewRangeSplit([])],
            date: [$scope.getNewRangeSplit($scope.getConditionsForFirstDateSplit(undefined))]
        };

        function onColumnChange(columnName) {
            if (!$scope.computablesMap || !columnName || !$scope.getColumn(columnName)) return;
            var newGenericType = Expressions.genericType($scope.getColType(columnName));
            if ($scope.params.mode === "RANGE") {
                // If new generic type is not num/date go to VALUES mode
                if (!$scope.isInColumns(columnName) || !$scope.numericalOrDate($scope.getColumn(columnName))) {
                    $scope.params.mode = "VALUES";
                    onColumnChange(columnName);
                    return;
                }

                if ($scope.currentGenericType && $scope.currentGenericType !== newGenericType) {
                    // Save old splits
                    rangeSplitsSave[$scope.currentGenericType] = $scope.params.rangeSplits;
                    $scope.params.rangeSplits = rangeSplitsSave[newGenericType];
                }
                for (var i=0; i < $scope.params.rangeSplits.length; i++) {
                    var conditions = RangeExpressions.getRangeConditions($scope.params.rangeSplits, i);
                    if (conditions) {
                        conditions.forEach(function(condition) {
                            condition.input = columnName;
                            condition.operator = RangeExpressions.modifyColTypeInComparisonOperator(condition.operator, $scope.getColType(columnName));
                        });
                    }
                }
            } else if ($scope.params.mode === "VALUES") {
                if (!$scope.currentGenericType && newGenericType === "boolean" && !isBooleanValueSplits()) {
                    $scope.params.valueSplits = valueSplitsSave["boolean"];
                }
                if ($scope.currentGenericType && newGenericType !== $scope.currentGenericType) {
                    // Save old value splits
                    if (['num', 'boolean'].indexOf($scope.currentGenericType) < 0) {
                        valueSplitsSave['other'] = $scope.params.valueSplits;
                    } else {
                        valueSplitsSave[$scope.currentGenericType] = $scope.params.valueSplits;
                    }
                    // Retrieve previously saved valueSplits for new column type
                    if (newGenericType === 'num') {
                        $scope.params.valueSplits = valueSplitsSave['num'];
                    } else if (newGenericType === 'boolean') {
                        if (valueSplitsSave['boolean'].length) {
                            $scope.params.valueSplits = valueSplitsSave['boolean'];
                        } else {
                            $scope.params.valueSplits = [{"value": "true"},{"value": "false"}];
                        }
                    } else {
                        $scope.params.valueSplits = valueSplitsSave['other'];
                    }
                }
            }
            $scope.currentGenericType = newGenericType;
        }

        function isBooleanValueSplits() {
            var isDefinedAndLength2 = ($scope.params.valueSplits && $scope.params.valueSplits.length === 2);
            var isFirstTrue = ($scope.params.valueSplits[0] && $scope.params.valueSplits[0]["value"] === "true");
            var isSecondFalse = ($scope.params.valueSplits[1] && $scope.params.valueSplits[1]["value"] === "false");
            return (isDefinedAndLength2 && isFirstTrue && isSecondFalse);
        }

        function removeUnusedOutputs() {
            var outputs = $scope.recipe.outputs.main.items;
            var usedOutputIndices = $scope.getActiveSplits().map(function(s) { return s.outputIndex });
            usedOutputIndices.push($scope.params.defaultOutputIndex);
            var allSplits = getAllSplits();
            for (var i = outputs.length - 1; i >= 0; --i) {
                if (usedOutputIndices.indexOf(i) < 0) {
                    outputs.splice(i, 1);
                    // update splits
                    allSplits.forEach(function(s) {
                        if (s.outputIndex > i) {
                            s.outputIndex--;
                        }
                    });
                    if ($scope.params.defaultOutputIndex > i) {
                        $scope.params.defaultOutputIndex--;
                    }
                }
            }
        }

        function getOutputsRefs() {
            return $scope.recipe.outputs.main.items.map(function(o){return o.ref});
        }

        function refreshAvailableDatasets() {
            DatasetUtils.listDatasetsUsabilityInAndOut($stateParams.projectKey, $scope.recipe.type).then(function(data) {
                var alreadyInOutput = function(computable) {
                    if ($scope.recipe && $scope.recipe.outputs && $scope.recipe.outputs.main && $scope.recipe.outputs.main.items) {
                        return $scope.recipe.outputs.main.items.filter(function(item) {return item.ref == computable.smartName;}).length > 0;
                    } else {
                        return false;
                    }
                };
                $scope.availableOutputDatasets = data[1].filter(function(computable){
                    // console.debug(computable, computable.usableAsOutput['main'].usable, !computable.alreadyUsedAsOutputOf)
                    return computable.usableAsOutput['main'].usable && !computable.alreadyUsedAsOutputOf && !alreadyInOutput(computable);
                });
            });
        }

        function onOutputDatasetChange(splits, splitIndex) {
            function getOutputIndex(splitIndex) {
                if (splitIndex >= 0) {
                    return splits[splitIndex].outputIndex;
                }
                if (splitIndex == -1) {
                    return $scope.params.defaultOutputIndex;
                }
            }

            function setOutput(splitIndex, outputIndex) {
                if (splitIndex >= 0) {
                    splits[splitIndex].outputIndex = outputIndex;
                }
                if (splitIndex == -1) {
                    $scope.params.defaultOutputIndex = outputIndex;
                }
            }

            function addAndSetOutput(datasetRef, dismissModalCallback) {
                dismissModalCallback();
                if (getOutputsRefs().indexOf(datasetRef) < 0) {
                    $scope.recipe.outputs.main.items.push({
                        ref: datasetRef,
                        appendMode: false
                    });
                }
                setOutput(splitIndex, $scope.recipe.outputs.main.items.length - 1);
            }

            if (getOutputIndex(splitIndex) == '$dku_other') {
                var newScope = $scope.$new();
                refreshAvailableDatasets();
                newScope.ok = function(dismissModalCallback) {
                    if ($scope.io.newOutputTypeRadio == 'select') {
                        if (!$scope.io.existingOutputDataset) return;
                        addAndSetOutput($scope.io.existingOutputDataset, dismissModalCallback);
                    } else {
                        var creationSettings = {
                            connectionId : $scope.newOutputDataset.connectionOption.id,
                            specificSettings : {
                                formatOptionId : $scope.newOutputDataset.formatOptionId,
                                overrideSQLCatalog: $scope.newOutputDataset.overrideSQLCatalog,
                                overrideSQLSchema: $scope.newOutputDataset.overrideSQLSchema
                            },
                            partitioningOptionId : $scope.newOutputDataset.partitioningOption,
                            zone: $scope.zone
                        };
                        DataikuAPI.datasets.newManagedDataset($stateParams.projectKey, $scope.newOutputDataset.name, creationSettings).success(function(dataset) {
                            RecipeComputablesService.getComputablesMap($scope.recipe, $scope).then(function(map){
                                $scope.setComputablesMap(map);
                                addAndSetOutput($scope.newOutputDataset.name, dismissModalCallback);
                            }, setErrorInScope.bind(newScope));
                        }).error(setErrorInScope.bind(newScope));
                    }
                };
                newScope.singleOutputRole = {name:"main", arity:"UNARY", acceptsDataset:true};

                setOutput(splitIndex, -1); // We must not keep $dku_other selected
                CreateModalFromTemplate("/templates/recipes/io/output-selection-modal.html", newScope);
            }
        }

        function hasComputedColumns() {
            return !!($scope.params && $scope.params.computedColumns && $scope.params.computedColumns.length);
        }

        function initDefaultOutputIndex() {
            var hasMoreThanOneOutput = ($scope.recipe.outputs.main.items && $scope.recipe.outputs.main.items.length > 1);
            if ($scope.params.defaultOutputIndex === 1 && !hasMoreThanOneOutput) {
                $scope.params.defaultOutputIndex = -1;
            }
        }

        $scope.openCloseInfo = function() {
            $scope.randomColumnsInfoOpen = !$scope.randomColumnsInfoOpen;
        };

        $scope.splittingMethods = [
            ['VALUES', 'Map values of a single column to the outputs datasets'],
            ['FILTERS', 'Define a filter for each output dataset'],
            ['RANDOM', 'Randomly split to the output datasets with exact ratio'],
            ['RANDOM_COLUMNS', 'Randomly split to the output datasets based on values of multiple columns'],
            ['CENTILE', 'Sort-based / centile split'],
            ['RANGE', 'Split on range of values for a column']
        ];

        $scope.randomSplittingMethods = [
            ["RANDOM", "Full random"],
            ["RANDOM_COLUMNS", "Random subset of column(s) values"],
        ];

        $scope.randomSplittingMethodsDesc = [
            'Randomly splits the dataset according to the provided ratios (exact when using DSS engine, approximate otherwise).',
            'Randomly selects a subset of values of one or more columns and send all rows with these values to an output, in order to obtain approximately the provided ratio for this output. Two outputs cannot contain the same values.'
        ];

        $scope.valuesSplittingMethods = [
            ["VALUES", "Discrete values"],
            ["RANGE", "Ranges"],
        ];

        $scope.columnTypes = [
            {name:'TINYINT',label:'tinyint (8 bit)'},
            {name:'SMALLINT',label:'smallint (16 bit)'},
            {name:'INT',label:'int'},
            {name:'BIGINT',label:'bigint (64 bit)'},
            {name:'FLOAT',label:'float'},
            {name:'DOUBLE',label:'double'},
            {name:'BOOLEAN',label:'boolean'},
            {name:'STRING',label:'string'},
            {name:'DATE',label:'date'},
            {name:'ARRAY',label:'array<...>'},
            {name:'MAP',label:'map<...>'},
            {name:'OBJECT',label:'object<...>'}
        ];

        $scope.hooks.onRecipeLoaded = function(){
            Logger.info("On Recipe Loaded");
            $scope.updateOutputs();
            $scope.inputDatasetName = RecipesUtils.getSingleInput($scope.recipe, "main").ref;
            $scope.hooks.updateRecipeStatus();

            //keep params for dirtyness detection
            visualCtrl.saveServerParams();

            /** setup for new output modal **/
            refreshAvailableDatasets();
            DataikuAPI.datasets.getManagedDatasetOptions($scope.recipe, 'main').success(function(data) {
                $scope.setupManagedDatasetOptions(data);
            });
            $scope.io = $scope.io || {};
            $scope.io.newOutputTypeRadio = 'select';

            /** Listeners **/
            $scope.$watch("recipe.params", $scope.updateRecipeStatusLater, true);
            $scope.$watch('params.column', onColumnChange);
            $scope.$watch('mode', DKUtils.reflowNext);
            $scope.$watchCollection('recipe.outputs.main.items', $scope.updateOutputs);
            $scope.$watchCollection('params.filterSplits', syncComputedColumns);
            $scope.$watch('params.computedColumns', syncComputedColumns, true);
            $scope.$watch('params', $scope.updateRecipeStatusLater, true);
        };

        $scope.params = {};
        if ($scope.script && $scope.script.data) {
            $scope.params = JSON.parse($scope.script.data);
        }
        var defaults = {
            mode: null,
            filterSplits: [], //list of {filter: [object], outputIndex: [string]} for FILTERS mode
            valueSplits: [], //list of {value: [string], outputIndex: [string]} for VALUES mode
            randomSplits: [], //list of {share: [int], outputIndex: [string]} for RANDOM mode
            randomColumnsSplits: [], //list of {share: [int], outputIndex: [string]} for RANDOM_COLUMNS mode
            centileSplits: [], //list of {share: [int], outputIndex: [string]} for RANDOM_COLUMNS mode
            randomColumns: [], //list of strings of selected columns for RANDOM_COLUMNS mode
            rangeSplits: [], //list of {filter: [object], outputIndex: [string]} for RANGE mode
            centileOrders: [], //list of strings of selected columns for CENTILE mode
            preFilter: {}, // object containing potential prefilters
            defaultOutputIndex: -1
        };

        $scope.params = $.extend({}, defaults, $scope.params);
        for (let vs of $scope.params.valueSplits || []) {
            if (vs.value == null) {
                vs.value = '';
            }
        }
        $scope.params.filterSplits.length  || $scope.addFilterSplit();
        initDefaultOutputIndex();

        $scope.specificControllerLoadedDeferred.resolve();
        $scope.enableAutoFixup();
        $scope.uiState = {
            currentStep: 'splitting',
            outputColumnNamesOverridable: false,
            computedColumns: angular.copy($scope.params.computedColumns)
        };
        $scope.randomColumnsInfoOpen = false;
    });

})();

(function() {
    'use strict';
    var app = angular.module('dataiku.recipes');

    app.controller("TopNRecipeCreationController", function($scope, $controller) {
        $scope.recipeType = "topn";
        $controller("SingleOutputDatasetRecipeCreationController", {$scope:$scope});

        $scope.autosetName = function() {
            if ($scope.io.inputDataset) {
                var niceInputName = $scope.io.inputDataset.replace(/[A-Z]*\./,"");
                $scope.maybeSetNewDatasetName(niceInputName + "_topn");
            }
        };
    });


    app.controller("TopNRecipeController", function ($scope, $q, $controller, DKUtils, RecipesUtils, Logger, DatasetUtils, $stateParams) {
        var visualCtrl = $controller('VisualRecipeEditorController', {$scope: $scope}); //Controller inheritance
        this.visualCtrl = visualCtrl;

        /******  order columns *****/
        $scope.addOrderColumn = function(col) {
            var orderList = $scope.uiState.columnStatus
                                .filter(function(c){return c.status=='S'})
                                .map(function(c){return c.order || 0;});
            var nextOrder = orderList.length ? Math.max.apply(null, orderList) + 1 : 0;
            col.status = 'S';
            col.order = nextOrder;
        };
        $scope.removeOrderColumn = function(col) {
            var colOrder = col.order;
            col.status = 'X';
            $scope.uiState.columnStatus.forEach(function(c) {
                if (c.status == 'S' && (c.order || 0) >= colOrder) {
                    c.order = Math.max((c.order || 0) - 1, 0);
                }
            });
        };

        /******  retrieved column selection *****/
        $scope.selectLine = function(event, col, ignore) {
            event.preventDefault();
            var hasLastSelection = $scope.uiState.columnStatus.filter(function(c) {
                return c.ignore == ignore && !!c.$lastSelection;
            }).length > 0 ;
            if (event.shiftKey && hasLastSelection) {
                var selecting = false;
                for (var i = 0; i < $scope.uiState.columnStatus.length; i++) {
                    var c = $scope.uiState.columnStatus[i];
                    if (c.ignore != ignore) {
                        continue;
                    }
                    var bound = !!c.$lastSelection || c.name === col.name;
                    var firstBound = !selecting && bound;
                    var lastBound = !!selecting && bound;
                    if (firstBound) {
                        selecting = true;
                        c.$selected = true;
                    }
                    c.$selected = selecting;
                    if (lastBound) {
                        selecting = false;
                    }
                }
            } else {
                // refresh the last clicked item
                $scope.uiState.columnStatus
                        .filter(function(c) {
                            return c.ignore == ignore;
                        }).forEach(function(c) {
                            c.$lastSelection = c.name === col.name;
                        });
                // handle meta/ctrl click or normal click
                if (event.metaKey || event.ctrlKey) {
                    col.$selected = !col.$selected;
                } else {
                    $scope.uiState.columnStatus
                        .filter(function(c) {
                            return c.ignore == ignore;
                        }).forEach(function(c) {
                            c.$selected = c.name === col.name;
                        });
                }
            }
        };

        function assignIgnoreSelected(ignore, selected) {
            return function(col) {
                col.ignore = ignore;
                col.$selected = selected;
                col.$lastSelection = false;
            }
        }

        $scope.removeAllRetrievedColumns = function() {
            if (!$scope.uiState.columnStatus) {
                return;
            }
            $scope.uiState.columnStatus.forEach(assignIgnoreSelected(true, false));
        };
        $scope.addAllRetrievedColumns = function() {
            if (!$scope.uiState.columnStatus) {
                return;
            }
            $scope.uiState.columnStatus.forEach(assignIgnoreSelected(false, false));
        };
        $scope.removeRetrievedColumns = function(col) {
            if (col) {
                assignIgnoreSelected(true, false)(col);
            } else if ($scope.uiState.columnStatus) {
                $scope.uiState.columnStatus
                    .filter(function(col){
                        return !col.ignore && col.$selected;
                    }).forEach(assignIgnoreSelected(true, false));
            }
        };
        $scope.addRetrievedColumns = function(col) {
            if (col) {
                assignIgnoreSelected(false, false)(col);
            } else if ($scope.uiState.columnStatus) {
                $scope.uiState.columnStatus
                    .filter(function(col) {
                        return col.ignore && col.$selected;
                    }).forEach(assignIgnoreSelected(false, false));
            }
        };

        /******  recipe related *****/
        $scope.hooks.getPayloadData = function () {
            return angular.toJson($scope.params);
        };

        $scope.hooks.updateRecipeStatus = function(forceUpdate, exactPlan) {
            var payload = $scope.hooks.getPayloadData();
            if (!payload) {
                return $q.reject("payload not ready");
            }
            var deferred = $q.defer();
            $scope.updateRecipeStatusBase(forceUpdate, payload, {reallyNeedsExecutionPlan: exactPlan, exactPlan: exactPlan}).then(function() {
                // $scope.recipeStatus should have been set by updateRecipeStatusBase
                if (!$scope.recipeStatus) {
                    return deferred.reject();
                }
                var outputSchema = $scope.recipeStatus.outputSchema;
                var outputSchemaBO = $scope.recipeStatus.outputSchemaBeforeOverride;
                if (outputSchema) {
                    // override handling:

                    $scope.params.outputColumnNameOverrides = $scope.params.outputColumnNameOverrides || {};
                    var columnsAO = outputSchema.columns; // after override
                    var columnsBO = (outputSchemaBO && outputSchemaBO.columns) ? outputSchemaBO.columns : columns; // before override

                    for (var i in columnsAO) {
                        if (columnsAO[i].name != columnsBO[i].name) {
                            $scope.params.outputColumnNameOverrides[columnsBO[i].name] = columnsAO[i].name;
                        }
                        columnsAO[i].$beforeOverride = columnsBO[i].name;
                        columnsAO[i].name = $scope.params.outputColumnNameOverrides[columnsBO[i].name] || columnsBO[i].name;
                    }
                }
                deferred.resolve($scope.recipeStatus);
            });
            return deferred.promise;
        };

        /******  overrides *****/
        $scope.updateColumnNameOverride = function(column) {
            if (column.$beforeOverride != column.name) {
                $scope.params.outputColumnNameOverrides[column.$beforeOverride] = column.name;
            } else {
                delete $scope.params.outputColumnNameOverrides[column.$beforeOverride];
            }
        };

        /******  filters  ******/
        function validateFilters() {
            if (!$scope.params) {
                return;//not ready
            }
            var inputRef = RecipesUtils.getSingleInput($scope.recipe, "main").ref;
            var inputSchema = $scope.computablesMap[inputRef].dataset.schema;
            validateFilter($scope.params.preFilter, inputSchema);
        }

        function validateFilter(filterDesc, schema) {
            if (!filterDesc || !filterDesc.enabled) {
                return;
            }
            if (angular.isUndefined(filterDesc.expression)) {
                return;
            }
            var deferred = $q.defer();
            Expressions.validateExpression(filterDesc.expression, schema)
                .success(function(data) {
                    if (data.ok && $scope.mustRunInDatabase && !data.fullyTranslated) {
                        data.ok = false;
                    }
                    filterDesc.$status = data;
                    filterDesc.$status.validated = true;
                    deferred.resolve(data);
                })
                .error(function() {
                    setErrorInScope.bind($scope);
                    deferred.reject('Error while validating filter');
                });
            return deferred.promise;
        }

        /* callback given to the filter module */
        $scope.onFilterUpdate = $scope.updateRecipeStatusLater;

        /****** computed columns ********/
        function computedColumnListUpdated(computedColumns) {
            $scope.params.computedColumns = angular.copy(computedColumns);
            $scope.updateRecipeStatusLater();
        }

        /* callback given to the computed columns module */
        $scope.onComputedColumnListUpdate = computedColumnListUpdated;

        function loadParamsFromScript(scriptData) {
            if (!scriptData) {
                return;
            }
            $scope.params = JSON.parse(scriptData);
            $scope.params.keys = $scope.params.keys || [];
            $scope.params.orders = $scope.params.orders || [];
            $scope.params.preFilter = $scope.params.preFilter || {};
            $scope.params.computedColumns = $scope.params.computedColumns || [];
            $scope.params.outputColumnNameOverrides = $scope.params.outputColumnNameOverrides || {};
            $scope.params.retrievedColumns = $scope.params.retrievedColumns || [];

            var i;
            $scope.uiState.columnStatus = angular.copy($scope.getColumns());
            var columnStatusNames = $scope.uiState.columnStatus.map(function(col){return col.name});
            var addedComputedColumns = [];
            for (i = 0; i < $scope.params.computedColumns.length; i++) {
                var computedCol = $scope.params.computedColumns[i];
                // the computed column name must be valid and should not exists in
                // the input schema or if it was already added as a computed column
                if (computedCol.name
                    && computedCol.name.length > 0
                    && columnStatusNames.indexOf(computedCol.name) == -1
                    && addedComputedColumns.indexOf(computedCol.name) == -1) {
                    addedComputedColumns.push(computedCol.name);
                    $scope.uiState.columnStatus.push({
                        name: computedCol.name,
                        type: computedCol.type
                    });
                }
            }
            $scope.uiState.retrieveAllColumns = $scope.params.retrievedColumns.length == 0 || $scope.params.retrievedColumns.length == $scope.uiState.columnStatus.length;
            $scope.uiState.columnStatus.forEach(function(col) {
                col.ignore = !$scope.uiState.retrieveAllColumns && $scope.params.retrievedColumns.indexOf(col.name) == -1;
                col.status = 'X';
            });
            // refresh the column status names (because some computed columns could have been added since last computation)
            columnStatusNames = ($scope.uiState.columnStatus || []).map(function(col){return col.name});
            var orderIdx = 0;
            for (i = 0; i < $scope.params.orders.length; i++) {
                var order = $scope.params.orders[i];
                var csnIdx = columnStatusNames.indexOf(order.column);
                if (csnIdx >= 0) {
                    $scope.uiState.columnStatus[csnIdx].status = 'S';
                    $scope.uiState.columnStatus[csnIdx].desc = !!order.desc;
                    $scope.uiState.columnStatus[csnIdx].order = orderIdx++;
                }
            }
            var hasGroupKey = false;
            $scope.params.keys.forEach(function(column) {
                var csnIdx = columnStatusNames.indexOf(column);
                if (csnIdx >= 0) {
                    hasGroupKey = true;
                    $scope.uiState.columnStatus[csnIdx].status = 'G';
                }
            });

            $scope.uiState.computedColumns = angular.copy($scope.params.computedColumns);
            $scope.uiState.fromSelection = hasGroupKey ? 'GROUPS' : 'WHOLE';

            //keep params for dirtyness detection
            visualCtrl.saveServerParams();

            // update recipe according to current schema
            resyncWithInputSchema();
            onColumnStatusChanged();
        }


        function resyncWithInputSchema() {
            // in case the dataset schema changed since the recipe creation/last edition
            var inputColumns = $scope.getColumns();

            var newColumnStatus = [];
            var oldColumnStatusNames = ($scope.uiState.columnStatus || []).map(function(col){return col.name});
            inputColumns.forEach(function(col) {
                var oldCSNIdx = oldColumnStatusNames.indexOf(col.name);
                if (oldCSNIdx >= 0) {
                    newColumnStatus.push(angular.extend($scope.uiState.columnStatus[oldCSNIdx], col));
                } else {
                    newColumnStatus.push(angular.extend(col, { status: 'X' }));
                }
            });
            var inputColumnNames = newColumnStatus.map(function(col){return col.name});
            var addedComputedColumns = [];
            if ($scope.params && $scope.params.computedColumns) {
                for (var i = 0; i < $scope.params.computedColumns.length; i++) {
                    var cc = $scope.params.computedColumns[i];
                    if (cc.name
                        && cc.name.length > 0
                        && inputColumnNames.indexOf(cc.name) == -1
                        && addedComputedColumns.indexOf(cc.name) == -1) {
                        addedComputedColumns.push(cc.name);
                        var col = {
                            name: cc.name,
                            type: cc.type
                        };
                        var oldCSNIdx = oldColumnStatusNames.indexOf(cc.name);
                        if (oldCSNIdx >= 0) {
                            newColumnStatus.push(angular.extend($scope.uiState.columnStatus[oldCSNIdx], col));
                        } else {
                            newColumnStatus.push(angular.extend(col, { status: 'X' }));
                        }
                    }
                }
            }
            $scope.uiState.columnStatus = newColumnStatus;
        }


        function onColumnStatusChanged() {
            if (!$scope.params) {
                return;
            }
            $scope.params.keys = ($scope.uiState.columnStatus || [])
                                                .filter(function(col){return col.status=='G'})
                                                .map(function(col){return col.name});
            $scope.params.orders = ($scope.uiState.columnStatus || [])
                                                .filter(function(col){return col.status=='S'})
                                                .sort(function(col1,col2){return col1.order-col2.order})
                                                .map(function(col){return {column: col.name, desc: !!col.desc}});
            $scope.params.retrievedColumns = ($scope.uiState.columnStatus || [])
                                                .filter(function(col){return $scope.uiState.retrieveAllColumns || !col.ignore})
                                                .map(function(col){return col.name});
            $scope.uiState.orderList = ($scope.uiState.columnStatus || [])
                                                .filter(function(col){return col.status=='S'})
                                                .sort(function(col1,col2){return col1.order-col2.order});
            $scope.updateRecipeStatusLater();
        }

        function onRetrieveAllColumnsChanged(nv) {
            if (nv) {
                $scope.addAllRetrievedColumns();
            }
            onColumnStatusChanged();
        }

        function onFromSelectionChanged(nv) {
            if (nv) {
                if (nv == 'WHOLE') {
                    ($scope.uiState.columnStatus || []).forEach(function(col){
                        if (col.status == 'G') {
                            col.status = 'X';
                        }
                    });
                }
            }
            onColumnStatusChanged();
        }

        function onOrderListChanged(nv) {
            if (nv) {
                var orders = {};
                ($scope.uiState.orderList || []).forEach(function(col,idx){orders[col.name]=idx});
                ($scope.uiState.columnStatus || []).forEach(function(col){col.order=orders[col.name]});
            }
        }

        function onScriptChanged(nv) {
             if (nv) {
                loadParamsFromScript($scope.script.data);
                DKUtils.reflowNext();
                DKUtils.reflowLater();
                $scope.hooks.updateRecipeStatus();
            }
        }

        // UI:
        $scope.uiState = {
            currentStep: 'topn',
            outputColumnNamesOverridable: true,
            retrieveAllColumns: true,
            computedColumns: [],
            fromSelection: 'WHOLE',
        };

        $scope.getFullStatus = function(status) {
            switch (status) {
                case 'G': return 'Group';
                case 'S': return 'Sort';
                default: return '';
            }
        };

        $scope.getDsOrGrpLabel = function() {
            return $scope.uiState.columnStatus.filter(function(col){return col.status=='G'}).length == 0 ? 'the whole dataset' : 'its group';
        };

        $scope.hooks.onRecipeLoaded = function(){
            Logger.info("On Recipe Loaded");
            validateFilters();
            $scope.$watch("script.data", onScriptChanged, true);  // this will call onScriptChanged and $scope.hooks.updateRecipeStatus when ready
        };

        $scope.enableAutoFixup();
        $scope.specificControllerLoadedDeferred.resolve();
        $scope.$watchCollection("recipe.inputs.main.items", function() {
            DatasetUtils.updateRecipeComputables($scope, $scope.recipe, $stateParams.projectKey, $stateParams.projectKey)
                .then(_ => resyncWithInputSchema());
        });
        $scope.$watch("uiState.columnStatus", onColumnStatusChanged, true);
        $scope.$watch("uiState.orderList", onOrderListChanged, true);
        $scope.$watch("uiState.retrieveAllColumns", onRetrieveAllColumnsChanged, true);
        $scope.$watch("uiState.fromSelection", onFromSelectionChanged);
        $scope.$watch("params.computedColumns", resyncWithInputSchema, true);
        $scope.$watch("params", $scope.updateRecipeStatusLater, true);
    });

})();
(function() {
    'use strict';
    var app = angular.module('dataiku.recipes');

    app.controller("SortRecipeCreationController", function($scope, $controller) {
        $scope.recipeType = "sort";
        $controller("SingleOutputDatasetRecipeCreationController", {$scope:$scope});

        $scope.autosetName = function() {
            if ($scope.io.inputDataset) {
                var niceInputName = $scope.io.inputDataset.replace(/[A-Z]*\./,"");
                $scope.maybeSetNewDatasetName(niceInputName + "_sorted");
            }
        }
    });

    app.controller("SortRecipeController", function($scope, $controller, $q, DKUtils, RecipesUtils, Logger, DatasetUtils, $stateParams) {
        var visualCtrl = $controller('VisualRecipeEditorController', {$scope: $scope}); // Controller inheritance
        this.visualCtrl = visualCtrl;

        let contextProjectKey = $scope.context && $scope.context.projectKey ? $scope.context.projectKey : $stateParams.projectKey;
        /******  order columns  ******/
        $scope.addOrderColumn = function(col) {
            var orderList = $scope.uiState.columnStatus
                                .filter(function(c){return c.status=='S'})
                                .map(function(c){return c.order || 0;});
            var nextOrder = orderList.length ? Math.max.apply(null, orderList) + 1 : 0;
            col.status = 'S';
            col.order = nextOrder;
        };
        $scope.removeOrderColumn = function(col) {
            var colOrder = col.order;
            col.status = 'X';
            $scope.uiState.columnStatus.forEach(function(c) {
                if (c.status == 'S' && (c.order || 0) >= colOrder) {
                    c.order = Math.max((c.order || 0) - 1, 0);
                }
            });
        };

        /******. recipe related. ******/
        $scope.hooks.getPayloadData = function() {
            return angular.toJson($scope.params);
        };

        $scope.hooks.updateRecipeStatus = function(forceUpdate, exactPlan) {
            var payload = $scope.hooks.getPayloadData();
            if (!payload) {
                return $q.reject("payload not ready");
            }
            var deferred = $q.defer();
            $scope.updateRecipeStatusBase(forceUpdate, payload, {reallyNeedsExecutionPlan: exactPlan, exactPlan: exactPlan}).then(function() {
                // $scope.recipeStatus should have been set by updateRecipeStatusBase
                if (!$scope.recipeStatus) {
                    return deferred.reject();
                }
                var outputSchema = $scope.recipeStatus.outputSchema;
                var outputSchemaBO = $scope.recipeStatus.outputSchemaBeforeOverride;
                if (outputSchema) {
                    // override handling:

                    $scope.params.outputColumnNameOverrides = $scope.params.outputColumnNameOverrides || {};
                    var columnsAO = outputSchema.columns; // after override
                    var columnsBO = (outputSchemaBO && outputSchemaBO.columns) ? outputSchemaBO.columns : columns; // before override

                    for (var i in columnsAO) {
                        if (columnsAO[i].name != columnsBO[i].name) {
                            $scope.params.outputColumnNameOverrides[columnsBO[i].name] = columnsAO[i].name;
                        }
                        columnsAO[i].$beforeOverride = columnsBO[i].name;
                        columnsAO[i].name = $scope.params.outputColumnNameOverrides[columnsBO[i].name] || columnsBO[i].name;
                    }
                }
                deferred.resolve($scope.recipeStatus);
            });
            return deferred.promise;
        };

        /******. overrides. ******/
        $scope.updateColumnNameOverride = function(column) {
            if (column.$beforeOverride != column.name) {
                $scope.params.outputColumnNameOverrides[column.$beforeOverride] = column.name;
            } else {
                delete $scope.params.outputColumnNameOverrides[column.$beforeOverride];
            }
        }

        /******  filters  ******/
        function validateFilters() {
            if (!$scope.params) {
                return; // not ready
            }
            var inputRef = RecipesUtils.getSingleInput($scope.recipe, "main").ref;
            var inputSchema = $scope.computablesMap[inputRef].dataset.schema;
            validateFilter($scope.params.preFilter, inputSchema);
        }

        function validateFilter(filterDesc, schema) {
            if (!filterDesc || !filterDesc.enabled) {
                return;
            }
            if (angular.isUndefined(filterDesc.expression)) {
                return;
            }
            var deferred = $q.defer();
            Expressions.validateExpression(filterDesc.expression, schema)
                .success(function(data) {
                    if (data.ok && $scope.mustRunInDatabase && !data.fullyTranslated) {
                        data.ok = false;
                    }
                    filterDesc.$status = data;
                    filterDesc.$status.validated = true;
                    deferred.resolve(data);
                })
                .error(function() {
                    setErrorInScope.bind($scope);
                    deferred.reject('Error while validating filter');
                });
            return deferred.promise;
        }

        /* callback given to the filter module */
        $scope.onFilterUpdate = $scope.updateRecipeStatusLater;

        /****** computed columns ********/
        function computedColumnListUpdated(computedColumns) {
            $scope.params.computedColumns = angular.copy(computedColumns);
            $scope.updateRecipeStatusLater();
        }

        /* callback given to the computed columns module */
        $scope.onComputedColumnListUpdate = computedColumnListUpdated;

        function loadParamsFromScripts(scriptData) {
            if (!scriptData) {
                return;
            }
            $scope.params = JSON.parse(scriptData);
            $scope.params.orders = $scope.params.orders || [];
            $scope.params.preFilter = $scope.params.preFilter || {};
            $scope.params.outputColumnNameOverrides = $scope.params.outputColumnNameOverrides || {};
            $scope.params.computedColumns = $scope.params.computedColumns || [];

            var i;
            $scope.uiState.columnStatus = angular.copy($scope.getColumns());
            var columnStatusNames = ($scope.uiState.columnStatus || []).map(function(col){return col.name});
            var addedComputedColumns = [];
            for (i = 0; i < $scope.params.computedColumns.length; i++) {
                var computedCol = $scope.params.computedColumns[i];
                // the computed column name must be valid and should not exists in
                // the input schema or if it was already added as a computed column
                if (computedCol.name
                    && computedCol.name.length > 0
                    && columnStatusNames.indexOf(computedCol.name) == -1
                    && addedComputedColumns.indexOf(computedCol.name) == -1) {
                    addedComputedColumns.push(computedCol.name);
                    $scope.uiState.columnStatus.push({
                        name: computedCol.name,
                        type: computedCol.type
                    });
                }
            }
            ($scope.uiState.columnStatus || []).forEach(function(col) {
                col.status = 'X';
            });
            // refresh the column status names (because some computed columns could have been added since last computation)
            columnStatusNames = ($scope.uiState.columnStatus || []).map(function(col){return col.name});
            var orderIdx = 0;
            for (i = 0; i < $scope.params.orders.length; i++) {
                var order = $scope.params.orders[i];
                var csnIdx = columnStatusNames.indexOf(order.column);
                if (csnIdx >= 0) {
                    $scope.uiState.columnStatus[csnIdx].status = 'S';
                    $scope.uiState.columnStatus[csnIdx].desc = !!order.desc;
                    $scope.uiState.columnStatus[csnIdx].order = orderIdx++;
                }
            }

            $scope.uiState.computedColumns = angular.copy($scope.params.computedColumns);

            // keep params for dirtyness detection
            visualCtrl.saveServerParams();

            // update recipe according to current schema
            resyncWithInputSchema();
            onColumnStatusChanged();
        }

        function resyncWithInputSchema() {
            // in cas the dataset schema changed since the recipe creation/last edition
            var inputColumns = $scope.getColumns();

            var newColumnStatus = [];
            var oldColumnStatusNames = ($scope.uiState.columnStatus || []).map(function(col){return col.name});
            inputColumns.forEach(function(col) {
                var oldCSNIdx = oldColumnStatusNames.indexOf(col.name);
                if (oldCSNIdx >= 0) {
                    newColumnStatus.push(angular.extend($scope.uiState.columnStatus[oldCSNIdx], col));
                } else {
                    newColumnStatus.push(angular.extend(col, { status: 'X' }));
                }
            });
            var inputColumnNames = newColumnStatus.map(function(col){return col.name});
            var addedComputedColumns = [];
            if ($scope.params && $scope.params.computedColumns) {
                for (var i = 0; i < $scope.params.computedColumns.length; i++) {
                    var cc = $scope.params.computedColumns[i];
                    if (cc.name
                        && cc.name.length > 0
                        && inputColumnNames.indexOf(cc.name) == -1
                        && addedComputedColumns.indexOf(cc.name) == -1) {
                        addedComputedColumns.push(cc.name);
                        var col = {
                            name: cc.name,
                            type: cc.type
                        };
                        var oldCSNIdx = oldColumnStatusNames.indexOf(cc.name);
                        if (oldCSNIdx >= 0) {
                            newColumnStatus.push(angular.extend($scope.uiState.columnStatus[oldCSNIdx], col));
                        } else {
                            newColumnStatus.push(angular.extend(col, { status: 'X' }));
                        }
                    }
                }
            }
            $scope.uiState.columnStatus = newColumnStatus;
        }

        function onColumnStatusChanged() {
            if (!$scope.params) {
                return;
            }
            $scope.params.orders = ($scope.uiState.columnStatus || [])
                                                    .filter(function(col){return col.status=='S'})
                                                    .sort(function(col1,col2){return col1.order-col2.order})
                                                    .map(function(col){return {column: col.name, desc: !!col.desc}});
            $scope.uiState.orderList = ($scope.uiState.columnStatus || [])
                                                    .filter(function(col){return col.status=='S'})
                                                    .sort(function(col1,col2){return col1.order-col2.order});
            $scope.updateRecipeStatusLater();
        }

        function onOrderListChanged(nv) {
            if (nv) {
                var orders = {};
                ($scope.uiState.orderList || []).forEach(function(col,idx){orders[col.name]=idx});
                ($scope.uiState.columnStatus || []).forEach(function(col){col.order=orders[col.name]});
            }
        }

        function onScriptChanged(nv) {
            if (nv) {
                loadParamsFromScripts($scope.script.data);
                DKUtils.reflowNext();
                DKUtils.reflowLater();
                $scope.hooks.updateRecipeStatus();
            }
        }

        /******  UI ******/
        $scope.uiState = {
            currentStep: 'sort',
            outputColumnNamesOverridable: true,
            computedColumns: []
        };

        $scope.hooks.onRecipeLoaded = function() {
            Logger.info("On Recipe Loaded");
            validateFilters();
            $scope.$watch("script.data", onScriptChanged, true);  // this will call $scope.hooks.updateRecipeStatus when ready
        };

        $scope.showOrderPreservationMessage = function(messages) {
            if (!messages) return; //not ready
            return messages.filter(msg => msg.code == 'SORT_OUTPUT_DS_ORDER_NOT_SUPPORTED').length;
        };

        $scope.enableAutoFixup();
        $scope.specificControllerLoadedDeferred.resolve();
        $scope.$watchCollection("recipe.inputs.main.items", function() {
            DatasetUtils.updateRecipeComputables($scope, $scope.recipe, $stateParams.projectKey, contextProjectKey)
                .then(_ => resyncWithInputSchema());
        });
        $scope.$watch("uiState.columnStatus", onColumnStatusChanged, true);
        $scope.$watch("uiState.orderList", onOrderListChanged, true);
        $scope.$watch("params.computedColumns", resyncWithInputSchema, true);
        $scope.$watch("params", $scope.updateRecipeStatusLater, true);
    });

})();
(function() {
    'use strict';
    var app = angular.module('dataiku.recipes');

    app.controller("PivotRecipeCreationController", function($scope, $controller, Fn) {
        $scope.recipeType = "pivot";
        $controller("SingleOutputDatasetRecipeCreationController", {$scope:$scope});

        $scope.autosetName = function() {
            if ($scope.io.inputDataset && $scope.io.targetVariable) {
                var niceInputName = $scope.io.inputDataset.replace(/[A-Z]*\./,"");
                var niceTargetVariable = $scope.io.targetVariable.replace(/[^\w ]+/g,"").replace(/ +/g,"_");
                $scope.maybeSetNewDatasetName(niceInputName + "_by_" + niceTargetVariable);
            }
        };

        $scope.getCreationSettings = function () {
            return {key: $scope.io.targetVariable};
        };

        var superFormIsValid = $scope.formIsValid;
        $scope.formIsValid = function() {
            return !!(superFormIsValid() && $scope.io.targetVariable !== undefined);
        };
        $scope.showOutputPane = function() {
            return !!($scope.io.inputDataset && $scope.io.targetVariable !== undefined);
        };

        $scope.$watch("io.targetVariable", Fn.doIfNv($scope.autosetName));
    });

    
    app.controller("EditCustomAggregatesController", function ($scope, $q, Logger, $timeout, Dialogs, DataikuAPI, $stateParams) {
        $scope.commitAggregates = function() {
            $scope.doCommitAggregates($scope.customAggregates);
            $scope.dismiss();
        };
        
        $scope.addAggregate = function() {
            $scope.customAggregates.push({name:"custom_" + $scope.customAggregates.length, label:null, suffix:null, expression:"", type:"string"});
        };
        $scope.removeAggregate = function(aggregate) {
            var idx = $scope.customAggregates.indexOf(aggregate);
            if (idx >= 0) {
                $scope.customAggregates.splice(idx, 1);
            }
        };
    });
    
    app.controller("PivotRecipeController", function ($scope, $rootScope, $q, $controller, DKUtils, RecipesUtils, Logger, RecipeStatusHelper, InfoMessagesUtils, $timeout, Dialogs, DataikuAPI, $stateParams, ComputableSchemaRecipeSave, CreateModalFromTemplate) {
        var visualCtrl = $controller('VisualRecipeEditorController', {$scope: $scope}); //Controller inheritance
        this.visualCtrl = visualCtrl;

        /******  recipe related *****/
        $scope.hooks.getPayloadData = function () {
            var cleanuped = angular.copy($scope.params);
            if (cleanuped != null) {
                delete cleanuped.$candidateExplicitIdentifierColumns;
                cleanuped.pivots.forEach(function(pivot) {
                    delete pivot.$candidateKeyColumns;
                    delete pivot.$status;
                    delete pivot.$statusClass;
                    delete pivot.$errors;
                    delete pivot.$warnings;
                    delete pivot.$confirmations;
                    delete pivot.$currentModalities;
                    pivot.valueColumns = pivot.valueColumns.filter(function(valueColumn) {return $scope.columnHasSomeComputation(valueColumn);}); 
                });
                cleanuped.otherColumns = cleanuped.otherColumns.filter(function(otherColumn) {return $scope.columnHasSomeComputation(otherColumn);}); 
            }
            return angular.toJson(cleanuped);
        };

        $scope.hooks.updateRecipeStatus = function(forceUpdate, exactPlan) {
            var payload = $scope.hooks.getPayloadData();
            if (!payload) {
                return $q.reject("payload not ready");
            }
            var deferred = $q.defer();
            $scope.updateRecipeStatusBase(forceUpdate, payload, {reallyNeedsExecutionPlan: exactPlan, exactPlan: exactPlan}).then(function() {
                // $scope.recipeStatus should have been set by updateRecipeStatusBase
                if (!$scope.recipeStatus) {
                    return deferred.reject();
                }
                deferred.resolve($scope.recipeStatus);
            });
            return deferred.promise;
        };

        $scope.hooks.save = function() {
            var deferred = $q.defer();
            if ($scope.recipeStatus && $scope.recipeStatus.outputSchema) {
                // output schema computation seems doable: do the schema validation modal
                var recipeSerialized = $scope.hooks.getRecipeSerialized();
                var payloadData = $scope.hooks.getPayloadData();
                ComputableSchemaRecipeSave.handleSave($scope, recipeSerialized, payloadData, deferred);
            } else {
                // no output schema : just save and let the runner alter the schema
                $scope.baseSave($scope.hooks.getRecipeSerialized(), $scope.hooks.getPayloadData()).then(function(){
                    deferred.resolve("Save done");
                }, function(error) {
                    Logger.error("Could not save recipe");
                    deferred.reject("Could not save recipe");
                });
            }
            return deferred.promise.then(visualCtrl.saveServerParams);
        };

        /********* dispatching of columns into identifiers / keys / values ************/

        var fixupFieldsForPivot = function(params) {
            params.keyColumns = params.keyColumns || [];
            params.valueColumns = params.valueColumns || [];
            params.explicitValues = params.explicitValues || [];
            params.valueLimit = params.valueLimit || 'TOP_N';
            params.topnLimit = params.topnLimit || 20;
            params.valueColumns.forEach(function(valueColumn) {
                angular.forEach($scope.aggregationTypes,function(agg){
                    if (valueColumn[agg.name] == true) {
                        valueColumn.$agg = agg.name;
                    }
                });
                angular.forEach(params.customAggregates,function(agg){
                    if (valueColumn.customAggr == agg.name) {
                        valueColumn.$agg = agg.name;
                    }
                });
            })
        };
        var fixupParamsFieldsForPivotSection = function(params) {
            params.identifierColumnsSelection = params.identifierColumnsSelection || 'EXPLICIT';
            params.customAggregates = params.customAggregates || [];
            params.explicitIdentifiers = params.explicitIdentifiers || [];
            params.pivots = params.pivots || [];
            if (params.pivots.length == 0) {
                // add 1 by default
                params.pivots.push({globalCount:true})
            }
            params.pivots.forEach(function(pivot) {fixupFieldsForPivot(pivot);});
        };
        var fixupParamsFieldsForComputedColumnsSection = function(params) {
            params.computedColumns = params.computedColumns || [];
        };
        var fixupParamsFieldsForOtherColumnsSection = function(params) {
            params.otherColumns = params.otherColumns || [];
        };
        var fixupParamsGeneric = function(params) {
            params.enginesPreferences = params.enginesPreferences || {};
        };
        
        var indexOfValueColumn = function(pivot, name) {
            var found = -1;
            pivot.valueColumns.forEach(function(valueColumn, i) {
                if (valueColumn.column == name) {
                    found = i;
                }
            });
            return found;
        };
        var indexOfValueColumnObject = function(pivot, col) {
            var found = -1;
            pivot.valueColumns.forEach(function(valueColumn, i) {
                if (valueColumn == col) {
                    found = i;
                }
            });
            return found;
        };
        
        var indexOfKeyColumn = function(pivot, name) {
            return pivot.keyColumns.indexOf(name);
        };
        
        var indexOfIdentifierColumn = function(name) {
            return $scope.params.explicitIdentifiers.indexOf(name);
        };
        
        var indexOfOtherColumn = function(name) {
            var found = -1;
            $scope.params.otherColumns.forEach(function(otherColumn, i) {
                if (otherColumn.column == name) {
                    found = i;
                }
            });
            return found;
        };
        
        $scope.$candidateExplicitIdentifierColumns = [];
        var buildColumnListsForPivotSection = function() {
            if ($scope.params == null) {
                return; // can't do anything
            }
            if ($scope.recipeStatus == null || $scope.recipeStatus.pivotStageSchema == null) {
                return; // column list not sent by the backend (yet)
            }
            // column list ready, split into lists for the selectors
            // explicitIdentifiers : any column that is not already an identifier can be used
            var notAlreadyInExplicitIdentifiers = [];
            $scope.recipeStatus.pivotStageSchema.columns.forEach(function(column) {
                if (indexOfIdentifierColumn(column.name) < 0) {
                    notAlreadyInExplicitIdentifiers.push(column);
                }
            });
            $scope.$candidateExplicitIdentifierColumns = notAlreadyInExplicitIdentifiers;
            // for each pivot:
            //   keyColumns : any column that is not an identifier and not already a keyColumn
            //   valueColumns : any column that is not an identifier and not already a valueColumn
            $scope.params.pivots.forEach(function(pivot) {
                pivot.$candidateKeyColumns = [];
                notAlreadyInExplicitIdentifiers.forEach(function(column) {
                    if (indexOfKeyColumn(pivot, column.name) < 0) {
                        pivot.$candidateKeyColumns.push(column);
                    } 
                });
            });
            // all non-identifier columns can be 'other' columns (even if already used in a pivot)
            var otherColumns = [];
            $scope.recipeStatus.pivotStageSchema.columns.forEach(function(column) {
                if (indexOfIdentifierColumn(column.name) < 0) {
                    var oidx = indexOfOtherColumn(column.name);
                    if (oidx >= 0) {
                        otherColumns.push($scope.params.otherColumns[oidx]);
                    } else {
                        otherColumns.push({column:column.name, type:column.type});
                    }
                }
            });
            // replace the contents of the array
            $scope.params.otherColumns = otherColumns;

        };
        var associateStatusToPivotElements = function() {
            if ($scope.params == null) {
                return;
            }
            $scope.params.pivots.forEach(function(pivot) {pivot.$status = null;});
            if ($scope.recipeStatus == null || $scope.recipeStatus.pivot == null) {
                return;
            }
            var status = $scope.recipeStatus.pivot;
            for (var i = 0; i < $scope.params.pivots.length; i++) {
                var pivot = $scope.params.pivots[i];
                var filteredStatus = InfoMessagesUtils.filterForLine(status, i);
                pivot.$status = filteredStatus;
                pivot.$statusClass = RecipeStatusHelper.getStatusClass(filteredStatus);
                pivot.$errors = RecipeStatusHelper.getErrors(filteredStatus.messages);
                pivot.$warnings = RecipeStatusHelper.getWarnings(filteredStatus.messages);
                pivot.$confirmations = RecipeStatusHelper.getConfirmations(filteredStatus.messages);
            }
            if ($scope.recipeStatus.pivotModalities) {
                for (var i = 0; i < $scope.params.pivots.length; i++) {
                    var pivot = $scope.params.pivots[i];
                    var modalities = $scope.recipeStatus.pivotModalities[i];
                    pivot.$currentModalities = modalities;
                }                
            }
        };
        $scope.$watch('recipeStatus.pivotStageSchema', buildColumnListsForPivotSection, true);
        $scope.$watch('recipeStatus.pivot', associateStatusToPivotElements);

        $scope.removeIdentifier = function(col) {
            var idx = indexOfIdentifierColumn(col);
            if (idx >= 0) {
                $scope.params.explicitIdentifiers.splice(idx, 1);
                buildColumnListsForPivotSection();
            }
        };

        $scope.addIdentifier = function(col) {
            var idx = indexOfIdentifierColumn(col);
            if (idx < 0) {
                $scope.params.explicitIdentifiers.push(col);
                // remove from pivots' keyColumns and valueColumns
                $scope.params.pivots.forEach(function(pivot) {
                    var kidx = indexOfKeyColumn(pivot, col);
                    if (kidx >= 0) {
                        pivot.keyColumns.splice(kidx, 1);
                    }
                    for (var vidx = indexOfValueColumn(pivot, col); vidx >= 0; vidx = indexOfValueColumn(pivot, col)) {
                        pivot.valueColumns.splice(vidx, 1);
                    }
                });
                buildColumnListsForPivotSection();
            }
        };
        
        $scope.removeKeyColumn = function(pivot, col) {
            var idx = indexOfKeyColumn(pivot, col);
            if (idx >= 0) {
                pivot.keyColumns.splice(idx, 1);
                removeKeyColumnInExplicitValues(pivot, idx);
                buildColumnListsForPivotSection();
            }
        };

        $scope.addKeyColumn = function(pivot, col) {
            var idx = indexOfKeyColumn(pivot, col);
            if (idx < 0) {
                pivot.keyColumns.push(col);
                addKeyColumnInExplicitValues(pivot);
                // remove from valueColumns
                for (var vidx = indexOfValueColumn(pivot, col); vidx >= 0; vidx = indexOfValueColumn(pivot, col)) {
                    pivot.valueColumns.splice(vidx, 1);
                }
                buildColumnListsForPivotSection();
            }
        };

        $scope.removeValueColumn = function(pivot, col) {
            var idx = indexOfValueColumnObject(pivot, col);
            if (idx >= 0) {
                $rootScope.$broadcast("dismissPopovers"); // in case the delete aggregate is currently being edited
                pivot.valueColumns.splice(idx, 1);
                buildColumnListsForPivotSection();
            }
        };

        $scope.addValueColumn = function(pivot, col) {
            pivot.valueColumns.push({column:col.name, type:col.type, count:true, $agg: "count"});
            var idx = indexOfKeyColumn(pivot, col.name);
            if (idx >= 0) {
                $scope.removeKeyColumn(pivot, col.name);
            }
            buildColumnListsForPivotSection();
        };

        $scope.removePivot = function(pivot) {
            var idx = $scope.params.pivots.indexOf(pivot);
            if (idx >= 0) {
                $scope.params.pivots.splice(idx, 1);
                buildColumnListsForPivotSection();
            }
        };

        $scope.addPivot = function() {
            var pivot = {};
            fixupFieldsForPivot(pivot);
            $scope.params.pivots.push(pivot);
            buildColumnListsForPivotSection();
        };
        
        $scope.listTypesOf = function(columns) {
            return columns ? columns.map(function(c) {return c.type;}) : [];
        };

        // call this in a ng-init when toggling some aggregate triggers the need for more setup. Otherwise
        // the get-status call might exclude the engine because of incomplete setup (typically: the ordercolumn
        // for first/last
        $scope.initColumnExtraFields = function(valueColumn) {
            valueColumn.concatSeparator = valueColumn.concatSeparator != null ? valueColumn.concatSeparator : ',';
            valueColumn.concatDistinct = valueColumn.concatDistinct || false;
        };
        
        /********  computed columns      *******/
        function computedColumnListUpdated(computedColumns) {
            $scope.params.computedColumns = angular.copy(computedColumns);
            $scope.updateRecipeStatusLater();
        }

        /* callback given to the computed columns module */
        $scope.onComputedColumnListUpdate = computedColumnListUpdated;
        
        
        /********  custom aggregations   *******/
        $scope.showEditCustomAggregatesModal = function() {
            var newScope = $scope.$new();
            newScope.customAggregates = angular.copy($scope.params.customAggregates);
            newScope.doCommitAggregates = function(customAggregates) {
                $scope.params.customAggregates = customAggregates;
            };
            CreateModalFromTemplate("/templates/recipes/visual-recipes-fragments/edit-custom-aggregates-modal.html", newScope, null, null);
        };

        /********  aggregations selector *******/
        $scope.aggregateUsabilityFlag = "usableInGroup";
        $scope.aggregationTypes =  [
            {name: "countDistinct", opType:"DISTINCT", label: "Distinct", tooltip: "Count distinct values"},
            {name: "min", label: "Min"},
            {name: "max", label : "Max"},

            {name: "avg", label: "Avg"},
            {name: "sum", label: "Sum"},
            {name: "concat", label: "Concat", tooltip: "Concatenate values in one string"},
            {name: "stddev", label: "Std. dev."},

            {name: "count", label: "Count", tooltip: "Count non-null"},
            {name: "first", label: "First"},
            {name: "last", label: "Last"},
        ];

        $scope.getAggregationLabel = function(valueColumn, withHtmlTags) {
            var label = '';
            if (withHtmlTags) {
                label += '<strong>';
            }
            label += valueColumn.$agg + '(';
            if (valueColumn.concat && valueColumn.concatDistinct) {
                label += 'distinct ';
            }
            label += valueColumn.column + ')';
            if (withHtmlTags) {
                label += '</strong>';
            }
            if (valueColumn.first || valueColumn.last) {
                label += ' ordered by ';
                if (withHtmlTags) {
                    label += '<strong>';
                }
                label += valueColumn.orderColumn;
                if (withHtmlTags) {
                    label += '</strong>';
                }
                if (valueColumn.firstLastNotNull) {
                    label += ' ignoring null values';
                }
            }
            if (valueColumn.concat && valueColumn.concatSeparator && valueColumn.concatSeparator.length > 0) {
                label += ' using separator "' + valueColumn.concatSeparator + '"';
            }
            return label;
        };

        $scope.columnHasSomeComputation = function (col) {
            var ret = false;
            $scope.aggregationTypes.forEach(function(agg) {
                ret = ret || col[agg.name];
            });
            ret = ret || (col.customAggr && col.customAggr.length > 0);
            return ret;
        };

        // Checks if we can perform the specified aggregation on column col
        $scope.colCanAggr = function(col, agg) {
            if (!$scope.engineCanAggr(agg)) return false;
            var opType = agg.opType || agg.name.toUpperCase();
            var aggregability = $scope.recipeStatus.selectedEngine.aggregabilities[opType];
            var typeCategory = {"string":"strings", 
                                "date":"dates", 
                                "boolean":"booleans",
                                "tinyint":"numerics",
                                "smallint":"numerics",
                                "int":"numerics",
                                "bigint":"numerics",
                                "float":"numerics",
                                "double":"numerics"                              
                            }[col.type];
            return aggregability && typeCategory && aggregability[typeCategory];
        };

        $scope.engineCanAggrType = function(opType) {
            if (!$scope.recipeStatus || !$scope.recipeStatus.selectedEngine) return false;
            var aggregability = $scope.recipeStatus.selectedEngine.aggregabilities[opType];
            return aggregability && aggregability[$scope.aggregateUsabilityFlag];
        };
        $scope.engineCanAggr = function(agg) {
            if (!$scope.recipeStatus || !$scope.recipeStatus.selectedEngine) return false;
            var opType = agg.opType || agg.name.toUpperCase();
            var aggregability = $scope.recipeStatus.selectedEngine.aggregabilities[opType];
            return aggregability && aggregability[$scope.aggregateUsabilityFlag];
        };

        $scope.getColumnsForOrder = function() {
            if ($scope.recipeStatus == null || $scope.recipeStatus.pivotStageSchema == null) {
                return [];
            } else {
                return $scope.recipeStatus.pivotStageSchema.columns;
            }
        };
             
        $scope.initOrderColumn = function(col) {
            var cols = $scope.getColumnsForOrder();
            col.orderColumn = col.orderColumn || (cols && cols.length ? cols[0].name : undefined);
        };
        // call this in a ng-init when toggling some aggregate triggers the need for more setup. Otherwise
        // the get-status call might exclude the engine because of incomplete setup (typically: the ordercolumn
        // for first/last
        $scope.initColumnExtraFields = function(column) {
            $scope.initOrderColumn(column);
            column.concatSeparator = column.concatSeparator != null ? column.concatSeparator : ',';
            column.concatDistinct = column.concatDistinct || false;
        };

        $scope.aggregation = {'all':{},'some':{},'none':{},'disabled':{}};

        $scope.recomputeAggregationStates = function(cols) {
            for (var k in $scope.aggregation) {$scope.aggregation[k]={};}

            cols.forEach(function(column){
                $scope.aggregationTypes.forEach(function(agg) {
                    var colEnabled = $scope.colCanAggr(column, agg);
                    $scope.aggregation.all[agg.name] =
                        ($scope.aggregation.all[agg.name] == undefined ? true : $scope.aggregation.all[agg.name])
                        && (colEnabled ? column[agg.name] : false);
                    $scope.aggregation.some[agg.name] =
                        ($scope.aggregation.some[agg.name] || false)
                        || (colEnabled ? column[agg.name] : false);
                    $scope.aggregation.disabled[agg.name] =
                        ($scope.aggregation.disabled[agg.name] || false)
                        || colEnabled;
                });
            });
            angular.forEach($scope.aggregationTypes,function(agg){
                $scope.aggregation.disabled[agg.name] = !$scope.aggregation.disabled[agg.name];
                $scope.aggregation.some[agg.name] = $scope.aggregation.some[agg.name] && !$scope.aggregation.all[agg.name];
                $scope.aggregation.none[agg.name] = !$scope.aggregation.some[agg.name] && !$scope.aggregation.all[agg.name];
            });
        }

        // Apply/disapply aggregation to all selected columns
        $scope.massAction = function(agg, selectedObjects){
            selectedObjects.forEach(function(val) {
                if ($scope.colCanAggr(val, agg)) {
                    val[agg.name] = $scope.aggregation.all[agg.name];
                }
            });
            // run the orderColumn init before updating the status, otherwise the ng-init will run while the new status is
            // computed and will be overwritten
            if (['first', 'last'].indexOf(agg.name) >= 0) {
                selectedObjects.forEach(function(val) {
                    $scope.initOrderColumn(val);
                });
            }
            $scope.aggregation.some[agg.name] = false;
            $scope.aggregation.none[agg.name] = !$scope.aggregation.all[agg.name];
            $scope.hooks.updateRecipeStatus();
        }
        
        $scope.updateAgg = function(valueColumn) {
            angular.forEach($scope.aggregationTypes,function(agg) {
                valueColumn[agg.name] = false;
            });
            valueColumn.customAggr = null;
            if (valueColumn.$agg) {
                if ($scope.params.customAggregates.map(function(a) {return a.name;}).indexOf(valueColumn.$agg) >= 0) {
                    valueColumn.customAggr = valueColumn.$agg;
                } else if ($scope.aggregationTypes.map(function(a) {return a.name;}).indexOf(valueColumn.$agg) >= 0) {
                    valueColumn[valueColumn.$agg] = true;
                } else {
                    logger.error("Unknown aggregate", valueColumn.$agg);
                }
            }
            if ((valueColumn.first || valueColumn.last) && !valueColumn.orderColumn) {
                $scope.initOrderColumn(valueColumn);
            }
        };
        
        /********* modalities **************/
        
        var removeKeyColumnInExplicitValues = function(pivot, idx) {
            pivot.explicitValues.forEach(function(keyValues) {
                if (keyValues.length > idx) {
                    keyValues.splice(idx, 1);
                }
            });
        };
        var addKeyColumnInExplicitValues = function(pivot) {
            pivot.explicitValues.forEach(function(keyValues) {
                keyValues.push(null);
            });
        };
        
        $scope.addModality = function(pivot) {
            var keyValues = pivot.keyColumns.map(function(k) {return null;});
            pivot.explicitValues.push(keyValues);
        };
        
        $scope.removeModality = function(pivot, keyValues) {
            var idx = pivot.explicitValues.indexOf(keyValues);
            if (idx >= 0) {
                pivot.explicitValues.splice(idx, 1);
            }
        };
        
        $scope.loadModalitiesFromOutput = function(pivot) {
            if (!pivot.$currentModalities) return;
            pivot.explicitValues = pivot.$currentModalities.map(function(o) {return o.keyValues;});
        };
        $scope.loadModalitiesFromDataset = function(pivot, smartName) {
            DataikuAPI.flow.recipes.pivot.getDatasetModalities($stateParams.projectKey, smartName, pivot).success(function(data) {
                pivot.explicitValues = data.explicitValues;
            }).error(setErrorInScope.bind($scope));
        };
        
        /********* schema handling **********/
        
        $scope.dropOutputSchema = function() {
            var output = RecipesUtils.getSingleOutput($scope.recipe, "main");
            Dialogs.confirmPositive($scope, 'Drop output schema', 'The schema of "'+output.ref+'" will be cleared. Are you sure you want to continue ?').then(function() {
                 DataikuAPI.flow.recipes.basicDropSchema($stateParams.projectKey, $scope.hooks.getRecipeSerialized()).success(function() {$scope.hooks.updateRecipeStatus(true);}).error(setErrorInScope.bind($scope));
            });
        };

        $scope.modalitySlugifications = [
                                     ["NONE", "None"],
                                     ["SOFT_SLUGIFY", "Soft slugification"],
                                     ["HARD_SLUGIFY", "Hard slugification"],
                                     ["NUMBER", "Numbering"]
                                 ];

        $scope.modalitySlugificationsDesc = [
                                     "Column names are built by concatenating the modality's values",
                                     "Replace punctuation and whitespace by _",
                                     "Keep only safe characters (latin letters, numbers)",
                                     "Number modalities instead of build a name from their values"
                                 ];
        
        $scope.$watch("params.$withModalityMaxLength", function() {
            if ($scope.params && !$scope.params.$withModalityMaxLength) {
                $scope.params.modalityMaxLength = null;
            }
        });

        /*********  ************/

        var onScriptChanged = function(nv) {
            if (nv) {
               loadParamsFromScript($scope.script.data);
               DKUtils.reflowNext();
               DKUtils.reflowLater();
               $scope.hooks.updateRecipeStatus();
           }
        };

        var loadParamsFromScript = function(scriptData) {
            if (!scriptData) {
                return;
            }
            $scope.params = JSON.parse(scriptData);
            fixupParamsGeneric($scope.params);
            fixupParamsFieldsForComputedColumnsSection($scope.params);
            fixupParamsFieldsForPivotSection($scope.params);
            fixupParamsFieldsForOtherColumnsSection($scope.params);
            buildColumnListsForPivotSection();
            
            $scope.uiState.computedColumns = angular.copy($scope.params.computedColumns);

            //keep params for dirtyness detection
            visualCtrl.saveServerParams();
        };
        
        // UI:
        $scope.uiState = {
            currentStep: 'pivot',
            modalitiesDatasetSmartName: null,
            computedColumns: []
        };

        $scope.hooks.onRecipeLoaded = function(){
            Logger.info("On Recipe Loaded");
            $scope.$watch("script.data", onScriptChanged, true);
            onScriptChanged($scope.script.data);
        };

        $scope.enableAutoFixup();
        $scope.specificControllerLoadedDeferred.resolve();
        $scope.$watch("params", $scope.updateRecipeStatusLater, true);
    });

    app.directive('pivotHelp', function() {
        return {
            restrict: 'A',
            scope: true,
            templateUrl: '/templates/recipes/fragments/pivot-help.html',
            link : function($scope, element, attrs) {
                $scope.examples = [];
                $scope.examples.push({
                    title: 'Simple count',
                    column: 'year',
                    row: '\u2014',
                    hasIdentifier: false,
                    content: 'count of records',
                    input: {
                        columns: ['id', 'country', 'year', 'qty'],
                        rows: [
                               ['1', 'US', '2016', 7 ],
                               ['2', 'US', '2017', 12],
                               ['3', 'US', '2017', 23],
                               ['4', 'FR', '2017', 8 ]
                              ]
                    },
                    output: {
                        title: 'Count of records',
                        columns: ['2016', '2017'],
                        rows: [
                               [1, 3]
                              ]
                    }
                });
                $scope.examples.push({
                    title: 'Pivot table',
                    column: 'year',
                    row: 'country',
                    hasIdentifier: true,
                    content: 'sum of qty',
                    input: {
                        columns: ['id', 'country', 'year', 'qty'],
                        rows: [
                               ['1', 'US', '2016', 7 ],
                               ['2', 'US', '2017', 12],
                               ['3', 'US', '2017', 23],
                               ['4', 'FR', '2017', 8 ]
                              ]
                    },
                    output: {
                        title: 'Qty per country/year',
                        columns: ['', '2016', '2017'],
                        rows: [
                               ['US', 7   , 35],
                               ['FR', null, 8]
                              ]
                    }
                });
                $scope.examples.push({
                    title: 'Pivot values',
                    column: 'metric',
                    row: 'id',
                    hasIdentifier: true,
                    content: 'first of values',
                    hint: 'Mostly used on input with a single value per key combination',
                    input: {
                        columns: ['id', 'metric', 'values'],
                        rows: [
                               ['1', 'weight' , 2],
                               ['1', 'height' , 4],
                               ['2', 'weight' , 3],
                               ['2', 'height' , 5],
                               ['3', 'weight' , 8],
                               ['3', 'height' , 5]
                              ]
                    },
                    output: {
                        title: 'Pivoted values',
                        columns: ['', 'weight', 'height'],
                        rows: [
                               ['1', 2, 4],
                               ['2', 3, 5],
                               ['3', 8, 5]
                              ]
                    }
                });
                $scope.examples.push({
                    title: 'Frequency table',
                    column: 'year',
                    row: 'country',
                    hasIdentifier: true,
                    content: 'count of records',
                    input: {
                        columns: ['id', 'country', 'year', 'qty'],
                        rows: [
                               ['1', 'US', '2016', 7 ],
                               ['2', 'US', '2017', 12],
                               ['3', 'US', '2017', 23],
                               ['4', 'FR', '2017', 8 ]
                              ]
                    },
                    output: {
                        title: 'Count of records',
                        columns: ['', '2016', '2017'],
                        rows: [
                               ['US', 1   , 2],
                               ['FR', null, 1]
                              ]
                    }
                });
                $scope.examples.push({
                    title: 'Various statistics',
                    column: 'year',
                    row: 'country',
                    hasIdentifier: true,
                    content: 'sum of qty',
                    other: 'average of qty',
                    input: {
                        columns: ['id', 'country', 'year', 'qty'],
                        rows: [
                               ['1', 'US', '2016', 7 ],
                               ['2', 'US', '2017', 12],
                               ['3', 'US', '2017', 23],
                               ['4', 'FR', '2017', 8 ]
                              ]
                    },
                    output: {
                        title: 'Qty per country/year',
                        columns: ['', '2016', '2017', 'avg(qty)'],
                        rows: [
                               ['US', 7   , 35, 14],
                               ['FR', null, 8 , 8]
                              ]
                    }
                });
                $scope.uiState = {selected : $scope.examples[0], hovered: null};
                $scope.getDisplayed = function() {
                    return $scope.uiState.hovered || $scope.uiState.selected;
                };
            }
        };
    });
    
    app.controller("PivotRecipeOutputColumnsController", function ($scope) {
        $scope.selection = $.extend({
            filterQuery: {
                userQuery: '',
                tags: [],
                interest: {},
            },
            filterParams: {
                userQueryTargets: ["name","type"],
                propertyRules: {},
            },
            orderQuery: null,
            orderReversed: false,
        }, $scope.selection || {});
    });
    
})();
(function() {
    'use strict';

    var app = angular.module('dataiku.recipes');

    app.controller("JoinRecipeCreationController", function($scope, Fn, $stateParams, DataikuAPI, $controller) {
        $scope.recipeType = "join";
        $controller("SingleOutputDatasetRecipeCreationController", {$scope:$scope});

        $scope.autosetName = function() {
            if ($scope.io.inputDataset) {
                var niceInputName = $scope.io.inputDataset.replace(/[A-Z]*\./,"");
                $scope.maybeSetNewDatasetName(niceInputName + "_joined");
            }
        };

        $scope.getCreationSettings = function () {
            return {virtualInputs: [$scope.io.inputDataset, $scope.io.inputDataset2]};
        };

        var superFormIsValid = $scope.formIsValid;
        $scope.formIsValid = function() {
            return !!(superFormIsValid() &&
                $scope.io.inputDataset2 && $scope.activeSchema2 && $scope.activeSchema2.columns && $scope.activeSchema2.columns.length
            );
        };
        $scope.showOutputPane = function() {
            return !!($scope.io.inputDataset && $scope.io.inputDataset2);
        };
    });


    app.controller("JoinRecipeController", function ($scope, $timeout, $controller, $q, $stateParams, DataikuAPI, DKUtils, Dialogs,
                   PartitionDeps, CreateModalFromTemplate, RecipesUtils, Logger, DatasetUtils) {
        var visualCtrl = $controller('VisualRecipeEditorController', {$scope: $scope}); //Controller inheritance

        let contextProjectKey = $scope.context && $scope.context.projectKey ? $scope.context.projectKey:$stateParams.projectKey;
        /****** computed columns ********/
        function computedColumnListUpdated(computedColumns) {
            $scope.params.computedColumns = angular.copy(computedColumns);
            $scope.updateRecipeStatusLater();
        }

        var isOpen = false;
        $scope.setOpen = function (state) {
            isOpen = state;
        }
        $scope.isOpen = function () {
            return isOpen;
        }

        $scope.getColumnsWithComputed = function(datasetName) {
            if (!$scope.uiState.columnsWithComputed || !$scope.uiState.columnsWithComputed[datasetName]) {
                var columns = angular.copy($scope.getColumns(datasetName));
                var datasetIdx;
                RecipesUtils.getInputsForRole($scope.recipe, "main").forEach(function(input, idx){
                    if (input.ref === datasetName) {
                        datasetIdx = idx;
                    }
                });
                var hasVirtualInputs = $scope.params && $scope.params.virtualInputs;
                if (datasetIdx >= 0 && hasVirtualInputs) {
                    var computedColumns = ($scope.params.virtualInputs.find(vi => vi.index == datasetIdx) || {}).computedColumns;
                    if (computedColumns) {
                        for (var i = 0; i < computedColumns.length; i++) {
                            columns.push({
                                name: computedColumns[i].name,
                                type: computedColumns[i].type,
                                timestampNoTzAsDate: false,
                                maxLength: -1
                            });
                        }
                    }
                }
                $scope.uiState.columnsWithComputed = $scope.uiState.columnsWithComputed || {};
                $scope.uiState.columnsWithComputed[datasetName] = columns;
            }
            return $scope.uiState.columnsWithComputed[datasetName];
        };

        $scope.getColumnWithComputed = function(datasetName, name) {
            return $scope.getColumnsWithComputed(datasetName).filter(function(col){return col.name===name})[0];
        };

        /* callback given to the computed columns module */
        $scope.onComputedColumnListUpdate = computedColumnListUpdated;

        var savePayloadAsIsForDirtyness = true;
        $scope.hooks.getPayloadData = function () {
            if (!$scope.params) return;
            if (savePayloadAsIsForDirtyness) {
                savePayloadAsIsForDirtyness = false;
            } else {
                $scope.params.selectedColumns = $scope.getSelectedColumns();
            }
            // cleanup : - null values for alias
            var clean = angular.copy($scope.params);
            (clean.selectedColumns || []).forEach(function(c) {if (c.alias == null) delete c.alias;});
            return angular.toJson(clean);
        };

        var applyEngineLimitations = function(){
            if ($scope.params.joins) {
                var eng = $scope.recipeStatus.selectedEngine;
                if (eng != null && eng.canDeduplicateJoinMatches === false) {
                    $scope.params.joins.forEach(function(join){
                        if (join.rightLimit != null && join.rightLimit.enabled) {
                            Logger.warn("Deactivate rightLimit (deduplicate join matches) because of engine");
                            join.rightLimit.enabled = false;
                        }
                    });
                }
                $scope.params.joins.forEach(function(join){
                    if (join.rightLimit != null && join.rightLimit.enabled && $scope.hasNonSymmetricConditions(join)) {
                        Logger.warn("Deactivate rightLimit because (deduplicate join matches) of non equi-join");
                        join.rightLimit.enabled = false;
                    }
                });
            }
        };

        var removeUnusedInputs = function() {
            if (!$scope.params.virtualInputs) return;
            var usedIndices = [];
            $scope.params.virtualInputs.forEach(function(vi){
                if (usedIndices.indexOf(vi.index) < 0) {
                    usedIndices.push(vi.index);
                }
            });
            var newIndices = {};
            for(var i=0;i<$scope.recipe.inputs.main.items.length;i++) {
                newIndices[i] = usedIndices.filter(function(k) {return k < i;}).length;
            }
            $scope.recipe.inputs.main.items = $scope.recipe.inputs.main.items.filter(function(input, idx) {
                return usedIndices.indexOf(idx) >= 0;
            });
            $scope.params.virtualInputs.forEach(function(vi) {vi.index = newIndices[vi.index];});
        };

        $scope.onInputReplaced = function(replacement, virtualIndex) {
            var inputNames = RecipesUtils.getInputsForRole($scope.recipe, "main").map(function(input){return input.ref});
            var inputDesc = {index: inputNames.indexOf(replacement.name)};
            $scope.params.virtualInputs[virtualIndex] = inputDesc;
            removeUnusedInputs();
            DatasetUtils.updateRecipeComputables($scope, $scope.recipe, $stateParams.projectKey, contextProjectKey)
                    .then(_ => $scope.resyncSchemas());
        }

        var updateCodeMirrorUI = function(){
            $('.CodeMirror').each(function(idx, el){
                el.CodeMirror.refresh();
            });
        };

        $scope.hooks.updateRecipeStatus = function(forceUpdate, exactPlan) {
            var payload = $scope.hooks.getPayloadData();
            if (!payload) return $q.reject("payload not ready");
            var deferred = $q.defer();
            $scope.updateRecipeStatusBase(forceUpdate, payload, {reallyNeedsExecutionPlan: exactPlan, exactPlan: exactPlan}).then(function() {
                // $scope.recipeStatus should have been set by updateRecipeStatusBase
                if (!$scope.recipeStatus) return deferred.reject();
                if ($scope.recipeStatus.outputSchema) {
                    $scope.params.postFilter = $scope.params.postFilter || {};
                    $scope.params.postFilter.$status = $scope.params.postFilter.$status || {};
                    $scope.params.postFilter.$status.schema = $scope.recipeStatus.outputSchema;
                }
                applyEngineLimitations();
                DKUtils.reflowLater();
                $timeout(updateCodeMirrorUI);
                deferred.resolve($scope.recipeStatus);
            });
            return deferred.promise;
        };

        $scope.getJoinSuggestions = function() {
            var payload = $scope.hooks.getPayloadData();
            var recipeSerialized = angular.copy($scope.recipe);
            PartitionDeps.prepareRecipeForSerialize(recipeSerialized);
            let fetchSuggestions = $scope.isFuzzy ? DataikuAPI.flow.recipes.fuzzyjoin.getSuggestions : DataikuAPI.flow.recipes.join.getSuggestions;
            return fetchSuggestions($stateParams.projectKey, recipeSerialized, payload)
                .success(function(suggestions) {
                    var lastJoin = $scope.params.joins[$scope.params.joins.length - 1];
                    if (suggestions.length > 0 ) {
                        // select everything available, let the user clean up later if he wants to
                        suggestions.forEach(function(condition) {condition.selected = true;});
                        $scope.addConditions(lastJoin, suggestions);
                        $scope.hooks.updateRecipeStatus();
                    }
                })
                .error(setErrorInScope.bind($scope));
        };

        $scope.canNonEquiJoin = function(join) {
            return $scope.recipeStatus && $scope.recipeStatus.selectedEngine != null && $scope.recipeStatus.selectedEngine.canNonEquiJoin;
        };

        $scope.showNewJoinModal = function() {
            CreateModalFromTemplate("/templates/recipes/visual-recipes-fragments/join-modal.html", $scope);
        };

        $scope.showJoinEditModal = function(join, tab) {
            $scope.setOpen(true);
            //check if the modal is already shown
            if (!$('#join-condition-modal').parent().hasClass('in')) {
                var newScope = $scope.$new();
                newScope.join = join;
                newScope.current = {};
                newScope.current.tab = tab || 'conditions'
                newScope.current.condition = null; //no selected condition when the modal is created
                newScope.showConditionRemove = true;

                if (!newScope.isFuzzy) {
                    newScope.join.rightLimit = newScope.join.rightLimit || {decisionColumn: {}};
                    const rl = newScope.join.rightLimit;
                    rl.maxMatches = rl.maxMatches || 1;
                    rl.enabled = (rl.enabled === true || rl.enabled === false) ? rl.enabled : false;
                    rl.type = rl.type || 'KEEP_LARGEST';
                }

                CreateModalFromTemplate("/templates/recipes/visual-recipes-fragments/join-edit-modal.html", newScope, $scope.isFuzzy ? "FuzzyJoinEditController" : "JoinEditController", (scope, el) => {
                    $timeout(() => {
                            scope.joinBlockBodyEl = el[0].getElementsByClassName('join-block-body')[0];
                        }
                    );
                });
            }
        };

        $scope.getSelectedColumns = function() {
            var outputSchema = [];
            if (!$scope.uiState || !$scope.uiState.selectedColumns) return;
            $scope.uiState.selectedColumns.forEach(function(datasetColumns, tableIndex) {
                datasetColumns.forEach(function(column) {
                    if(column.selected) {
                        outputSchema.push({
                            name: column.name,
                            alias: column.alias,
                            table: tableIndex,
                            type: column.type
                        });
                    }
                })
            });
            return outputSchema;
        };

        $scope.addDataset = function(datasetName) {
            if (RecipesUtils.getInput($scope.recipe, "main", datasetName) == null) {
                RecipesUtils.addInput($scope.recipe, "main", datasetName);
            }
            var inputNames = RecipesUtils.getInputsForRole($scope.recipe, "main").map(function(input){return input.ref});
            var inputDesc = {
                index: inputNames.indexOf(datasetName)}
            ;
            $scope.params.virtualInputs.push(inputDesc);
            $scope.uiState.currentStep = 'join';
        }

        $scope.autoSelectColumns = function(inputDesc) {
            $scope.uiState.columnsWithComputed = undefined;
            //Auto select columns that do not conflict
            $scope.params.selectedColumns = $scope.params.selectedColumns || [];
            var selectedNames = $scope.params.selectedColumns.map(function(col){
                return $scope.getColumnOutputName(inputDesc, col).toLowerCase();
            });

            var selectColumn = function(columnName) {
                $scope.params.selectedColumns.push({
                    name: columnName,
                    table: $scope.params.virtualInputs.length-1
                });
            }

            var datasetName = $scope.outputDatasetName;
            var excludedColumnNames = [];
            if ($scope.computablesMap && datasetName && $scope.computablesMap[datasetName] && $scope.computablesMap[datasetName].dataset) {
                var dataset = $scope.computablesMap[datasetName].dataset;
                if (dataset.type == 'HDFS') {
                    if (dataset.partitioning && dataset.partitioning.dimensions.length > 0) {
                        dataset.partitioning.dimensions.forEach(function(p) {excludedColumnNames.push(p.name);});
                    }
                }
            }

            $scope.getColumnsWithComputed($scope.getDatasetNameFromRecipeInputIndex(inputDesc.index)).forEach(function(column) {
                var outputName = $scope.getColumnOutputName(inputDesc, {
                    name: column.name
                });
                if (selectedNames.indexOf(outputName.toLowerCase()) < 0 && !excludedColumnNames.includes(column.name)) { //no conflict
                    selectColumn(column.name);
                }
            });

            createColumnList();
        }

        var removeDatasets = function(indices) {
            indices.sort().reverse();
            indices.forEach(function(index) {
                $scope.params.joins = $scope.params.joins.filter(function(join) {
                    return join.table1 != index && join.table2 != index;
                });
                $scope.params.joins.forEach(function(join) {
                    if (join.table1 > index) {
                        join.table1--;
                        join.on.forEach(function(condition){
                            condition.column1.table--;
                        })
                    }
                    if (join.table2 > index) {
                        join.table2--;
                        join.on.forEach(function(condition){
                            condition.column2.table--;
                        })
                    }
                });
                $scope.params.selectedColumns = $scope.params.selectedColumns.filter(function(column) {
                    return column.table != index;
                });
                $scope.params.selectedColumns.forEach(function(column) {
                    if(column.table > index) {
                        column.table--;
                    }
                });

                var datasetName = $scope.getDatasetNameFromRecipeInputIndex($scope.params.virtualInputs[index].index);
                var numberOfUses = $scope.params.virtualInputs.filter(function(table) {
                    return table.name == datasetName;
                }).length;
                if (numberOfUses == 1) {
                    RecipesUtils.removeInput($scope.recipe, "main", datasetName);
                    $scope.params.virtualInputs.forEach(function(vi) {
                        if (vi.index > index) {
                            vi.index--;
                        }
                    });
                }

                $scope.params.virtualInputs.splice(index, 1);
                $scope.uiState.selectedColumns.splice(index, 1);
            });

            $scope.hooks.updateRecipeStatus();

            if ($scope.params.virtualInputs.length == 0) {
                $scope.showNewJoinModal();
            }
        };

        var getDependantDatasets = function(index) {
            var dependantDatasets = [];
            for(var i = 0; i < $scope.params.joins.length; i++) {
                var join = $scope.params.joins[i];
                if (join.table1 == index) {
                    dependantDatasets.push(join.table2);
                    dependantDatasets = dependantDatasets.concat(getDependantDatasets(join.table2))
                }
            }
            return dependantDatasets;
        };

        $scope.removeDataset = function(index) {
            var datasetsToBeRemoved = getDependantDatasets(index);
            datasetsToBeRemoved.push(index);
            if (datasetsToBeRemoved.length == 1) {
                removeDatasets(datasetsToBeRemoved);
            } else {
                var datasetList = datasetsToBeRemoved.map(function(index) {
                    return $scope.getDatasetNameFromRecipeInputIndex($scope.params.virtualInputs[index].index);
                })
                Dialogs.confirm($scope,
                    'Remove datasets',
                    'The following datasets will be removed from the recipe:'+
                    '<ul><li>'+datasetList.join('</li><li>')+'</li></ul>'
                )
                .then(function() {
                     removeDatasets(datasetsToBeRemoved);
                });
            }
        };

        // gets the dataset name from the index within the virtual inputs
        $scope.getDatasetName = function(virtualIndex) {
            var dataset = $scope.params.virtualInputs[virtualIndex];
            return $scope.getDatasetNameFromRecipeInputIndex(dataset.index);
        };

        // gets the dataset name from the index within the recipe's inputs
        $scope.getDatasetNameFromRecipeInputIndex = function(index) {
            var input = $scope.recipe.inputs.main.items[index];
            return input ? input.ref : "";
        };

        var createColumnList = function() {
            var selectedColumns = (($scope.params || {}).virtualInputs || []).map(function() {return {};});
            if ($scope.params.selectedColumns) {
                $scope.params.selectedColumns.forEach(function(column) {
                    selectedColumns[column.table][column.name] = column.alias || null;
                });
            }

            var columnList = [];
            (($scope.params || {}).virtualInputs || []).forEach(function(inputDesc, index) {
                var inputColumns = $scope.getColumnsWithComputed($scope.getDatasetNameFromRecipeInputIndex(inputDesc.index)).map(function(column) {
                    var alias = selectedColumns[index][column.name];
                    return {
                        name: column.name,
                        type: column.type,
                        maxLength: column.maxLength,
                        selected: alias !== undefined,
                        alias: alias
                    }
                });
                columnList.push(inputColumns);
            });
            $scope.uiState.selectedColumns = columnList;
        };

        $scope.resyncSchemas = function() {
            $scope.uiState.columnsWithComputed = undefined;
            // regenerated selected columns (drop columns that don't exist anymore)
            createColumnList();

            // remove join conditions if the columns do not exist anymore
            $scope.params.joins.forEach(function(join){
                var dataset1 = $scope.getDatasetNameFromRecipeInputIndex($scope.params.virtualInputs[join.table1].index);
                var dataset2 = $scope.getDatasetNameFromRecipeInputIndex($scope.params.virtualInputs[join.table2].index);
                var columns1 = ($scope.getColumnsWithComputed(dataset1)||[]).map(function(col){return col.name});
                var columns2 = ($scope.getColumnsWithComputed(dataset2)||[]).map(function(col){return col.name});
                join.on = join.on.filter(function(cond){
                    if (!columns1 || !columns2 || columns1.indexOf(cond.column1.name) < 0 || columns2.indexOf(cond.column2.name) < 0) {
                        return false;
                    }
                    return true;
                })
            });
        };

        $scope.getColumnList = function(index) {
            return $scope.uiState.selectedColumns[index];
        };

        $scope.getColumnOutputName = function(inputDesc, column) { //TODO compute on server
            if (column.alias) {
                return column.alias;
            } else if (inputDesc.prefix) {
                return inputDesc.prefix + '_' + column.name;
            } else {
                return column.name;
            }
        };

        $scope.hasNonSymmetricConditions = function(join) {
            if (!join || !join.on) {
                return false;
            }
            var asymetricConditions = ['K_NEAREST', 'K_NEAREST_INFERIOR'];
            for (var i = 0; i < join.on.length; ++i) {
                if (asymetricConditions.indexOf(join.on[i].type) >= 0) {
                    return true;
                }
            }
            return false;
        };

        $scope.addEmptyCondition = function(join, current) {
            var newCondition = {
                column1: {
                    table: join.table1,
                    name: $scope.getColumnsWithComputed($scope.getDatasetName(join.table1))[0].name
                },
                column2: {
                    table: join.table2,
                    name: $scope.getColumnsWithComputed($scope.getDatasetName(join.table2))[0].name
                },
                type: 'EQ'
            };
            join.on = join.on || [];
            join.on.push(newCondition);
            if (current) {
                current.condition = newCondition;
            }
        };

        $scope.addConditions = function(join, conditions) {
            conditions.forEach(function(condition){
                if (condition.selected) {
                    delete condition.selected;
                    join.on.push(condition);
                }
            });
            $scope.updateRecipeStatusLater(0);
        };

        $scope.removeCondition = function(scope, join, condition) {
            if ( scope.current != null && scope.current.condition == condition ) {
                scope.current.condition = null;
            }
            var index = join.on.indexOf(condition);
            join.on.splice(index, 1);
            $scope.hooks.updateRecipeStatus();
        };

        $scope.removeAllConditions = function(scope, join) {
            if ( scope.current != null ) {
                scope.current.condition = null;
            }
            join.on = [];
            $scope.hooks.updateRecipeStatus();
            $scope.setOpen(true);
        };

        $scope.range = function(n) {
            return Array.apply(null, Array(n)).map(function(_, i) {return i;});
        };

        $scope.getConditionString = function(condition) {
            var col1 = condition.column1.name,
                col2 = condition.column2.name,
                dataset1 = $scope.getDatasetNameFromRecipeInputIndex($scope.params.virtualInputs[condition.column1.table].index),
                dataset2 = $scope.getDatasetNameFromRecipeInputIndex($scope.params.virtualInputs[condition.column2.table].index);
            switch(condition.type) {
                case 'EQ':
                    return dataset1+'.'+col1+' = '+dataset2+'.'+col2;
                case 'WITHIN_RANGE':
                    return 'abs('+dataset2+'.'+col2+' - '+dataset1+'.'+col1+') < '+condition.maxDistance;
                case 'K_NEAREST':
                    return dataset2+'.'+col2+' is the nearest match for '+dataset1+'.'+col1+(condition.strict ? '(strict)' : '');
                case 'K_NEAREST_INFERIOR':
                    return dataset2+'.'+col2+' is the nearest match before '+dataset1+'.'+col1+(condition.strict ? '(strict)' : '');
                case 'CONTAINS':
                    return dataset1+'.'+col1+' contains '+dataset2+'.'+col2;
                case 'STARTS_WITH':
                    return dataset1+'.'+col1+' contains '+dataset2+'.'+col2;
                case 'LTE':
                    return dataset1+'.'+col1+' is before '+dataset2+'.'+col2;
                case 'GTE':
                    return dataset1+'.'+col1+' is after '+dataset2+'.'+col2;
                case 'NE':
                    return dataset1+'.'+col1+' different from '+dataset2+'.'+col2;
            }
        };

        $scope.onFilterUpdate = function(filterDesc) {
            $scope.updateRecipeStatusLater();
        };

        $scope.listColumnsForCumstomColumnsEditor = function(){
            return scope.getSelectedColumns().map(function(c){
                var inputDesc = scope.params.virtualInputs[c.table];
                return scope.getColumnOutputName(inputDesc, c);
            });
        };

        $scope.$watch("params.postFilter.expression", $scope.updateRecipeStatusLater);
        $scope.$watch("params.postFilter.enabled", $scope.updateRecipeStatusLater);
        $scope.$watch("params.virtualInputs", $scope.updateRecipeStatusLater, true);

        var matchingTypeName = {
            'EQ': '=',
            'WITHIN_RANGE': '~',
            'K_NEAREST': '~',
            'NEAREST_INFERIOR': '~',
            'CONTAINS': '~',
            'STARTS_WITH': '~',
            'LTE': '<=',
            'LT': '<',
            'GTE': '>=',
            'GT': '>',
            'NE': '!='
        };

        $scope.isRelativeDistance = function (condition) {
            return angular.isNumber(condition.fuzzyMatchDesc.relativeTo);
        };

        $scope.getMatchingTypeSymbol = function(condition) {
            if ($scope.isFuzzy) {
                const fuzzyMatchDesc = condition.fuzzyMatchDesc;
                let threshold = fuzzyMatchDesc.threshold;
                if (!fuzzyMatchDesc || !angular.isNumber(threshold)) return '?';
                if (fuzzyMatchDesc.distanceType === 'EXACT') return '=';
                if ($scope.isRelativeDistance(condition)) {
//                  Rounding to avoid long decimal tail after floating point math operations e.g. 0.072*100=7.199999999999999
                    threshold = Math.round((threshold * 100) * 10 ** 12) / 10 ** 12;
                    return `${threshold} %`;
                } else {
                    return threshold.toString();
                }
            } else {
                const type = condition.type;
                if (matchingTypeName.hasOwnProperty(type)) {
                    return matchingTypeName[type];
                }
            }
        };

        $scope.getDatasetColorClass = function(datasetIndex) {
            return 'dataset-color-'+(datasetIndex%6);
        };

        $scope.getJoinTypeName = function(join) {
            if (join.type) {
                var name = (join.conditionsMode == 'NATURAL' && join.type != 'ADVANCED' && join.type != 'CROSS' ? 'Natural ' : '') + join.type + ' join';
                return name.charAt(0).toUpperCase() + name.substr(1).toLowerCase()
            }
        };

        function onScriptChanged(nv, ov) {
            if (nv) {
                $scope.params = JSON.parse($scope.script.data);
                $scope.params.computedColumns = $scope.params.computedColumns || [];
                $scope.uiState.computedColumns = angular.copy($scope.params.computedColumns);
                $scope.uiState.columnsWithComputed = undefined;
                savePayloadAsIsForDirtyness = true;
                visualCtrl.saveServerParams(); //keep for dirtyness detection
                createColumnList();
                $scope.hooks.updateRecipeStatus();
                DKUtils.reflowLater();
                if ($scope.params.joins && $scope.params.joins.length > 0 && $scope.params.joins[$scope.params.joins.length-1].on.length == 0) {
                    $scope.getJoinSuggestions();
                    var lastJoin = $scope.params.joins[$scope.params.joins.length-1];
                    var lastInputDesc = $scope.params.virtualInputs[lastJoin.table2];
                    $scope.autoSelectColumns(lastInputDesc);
                }
            }
        };

        $scope.$watchCollection("recipe.outputs.main.items", function() {
            var outputs = RecipesUtils.getOutputsForRole($scope.recipe, "main");
            if (outputs.length == 1) {
                $scope.outputDatasetName = outputs[0].ref;
            }
            $scope.updateRecipeStatusLater();
        });

        $scope.$watchCollection("params.virtualInputs", removeUnusedInputs);
        $scope.$watch("params.virtualInputs", function() {
            $scope.uiState.columnsWithComputed = undefined;
            DatasetUtils.updateRecipeComputables($scope, $scope.recipe, $stateParams.projectKey, contextProjectKey)
                    .then(_ => createColumnList());
        }, true);

        $scope.hooks.onRecipeLoaded = function() {
            Logger.info("On Recipe Loaded");
            $scope.$watch("script.data", onScriptChanged);
            // the onScriptChanged will be called because adding a $watch on the scope triggers an 'initialization' run
        };

        $scope.specificControllerLoadedDeferred.resolve();

        $scope.params = $scope.params || {};
        $scope.enableAutoFixup();
        $scope.uiState = {
            currentStep: 'join',
            computedColumns: []
        };
    });


    app.controller("NewJoinController", function ($scope, DataikuAPI, $q, $stateParams, Dialogs, DatasetUtils) {
        $scope.params.virtualInputs = $scope.params.virtualInputs || [];
        $scope.creation = !$scope.params.virtualInputs || !$scope.params.virtualInputs.length;
        $scope.newJoin = {
            table1Index: 0
        };

        $scope.joinIsValid = function() {
            return !!(($scope.newJoin.dataset1 || $scope.newJoin.table1Index != null) && $scope.newJoin.dataset2);
        };

        $scope.addJoin = function() {
            if ($scope.creation) {
                $scope.newJoin.table1Index = 0;
                $scope.addDataset($scope.newJoin.dataset1);
            }

            let contextProjectKey = $scope.context && $scope.context.projectKey ? $scope.context.projectKey:$stateParams.projectKey;
            DatasetUtils.updateDatasetInComputablesMap($scope, $scope.newJoin.dataset2, $stateParams.projectKey, contextProjectKey)
            .then(() => {
                if (!$scope.dataset2IsValid($scope.newJoin.dataset2)) {
                    return;
                }
                $scope.newJoin.table2Index = $scope.params.virtualInputs.length;

                $scope.addDataset($scope.newJoin.dataset2);

                var join = {
                    table1: $scope.newJoin.table1Index,
                    table2: $scope.newJoin.table2Index,
                    type: 'LEFT',
                    conditionsMode : 'AND',
                    on: [],
                    outerJoinOnTheLeft: true, // just for ADVANCED join type
                    rightLimit: {}
                };
                $scope.params.joins = $scope.params.joins || [];
                $scope.params.joins.push(join);
                $scope.dismiss();
                $scope.getJoinSuggestions();

                var table2Input = $scope.params.virtualInputs[$scope.newJoin.table2Index];
                $scope.autoSelectColumns(table2Input);
            });
        };

        $scope.dataset2IsValid = function(datasetName) {
            if (!datasetName) {
                return false;
            }
            const computable = $scope.computablesMap[datasetName];
            if (!computable) {
                $scope.error = 'Dataset '+datasetName+' does not seem to exist, try reloading the page.';
                return false;
            }
            if (!computable.dataset) {
                $scope.error = datasetName+' is not a dataset';
                return false;
            }
            if (!computable.dataset.schema || !computable.dataset.schema.columns.length) {
                $scope.error = 'Dataset '+datasetName+' has an empty schema';
                return false;
            }
            return true;
        };

        $scope.$on('$destroy', function() {
            $scope.updateRecipeStatusLater(0);
        });

        DatasetUtils.listDatasetsUsabilityInAndOut($stateParams.projectKey, "join").then(function(data){
            $scope.availableInputDatasets = data[0];
        });
    });

    /*
    Controller for join edit modal
    */
    app.controller("JoinEditController", function ($scope, CodeMirrorSettingService) {
        $scope.uiState = $scope.uiState || {};

        if (($scope.join.on.length == 0) && (!$scope.inFuzzy)){
            $scope.addEmptyCondition($scope.join);
            $scope.current.condition = $scope.join.on[0];
        }

        //TODO @join add $right, $left in autocompletion
        $scope.sqlEditorOptions = CodeMirrorSettingService.get('text/x-sql');
        $scope.sqlEditorOptions.autofocus = true;

        $scope.updateDecisionColumn = function() {
            var decisionColumn = $scope.join.rightLimit.decisionColumn;
            $scope.join.rightLimit.decisionColumn = {
                name: $scope.uiState.decisionColumnName,
                table: $scope.join.table2
            };
            $scope.hooks.updateRecipeStatus();
        };

        // getColumn: 1 or 2
        $scope.getColumn = function (condition, columnIdx) {
            const col = !columnIdx || columnIdx === 1 ? 'column1' : 'column2';
            return $scope.getColumnWithComputed($scope.getDatasetNameFromRecipeInputIndex($scope.params.virtualInputs[condition[col].table].index), condition[col].name);
        };

        $scope.hasStringOperand = function(condition, columnIdx) {
            const col = $scope.getColumn(condition, columnIdx);
            return col && col.type === 'string';
        };

        $scope.hasNumOperand = function(condition, columnIdx) {
            const col = $scope.getColumn(condition, columnIdx);
            return col && ['tinyint', 'smallint', 'int', 'bigint', 'float', 'double'].includes(col.type);
        };

        $scope.hasDateOperand = function(condition, columnIdx) {
            const col = $scope.getColumn(condition, columnIdx);
            return col && col.type === 'date';
        };

        $scope.hasGeoOperand = function(condition, columnIdx) {
            const col = $scope.getColumn(condition, columnIdx);
            return col && col.type === 'geopoint';
        };

        $scope.setJoinType = function(join, type) {
            join.type = type;
        };

        /* on operand change, make sure the condition type makes sense, if not fall back to = condition */
        var updateOperandType = function() {
            var condition = $scope.current.condition;
            if (!condition) {
                return;
            }
            var numOrDateJoinType = ['EQ', 'K_NEAREST', 'K_NEAREST_INFERIOR', 'WITHIN_RANGE', 'LTE', 'GTE', 'NE'];
            var stringJoinType = ['EQ', 'CONTAINS', 'STARTS_WITH', 'LTE', 'GTE', 'NE'];
            if (($scope.hasNumOperand(condition) || $scope.hasDateOperand(condition)) && numOrDateJoinType.indexOf(condition.type) < 0) {
                condition.type = 'EQ';
            } else if ($scope.hasStringOperand(condition) && stringJoinType.indexOf(condition.type) < 0) {
                condition.type = 'EQ';
            }
        };
        if (!$scope.isFuzzy) {
            $scope.$watch('current.condition.column1.name', updateOperandType);
            $scope.$watch('current.condition.column2.name', updateOperandType);
        }
        $scope.$on('$destroy', function() {
            $scope.updateRecipeStatusLater(0);
        });
    });

    var app = angular.module('dataiku.directives.widgets');

    app.directive('fuzzyJoinConditionSettings', function () {
        return {
            templateUrl: 'templates/recipes/fragments/join-condition-settings.html',
            link: function ($scope, element, attrs) {
                $scope.$watch('[current.condition.column1.name, current.condition.column2.name]', function (nv, ov) {
                    if (nv !== ov) {
                        $scope.guessDistanceType($scope.current.condition);
                    }
                });
                $scope.$watch('isRelativeDistance(current.condition)', function (nv, ov) {
                    if (angular.isDefined(nv) && angular.isDefined(ov) && nv !== ov) {
                        $scope.setInitialThreshold($scope.current.condition);
                    }
                });
            }
        };
    });

    /*
    this directive creates an element representing a join between two datasets
    */
    app.directive('joinBlock', function() {
        return {
            restrict: 'EA',
            scope: true,
            templateUrl: '/templates/recipes/fragments/join-block.html',
            link : function(scope, element, attrs) {
                scope.onConditionClicked = function (join, condition) {
                    if (attrs.onConditionClicked) {
                        if (!scope.current || scope.current.condition !== condition) {
                            var newScope = scope.$new();
                            newScope.join = join;
                            newScope.condition = condition;
                            newScope.$eval(attrs.onConditionClicked);
                        } else {
                            scope.current.condition = null;
                        }
                    }
                };
            }
        };
    });

    app.directive('joinBlockDropdownJoin', function() {
        return {
            restrict: 'EA',
            scope: true,
            templateUrl: '/templates/recipes/fragments/join-block-dropdown-join.html',
            link : function(scope, element, attrs) {
                scope.getJoinTypes = function() {
                    if (scope.isFuzzy) {
                        return ['LEFT', 'INNER', 'FULL', 'RIGHT'];
                    } else {
                        return ['LEFT', 'INNER', 'FULL', 'RIGHT', 'CROSS', 'ADVANCED'];
                    }
                };
                scope.joinTypes = scope.getJoinTypes();

                scope.getClass = function(type) {
                    if (type !== 'FULL') {
                        return `{selected: join.type == '${type}'}`;
                    } else {
                        return "{selected: join.type == 'FULL', disabled: !recipeStatus.selectedEngine.canFullOuterJoin}"
                    }
                }

                scope.getIconType = function (type) {
                    switch (type) {
                        case 'LEFT': return "icon-jointype-left"; break;
                        case 'INNER': return "icon-jointype-inner"; break;
                        case 'FULL': return "icon-jointype-outer"; break;
                        case 'RIGHT': return "icon-jointype-right"; break;
                        case 'CROSS': return "icon-jointype-cross"; break;
                        case 'ADVANCED': return "icon-jointype-advanced"; break;
                    }
                };


                scope.getTypeType = function (type) {
                    switch (type) {
                        case 'LEFT': return "Left Join"; break;
                        case 'INNER': return "Inner join"; break;
                        case 'FULL': return "Outer join"; break;
                        case 'RIGHT': return "Right join"; break;
                        case 'CROSS': return "Cross join"; break;
                        case 'ADVANCED': return "Advanced join"; break;
                    }
                };

                scope.getDescriptionType = function (type) {
                    switch (type) {
                        case 'LEFT': return "Keep all rows of the left dataset and add information from the right dataset"; break;
                        case 'INNER': return "Keep matches and drop rows without match from both datasets"; break;
                        case 'FULL': return "Keep all matches and keep rows without match from both datasets"; break;
                        case 'RIGHT': return "Keep all matches and keep rows without match from the right dataset"; break;
                        case 'CROSS': return "Cartesian product : match all rows of the left dataset with all rows of the right dataset"; break;
                        case 'ADVANCED': return "Custom options for rows selection and deduplication"; break;
                    }
                };
                scope.setJoinType = function(join, type) {
                    join.type = type;
                    if (!scope.isOpen() && (type != 'CROSS')) {
                        scope.showJoinEditModal(join);
                    }
                };
                scope.isSafari = function() {
                    var ua = navigator.userAgent.toLowerCase();
                    if (ua.indexOf('safari') != -1) {
                      if (ua.indexOf('chrome') > -1) {
                        return false;
                      } else {
                        return true; // Safari
                      }
                    } else {
                        return false;
                    }
                }
                scope.getCSSStyle = function(join) {
                    if (scope.isSafari()) {
                        return "";
                    } else {
                        return "background-image: linear-gradient(to right, "+ scope.getRealColor(join.table1) + " 50%,  " + scope.getRealColor(join.table2) + " 50%);" +
                                "background-clip: text;" +
                                "-webkit-background-clip: text;" +
                                "-moz-background-clip: text;" +
                                "-webkit-text-fill-color: transparent;" +
                                "color: transparent;" +
                                "display: inline;"
                    }
                };

                scope.getRealColor = function (index) {
                    // Grab color from visual-recipes (and color-variable.less)
                    switch (index%6) {
                        case 0: return "#28A9DD";break;
                        case 1: return "#29AF5D";break;
                        case 2: return "#8541AA";break;
                        case 3: return "#F44336";break;
                        case 4: return "#4785A4";break;
                        case 5: return "#F28C38";break;
                    }
                }

            }
        }
    });
    app.directive('joinBlockEmpty', function() {
        return {
            restrict: 'EA',
            scope: true,
            templateUrl: '/templates/recipes/fragments/join-block-empty.html',
            link : function(scope, element, attrs) {
                scope.onConditionClicked = function (join, condition) {
                    if (attrs.onConditionClicked) {
                        if (!scope.current || scope.current.condition !== condition) {
                            var newScope = scope.$new();
                            newScope.join = join;
                            newScope.condition = condition;
                            newScope.$eval(attrs.onConditionClicked);
                        } else {
                            scope.current.condition = null;
                        }
                    }
                };
            }
        };
    });

    /*
    Widget to select columns from input dataset and edit their output names
    */
    app.directive('selectedColumnsEditor', function($timeout) {
        return {
            restrict: 'EA',
            scope: true,
            link : function(scope, element, attrs) {
                var getColumns = function() {
                    return scope.$eval(attrs.columns);
                };

                var getExpectedFinalColumnName = function(name) {
                    if (scope.input && scope.input.prefix) {
                        return scope.input.prefix + '_' + name;
                    } else {
                        return name;
                    }
                }

                scope.editColumnAlias = function(columnIndex, column) {
                    scope.currentEditedColumn = column;
                    $timeout(function(){$('.alias-editor', element).get(columnIndex).focus();});
                };

                scope.endColumnEdition = function() {
                    var col = scope.currentEditedColumn;
                    var expected = getExpectedFinalColumnName(col ? col.name : '');
                    if (col && col.alias == expected) {
                        delete col.alias;
                    }
                    scope.currentEditedColumn = null;
                    scope.hooks.updateRecipeStatus();
                };

                scope.keyDownOnAliasBox = function(event) {
                   if (event.keyCode == 13 || event.keyCode == 27){//enter or esc
                        scope.endColumnEdition();
                   }
                };

                scope.updateSelectAll = function() {
                    $.each(getColumns(), function(idx, column) {
                        column.selected = scope.selected.all;
                    });
                    scope.selected.any = scope.selected.all;
                    scope.hooks.updateRecipeStatus();
                };

                var updateGlobalSelectionStatus = function() {
                    var all = true, any = false;
                    $.each(getColumns(), function(idx, column) {
                        if (column.selected) {
                            any = true;
                        } else {
                            all = false;
                        }
                    });
                    scope.selected = {
                        all: all, any: any
                    };
                };

                scope.onSelectionChange = function() {
                    updateGlobalSelectionStatus();
                    scope.hooks.updateRecipeStatus();
                };

                scope.hasDuplicates = function (datasetIndex, column) {
                    if (!scope.recipeStatus || !scope.recipeStatus.selectedColumns || !scope.recipeStatus.selectedColumns.duplicates)
                        return false;
                    if (!column.selected)
                        return false;
                    var duplicates = scope.recipeStatus.selectedColumns.duplicates;
                    for (var i = 0; i < duplicates.length; ++i) {
                        var duplicate = duplicates[i];
                        if (
                            duplicate.dataset1 == datasetIndex && duplicate.column1 == column.name
                            ||
                            duplicate.dataset2 == datasetIndex && duplicate.column2 == column.name
                        ) {
                            return true;
                        }
                    }
                    return false;
                };

                updateGlobalSelectionStatus();
            }
        };
    });
})();

(function () {
    'use strict';

    var app = angular.module('dataiku.recipes');

    app.controller("FuzzyJoinRecipeCreationController", function ($scope, Fn, $stateParams, DataikuAPI, $controller) {
        $scope.recipeType = "fuzzyjoin";
        $controller("SingleOutputDatasetRecipeCreationController", {$scope: $scope});

        $scope.autosetName = function () {
            if ($scope.io.inputDataset) {
                var niceInputName = $scope.io.inputDataset.replace(/[A-Z]*\./, "");
                $scope.maybeSetNewDatasetName(niceInputName + "_joined");
            }
        };

        $scope.getCreationSettings = function () {
            return {virtualInputs: [$scope.io.inputDataset, $scope.io.inputDataset2]};
        };

        var superFormIsValid = $scope.formIsValid;
        $scope.formIsValid = function () {
            return !!(superFormIsValid() &&
                $scope.io.inputDataset2 && $scope.activeSchema2 && $scope.activeSchema2.columns && $scope.activeSchema2.columns.length
            );
        };
        $scope.showOutputPane = function () {
            return !!($scope.io.inputDataset && $scope.io.inputDataset2);
        };

        $scope.showAdditionalInputsMessage = false;
    });

    app.controller("FuzzyJoinEditController", function ($scope, $controller, $timeout) {
        $scope.inFuzzy = true;
        $controller('JoinEditController', {$scope: $scope});

        $scope.checkBothOperands = function (fn) {
            return (c) => {
                return fn(c, 1) && fn(c, 2);
            };
        };

        const fuzzyJoinDistanceTypesAvailability = {
            'EXACT': () => true,
            'EUCLIDEAN': $scope.checkBothOperands($scope.hasNumOperand),
            'LEVENSHTEIN': $scope.checkBothOperands($scope.hasStringOperand),
            'HAMMING': $scope.checkBothOperands($scope.hasStringOperand),
            'COSINE': $scope.checkBothOperands($scope.hasStringOperand),
            'JACCARD': $scope.checkBothOperands($scope.hasStringOperand),
            'GEO': $scope.checkBothOperands($scope.hasGeoOperand),
        };

        $scope.availableDistances = function (condition) {
            return Object.entries(fuzzyJoinDistanceTypesAvailability).filter(([k, v]) => v(condition)).map(e => e[0]);
        };

        $scope.guessDistanceType = function (condition) {
            // Take the first non-EXACT distance available, if there's non default to EXACT or undefined if
            // no distances are available
            const availableDistances = $scope.availableDistances(condition);
            const matchingAvailableDistance = availableDistances.find(e => {
                return e && e !== 'EXACT';
            });
            if (matchingAvailableDistance) {
                condition.fuzzyMatchDesc.distanceType = matchingAvailableDistance;
            } else if (availableDistances.length) {
                condition.fuzzyMatchDesc.distanceType = availableDistances[0];
            }
        };

        $scope.setInitialThreshold = function (condition) {
            condition.fuzzyMatchDesc.threshold = $scope.isRelativeDistance(condition) ? 0.5 : 1;
        };

        $scope.addEmptyCondition = function (join, current, el) {
            const newCondition = {
                column1: {
                    table: join.table1,
                    name: $scope.getColumnsWithComputed($scope.getDatasetName(join.table1))[0].name
                },
                column2: {
                    table: join.table2,
                    name: $scope.getColumnsWithComputed($scope.getDatasetName(join.table2))[0].name
                },
                type: 'EQ',
                fuzzyMatchDesc: {
                    "threshold": 0
                }
            };
            $scope.guessDistanceType(newCondition);
            $scope.setInitialThreshold(newCondition);
            join.on = join.on || [];
            join.on.push(newCondition);

            current.condition = join.on[join.on.length - 1];
            if (el) {
                $timeout(() => {
                    el.scrollTop = el.scrollHeight;
                });
            }
        };
        if ($scope.join.on.length == 0) {
            $scope.addEmptyCondition($scope.join, $scope.current, null);
            $scope.current.condition = $scope.join.on[0];
        }

    });

    app.controller("FuzzyJoinRecipeController", function ($scope, $controller) {
        $controller('JoinRecipeController', {$scope: $scope});

        const originalSave = $scope.hooks.save;
        $scope.hooks.save = function () {
            const join = $scope.params.joins[0];

            $scope.recipeWT1Event('fuzzy-join-params', {
                "type": join.type,
                "on": JSON.stringify(join.on.map(on => {
                        return {
                            fuzzyMatchDesc: on.fuzzyMatchDesc,
                            normaliseDesc: on.normaliseDesc,
                            column1: $scope.getColumn($scope.getDatasetName(on.column1.table), on.column1.name).type,
                            column2: $scope.getColumn($scope.getDatasetName(on.column2.table), on.column2.name).type,
                        };
                    })
                )
            });
            return originalSave();
        };
        $scope.hasNormalisationParams = function (normaliseDesc) {
            return normaliseDesc && Object.values(normaliseDesc).some(v => v === true);
        };
        $scope.hasExtraInfoToShow = function (condition) {
            return $scope.hasNormalisationParams(condition.normaliseDesc) || $scope.isRelativeDistance(condition);
        };

        $scope.isConditionExpanded = (condition, current) => {
            return $scope.isFuzzy && current && current.condition && current.condition === condition;
        };


        $scope.joinDistanceTypes = {
            'EXACT': 'Strict equality',
            'EUCLIDEAN': 'Euclidean',
            'LEVENSHTEIN': 'Damerau-Levenshtein',
            'HAMMING': 'Hamming',
            'COSINE': 'Cosine',
            'JACCARD': 'Jaccard',
            'GEO': 'Geospatial'
        };

        $scope.isFuzzy = true;

        $scope.normalisationParams = {
            caseInsensitive: {label: 'Case insensitive', desc: 'Ignore case when matching characters'},
            normaliseText: {label: 'Remove punctuation and extra spaces', desc: 'Remove punctuation and extra spaces'},
            unicodeCasting: {label: 'Unicode casting', desc: 'Remove accents: cÁfé -> cAfe'},
            clearSalutations: {label: 'Clear salutations', desc: 'Remove English salutations, e.g. Miss, Sir, Dr'},
            clearStopWords: {label: 'Clear stop words', desc: 'Remove common stop words depending on the language'},
            transformToStem: {label: 'Transform to stem', desc: 'Transform words to base form (Snowball stemmer)'},
            sortAlphabetically: {label: 'Alphabetic sorting of words', desc: 'Alphabetic sorting of words'},
        };

        $scope.isNumber = angular.isNumber;
        $scope.isDefined = angular.isDefined;

        $scope.updateDebugMode = function () {
            $scope.params.withMetaColumn = $scope.params.debugMode;
            $scope.hooks.updateRecipeStatus();
        };
    });


    app.controller("NewFuzzyJoinController", function ($scope, DataikuAPI, $q, $stateParams, Dialogs, DatasetUtils) {
        $scope.params.virtualInputs = $scope.params.virtualInputs || [];
        $scope.creation = !$scope.params.virtualInputs || !$scope.params.virtualInputs.length;
        $scope.newJoin = {
            table1Index: 0
        };

        $scope.joinIsValid = function () {
            return !!(($scope.newJoin.dataset1 || $scope.newJoin.table1Index != null) && $scope.newJoin.dataset2);
        };

        $scope.addJoin = function () {
            if ($scope.creation) {
                $scope.newJoin.table1Index = 0;
                $scope.addDataset($scope.newJoin.dataset1);
            }

            let contextProjectKey = $scope.context && $scope.context.projectKey ? $scope.context.projectKey:$stateParams.projectKey;
            DatasetUtils.updateDatasetInComputablesMap($scope, $scope.newJoin.dataset2, $stateParams.projectKey, contextProjectKey)
            .then(() => {
                if (!$scope.dataset2IsValid($scope.newJoin.dataset2)) {
                    return;
                }

                $scope.newJoin.table2Index = $scope.params.virtualInputs.length;

                $scope.addDataset($scope.newJoin.dataset2);

                var join = {
                    table1: $scope.newJoin.table1Index,
                    table2: $scope.newJoin.table2Index,
                    type: 'LEFT',
                    conditionsMode: 'AND',
                    on: [],
                    outerJoinOnTheLeft: true, // just for ADVANCED join type
                    rightLimit: {}
                };
                $scope.params.joins = $scope.params.joins || [];
                $scope.params.joins.push(join);
                $scope.dismiss();
                $scope.getJoinSuggestions();

                var table2Input = $scope.params.virtualInputs[$scope.newJoin.table2Index];
                $scope.autoSelectColumns(table2Input);
            });
        };

        $scope.dataset2IsValid = function (datasetName) {
            if (!datasetName) {
                return false;
            }
            const computable = $scope.computablesMap[datasetName];
            if (!computable) {
                $scope.error = 'Dataset ' + datasetName + ' does not seem to exist, try reloading the page.';
                return false;
            }
            if (!computable.dataset) {
                $scope.error = datasetName + ' is not a dataset';
                return false;
            }
            if (!computable.dataset.schema || !computable.dataset.schema.columns.length) {
                $scope.error = 'Dataset ' + datasetName + ' has an empty schema';
                return false;
            }
            return true;
        };

        $scope.$on('$destroy', function () {
            $scope.updateRecipeStatusLater(0);
        });

        DatasetUtils.listDatasetsUsabilityInAndOut($stateParams.projectKey, "fuzzyjoin").then(function (data) {
            $scope.availableInputDatasets = data[0];
        });
    });
})();

(function() {
    'use strict';
	var app = angular.module('dataiku.recipes');

    // Creation modal controller
    app.controller("SyncRecipeCreationController", function($scope, $rootScope, Fn, $stateParams, DataikuAPI, $controller, FeatureFlagsService) {
        $scope.recipeType = "sync";
        if ($rootScope.appConfig.streamingEnabled) {
            $scope.datasetsOnly = false;
            $scope.inputDatasetsOnly = true;
        }        
        $controller("SingleOutputDatasetRecipeCreationController", {$scope:$scope});

        if ($rootScope.appConfig.streamingEnabled) {
            $scope.singleOutputRole.acceptsStreamingEndpoint = true; // add the possibility of streaming endpoints
        }        

        $scope.autosetName = function() {
            if ($scope.io.inputDataset) {
                var niceInputName = $scope.io.inputDataset.replace(/[A-Z]*\./,"");
                $scope.maybeSetNewDatasetName(niceInputName + "_copy");
            }
        };
    });


    app.controller("SyncRecipeController", function($scope, $stateParams, $q, $controller, Assert, StateUtils, DataikuAPI, Dialogs, TopNav, RecipesUtils, PartitionDeps, ComputableSchemaRecipeSave, Logger) {
	    Assert.inScope($scope, 'recipe');

        $controller("_RecipeWithEngineBehavior", {$scope:$scope});

        $scope.schemaModes = [
            ["FREE_SCHEMA_NAME_BASED", "Free output schema (name-based matching)"],
            ["STRICT_SYNC", "Maintain strict schema equality"]
        ];

        $scope.hooks.save = function(){
            if ($scope.recipe.params.schemaMode == "FREE_SCHEMA_NAME_BASED") {
                return $scope.hooks.origSaveHook();
            } else {
                var deferred = $q.defer();
                var recipeSerialized = angular.copy($scope.recipe);
                PartitionDeps.prepareRecipeForSerialize(recipeSerialized);
                ComputableSchemaRecipeSave.handleSave($scope, recipeSerialized, null, deferred);
                return deferred.promise;
            }
        };

        $scope.hooks.onRecipeLoaded = function() {
            Logger.info("On Recipe Loaded");
            $scope.hooks.updateRecipeStatus();
        };

        $scope.hooks.updateRecipeStatus = function() {
            var deferred = $q.defer();
            $scope.updateRecipeStatusBase(false).then(function() {
                // $scope.recipeStatus should have been set by updateRecipeStatusBase
                if (!$scope.recipeStatus) return deferred.reject();
                deferred.resolve($scope.recipeStatus);
            });
            return deferred.promise;
        };

        $scope.resyncSchema = function() {
            var input = RecipesUtils.getSingleInput($scope.recipe, "main");
            var output = RecipesUtils.getSingleOutput($scope.recipe, "main");
            Dialogs.confirmPositive($scope, 'Resynchronize schema',
                'The schema of "'+input.ref+'" will be copied to "'+output.ref+'". Are you sure you want to continue ?')
            .then(function() {
                 DataikuAPI.flow.recipes.basicResyncSchema($stateParams.projectKey, $scope.hooks.getRecipeSerialized()).error(setErrorInScope.bind($scope));
            });
        };

        TopNav.setTab(StateUtils.defaultTab("io"));

        $scope.recipe.params = $scope.recipe.params || {};
        $scope.recipe.params.schemaMode = $scope.recipe.params.schemaMode || "FREE_SCHEMA_NAME_BASED";
        $scope.params = $scope.recipe.params;

        $scope.$watch("recipe.params", $scope.updateRecipeStatusLater, true);
        $scope.enableAutoFixup();
        $scope.specificControllerLoadedDeferred.resolve();
	});
})();
(function() {
    'use strict';
    var app = angular.module('dataiku.recipes');


    app.controller("UpdateRecipeCreationController", function($scope, Fn, $stateParams, DataikuAPI, $controller) {
        $scope.recipeType = "update";
        $controller("SingleOutputDatasetRecipeCreationController", {$scope:$scope});

        $scope.inlineDataset = true; // to send to the check-name-safety

        $scope.autosetName = function() {
            if ($scope.io.inputDataset) {
                var niceInputName = $scope.io.inputDataset.replace(/[A-Z]*\./,"");
                $scope.maybeSetNewDatasetName(niceInputName + "_copy");
            }
        };
    });


    app.controller("UpdateRecipeController", function($scope, $stateParams, $q, $timeout, DataikuAPI, Dialogs, PartitionDeps, RecipesUtils, ActivityIndicator, ComputableSchemaRecipeSave) {
        $scope.hooks.save = function() {
            var deferred = $q.defer();
            var recipeSerialized = angular.copy($scope.recipe);
            PartitionDeps.prepareRecipeForSerialize(recipeSerialized);
            var serializedPayload = angular.toJson($scope.recipe.params);
            ComputableSchemaRecipeSave.handleSave($scope, recipeSerialized, serializedPayload, deferred);
            return deferred.promise;
        };

        $scope.hooks.preRunValidate = function() {
            var deferred = $q.defer();
            if (!$scope.recipe.params.uniqueKey || $scope.recipe.params.uniqueKey.length == 0) {
                ActivityIndicator.error("Unique key is required");
                deferred.reject("Unique key is required");
            } else {
                deferred.resolve({ok: true});
            }
            return deferred.promise;
        };

        $scope.uiState = {};
        $scope.recipe.params = $scope.recipe.params || {};
        $scope.recipe.params.uniqueKey = $scope.recipe.params.uniqueKey || [];
        $scope.recipe.params.filter = $scope.recipe.params.filter || {};
        $scope.recipe.params.addMissingRows =   $scope.recipe.params.addMissingRows !== undefined ? $scope.recipe.params.addMissingRows : true;
        $scope.recipe.params.deleteMissingCols = $scope.recipe.params.deleteMissingCols || false;
        $scope.recipe.params.deleteMissingRows = $scope.recipe.params.deleteMissingRows || false;
        $scope.recipe.params.addMissingCols = $scope.recipe.params.addMissingCols !== undefined ? $scope.recipe.params.addMissingCols : true;

        //TODO move
        $scope.getInputName = function(idx, role) {
            idx = idx || 0;
            role = role || 'main';
            return $scope.recipe.inputs[role].items[idx].ref;
        };

        $scope.getInputSchema = function(idx, role) {
            if ($scope.computablesMap) {
                return $scope.computablesMap[$scope.getInputName(idx, role)].dataset.schema;
            }
        };

        function getInputColumns() {
            return $scope.getInputSchema().columns.map(function(col){return col.name});
        }

        $scope.updateSuggests = function() {
            var schema = $scope.getInputSchema();
            if (schema && schema.columns) {
                $scope.remainingSuggests = listDifference(getInputColumns(), $scope.recipe.params.uniqueKey);
            }
        };

        $scope.addKeyPart = function(name) {
            if (listDifference(getInputColumns(), $scope.recipe.params.uniqueKey).indexOf(name) >= 0) {
                $scope.recipe.params.uniqueKey.push(name);
                $scope.updateSuggests();
                $timeout(function() {$scope.uiState.newKeyPart = '';$('#keypart').blur();});
            }
        };

        $scope.removeKeyPart = function(index) {
            $scope.recipe.params.uniqueKey.splice(index,1);
            $scope.updateSuggests();
        };

        //enable auto-add key part on click (no need to type enter)
        $scope.$on("typeahead-updated", function() {
            safeApply($scope, function(){
                $scope.addKeyPart($scope.uiState.newKeyPart);
            });
        });

        $scope.$on('computablesMapChanged', $scope.updateSuggests, true);

        $scope.$watch('getInputSchema()', $scope.updateSuggests);

        $scope.updateSuggests();
        $scope.enableAutoFixup();
    });

    app.directive("exportRecipeBody", function(Assert, ExportService) {
        return {
            scope: true,
            link: function($scope) {
                Assert.inScope($scope, 'recipe');
                let setExportParams = function(params) {
                    $scope.recipe.params.exportParams = params;
                };
                ExportService.initExportBehavior($scope, {}, {advancedSampling: true, partitionListLoader: null},
                    $scope.recipe.params, null, $scope.recipe.params.exportParams, setExportParams);
            }
        };
    });


app.controller("ExportRecipeCreationController", function($scope, $stateParams, $state, $controller, Fn,
        DataikuAPI, WT1, RecipesUtils, RecipeDescService, DatasetsService, RecipeComputablesService, PartitionDeps, BigDataService) {

    $controller("_RecipeCreationControllerBase", {$scope:$scope});

    function init(){

        $scope.recipeName = {};
        $scope.script = "";
        $scope.recipe = {
            projectKey : $stateParams.projectKey,
            type: "export",
            inputs : {},
            outputs : {},
            params: {}
        };

        if($scope.recipePrefillKey) {
            var prefill = BigDataService.fetch($scope.recipePrefillKey);

            if(prefill) {
                if(prefill.script) {
                    $scope.script = prefill.script;
                }
                if(prefill.input) {
                    prefill.input.forEach(function(x){
                        RecipesUtils.addInput($scope.recipe, "main", x);
                    })
                }
                if(prefill.output) {
                    prefill.output.forEach(function(x){
                        RecipesUtils.addOutput($scope.recipe, "main", x);
                    });
                }
            }
        }
        $scope.$on("preselectInputDataset", function(scope, preselectedInputDataset) {
            RecipesUtils.addInput($scope.recipe, "main", preselectedInputDataset);
            $scope.preselectedInputDataset = preselectedInputDataset;
        });

        RecipeComputablesService.getComputablesMap($scope.recipe, $scope).then(function(map){
            $scope.setComputablesMap(map);
        });
    }

    // we will autofill the name if needed
    $scope.$watch("[recipe.inputs, recipe.outputs]", function(nv, ov) {
        if (nv && $scope.recipe && $scope.recipe.inputs && $scope.recipe.outputs){
            if ($scope.preselectedInputDataset && $scope.recipe.inputs.main.items[0].ref != $scope.preselectedInputDataset) {
                $scope.zone = null;
            }
            var outputs = RecipesUtils.getFlatOutputsList($scope.recipe);
            $scope.hasRequiredIO = RecipeDescService.hasValidRequiredRoles($scope.recipe);
            if (outputs.length && $scope.hasRequiredIO) {
                $scope.recipeName.name = "compute_" + outputs[0].ref;
            } else {
                // erase the name to make the modal not ready to close
                $scope.recipeName.name = null;
            }
        }
    }, true);


    init();

    addDatasetUniquenessCheck($scope, DataikuAPI, $stateParams.projectKey);
    fetchManagedDatasetConnections($scope, DataikuAPI);
    DatasetsService.updateProjectList($stateParams.projectKey);
});


    app.controller("ExportRecipeController", function($scope, $stateParams, $q, $timeout, DataikuAPI, Dialogs, PartitionDeps) {
        $scope.hooks.save = function() {
            var deferred = $q.defer();
            var recipeSerialized = angular.copy($scope.recipe);
            PartitionDeps.prepareRecipeForSerialize(recipeSerialized);

            $scope.baseSave(recipeSerialized, null).then(function(){
                        deferred.resolve("Save done");
                    }, function(error) {
                        Logger.error("Could not save recipe");
                        deferred.reject("Could not save recipe");
                    })
            return deferred.promise;
        };

        $scope.hooks.preRunValidate = function() {
            var deferred = $q.defer();
            deferred.resolve({"ok" : true});
            return deferred.promise;
        };

        $scope.enableAutoFixup();
    });
})();

(function() {
'use strict';
var app = angular.module('dataiku.recipes');

app.controller("DownloadRecipeCreationController", function($scope, $stateParams, $state, $controller, Fn,
        DataikuAPI, WT1, RecipesUtils, RecipeDescService, DatasetsService, RecipeComputablesService, PartitionDeps, BigDataService, DatasetUtils) {

    $controller("_RecipeCreationControllerBase", {$scope:$scope});
    $controller("_RecipeOutputNewManagedBehavior", {$scope:$scope});

    $scope.uiState = $scope.uiState || {};
    $scope.io.newOutputTypeRadio = 'new-odb';
    $scope.recipeType = 'download';

    // for safety, to use the _RecipeOutputNewManagedBehavior fully (maybe one day)
    $scope.setErrorInTopScope = function(scope) {
        return setErrorInScope.bind($scope);
    };

    var makeMainRole = function (refs) {
        return {
            main: {
                items: refs.filter(function(ref) {return !!ref;}).map(function(ref) {return {ref: ref}; })
            }
        }
    };

    // Creates the recipe object and sends it to the backend
    $scope.doCreateRecipe = function() {
        var createOutputFolder = $scope.io.newOutputTypeRadio == 'new-odb';
        var outputRef = createOutputFolder ? $scope.newOutputODB.name : $scope.io.existingOutputDataset;
        var outputName = createOutputFolder ? $scope.newOutputODB.name : $scope.availableOutputFolders.filter(function(f) {return f.smartName == $scope.io.existingOutputDataset;})[0].label;
        var recipe = {
            type: $scope.recipeType,
            projectKey: $stateParams.projectKey,
            name: "download_to_"+outputName,

            inputs: {},
            outputs: makeMainRole([outputRef]),
        };
        if ($scope.zone) recipe.zone = $scope.zone;

        var settings = {
                createOutputFolder : createOutputFolder,
                outputFolderSettings : $scope.getFolderCreationSettings()
        };

        return DataikuAPI.flow.recipes.generic.create(recipe, settings);
    };

    // Called from UI, force means that no check-name-safety call is done
    $scope.createRecipe = function() {
        $scope.recipeWT1Event("recipe-create-" + $scope.recipeType);
        var p = $scope.doCreateRecipe();
        if (p) {
            $scope.creatingRecipe = true;
            p.success(function(data) {
                $scope.creatingRecipe = false;
                $scope.dismiss();
                $scope.$state.go('projects.project.recipes.recipe', {recipeName: data.id});
            }).error(function(a, b, c) {
                $scope.creatingRecipe = false;
                setErrorInScope.bind($scope)(a,b,c);
            });
        }
    };

    $scope.formIsValid = function() {
        if ($scope.io.newOutputTypeRadio == 'new-odb') {
            return $scope.newOutputODB && $scope.newOutputODB.name && $scope.newOutputODB.connectionOption;
        } else if ($scope.io.newOutputTypeRadio == 'select') {
            return $scope.io.existingOutputDataset;
        } else {
            return false;
        }
    };

    DatasetUtils.listFoldersUsabilityForOutput($stateParams.projectKey, $scope.recipeType).then(function(data){
        $scope.availableOutputFolders = data.filter(function(computable){
            return computable.usableAsOutput['main'] && computable.usableAsOutput['main'].usable && !computable.alreadyUsedAsOutputOf;
        });
    });

    var updateManagedFolderOptions = function() {
        var recipe = {
                type: $scope.recipeType,
                projectKey: $stateParams.projectKey,
                name: "compute_",
                inputs: {},
                outputs: {}
            };

        DataikuAPI.datasets.getManagedFolderOptions(recipe, 'main')
            .success(function(data) {
                $scope.setupManagedFolderOptions(data);
            })
            .error($scope.setErrorInTopScope($scope));
    };
    updateManagedFolderOptions();
});


app.controller("DownloadRecipeController", function($scope, $stateParams, $q, $timeout, DataikuAPI, Dialogs, PartitionDeps, RecipesUtils, ExportService) {
    $scope.hooks.save = function() {
        var deferred = $q.defer();
        var recipeSerialized = angular.copy($scope.recipe);
        PartitionDeps.prepareRecipeForSerialize(recipeSerialized);

        $scope.baseSave(recipeSerialized, null).then(function(){
                    deferred.resolve("Save done");
                }, function(error) {
                    Logger.error("Could not save recipe");
                    deferred.reject("Could not save recipe");
                })
        return deferred.promise;
    };

    $scope.hooks.preRunValidate = function() {
        var deferred = $q.defer();
        deferred.resolve({"ok" : true});
        return deferred.promise;
    };

    $scope.isOutputPartitioned = function() {
        return RecipesUtils.hasAnyPartitioning($scope.recipe, $scope.computablesMap);
    };

    $scope.enableAutoFixup();

    $scope.hasConnectionHasMetadata = function(source) {
        return ['Azure', 'S3', 'GCS'].indexOf(source.providerType) >= 0;
    };
    $scope.getDefaultPath = function(source) {
        return ['FTP', 'SFTP', 'SCP', 'Azure', 'S3', 'GCS'].indexOf(source.providerType) >= 0 ? '' : '/';
    };
    var contextVars = {};
    $scope.getContextVars = function() {
        return contextVars; // don't return a new one each time, otherwise $digest loop
    };
    $scope.getConnectionType = function(t) {
        return t == 'SFTP' || t == 'SCP' ? 'SSH' : t;
    };

    DataikuAPI.datasets.listFSProviderTypes(true).success(function(data) {
        $scope.providerTypes = data;
        $scope.providerTypes = ["URL"].concat($scope.providerTypes);
    }).error(setErrorInScope.bind($scope));

    $scope.addSource = function() {
        var source = {useGlobalProxy:true, providerType:'URL', params:{path:'', consider404AsEmpty:true, fallbackHeadToGet:true, trustAnySSLCertificate:false}};
        $scope.recipe.params.sources.push(source);
    };
    $scope.removeSource = function(index) {
        $scope.recipe.params.sources.splice(index, 1);
    };

    $scope.onProviderParamsChanged = function(source) {
        // no special action to take when changing the provider (at the moment)
    };

    $scope.checkSource = function(source) {
        var recipeSerialized = angular.copy($scope.recipe);
        PartitionDeps.prepareRecipeForSerialize(recipeSerialized);
        DataikuAPI.flow.recipes.download.checkDownloadSource($stateParams.projectKey, recipeSerialized, source, source.$testPartition).success(function(data) {
            source.$check = data;
        }).error(setErrorInScope.bind($scope));
    };
});

app.controller("CreateUrlDownloadToFolderDatasetController", function($scope, $state, $timeout, DataikuAPI, WT1, JobDefinitionComputer) {
    var folder;
    $scope.downloading = false;
    $scope.params = {
        url: '',
        connection: null,
        recipeName: null,
        folderName: '',
        folderId: null
    };
    $scope.$watch('params.projectKey', function(projectKey) {
        DataikuAPI.datasets.getManagedFolderOptionsNoContext(projectKey).success(function(data) {
            $scope.connections = data.connections.filter(function(_) {
                return ['Filesystem', 'HDFS'].indexOf(_.connectionType) >= 0;
            });
            var selected = $scope.connections.map(function(_){ return _.connectionName; }).indexOf('filesystem_managed');
            if (selected < 0) { // first Filesystem
                selected = $scope.connections.map(function(_){ return _.connectionType; }).indexOf('Filesystem');
                if (selected < 0 && $scope.connections.length > 0) { // first connection
                    selected = 0;
                }
            }
            if (selected >= 0) {
                $scope.params.connection = $scope.connections[selected];
            }
        });
    });
    $scope.checkURL = function() {
        $scope.downloading = true;
        function done(data) {
            $scope.downloadCheck = data;
            $scope.downloading = false;
            if (data.successful) {
                var url = new URL($scope.params.url);
                if (!$scope.params.folderName) {
                    $scope.params.folderName = url.hostname;
                }
            }
        }
        DataikuAPI.flow.recipes.download.checkDownloadURL($scope.projectKey, $scope.params.url)
            .success(done).error(done);
    };
    $scope.createFolderAndDownload = function() {
        if (!$scope.params.folderId) {
            WT1.event("new-managed-folder-modal-create");
            DataikuAPI.datasets.newManagedFolder($scope.params.projectKey, $scope.params.folderName, {
                type: $scope.params.connection.fsProviderTypes[0],
                connectionId: $scope.params.connection.connectionName,
                partitioningOptionId: 'NP'
            }).success(function(data) {
                $scope.params.folderId = data.id;
                folder = data;
                createRecipe();
            }).error(setErrorInScope.bind($scope));
        } else if (!$scope.params.recipeName) {
            createRecipe();
        } else {
            runRecipe();
        }
    };
    $scope.goToFolder = function() {
        $state.go('projects.project.managedfolders.managedfolder.view', { odbId: $scope.params.folderId });
        $scope.dismiss();
    };
    $scope.goCreateDataset = function() {
        $state.go('projects.project.datasets.new_with_type.settings', {
            type: 'FilesInFolder',
            prefillParams: JSON.stringify({
                folderSmartId: $scope.params.folderId,
                itemPathPattern: "/.*"
            })
        });
        $scope.dismiss();
        return;
    }

    function createRecipe() {
        var recipe = {
            name: 'compute_' + $scope.params.folderId,
            projectKey: $scope.params.projectKey,
            type: "download",
            inputs: {},
            outputs: {
                main: {
                    items: [{
                        ref: $scope.params.folderId,
                        deps: []
                    }]
                }
            },
            params: {
                deleteExtraFiles: true,
                copyEvenUpToDateFiles: false,
                sources: [{
                    useGlobalProxy:true,
                    providerType: "URL",
                    params: { path: $scope.params.url }
                }]
            }
        };
        $scope.creatingRecipe = true;
        DataikuAPI.flow.recipes.generic.create(recipe, { script: '' })
            .success(function(data) {
                $scope.params.recipeName = data.id;
                $scope.creatingRecipe = false;
                runRecipe();
            }).error(function(a, b, c) {
                $scope.creatingRecipe = false;
                setErrorInScope.bind($scope)(a,b,c);
            });
    }

    function runRecipe() {
        $scope.downloading = true;
        $scope.jobStatus = null;

        var jd = JobDefinitionComputer.computeJobDefForBox(
            $scope.params.projectKey,
            'NON_RECURSIVE_FORCED_BUILD',
            folder,
            null,   // NP
            'RECIPE',
            $scope.params.recipeName
        );

        DataikuAPI.flow.jobs.start(jd).success(function(data) {
            $scope.jobId = data.id;
            waitForEndOfRecipeRun();
        }).error(function(a, b, c) {
            $scope.downloading = false;
            setErrorInScope.bind($scope)(a, b,c);
        });

    }

    function waitForEndOfRecipeRun() {
        DataikuAPI.flow.jobs.getJobStatus($scope.params.projectKey, $scope.jobId).success(function(data) {
            $scope.jobStatus = data;
            data.totalWarningsCount = 0;
            for (var actId in data.baseStatus.activities) {
                var activity = data.baseStatus.activities[actId];
                if (activity.warnings) {
                    data.totalWarningsCount += activity.warnings.totalCount;
                }
            }
            if (data.baseStatus.state != "DONE" && data.baseStatus.state != "ABORTED" &&
                data.baseStatus.state != "FAILED") {
                $scope.jobCheckTimer = $timeout(waitForEndOfRecipeRun, 2000);
            } else {
                $scope.downloading = false;
            }
        }).error(setErrorInScope.bind($scope));
    }

});

})();
(function() {
    'use strict';
    var app = angular.module('dataiku.recipes');

    app.controller("MergeFolderRecipeCreationController", function($scope, $controller, $stateParams, DataikuAPI, Fn, RecipeComputablesService) {

        $controller("CodeBasedRecipeCreationController", {$scope:$scope});

        $scope.recipeType = "merge_folder";
        $scope.recipeName = {};
        $scope.recipe = {
            type: 'merge_folder',
            projectKey: $stateParams.projectKey,
            inputs: {
                main: {
                    items: []
                }
            },
            outputs: {
                main: {
                    items: []
                }
            }
        };

        RecipeComputablesService.getComputablesMap($scope.recipe, $scope).then(function(map) {
            $scope.setComputablesMap(map);
        });

    });

    app.controller("MergeFolderRecipeController", function($scope, $stateParams, $q, $timeout, DataikuAPI, PartitionDeps) {
        $scope.hooks.save = function() {
            var deferred = $q.defer();
            var recipeSerialized = angular.copy($scope.recipe);
            PartitionDeps.prepareRecipeForSerialize(recipeSerialized);

            $scope.baseSave(recipeSerialized, null).then(function(){
                        deferred.resolve("Save done");
                    }, function(error) {
                        Logger.error("Could not save recipe");
                        deferred.reject("Could not save recipe");
                    })
            return deferred.promise;
        };

        $scope.hooks.preRunValidate = function() {
            var deferred = $q.defer();
            deferred.resolve({"ok" : true});
            return deferred.promise;
        };

        $scope.enableAutoFixup();

        $scope.conflictHandlings = [
            ["SUFFIX", "Add a suffix when conflicts happen"],
            ["FAIL", "Fail if files conflict"],
            ["OVERWRITE", "Overwrite files with the same name"]
        ];

        $scope.recipe.params.conflictHandling = $scope.recipe.params.conflictHandling || "OVERWRITE";
    });

})();

(function(){
'use strict';

var app = angular.module('dataiku.recipes');


app.factory("CodeBasedEditorUtils", function($rootScope, CodeMirrorSettingService) {
    var svc = {
        editorOptions : function(mode, $scope, enableLint) {
            const hintModeBlacklist = ['text/x-sql', 'text/x-sql2', 'text/x-hivesql', 'text/x-dkupig']; // don't apply recipe autocomplete to these modes
            var options = CodeMirrorSettingService.get(mode, {
                onLoad: function(cm) {$scope.cm = cm;},
                words: getRecipeWords($scope)
            });
            options.extraKeys['Meta-Enter'] = function(cm) {$scope.validateRecipe();};
            options.extraKeys['Ctrl-Enter'] = function(cm) {$scope.validateRecipe();};
            options.gutters = ["CodeMirror-lint-markers","CodeMirror-foldgutter"];

            // computablesMap isn't available if coming from list view, so fire when it is available
            $scope.$on('computablesMapChanged', () => {
                if (hintModeBlacklist.indexOf(mode) < 0) {
                    options.extraKeys[CodeMirrorSettingService.getShortcuts()['AUTOCOMPLETE_SHORTCUT']] = CodeMirrorSettingService.showHint(mode, getRecipeWords($scope));
                }
            })

            if (enableLint) {
                options.lint = {
                    'getAnnotations' : function(cm,updateFunction) {
                        $scope.linterFunction = function(err) {
                            updateFunction(err);
                        };
                    },
                    'async' : true
                };
            }
            return options;
        },

        updateLinter : function(validationResult, linterFunction) {
            var found = [];
            if(validationResult) {
                validationResult.topLevelMessages.messages.forEach(function(err) {
                    if (err.line >= 0) {
                         var lineTo = (err.lineTo >= 0 ? err.lineTo : err.line);
                        found.push({
                            from: CodeMirror.Pos(err.line-1, 0),
                            to: CodeMirror.Pos(lineTo-1, 1000),
                            message: err.message + (err.context ? " (around " + err.context + ")" : ""),
                            severity : err.severity=='WARNING'?'warning':'error'
                        });
                    }
                });
            }
            if(linterFunction) {
                linterFunction(found);
            }
        }
    };

    return svc;

    function getRecipeWords($scope) {
        let inputs = $scope.recipe && $scope.recipe.inputs && $scope.recipe.inputs['main'] ? $scope.recipe.inputs['main'].items : [];
        let outputs = $scope.recipe && $scope.recipe.outputs && $scope.recipe.outputs['main'] ? $scope.recipe.outputs['main'].items : [];
        let computables = $scope.computablesMap || [];
        return inputs.concat(outputs) // [input1 def, output1 def]
                .map(_ => computables[_.ref]) // [input1 computable, output1 computable]
                .filter(_ => _ && _.dataset && _.dataset.schema && _.dataset.schema.columns)
                .map(_ => _.dataset.schema.columns.map(c => c.name)) // [[input1 col names], [output1 col names]]
                .reduce((a, b) => a.concat(b.filter(_ => !a.includes(_))), []); // [deduplicated concatenated col names]
    }
});


app.factory("CodeBasedValidationUtils", function(DataikuAPI, RecipeRunJobService, $stateParams){
    var svc = {
        /* Returns a promise to the validation result (ie CodeBasedRecipeStatus object) */
        getGenericCheckPromise : function($scope) {
            $scope.hooks.resetScope();

            return DataikuAPI.flow.recipes.generic.getStatusWithSpinner($scope.hooks.getRecipeSerialized(),
                $scope.script.data, 1, {
                    targetPartitionSpec : RecipeRunJobService.getTargetPartition($scope, $stateParams)
                })
            .error(setErrorInScope.bind($scope))
            .then(function(resp) {
                var data = resp.data;
                data.allMessagesLength = data.allMessagesForFrontend.messages.reduce(function(acc, msg){
                    return acc + msg.message.length;
                }, 0);
                return data;
            });
        }
    }
    return svc;
});


app.factory("CodeBasedToPluginConverter", function(CreateModalFromTemplate, DataikuAPI, WT1, $state, $rootScope, StateUtils, PluginsService){
    const svc = {
        transformToDevPlugin: function($scope, convertAPIFunc, type) {
            CreateModalFromTemplate("/templates/recipes/custom-code/code-recipe-to-customcode.html", $scope, null, function(modalScope) {
                const getAPICallParams = function(scope) {
                    const params = scope.convert;
                    const pluginId = params.mode == 'NEW' ? params.newPluginId : params.targetPluginId;
                    return [pluginId,
                            params.mode,
                            scope.script.data,
                            params.targetFolder,
                            scope.hooks.getRecipeSerialized()];
                };
                PluginsService.transformToDevPlugin(modalScope, convertAPIFunc, getAPICallParams,
                                                    "plugin-convert-to-customcode", "customCodeRecipes", type);
            });
        }
    }
    return svc;
});



app.directive('codeBasedRecipeBase', function($timeout, $stateParams, DataikuAPI, Assert, StateUtils, TopNav, RecipesUtils) {
    return {
        controller: function($scope) {
            const tabToSelect = StateUtils.defaultTab($scope.creation ? "io" : "code");
            TopNav.setTab(tabToSelect);
            Assert.inScope($scope, 'hooks');

            function insert(text) {
                if(!text) return;

                $timeout(function() {
                    $scope.cm.replaceSelection(text, 'end');
                });
                $scope.cm.focus();
            }

            function checkDatasetFragmentsLoaded(type, dataset) {
                return $scope.insertableFragments && $scope.insertableFragments[type][dataset.name];
            }
            function checkStreamingEndpointFragmentsLoaded(type, streamingEndpoint) {
                return $scope.insertableFragments && $scope.insertableFragments[type][streamingEndpoint.id];
            }

            /**
            * Inserts the column name
            */
            $scope.insertColumn = function(type, dataset, column) {
                if(checkDatasetFragmentsLoaded(type, dataset)) {
                    insert($scope.insertableFragments[type][dataset.name].columnRefs[column.name]);
                }
                if(checkStreamingEndpointFragmentsLoaded(type, dataset)) {
                    insert($scope.insertableFragments[type][dataset.id].columnRefs[column.name]);
                }
            };

            /**
            * Inserts the dataset name
            */
            $scope.insertDataset = function(type, dataset) {
                if(checkDatasetFragmentsLoaded(type, dataset)) {
                    insert($scope.insertableFragments[type][dataset.name].datasetRef);
                }
            }
            $scope.insertStreamingEndpoint = function(type, streamingEndpoint) {
                if(checkStreamingEndpointFragmentsLoaded(type, streamingEndpoint)) {
                    insert($scope.insertableFragments[type][streamingEndpoint.id].datasetRef);
                }
            }

            $scope.$watchGroup(['recipe.inputs', 'recipe.outputs'], function() {
                DataikuAPI.flow.recipes.getInsertableFragments($stateParams.projectKey, $scope.recipe)
                    .success(function(fragments) {
                        $scope.insertableFragments = fragments;
                    }).error(setErrorInScope.bind($scope));
            }, true);

            $scope.rightUIState = { "activeTab" : "datasets"};

            $scope.resolveCodeForPreviewFunc = function (sample) {
            	var inputs = RecipesUtils.getFlatInputsList($scope.recipe);
                var outputs = RecipesUtils.getFlatOutputsList($scope.recipe);

            	var resolveCode = sample.code;
                if (typeof(resolveCode)!=='undefined' &&  inputs.length>0) {
                	var inputRegexp = new RegExp("__FIRST_INPUT__",'g');
                	resolveCode = resolveCode.replace(inputRegexp, inputs[0].ref);
                }
                if (typeof(resolveCode)!=='undefined' && outputs.length>0) {
                	var outputRegexp = new RegExp("__FIRST_OUTPUT__",'g');
                	resolveCode = resolveCode.replace(outputRegexp, outputs[0].ref);
                }
                return resolveCode;
            }

            $scope.resolveCodeForInsertionFunc = function (sample) {
                var code = "\n\n"
		        code += $scope.resolveCodeForPreviewFunc(sample);
                return code;
            }
        }
    }
});


app.directive("codeBasedRecipeAutofill", function() {
    return {
        controller : function($scope, DataikuAPI) {
            // Marks whether the user has started editing
            // the script or not.
            //
            // We allow ourselves to auto-fill the script
            // as long as the user has not started writing anything.
            var no_user_edit = false;
            // flag marking that the current change is coming from auto change.
            var auto_change = false;

            var autofill = function(){
                auto_change = true;
                if ($scope.autofillCode && $scope.computablesMap) $scope.autofillCode();
                window.setTimeout(function() {
                	// there is a nice race condition where the snippet directive links while
                	// this function is run in a digestion cycle, leading to the code mirror
                	// pane not refreshing after the autofill code is set on script.data.
                	// Apparently it works on firefox but not on chrome
                	if ( $scope.cm != null && $scope.script.data != null && $scope.cm.getValue() != $scope.script.data) {
                		// So we force code mirror to update its contents.
                        $scope.cm.setValue($scope.script.data);
                	}
                    auto_change = false;
                }, 0);
            }
            if ($scope.script.data==undefined || !$scope.script.data.length) {
                no_user_edit = true;
                autofill();
            }

            $scope.$watch("script.data", function(nv, ov) {
                if (!auto_change) {
                    no_user_edit = false;
                }
            });

            var onRecipeIoOrComputableChange = function() {
                if (no_user_edit) {
                    var typing = 0;
                    auto_change = true;
                    autofill();
                }
            };
            $scope.$on('computablesMapChanged', onRecipeIoOrComputableChange);
            $scope.$watch("[ recipe.inputs, recipe.outputs ]", onRecipeIoOrComputableChange, true);

        }
    }
});

app.controller("RecipeFromNotebookCreationController", function($scope, $stateParams, StateUtils, DataikuAPI, WT1, Fn, DatasetsService, RecipeComputablesService) {
    $scope.setComputablesMap = function(map) {
        $scope.computablesMap = map;
        $scope.$broadcast('computablesMapChanged');
    };

    $scope.recipeWT1Event = function(type, params) {
        WT1.event(type, params || {});
    };

    $scope.createRecipe = function() {
        $('iframe#jupyter-iframe')[0].contentWindow.IPython.notebook.save_notebook().then(function() {
            WT1.event("notebook-ipython-create-recipe");
            $scope.creatingRecipe = true;
            DataikuAPI.jupyterNotebooks.createRecipeFromNotebook($stateParams.projectKey, $scope.notebookName, $scope.recipe).success(function(data) {
                $scope.creatingRecipe = false;
                $scope.dismiss();
                StateUtils.go.recipe(data.id);
            }).error(function(a, b, c) {
                $scope.creatingRecipe = false;
                setErrorInScope.bind($scope)(a, b, c);
            });
        }).catch(setErrorInScope.bind($scope));
    };

    function init() {
        $scope.recipe = {
            projectKey: $stateParams.projectKey,
            type: $scope.newRecipeType,
            inputs: {},
            outputs: {},
            params: {}
        };

        if ($scope.analyzedDataset) {
            $scope.recipe.inputs.main = {
                items: [
                    {
                        ref: $scope.analyzedDataset,
                        deps: []
                    }
                ]
            };
        }

        RecipeComputablesService.getComputablesMap($scope.recipe, $scope).then(function(map){
            $scope.setComputablesMap(map);
        });
    }

    $scope.$watch("newRecipeType", Fn.doIfNv(init));

    addDatasetUniquenessCheck($scope, DataikuAPI, $stateParams.projectKey);
    fetchManagedDatasetConnections($scope, DataikuAPI);
    DatasetsService.updateProjectList($stateParams.projectKey);
});


app.controller("CodeBasedRecipeCreationController", function($scope, $stateParams, $state, $controller, Fn,
        DataikuAPI, WT1, RecipesUtils, RecipeDescService, DatasetsService, RecipeComputablesService, PartitionDeps, BigDataService) {

    $controller("_RecipeCreationControllerBase", {$scope:$scope});

    function init(){
        $scope.recipeName = {};
        $scope.script = "";
        $scope.recipe = {
            projectKey : $stateParams.projectKey,
            type: $scope.newRecipeType,
            inputs : {},
            outputs : {},
            params: {}
        };

        // recipePrefillKey is a handle (throught "BigDataService" :) ) to an initial script for the recipe (from notebook)
        if($scope.recipePrefillKey) {
            var prefill = BigDataService.fetch($scope.recipePrefillKey);

            if(prefill) {
                if(prefill.script) {
                    $scope.script = prefill.script;
                }
                if(prefill.input) {
                    prefill.input.forEach(function(x){
                        RecipesUtils.addInput($scope.recipe, "main", x);
                    })
                }
                if(prefill.output) {
                    prefill.output.forEach(function(x){
                        RecipesUtils.addOutput($scope.recipe, "main", x);
                    });
                }
            }
        }

        if ($scope.preselectedInputs) {
            if (angular.isArray($scope.preselectedInputs)) {
                $scope.preselectedInputs.forEach(function(input){
                    RecipesUtils.addInput($scope.recipe, "main", input);
                })
            } else {
                RecipesUtils.addInput($scope.recipe, "main", $scope.preselectedInputs);
            }
        }

        RecipeComputablesService.getComputablesMap($scope.recipe, $scope).then(function(map){
            $scope.setComputablesMap(map);
        });
    }

    // we will autofill the name if needed
    $scope.$watch("[recipe.inputs, recipe.outputs]", function(nv, ov) {
        if (nv && $scope.recipe && $scope.recipe.inputs && $scope.recipe.outputs){
            if ($scope.preselectedInputs && $scope.recipe.inputs.main.items.map(it => it.ref)[0] != $scope.preselectedInputs[0]) {
                $scope.zone = null;
            }
            var outputs = RecipesUtils.getFlatOutputsList($scope.recipe);
            if (outputs.length && RecipeDescService.hasValidRequiredRoles($scope.recipe)) {
                $scope.recipeName.name = "compute_" + outputs[0].ref;
            } else {
            	// erase the name to make the modal not ready to close
                $scope.recipeName.name = null;
            }
        }
    }, true);


    $scope.$watch("newRecipeType", Fn.doIfNv(init));

    addDatasetUniquenessCheck($scope, DataikuAPI, $stateParams.projectKey);
    fetchManagedDatasetConnections($scope, DataikuAPI);
    DatasetsService.updateProjectList($stateParams.projectKey);

});


app.controller("_CodeBasedRecipeControllerBase", function($scope, $stateParams) {
    $scope.enableAutoFixup();
});


app.controller('DummyRecipeController', function ($scope, TopNav, StateUtils) {
    TopNav.setTab(StateUtils.defaultTab("settings"));
    $scope.hooks.recipeIsDirty = function() {
        return false;
    };
});


app.controller('MeaningPopoverController', function ($scope, DataikuAPI, UDM_TYPES) {
    $scope.types = UDM_TYPES;
    $scope.user_defined = !!$scope.col.meaning;

    $scope.getPlacement = function(tip, el) {
        var offset = $(el).offset(),
               top = offset.top,
               height = $(document).outerHeight();
           return 0.5 * height - top > 0 ? 'bottom' : 'top';
    }

    if (!$scope.appConfig.meanings.categories
        .filter(function(cat) { return cat.label === "User-defined"; })[0]
        .meanings.filter(function(mapping) { return mapping.id === $scope.col.meaning; }).length) {
        $scope.hide = true;
        return;
    };

    DataikuAPI.meanings.getUDM($scope.col.meaning).success(function(udm) {
        $scope.selected = {item: {_source: udm}};
        $scope.selected.item._source.udm_type = udm.type;
    });
});


}());


function cleanupVariable(s) {
    var result = s.replace(/^([A-Z]+)/g, function($1){return $1.toLowerCase();});
    return result.replace(/[^A-Za-z0-9_]/g, "_");
}

(function() {
'use strict';

const app = angular.module('dataiku.recipes');

app.factory("CodeRecipeFillingHelper", function(RecipesUtils) {
    var svc = {
        getIOData: function($scope) {
            const inputItems = RecipesUtils.getInputsForRole($scope.recipe, "main");
            const inputDatasets  = inputItems.map(item => $scope.computablesMap[item.ref]).filter(x => x.type == "DATASET");
            const inputStreamingEndpoints  = inputItems.map(item => $scope.computablesMap[item.ref]).filter(x => x.type == "STREAMING_ENDPOINT");
            const outputItems = RecipesUtils.getOutputsForRole($scope.recipe, "main");
            const outputDatasets  = outputItems.map(item => $scope.computablesMap[item.ref]).filter(x => x.type == "DATASET");
            const outputStreamingEndpoints  = outputItems.map(item => $scope.computablesMap[item.ref]).filter(x => x.type == "STREAMING_ENDPOINT");

            return {
                inputItems: inputItems,
                inputDatasets: inputDatasets,
                inputStreamingEndpoints: inputStreamingEndpoints,
                outputItems: outputItems,
                outputDatasets: outputDatasets,
                outputStreamingEndpoints: outputStreamingEndpoints,
                isOneDatasetToOneDataset: (inputDatasets.length == 1 && outputDatasets.length == 1),
                isOneStreamingEndpointToOneDataset: (inputDatasets.length == 0 && inputStreamingEndpoints.length == 1 && outputDatasets.length == 1 && outputStreamingEndpoints.length == 0),
                isOneDatasetToOneStreamingEndpoint: (inputDatasets.length == 1 && inputStreamingEndpoints.length == 0 && outputDatasets.length == 0 && outputStreamingEndpoints.length == 1),
                isOneStreamingEndpointToOneStreamingEndpoint: (inputDatasets.length == 0 && inputStreamingEndpoints.length == 1 && outputDatasets.length == 0 && outputStreamingEndpoints.length == 1)
            }
        }
    }
    return svc;
})

app.controller("PythonRecipeController", function($scope, $rootScope, CodeBasedEditorUtils, CodeBasedValidationUtils, CodeBasedToPluginConverter, CodeMirrorSettingService, DataikuAPI, $q, TopNav, $state, $stateParams, RecipesUtils, RecipeRunJobService, CreateModalFromTemplate, Dialogs, WT1, $timeout, CodeRecipeFillingHelper) {
    $scope.enableAutoFixup();

    // Editor options
    $scope.identifierQuote = '"';
    $scope.editorOptions = CodeBasedEditorUtils.editorOptions('text/x-python', $scope, true);

    $scope.hooks.insertVariable = function(variableName, type) {
        $timeout(function() {
            if (type == "FLOW") {
                $scope.cm.replaceSelection('dataiku.dku_flow_variables["'+variableName+'"]', "end");
            } else {
                $scope.cm.replaceSelection('dataiku.get_custom_variables()["'+variableName+'"]', "end");
            }
        });
        $scope.cm.focus();
    }

    $scope.autofillCode = function() {
        $scope.script.data = "# -*- coding: utf-8 -*-\n";
        $scope.script.data += "import dataiku\n";
        $scope.script.data += "import pandas as pd, numpy as np\n";
        $scope.script.data += "from dataiku import pandasutils as pdu\n\n";

        const recipeIOData = CodeRecipeFillingHelper.getIOData($scope);

        if (recipeIOData.inputItems.length > 0) {
            $scope.script.data += "# Read recipe inputs\n";
        }
        var modelCount = 1;
        recipeIOData.inputItems.forEach(function(item) {
            var computable = $scope.computablesMap[item.ref];
            if (computable.type == 'DATASET' ) {
                $scope.script.data += cleanupVariable(item.ref) + " = dataiku.Dataset(\""+ item.ref +"\")\n";
                $scope.script.data += cleanupVariable(item.ref) + "_df = " + cleanupVariable(item.ref) + ".get_dataframe()\n"
            } else if (computable.type == 'MANAGED_FOLDER' ) {
                var name = computable.box.name;
                $scope.script.data += cleanupVariable(name) + " = dataiku.Folder(\""+ item.ref +"\")\n";
                $scope.script.data += cleanupVariable(name) + "_info = " + cleanupVariable(name) + ".get_info()\n"
            } else if (computable.type == 'SAVED_MODEL') {
                $scope.script.data += "# " + computable.label + "\n";
                $scope.script.data += "model_" + modelCount + " = dataiku.Model(\""+ item.ref +"\")\n";
                $scope.script.data += "pred_" + modelCount + " = model_" + modelCount + ".get_predictor()\n"
                modelCount++;
            } else if (computable.type == 'MODEL_EVALUATION_STORE') {
                var name = computable.mes.name;
                $scope.script.data += cleanupVariable(name) + " = dataiku.ModelEvaluationStore(\""+ item.ref +"\")\n";
                $scope.script.data += cleanupVariable(name) + "_info = " + cleanupVariable(name) + ".get_info()\n"
                modelCount++;
            }
        })
        $scope.script.data += "\n\n";

        if (recipeIOData.isOneDatasetToOneDataset) {
            // Special case for special people: make the code recipe work without actually writing code.
            $scope.script.data += "# Compute recipe outputs from inputs\n";
            $scope.script.data += "# TODO: Replace this part by your actual code that computes the output, as a Pandas dataframe\n";
            $scope.script.data += "# NB: DSS also supports other kinds of APIs for reading and writing data. Please see doc.\n\n";
            $scope.script.data +=  cleanupVariable(recipeIOData.outputDatasets[0].name) + "_df = " + cleanupVariable(recipeIOData.inputDatasets[0].name) + "_df # For this sample code, simply copy input to output\n";
        } else if (recipeIOData.outputDatasets.length > 0) {
            // Make it very very clear that you have to write code
            $scope.script.data += "# Compute recipe outputs\n";
            $scope.script.data += "# TODO: Write here your actual code that computes the outputs\n";
            $scope.script.data += "# NB: DSS supports several kinds of APIs for reading and writing data. Please see doc.\n\n";
            recipeIOData.outputItems.forEach(function(item) {
                var computable = $scope.computablesMap[item.ref];
                if (computable.type == 'DATASET') {
                    $scope.script.data += cleanupVariable(item.ref) + "_df = ... # Compute a Pandas dataframe to write into " + item.ref + "\n";
                }
            })
        }

        $scope.script.data += "\n\n";

        if (recipeIOData.outputItems.length > 0) {
            $scope.script.data += "# Write recipe outputs\n";
        }
        recipeIOData.outputItems.forEach(function(item) {
            var computable = $scope.computablesMap[item.ref];
            if (computable.type == 'DATASET') {
                $scope.script.data += cleanupVariable(item.ref) + " = dataiku.Dataset(\""+ item.ref +"\")\n";
                $scope.script.data += cleanupVariable(item.ref) + ".write_with_schema(" + cleanupVariable(item.ref) + "_df)\n"
            } else if (computable.type == 'MANAGED_FOLDER' ) {
                var name = computable.box.name;
                $scope.script.data += cleanupVariable(name) + " = dataiku.Folder(\""+ item.ref +"\")\n";
                $scope.script.data += cleanupVariable(name) + "_info = " + cleanupVariable(name) + ".get_info()\n"
            } else if (computable.type == 'STREAMING_ENDPOINT' ) {
                var name = computable.streamingEndpoint.id;
                $scope.script.data += cleanupVariable(name) + " = dataiku.StreamingEndpoint(\""+ item.ref +"\")\n";
                $scope.script.data += "with " + cleanupVariable(name) + ".get_writer() as " + cleanupVariable(name) + "_writer:\n";
                $scope.script.data += "    # " + cleanupVariable(name) + "_writer.write_row_dict(...)\n";
                $scope.script.data += "    # " + cleanupVariable(name) + "_writer.flush()\n";
            } else if (computable.type == 'MODEL_EVALUATION_STORE' ) {
                var name = computable.mes.name;
                $scope.script.data += cleanupVariable(name) + " = dataiku.ModelEvaluationStore(\""+ item.ref +"\")\n";
                $scope.script.data += cleanupVariable(name) + "_info = " + cleanupVariable(name) + ".get_info()\n"
            }
        });
    };

    $scope.hooks.transformToDevPlugin = function(){
        CodeBasedToPluginConverter.transformToDevPlugin($scope, DataikuAPI.flow.recipes.python.convertToCustom, "python");
    }

    $rootScope.$broadcast('transformToDevPlugin',$scope.hooks.transformToDevPlugin);

    $scope.validateRecipe = function() {
        return CodeBasedValidationUtils.getGenericCheckPromise($scope).then(function(valResult) {
            $scope.valCtx.validationResult = valResult;
            CodeBasedEditorUtils.updateLinter(valResult, $scope.linterFunction);
            return valResult;
        });
    };
    $scope.hooks.preRunValidate = $scope.validateRecipe;
});


app.controller("CPythonRecipeController", function($scope, $controller, CodeBasedEditorUtils, CodeBasedValidationUtils, CodeRecipeFillingHelper, CodeBasedToPluginConverter, DataikuAPI, $q, TopNav, $state, $stateParams, RecipesUtils, RecipeRunJobService, CreateModalFromTemplate, Dialogs, WT1, $timeout, Logger) {

    $controller("_ContinuousRecipeInitStartedJobBehavior", {$scope:$scope});

    $scope.enableAutoFixup();

    // Editor options
    $scope.identifierQuote = '"';
    $scope.editorOptions = CodeBasedEditorUtils.editorOptions('text/x-python', $scope, true);
    $scope.hooks.insertVariable = function(variableName, type) {
        $timeout(function() {
            if (type == "FLOW") {
                $scope.cm.replaceSelection('dataiku.dku_flow_variables["'+variableName+'"]', "end");
            } else {
                $scope.cm.replaceSelection('dataiku.get_custom_variables()["'+variableName+'"]', "end");
            }
        });
        $scope.cm.focus();
    }

    $scope.autofillCode = function(functionMode) {
        var suffix;
        if (functionMode !== undefined && $scope.script.data && $scope.script.data.length > 0) {
            let endOfUserCode = $scope.script.data.indexOf('# Previous code');
            if (endOfUserCode < 0) {
                suffix = '\n\n# Previous code \n"""\n' + $scope.script.data.trim() + '\n"""\n';
            } else {
                suffix = '\n\n# Previous code since code mode change\n"""\n' + $scope.script.data.substring(0, endOfUserCode).trim() + '\n"""\n';
            }
        } else {
            suffix = '';
        }        
        if (functionMode) {
            $scope.script.data = '';
        } else {
            $scope.script.data = "# -*- coding: utf-8 -*-\n";  // don't use in function mode
        }
        
        $scope.script.data += "import dataiku\n";
        $scope.script.data += "import pandas as pd, numpy as np, json\n";
        $scope.script.data += "from dataiku import pandasutils as pdu\n\n";

        const recipeIOData = CodeRecipeFillingHelper.getIOData($scope);

        if (recipeIOData.inputItems.length > 0) {
            $scope.script.data += "# Read recipe inputs\n";
        }
        var modelCount = 1;
        recipeIOData.inputItems.forEach(function(item) {
            var computable = $scope.computablesMap[item.ref];
            if (computable.type == 'DATASET' ) {
                $scope.script.data += cleanupVariable(item.ref) + " = dataiku.Dataset(\""+ item.ref +"\")\n";
                $scope.script.data += cleanupVariable(item.ref) + "_df = " + cleanupVariable(item.ref) + ".get_dataframe()\n"
            } else if (computable.type == 'STREAMING_ENDPOINT' ) {
                $scope.script.data += cleanupVariable(item.ref) + " = dataiku.StreamingEndpoint(\""+ item.ref +"\")\n";
                if (functionMode) {
                } else {
                    // setup the iterators
                    if (computable.streamingEndpoint.type == 'kafka') {
                        $scope.script.data += cleanupVariable(item.ref) + "_messages = "+ cleanupVariable(item.ref) +".get_message_iterator() # use as a generator, prefer get_native_kafka_consumer()\n";
                    } else if (computable.streamingEndpoint.type == 'sqs') {
                        $scope.script.data += cleanupVariable(item.ref) + "_messages = "+ cleanupVariable(item.ref) +".get_message_iterator() # use as a generator, prefer get_native_sqs_consumer()\n";
                    } else if (computable.streamingEndpoint.type == 'httpsse') {
                        $scope.script.data += cleanupVariable(item.ref) + "_messages = "+ cleanupVariable(item.ref) +".get_message_iterator() # use as a generator, prefer get_native_httpsse_consumer()\n";
                    }                
                }
            } else if (computable.type == 'MANAGED_FOLDER' ) {
                var name = computable.box.name;
                $scope.script.data += cleanupVariable(name) + " = dataiku.Folder(\""+ item.ref +"\")\n";
                $scope.script.data += cleanupVariable(name) + "_info = " + cleanupVariable(name) + ".get_info()\n"
            } else if (computable.type == 'SAVED_MODEL') {
                $scope.script.data += "# " + computable.label + "\n";
                $scope.script.data += "model_" + modelCount + " = dataiku.Model(\""+ item.ref +"\")\n";
                $scope.script.data += "pred_" + modelCount + " = model_" + modelCount + ".get_predictor()\n"
                modelCount++;
            }
        })
        $scope.script.data += "\n\n";

        if (functionMode) {
            if (recipeIOData.outputItems.length > 0) {
                $scope.script.data += "# Write recipe outputs\n";
                
                recipeIOData.outputItems.forEach(function(item) {
                    var computable = $scope.computablesMap[item.ref];
                    if (computable.type == 'DATASET') {
                        $scope.script.data += cleanupVariable(item.ref) + " = dataiku.Dataset(\""+ item.ref +"\")\n";
                    } else if (computable.type == 'STREAMING_ENDPOINT' ) {
                        $scope.script.data += cleanupVariable(item.ref) + " = dataiku.StreamingEndpoint(\""+ item.ref +"\")\n";
                    } else if (computable.type == 'MANAGED_FOLDER' ) {
                        var name = computable.box.name;
                        $scope.script.data += cleanupVariable(name) + " = dataiku.Folder(\""+ item.ref +"\")\n";
                        $scope.script.data += cleanupVariable(name) + "_info = " + cleanupVariable(name) + ".get_info()\n"
                    }
                });

                $scope.script.data += "def init():\n";
                $scope.script.data += "    # called once, before the main loop of calls to process() starts\n";
                
                let schemaSuggested = recipeIOData.inputStreamingEndpoints.length == 1 ? (cleanupVariable(recipeIOData.inputStreamingEndpoints[0].smartName) + '.get_schema()') : '...';
                recipeIOData.outputItems.forEach(function(item) {
                    var computable = $scope.computablesMap[item.ref];
                    if (computable.type == 'DATASET') {
                        $scope.script.data += "    " + cleanupVariable(item.ref) + ".write_schema(" + schemaSuggested + ") # construct the list of columns in the output dataset\n"
                    } else if (computable.type == 'STREAMING_ENDPOINT' ) {
                        $scope.script.data += "    " + cleanupVariable(item.ref) + ".set_schema(" + schemaSuggested + ") # construct the list of columns in the output streaming endpoint\n"
                    }
                });
            }
            $scope.script.data += "\n\n";
     
            // Make it very very clear that you have to write code
            $scope.script.data += "# Process input in batches\n";
            $scope.script.data += "def process(inputs, outputs):\n";
            $scope.script.data += "    # TODO: Write here your actual code that computes the outputs\n";
            recipeIOData.inputItems.forEach(function(item) {
                var computable = $scope.computablesMap[item.ref];
                if (computable.type == 'STREAMING_ENDPOINT' ) {
                    $scope.script.data += "    df_" + cleanupVariable(item.ref) + " = inputs.get(" + cleanupVariable(item.ref) + ")\n"
                }
            });
            let dataSuggested = recipeIOData.inputStreamingEndpoints.length == 1 && recipeIOData.inputDatasets.length == 0 ? ('df_' + cleanupVariable(recipeIOData.inputStreamingEndpoints[0].smartName)) : '...';
            recipeIOData.outputItems.forEach(function(item) {
                var computable = $scope.computablesMap[item.ref];
                if (computable.type == 'DATASET') {
                    $scope.script.data += "    outputs.set(" + cleanupVariable(item.ref) + ", " + dataSuggested + ")\n"
                } else if (computable.type == 'STREAMING_ENDPOINT' ) {
                    $scope.script.data += "    outputs.set(" + cleanupVariable(item.ref) + ", " + dataSuggested + ")\n"
                }
            });
        } else {
            // Make it very very clear that you have to write code
            $scope.script.data += "# Compute recipe outputs\n";
            $scope.script.data += "# TODO: Write here your actual code that computes the outputs\n";
            $scope.script.data += "# NB: DSS supports several kinds of APIs for reading and writing data. Please see doc.\n\n";
    
            if (recipeIOData.outputItems.length > 0) {
                $scope.script.data += "# Write recipe outputs\n";
            }
            if (recipeIOData.isOneDatasetToOneStreamingEndpoint) {
                // Special case for special people: make the code recipe work without actually writing code.
                let item = recipeIOData.outputItems[0];
                var computable = $scope.computablesMap[item.ref];
                let inputItem = recipeIOData.inputItems[0];
                $scope.script.data += cleanupVariable(item.ref) + " = dataiku.StreamingEndpoint(\""+ item.ref +"\")\n";
                $scope.script.data += cleanupVariable(item.ref) + ".set_schema(" + cleanupVariable(inputItem.ref) + ".read_schema()) # construct the list of columns in the output streaming endpoint\n"
                $scope.script.data += "with " + cleanupVariable(item.ref) + ".get_writer() as " + cleanupVariable(item.ref) + "_writer:\n";
                $scope.script.data += "    cnt = 0\n";
                $scope.script.data += "    for i, row in " + cleanupVariable(inputItem.ref) + "_df.iterrows(): # iterate over rows to write \n";
                $scope.script.data += "        " + cleanupVariable(item.ref) + "_writer.write_row_dict(row.to_dict())\n";
                $scope.script.data += "        cnt += 1\n";
                $scope.script.data += "        if cnt > 100:\n";
                $scope.script.data += "            cnt = 0\n";
                $scope.script.data += "            " + cleanupVariable(item.ref) + "_writer.flush()\n";
                $scope.script.data += "\n";
                $scope.script.data += "raise Exception('No more data to read')\n";
            } else if (recipeIOData.isOneStreamingEndpointToOneStreamingEndpoint) {
                // Special case for special people: make the code recipe work without actually writing code.
                let item = recipeIOData.outputItems[0];
                var computable = $scope.computablesMap[item.ref];
                let inputItem = recipeIOData.inputItems[0];
                $scope.script.data += cleanupVariable(item.ref) + " = dataiku.StreamingEndpoint(\""+ item.ref +"\")\n";
                $scope.script.data += cleanupVariable(item.ref) + ".set_schema(" + cleanupVariable(inputItem.ref) + ".get_schema()) # construct the list of columns in the output streaming endpoint\n"
                $scope.script.data += "with " + cleanupVariable(item.ref) + ".get_writer() as " + cleanupVariable(item.ref) + "_writer:\n";
                $scope.script.data += "    cnt = 0\n";
                $scope.script.data += "    for row in " + cleanupVariable(inputItem.ref) + "_messages: # iterate over rows to write \n";
                $scope.script.data += "        " + cleanupVariable(item.ref) + "_writer.write_row_dict(row)\n";
                $scope.script.data += "        cnt += 1\n";
                $scope.script.data += "        if cnt > 100:\n";
                $scope.script.data += "            cnt = 0\n";
                $scope.script.data += "            " + cleanupVariable(item.ref) + "_writer.flush()\n";
            } else if (recipeIOData.isOneStreamingEndpointToOneDataset) {
                // Special case for special people: make the code recipe work without actually writing code.
                let item = recipeIOData.outputItems[0];
                var computable = $scope.computablesMap[item.ref];
                let inputItem = recipeIOData.inputItems[0];
                $scope.script.data += cleanupVariable(item.ref) + " = dataiku.Dataset(\""+ item.ref +"\")\n";
                $scope.script.data += cleanupVariable(item.ref) + ".write_schema(" + cleanupVariable(inputItem.ref) + ".get_schema()) # construct the list of columns in the output dataset\n"
                $scope.script.data += "with " + cleanupVariable(item.ref) + ".get_continuous_writer('" + $stateParams.recipeName + "') as " + cleanupVariable(item.ref) + "_writer:\n";
                $scope.script.data += "    cnt = 0\n";
                $scope.script.data += "    for row in " + cleanupVariable(inputItem.ref) + "_messages: # iterate over rows to write \n";
                $scope.script.data += "        " + cleanupVariable(item.ref) + "_writer.write_row_dict(row)\n";
                $scope.script.data += "        cnt += 1\n";
                $scope.script.data += "        if cnt > 100:\n";
                $scope.script.data += "            cnt = 0\n";
                $scope.script.data += "            " + cleanupVariable(item.ref) + "_writer.checkpoint(str(cnt))\n";
            } else {
                recipeIOData.outputItems.forEach(function(item) {
                    var computable = $scope.computablesMap[item.ref];
                    if (computable.type == 'DATASET') {
                        $scope.script.data += cleanupVariable(item.ref) + " = dataiku.Dataset(\""+ item.ref +"\")\n";
                        $scope.script.data += cleanupVariable(item.ref) + ".write_schema(...) # construct the list of columns in the output dataset\n"
                        $scope.script.data += "with " + cleanupVariable(item.ref) + ".get_continuous_writer() as " + cleanupVariable(item.ref) + "_writer:\n"
                        $scope.script.data += "    " + cleanupVariable(item.ref) + "_writer.write_row_dict(...) # generate data to write \n";
                    } else if (computable.type == 'STREAMING_ENDPOINT' ) {
                        $scope.script.data += cleanupVariable(item.ref) + " = dataiku.StreamingEndpoint(\""+ item.ref +"\")\n";
                        $scope.script.data += cleanupVariable(item.ref) + ".set_schema(...) # construct the list of columns in the output streaming endpoint\n"
                        $scope.script.data += "with " + cleanupVariable(item.ref) + ".get_writer() as " + cleanupVariable(item.ref) + "_writer:\n";
                        $scope.script.data += "    " + cleanupVariable(item.ref) + "_writer.write_row_dict(...) # generate data to write \n";
                    } else if (computable.type == 'MANAGED_FOLDER' ) {
                        var name = computable.box.name;
                        $scope.script.data += cleanupVariable(name) + " = dataiku.Folder(\""+ item.ref +"\")\n";
                        $scope.script.data += cleanupVariable(name) + "_info = " + cleanupVariable(name) + ".get_info()\n"
                    }
                });
            }
        }
        
        $scope.script.data += "\n\n";
        $scope.script.data += suffix;
    };

    $scope.transformToDevPlugin = function(){
        CodeBasedToPluginConverter.transformToDevPlugin($scope, DataikuAPI.flow.recipes.python.convertToCustom, "python");
    }

    $scope.validateRecipe = function() {
        return CodeBasedValidationUtils.getGenericCheckPromise($scope).then(function(valResult) {
            $scope.valCtx.validationResult = valResult;
            CodeBasedEditorUtils.updateLinter(valResult, $scope.linterFunction);
            return valResult;
        });
    };
    $scope.hooks.preRunValidate = $scope.validateRecipe;
    
    $scope.selectCodeMode = function() {
        var items = [
            { mode: 'FREE_FORM', title: 'Free-Form', desc: "The code is a script." },
            { mode: 'FUNCTION', title: 'Function', desc: "The code defines a process function, taking in batches of input rows and producing batches of output rows." }
        ];
        Dialogs.select($scope, 'Code mode', 'Select the mode for the code:', items,
                items[$scope.recipe.params.codeMode === 'FUNCTION' ? 1 : 0]
        ).then(function(item) {
            $scope.recipe.params.codeMode = item.mode;
        }, function() {});
    };
    
    $scope.$watch('recipe.params.codeMode', function(mode, previous) {
        Logger.info("Transform: from " + previous + " to " + mode);
        if (mode === 'FUNCTION' && previous === 'FREE_FORM') {
            $scope.autofillCode(true);
            $timeout($scope.cm.setValue.bind($scope.cm, $scope.script.data), 0);
        } else if (mode === 'FREE_FORM' && previous === 'FUNCTION') {
            $scope.autofillCode(false);
            $timeout($scope.cm.setValue.bind($scope.cm, $scope.script.data), 0);
        }
    });
    
    
    let setupFeedParams = function() {
        if (!$scope.recipe) return;
        if ($scope.recipe.params.codeMode != 'FUNCTION') return;
        if (!$scope.computablesMap) return;
        
        // add outputs not yet listed in the production settings
        $scope.recipe.outputs['main'].items.forEach(function(output) {
            var production = $scope.recipe.params.feedParams.outputs.filter(function(o) {return o.ref == output.ref})[0];
            if (production == null) {
                production = {ref:output.ref, checkpointingType:'none', checkpointingParams:{}}
                let computable = $scope.computablesMap[output.ref];
                if (computable != null && computable.type == 'DATASET') {
                    production['checkpointingType'] = 'dataset'; // that's the only guaranteed option
                    production['checkpointingParams']['checkpointInterval'] = 10000
                    production['checkpointingParams']['checkpointMaxRows'] = 100000
                }
                $scope.recipe.params.feedParams.outputs.push(production);
            }
        });
        
        // add inputs not yet listed in the consumptions settings
        if ($scope.recipe.inputs.main && $scope.recipe.inputs['main'].items) {
            $scope.recipe.inputs['main'].items.forEach(function(input) {
                var consumption = $scope.recipe.params.feedParams.inputs.filter(function(i) {return i.ref == input.ref})[0];
                if (consumption == null) {
                    consumption = {ref:input.ref, withWindow:false}
                    let computable = $scope.computablesMap[input.ref];
                    if (computable != null && computable.type == 'STREAMING_ENDPOINT') {
                        $scope.recipe.params.feedParams.inputs.push(consumption);
                    }
                }
            });
        }
        
        // remove production settings not listed in the outputs
        $scope.recipe.params.feedParams.outputs = $scope.recipe.params.feedParams.outputs.filter(function(production) {
            let output = $scope.recipe.outputs['main'].items.filter(function(o) {return o.ref == production.ref;})[0];
            return output != null;
        });
        
        // remove consumption settings not listed in the inputs
        $scope.recipe.params.feedParams.inputs = $scope.recipe.params.feedParams.inputs.filter(function(consumption) {
            let input = $scope.recipe.inputs['main'].items.filter(function(i) {return i.ref == consumption.ref;})[0];
            return input != null;
        });
    };
    setupFeedParams();
    
    $scope.$watch("recipe.params.codeMode", setupFeedParams, false);
    $scope.$watch("recipe.inputs.main.items", setupFeedParams, true);
    $scope.$watch("recipe.outputs.main.items", setupFeedParams, true);
    $scope.$watch("computablesMap", setupFeedParams, false);
});

app.directive("feedProductionSettings", function() {
    return {
        scope: {
            computablesMap: '=',
            production: '='
        },
        templateUrl: "/templates/recipes/fragments/feed-production-settings.html",
        link: function($scope, element, attrs) {
            let init = function() {
                $scope.possibleTypes = [];
                $scope.possibleTypesDescriptions = [];
                if (!$scope.computablesMap) return;
                if (!$scope.production) return;
                $scope.computable = $scope.computablesMap[$scope.production.ref];
                if ($scope.computable.type == 'DATASET') {
                    $scope.possibleTypes.push({type:'dataset', label:'In the dataset'});
                    $scope.possibleTypesDescriptions.push('Store checkpoint alongside the data if possible: as a hidden file for file-based dataset, in a dedicated table for sql dataset');
                } else if ($scope.computable.type == 'STREAMING_ENDPOINT') {
                    $scope.possibleTypes.push({type:'none', label:"Don't store checkpoints"});
                    $scope.possibleTypesDescriptions.push('');
                    if ($scope.computable.streamingEndpoint.type == 'kafka') {
                        $scope.possibleTypes.push({type:'kafka_transaction', label:'In a Kafka topic'});
                        $scope.possibleTypesDescriptions.push('Store checkpoints in a second topic');
                    }
                }
                $scope.possibleTypes.push({type:'file', label:'In a file'});
                $scope.possibleTypesDescriptions.push('Store checkpoints in a file on the local filesystem');
            };
            init();
            $scope.$watch('computablesMap', init, false);
            $scope.$watch('production', init, false);
            
            let fixupCheckpointingParams = function() {
                if (['dataset', 'file'].indexOf($scope.production.checkpointingType) >= 0) {
                    $scope.production.checkpointingParams['checkpointInterval'] = $scope.production.checkpointingParams['checkpointInterval'] || 10000;
                    $scope.production.checkpointingParams['checkpointMaxRows'] = $scope.production.checkpointingParams['checkpointMaxRows'] || 100000;
                }
                if (['kafka_transaction'].indexOf($scope.production.checkpointingType) >= 0) {
                    $scope.production.checkpointingParams['checkpointInterval'] = $scope.production.checkpointingParams['checkpointInterval'] || 100;
                }
            };
            $scope.$watch('production.checkpointingType', fixupCheckpointingParams)
        }
    };
});

app.directive("feedConsumptionSettings", function() {
    return {
        scope: {
            computablesMap: '=',
            consumption: '='
        },
        templateUrl: "/templates/recipes/fragments/feed-consumption-settings.html",
        link: function($scope, element, attrs) {
            let init = function() {
                if (!$scope.computablesMap) return;
                if (!$scope.consumption) return;
                $scope.computable = $scope.computablesMap[$scope.consumption.ref];
            };
            init();
            $scope.$watch('computablesMap', init, false);
            $scope.$watch('consumption', init, false);
            
            $scope.canWindow = function() {
                return $scope.computable && $scope.computable.type == 'STREAMING_ENDPOINT' && $scope.computable.streamingEndpoint.type.toLowerCase() == 'kafka';
            };
        }
    };
});

app.controller("KsqlRecipeController", function($scope,  $controller, CodeBasedEditorUtils, CodeBasedValidationUtils, CodeRecipeFillingHelper, CodeBasedToPluginConverter, ComputableSchemaRecipeSave, DataikuAPI, $q, TopNav, $state, $stateParams, RecipesUtils, RecipeRunJobService, CreateModalFromTemplate, Dialogs, WT1, $timeout) {
    
    $controller("_ContinuousRecipeInitStartedJobBehavior", {$scope:$scope});

    $scope.enableAutoFixup();

    // Editor options
    $scope.identifierQuote = '`';
    $scope.editorOptions = CodeBasedEditorUtils.editorOptions('text/x-sql', $scope, true);
    $scope.hooks.insertVariable = function(variableName, type) {
        $timeout(function() {
            if (type == "FLOW") {
                $scope.cm.replaceSelection('${"'+variableName+'"}', "end");
            } else {
                $scope.cm.replaceSelection('${"'+variableName+'"}', "end");
            }
        });
        $scope.cm.focus();
    }

    $scope.autofillCode = function() {
        $scope.script.data = "// code";
    };

    $scope.synchronizeInput = function(loc) {
        DataikuAPI.streamingEndpoints.syncKsql(loc.projectKey, loc.id, true).success(function(data) {
            $scope.validateRecipe();
        }).error(setErrorInScope.bind($scope));
    };

    $scope.validateRecipe = function() {
        var preValidate = new Date().getTime();

        return CodeBasedValidationUtils.getGenericCheckPromise($scope).then(function(valResult) {
            $scope.valCtx.validationResult = valResult;
            CodeBasedEditorUtils.updateLinter(valResult, $scope.linterFunction);
            
            $scope.recipeWT1Event("ksql-validate", {
                ok : !valResult.topLevelMessages.error,
                time : (new Date().getTime() - preValidate),
                schemaChange : (valResult.schemaResult ? (valResult.schemaResult.totalIncompatibilities > 0) : false),
                firstError : (valResult.topLevelMessages.messages.length ? valResult.topLevelMessages.messages[0].message : null)
            });

            return ComputableSchemaRecipeSave.handleSchemaUpdateWithPrecomputed($scope, valResult.schemaResult).then(function(changeResult){
                if (changeResult.changed) {
                    // Validate again
                    return $scope.validateRecipe();
                } else {
                    return valResult;
                }
            });
        });
    };
    
    $scope.hooks.preRunValidate = $scope.validateRecipe;
});


app.controller("JuliaRecipeController", function($scope, CodeBasedEditorUtils, CodeBasedValidationUtils, CodeBasedToPluginConverter, CodeMirrorSettingService, DataikuAPI, $q, TopNav, $state, $stateParams, RecipesUtils, RecipeRunJobService, CreateModalFromTemplate, Dialogs, WT1, $timeout, CodeRecipeFillingHelper) {
    $scope.enableAutoFixup();

    // Editor options
    $scope.identifierQuote = '"';
    $scope.editorOptions = CodeBasedEditorUtils.editorOptions('text/x-julia', $scope);
    $scope.hooks.insertVariable = function(variableName, type) {
        $timeout(function() {
            var fn = (type == "FLOW" ? "get_flow_variable" : "get_custom_variable");
            $scope.cm.replaceSelection("Dataiku." + fn + '("'+variableName+'")', "end");
        });
        $scope.cm.focus();
    }

    $scope.autofillCode = function() {
        $scope.script.data = "using Dataiku\n";
        $scope.script.data += "import Dataiku: get_dataframe\n\n";

        const recipeIOData = CodeRecipeFillingHelper.getIOData($scope);

        if (recipeIOData.inputItems.length > 0) {
            $scope.script.data += "# Read recipe inputs\n";
        }
        var modelCount = 1;
        recipeIOData.inputItems.forEach(function(item) {
            var computable = $scope.computablesMap[item.ref];
            if (computable.type == 'DATASET' ) {
                $scope.script.data += cleanupVariable(item.ref) + "_df = get_dataframe(dataset\""+ item.ref +"\")\n"
            } else if (computable.type == 'MANAGED_FOLDER' ) {
                var name = computable.box.name;
                $scope.script.data += cleanupVariable(name) + "_info = Dataiku.get_settings(folder\"" + item.ref + "\")\n"
            } else if (computable.type == 'SAVED_MODEL') {
                $scope.script.data += "# " + computable.label + "\n";
                $scope.script.data += "pred_" + modelCount + " = Dataiku.get_active_version(model\"" + item.ref + "\")\n"
                modelCount++;
            }
        })
        $scope.script.data += "\n\n";

        if (recipeIOData.isOneDatasetToOneDataset) {
            // Special case for special people: make the code recipe work without actually writing code.
            $scope.script.data += "# Compute recipe outputs from inputs\n";
            $scope.script.data += "# TODO: Replace this part by your actual code that computes the output, as a Julia DataFrame\n\n";
            $scope.script.data +=  cleanupVariable(recipeIOData.outputDatasets[0].name) + "_df = " + cleanupVariable(recipeIOData.inputDatasets[0].name) + "_df # For this sample code, simply copy input to output\n";
        } else if (recipeIOData.outputDatasets.length > 0) {
            // Make it very very clear that you have to write code
            $scope.script.data += "# Compute recipe outputs\n";
            $scope.script.data += "# TODO: Write here your actual code that computes the outputs\n\n";
            recipeIOData.outputItems.forEach(function(item) {
                var computable = $scope.computablesMap[item.ref];
                if (computable.type == 'DATASET') {
                    $scope.script.data += cleanupVariable(item.ref) + "_df = ... # Compute a Julia DataFrame to write into " + item.ref + "\n";
                }
            })
        }

        $scope.script.data += "\n\n";

        if (recipeIOData.outputItems.length > 0) {
            $scope.script.data += "# Write recipe outputs\n";
        }
        recipeIOData.outputItems.forEach(function(item) {
            var computable = $scope.computablesMap[item.ref];
            if (computable.type == 'DATASET') {
                $scope.script.data += "Dataiku.write_with_schema(dataset\""+ item.ref +"\", " + cleanupVariable(item.ref) + "_df)\n"
            } else if (computable.type == 'MANAGED_FOLDER' ) {
                var name = computable.box.name;
                $scope.script.data += cleanupVariable(name) + "_info = Dataiku.get_settings(folder\""+ item.ref +"\")\n"
            }
        });

    };

    $scope.transformToDevPlugin = function() {
        CodeBasedToPluginConverter.transformToDevPlugin($scope, DataikuAPI.flow.recipes.julia.convertToCustom, "julia");
    };

    $scope.validateRecipe = function() {
        return CodeBasedValidationUtils.getGenericCheckPromise($scope).then(function(valResult) {
            $scope.valCtx.validationResult = valResult;
            CodeBasedEditorUtils.updateLinter(valResult, $scope.linterFunction);
            return valResult;
        });
    };
    $scope.hooks.preRunValidate = $scope.validateRecipe;
});

app.controller("RRecipeController", function($rootScope, $scope, DataikuAPI, CodeBasedValidationUtils, CodeBasedEditorUtils, CodeBasedToPluginConverter, CodeMirrorSettingService, $state, $stateParams, RecipesUtils, Dialogs, CreateModalFromTemplate, WT1, $q, RecipeRunJobService, $timeout, CodeRecipeFillingHelper) {
    $scope.enableAutoFixup();

    // Editor
    $scope.identifierQuote = '"';
    $scope.editorOptions = CodeBasedEditorUtils.editorOptions('text/x-rsrc', $scope);
    $scope.hooks.insertVariable = function(variableName, type) {
        $timeout(function() {
            var fn = (type == "FLOW" ? "dkuFlowVariable" : "dkuCustomVariable");
            $scope.cm.replaceSelection(fn + '("'+variableName+'")', "end");
        });
        $scope.cm.focus();
    }

    $scope.autofillCode = function() {
        $scope.script.data = "library(dataiku)\n\n";
        const recipeIOData = CodeRecipeFillingHelper.getIOData($scope);

        if (recipeIOData.inputItems.length > 0) {
            $scope.script.data += "# Recipe inputs\n";
        }
        recipeIOData.inputItems.forEach(function(item){
            var computable = $scope.computablesMap[item.ref];
            if (computable.type == 'DATASET' ) {
                $scope.script.data += cleanupVariable(item.ref) + " <- dkuReadDataset(\""+ item.ref +"\", samplingMethod=\"head\", nbRows=100000)\n";
            }
            if (computable.type == 'MANAGED_FOLDER') {
                var name = computable.box.name;
                $scope.script.data += cleanupVariable(name) + " <- dkuManagedFolderPath(\""+ item.ref +"\")\n";
            }
        });
        $scope.script.data += "\n";

        if (recipeIOData.isOneDatasetToOneDataset) {
            // Special case for special people: make the code recipe work without actually writing code.
            $scope.script.data += "# Compute recipe outputs from inputs\n";
            $scope.script.data += "# TODO: Replace this part by your actual code that computes the output, as a R dataframe or data table\n";
            $scope.script.data +=  cleanupVariable(recipeIOData.outputDatasets[0].name) + " <- " + cleanupVariable(recipeIOData.inputDatasets[0].name) + " # For this sample code, simply copy input to output\n";
        } else if (recipeIOData.outputDatasets.length > 0) {
            // Make it very very clear that you have to write code
            $scope.script.data += "# Compute recipe outputs\n";
            $scope.script.data += "# TODO: Write here your actual code that computes the outputs\n";
            recipeIOData.outputItems.forEach(function(item) {
                var computable = $scope.computablesMap[item.ref];
                if (computable.type == 'DATASET') {
                    $scope.script.data += cleanupVariable(item.ref) + " <- replace_me # Compute a data frame for the output to write into " + item.ref + "\n";
                }
            });
        }

        $scope.script.data += "\n\n";

        var outputDatasets = RecipesUtils.getOutputsForRole($scope.recipe, "main");
        if (recipeIOData.outputItems.length > 0) {
            $scope.script.data += "# Recipe outputs\n";
        }
        recipeIOData.outputItems.forEach(function(item){
            var computable = $scope.computablesMap[item.ref];
            if (computable.type == 'DATASET' ) {
                $scope.script.data +="dkuWriteDataset(" + cleanupVariable(item.ref) + ",\""+item.ref+"\")\n";
            }
            if (computable.type == 'MANAGED_FOLDER' ) {
                var name = computable.box.name;
                $scope.script.data += cleanupVariable(name) + " <- dkuManagedFolderPath(\""+ item.ref +"\")\n";
            }
        });
    };

    $scope.hooks.transformToDevPlugin = function(){
        CodeBasedToPluginConverter.transformToDevPlugin($scope, DataikuAPI.flow.recipes.r.convertToCustom, "r");
    }

    $rootScope.$broadcast('transformToDevPlugin',$scope.hooks.transformToDevPlugin);

    $scope.validateRecipe = function() {
        return CodeBasedValidationUtils.getGenericCheckPromise($scope).then(function(valResult) {
            $scope.valCtx.validationResult = valResult;
            CodeBasedEditorUtils.updateLinter(valResult, $scope.linterFunction);
            return valResult;
        });
    };
    $scope.hooks.preRunValidate = $scope.validateRecipe;
});

app.controller("ShellRecipeController", function($scope, DataikuAPI, $q, TopNav, $stateParams, RecipesUtils, RecipeRunJobService, CreateModalFromTemplate, Dialogs, $timeout, CodeBasedValidationUtils, CodeBasedEditorUtils, CodeBasedToPluginConverter) {
    $scope.enableAutoFixup();

    $scope.identifierQuote = "'";
    $scope.editorOptions = CodeBasedEditorUtils.editorOptions('text/x-sh', $scope, true);
    $scope.hooks.insertVariable = function(variableName, type) {
        $timeout(function() {
            var shellName = (type=='USER'?'DKU_CUSTOM_VARIABLES_':'') + variableName;
            var shellVariable = '$' + shellName;
            if (shellName.indexOf('.') >= 0) {
                // . in a variable name will cause sh and friends to stop parsing for a variable name, so
                // we use a trick to retrieve the value
                shellVariable = '$(printenv ' + shellName + ')';
            }
            $scope.cm.replaceSelection(shellVariable, "end");
        });
        $scope.cm.focus();
    }

    $scope.getInputOrOuputLabel = function(ref) {
        if ( ref == null || ref.length == 0 ) {
            return '';
        }
        if ( $scope.computablesMap == null ) {
            return '';
        }
        var computable = $scope.computablesMap[ref];
        return computable.label;
    };
    $scope.inputDatasets = [];
    $scope.outputDatasets = [];
    var onRecipeIoOrComputableChange = function() {
        if ( $scope.computablesMap == null ) {
            return;
        }
        $scope.inputDatasets = [];
        if ($scope.recipe.inputs && $scope.recipe.inputs['main'] && $scope.recipe.inputs['main'].items) {
            var found = null;
            $scope.recipe.inputs['main'].items.forEach(function(input) {
                if (input.ref == $scope.recipe.params.pipeIn) {
                    found = input;
                }
                if ( $scope.computablesMap[input.ref].dataset != null) {
                    $scope.inputDatasets.push(input);
                }
            });
            if (found == null) {
                // dataset piped in has been removed, clear the pipe in
                $scope.recipe.params.pipeIn = null;
            }
        }

        $scope.outputDatasets = [];
        if ($scope.recipe.outputs && $scope.recipe.outputs['main'] && $scope.recipe.outputs['main'].items) {
            var found = null;
            $scope.recipe.outputs['main'].items.forEach(function(output) {
                if (output.ref == $scope.recipe.params.pipeOut) {
                    found = output;
                }
                if ( $scope.computablesMap[output.ref].dataset != null) {
                    $scope.outputDatasets.push(output);
                }
            });
            if (found == null) {
                // dataset piped in has been removed, clear the pipe in
                $scope.recipe.params.pipeOut = null;
            }
        }
        $scope.validateRecipe(true);
    };
    $scope.$on('computablesMapChanged', onRecipeIoOrComputableChange);
    $scope.$watch("[recipe.inputs, recipe.outputs]", onRecipeIoOrComputableChange, true);

    $scope.validateRecipe = function() {
        return CodeBasedValidationUtils.getGenericCheckPromise($scope).then(function(valResult) {
            $scope.valCtx.validationResult = valResult;
            CodeBasedEditorUtils.updateLinter(valResult, $scope.linterFunction);
            $scope.recipeWT1Event("shell-recipe-validate", { ok : !valResult.topLevelMessages.error});
            return valResult;
        });
    }
    $scope.hooks.preRunValidate = $scope.validateRecipe;

    var superRecipeIsDirty = $scope.hooks.recipeIsDirty;
    $scope.hooks.recipeIsDirty = function() {
        // cleanup pipeIn and pipeOut in params, which can be null
        if ( $scope.recipe.params.pipeIn == null ) {
            delete $scope.recipe.params.pipeIn;
        }
        if ( $scope.recipe.params.pipeOut == null ) {
            delete $scope.recipe.params.pipeOut;
        }
        return superRecipeIsDirty();
    }
});


})();
(function() {
'use strict';

const app = angular.module('dataiku.recipes');


app.controller("PySparkRecipeController", function($rootScope, $scope, DataikuAPI, CodeBasedEditorUtils, CodeBasedToPluginConverter, CodeBasedValidationUtils, $q, WT1, $state, $stateParams, CreateModalFromTemplate, Dialogs, RecipesUtils, $timeout, CodeRecipeFillingHelper) {
    $scope.enableAutoFixup();
    if ($scope.script.data == null) $scope.script.data = "";

    // Editor settings
    $scope.identifierQuote = '"';
    $scope.editorOptions = CodeBasedEditorUtils.editorOptions('text/x-python', $scope, true);
    $scope.hooks.insertVariable = function(variableName, type) {
        $timeout(function() {
            $scope.cm.replaceSelection('"'+variableName+'"', "end");
        });
        $scope.cm.focus();
    }
    // conversion to custom
    $scope.hooks.transformToDevPlugin = function(){
        CodeBasedToPluginConverter.transformToDevPlugin($scope, DataikuAPI.flow.recipes.pyspark.convertToCustom, "pyspark");
    }

    $rootScope.$broadcast('transformToDevPlugin',$scope.hooks.transformToDevPlugin);

    // Validation: TODO

    // Autofill
    $scope.autofillCode = function() {
        $scope.script.data = "# -*- coding: utf-8 -*-\n";
        $scope.script.data += "import dataiku\n";
        $scope.script.data += "from dataiku import spark as dkuspark\n";
        $scope.script.data += "from pyspark import SparkContext\n";
        $scope.script.data += "from pyspark.sql import SQLContext\n\n";

        const sparkVersion = $scope.appConfig.sparkVersion || "1.X";
        if (sparkVersion.substring(0, 1) == "1") {
        	$scope.script.data += "sc = SparkContext()\n";
        } else {
        	$scope.script.data += "sc = SparkContext.getOrCreate()\n";
        }

        $scope.script.data += "sqlContext = SQLContext(sc)\n\n";

        const recipeIOData = CodeRecipeFillingHelper.getIOData($scope);

        if (recipeIOData.inputItems.length > 0) {
            $scope.script.data += "# Read recipe inputs\n";
        }
        recipeIOData.inputItems.forEach(function(item) {
            var computable = $scope.computablesMap[item.ref];
            if (computable.type == 'DATASET' ) {
                $scope.script.data += cleanupVariable(item.ref) + " = dataiku.Dataset(\""+ item.ref +"\")\n";
                $scope.script.data += cleanupVariable(item.ref) + "_df = dkuspark.get_dataframe(sqlContext, " + cleanupVariable(item.ref) + ")\n"
            }
            if (computable.type == 'MANAGED_FOLDER' ) {
                var name = computable.box.name;
                $scope.script.data += cleanupVariable(name) + " = dataiku.Folder(\""+ item.ref +"\")\n";
                $scope.script.data += cleanupVariable(name) + "_info = " + cleanupVariable(name) + ".get_info()\n"
            }
        });
        $scope.script.data += "\n";

        if (recipeIOData.isOneDatasetToOneDataset) {
            // Special case for special people: make the code recipe work without actually writing code.
            $scope.script.data += "# Compute recipe outputs from inputs\n";
            $scope.script.data += "# TODO: Replace this part by your actual code that computes the output, as a SparkSQL dataframe\n";
            $scope.script.data +=  cleanupVariable(recipeIOData.outputItems[0].ref) + "_df = " + cleanupVariable(recipeIOData.inputItems[0].ref) + "_df # For this sample code, simply copy input to output\n";
        } else if (recipeIOData.outputDatasets.length > 0) {
            // Make it very very clear that you have to write code
            $scope.script.data += "# Compute recipe outputs\n";
            $scope.script.data += "# TODO: Write here your actual code that computes the outputs as SparkSQL dataframes\n";
            recipeIOData.outputItems.forEach(function(item) {
                var computable = $scope.computablesMap[item.ref];
                if (computable.type == 'DATASET') {
                    $scope.script.data += cleanupVariable(item.ref) + "_df = ... # Compute a SparkSQL dataframe to write into " + item.ref + "\n";
                }
            })
        }

        $scope.script.data += "\n";

        if (recipeIOData.outputItems.length > 0) {
            $scope.script.data += "# Write recipe outputs\n";
        }
        recipeIOData.outputItems.forEach(function(item) {
            var computable = $scope.computablesMap[item.ref];
            if (computable.type == 'DATASET' ) {
                $scope.script.data += cleanupVariable(item.ref) + " = dataiku.Dataset(\""+ item.ref +"\")\n";
                $scope.script.data += "dkuspark.write_with_schema(" + cleanupVariable(item.ref) + ", " + cleanupVariable(item.ref) + "_df)\n"
            }
            if (computable.type == 'MANAGED_FOLDER' ) {
                var name = computable.box.name;
                $scope.script.data += cleanupVariable(name) + " = dataiku.Folder(\""+ item.ref +"\")\n";
                $scope.script.data += cleanupVariable(name) + "_info = " + cleanupVariable(name) + ".get_info()\n"
            }
        });
    };

    $scope.validateRecipe = function() {
        return CodeBasedValidationUtils.getGenericCheckPromise($scope).then(function(valResult) {
            $scope.valCtx.validationResult = valResult;
            CodeBasedEditorUtils.updateLinter(valResult, $scope.linterFunction);
            return valResult;
        });
    };
});


app.controller("SparkRRecipeController", function($rootScope, $scope, $q, WT1, $stateParams, RecipesUtils, CodeBasedEditorUtils, CodeBasedValidationUtils, Logger, Dialogs, $timeout, CodeRecipeFillingHelper) {
    $scope.enableAutoFixup();

    // Edito options
    if ($scope.script.data == null) $scope.script.data = "";
    $scope.identifierQuote = '"';
    $scope.editorOptions = CodeBasedEditorUtils.editorOptions('text/x-rsrc', $scope);
    $scope.hooks.insertVariable = function(variableName, type) {
        $scope.cm.replaceSelection('"'+variableName+'"', "end");
        $scope.cm.focus();
    }

    $scope.autofillCode = function(mode, transform) {
        var previousCode = ""
        if (transform && $scope.script.data) {
            previousCode = $scope.script.data.split("\n").map(function(x) { return "# " + x }).join("\n")
        }

        const recipeIOData = CodeRecipeFillingHelper.getIOData($scope);

        if (mode == null) mode = "SPARKR";

        if (mode == "SPARKR") {
            $scope.script.data  = "library(SparkR)\nlibrary(dataiku)\n";

            var sparkVersion = $scope.appConfig.sparkVersion || "1.X";
            var sparkVersion = sparkVersion.substring(0, 1);

            if (sparkVersion == "1") {
                $scope.script.data += "library(dataiku.spark)\n\n";
                $scope.script.data += "sc <- sparkR.init()\n";
                $scope.script.data += "sqlContext <- sparkRSQL.init(sc)\n";
            } else {
                $scope.script.data += "library(dataiku.spark2)\n\n";
                $scope.script.data += "sc <- sparkR.session()\n";
            }

            if (recipeIOData.inputItems.length > 0) {
                $scope.script.data += "# Recipe inputs\n";
            }
            recipeIOData.inputItems.forEach(function(item){
                var computable = $scope.computablesMap[item.ref];
                if (computable.type == 'DATASET' ) {
                    if (sparkVersion == "1") {
                        $scope.script.data += cleanupVariable(item.ref) + " <- dkuSparkReadDataset(sqlContext, \""+ item.ref +"\")\n";
                    } else {
                        $scope.script.data += cleanupVariable(item.ref) + " <- dkuSparkReadDataset(\""+ item.ref +"\")\n";
                    }
                }
                if (computable.type == 'MANAGED_FOLDER' ) {
                    var name = computable.box.name;
                    $scope.script.data += cleanupVariable(name) + " <- dkuManagedFolderPath(\""+ item.ref +"\")\n";
                }
            });
            $scope.script.data += "\n";

            if (recipeIOData.isOneDatasetToOneDataset) {
                // Special case for special people: make the code recipe work without actually writing code.
                $scope.script.data += "# Compute recipe outputs from inputs\n";
                $scope.script.data += "# TODO: Replace this part by your actual code that computes the output, as Spark dataframe\n";
                $scope.script.data +=  cleanupVariable(recipeIOData.outputItems[0].ref) + " <- " + cleanupVariable(recipeIOData.inputItems[0].ref) + " # For this sample code, simply copy input to output\n";
            } else if (recipeIOData.outputDatasets.length > 0) {
                // Make it very very clear that you have to write code
                $scope.script.data += "# Compute recipe outputs\n";
                $scope.script.data += "# TODO: Write here your actual code that computes the outputs\n";
                recipeIOData.outputItems.forEach(function(item) {
                    var computable = $scope.computablesMap[item.ref];
                    if (computable.type == 'DATASET') {
                        $scope.script.data += cleanupVariable(item.ref) + " <- replace_me # Compute a data frame for the output to write into " + item.ref + "\n";
                    }
                });
            }

            $scope.script.data += "\n\n";

            if (recipeIOData.outputItems.length > 0) {
                $scope.script.data += "# Recipe outputs\n";
            }
            recipeIOData.outputItems.forEach(function(item){
                var computable = $scope.computablesMap[item.ref];
                if (computable.type == 'DATASET' ) {
                    $scope.script.data +="dkuSparkWriteDataset(" + cleanupVariable(item.ref) + ",\""+item.ref+"\")\n";
                }
                if (computable.type == 'MANAGED_FOLDER' ) {
                    var name = computable.box.name;
                    $scope.script.data += cleanupVariable(name) + " <- dkuManagedFolderPath(\""+ item.ref +"\")\n";
                }
            });
        } else {
            $scope.script.data  = "library(sparklyr)\nlibrary(dplyr)\nlibrary(dataiku.sparklyr)\n\n";
            $scope.script.data += "sc <- dku_spark_connect()\n\n"

            if (recipeIOData.inputItems.length > 0) {
                $scope.script.data += "# Recipe inputs\n";
            }
            recipeIOData.inputItems.forEach(function(item){
                var computable = $scope.computablesMap[item.ref];

                if (computable.type == 'DATASET' ) {
                    $scope.script.data += cleanupVariable(item.ref) + " <- spark_read_dku_dataset(sc, \""+ item.ref +"\", \""+cleanupVariable(item.ref) +"_tbl\")\n";
                }
                if (computable.type == 'MANAGED_FOLDER' ) {
                    var name = computable.box.name;
                    $scope.script.data += cleanupVariable(name) + " <- dkuManagedFolderPath(\""+ item.ref +"\")\n";
                }
            });
            $scope.script.data += "\n";

            if (recipeIOData.isOneDatasetToOneDataset) {
                // Special case for special people: make the code recipe work without actually writing code.
                $scope.script.data += "# Compute recipe outputs from inputs\n";
                $scope.script.data += "# TODO: Replace this part by your actual code that computes the output, as Sparklyr dataframe\n";
                $scope.script.data +=  cleanupVariable(recipeIOData.outputItems[0].ref) + " <- " + cleanupVariable(recipeIOData.inputItems[0].ref) + " # For this sample code, simply copy input to output\n";
            } else if (recipeIOData.outputDatasets.length > 0) {
                // Make it very very clear that you have to write code
                $scope.script.data += "# Compute recipe outputs\n";
                $scope.script.data += "# TODO: Write here your actual code that computes the outputs as Sparklyr dataframes\n";
                recipeIOData.outputItems.forEach(function(item) {
                    var computable = $scope.computablesMap[item.ref];
                    if (computable.type == 'DATASET') {
                        $scope.script.data += cleanupVariable(item.ref) + " <- replace_me # Compute a data frame for the output to write into " + item.ref + "\n";
                    }
                });
            }

            $scope.script.data += "\n";

            var outputDatasets = RecipesUtils.getOutputsForRole($scope.recipe, "main");
            if (recipeIOData.outputItems.length > 0) {
                $scope.script.data += "# Recipe outputs\n";
            }
            recipeIOData.outputItems.forEach(function(item){
                var computable = $scope.computablesMap[item.ref];
                if (computable.type == 'DATASET' ) {
                    $scope.script.data +="spark_write_dku_dataset(" + cleanupVariable(item.ref) + ",\""+item.ref+"\")\n";
                }
                if (computable.type == 'MANAGED_FOLDER' ) {
                    var name = computable.box.name;
                    $scope.script.data += cleanupVariable(name) + " <- dkuManagedFolderPath(\""+ item.ref +"\")\n";
                }
            });
        }

        $scope.script.data += "\n" + previousCode
    };

    $scope.selectRecipeMode = function() {
        var items = [
            { mode: 'SPARKR', title: 'SparkR', desc: "Use SparkR (native Spark) API" },
            { mode: 'SPARKLYR', title: 'Sparklyr', desc: "Use Sparklyr (dplyr) API"}
        ];
        Dialogs.select($scope, 'API', 'Select the API to use', items,
                items[$scope.recipe.params.recipeMode === 'SPARKLYR' ? 1 : 0]
        ).then(function(item) {
            $scope.recipe.params.recipeMode = item.mode;
        });
    };

    $scope.$watch('recipe.params.recipeMode', function(mode, previous) {
        Logger.info("Transform: from " + previous + " to " + mode);
        if (previous != null && mode != null && previous != mode) {
            $scope.autofillCode(mode, true);
            $timeout($scope.cm.setValue.bind($scope.cm, $scope.script.data), 0);
        }
    });

    $scope.validateRecipe = function() {
        return CodeBasedValidationUtils.getGenericCheckPromise($scope).then(function(valResult) {
            $scope.valCtx.validationResult = valResult;
            CodeBasedEditorUtils.updateLinter(valResult, $scope.linterFunction);
            return valResult;
        });
    };
});

app.controller("SparkSQLQueryRecipeController", function($rootScope, $scope, DataikuAPI, RecipeRunJobService, RecipesUtils, $q, WT1, $stateParams, $timeout, CodeBasedEditorUtils, CodeBasedValidationUtils, ComputableSchemaRecipeSave, Fn, CodeMirrorSettingService, SQLRecipeHelperService) {
    $scope.enableAutoFixup();

    // Editor
    $scope.noPrefixForeign = true;
    $scope.identifierQuote = '`';
    if ($scope.script.data == null) $scope.script.data = "";
    $scope.editorOptions = CodeBasedEditorUtils.editorOptions('text/x-sql2', $scope);
    $scope.editorOptions.extraKeys[CodeMirrorSettingService.getShortcuts()['AUTOCOMPLETE_SHORTCUT']] = function(cm) {
        return $scope.autocompleteSQL(cm, 'spark_sql_query-recipe');
    };

    $scope.anyPipelineTypeEnabled = function() {
        return $rootScope.projectSummary.sparkPipelinesEnabled;
    };

    $scope.autocompleteSQL = function(cm, type) {
        if (!$scope.tables) {   // cache recipe "tables" and fields
            $scope.tables = [].concat($scope.recipe.inputs.main.items, $scope.recipe.outputs.main.items)
                .map(function(t) { return {table: t.ref}; });
            $scope.fields = [].concat.apply([], $scope.tables.map(function(f) {
                return $scope.computablesMap[f.table].dataset.schema.columns
                    .map(function(c) { return {table: f.table, name: c.name}; });
            }));
            // deduplicate fields by name
            $scope.fields = $scope.fields.filter(function(f) { return !(f.name in this) && (this[f.name] = true); }, {});
        }
        CodeMirror.showHint(cm, function(editor) {
            return CodeMirror.sqlNotebookHint(editor, type+"-notebook", $scope.tables.map(Fn.prop("table")), $scope.fields);
        }, {completeSingle:false});
    };

    $scope.sqlFormat = SQLRecipeHelperService.sqlFormat.bind(this, $scope);

    $scope.hooks.insertVariable = function(variableName, type) {
        $timeout(function() {
            $scope.cm.replaceSelection('${'+variableName+'}', "end");
        });
        $scope.cm.focus();
    }

    $scope.autofillCode = function() {
        //Nothing to do: SparkSQL recipes are prefilled on creation
    };

    $scope.validateRecipe = function() {
        return CodeBasedValidationUtils.getGenericCheckPromise($scope).then(function(valResult) {
            $scope.valCtx.validationResult = valResult;
            CodeBasedEditorUtils.updateLinter(valResult, $scope.linterFunction);
            $scope.recipeWT1Event("sparksql-query-validate", { ok : !valResult.topLevelMessages.error});

            return ComputableSchemaRecipeSave.handleSchemaUpdateWithPrecomputed($scope, valResult.schemaResult).then(function(changeResult){
                if (changeResult.changed) {
                    // Validate again
                    return $scope.validateRecipe();
                } else {
                    return valResult;
                }
            });
        });
    };

    $scope.hooks.preRunValidate = $scope.validateRecipe;
});

app.controller("SparkScalaRecipeController", function($rootScope, $scope, DataikuAPI, $q, TopNav, $state, $stateParams, RecipesUtils, RecipeRunJobService, CreateModalFromTemplate,
        Logger, Dialogs, WT1, $timeout, CodeBasedEditorUtils, CodeBasedValidationUtils, CodeBasedToPluginConverter) {
    $scope.enableAutoFixup();

    // Editor
    $scope.identifierQuote = '"';
    $scope.editorOptions = CodeBasedEditorUtils.editorOptions('text/x-scala', $scope, true);
    $scope.hooks.insertVariable = function(variableName, type) {
        $timeout(function() {
            var dic = (type == "FLOW" ? "dkuContext.flowVariables":  "dkuContext.customVariables");
            $scope.cm.replaceSelection(dic + '("' + variableName + '")', "end");
        });
        $scope.cm.focus();
    }

    $scope.anyPipelineTypeEnabled = function() {
        return $rootScope.projectSummary.sparkPipelinesEnabled;
    };

    // conversion to custom
    $scope.hooks.transformToDevPlugin = function(){
        CodeBasedToPluginConverter.transformToDevPlugin($scope, DataikuAPI.flow.recipes.scala.convertToCustom, "spark_scala");
    }

    $rootScope.$broadcast('transformToDevPlugin',$scope.hooks.transformToDevPlugin);

    function getComputablesOfType(list, type) {
        return list.map(function(_) { return { ref: _.ref, computable: $scope.computablesMap[_.ref] }; })
                   .filter(function(_) { return _.computable.type === type; });
    }

    $scope.autofillCode = function(functionMode) {
        var suffix = $scope.script.data;
        if (functionMode) {
            $scope.script.data  = "// The code below is the body of a function with signature:\n";
            $scope.script.data += "// def transform(inputDatasets: Map[String, DataFrame],\n"
            $scope.script.data += "//   sparkContext: SparkContext, sqlContext: SQLContext, dkuContext: DataikuSparkContext\n";
            $scope.script.data += "// ): Map[String, DataFrame]\n\n";
            $scope.script.data += "import org.apache.spark.sql.functions._\n\n";
            suffix = '\n\n/** Previous code */\n' + suffix.replace(/^/gm, '// ');
        } else {
            $scope.script.data  = "import com.dataiku.dss.spark._\n";
            $scope.script.data += "import org.apache.spark.SparkContext\n";
            $scope.script.data += "import org.apache.spark.sql.SQLContext\n";
            $scope.script.data += "import org.apache.spark.sql.functions._\n\n";
            $scope.script.data += "val sparkConf    = DataikuSparkContext.buildSparkConf()\n";

            const sparkVersion = $scope.appConfig.sparkVersion || "1.X";
            if (sparkVersion.substring(0, 1) == "1") {
                $scope.script.data += "val sparkContext = new SparkContext(sparkConf)\n";
            } else {
                $scope.script.data += "val sparkContext = SparkContext.getOrCreate(sparkConf)\n";
            }
            $scope.script.data += "val sqlContext   = new SQLContext(sparkContext)\n";
            $scope.script.data += "val dkuContext   = DataikuSparkContext.getContext(sparkContext)\n\n";
            suffix = '';
        }

        var inputDatasets = RecipesUtils.getInputsForRole($scope.recipe, "main");
        if (inputDatasets.length > 0) {
            $scope.script.data += "// Recipe inputs\n";
        }
        getComputablesOfType(inputDatasets, 'MANAGED_FOLDER').forEach(function (_) {
            $scope.script.data += "val " + cleanupVariable(_.computable.box.name) +
                ' = dkuContext.getManagedFolderRoot("'+ _.computable.box.id +
                (_.computable.box.projectKey === $scope.recipe.projectKey ? '' : '", "' + _.computable.box.projectKey) +
                '")\n';
        });
        getComputablesOfType(inputDatasets, 'DATASET').forEach(function (_) {
            $scope.script.data += "val " + cleanupVariable(_.ref) + ' = ' +
                (functionMode ? 'inputDatasets(' : 'dkuContext.getDataFrame(sqlContext, ') +
                '"' + _.ref + '")\n';
        });
        $scope.script.data += "\n";

        var outputDatasets = RecipesUtils.getOutputsForRole($scope.recipe, "main");

        $scope.script.data += "// TODO: Write here your actual code that computes the outputs\n"
        getComputablesOfType(outputDatasets, 'DATASET').forEach(function (_) {
            $scope.script.data += "val " + cleanupVariable(_.ref) + ' = replace_me_by_your_code\n';
        });
        $scope.script.data += "\n";

        if (outputDatasets.length > 0) {
            $scope.script.data += "// Recipe outputs\n";
        }
        getComputablesOfType(outputDatasets, 'MANAGED_FOLDER').forEach(function (_) {
            $scope.script.data += "val " + cleanupVariable(_.computable.box.name) +
                ' = dkuContext.getManagedFolderRoot("'+ _.computable.box.id +
                (_.computable.box.projectKey === $scope.recipe.projectKey ? '' : '", "' + _.computable.box.projectKey) +
                '")\n';
        });
        if (functionMode) {
            $scope.script.data += "// The returned Map must contain (dataset name -> dataframe) pairs\n"
            $scope.script.data += "Map(" +
                getComputablesOfType(outputDatasets, 'DATASET').map(function (_) {
                    return '"' + _.ref + '" -> ' + cleanupVariable(_.ref);
                }).join(',\n    ') +
                ")\n";
        } else {
            getComputablesOfType(outputDatasets, 'DATASET').forEach(function (_) {
                $scope.script.data += 'dkuContext.save("' + _.ref + '", ' + cleanupVariable(_.ref) + ');\n';
            });
        }
        $scope.script.data += suffix;
    };

    $scope.selectCodeMode = function() {
        var items = [
            { mode: 'FREE_FORM', title: 'Free-Form', desc: "The code is a script. " +
                "It must instantiate its Spark context and SQL context, load its input datasets and save its output datasets." },
            { mode: 'FUNCTION', title: 'Function', desc: "The code is the body of a function. " +
                "It recieves pre-instantiated Spark context, SQL context, and input datasets and must return its output datasets. " +
                "This mode is compatible with Spark pipelines." }
        ];
        Dialogs.select($scope, 'Code mode', 'Select the mode for the code:', items,
                items[$scope.recipe.params.codeMode === 'FUNCTION' ? 1 : 0]
        ).then(function(item) {
            $scope.recipe.params.codeMode = item.mode;
        });
    };

    var transformCode = true;
    $scope.$watch('recipe.params.codeMode', function(mode, previous) {
        Logger.info("Transform: from " + previous + " to " + mode);
        if (transformCode && mode === 'FUNCTION' && previous === 'FREE_FORM') {
            transformCode = false; // only once
            $scope.autofillCode(true);
            $timeout($scope.cm.setValue.bind($scope.cm, $scope.script.data), 0);
        }
    });

    $scope.validateRecipe = function() {
        return CodeBasedValidationUtils.getGenericCheckPromise($scope).then(function(valResult) {
            $scope.valCtx.validationResult = valResult;
            CodeBasedEditorUtils.updateLinter(valResult, $scope.linterFunction);
            $scope.recipeWT1Event("spark-scala-validate", {
                ok : !valResult.topLevelMessages.error,
                firstError : (valResult.topLevelMessages.messages.length ? valResult.topLevelMessages.messages[0].message : null)
            });
            return valResult;
        });
    };
    $scope.hooks.preRunValidate = $scope.validateRecipe;
});


app.controller("StreamingSparkScalaRecipeController", function($scope, $controller, DataikuAPI, $q, TopNav, $state, $stateParams, RecipesUtils, RecipeRunJobService, CreateModalFromTemplate,
        Logger, Dialogs, WT1, $timeout, CodeBasedEditorUtils, CodeBasedValidationUtils, CodeBasedToPluginConverter) {
    $scope.enableAutoFixup();

    $controller("_ContinuousRecipeInitStartedJobBehavior", {$scope:$scope});

    // Editor
    $scope.identifierQuote = '"';
    $scope.editorOptions = CodeBasedEditorUtils.editorOptions('text/x-scala', $scope, true);
    $scope.hooks.insertVariable = function(variableName, type) {
        $timeout(function() {
            var dic = (type == "FLOW" ? "dkuContext.flowVariables":  "dkuContext.customVariables");
            $scope.cm.replaceSelection(dic + '("' + variableName + '")', "end");
        });
        $scope.cm.focus();
    }

    // conversion to custom
    $scope.transformToDevPlugin = function(){
        CodeBasedToPluginConverter.transformToDevPlugin($scope, DataikuAPI.flow.recipes.scala.convertToCustom, "spark_scala");
    }

    function getComputablesOfType(list, type) {
        return list.map(function(_) { return { ref: _.ref, computable: $scope.computablesMap[_.ref] }; })
                   .filter(function(_) { return _.computable.type === type; });
    }

    $scope.autofillCode = function(functionMode) {
        var suffix = $scope.script.data;
        if (functionMode) {
            $scope.script.data  = "// The code below is the body of a function with signature:\n";
            $scope.script.data += "// def transform(inputDatasets: Map[String, DataFrame],\n"
            $scope.script.data += "//   sparkContext: SparkContext, sqlContext: SQLContext, dkuContext: DataikuSparkContext\n";
            $scope.script.data += "// ): Map[String, DataFrame]\n\n";
            $scope.script.data += "import org.apache.spark.sql.functions._\n\n";
            suffix = '\n\n/** Previous code */\n' + suffix.replace(/^/gm, '// ');
        } else {
            $scope.script.data  = "import com.dataiku.dss.spark._\n";
            $scope.script.data += "import org.apache.spark.SparkContext\n";
            $scope.script.data += "import org.apache.spark.sql.SQLContext\n";
            $scope.script.data += "import org.apache.spark.sql.functions._\n\n";
            $scope.script.data += "val sparkConf    = DataikuSparkContext.buildSparkConf()\n";
            $scope.script.data += "val sparkContext = new SparkContext(sparkConf)\n";
            $scope.script.data += "val sqlContext   = new SQLContext(sparkContext)\n";
            $scope.script.data += "val dkuContext   = DataikuSparkContext.getContext(sparkContext)\n\n";
            suffix = '';
        }

        var inputDatasets = RecipesUtils.getInputsForRole($scope.recipe, "main");
        if (inputDatasets.length > 0) {
            $scope.script.data += "// Recipe inputs\n";
        }
        getComputablesOfType(inputDatasets, 'MANAGED_FOLDER').forEach(function (_) {
            $scope.script.data += "val " + cleanupVariable(_.computable.box.name) +
                ' = dkuContext.getManagedFolderRoot("'+ _.computable.box.id +
                (_.computable.box.projectKey === $scope.recipe.projectKey ? '' : '", "' + _.computable.box.projectKey) +
                '")\n';
        });
        getComputablesOfType(inputDatasets, 'DATASET').forEach(function (_) {
            $scope.script.data += "val " + cleanupVariable(_.ref) + ' = ' +
                (functionMode ? 'inputDatasets(' : 'dkuContext.getDataFrame(sqlContext, ') +
                '"' + _.ref + '")\n';
        });
        getComputablesOfType(inputDatasets, 'STREAMING_ENDPOINT').forEach(function (_) {
            $scope.script.data += "val " + cleanupVariable(_.ref) + ' = ' +
                (functionMode ? 'inputStreamingEndpoints(' : 'dkuContext.getStream(') + 
                '"' + _.ref + '")\n';
        });
        $scope.script.data += "\n";
        
        var outputDatasets = RecipesUtils.getOutputsForRole($scope.recipe, "main");

        var hasDataframeToOutput = false;
        if (inputDatasets.length == 1 && outputDatasets.length == 1) {
             if (getComputablesOfType(inputDatasets, 'DATASET').length == 1) {
                 hasDataframeToOutput = true;
             } else if (getComputablesOfType(inputDatasets, 'STREAMING_ENDPOINT').length == 1) {
                 hasDataframeToOutput = true;
             }
        }
        var dataframeToOutput = "someStreamingDataframe";
        if (hasDataframeToOutput) {
            $scope.script.data += "// replace by your code\n";
            $scope.script.data += "val df = " + cleanupVariable(inputDatasets[0].ref) + "\n";
            $scope.script.data += "\n";
            dataframeToOutput = "df";
        }

        if (outputDatasets.length > 0) {
            $scope.script.data += "// Recipe outputs\n";
        }
        getComputablesOfType(outputDatasets, 'MANAGED_FOLDER').forEach(function (_) {
            $scope.script.data += "val " + cleanupVariable(_.computable.box.name) +
                ' = dkuContext.getManagedFolderRoot("'+ _.computable.box.id +
                (_.computable.box.projectKey === $scope.recipe.projectKey ? '' : '", "' + _.computable.box.projectKey) +
                '")\n';
        });
        if (functionMode) {
            $scope.script.data += "// The returned Map must contain (dataset or streaming endpoint name -> dataframe) pairs\n"
            $scope.script.data += "Map(" +
                getComputablesOfType(outputDatasets, 'DATASET').concat(getComputablesOfType(outputDatasets, 'STREAMING_ENDPOINT')).map(function (_) {
                    return '"' + _.ref + '" -> ' + dataframeToOutput;
                }).join(',\n    ') +
                ")\n";
        } else {
            getComputablesOfType(outputDatasets, 'STREAMING_ENDPOINT').forEach(function (_) {
                $scope.script.data += "val " + cleanupVariable(_.computable.streamingEndpoint.id) +
                    ' = dkuContext.saveStreamingQueryToStreamingEndpoint("'+ _.computable.streamingEndpoint.id  + '", ' + dataframeToOutput + ')\n';
            });
            getComputablesOfType(outputDatasets, 'DATASET').forEach(function (_) {
                $scope.script.data += "val " + cleanupVariable(_.computable.dataset.name) +
                    ' = dkuContext.saveStreamingQueryToDataset("'+ _.ref + '", ' + dataframeToOutput + ')\n';
            });
        }
        $scope.script.data += suffix;
    };

    $scope.selectCodeMode = function() {
        var items = [
            { mode: 'FREE_FORM', title: 'Free-Form', desc: "The code is a script. " +
                "It must instantiate its Spark context and SQL context, load its input datasets and save its output datasets." },
            { mode: 'FUNCTION', title: 'Function', desc: "The code is the body of a function. " +
                "It recieves pre-instantiated Spark context, SQL context, and input datasets and must return its output datasets. " +
                "This mode is compatible with Spark pipelines." }
        ];
        Dialogs.select($scope, 'Code mode', 'Select the mode for the code:', items,
                items[$scope.recipe.params.codeMode === 'FUNCTION' ? 1 : 0]
        ).then(function(item) {
            $scope.recipe.params.codeMode = item.mode;
        });
    };

    var transformCode = true;
    $scope.$watch('recipe.params.codeMode', function(mode, previous) {
        Logger.info("Transform: from " + previous + " to " + mode);
        if (transformCode && mode === 'FUNCTION' && previous === 'FREE_FORM') {
            transformCode = false; // only once
            $scope.autofillCode(true);
            $timeout($scope.cm.setValue.bind($scope.cm, $scope.script.data), 0);
        }
    });

    $scope.validateRecipe = function() {
        return CodeBasedValidationUtils.getGenericCheckPromise($scope).then(function(valResult) {
            $scope.valCtx.validationResult = valResult;
            CodeBasedEditorUtils.updateLinter(valResult, $scope.linterFunction);
            $scope.recipeWT1Event("spark-scala-validate", {
                ok : !valResult.topLevelMessages.error,
                firstError : (valResult.topLevelMessages.messages.length ? valResult.topLevelMessages.messages[0].message : null)
            });
            return valResult;
        });
    };
    $scope.hooks.preRunValidate = $scope.validateRecipe;
});


})();
(function() {

'use strict';
var app = angular.module('dataiku.recipes');

app.controller("HiveRecipeController", function($scope, DataikuAPI,ActivityIndicator, $q, WT1, $stateParams, RecipeRunJobService, RecipesUtils, Fn, DKUtils, CreateModalFromTemplate, Dialogs, $state, $timeout,  CodeBasedEditorUtils, CodeBasedValidationUtils, ComputableSchemaRecipeSave, CodeMirrorSettingService) {
    // Editor
    $scope.identifierQuote = '`';
    $scope.editorOptions = CodeBasedEditorUtils.editorOptions('text/x-hivesql', $scope, true);
    $scope.editorOptions.extraKeys[CodeMirrorSettingService.getShortcuts()['AUTOCOMPLETE_SHORTCUT']] = function(cm) {
        $scope.recipeWT1Event("hive-script-autocomplete");
        CodeMirror.showHint(cm, function(cm){
            var relevantDatasetRefs = RecipesUtils.getFlatIOList($scope.recipe).map(Fn.prop("ref"));
            var fieldsToAutocomplete = CodeMirror.sqlFieldsAutocomplete(cm, relevantDatasetRefs.map(function(v) { return {table:v}; }));
            var sqlFields = [];
            if (fieldsToAutocomplete && fieldsToAutocomplete.length) {
                for(var i in relevantDatasetRefs) {
                    var tableName = relevantDatasetRefs[i];
                    var columns = $scope.computablesMap[tableName].dataset.schema.columns;
                    for(var j in columns) {
                        sqlFields.push({name:columns[j].name,table:tableName});
                    }
                }
            }
            CodeMirror.showHint(cm, function(cm){
                return CodeMirror.sqlNotebookHint(cm, "hive-recipe", relevantDatasetRefs,sqlFields);
            }, {completeSingle:false});
        });
    };

    $scope.hooks.insertVariable = function(variableName, type) {
        $timeout(function() {
            $scope.cm.replaceSelection(' ${'+variableName+'} ', "end");
        });
        $scope.cm.focus();
    }

    $scope.enableAutoFixup();

    $scope.validateRecipe = function() {
        var preValidate = new Date().getTime();

        return CodeBasedValidationUtils.getGenericCheckPromise($scope).then(function(valResult) {
            $scope.valCtx.validationResult = valResult;

            CodeBasedEditorUtils.updateLinter(valResult, $scope.linterFunction);
            $scope.recipeWT1Event("hive-validate", {
                ok : !valResult.topLevelMessages.error,
                time : (new Date().getTime() - preValidate),
                schemaChange : (valResult.schemaResult ? (valResult.schemaResult.totalIncompatibilities > 0) : false),
                firstError : (valResult.topLevelMessages.messages.length ? valResult.topLevelMessages.messages[0].message : null)
            });

            return ComputableSchemaRecipeSave.handleSchemaUpdateWithPrecomputed($scope, valResult.schemaResult).then(function(changeResult){
                if (changeResult.changed) {
                    // Validate again
                    return $scope.validateRecipe();
                } else {
                    return valResult;
                }
            });
        });
    };

    $scope.hooks.preRunValidate = $scope.validateRecipe;

    $scope.synchronizeInput = function(datasetLoc) {
        const datasets = [datasetLoc];
        DataikuAPI.datasets.synchronizeHiveMetastore(datasets).success(function () {
            $scope.validateRecipe();
        }).error(setErrorInScope.bind($scope));
    };

    $scope.autofillCode = function() {
        //Nothing to do: Hive recipes are prefilled on creation
    };

    $scope.doConversionToImpala = function(type, label) {
        Dialogs.confirm($scope, "Convert to Impala recipe", "Are you sure you want to convert "+
            "this to an Impala recipe? This operation is irreversible.").then(function() {
            $scope.recipe.type = "impala";
            $scope.saveRecipe().then(function() {
                $state.go('projects.project.recipes.recipe', {projectKey : $stateParams.projectKey, recipeName: $scope.recipe.name});
                DKUtils.reloadState();
            });
        });
    };

    $scope.convertToImpala = function() {
        DataikuAPI.flow.recipes.hive.checkImpalaConvertibility($stateParams.projectKey,
            $scope.hooks.getRecipeSerialized(),
            $scope.script.data, RecipeRunJobService.getTargetPartition($scope, $stateParams)).success(function(data) {
                var newScope = $scope.$new();
                newScope.executionPlan = data.executionPlan;
                newScope.query = data.sql;
                newScope.runsOnImpala = true;
                newScope.validatesOnImpala = data.runsOnImpala;
                newScope.impalaImpossibilityReason = data.impalaImpossibilityReason;
                newScope.convert = $scope.doConversionToImpala;
                newScope.uiState = {currentTab: 'query'};
                CreateModalFromTemplate("/templates/recipes/fragments/sql-modal.html", newScope, null, function(newScope){
                    newScope.engine = 'IMPALA';
                    newScope.isAlreadyRecipe = false; // this is the conversion modal, show the conversion button
                });
        }).error(setErrorInScope.bind($scope));
    };
});

app.controller("ImpalaRecipeController", function($scope, DataikuAPI,ActivityIndicator, $q, WT1, $stateParams, RecipeRunJobService, RecipesUtils, Fn, CreateModalFromTemplate, $state, Dialogs, MonoFuture, CodeBasedEditorUtils, CodeBasedValidationUtils, ComputableSchemaRecipeSave, SQLRecipeHelperService, $timeout, CodeMirrorSettingService) {
    $scope.enableAutoFixup();

    $scope.identifierQuote = '`';
    $scope.editorOptions = CodeBasedEditorUtils.editorOptions('text/x-hivesql', $scope, true);
    $scope.editorOptions.extraKeys[CodeMirrorSettingService.getShortcuts()['AUTOCOMPLETE_SHORTCUT']] = function(cm) {
        $scope.recipeWT1Event("impala-script-autocomplete");
        SQLRecipeHelperService.handleAutocompleteRequest($scope, cm, "impala-recipe")
    };

     $scope.hooks.insertVariable = function(variableName, type) {
        $timeout(function() {
            $scope.cm.replaceSelection(' ${'+variableName+'} ', "end");
        });
        $scope.cm.focus();
    }

    $scope.autofillCode = function() {
        //Nothing to do: Impala recipes are prefilled on creation
    };


    $scope.validateRecipe = function() {
        return CodeBasedValidationUtils.getGenericCheckPromise($scope).then(function(valResult) {
            $scope.valCtx.validationResult = valResult;

            CodeBasedEditorUtils.updateLinter(valResult, $scope.linterFunction);
            $scope.recipeWT1Event("impala-validate", {
                ok : !valResult.topLevelMessages.error,
                firstError : (valResult.topLevelMessages.messages.length ? valResult.topLevelMessages.messages[0].message : null)
            });

            return ComputableSchemaRecipeSave.handleSchemaUpdateWithPrecomputed($scope, valResult.schemaResult).then(function(changeResult){
                if (changeResult.changed) {
                    // Validate again
                    return $scope.validateRecipe();
                } else {
                    return valResult;
                }
            });
        });
    };

    $scope.hooks.preRunValidate = $scope.validateRecipe;

    $scope.showExecutionPlan = function() {
        $scope.hooks.resetScope();

        MonoFuture($scope).wrap(DataikuAPI.flow.recipes.impala.getExecutionPlan)($stateParams.projectKey,
                $scope.hooks.getRecipeSerialized(),
                $scope.script.data,
                RecipeRunJobService.getTargetPartition($scope)).success(function(data) {
                    $scope.future = null;
                    $scope.valCtx.validationResult = data.result.validationResult;
                    if (!data.result.validationResult.topLevelMessages.error) {
                        CreateModalFromTemplate("/templates/recipes/fragments/sql-modal.html", $scope, null, function(newScope){
                            newScope.executionPlan = data.result.executionPlan;
                            newScope.query = data.result.executionPlan.query;
                            newScope.uiState = {currentTab: 'plan'};
                            newScope.engine = 'IMPALA';
                            newScope.isAlreadyRecipe = true;
                        });
                    }
        }).update(function(data) {
            $scope.future = data;
        }).error(function(data) {
            $scope.future = null;
            if ( data.aborted ) {
                $scope.valCtx = {validationResult : {topLevelMessages : { messages : [{severity: "error", line: -1, message: "Query aborted"}]}}}
            } else {
                $scope.valCtx = {validationResult : {topLevelMessages : { messages : [{severity: "error", line: -1, message: "Query failed unexpectedly"}]}}}
            }
        });
    };

    $scope.run = function() {
        $scope.hooks.resetScope();

        MonoFuture($scope).wrap(DataikuAPI.flow.recipes.impala.run)($stateParams.projectKey,
                $scope.hooks.getRecipeSerialized(),
                $scope.script.data, RecipeRunJobService.getTargetPartition($scope)).success(function(data) {
                    $scope.future = null;
                    $scope.valCtx.validationResult = data.result;
                    $scope.recipeWT1Event("impala-query-run", {
                        ok : !data.result.topLevelMessages.error,
                        runOK : (data.result.runResult && data.result.runResult.success),
                        runRows : (data.result.runResult ? data.result.runResult.totalRows : -1)
                    });
                    if (data.result && data.result.runResult && data.result.runResult.success && data.result.runResult.rows){
                       CreateModalFromTemplate("/templates/recipes/sql/rows-preview-modal.html", $scope);
                    }
        }).update(function(data) {
            $scope.future = data;
        }).error(function(data) {
            $scope.future = null;
            if ( data.aborted ) {
                $scope.valCtx = {validationResult : {genericCheckResult : { errors : [{severity: "error", line: -1, message: "Query aborted"}]}}}
            } else {
                $scope.valCtx = {validationResult : {genericCheckResult : { errors : [{severity: "error", line: -1, message: "Query failed unexpectedly"}]}}}
            }
        });
    };

    $scope.$watch("[ recipe.inputs, recipe.outputs]", function(nv, ov) {
        DataikuAPI.flow.recipes.impala.checkFullSqlAvailability($stateParams.projectKey,
                $scope.hooks.getRecipeSerialized()).success(function(data) {
                $scope.fullSqlAvailability = data;
            }).error(setErrorInScope.bind($scope));
    }, true);

    $scope.visitUnsynchonizedDataset = function() {
        var name = $scope.valCtx.validationResult.runResult.datasetInNeedOfSynchronization;
        if ( name != null ) {
            $state.go('projects.project.datasets.dataset.settings', {projectKey : $stateParams.projectKey, datasetName : name});
        }
    };
    $scope.resynchronizeMetastore = function() {
        var name = $scope.valCtx.validationResult.runResult.datasetInNeedOfSynchronization;
        if ( name != null ) {
            Dialogs.confirmPositive($scope,
                'Hive metastore resynchronization',
                'Are you sure you want to resynchronize ' + name + ' to the Hive metastore?')
            .then(function() {
                    ActivityIndicator.waiting('Synchronizing Hive metastore...');
                    const datasets = [{
                        type: 'DATASET',
                        projectKey: $stateParams.projectKey,
                        id: name
                    }];
                    DataikuAPI.datasets.synchronizeHiveMetastore(datasets).success(function(data,status,headers){
                        $scope.valCtx.validationResult = null;
                        ActivityIndicator.success('Hive metastore successfully synchronized');
                    }).error(function(data, status, headers) {
                        ActivityIndicator.hide();
                        setErrorInScope.call($scope,data,status,headers);
                    });
            });
        }
    };

});

app.controller("PigRecipeController", function($scope, DataikuAPI, ActivityIndicator, $q, WT1, TopNav, $stateParams, RecipesUtils, Fn, RecipeRunJobService, $timeout, CodeBasedEditorUtils, CodeBasedValidationUtils, ComputableSchemaRecipeSave, CodeMirrorSettingService) {
    $scope.enableAutoFixup();

    // Editor
    $scope.identifierQuote = ''; // explicitly don't quote
    $scope.editorOptions = CodeBasedEditorUtils.editorOptions('text/x-dkupig', $scope, true);
    $scope.editorOptions.extraKeys[CodeMirrorSettingService.getShortcuts()['AUTOCOMPLETE_SHORTCUT']] = function(cm) {
        $scope.recipeWT1Event("pig-autocomplete");
        CodeMirror.showHint(cm, function(editor){
            var inputs = RecipesUtils.getFlatInputsList($scope.recipe).map(Fn.prop("ref"));
            var outputs= RecipesUtils.getFlatOutputsList($scope.recipe).map(Fn.prop("ref"));

            var relations = $scope.valCtx.validationResult;
            if(relations) {
                relations = relations.relationSchemas;
            }
            return CodeMirror.pigHintWithContext(editor,{inputs:inputs, outputs:outputs,relations:relations});
        }, {completeSingle:false});
    };

    $scope.hooks.insertVariable = function(variableName, type) {
        $timeout(function() {
            $scope.cm.replaceSelection(' ${'+variableName+'} ', "end");
        });
        $scope.cm.focus();
    }

    $scope.validateRecipe = function() {
        // we store the state of the tree
        if($scope.valCtx.validationResult && $scope.valCtx.validationResult.relationSchemas) {
            populateOpenList('',$scope.valCtx.validationResult.relationSchemas);
        }
        return CodeBasedValidationUtils.getGenericCheckPromise($scope).then(function(valResult) {
            $scope.valCtx.validationResult = valResult;
            CodeBasedEditorUtils.updateLinter(valResult, $scope.linterFunction);

            if (valResult.relationSchemas) {
                // restore the state of the tree
                restoreOpenState('',$scope.valCtx.validationResult.relationSchemas);
            }

            $scope.recipeWT1Event("pig-query-validate", { ok : !valResult.topLevelMessages.error});

            return ComputableSchemaRecipeSave.handleSchemaUpdateWithPrecomputed($scope, valResult.schemaResult).then(function(changeResult){
                if (changeResult.changed) {
                    // Validate again
                    return $scope.validateRecipe();
                } else {
                    return valResult;
                }
            });
        });
    };

    $scope.hooks.preRunValidate = $scope.validateRecipe;

    $scope.widgets = [];

    var openList = [];
    var openListSeparator = '!#|~';

    function populateOpenList(path,oldResponse) {
        if(oldResponse) {
            for(var k in oldResponse) {
                var field = oldResponse[k];
                var npath = path+openListSeparator+field.name;
                if(field.fields) {
                    populateOpenList(npath, field.fields);
                }
                if(field.show) {
                    // add to open list
                    openList.push(npath);
                } else {
                    // remove from open list
                    var idx = openList.indexOf(npath);
                    if(idx!=-1) {
                        openList.splice(idx,1);
                    }
                }
            }
        }
        // deduplicate
        openList.filter(function(elm,idx){return openList.indexOf(elm)==idx;});
    }

    function restoreOpenState(path, newResponse) {
        if(newResponse) {
            for(var k in newResponse) {
                var field = newResponse[k];
                if(field.name) {
                    var npath = path+openListSeparator+field.name;
                    if(openList.indexOf(npath)!=-1) {
                        field.show=true;
                        restoreOpenState(npath,field.fields);
                    }
                }
            }
        }
    }

    $scope.autofillCode = function() {
        $scope.script.data = "";

        var inputDatasets = RecipesUtils.getInputsForRole($scope.recipe, "main");
        if (inputDatasets.length > 0) {
            $scope.script.data += "-- Read input datasets\n";
            for (var i=0; i<inputDatasets.length; i++) {
                var dataset = inputDatasets[i].ref;
                $scope.script.data += "relation_" + cleanupVariable(dataset) + " = DKULOAD '"+ dataset +"';\n";
            }
        }

        $scope.script.data += "\n";
        $scope.script.data += "-- Applicative code\n\n";

        var outputDatasets = RecipesUtils.getOutputsForRole($scope.recipe, "main");
        if (outputDatasets.length > 0) {
            $scope.script.data += "-- Store output datasets\n";
            for (var i=0; i<outputDatasets.length; i++) {
                var dataset = outputDatasets[i].ref;
                $scope.script.data +="DKUSTORE relation_" +cleanupVariable(dataset) + " INTO '" + dataset+"';\n";
            }
        }
    };

});

})();
(function() {
'use strict';

const app = angular.module('dataiku.recipes');


app.factory("SQLRecipeHelperService", function(RecipesUtils, Fn, DKUSQLFormatter){
    var svc = {
        buildSQLDatasetsList : function($scope) {
            var sqlDatasets = [];
            if ( $scope.computablesMap == null ) {
                return sqlDatasets;
            }
            var found = null;
            if ($scope.recipe.inputs && $scope.recipe.inputs['main'] && $scope.recipe.inputs['main'].items) {
                $scope.recipe.inputs['main'].items.forEach(function(input) {
                    if (input.ref == $scope.recipe.params.mainConnectionDataset) {
                        found = input;
                    }
                    if ( $scope.computablesMap[input.ref].dataset != null) {
                        sqlDatasets.push(input);
                    }
                });
            }
            if ($scope.recipe.outputs && $scope.recipe.outputs['main'] && $scope.recipe.outputs['main'].items) {
                $scope.recipe.outputs['main'].items.forEach(function(output) {
                    if (output.ref == $scope.recipe.params.mainConnectionDataset) {
                        found = output;
                    }
                    if ($scope.computablesMap[output.ref].dataset != null) {
                        sqlDatasets.push(output);
                    }
                });
            }

            if (found == null) {
                // dataset used to give the main connection has been removed, clear it
                delete $scope.recipe.params.mainConnectionDataset;
            }
            return sqlDatasets;
        },
        maintainSQLDatasetList: function($scope) {
            $scope.sqlDatasets = [];
            var onRecipeIoOrComputableChange = function() {
                $scope.sqlDatasets = svc.buildSQLDatasetsList($scope);
            };
            $scope.$on('computablesMapChanged', onRecipeIoOrComputableChange);
            $scope.$watch("[recipe.inputs, recipe.outputs]", onRecipeIoOrComputableChange, true);
        },

        handleAutocompleteRequest: function($scope, cm, type) {
            CodeMirror.showHint(cm, function(cm){
                var relevantDatasetRefs = RecipesUtils.getFlatIOList($scope.recipe).map(Fn.prop("ref"));
                var fieldsToAutocomplete = CodeMirror.sqlFieldsAutocomplete(cm, relevantDatasetRefs.map(function(v) { return {table:v}; }));
                var sqlFields = [];
                if (fieldsToAutocomplete && fieldsToAutocomplete.length) {
                    for(var i in relevantDatasetRefs) {
                        var tableName = relevantDatasetRefs[i];
                        var columns = $scope.computablesMap[tableName].dataset.schema.columns;
                        for(var j in columns) {
                            sqlFields.push({name:columns[j].name,table:tableName});
                        }
                    }
                }
                CodeMirror.showHint(cm, function(cm){
                    return CodeMirror.sqlNotebookHint(cm, type, relevantDatasetRefs,sqlFields);
                }, {completeSingle:false});
            });
        },
        sqlFormat: function($scope){
            var codeMirrors = $(".editor .CodeMirror");
            var cm = codeMirrors[0].CodeMirror;
            cm.setValue(DKUSQLFormatter.format(cm.getValue(), cm.getOption("indentUnit")));
        }
    }
    return svc;
});

app.factory('DKUSQLFormatter', function(){
    function escapeDkuExpansions(code) {
        const replacementMap = {};
        var cnt = 0;
        var escapedCode = code.replace(/\$\{[^}]*\}/g, (match) => {
            const token = "dku__var__" + (cnt++) + "__ukd";
            replacementMap[token] = match;
            return token;
        });
        return [escapedCode, replacementMap];
    }

    function unescapeDkuExpansions(code, map) {
        const tokens = Object.keys(map);
        if(tokens.length == 0) return code;
        const pattern = new RegExp(tokens.join('|'), 'g');
        return code.replace(pattern, (token)=> map[token]);
    }
    
    return {
        format: function(sql, indent) {
            // Dataiku's variable expansions are not standard SQL and the
            // library 'sql-formatter' doesn't deal with them nicely.
            //
            // This issue can be alleviated by temporarily replacing all
            // expansions by SQL-friendly tokens.
            const [escapedSql, replacementMap] = escapeDkuExpansions(sql);
            const formattedEscapedSql = sqlFormatter.format(escapedSql, {indent: Array(indent + 1).join(' ')});
            return unescapeDkuExpansions(formattedEscapedSql, replacementMap);
        }
    };
});

app.controller("SQLScriptRecipeController", function($scope, CodeBasedEditorUtils, CodeBasedValidationUtils, CodeBasedToPluginConverter, DataikuAPI, $q, WT1, $stateParams, RecipeRunJobService, RecipesUtils, Fn, $timeout, SQLRecipeHelperService, CodeMirrorSettingService) {
    $scope.enableAutoFixup();

    // Editor settings
    $scope.identifierQuote = null; // guess quoting style from dataset input type
    $scope.editorOptions = CodeBasedEditorUtils.editorOptions('text/x-sql2', $scope);
    $scope.editorOptions.extraKeys[CodeMirrorSettingService.getShortcuts()['AUTOCOMPLETE_SHORTCUT']] = function(cm) {
        $scope.recipeWT1Event("sql-script-autocomplete");
        SQLRecipeHelperService.handleAutocompleteRequest($scope, cm, "sql-recipe");
    };

    $scope.hooks.insertVariable = function(variableName, type) {
        $timeout(function() {
            $scope.cm.replaceSelection(' ${'+variableName+'} ', "end");
        });
        $scope.cm.focus();
    }

    // Autofill: none in SQL script
    if ($scope.script.data == null) $scope.script.data = " ";

    // Maintenance of the list of SQL datasets for selecting connection
    $scope.getInputOrOuputLabel = function(ref) {
        if ( ref == null || ref.length == 0 ) {
            return '';
        }
        if ( $scope.computablesMap == null ) {
            return '';
        }
        var computable = $scope.computablesMap[ref];
        return computable.label;
    };
    SQLRecipeHelperService.maintainSQLDatasetList($scope);

    $scope.sqlFormat = SQLRecipeHelperService.sqlFormat.bind(this, $scope);

    $scope.validateRecipe = function() {
        return CodeBasedValidationUtils.getGenericCheckPromise($scope).then(function(valResult) {
            $scope.valCtx.validationResult = valResult;
            CodeBasedEditorUtils.updateLinter(valResult, $scope.linterFunction);
            $scope.recipeWT1Event("sql-script-validate", { ok : !valResult.topLevelMessages.error});
            return valResult;
        });
    };
    $scope.hooks.preRunValidate = $scope.validateRecipe;
});

app.factory("HoverIntent", function(){
    var svc = {
        create: function(cb) {
            return {
                cb : cb
            }
        },
        move: function(hi, evt, triggerTag) {
            if (hi.triggerTag == triggerTag) {
                // Still over the same trigger
                return;
            } else if (hi.timeout) {
                // We moved away
                clearTimeout(hi.timeout);
            }
            hi.timeout = setTimeout(function(){
                hi.cb(hi.origEvent, hi.triggerTag);
            }, 500);
            hi.triggerTag = triggerTag;
            hi.origEvent = evt;
        },
        clear : function(hi) {
            clearTimeout(hi.timeout);
        }

    }
    return svc;
})


app.controller("SQLQueryRecipeController", function($rootScope, $scope, CodeBasedEditorUtils, CodeBasedValidationUtils, CodeBasedToPluginConverter, DataikuAPI, $q, WT1, $stateParams, CreateModalFromTemplate, RecipeRunJobService, RecipesUtils, Fn, MonoFuture, $timeout, ComputableSchemaRecipeSave, SQLRecipeHelperService, CodeMirrorSettingService){
    $scope.enableAutoFixup();

    // Editor settings
    $scope.identifierQuote = null; // guess quoting style from dataset input type
    $scope.editorOptions = CodeBasedEditorUtils.editorOptions('text/x-sql2', $scope);
    $scope.editorOptions.extraKeys[CodeMirrorSettingService.getShortcuts()['AUTOCOMPLETE_SHORTCUT']] = function(cm) {
        $scope.recipeWT1Event("sql-script-autocomplete");
        SQLRecipeHelperService.handleAutocompleteRequest($scope, cm, "sql-recipe");
    }

    $scope.anyPipelineTypeEnabled = function() {
        return $rootScope.projectSummary.sqlPipelinesEnabled;
    };

    // var hi = HoverIntent.create(function(origEvent, triggerTag){
    //     //console.info("HI on ", triggerTag);

    //     if (popup) popup.remove();

    //     popup = $("<div style='position: absolute; background: white;padding: 3px; display: none; border: 1px #ddd solid; box-shadow: 2px 2px rgba(0,0,0,0.3)'/>")

    //     if (triggerTag.type == 'variable-2' && triggerTag.string.indexOf("${") == 0) {
    //         var variableName = triggerTag.string.replace("${", "").replace("}", "")
    //         if ($scope.valCtx.validationResult && $scope.valCtx.validationResult.substitutionVariables) {
    //             var variableValue =$scope.valCtx.validationResult.substitutionVariables[variableName];
    //             if (variableValue) {
    //                 popup.html($("<span>" +variableName + " =  "+ variableValue.value + "</span>"));
    //                 popup.show();
    //                 popup.css("left", origEvent.clientX);
    //                 popup.css("top", origEvent.clientY);
    //                 $("body").append(popup);
    //             }
    //         }
    //     }
    // });
    // var popup = null;

    // $scope.$watch("cm", function(nv, ov){
    //     if (!nv) return;
    //     CodeMirror.on($scope.cm.getWrapperElement(), "mousemove", function(evt){
    //         var pos = $scope.cm.coordsChar({ left: evt.clientX, top: evt.clientY });
    //         var token = $scope.cm.getTokenAt(pos);
    //         HoverIntent.move(hi, evt, token);
    //     });
    //     CodeMirror.on($scope.cm.getWrapperElement(), "mouseout", function(){
    //         HoverIntent.clear(hi);
    //     })
    // });

    $scope.hooks.insertVariable = function(variableName, type) {
        $timeout(function() {
            $scope.cm.replaceSelection(' ${'+variableName+'} ', "end");
        });
        $scope.cm.focus();
    }

    //Nothing to do: SQL query recipes are prefilled on creation
    $scope.autofillCode = function() {
    };

    // Maintenance of the list of SQL datasets for selecting connection
    $scope.getInputOrOuputLabel = function(ref) {
        if ( ref == null || ref.length == 0 ) {
            return '';
        }
        if ( $scope.computablesMap == null ) {
            return '';
        }
        var computable = $scope.computablesMap[ref];
        return computable.label;
    };
    SQLRecipeHelperService.maintainSQLDatasetList($scope);

    $scope.sqlFormat = SQLRecipeHelperService.sqlFormat.bind(this, $scope);

    $scope.validateRecipe = function() {
        return CodeBasedValidationUtils.getGenericCheckPromise($scope).then(function(valResult) {
            $scope.valCtx.validationResult = valResult;
            CodeBasedEditorUtils.updateLinter(valResult, $scope.linterFunction);

            $scope.recipeWT1Event("sql-query-validate", { ok : !valResult.topLevelMessages.error});

            return ComputableSchemaRecipeSave.handleSchemaUpdateWithPrecomputed($scope, valResult.schemaResult).then(function(changeResult){
                if (changeResult.changed) {
                    // Validate again
                    return $scope.validateRecipe();
                } else {
                    return valResult;
                }
            });
        });
    };

    $scope.hooks.preRunValidate = $scope.validateRecipe;

    $scope.showExecutionPlan = function() {
        $scope.hooks.resetScope();

        DataikuAPI.flow.recipes.sqlQuery.getExecutionPlan($stateParams.projectKey,
            $scope.hooks.getRecipeSerialized(),
            $scope.script.data,
            RecipeRunJobService.getTargetPartition($scope)).success(function(data) {
                $scope.valCtx.validationResult = data.validationResult;
                if (!data.validationResult.topLevelMessages.error) {
                    CreateModalFromTemplate("/templates/recipes/fragments/sql-modal.html", $scope, null, function(newScope) {
                        newScope.executionPlan = data.executionPlan;
                        if (data.executionPlan) {
                            newScope.query = data.executionPlan.query;
                        } else {
                            newScope.failedToComputeExecutionPlan = true; //TODO @recipes, report source error
                        }
                        newScope.uiState = {currentTab: 'plan'};
                        newScope.engine = 'SQL';
                        newScope.isAlreadyRecipe = true;
                    });
                }
        }).error(setErrorInScope.bind($scope));
    };

    $scope.showExpandedQuery = function(query) {
        CreateModalFromTemplate("/templates/recipes/fragments/sql-modal.html", $scope, null, function(newScope){
            newScope.query = query;
            newScope.uiState = {currentTab: 'query'};
            newScope.engine = 'SQL';
            newScope.isAlreadyRecipe = true;
        });
    };

    $scope.run = function() {
        $scope.hooks.resetScope();

        MonoFuture($scope).wrap(DataikuAPI.flow.recipes.sqlQuery.run)($stateParams.projectKey,
                $scope.hooks.getRecipeSerialized(),
                $scope.script.data, RecipeRunJobService.getTargetPartition($scope)).success(function(data) {
                    $scope.future = null;
                    //console.info(data.result);
                    $scope.valCtx.validationResult = data.result;
                    $scope.recipeWT1Event("sql-query-run", {
                        ok : !data.result.topLevelMessages.error,
                        runOK : (data.result.runResult && data.result.runResult.success),
                        runRows : (data.result.runResult ? data.result.runResult.totalRows : -1)
                    });
                    if (data.result && data.result.runResult && data.result.runResult.success && data.result.runResult.rows){
                       CreateModalFromTemplate("/templates/recipes/sql/rows-preview-modal.html", $scope);
                    }
        }).update(function(data) {
            $scope.future = data;
        }).error(function(data) {
            $scope.future = null;
            if ( data.aborted ) {
                $scope.valCtx = {validationResult : {topLevelMessages : { messages : [{severity: "error", line: -1, message: "Query aborted"}]}}}
            } else {
                $scope.valCtx = {validationResult : {topLevelMessages : { messages : [{severity: "error", line: -1, message: "Query failed unexpectedly"}]}}}
            }
        });
    };
});

})();

(function() {
'use strict';

const app = angular.module('dataiku.recipes.customcode', []);


app.controller("RecipeFromPluginCreationController", function($scope, DataikuAPI, WT1, $rootScope, CreateModalFromTemplate, SelectablePluginsService){
    $scope.uiState = {
        step : "choose-recipe"
    };
    $scope.recipes = [];

    $scope.$watch("pluginId", function(nv, ov) {
        if (!nv) return;
        $scope.plugin = Array.dkuFindFn($rootScope.appConfig.loadedPlugins, function(n){
            return n.id === nv
        });

        if ($scope.plugin) {
            $rootScope.appConfig.customCodeRecipes.forEach(function(recipe) {
                if (recipe.ownerPluginId == $scope.pluginId) {
                    $scope.recipes.push({
                        activated: SelectablePluginsService.canBeBuildFromInputs(recipe, $scope.inputCount),
                        preselectedInputs: getPreselectedInputs(recipe.desc, $scope.inputs),
                        preselectedRole: getPreselectedRole(recipe.desc, $scope.inputs),
                        recipeType: recipe.recipeType,
                        label: recipe.desc.meta.label,
                        description: recipe.desc.meta.description,
                        icon: recipe.desc.meta.icon || $scope.plugin.icon,
                        iconColor: recipe.desc.meta.iconColor,
                        displayOrderRank: recipe.desc.meta.displayOrderRank
                    });
                }
            });
        }

        function getPreselectedInputs(desc, inputs) {
            if (!inputs)
                return null;
            return (inputs.MANAGED_FOLDER || []).concat(inputs.DATASET || []).concat(inputs.SAVED_MODEL || [])
        }

        function getPreselectedRole(desc, inputs) {
            let preselectedRoles = [];
            if (!inputs) {
                return null;
            }
            if (inputs.DATASET && inputs.DATASET.length > 0 && desc.selectableFromDataset) {
                preselectedRoles[desc.selectableFromDataset] = inputs.DATASET;
            }
            if (inputs.MANAGED_FOLDER && inputs.MANAGED_FOLDER.length > 0 && desc.selectableFromFolder) {
                preselectedRoles[desc.selectableFromFolder] = inputs.MANAGED_FOLDER;
            }
            if (inputs.SAVED_MODEL && inputs.SAVED_MODEL.length > 0 && desc.selectableFromSavedModel) {
                preselectedRoles[desc.selectableFromSavedModel] = inputs.SAVED_MODEL;
            }
            return preselectedRoles;
        }

        $scope.recipes.sort((a, b) => a.label.toLowerCase().localeCompare(b.label.toLowerCase()));
    });

    $scope.create = function(recipe, zoneId) {
        $scope.showCreateCustomCodeRecipeModal(recipe.recipeType, recipe.preselectedInputs, recipe.preselectedRole, zoneId);
    };
});


app.controller("CustomCodeRecipeCreationController", function($scope, Assert, DataikuAPI, WT1, $stateParams, TopNav, Fn, PartitionDeps,
               RecipeComputablesService, DatasetsService, $controller, $state, RecipesUtils, RecipeDescService, PluginConfigUtils){

    var realDismiss = $scope.dismiss;
    $scope.dismiss = function() {
        if (angular.isDefined($scope.oldScope)) {
            $scope.oldScope.dismiss();
        }
        realDismiss();
    };

    $controller("_RecipeCreationControllerBase", {$scope:$scope});

    $scope.helpState = {};

    $scope.recipeName = {};
    function init(){
        $scope.recipe = {
            projectKey : $stateParams.projectKey,
            type : $scope.newRecipeType,
            inputs: {}, outputs: {},
            params : {
                customConfig : {}
            },
            zone: $scope.zone
        }

        $scope.loadedDesc = $scope.appConfig.customCodeRecipes.filter(function(x){
            return x.recipeType == $scope.recipe.type;
        })[0];

        Assert.inScope($scope, 'loadedDesc');
        // clone, so that we can put additional flags in the roles
        $scope.desc = angular.copy($scope.loadedDesc.desc);

        // put default values in place
        PluginConfigUtils.setDefaultValues($scope.desc.params, $scope.recipe.params.customConfig);

        $scope.pluginDesc = $scope.appConfig.loadedPlugins.filter(function(x){
            return x.id == $scope.loadedDesc.ownerPluginId;
        })[0];

        RecipeComputablesService.getComputablesMap($scope.recipe, $scope).then(function(map){
            $scope.setComputablesMap(map);
        });

        if ($scope.preselectedInputs) {
            for (let [inputType, ids] of Object.entries($scope.preselectedInputRole)) {
                ids.forEach(function(id) {
                    RecipesUtils.addInput($scope.recipe, inputType, id);
                })
            }
        }

    }
    $scope.$watch("newRecipeType", Fn.doIfNv(init));

    addDatasetUniquenessCheck($scope, DataikuAPI, $stateParams.projectKey);
    DatasetsService.updateProjectList($stateParams.projectKey);

    // we will autofill the name if needed
    $scope.$watch("[recipe.inputs, recipe.outputs]", function(nv, ov) {
        if (nv && $scope.recipe && $scope.recipe.inputs && $scope.recipe.outputs) {
            if ($scope.preselectedInputs
                && !RecipesUtils.getFlatInputsList($scope.recipe).some(_ => _.ref === $scope.preselectedInputs[0])) {
                $scope.zone = null;
            }
            var outputs = RecipesUtils.getFlatOutputsList($scope.recipe);
            $scope.hasRequiredIO = RecipeDescService.hasValidRequiredRoles($scope.recipe);
            if (outputs.length && $scope.hasRequiredIO) {
                let firstNonNullOutput = outputs.find(o => !!o);
                // hasValidRequiredRoles does not imply that there is an output since plugin recipes could have several non-mandatory output roles
                // let's not fail here in that case, the backend should send back a proper error
                if (firstNonNullOutput) {
                    $scope.recipeName.name = "compute_" + firstNonNullOutput.ref;
                } else {
                    $scope.recipeName.name = null;
                }
            } else {
                $scope.recipeName.name = null;
            }
        }
    }, true);
});


app.controller("CustomCodeRecipeController", function($rootScope, $scope, Assert, DataikuAPI, WT1, $stateParams, StateUtils, TopNav, RecipesUtils, PluginConfigUtils, Logger, DatasetUtils) {
    $scope.loadedDesc = $scope.appConfig.customCodeRecipes.filter(function(x){
        return x.recipeType == $scope.recipe.type;
    })[0];

    Assert.inScope($scope, 'loadedDesc');
    // clone, so that we can put additional flags in the roles
    $scope.desc = angular.copy($scope.loadedDesc.desc);

    $scope.pluginDesc = $scope.appConfig.loadedPlugins.filter(function(x){
        return x.id == $scope.loadedDesc.ownerPluginId;
    })[0];

    if ($scope.creation) {
        TopNav.setTab(StateUtils.defaultTab("io"));
    }

    if (!$scope.recipe.params) {
        $scope.recipe.params = {}
    }
    if (!$scope.recipe.params.customConfig){
        $scope.recipe.params.customConfig = {}
    }

    $scope.anyPipelineTypeEnabled = function() {
        return $rootScope.projectSummary.sparkPipelinesEnabled;
    };

    $scope.columnsPerInputRole = {};
    PluginConfigUtils.setDefaultValues($scope.desc.params, $scope.recipe.params.customConfig);
    /* In addition to default values, set properly the columns stuff */
    $scope.desc.params.forEach(function(param) {
    	if ($scope.recipe.params.customConfig[param.name] === undefined) {
        	if ( param.type == "COLUMNS" ) {
        		// the dku-list-typeahead expects something not null
        		$scope.recipe.params.customConfig[param.name] = [];
        	}
    	}
    	if (param.columnRole != null) {
    		$scope.columnsPerInputRole[param.columnRole] = [];
    	}
    });

    $scope.enableAutoFixup();

    function refreshColumnListsFromComputablesMap() {
        if (!$scope.computablesMap) { // not ready
            return;
        }
        DatasetUtils.updateRecipeComputables($scope, $scope.recipe, $stateParams.projectKey, $stateParams.projectKey).then(function(){
            for (const roleName in $scope.recipe.inputs) {
                $scope.columnsPerInputRole[roleName] = [];
                const items = RecipesUtils.getInputsForRole($scope.recipe, roleName);
                items.forEach(function(item) {
                    const computable = $scope.computablesMap[item.ref];
                    if (computable == null) {
                        Logger.error("Computable not found for " + item.ref);
                    } else {
                        if (!(roleName in $scope.columnsPerInputRole)) {
                            $scope.columnsPerInputRole[roleName] = [];
                        }
                        if (computable.dataset) {
                            $scope.columnsPerInputRole[roleName] = $scope.columnsPerInputRole[roleName].concat(computable.dataset.schema.columns);
                        }
                    }
                });
            }
        });
    }

    $scope.roleChanged = function(roleName) {
        // clear first, in case the inputs of this role are all gone
    	$scope.columnsPerInputRole[roleName] = [];
    	// then compute the new list, when non empty
    	const inputs = RecipesUtils.getInputsForRole($scope.recipe, roleName);
        inputs.forEach(function(input) {
            const computable = $scope.computablesMap[input.ref];
            if (computable == null) {
                Logger.error("Computable not found for " + input.ref);
            } else {
                if (computable.dataset) {
                    $scope.columnsPerInputRole[roleName] = $scope.columnsPerInputRole[roleName].concat(computable.dataset.schema.columns);
                }
            }
        });
    };

    $scope.toggleShowRequirements = function() {
    	if ( $scope.showRequirements === undefined ) {
    		$scope.showRequirements = false;
    		// first time : fetch requirements from the backend, with the command line to install them
    	    DataikuAPI.flow.recipes.getRequirements($stateParams.projectKey, $scope.recipe.type).success(function(data){
    	    	$scope.requirements = data;
    	    }).error(setErrorInScope.bind($scope));
    	}
    	$scope.showRequirements = !$scope.showRequirements;
    };

    refreshColumnListsFromComputablesMap();
    $scope.$on('computablesMapChanged', function() {
    	refreshColumnListsFromComputablesMap();
    });
});


app.controller("AppRecipeCreationController", function($scope, Assert, DataikuAPI, WT1, $stateParams, TopNav, Fn, PartitionDeps,
               RecipeComputablesService, DatasetsService, $controller, $state, RecipesUtils, RecipeDescService, PluginConfigUtils){

    var realDismiss = $scope.dismiss;
    $scope.dismiss = function() {
        if (angular.isDefined($scope.oldScope)) {
            $scope.oldScope.dismiss();
        }
        realDismiss();
    };

    $controller("_RecipeCreationControllerBase", {$scope:$scope});

    $scope.helpState = {};

    $scope.recipeName = {};
    function init(){
        $scope.recipe = {
            projectKey : $stateParams.projectKey,
            type : $scope.newRecipeType,
            inputs: {}, outputs: {},
            params : {
                customConfig : {}
            }
        }

        $scope.loadedDesc = $scope.appConfig.appRecipes.filter(function(x){
            return x.recipeType == $scope.recipe.type;
        })[0];

        Assert.inScope($scope, 'loadedDesc');
        // clone, so that we can put additional flags in the roles
        $scope.desc = angular.copy($scope.loadedDesc);

        RecipeComputablesService.getComputablesMap($scope.recipe, $scope).then(function(map){
            $scope.setComputablesMap(map);
        });

        if ($scope.preselectedInputs) {
            $scope.preselectedInputs.forEach( (preselectedInput) => {
                RecipesUtils.addInput($scope.recipe, $scope.preselectedInputRole, preselectedInput);
            });
        }

    }
    $scope.$watch("newRecipeType", Fn.doIfNv(init));

    addDatasetUniquenessCheck($scope, DataikuAPI, $stateParams.projectKey);
    DatasetsService.updateProjectList($stateParams.projectKey);

    // we will autofill the name if needed
    $scope.$watch("[recipe.inputs, recipe.outputs]", function(nv, ov) {
        if (nv && $scope.recipe && $scope.recipe.inputs && $scope.recipe.outputs){
            var outputs = RecipesUtils.getFlatOutputsList($scope.recipe);
            if (outputs.length) {
                let firstNonNullOutput = outputs.find(o => !!o);
                if (firstNonNullOutput) {
                    $scope.recipeName.name = "compute_" + firstNonNullOutput.ref;
                } else {
                    $scope.recipeName.name = null;
                }
            } else {
                $scope.recipeName.name = null;
            }
        }
    }, true);
});


app.controller("AppRecipeController", function($rootScope, $scope, Assert, DataikuAPI, WT1, $state, $stateParams, StateUtils, TopNav, RecipesUtils, PluginConfigUtils, Logger, DatasetUtils) {
    $scope.loadedDesc = $scope.appConfig.appRecipes.filter(function(x){
        return x.recipeType == $scope.recipe.type;
    })[0];
    Assert.inScope($scope, 'loadedDesc');
    // clone, so that we can put additional flags in the roles
    $scope.desc = angular.copy($scope.loadedDesc);

    TopNav.setTab("settings");

    if (!$scope.recipe.params) {
        $scope.recipe.params = {}
    }
    if (!$scope.recipe.params.variables){
        $scope.recipe.params.variables = {}
    }

    $scope.desc.variablesEditionTile.behavior = 'INLINE_AUTO_SAVE'; // it's a bit of a lie, but that way you don't have the save button next to the form
    
    $scope.columnsPerInputRole = {};

    $scope.enableAutoFixup();

    function refreshColumnListsFromComputablesMap() {
        if (!$scope.computablesMap) { // not ready
            return;
        }
        DatasetUtils.updateRecipeComputables($scope, $scope.recipe, $stateParams.projectKey, $stateParams.projectKey).then(function(){
            for(var roleName in $scope.recipe.inputs) {
                $scope.columnsPerInputRole[roleName] = [];
                var items = RecipesUtils.getInputsForRole($scope.recipe, roleName);
                if (items.length > 0) {
                    var input = items[0];
                    var computable = $scope.computablesMap[input.ref];
                    if (computable == null) {
                        Logger.error("Computable not found for " + input.ref);
                    } else {
                        $scope.columnsPerInputRole[roleName] = computable.dataset ? computable.dataset.schema.columns : [];
                    }
                }
            }
        });
    }
    $scope.roleChanged = function(roleName) {
        // clear first, in case the inputs of this role are all gone
        $scope.columnsPerInputRole[roleName] = [];
        // then compute the new list, when non empty
        const inputs = RecipesUtils.getInputsForRole($scope.recipe, roleName);
        if (inputs.length > 0) {
            const computable = $scope.computablesMap[inputs[0].ref];
            if (computable == null) {
                Logger.error("Computable not found for " + input.ref);
            } else {
                $scope.columnsPerInputRole[roleName] = computable.dataset ? computable.dataset.schema.columns : [];
            }
        }
    };

    refreshColumnListsFromComputablesMap();
    $scope.$on('computablesMapChanged', function() {
        refreshColumnListsFromComputablesMap();
    });
    
    $scope.hasParameters = function() {
        let tile = $scope.desc ? $scope.desc.variablesEditionTile : null;
        if (!tile) return false;
        return (tile.html && tile.html.length > 0) || (tile.params && tile.params.length > 0);
    };
    
    DataikuAPI.apps.getAppRecipeUsability($scope.recipe.type).success(function(data){
        $scope.usability = data;
    }).error(setErrorInScope.bind($scope));
    
    $scope.canGoToDesigner = function() {
        if (!$scope.usability) return false;
        return $scope.usability.canEdit;
    };
    $scope.goToDesigner = function() {
        if (!$scope.usability) return;
        if ($scope.usability.origin == 'PROJECT') {
            $state.go('projects.project.appdesigner', {projectKey : $scope.usability.projectKey});
        } else if ($scope.usability.origin == 'PLUGIN') {
            $state.go('projects.project.appdesigner', {projectKey : $scope.desc.recipeType.substring('App_PROJECT_'.length)});
        }
    };
});


})();
(function() {
'use strict';

const app = angular.module('dataiku.recipes');


    app.controller("_BaseMLRecipeEditor", function($scope, $q, $state, Assert, GraphZoomTrackerService, DataikuAPI,
        $stateParams, FullModelIdUtils) {
        Assert.inScope($scope, 'script');
        Assert.inScope($scope, 'recipe');
        GraphZoomTrackerService.setFocusItemByName("recipe", $state.params.recipeName);

        $scope.desc = JSON.parse($scope.script.data);

        $scope.hooks.preRunValidate = function() {
            return $q.when({ ok : true});
        };

        $scope.hooks.recipeIsDirty = function() {
            if (!$scope.recipe) return false;
            if ($scope.creation) {
                return true;
            } else {
                var dirty = !angular.equals($scope.recipe, $scope.origRecipe);
                var origDesc = JSON.parse($scope.origScript.data);
                dirty = dirty || !angular.equals(origDesc, $scope.desc);
               return dirty;
            }
        };

        $scope.isMLBackendType = function(mlBackendType){
            return $scope.desc.backendType === mlBackendType;
        };

        $scope.goToAnalysisModel = function(){
            Assert.trueish($scope.desc.generatingModelId, 'no generatingModelId');
            // Enforcing projectKey to be current Project and not the one hard coded in fullModelId
            // to prevent from breaking when changing projectKey of analysis (e.g. importing project
            // and changing projectKey)
            const { elements, fullModelId } = FullModelIdUtils.parseWithEnforcedProjectKey($scope.desc.generatingModelId, $stateParams.projectKey);

            const params = {
                projectKey: elements.projectKey,
                analysisId: elements.analysisId,
                mlTaskId: elements.mlTaskId,
                fullModelId: fullModelId
            };

            let state = "projects.project.analyses.analysis.ml.";
            if ($scope.recipe.type == "prediction_training") {
                state += "predmltask.model.report";
            } else {
                state += "clustmltask.model.report";
            }
            $state.go(state, params);
        };

        // Retrieving list of containers to know if computation will occur on a container or not
        let listContainersWithDefault = null;
        DataikuAPI.containers.listNamesWithDefault($stateParams.projectKey).success(function(data) {
                    listContainersWithDefault = data;
        }).error(setErrorInScope.bind($scope));

        $scope.inContainer = function(selectedContainer) {
            if (selectedContainer.containerMode === "NONE" || listContainersWithDefault === null) {
                return false;
            } else if (selectedContainer.containerMode === "INHERIT") {
                return listContainersWithDefault.resolvedInheritValue != null;
            } else {
                return true;
            }
        };

        $scope.getModelUsedCodeEnvName = function() {
            if ($scope.modelDetails
                && $scope.modelDetails.coreParams
                && $scope.modelDetails.coreParams.executionParams) {
                    return $scope.modelDetails.coreParams.executionParams.envName;
            } else {
                return undefined;
            }
        };

        $scope.isPartitionedModel = function () {
            return $scope.modelDetails
                && $scope.modelDetails.coreParams
                && $scope.modelDetails.coreParams.partitionedModel
                && $scope.modelDetails.coreParams.partitionedModel.enabled;
        }
    });


    app.controller("_MLRecipeWithOutputSchemaController", function($scope, $q, ComputableSchemaRecipeSave, PartitionDeps) {
        $scope.hooks.save = function(){
            var deferred = $q.defer();
            var recipeSerialized = angular.copy($scope.recipe);
            PartitionDeps.prepareRecipeForSerialize(recipeSerialized);
            var payload = angular.toJson($scope.desc);
            ComputableSchemaRecipeSave.handleSave($scope, recipeSerialized, payload, deferred);
            $scope.script.data = payload;
            return deferred.promise;
        };
    });


    app.controller("_MLRecipeWithoutOutputSchemaController", function($scope, PartitionDeps, Assert){
        Assert.inScope($scope, 'recipe');
        Assert.inScope($scope, 'desc');

        $scope.hooks.save = function(){
            var recipeSerialized = angular.copy($scope.recipe);
            PartitionDeps.prepareRecipeForSerialize(recipeSerialized);
            var payload = angular.toJson($scope.desc);
            $scope.script.data = payload;
            return $scope.baseSave(recipeSerialized, payload);
        };
    });


    app.controller("PredictionTrainingRecipeEditor", function($scope, $controller) {
        $controller("_BaseMLRecipeEditor", { $scope });
        $controller("_MLRecipeWithoutOutputSchemaController", { $scope });
        $controller("_K8sConfigurationCheckerController", { $scope });

        $scope.operationModeChanged = function(nv) {
            $scope.desc.splitParams.kfold = nv === 'TRAIN_KFOLD'
        }
        $scope.enableAutoFixup();
        $scope.isMLLib = function() { return $scope.desc.backendType === 'MLLIB' };
        
        // Overriding `$scope.isPartitionedModel` defined in _BaseMLRecipeEditor
        // because train recipe does not have `modelDetails`. Instead, coreParams
        // are stored in `desc.core`
        $scope.isPartitionedModel = function() {
            return $scope.desc
                   && $scope.desc.core
                   && $scope.desc.core.partitionedModel
                   && $scope.desc.core.partitionedModel.enabled;
        };

        $scope.partitionedSourceOptions = [
            ["ACTIVE_VERSION", "Active"],
            ["LATEST_VERSION", "Latest"],
            ["EXPLICIT_VERSION", "Explicit"],
            ["NONE", "None"]
        ];

        $scope.partitionedSourceDescs = [
            "Train upon the currently active saved model version",
            "Train upon the most recently trained version",
            "Choose which version to train upon",
            "Build a new partitioned models from scratch"
        ];

        $scope.hasSelectedK8sContainer = () => {
            const { backendType } = $scope.desc;
            const { containerSelection } = $scope.recipe.params;
            return $scope.isK8sContainer(backendType, containerSelection);
        };

        const updateHpSearchDistribution = (newSelection, oldSelection) => {
            if (angular.equals(newSelection, oldSelection)) {
                return;
            }

            const searchParams = $scope.desc.modeling.grid_search_params;
            searchParams.distributed = searchParams.distributed && $scope.hasSelectedK8sContainer();
        };

        $scope.$watch('recipe.params.containerSelection', updateHpSearchDistribution, true);
    });


    app.controller("ClusteringTrainingRecipeEditor", function($scope, $controller) {
        $controller("_BaseMLRecipeEditor", {$scope:$scope});
        $controller("_MLRecipeWithoutOutputSchemaController", {$scope:$scope})
        $scope.enableAutoFixup();
        $scope.isMLLib = function() { return $scope.desc.backendType === 'MLLIB' };
    });


    app.controller("PredictionScoringRecipeEditor", function($scope, $controller, $q, DataikuAPI, Assert,
        MLExportService, FullModelIdUtils) {
        $controller("_BaseMLRecipeEditor", {$scope:$scope});
        $controller("_MLRecipeWithOutputSchemaController", {$scope:$scope});
        $controller("_RecipeWithEngineBehavior", {$scope:$scope});

        // Payload is not expanded by backend, need defaults in the frontend
        // See PredictionScoringRecipePayloadParams.IndividualExplanationParams
        $scope.desc.individualExplanationParams = {
            method: "ICE",
            nbExplanations: 3,
            shapleyBackgroundSize: 100,
            subChunkSize: 5000,
            ... ($scope.desc.individualExplanationParams || {})
        };
       
        $scope.enableAutoFixup();
        $scope.canChangeEngine = function(){
            return true;
        };

        $scope.selectedEngine = function(){
            return $scope.recipeStatus && $scope.recipeStatus.selectedEngine && $scope.recipeStatus.selectedEngine.type;
        };

        $scope.$watch("recipeStatus.selectedEngine.type", (nv) => {
            if (nv && $scope.canComputeExplanations() === false) {
                $scope.desc.outputExplanations = false;
            }                
        })

        $scope.hooks.onRecipeLoaded = function(){
             $scope.hooks.updateRecipeStatus();
        };

        $scope.hooks.getPayloadData = function(){
            return angular.toJson($scope.desc);
        };

        $scope.hooks.updateRecipeStatus = function() {
            var deferred = $q.defer();
            var payload = $scope.hooks.getPayloadData();
            $scope.updateRecipeStatusBase(false, payload).then(function() {
                // $scope.recipeStatus should have been set by updateRecipeStatusBase
                if (!$scope.recipeStatus) return deferred.reject();
                deferred.resolve($scope.recipeStatus);
            });
            return deferred.promise;
        };

        var noProbAlgos = ['DECISION_TREE_CLASSIFICATION', 'MLLIB_DECISION_TREE'];
        $scope.noSQLProbas = function(){
            return $scope.isMulticlass() && $scope.selectedEngine() == "SQL"
                                  && noProbAlgos.indexOf($scope.modelDetails.modeling.algorithm) >= 0;
        }

        DataikuAPI.ml.prediction.getPreparedInputSchema($scope.recipe).success(function(data) {
            $scope.preparedInputSchema = data;
        }).error(setErrorInScope.bind($scope));

        var safeSQLAlgorithms = ['LASSO_REGRESSION', 'RIDGE_REGRESSION', 'LEASTSQUARE_REGRESSION',
        'LOGISTIC_REGRESSION', 'DECISION_TREE_CLASSIFICATION', 'DECISION_TREE_REGRESSION', 'MLLIB_LOGISTIC_REGRESSION',
        'MLLIB_DECISION_TREE', 'MLLIB_LINEAR_REGRESSION'];
        $scope.isRiskySQL = function(){
            if ($scope.recipeStatus && $scope.recipeStatus.selectedEngine && $scope.recipeStatus.selectedEngine.variant == "IN_SNOWFLAKE") {
                return false;
            }
            if(!$scope.modelDetails){
                return false;
            }
            return safeSQLAlgorithms.indexOf($scope.modelDetails.modeling.algorithm) < 0;
        };

        //$scope.updateStatus = function(){};

        $scope.hasConditionalOutputs = function(){
            return $scope.model.conditionalOutputs && $scope.model.conditionalOutputs.length > 0;
        };

        $scope.isSQL = function(){
            return $scope.selectedEngine() == 'SQL'
                        && $scope.model.miniTask.backendType != 'VERTICA';
        };

        $scope.hasCalibration = function(){
            return $scope.modelDetails && $scope.modelDetails.coreParams.calibration.calibrationMethod != 'NO_CALIBRATION';
        };

        $scope.canForceOriginalEngine = function(){
            if (!$scope.model || !$scope.model.miniTask) return; // not ready
            var pyCase = $scope.model.miniTask.backendType == 'PY_MEMORY' && $scope.selectedEngine() == 'DSS';
            var kerasCase = $scope.model.miniTask.backendType == 'KERAS' && $scope.selectedEngine() == 'DSS';
            var mllibCase = $scope.model.miniTask.backendType == 'MLLIB' && $scope.selectedEngine() == 'SPARK';
            return pyCase || mllibCase || kerasCase;
        };

        $scope.canComputeExplanations = function() {
            if (!$scope.model || !$scope.model.miniTask) return; // not ready
            return $scope.model.miniTask.backendType == 'PY_MEMORY' && $scope.selectedEngine() == 'DSS';
        }

        $scope.onOutputExplanationsChange = function() {
            $scope.desc.forceOriginalEngine = $scope.desc.outputExplanations;
            $scope.desc.individualExplanationParams.method = "ICE";
        }

        $scope.mayUseContainer = function() {
            if (!$scope.model || !$scope.model.miniTask) return false; // not ready
            return ($scope.model.miniTask.backendType == 'KERAS' || $scope.model.miniTask.backendType == 'PY_MEMORY')
                    && $scope.selectedEngine() == 'DSS';
        };

        $scope.hasSQLWarnings = function(){
            return $scope.hasConditionalOutputs() || $scope.isRiskySQL() || $scope.noSQLProbas();
        };

        $scope.showDownloadSQL = function(){
            return $scope.appConfig.licensedFeatures && $scope.appConfig.licensedFeatures.modelsRawSQLExport;
        };

        $scope.downloadSQL = function(){
            MLExportService.downloadFile($scope, () => DataikuAPI.ml.prediction.getSql($scope.recipe),
                (exportId) => DataikuAPI.ml.prediction.getScoringModelDownloadURL("sql", exportId));
        };

        function computablesMapChanged() {
            if (!$scope.computablesMap) return;

            $scope.recipe.inputs['model'].items.forEach(function(inp){
                var computable = $scope.computablesMap[inp.ref];
                if (computable.type == "SAVED_MODEL") {
                    $scope.model = computable.model;
                }
            });

            Assert.inScope($scope, 'model');
            Assert.trueish($scope.model.miniTask.taskType == "PREDICTION", 'not a prediction task');

            const fmiComponents = {
                projectKey: $scope.model.projectKey,
                savedModelId: $scope.model.id,
                versionId: $scope.model.activeVersion
            };

            DataikuAPI.ml.prediction.getModelDetails(FullModelIdUtils.buildSavedModelFmi(fmiComponents))
                .success(function(data){
                    $scope.modelDetails = data;
                    // Signal to Puppeteer that the content of the element has been loaded and is thus available for content extraction
                    $scope.puppeteerHook_elementContentLoaded = true;
                });

            $scope.zeTrue = true;
            $scope.zeFalse = false;


            $scope.isBinaryClassification = function(){
                return $scope.modelDetails && $scope.modelDetails.coreParams.prediction_type == "BINARY_CLASSIFICATION";
            };

            $scope.isMulticlass = function(){
                return $scope.modelDetails && $scope.modelDetails.coreParams.prediction_type == "MULTICLASS";
            };

            $scope.isRegression = function(){
                return $scope.modelDetails && $scope.modelDetails.coreParams.prediction_type == "REGRESSION";
            };

            $scope.isProbaAware = function(){
                return $scope.modelDetails && $scope.modelDetails.iperf.probaAware && !$scope.noSQLProbas();
            };
        }
        $scope.$on('computablesMapChanged', computablesMapChanged);
        computablesMapChanged(); // May have loaded before this controller (itself ~ajax loaded by template)
    });


    app.controller("ClusteringClusterRecipeEditor", function($scope, $controller, DataikuAPI) {
        $controller("_BaseMLRecipeEditor", {$scope:$scope});
        $controller("_MLRecipeWithOutputSchemaController", {$scope:$scope})
        $scope.enableAutoFixup();

        DataikuAPI.ml.clustering.getPreparedInputSchema($scope.recipe, $scope.desc).success(function(data) {
            $scope.preparedInputSchema = data;
        }).error(setErrorInScope.bind($scope));
    });


    app.controller("ClusteringScoringRecipeEditor", function($scope, $controller, DataikuAPI, Assert) {
        $controller("_BaseMLRecipeEditor", {$scope:$scope});
        $controller("_MLRecipeWithOutputSchemaController", {$scope:$scope})
        $scope.enableAutoFixup();

        DataikuAPI.ml.clustering.getPreparedInputSchema($scope.recipe, $scope.desc).success(function(data) {
            $scope.preparedInputSchema = data;

            $scope.$watch("computablesMap", (nv) => {
                if (nv) {
                    $scope.recipe.inputs['model'].items.forEach(function(inp){
                        var computable = $scope.computablesMap[inp.ref];
                        if (computable.type == "SAVED_MODEL") {
                            $scope.model = computable.model;
                        }
                    });
        
                    Assert.inScope($scope, 'model');
                    Assert.trueish($scope.model.miniTask.taskType == "CLUSTERING", 'not a clustering task');
                }
            })
        }).error(setErrorInScope.bind($scope));
    });


    app.controller("EvaluationRecipeEditor", function($scope, $controller, $q, DataikuAPI, Assert, FullModelIdUtils) {
        $controller("_BaseMLRecipeEditor", {$scope:$scope});
        $controller("_MLRecipeWithOutputSchemaController", {$scope:$scope});
        $controller("_RecipeWithEngineBehavior", {$scope:$scope});
        $controller("EvaluationLabelUtils", {$scope:$scope});

        $scope.uiState = {};

        $scope.enableAutoFixup();

        $scope.selectedEngine = function(){
            return $scope.recipeStatus ? $scope.recipeStatus.selectedEngine.type : undefined;
        };

        $scope.hooks.onRecipeLoaded = function(){
             $scope.hooks.updateRecipeStatus();
        };

        $scope.hooks.getPayloadData = function(){
            return angular.toJson($scope.desc);
        };

        $scope.hooks.updateRecipeStatus = function() {
            var deferred = $q.defer();
            var payload = $scope.hooks.getPayloadData();
            $scope.updateRecipeStatusBase(false, payload).then(function() {
                // $scope.recipeStatus should have been set by updateRecipeStatusBase
                if (!$scope.recipeStatus) return deferred.reject();
                deferred.resolve($scope.recipeStatus);
            });
            return deferred.promise;
        };

        // START differences with scoring

        if ($scope.recipe.outputs['main'] && $scope.recipe.outputs["main"].items && $scope.recipe.outputs["main"].items.length) {
            DataikuAPI.ml.prediction.getPreparedInputSchema($scope.recipe).success(function(data) {
                $scope.preparedInputSchema = data;
            }).error(setErrorInScope.bind($scope));
        }
        
        $scope.hasAllRequiredOutputs = function() {
            if (!$scope.recipe || !$scope.recipe.outputs) {
                return false;
            }
            var out = $scope.recipe.outputs;
            // at least one of the outputs is needed
            if(out.main && out.main.items && out.main.items.length) {
                return true;
            }
            if(out.evaluationStore && out.evaluationStore.items && out.evaluationStore.items.length) {
                return true;
            }
            if(out.metrics && out.metrics.items && out.metrics.items.length) {
                return true;
            }
            return false;
        };

        // END differences with scoring

        var safeSQLAlgorithms = ['LASSO_REGRESSION', 'RIDGE_REGRESSION', 'LEASTSQUARE_REGRESSION',
        'LOGISTIC_REGRESSION', 'DECISION_TREE_CLASSIFICATION', 'DECISION_TREE_REGRESSION', 'MLLIB_LOGISTIC_REGRESSION',
        'MLLIB_DECISION_TREE', 'MLLIB_LINEAR_REGRESSION'];
        $scope.isRiskySQL = function(){
            if(!$scope.modelDetails){
                return false;
            }
            return safeSQLAlgorithms.indexOf($scope.modelDetails.modeling.algorithm) < 0;
        };

        $scope.mayUseContainer = function() {
            if (!$scope.model || !$scope.model.miniTask) return false; // not ready
            return ($scope.model.miniTask.backendType == 'KERAS' || $scope.model.miniTask.backendType == 'PY_MEMORY')
                    && $scope.selectedEngine() == 'DSS';
        };

        $scope.willUseSpark = function(){
            return $scope.selectedEngine() == 'SPARK';
        };

        $scope.versionDisplayFn = function(version) {
            return version.label;
        }

        $scope.versionValueFn = function(version) {
            return version.versionId;
        }

        function computablesMapChanged() {
            if (!$scope.computablesMap) return;

            $scope.recipe.inputs['model'].items.forEach(function(inp){
                var computable = $scope.computablesMap[inp.ref];
                if (computable.type == "SAVED_MODEL") {
                    $scope.model = computable.model;
                }
            });

            Assert.inScope($scope, 'model');
            Assert.trueish($scope.model.miniTask.taskType == "PREDICTION", 'not a prediction task');

            $scope.modelVersions = [{versionId:'', label:"Active version"}];
            DataikuAPI.savedmodels.prediction.getStatus( $scope.model.projectKey, $scope.model.id).success(function(data){
                data.versions.forEach(function(v) {
                    $scope.modelVersions.push({versionId:sanitize(v.versionId), label:'<i>' + moment(v.snippet.trainInfo.startTime).format('YYYY/MM/DD HH:mm')
                    + " " + sanitize(v.snippet.userMeta.name) + (v.active ? ' (active)' : '') + '</i>&nbsp;-&nbsp;<b>' + sanitize(v.versionId) + '</b>'})
                });
                // this copy must be made for angular state detection to detect the change.
                $scope.modelVersions = $scope.modelVersions.slice();
            }).error(setErrorInScope.bind($scope));

            const fmiComponents = {
                projectKey: $scope.model.projectKey,
                savedModelId: $scope.model.id,
                versionId: $scope.model.activeVersion
            };
            DataikuAPI.ml.prediction.getModelDetails(FullModelIdUtils.buildSavedModelFmi(fmiComponents))
                .success(function(data){
                    $scope.modelDetails = data;
                    // Signal to Puppeteer that the content of the element has been loaded and is thus available for content extraction
                    $scope.puppeteerHook_elementContentLoaded = true;
                });

            $scope.zeTrue = true;
            $scope.zeFalse = false;


            $scope.isBinaryClassification = function(){
                return $scope.modelDetails && $scope.modelDetails.coreParams.prediction_type == "BINARY_CLASSIFICATION";
            };

            $scope.isMulticlass = function(){
                return $scope.modelDetails && $scope.modelDetails.coreParams.prediction_type == "MULTICLASS";
            };

            $scope.isRegression = function(){
                return $scope.modelDetails && $scope.modelDetails.coreParams.prediction_type == "REGRESSION";
           };

           $scope.isProbaAware = function(){
                return $scope.modelDetails && $scope.modelDetails.iperf.probaAware;
            };
        };
        $scope.$on('computablesMapChanged', computablesMapChanged);
        computablesMapChanged(); // May have loaded before this controller (itself ~ajax loaded by template)
    });

    app.controller("StandaloneEvaluationRecipeEditor", function($scope, $controller, $q, DataikuAPI, Assert, CodeMirrorSettingService, PMLSettings) {
        $controller("_BaseMLRecipeEditor", {$scope:$scope});
        $controller("_MLRecipeWithoutOutputSchemaController", {$scope:$scope});
        $controller("_RecipeWithEngineBehavior", {$scope:$scope});
        $controller("EvaluationLabelUtils", {$scope:$scope});

        $scope.enableAutoFixup();
        
        $scope.codeMirrorSettingService = CodeMirrorSettingService;

        $scope.selectedEngine = function(){
            return $scope.recipeStatus && $scope.recipeStatus.selectedEngine ? $scope.recipeStatus.selectedEngine.type : undefined;
        };

        $scope.hooks.onRecipeLoaded = function(){
             $scope.hooks.updateRecipeStatus();
        };

        $scope.hooks.getPayloadData = function(){
            return angular.toJson($scope.desc);
        };

        $scope.hooks.updateRecipeStatus = function() {
            var deferred = $q.defer();
            var payload = $scope.hooks.getPayloadData();
            $scope.updateRecipeStatusBase(false, payload).then(function() {
                // $scope.recipeStatus should have been set by updateRecipeStatusBase
                if (!$scope.recipeStatus) return deferred.reject();
                deferred.resolve($scope.recipeStatus);
            });
            return deferred.promise;
        };

        $scope.mayUseContainer = function() {
            return $scope.selectedEngine() == 'DSS';
        };

        $scope.willUseSpark = function(){
            return $scope.selectedEngine() == 'SPARK';
        };

        function computablesMapChanged() {
            if (!$scope.computablesMap) return;
            $scope.recipe.inputs['main'].items.forEach(function(inp){
                var computable = $scope.computablesMap[inp.ref];
                if (computable.type == "DATASET") {
                    $scope.inputColumns = computable.dataset.schema.columns.map(_ => _.name);
                }
            });
        };
        $scope.$on('computablesMapChanged', computablesMapChanged);
        computablesMapChanged(); // May have loaded before this controller (itself ~ajax loaded by template)

        $scope.isBinaryClassification = function(){
            return $scope.desc.predictionType == "BINARY_CLASSIFICATION";
        };

        $scope.isMulticlass = function(){
            return $scope.desc.predictionType == "MULTICLASS";
        };

        $scope.isRegression = function(){
            return $scope.desc.predictionType == "REGRESSION";
       };

       $scope.isProbaAware = function(){
            return $scope.desc.isProbaAware;
        };
        
        $scope.buildNewFeature = function() {
            return {name:'', type:'NUMERIC', role:'INPUT'};
        };
        
        $scope.thresholdOptimizationMetrics = PMLSettings.task.thresholdOptimizationMetrics;
        
        $scope.baseCanSave = $scope.canSave;
        $scope.canSave = function() {
            if ( ($scope.desc.predictionType == 'BINARY_CLASSIFICATION' || $scope.desc.predictionType == 'MULTICLASS')
                && $scope.desc.isProbaAware && (!$scope.desc.probas || !$scope.desc.probas.length))
                return false;
            return $scope.baseCanSave();
        }
    });


    app.directive('scoringColumnsFilter', function(Assert) {
        return {
            restrict: 'AE',
            replace: false,
            templateUrl: "/templates/recipes/scoring-column-filter.html",
            link: function(scope) {
                Assert.inScope(scope, 'preparedInputSchema');

                scope.uiState = scope.uiState || {};
                scope.selectionState = {};

                scope.desc.keptInputColumns = scope.desc.keptInputColumns || [];

                scope.columns = scope.preparedInputSchema.columns
                scope.filteredColumns = scope.columns;

                scope.updateFilteredColumnsSelection = function() {
                    scope.desc.keptInputColumns = scope.columns.filter(function(col){return col.$selected}).map(function(col){return col.name});
                    updateSelectionUiState();
                };

                scope.updateColumnsFilter = function(query) {
                    if (!query || !query.trim().length) {
                        scope.filteredColumns = scope.columns;
                    } else {
                        var lowercaseQuery = query.toLowerCase();
                        scope.filteredColumns = scope.columns.filter(function(col) {col.$filtered = !(col.name.toLowerCase().indexOf(lowercaseQuery) >= 0 || col.type.toLowerCase() == lowercaseQuery); return !col.$filtered});
                    }
                    updateSelectionUiState();
                };

                scope.updateSelectAllColumns = function(selectAll) {
                    scope.filteredColumns.forEach(function(col){col.$selected = col.$filtered ? col.$selected : selectAll});
                    scope.updateFilteredColumnsSelection();
                };

                var updateSelectionUiState = function() {
                    scope.selectionState.all = true;
                    scope.selectionState.any = false;
                    scope.filteredColumns.forEach(function(col) {
                        scope.selectionState.any = scope.selectionState.any || col.$selected;
                        scope.selectionState.all = scope.selectionState.all && col.$selected;
                    });
                };

                scope.columns.forEach(function(col) {
                    col.$selected = scope.desc.keptInputColumns.indexOf(col.name) >= 0;
                });


                updateSelectionUiState();
            }
        };
    });

    app.directive('metricsFilter', function(){
        return {
            templateUrl: '/templates/recipes/metrics-filter.html',
            link: function(scope, element){

                scope.uiState = scope.uiState || {};
                scope.metricsSelectionState = {};
                scope.desc.metrics = scope.desc.metrics || [];

                var metrics;
                if(scope.isBinaryClassification()){
                    metrics = ["precision", "recall", "auc", "f1", "accuracy", "mcc", "costMatrixGain", "hammingLoss", "logLoss", "lift", "calibrationLoss", "customScore"];
                } else if(scope.isMulticlass()){
                    metrics = ["mrocAUC", "recall", "precision", "accuracy", "logLoss", "hammingLoss", "mcalibrationLoss", "customScore"];
                } else {
                    metrics = ["evs", "mae", "mse", "mape", "rmse", "rmsle", "r2", "pearson", "customScore"];
                }
                scope.metrics = metrics.map(function(m){return {name: m}; });

                scope.updateFilteredMetricsSelection = function() {
                    scope.desc.metrics = scope.metrics.filter(function(m){return m.$selected}).map(function(m){return m.name});
                    updateSelectionUiState();
                };

                var updateSelectionUiState = function() {
                    scope.metricsSelectionState.all = true;
                    scope.metricsSelectionState.any = false;
                    scope.metrics.forEach(function(m) {
                        scope.metricsSelectionState.any = scope.metricsSelectionState.any || m.$selected;
                        scope.metricsSelectionState.all = scope.metricsSelectionState.all && m.$selected;
                    });
                };

                scope.metrics.forEach(function(m) {
                    m.$selected = scope.desc.metrics.indexOf(m.name) >= 0;
                });


                updateSelectionUiState();
            }
        };
    });

    app.directive('outputsFilter', function(){
        return {
            templateUrl: '/templates/recipes/outputs-filter.html',
            link: function(scope, element){

                scope.uiState = scope.uiState || {};
                scope.outputSelectionState = {};

                var outputs;
                if(scope.isRegression()){
                    outputs = ["error", "error_decile", "abs_error_decile", "relative_error"];
                } else {
                    outputs = ["prediction_correct"];
                }
                scope.outputs = outputs.map(function(o){return {name: o}; });

                scope.updateFilteredOutputsSelection = function() {
                    scope.desc.outputs = scope.outputs.filter(function(o){return o.$selected}).map(function(o){return o.name});
                    updateSelectionUiState();
                };

                var updateSelectionUiState = function() {
                    scope.outputSelectionState.all = true;
                    scope.outputSelectionState.any = false;
                    scope.outputs.forEach(function(o) {
                        scope.outputSelectionState.any = scope.outputSelectionState.any || o.$selected;
                        scope.outputSelectionState.all = scope.outputSelectionState.all && o.$selected;
                    });
                };

                scope.outputs.forEach(function(o) {
                    o.$selected = scope.desc.outputs.indexOf(o.name) >= 0;
                });


                updateSelectionUiState();
            }
        };
    });
})();

(function() {
'use strict';

var app = angular.module('dataiku.controllers');


app.controller('RecipesListController', function ($controller, $scope, $state, $stateParams,
       DataikuAPI, TaggableObjectsService, Dialogs, TopNav) {

    $controller('_TaggableObjectsListPageCommon', {$scope: $scope});

    TopNav.setLocation(TopNav.TOP_FLOW, "recipes", TopNav.TABS_NONE, null);
    TopNav.setItem(null);

    $scope.selection = $.extend({
        filterQuery: {
            userQuery: '',
            tags: [],
            interest: {
                starred: '',
            },
        },
        filterParams: {
            userQueryTargets: ["name","tags","type"],
            propertyRules: {tag:"tags"},
        },
        orderQuery: "-lastModifiedOn",
        orderReversed: false,
    }, $scope.selection || {});

    $scope.sortBy = [
        { value: 'name', label: 'Name' },
        { value: 'type', label: 'Type' },
        { value: '-lastModifiedOn', label: 'Last modified' }
    ];

    $scope.sortCookieKey = 'recipes';
    $scope.maxItems = 20;

    $scope.list = function() {
        DataikuAPI.flow.recipes.listHeads($stateParams.projectKey, $scope.tagFilter).success(function(data) {
            $scope.listItems = data.items;
            $scope.restoreOriginalSelection();
        }).error(setErrorInScope.bind($scope));
    };
    $scope.list() ;


    /* Specific actions */

    $scope.goToItem = function(recipe){
        $state.transitionTo('flow-editor.recipe', {recipeName : recipe.name});
    };
});

}());
(function(){
'use strict';

    const app = angular.module('dataiku.services');

    app.factory('Expressions', function($stateParams, DataikuAPI, Logger) {

        function inColName(value) {
            return "<span class=\"input-column-name\">" + sanitize(value) + "</span>";
        }
        function numLiteral(value) {
            return "<span class=\"num-literal\">" + sanitize(value) + "</span>";
        }
        function anumLiteral(value) {
            if (value == null || value.length == 0) {
                return '<span class="alphanum-literal">\'\'</span>';
            } else {
                return "<span class=\"alphanum-literal\">" + sanitize(value) + "</span>";
            }
        }

        var operators = [ //names should be unique
            {
                name: "empty array",
                label: "is an empty array",
                params: [],
                enableFor: ["array"],
                repr : function(cond) { return inColName(cond["input"]) + " is an empty array"; }
            },
            {
                name: "not empty array",
                label: "is not an empty array",
                params: [],
                enableFor: ["array"],
                repr : function(cond) { return inColName(cond["input"]) + " is not an empty array"; }
            },
            {
                name: "array contains",
                label: "contains",
                params: ["string"],
                enableFor: ["array"],
                repr : function(cond) { return inColName(cond["input"]) + " contains " + anumLiteral(cond["string"]); },
                meaning: "contains"
            },

            {
                name: "not empty",
                label: "is defined",
                params: [],
                enableFor: ["string"],
                repr : function(cond) { return inColName(cond["input"]) + " is defined"; },
                meaning: "is defined"
            },
            {
                name: "is empty",
                label: "is not defined",
                params: [],
                enableFor: ["string"],
                repr : function(cond) { return inColName(cond["input"]) + " is not defined"; },
                meaning: "is not defined"
            },
            {
                name: "not empty string",
                label: "is defined",
                params: [],
                disableFor: ["string"],
                repr : function(cond) { return inColName(cond["input"]) + " is defined"; },
                meaning: "is defined"
            },
            {
                name: "empty string",
                label: "is not defined",
                params: [],
                disableFor: ["string"],
                repr : function(cond) { return inColName(cond["input"]) + " is not defined"; },
                meaning: "is not defined"
            },

            {
                name: "true",
                label: "is true",
                params: [],
                enableFor: ["boolean"],
                repr : function(cond) { return inColName(cond["input"]) + " is true"; },
                meaning: "is true",
                approximateEquivalences: ["==", "== [column]"]
            },
            {
                name: "false",
                label: "is false",
                params: [],
                enableFor: ["boolean"],
                repr : function(cond) { return inColName(cond["input"]) + " is false"; },
                meaning: "is false",
                approximateEquivalences: ["==", "== [column]"]
            },

            {
                name: "== [string]",
                label: "equals",
                params: ["string"],
                disableFor: ["num", "date", "boolean"],
                repr : function(cond) { return inColName(cond["input"]) + " == " + anumLiteral(cond["string"]); },
                meaning: "==",
                approximateEquivalences: ["is true", "== [column]"]
            },
            {
                name: "== [string]i",
                label: "equals (case insensitive)",
                params: ["string"],
                disableFor: ["num", "date", "boolean"],
                repr : function(cond) { return inColName(cond["input"]) + " == " + anumLiteral(cond["string"]) + " (insensitive)"; },
                meaning: "==",
                approximateEquivalences: ["is true", "== [column]"]
            },
            {
                name: "!= [string]",
                label: "is different from",
                params: ["string"],
                disableFor: ["num", "date", "boolean"],
                repr : function(cond) { return inColName(cond["input"]) + " != " + anumLiteral(cond["string"]); },
                meaning: "!=",
                approximateEquivalences: ["!= [column]"]
            },

            {
                name: "== [NaNcolumn]",
                label: "is the same as ",
                params: ["col"],
                disableFor: ["num"],
                category: "column",
                repr : function(cond) { return inColName(cond["input"]) + " == " + inColName(cond["col"]); },
                meaning: "== [column]",
                approximateEquivalences: ["=="]
            },
            {
                name: "!= [NaNcolumn]",
                label: "is different from ",
                params: ["col"],
                disableFor: ["num"],
                category: "column",
                repr : function(cond) { return inColName(cond["input"]) + " != " + inColName(cond["col"]); },
                meaning: "!= [column]",
                approximateEquivalences: ["!="]
            },

            {
                name: "== [number]",
                label: "==",
                params: ["num"],
                enableFor: ["num"],
                repr : function(cond) { return inColName(cond["input"]) + " == " + numLiteral(cond["num"]); },
                meaning: "==",
                approximateEquivalences: ["is true", "== [column]"]
            },
            {
                name: "!= [number]",
                label: "!=",
                params: ["num"],
                enableFor: ["num"],
                repr : function(cond) { return inColName(cond["input"]) + " != " + numLiteral(cond["num"]); },
                meaning: "!=",
                approximateEquivalences: ["!= [column]"]
            },
            {
                name: ">  [number]",
                label: "> ",
                params: ["num"],
                enableFor: ["num"],
                repr : function(cond) { return inColName(cond["input"]) + " > " + numLiteral(cond["num"]); },
                meaning: ">",
                approximateEquivalences: [">=", ">  [column]", ">= [column]"]
            },
            {
                name: "<  [number]",
                label: "< ",
                params: ["num"],
                enableFor: ["num"],
                repr : function(cond) { return inColName(cond["input"]) + " < " + numLiteral(cond["num"]); },
                meaning: "<",
                approximateEquivalences: ["<=", "<  [column]", "<= [column]"]
            },
            {
                name: ">= [number]",
                label: ">=",
                params: ["num"],
                enableFor: ["num"],
                repr : function(cond) { return inColName(cond["input"]) + " >= " + numLiteral(cond["num"]); },
                meaning: ">=",
                approximateEquivalences: [ ">", ">= [column]", ">  [column]"]
            },
            {
                name: "<= [number]",
                label: "<=",
                params: ["num"],
                enableFor: ["num"],
                repr : function(cond) { return inColName(cond["input"]) + " <= " + numLiteral(cond["num"]); },
                meaning: "<=",
                approximateEquivalences: ["<", "<= [column]", "<  [column]"]
            },

            {
                name: "== [date]",
                label: "equals",
                params: ["date", "time", "unit"],
                enableFor: ["date"],
                repr : function(cond) { return inColName(cond["input"]) + " == " + numLiteral(cond["date"]) + " " + numLiteral(cond["time"]) + " (~ " + anumLiteral(cond["unit"]) + ")"; },
                meaning: "==",
                approximateEquivalences: ["is true", "== [column]"]
            },
            {
                name: ">= [date]",
                label: "is after",
                params: ["date", "time"],
                enableFor: ["date"],
                repr : function(cond) { return inColName(cond["input"]) + " >= " + numLiteral(cond["date"]) + " " + numLiteral(cond["time"]) ; },
                meaning: ">=",
                approximateEquivalences: [">", ">= [column]", ">  [column]"]
            },
            {
                name: "<  [date]",
                label: "is before",
                params: ["date", "time"],
                enableFor: ["date"],
                repr : function(cond) { return inColName(cond["input"]) + " <=" + numLiteral(cond["date"]) + " " + numLiteral(cond["time"]) ; },
                meaning: "<",
                approximateEquivalences: ["<=", "<  [column]", "<= [column]"]
            },
            {
                name: ">< [date]",
                label: "is between",
                params: ["date", "date2", "time", "time2"],
                enableFor: ["date"],
                repr : function(cond) {
                    return numLiteral(cond["date"]) + " " + numLiteral(cond["time"]) +
                        " <= " +
                        inColName(cond["input"]) +
                        " < " +
                        numLiteral(cond["date2"]) + " " + numLiteral(cond["time2"]);
                },
                approximateEquivalences: [">=", ">", ">= [column]", ">  [column]"] //debatable
            },

            {
                name: "== [column]",
                label: "==",
                params: ["col"],
                enableFor: ["num"],
                category: "column",
                repr : function(cond) { return inColName(cond["input"]) + " == " + inColName(cond["col"]); },
                meaning: "== [column]",
                approximateEquivalences: ["=="]
            },
            {
                name: "!= [column]",
                label: "!=",
                params: ["col"],
                enableFor: ["num"],
                category: "column",
                repr : function(cond) { return inColName(cond["input"]) + " != " + inColName(cond["col"]); },
                meaning: "!= [column]",
                approximateEquivalences: ["!="]
            },
            {
                name: ">  [column]",
                label: " >",
                params: ["col"],
                enableFor: ["num"],
                category: "column",
                repr : function(cond) { return inColName(cond["input"]) + " > " + inColName(cond["col"]); },
                meaning: ">  [column]",
                approximateEquivalences: [">= [column]", ">", ">="]
            },
            {
                name: "<  [column]",
                label: " <",
                params: ["col"],
                enableFor: ["num"],
                category: "column",
                repr : function(cond) { return inColName(cond["input"]) + " < " + inColName(cond["col"]); },
                meaning: "<  [column]",
                approximateEquivalences: ["<= [column]", "<", "<="]
            },
            {
                name: ">= [column]",
                label: ">=",
                params: ["col"],
                enableFor: ["num"],
                category: "column",
                repr : function(cond) { return inColName(cond["input"]) + " >= " + inColName(cond["col"]); },
                meaning: ">= [column]",
                approximateEquivalences: [">  [column]", ">=", ">"]
            },
            {
                name: "<= [column]",
                label: "<=",
                params: ["col"],
                enableFor: ["num"],
                category: "column",
                repr : function(cond) { return inColName(cond["input"]) + " <= " + inColName(cond["col"]); },
                meaning: "<= [column]",
                approximateEquivalences: ["<  [column]", "<=", "<"]
            },

            {
                name: "contains",
                label: "contains",
                params: ["string"],
                enableFor: ["string"],
                repr : function(cond){
                    return inColName(cond["input"]) + " contains " + anumLiteral(cond["string"]);
                },
                meaning: "contains"
            },
            {
                name: "regex",
                label: "matches the regex",
                params: ["string"],
                enableFor: ["string"],
                repr : function(cond) { return inColName(cond["input"]) + " =~ /" + anumLiteral(cond["string"]) + "/"; },
                approximateEquivalences: ["=="] //debatable
            }
        ];


        { //debug check for operator names
            var namesSoFar = [];
            for (var i = 0; i < operators.length; ++i) {
                var name = operators[i].name;
                if (namesSoFar.indexOf(name) >= 0) {
                    Logger.error("Duplicate operator name ("+name+")");
                }
                namesSoFar.push(name);
            }
        }

        var genericType = function(type) {
            type = (type||'').toLowerCase();
            if (["tinyint", "smallint", "int", "bigint", "float", "double"].indexOf(type) > -1) {
                return "num";
            }
            return type;
        };

        var getDefaultOperator = function(type) { //for default selection in UI
            switch(genericType(type)) {
                case "array": return "not empty array";
                case "boolean": return "true";
                case "date": return ">= [date]";
                case "num": return "== [number]";
                case "string": return "contains";
                default: return "not empty";
            }
        };

        const DATE_UNITS = [
            {name:"seconds",label:"second"},
            {name:"minutes",label:"minute"},
            {name:"hours",label:"hour"},
            {name:"days",label:"day"},
            {name:"weeks",label:"week"},
            {name:"months",label:"month"},
            {name:"years",label:"year"}
       ];

        var has = function(t,v) { if(!t) return false; return t.indexOf(v) > -1; };

        var getOperators = function(type) {
            if (!type) return operators;
            type = genericType(type);
            return operators
                .filter(function(op) {
                    return has(op.enableFor, type) ||  (!op.enableFor && !has(op.disableFor, type));
                })
                .map(function(op) {
                    return {name: op.name, label:op.label, params:op.params, category:op.category, meaning:op.meaning, approximateEquivalences: op.approximateEquivalences};
                });
        };

        var getOperatorByName = function(name){
            return operators.find(op => op.name == name);
        };

        var quoteString = function(str) {
            if (!str) return '';
            if (str.indexOf('"') < 0) return '"'+str+'"';
            if (str.indexOf("'") < 0) return "'"+str+"'";
            return "'"+str.replace(/'/g, "\\'")+"'";
        };

        // support for column names which are invalid grel identifiers
        var val = function(colName) {
            return "val("+quoteString(colName)+")";
        };
        var boolval = function(colName) {
            return "asBool(val("+quoteString(colName)+"))";
        };

        var validateExpression = function (expression, schema) {
            return DataikuAPI.flow.recipes.filter.validateExpression(expression, JSON.stringify(schema), $stateParams.projectKey);
        };

        var service = {
            getOperators: getOperators,
            getDefaultOperator: getDefaultOperator,
            validateExpression: validateExpression,
            genericType: genericType,
            dateUnits: DATE_UNITS,
            getOperatorByName: getOperatorByName
        };
        return service;
    });

})();


(function(){
'use strict';

    const app = angular.module('dataiku.directives.widgets');

    app.directive('filterEditor', function($timeout, Expressions, DataikuAPI, Logger, $stateParams, CodeMirrorSettingService) {
        return {
            templateUrl: '/templates/recipes/fragments/filter-editor.html',
            restrict: 'EA',
            scope: true,
            link : function(scope, element, attrs) {
                if ( attrs.hideSqlFilter ) {
                    scope.hideSqlFilter = scope.$eval(attrs.hideSqlFilter);
                } else {
                    // the parent may have set it
                }
                var manuallyEditedCustomFormula; //save the expression if it was manually edited to restore it if necessary
                var manuallyEditedSQLExpression; //save the expression if it was manually edited to restore it if necessary
                var automaticallyGeneratedCustomFormula; //save the expression if it was manually edited to restore it if necessary
                var automaticallyGeneratedSQLExpression; //save the expression if it was manually edited to restore it if necessary
                var timeout;//buffer validate expression AJAX calls

                DataikuAPI.flow.recipes.generic.getVariables($stateParams.projectKey).success(function(data) {
                    scope.recipeVariables = data;
                }).error(setErrorInScope.bind(scope));

                scope.$parent.$watch(attrs.schema, function(nv) {
                    scope.schema = nv;
                });
                scope.onExpressionChange = function(){
                    scope.revalidateExpression();
                    manuallyEditedCustomFormula = scope.filterDesc.expression;
                };

                scope.onFilterModeChange = function() {
                    scope.revalidateExpression();
                };

                scope.onSQLChange = function(){
                    manuallyEditedSQLExpression = scope.filterDesc.expression;
                };

                scope.revalidateExpression = function(){
                    scope.filterDesc.$status.validated = false;
                    $timeout.cancel(timeout);
                    if (!scope.filterDesc.expression) return;
                    scope.validationPending = true;
                    timeout = $timeout(scope.validateExpression, 400);
                };


                scope.updateUiData = function(){
                    delete scope.filterDesc.language;
                    // handle mode shifts
                    if (uiData.mode != lastUiData.mode) {
                        if (lastUiData.mode == 'SQL') {
                            // no keeping the expression for the other modes
                        } else if (lastUiData.mode == 'CUSTOM') {
                            // if moving to SQL try putting the converted GREL expression
                            var setTranslatedExpression = null;
                            if (uiData.mode == 'SQL' && manuallyEditedSQLExpression == null) {
                                setTranslatedExpression = function(data) {
                                    if (data.ok) {
                                        scope.filterDesc.expression = data.sql;
                                        manuallyEditedSQLExpression = null;
                                    }
                                };
                            }
                            if (setTranslatedExpression != null) {
                                Expressions.validateExpression(scope.filterDesc.expression, getSchema())
                                .success(setTranslatedExpression)
                                .error(setErrorInScope.bind(scope));
                            }
                        } else {
                            var setTranslatedExpression = null;
                            if (uiData.mode == 'SQL' && manuallyEditedSQLExpression == null) {
                                setTranslatedExpression = function(data) {
                                    if (data.ok) {
                                        scope.filterDesc.expression = data.sql;
                                        manuallyEditedSQLExpression = null;
                                    }
                                };
                            } else if (uiData.mode == 'CUSTOM' && manuallyEditedCustomFormula == null) {
                                setTranslatedExpression = function(data) {
                                    if (data.ok) {
                                        scope.filterDesc.expression = data.grel;
                                        manuallyEditedCustomFormula = null;
                                    }
                                };
                            }
                            if (setTranslatedExpression != null) {
                                var lastFilterDesc = angular.copy(scope.filterDesc);
                                lastFilterDesc.uiData = lastUiData;
                                DataikuAPI.flow.recipes.filter.validateAst(lastFilterDesc, $stateParams.projectKey)
                                    .success(setTranslatedExpression)
                                    .error(setErrorInScope.bind(scope));
                            }
                        }
                    }
                    lastUiData = angular.copy(uiData);
                };

                var getSchema = function() {
                    if (scope.filterDesc.$status && scope.filterDesc.$status.schema) {
                        return scope.filterDesc.$status.schema;
                    } else if (scope.schema) {
                        return scope.schema;
                    } else {
                        return {columns: []};
                    }
                };

                scope.hasSchema = function() {
                    return (scope.filterDesc.$status && scope.filterDesc.$status.schema) || scope.schema;
                }

                scope.validateExpression = function() {
                    if (!scope.filterDesc.enabled || !scope.filterDesc.expression || !scope.hasSchema()) {
                        return;
                    }
                    scope.validationPending = false;
                    scope.validationInProgress = scope.validationInProgress ? scope.validationInProgress+1 : 1;
                    Expressions.validateExpression(scope.filterDesc.expression, getSchema())
                        .success(function(data) {
                            if (data.ok && scope.mustRunInDatabase && !data.fullyTranslated) {
                                data.ok = false;
                                data.message = "this expression cannot be translated to SQL."
                            }
                            scope.filterDesc.$status = scope.filterDesc.$status || {};
                            $.extend(scope.filterDesc.$status, data);
                            scope.filterDesc.$status.validated = true;
                            scope.validationInProgress--;
                            automaticallyGeneratedSQLExpression = data.sql;
                            manuallyEditedSQLExpression = null;
                        })
                        .error(function(data) {
                            scope.validationInProgress--;
                            setErrorInScope.bind(scope);
                        });
                };

                scope.getColumns = function() {
                    var schema = getSchema();
                    return schema && schema.columns || [];
                };

                scope.clickedOnColumnName = function(colName) {
                    scope.addFormulaElement(colName.match(/^[a-z0-9_]+$/i) ? colName : `val('${colName}')`);
                };

                scope.clickedOnVariableName = function(varName) {
                    scope.addFormulaElement('variables["' + varName + '"]');
                };

                scope.addFormulaElement = function(code) {
                    // replace selection and focuses editor
                    var cm = $('.CodeMirror', element).get(0).CodeMirror;
                    cm.replaceSelection(code);
                    cm.focus();
                };

                // --- init parameters given in attributes:
                var defaults = {
                    modelLabel: "Keep only rows that satisfy",
                    mustRunInDatabase: false,
                    filterUpdateCallback: null,
                    dataset: null,
                    schema: null,
                    filterDesc: null
                };

                var regenInternalFields = function() {
                    $.each(defaults, function(param, value) {
                        scope[param] = scope.$eval(attrs[param]) || value;
                    });
                    if (!scope.filterDesc) {
                        Logger.error('"filter-desc" attribute is required by directive filterEditor', attrs);
                    }
                    if (!scope.schema && !scope.dataset && !(scope.filterDesc.$status && scope.filterDesc.$status.schema)) {
                        Logger.error('filterEditor must have either a dataset or a schema', attrs);
                    }

                };

                regenInternalFields();

                var columns = function(){return scope.getColumns().map(function(c){return c.name}); };
                scope.editorOptions = {
                        onLoad: function(cm) {
                            cm.on("keyup", function(cm, evt) {
                                if (evt.type == 'keyup') {
                                    /* Ignore tab, esc, and navigation/arrow keys */
                                    if (evt.keyCode == 9 || evt.keyCode == 27 || (evt.keyCode>= 33 && evt.keyCode <= 40)) {
                                        return;
                                    } else {
                                        var options = {
                                            columns: columns,
                                            completeSingle: false
                                        }
                                        CodeMirror.commands.autocomplete(cm, null, options);
                                    }
                                }
                            });
                        },
                        mode:'text/grel',
                        theme:'elegant',
                        variables: columns,
                        lineNumbers : false,
                        lineWrapping : true,
                        indentUnit: 4,
                        autofocus: true
                    };
                scope.sqlEditorOptions = CodeMirrorSettingService.get('text/x-sql');
                scope.sqlEditorOptions.variables = columns;
                scope.sqlEditorOptions.autofocus = true;

                // --- init uiData:
                scope.filterDesc.uiData = scope.filterDesc.uiData || {};
                var uiData = scope.filterDesc.uiData;
                var lastUiData = angular.copy(uiData);
                uiData.conditions = uiData.conditions || [{}];
                uiData.mode = uiData.mode || '&&';
                scope.conditions = uiData.conditions; //short name


                scope.$watch(
                    'filterDesc.uiData',
                    function(nv, ov){
                        if(angular.equals(ov, nv)) return;
                        scope.updateUiData();
                    },
                    true
                );

                scope.$watch(
                    'filterDesc.enabled',
                    scope.updateUiData,
                    true
                );

                scope.$watch(
                    'mustRunInDatabase',
                    scope.validateExpression
                );

                if (scope.filterUpdateCallback) {
                    scope.$watch('[filterDesc.expression, filterDesc.enabled, filterDesc.uiData]',
                        function(nv, ov){
                            if(angular.equals(ov, nv)) return;
                            scope.filterUpdateCallback(scope.filterDesc);
                        },
                        true
                    );
                }

                scope.filterDesc.$status = scope.filterDesc.$status || {}; //status is not saved on server

                if (scope.filterDesc.expression) {
                    scope.validateExpression();
                }
                scope.$watch('recipeStatus', function() {
                    // in case this filter is in a visual recipe, make sure to update the internal
                    // flags when the engine or something else changes
                    regenInternalFields();
                    //scope.revalidateExpression();
                },true);
            }
        };
    });

    app.directive('filterConditionsEditor', function(Expressions, Logger) {
        return {
            templateUrl : '/templates/recipes/fragments/filter-conditions-editor.html',
            restrict: 'AE',
            link : function(scope, element, attrs) {
                var mapToAttr = function(arr, attr) {
                    return arr.map(function(el){return el[attr]; });
                }
                var updateIfNotAllowed = function(currentValue, allowedValues, defaultValue) {
                    if (!allowedValues || !allowedValues.length) {
                        Logger.warn("WARNING: no allowedValues");
                        return defaultValue;
                    }
                    if (allowedValues.indexOf(currentValue) > -1) return currentValue;
                    if (defaultValue) return defaultValue;
                    return allowedValues[0];
                };

                scope.update = function(cond) {
                    cond.input = updateIfNotAllowed(cond.input, mapToAttr(scope.getColumns(), 'name'));
                    cond.col = updateIfNotAllowed(cond.col, mapToAttr(scope.getColumnsExcept(cond.input), 'name'));
                    var col = scope.getColumn(cond.input);
                    if (col) {
                        var tmp = cond.operator
                        var type = scope.getColumn(cond.input).type;
                        cond.operator = updateIfNotAllowed(
                            cond.operator,
                            mapToAttr(Expressions.getOperators(type), 'name'),
                            Expressions.getDefaultOperator(type)
                            );
                    }
                };

                scope.getColumn = function(name){
                    return scope.getColumns().find(col => col.name == name);
                };

                scope.populateWithDefaults = function(cond) {
                    var today = (new Date()).toISOString().split('T')[0];
                    if (scope.operatorHasParam(cond.operator, 'date')) {
                        cond.date = cond.date || today;
                        cond.time = cond.time || "00:00";
                    }
                    if (scope.operatorHasParam(cond.operator, 'date2')) {
                        cond.date2 = cond.date2 || today;
                        cond.time2 = cond.time2 || "00:00";
                    }
                }

                scope.getColumnGenericType = function(name) {
                    if (!name) return;
                    var col = scope.getColumns().find(col => col.name == name);
                    if (!col) return;
                    return Expressions.genericType(col.type);
                };

                scope.getColumnsExcept = function(name) {
                    return scope.getColumns().filter(col => col.name != name);
                };
                var opss = {}
                /* returns an array of operators that can act on a variable with specified type */
                scope.getOperators = function(type) {
                    if (type in opss) return opss[type]
                    opss[type] = Expressions.getOperators(type);
                    return opss[type]
                };

                scope.dateUnits = Expressions.dateUnits;
                var ocs = {};
                /* returns a list of String indicating the category (for now: "column" or "") */
                scope.getOperatorsCategories = function(type) {
                    if (type in ocs) return ocs[type]
                    ocs[type] = scope.getOperators(type).map(op => op.category || "");
                    return ocs[type]
                };

                scope.getOperator = function(name){
                    return Expressions.getOperators().find(op => op.name == name);
                };

                scope.operatorHasParam = function(operatorName, paramName){
                    if (!operatorName) return false;
                    return scope.getOperator(operatorName).params.includes(paramName);
                };

                scope.insert = function(index){
                    const newCondition = {num: 0};
                    scope.update(newCondition);
                    scope.conditions.push(newCondition);
                };

                scope.remove = function(index){
                    scope.conditions.splice(index, 1);
                };

                scope.intialiseAllData = function() {
                    scope.conditions.forEach(c => {
                        scope.update(c)
                    });
                }

                scope.$watch("hasSchema()", function(nv, ov) {
                    if (nv && nv!=ov && scope.filterDesc.enabled) {
                        scope.intialiseAllData();
                    }
                });

                scope.$watch("filterDesc.enabled", function(nv, ov) {
                    if (nv && scope.hasSchema()) {
                        scope.intialiseAllData();
                    }
                });
                scope.keyDownOnParam = function(event, index) {
                    if (event.keyCode == 13 && index+1 == scope.conditions.length) {
                        scope.insert(index+1);
                    }
                };

                scope.formatedColName = function(col) {
                    return col.name + ' ('+col.type+')';
                };
            }
        };
    });

    app.directive('filterCondition', function (Expressions) {
        return {
            restrict:'A',
            link: function($scope, element, attrs) {
                /*
                 * When changing filter condition's column (c.input), looking for an equivalent operator (c.operator)
                 * based on the current operator meaning or the current operator approximate equivalent meanings (as a fallback).
                 * Otherwise resetting it to default.
                 * example:
                 * - filter rule used to be 'DATE_COLUMN' is defined
                 * - user changes 'DATE_COLUMN' to 'STRING_COLUMN'
                 * - if we can find an operator with the same meaning as 'is defined' for string columns, then we update c.operator to it.
                 */
                $scope.$watch('c.input', function(nv, ov) {
                    if (nv !== undefined && ov !== undefined && nv != ov) {
                        let newType = $scope.getColumnGenericType(nv)
                        let newOperators = $scope.getOperators(newType);
                        let oldOperator = $scope.getOperators($scope.getColumnGenericType(ov)).find(o => o.name == $scope.c.operator);
                        $scope.c.operator = Expressions.getDefaultOperator(newType); // setting first as default in case we don't find an equivalence
                        if (oldOperator) {
                            let equivalentOperator;
                            //looking for exact equivalence
                            if (oldOperator.meaning) {
                                equivalentOperator = newOperators.find(o => o.meaning == oldOperator.meaning);
                            }
                            //looking for approximate equivalence
                            if (!equivalentOperator && oldOperator.approximateEquivalences) {
                                for (let i=0; i<oldOperator.approximateEquivalences.length; i++) {
                                    let approximateEquivalence = oldOperator.approximateEquivalences[i];
                                    equivalentOperator = newOperators.find(o => o.meaning == approximateEquivalence);
                                    if (typeof(equivalentOperator) !== 'undefined') {
                                        break;
                                    }
                                }
                            }
                            if (equivalentOperator) {
                                $scope.c.operator = equivalentOperator.name;
                            }
                        }
                    }
                })
            }
        }
    });

    app.directive('inputDateConversion', function ($timeout) {
        return {
            scope:false,
            restrict:'A',
            link: function($scope, element, attrs) {
                $scope.$watch(attrs.inputDateConversion, function(nv) {
                    if (nv == null) return;
                    var newVal = nv;
                    var curVal = $(element).val()
                    if (curVal == newVal) return;
                    var date = new Date();
                    date.setMilliseconds(0);
                    date.setSeconds(0);
                    date.setHours(0);
                    date.setMinutes(0);
                    date.setDate(parseInt(newVal.substring(8,10)));
                    date.setMonth(parseInt(newVal.substring(5,7))-1);
                    date.setFullYear(parseInt(newVal.substring(0,4)));
                    $scope[attrs.ngModel] = date
                    $(element).val(newVal);
                });
                $scope.$watch(attrs.ngModel, function(nv) {
                    if (nv == null) return;
                    var newVal = $(element).val()
                    var curVal = $scope.$eval(attrs.inputDateConversion);
                    if (curVal == newVal) return;
                    // timezone hell : use val() instead of getting the date
                    $scope.$eval(attrs.inputDateConversion + '="' + newVal + '"')
                });
            }
        };
    });

    app.directive('inputTimeConversion', function ($timeout) {
        return {
            scope:false,
            restrict:'A',
            link: function($scope, element, attrs) {
                $scope.$watch(attrs.inputTimeConversion, function(nv) {
                    if (nv == null) return;
                    var newVal = nv;
                    var curVal = $(element).val().substring(0,5)
                    if (curVal == newVal) return;
                    var date = new Date();
                    date.setMilliseconds(0);
                    date.setSeconds(0);
                    date.setHours(parseInt(newVal.substring(0,2)));
                    date.setMinutes(parseInt(newVal.substring(3,5)));
                    $scope[attrs.ngModel] = date;
                    $(element).val(newVal); // to avoid infinite digest
                    $timeout(function() {$(element).val(newVal);}); // because firefox likes to format time with full precision
                });
                $scope.$watch(attrs.ngModel, function(nv) {
                    if (nv == null) return;
                    var newVal = $(element).val().substring(0,5)
                    var curVal = $scope.$eval(attrs.inputTimeConversion);
                    if (curVal == newVal) return;
                    $scope.$eval(attrs.inputTimeConversion + '="' + newVal + '"')
                });
            }
        };
    });

    app.directive('inputFilterBlock', function (CreateModalFromTemplate) {
        return {
            templateUrl : '/templates/recipes/fragments/filter-management-block.html',
            restrict: 'AE',
            scope: {
                filter: '=',
                dataset: '=',
                schema: '=',
                recipeStatus: '=',
                onChange: '&',
                hideSqlFilter: '=',
                recipeVariables: '='
            },
            link : function(scope, element, attrs) {
                scope.showFilterModal = function() {
                    scope.filter = scope.filter || {};
                    var newScope = scope.$new();
                    newScope.dataset = scope.dataset;
                    newScope.schema = scope.schema;
                    newScope.filter = scope.filter;
                    newScope.recipeVariables = scope.recipeVariables;
                    CreateModalFromTemplate('/templates/recipes/fragments/filter-modal.html', newScope, null, function(newScope){
                        newScope.hideSqlFilter = scope.hideSqlFilter || false;
                    });
                };

                scope.ok = function() {
                    if (scope.onChange) {
                        scope.onChange();
                    }
                }
            }
        };
    });

    app.directive('inlineFilterEditor', function(DataikuAPI, $stateParams) {
        return {
            templateUrl : '/templates/widgets/inline-filter-editor-simple.html',
            scope: {
                filter: '=',
                dataset: '=',
                schema: '='
            },
            link : function(scope, element, attrs) {
                DataikuAPI.flow.recipes.generic.getVariables($stateParams.projectKey).success(function(data) {
                    scope.recipeVariables = data;
                }).error(setErrorInScope.bind(scope));
            }
        };
    });

    app.directive('grelReference', function (CachedAPICalls, $filter) {
        return {
            templateUrl : '/templates/widgets/grel-reference.html',
            link : function($scope, element, attrs) {
                CachedAPICalls.customFormulasReference.success(function(data) {
                    $scope.grelSyntax = [];
                    $scope.grelSyntax.push({type: 'Columns access', name:'column_name',unrealFunction:true, returns:'the value of a given cell', description:'column_name must be a valid identifier'});
                    $scope.grelSyntax.push({type: 'Columns access', name:'numval',params:'column', returns:'the numerical value of a given cell', description:''});
                    $scope.grelSyntax.push({type: 'Columns access', name:'strval',params:'column', returns:'the String value of a given cell', description:'strval returns an empty string for cells with no value.'});
                    $scope.grelSyntax.push({type: 'Columns access', name:'strval',params:'column, defaultValue', returns:'the String value of a given cell of defaultValue if the cell is empty', description:''});
                    $scope.grelSyntax.push({type: 'Columns access', name:'cells',params:'', isField:true, returns:'Returns a dictionary of cells of the current row', description:'Use cells["columnName"].value to access the value of a cell. This returns null for cells with no value'});
                    data.forEach(function(f) {
                        f.type = 'Functions';
                        $scope.grelSyntax.push(f);
                    });
                    $scope.refreshFilteredGrelFunctions();
                }).error(setErrorInScope.bind($scope));

                $scope.editing = {grelFilter : ''};
                $scope.refreshFilteredGrelFunctions = function() {
                    var filteredSyntax = $scope.grelSyntax;
                    $scope.filteredGrelFunctions = [];
                    if ( $scope.grelSyntax == null ) {
                        return;
                    }
                    if ( $scope.editing.grelFilter != null && $scope.editing.grelFilter.length > 0 ) {
                        filteredSyntax = $filter('filter')($scope.grelSyntax, $scope.editing.grelFilter);
                    }
                    // group by type
                    var lastGroup = null;
                    filteredSyntax.forEach(function(f) {
                        if ( lastGroup == null || lastGroup.name != f.type ) {
                            if ( lastGroup != null ) {
                                $scope.filteredGrelFunctions.push(lastGroup);
                            }
                            lastGroup = {name:f.type, functions:[]};
                        }
                        lastGroup.functions.push(f);
                    });
                    if ( lastGroup != null ) {
                        $scope.filteredGrelFunctions.push(lastGroup);
                    }

                };
                $scope.$watch('editing.grelFilter', function() {
                    $scope.refreshFilteredGrelFunctions();
                }, true);
            }
        };
    });
    app.directive('grelExamples', function (CachedAPICalls, $filter) {
        return {
            templateUrl : '/templates/widgets/grel-examples.html',
            link : function($scope, element, attrs) {
                // nothing here (yet?)
            }
        };
    });
    app.directive('grelReferenceAndExamples', function (CachedAPICalls, $filter) {
        return {
            templateUrl : '/templates/widgets/grel-reference-and-examples.html',
            link : function($scope, element, attrs) {
                // nothing here (yet?)
            }
        };
    });
    
    app.filter("filterNiceRepr", function(Expressions){
        function translateConds(input) {
            return input.uiData.conditions.map(function(cond){
                var op = Expressions.getOperatorByName(cond["operator"]);
                if (!op) return "Unknown op: " + cond["operator"];
                if (op.repr) return op.repr(cond);
                else return sanitize(JSON.stringify(cond));
            });
        }
        return function(input) {
            function anumLiteral(value) {
                return "<span class='alphanum-literal flex'>" + sanitize(value) + "</span>";
            }
            if (!input || !input.enabled || !input.uiData) return "No filter";

            if (input.uiData.mode == "&&") {
                var condStr = translateConds(input);
                if (condStr.length == 1) return condStr[0];
                else return condStr.map(function(x) { return "(" + x + ")"}).join(" AND ");
            } else if( input.uiData.mode == "||") {
                var condStr = translateConds(input);
                if (condStr.length == 1) return condStr[0];
                else return condStr.map(function(x) { return "(" + x + ")"}).join(" OR ");
            } else if (input.uiData.mode == "CUSTOM") {
                return "<span class='noflex'>Formula: </span>" + anumLiteral(input.expression);
            } else if (input.uiData.mode == "SQL") {
                return "<span class='noflex'>SQL: </span>" + anumLiteral(input.expression);
            }
        }
    });
})();

(function(){
    'use strict';

    var widgets = angular.module('dataiku.directives.widgets');

    widgets.directive('computedColumnStep', function(Logger, $timeout) {
        return {
            templateUrl: '/templates/recipes/visual-recipes-fragments/inline-computed-columns.html',
            restrict: 'EA',
            scope: true,
            link: function(scope, element, attrs) {
                scope.computedColumnStep = {};

                scope.getComputedColumnsStatus = function(recipeStatus, computedColumnIndex) {
                    return ((recipeStatus || {}).messages || []).filter(function(msg) {
                        return msg.line === computedColumnIndex;
                    });
                };

                scope.addNewComputedColumn = function() {
                    scope.computedColumnStep.editingNewComputedColumn = true;
                    scope.computedColumnListDesc.push({name:'', type: 'double', expr: '', mode: 'GREL'});
                    // focus the newly added computed column's name input
                    $timeout(function() {
                        element.find('[computed-column-step-editor]').last().find('input.computed-column-name').focus();
                    });
                };

                // --- init parameters given in attributes:
                var defaults = {
                    computedColumnListUpdateCallback: null,
                    dataset: null,
                    schema: null,
                    computedColumnListDesc: null
                };

                var regenInternalFields = function() {
                    $.each(defaults, function(param, value) {
                        scope[param] = scope.$eval(attrs[param]) || value;
                    });
                    if (!scope.computedColumnListDesc) {
                        Logger.error('"computed-column-list-desc" attribute is required by directive computed-column-step', attrs);
                    }
                    if (!scope.schema && !scope.dataset) {
                        Logger.error('computedColumnStep must have either a dataset or a schema', attrs);
                    }
                };

                regenInternalFields();

                if (scope.computedColumnListUpdateCallback) {
                    var computedColumnListDescOldValue;

                    var computedColumnListDescChanged = function(nv, ov){
                        // check if the newly added computed column's expression is set,
                        // if so compute status for this news computed column aswell
                        if (scope.computedColumnStep.editingNewComputedColumn && nv[nv.length-1] && nv[nv.length-1].expr) {
                            scope.computedColumnStep.editingNewComputedColumn = false;
                        }
                        var oldValue = computedColumnListDescOldValue;
                        var newValue = nv;
                        // ignoring the last element of the array if it has been recently added
                        if (scope.computedColumnStep.editingNewComputedColumn) {
                            newValue = newValue.slice(0, -1);
                        }
                        if(angular.equals(oldValue, newValue)) {
                            return;
                        }
                        computedColumnListDescOldValue = angular.copy(newValue);
                        scope.computedColumnListUpdateCallback(newValue);
                    };

                    scope.$on('$destroy', function() {
                        scope.computedColumnStep.editingNewComputedColumn = false;
                        computedColumnListDescChanged(scope.computedColumnListDesc, computedColumnListDescOldValue);
                    });

                    scope.$watch('computedColumnListDesc', computedColumnListDescChanged, true);
                }

                scope.$watch('recipeStatus', function() {
                    // in case these computed columns are in a visual recipe, make sure to update the internal
                    // flags when the engine or something else changes
                    regenInternalFields();
                },true);
            }
        };
    });

    widgets.directive('computedColumnStepEditor', function(Logger, InfoMessagesUtils, ColumnTypeConstants, CodeMirrorSettingService) {
        return {
            templateUrl: '/templates/recipes/fragments/computed-column-step-editor.html',
            restrict: 'EA',
            scope: true,
            link: function(scope, element, attrs) {
                var getSchema = function() {
                    if (scope.schema) {
                        return scope.schema;
                    } else {
                        Logger.error("schema not found for computed column")
                        return {columns: {}};
                    }
                };

                scope.getColumns = function() {
                    var schema = getSchema();
                    return schema && schema.columns || [];
                };

                scope.clickedOnColumnName = function(colName) {
                    scope.addFormulaElement(colName.match(/^[a-z0-9_]+$/i) ? colName : `val('${colName}')`);
                };

                scope.clickedOnVariableName = function(varName) {
                    scope.addFormulaElement(`variables['${colName}']`);
                };

                scope.addFormulaElement = function(code) {
                    // replace selection and focuses editor
                    var cm = $('.CodeMirror', element).get(0).CodeMirror;
                    cm.replaceSelection(code);
                    cm.focus();
                };

                scope.InfoMessagesUtils = InfoMessagesUtils;
                scope.ColumnTypeConstants = ColumnTypeConstants;

                // --- init parameters given in attributes:
                var defaults = {
                    mustRunInDatabase: false,
                    computedColumnUpdateCallback: null,
                    dataset: null,
                    schema: null,
                    computedColumnDesc: null,
                    recipeStatusMessages: null
                };

                var regenInternalFields = function() {
                    $.each(defaults, function(param, value) {
                        scope[param] = scope.$eval(attrs[param]) || value;
                    });
                    if (!scope.computedColumnDesc) {
                        Logger.error('"computed-column-desc" attribute is required by directive computed-column-step-editor', attrs);
                    }
                    if (!scope.schema && !scope.dataset) {
                        Logger.error('computedColumnStepEditor must have either a dataset or a schema', attrs);
                    }
                };

                regenInternalFields();

                scope.sqlEditorOptions = CodeMirrorSettingService.get('text/x-sql');

                if (scope.computedColumnUpdateCallback) {
                    scope.$watch('computedColumnDesc',
                        function(nv, ov){
                            if(angular.equals(ov, nv)) {
                                return;
                            }
                            scope.computedColumnUpdateCallback(scope.computedColumnDesc);
                        },
                        true
                    );
                }

                scope.$watch('recipeStatus', function() {
                    // in case these computed columns are in a visual recipe, make sure to update the internal
                    // flags when the engine or something else changes
                    regenInternalFields();
                },true);
            }
        };
    });

    widgets.directive('inputComputedColumnsBlock', function (CreateModalFromTemplate, $timeout) {
        return {
            templateUrl : '/templates/recipes/fragments/computed-columns-management-block.html',
            restrict: 'AE',
            scope: {
                inputIndex: '=',
                computedColumnListDesc: '=',
                dataset: '=',
                schema: '=',
                recipeStatus: '=',
                onChange: '&',
                recipeVariables: '='
            },
            link : function(scope, element, attrs) {
                scope.computedColumnListDesc = scope.computedColumnListDesc || [];

                scope.getInputComputedColumnsStatus = function(inputIndex, computedColumnIndex) {
                    return (((scope.recipeStatus || {}).inputComputedColumns || {}).messages || []).filter(function(msg) {
                        return msg.column === inputIndex && msg.line === computedColumnIndex;
                    });
                };

                scope.showComputedColumnsModal = function(computedColumnDescIdx) {
                    var computedColumnDesc = scope.computedColumnListDesc[computedColumnDescIdx];

                    var newScope = scope.$new();

                    newScope.computedColumnListDesc = scope.computedColumnListDesc;
                    newScope.dataset = scope.dataset;
                    newScope.schema = scope.schema;
                    newScope.recipeVariables = scope.recipeVariables;

                    newScope.newComputedColumn = computedColumnDescIdx === undefined || !computedColumnDesc;

                    newScope.computedColumnDesc = newScope.newComputedColumn ? {name:'', type: 'double', expr: '', mode: 'GREL'} : computedColumnDesc;
                    newScope.computedColumnDescIdx = newScope.newComputedColumn ? scope.computedColumnListDesc.length : computedColumnDescIdx;

                    CreateModalFromTemplate('/templates/recipes/fragments/computed-columns-modal.html', newScope, null, function(newScope) {
                        $timeout(function() {
                            $('#computed-columns-modal input.computed-column-name').focus();
                        });
                        if (newScope.newComputedColumn) {
                            newScope.$watch('computedColumnDesc.expr', function(nv) {
                                if (newScope.newComputedColumn && !!nv) {
                                    newScope.newComputedColumn = false;
                                    newScope.computedColumnListDesc.push(newScope.computedColumnDesc);
                                }
                            });

                            newScope.$on('$destroy', function() {
                                if (newScope.newComputedColumn) {
                                    newScope.newComputedColumn = false;
                                    newScope.computedColumnListDesc.push(newScope.computedColumnDesc);
                                }
                            });
                        }
                    });
                };

                scope.addNewComputedColumn = function() {
                    scope.showComputedColumnsModal();
                };

                scope.ok = function() {
                    if (scope.onChange) {
                        scope.onChange();
                    }
                }
            }
        };
    });
})();

(function() {
'use strict';

const app = angular.module('dataiku.recipes');


app.service("RecipesUtils", function(Assert, Logger, $filter){
    var svc = {
        isMLRecipe: function(recipe){
            return recipe.type in {
                "prediction_training" : true,
                "prediction_scoring" : true,
                "clustering_training" : true,
                "clustering_scoring" : true,
                "clustering_complete" : true,
                "evaluation": true,
                "standalone_evaluation": true
            };
        },

        getInputsForRole: function(recipe, role) {
            if (recipe.inputs[role] != null) return recipe.inputs[role].items;
            return [];
        },
        getOutputsForRole: function(recipe, role) {
            if (recipe.outputs[role] != null) return recipe.outputs[role].items;
            return [];
        },

        getFlatInputsList: function(recipe) {
            var flat =[];
            $.each(recipe.inputs, function(roleName, roleData){
                flat = flat.concat(roleData.items);
            });
            return flat;
        },
        getFlatOutputsList: function(recipe) {
            Assert.trueish(recipe, 'no recipe');
            var flat =[];
            $.each(recipe.outputs, function(roleName, roleData){
               flat = flat.concat(roleData.items);
            });
            return flat;
        },
        getFlatIOList: function(recipe) {
            return svc.getFlatInputsList(recipe).concat(svc.getFlatOutputsList(recipe));
        },

        hasAnyPartitioning: function(recipe, computablesMap) {
            var hap = svc.getFlatIOList(recipe).some(function(input){
                var computable = computablesMap[input.ref];
                if (computable == null) {
                    Logger.error("Computable not found for " + input.ref);
                    return false;
                }
                const partitioning = $filter('retrievePartitioning')(computable);
                return partitioning && partitioning.dimensions && partitioning.dimensions.length;
            });
            return hap;
        },

        addInput: function(recipe, role, ref) {
            if (recipe.inputs == null) recipe.inputs = {};
            if (recipe.inputs[role] == null) recipe.inputs[role] = { items : [] }
            recipe.inputs[role].items.push({ref:ref, deps : []});
        },
        addOutput: function(recipe, role, ref) {
            if (recipe.outputs == null) recipe.outputs = {};
            if (!recipe.outputs[role]) recipe.outputs[role] = { items : [] }
            recipe.outputs[role].items.push({ref:ref, deps : []});
        },

        getSingleInput: function(recipe, role) {
            if (recipe.inputs[role] == null) throw Error("No input found in role " + role);
            if (recipe.inputs[role].items.length  == 0) throw Error("No input found in role " + role);
            if (recipe.inputs[role].items.length > 1) throw Error("Multiple inputs found in role " + role);
            return recipe.inputs[role].items[0]
        },
        getSingleOutput: function(recipe, role) {
            if (recipe.outputs[role] == null) throw Error("No output found in role " + role);
            if (recipe.outputs[role].items.length  == 0) throw Error("No output found in role " + role);
            if (recipe.outputs[role].items.length > 1) throw Error("Multiple outputs found in role " + role);
            return recipe.outputs[role].items[0]
        },

        getInput: function(recipe, role, ref) {
            if (recipe.inputs[role] == null) return null;
            if (recipe.inputs[role].items.length  == 0) return null;
            var i = 0;
            for (i = 0; i < recipe.inputs[role].items.length; i++) {
                var input = recipe.inputs[role].items[i];
                if (input.ref == ref) return input;
            }
            return null;
        },
        removeInput: function(recipe, role, ref) {
            if (recipe.inputs[role] == null) return;
            if (recipe.inputs[role].items.length  == 0) return;
            recipe.inputs[role].items = recipe.inputs[role].items.filter(function(x){
                return x.ref != ref;
            })
        },
        parseScriptIfNeeded: function(recipeData) {
            if (['shaker', 'join', 'grouping', 'sampling', 'split', 'clustering_training', 'prediction_training'].indexOf(recipeData.recipe.type) > -1 && typeof recipeData.script === 'string') {
                recipeData.script = JSON.parse(recipeData.script);
            }

        }
    };
    return svc;
});


app.service("RecipeRunJobService", function(Assert, DataikuAPI, $stateParams, RecipesUtils, JobDefinitionComputer, $filter) {

    function getOutputAndPartitioning(recipe, computablesMap) {
        if (!computablesMap) {
            throw new Error("computablesMap not ready");
        }
        const outputs = RecipesUtils.getFlatOutputsList(recipe);
        for (const output of outputs) {
            const computable = computablesMap[output.ref];
            const partitioning = $filter('retrievePartitioning')(computable);

            if (partitioning && partitioning.dimensions.length > 0) {
                return { output, partitioning };
            }
        }
        return { output: outputs[0] };
    }
    var svc = {
        getOutputAndPartitioning,

        getOutputDimensions: function(recipe, computablesMap) {
            const partitioning = getOutputAndPartitioning(recipe, computablesMap).partitioning
            return partitioning ? partitioning.dimensions : [];
        },

        getTargetPartition: function($scope) {
        	if ( $scope.testRun == null ) return "";
            var outputs = RecipesUtils.getFlatOutputsList($scope.recipe);
            /* First find a dataset */
            for (var i = 0; i < outputs.length; i++) {
                var output = outputs[i];
                if (!$scope.computablesMap) {
                    throw new Error("computablesMap not ready");
                }
                var computable = $scope.computablesMap[output.ref];
                if (computable.type == "DATASET") {
                    var jd = JobDefinitionComputer.computeJobDefForSingleDataset($stateParams.projectKey,
                                $scope.testRun.runMode,
                                computable.dataset,
                                $scope.testRun.build_partitions);
                    return jd.outputs[0].targetPartition;
                }
            }
            /* No dataset found ... */
            return "";
        },

        isRunning: function(startedJob) {
            if (!startedJob || !startedJob.jobStatus || !startedJob.jobStatus.baseStatus){
                return false;
            }
            var state = startedJob.jobStatus.baseStatus.state;
            return ["RUNNING", "NOT_STARTED", "COMPUTING_DEPS"].includes(state);
        },

        run: function(recipe, computablesMap, testRun, startedJob, errorScope) {
            Assert.trueish(recipe, 'no recipe');
            Assert.trueish(computablesMap, 'no computablesMap');
            Assert.trueish(RecipesUtils.getFlatOutputsList(recipe).length > 0, 'no outputs');
            /* Identify the computable to build. First we look for a partitioned dataset or model */
            var computable = null;
            var outputs = RecipesUtils.getFlatOutputsList(recipe);
            for (var i = 0; i < outputs.length; i++) {
                var output = outputs[i];
                var _computable = computablesMap[output.ref];
                if (_computable.type == "DATASET" && _computable.dataset.partitioning.dimensions.length) {
                    computable = _computable;
                    break;
                }
            }
            /* No partitioning so just take the first output */
            if (computable == null) {
                computable = computablesMap[outputs[0].ref];
            }

            if (computable.type == "SAVED_MODEL") {
                var jd = JobDefinitionComputer.computeJobDefForSavedModel($stateParams.projectKey, testRun.runMode, computable.model, testRun.build_partitions, 'RECIPE', $stateParams.recipeName);
            } else if (computable.type == "MANAGED_FOLDER") {
                var jd = JobDefinitionComputer.computeJobDefForBox($stateParams.projectKey, testRun.runMode, computable.box, testRun.build_partitions, 'RECIPE', $stateParams.recipeName);
            } else if (computable.type == "STREAMING_ENDPOINT") {
                var jd = JobDefinitionComputer.computeJobDefForStreamingEndpoint($stateParams.projectKey, testRun.runMode, computable.streamingEndpoint, testRun.build_partitions, 'RECIPE', $stateParams.recipeName);
            } else if (computable.type == "MODEL_EVALUATION_STORE") {
                var jd = JobDefinitionComputer.computeJobDefForModelEvaluationStore($stateParams.projectKey, testRun.runMode, computable.mes, testRun.build_partitions, 'RECIPE', $stateParams.recipeName);
            } else {
                var jd = JobDefinitionComputer.computeJobDefForSingleDataset(
                            $stateParams.projectKey,
                            testRun.runMode,
                            computable.dataset,
                            testRun.build_partitions,
                            'RECIPE',
                            $stateParams.recipeName || recipe.name);
            }
            return DataikuAPI.flow.jobs.start(jd).success(function(data) {
                startedJob.starting = false;
                startedJob.jobId = data.id;
            }).error(function(a, b, c) {
                startedJob.starting = false;
                setErrorInScope.bind(errorScope)(a, b,c);
                errorScope.recipeWT1Event("recipe-run-start-failed");
            });
        }
    }
    return svc;
});

app.service("RecipeDescService", function($stateParams, DataikuAPI, Logger, WT1) {

    var descriptors;

    function capitalize(str) {
        if (!str) return '';
        if(str.length>0) {
            str = str.substring(0,1).toUpperCase() + str.substring(1);
        }
        return str;
    }
    function formatNice(str) {
        if (!str) return '';
        str = str.toLowerCase();
        str = str.replace(/[_ ]+/g,' ');
        return str;
    }

    function isOverallUnary(roles) {
        if (!roles) return false;
        var unary = null;
        roles.forEach(function(r) {
            if (r.arity != 'UNARY') {
                unary = false;
            } else if (unary === null) {
                // first one
                unary = true;
            } else {
                // 2 unaries => not overall unary
                unary = false;
            }
        });
        return unary;
    }

    var svc = {
        load: function(errorScope) {
            DataikuAPI.flow.recipes.getTypesDescriptors().success(function(data) {
                Logger.info("Received recipe descriptors");
                descriptors = data;
            }).error(function(a, b, c) {
                Logger.error("Failed to get recipe descriptors");
                setErrorInScope.bind(errorScope)(a, b, c);
                WT1.event("get-recipe-descriptors-failed");
            });
        },
        getDescriptors: function() {
            if (!descriptors) {
                logger.error("Recipes descriptors not ready");
            }
            return descriptors;
        },
        isRecipeType: function(recipeType) {
            var desc;
            if (!descriptors) {
                Logger.error("Recipe descriptors are not ready");
            } else {
                return !!descriptors[recipeType];
            }
        },
        getDescriptor: function(recipeType) {
            var desc;
            if (!descriptors) {
                Logger.error("Recipe descriptors are not ready");
            } else {
                angular.forEach(descriptors, function(d, t) {
                    if (t == recipeType || t.toLowerCase() == recipeType) desc = d;
                });
                if (!desc) {
                    // This should not happen (maybe a new plugin recipe type)
                    Logger.error("Recipe descriptor not found for type: "+recipeType);
                }
                return angular.copy(desc);
            }
        },
        getRolesIndex: function(recipeType) {
            var desc = svc.getDescriptor(recipeType);
            var inputRolesIndex = {};
            var outputRolesIndex = {};
            desc.inputRoles.forEach(function(r) {
                inputRolesIndex[r.name] = r;
            });
            desc.outputRoles.forEach(function(r) {
                r.editing = true; //Ugly, to be compatible with current templates
                outputRolesIndex[r.name] = r;
            });
            return {inputs: inputRolesIndex, outputs: outputRolesIndex};
        },

        getInputRoleDesc: function(recipeType, roleName) {
            return svc.getRolesIndex(recipeType).inputs[roleName];
        },

        getRecipeTypeName: function(recipeType, capitalize) {
            if(!recipeType) return '';
            var desc = svc.getDescriptor(recipeType);
            var name = (desc && desc.meta && desc.meta.label) || formatNice(recipeType);
            return capitalize ? capitalize(name) : name;
        },
        isSingleInputRecipe: function(recipeType) {
            return !recipeType.startsWith('CustomCode_') && !recipeType.startsWith('App_') && isOverallUnary(svc.getDescriptor(recipeType).inputRoles);
        },
        isSingleOutputRecipe: function(recipeType) {
            return !recipeType.startsWith('CustomCode_') && !recipeType.startsWith('App_') && isOverallUnary(svc.getDescriptor(recipeType).outputRoles);
        },
        hasValidRequiredRoles: function(recipe) {
            const desc = svc.getDescriptor(recipe.type);
            return !desc.inputRoles.some(role => role.required && (!recipe.inputs[role.name] || recipe.inputs[role.name].items.length == 0))
                && !desc.outputRoles.some(role => role.required && (!recipe.outputs[role.name] || recipe.outputs[role.name].items.length == 0));
        }
    };

    return svc;
});

app.service("SelectablePluginsService", function($rootScope) {
    var svc = {

        listSelectablePlugins : function (inputTypesCount) {

            const pluginsById = $rootScope.appConfig.loadedPlugins.reduce( function (map, obj) {
                map[obj.id] = obj;
                return map;
            }, {});

            var selectablePlugins = [];
            var alreadySelectedPlugins = {};

            $rootScope.appConfig.customCodeRecipes.forEach( (recipe) => {
                if (!alreadySelectedPlugins[recipe.ownerPluginId] && svc.canBeBuildFromInputs(recipe, inputTypesCount).ok && pluginsById.hasOwnProperty(recipe.ownerPluginId)) {
                    const plugin = pluginsById[recipe.ownerPluginId];
                    plugin.pluginId = plugin.id;
                    selectablePlugins.push(plugin);
                    alreadySelectedPlugins[plugin.id] = true;
                }
            });

            return selectablePlugins;
        },

        canBeBuildFromInputs: function (recipe, inputTypesCount) {
            if (!inputTypesCount)
                return { ok: true};

            const allTypes = {
                "DATASET": {
                    "selectableFromRole": 'selectableFromDataset',
                    "inputName" : recipe.desc.selectableFromDataset,
                    "inputTypeCount": inputTypesCount.DATASET
                },
                "MANAGED_FOLDER":  {
                    "selectableFromRole": 'selectableFromFolder',
                    "inputName": recipe.desc.selectableFromFolder,
                    "inputTypeCount": inputTypesCount.MANAGED_FOLDER
                },
                "SAVED_MODEL": {
                    "selectableFromRole": 'selectableFromSavedModel',
                    "inputName": recipe.desc.selectableFromSavedModel,
                    "inputTypeCount": inputTypesCount.SAVED_MODEL
                }
            };
            for (let [inputType, nb_input] of Object.entries(inputTypesCount)) {
                const typeParams = allTypes[inputType];
                var role = recipe.desc.inputRoles.find( (el) => { return el.name == typeParams.inputName; });
                // role does not exist
                if (!role)
                    return { ok: false, reason: "InputRole selectable from " + inputType + " doesn't exist in this recipe."};

                // recipe does not accept selectable inputs of this type
                if (!recipe.desc.hasOwnProperty(typeParams.selectableFromRole)) {
                    return { ok: false, reason: "Input role type " + inputType + " of (" + role.name + ") is not selectable for this recipe."};
                }
                // recipe does not accept inputs of type of the role
                if ((inputType === "DATASET" && !role.acceptsDataset) ||
                    (inputType === "MANAGED_FOLDER" && !role.acceptsManagedFolder) ||
                    (inputType === "SAVED_MODEL" && !role.acceptsSavedModel)) {
                    return { ok: false, reason: "Recipe doesn't accept " + inputType + " as input for the selectable role (" + role.name + ")."};
                }

                if (nb_input > 1 && role.arity == 'UNARY')
                    return { ok: false, reason: "Recipe only accepts unary inputs for the selectable role (" + role.name + ")."};
            }
            return {ok: true};
        }

    };
    return svc;
});

app.service("RecipeComputablesService", function(Assert, DataikuAPI, $stateParams, RecipesUtils, Logger) {
    var svc = {

        isUsedAsInput: function(recipe, ref) {
            var found = false;
            $.each(recipe.inputs, function(role, roleData){
                 found |= roleData.items.some(function(input) {
                    return input.ref == ref;
                 });
            })
            return found;
        },
        isUsedAsOutput: function(recipe, ref) {
            var found = false;
            $.each(recipe.outputs, function(role, roleData){
                 found |= roleData.items.some(function(x) {
                    return x.ref == ref;
                 });
            })
            return found;
        },
        getComputablesMap: function(recipe, errorScope) {
            return DataikuAPI.flow.listUsableComputables($stateParams.projectKey, {
                forRecipeType : recipe.type
            }).then(function(data) {
                var computablesMap ={};
                $.each(data.data, function(idx, elt) { computablesMap[elt.smartName]  = elt;});
                // added bonus: lots of places expect computablesMap to contain all the input/outputs of the recipe
                // so that if one of the elements is removed or stopped being exposed, the UI throws gobs of js
                // errors
                // => we pad the map with fake elements to cover the input/outputs
                var unusable = {};
                angular.forEach(recipe.inputs, function(x, role) {unusable[role] = {};});
                angular.forEach(recipe.outputs, function(x, role) {unusable[role] = {};});
                RecipesUtils.getFlatIOList(recipe).forEach(function(io){
                    var computable = computablesMap[io.ref];
                    if (computable == null) {
                        Logger.warn("Computable not found for " + io.ref + ". Inserting dummy computable.");
                        computablesMap[io.ref] = {type:'MISSING', name:io.ref, usableAsInput:unusable, usableAsOutput:unusable};
                    }
                });
                return computablesMap;
            }, function(resp){
                setErrorInScope.bind(errorScope)(resp.data, resp.status, resp.headers)
            });
        },

        /* returns the name of an output computable */
        getAnyOutputName: function(recipe) {
            if (!recipe || !recipe.outputs) return;
            var roles = Object.keys(recipe.outputs);
            for (var r = 0; r < roles.length; r++) {
                var items = recipe.outputs[roles[r]].items;
                if (items && items.length > 0) {
                    return items[0].ref;
                }
            }
        },

        /**
         * Builds the list of usable inputs for a given role.
         * Note: it actually also includes some non-usable inputs ...
         */
        buildPossibleInputList: function(recipe, computablesMap, role, filter){
            var usableInputs = [];
            var filterStr = null;
            if (filter && filter.length) {
                filterStr = filter.toLowerCase();
            }
            Assert.trueish(computablesMap, 'no computablesMap');
            $.each(computablesMap, function(k, v) {
                if (!filter || !filter.length || v.smartName.toLowerCase().indexOf(filterStr) >= 0 || (v.label && v.label.toLowerCase().indexOf(filterStr) >= 0)) {
                    if (!svc.isUsedAsInput(recipe, v.smartName)) {
                        usableInputs.push(v);
                    }
                }
            });
            return usableInputs;
        },
        /**
         * Builds the list of usable outputs for a given role.
         * Note: it actually also includes some non-usable outputs ...
         * It removes the ones that are currently used in the recipe, and executes the filter
         */
        buildPossibleOutputList: function(recipe, computablesMap, role, filter){
            if (!computablesMap) {
                throw Error("No computablesMap");
            }
            var usable = [];
            var filterStr = null;
            if (filter && filter.length) {
                filterStr = filter.toLowerCase();
            }

            $.each(computablesMap, function(k, v) {
                if (!filter || !filter.length || v.smartName.toLowerCase().indexOf(filterStr) >= 0) {
                    if (!svc.isUsedAsOutput(recipe, v.smartName)) {
                        usable.push(v);
                    }
                }
            });
            return usable;
        }
    };
    return svc;
});

app.service("CodeEnvsService", function(DataikuAPI, $stateParams, RecipeDescService, Logger, CreateModalFromTemplate) {
    var svc = {
        canPythonCodeEnv: function(recipe) {
            if (recipe.nodeType !== 'RECIPE' && recipe.interest && recipe.interest.objectType !== 'RECIPE') {
                return false;
            }
            var t = recipe.recipeType || recipe.type;
            if(['python','pyspark'].indexOf(t) >= 0) {
                return true;
            }
            if (t.startsWith('CustomCode_')) {
                var desc = RecipeDescService.getDescriptor(t);
                if (!desc) return;
                if (['PYTHON'].indexOf(desc.kind) >= 0) {
                    return true;
                }
            }
            return false;
        },

        canRCodeEnv: function(recipe) {
            if (recipe.nodeType !== 'RECIPE' && recipe.interest && recipe.interest.objectType !== 'RECIPE') {
                return false;
            }
            var t = recipe.recipeType || recipe.type;
            if(['r','sparkr'].indexOf(t) >= 0) {
                return true;
            }
            if (t.startsWith('CustomCode_')) {
                var desc = RecipeDescService.getDescriptor(t);
                if (!desc) return;
                if (['R'].indexOf(desc.kind) >= 0) {
                    return true;
                }
            }
            return false;
        },
        startChangeCodeEnv: function(selectedRecipes, envLang, $scope) {
            return CreateModalFromTemplate('/templates/recipes/fragments/change-code-env-modal.html', $scope, null, function(modalScope) {
                modalScope.uiState = {envSelection : {envMode : 'INHERIT'}};
                modalScope.envLang = envLang;
                modalScope.selectedObjects = selectedRecipes;

                modalScope.change = function() {
                    DataikuAPI.flow.recipes.massActions.changeCodeEnv(modalScope.selectedObjects, modalScope.uiState.envSelection).success(function() {
                        modalScope.resolveModal();
                    }).error(setErrorInScope.bind(modalScope));
                };
            })
        }
    };
    return svc;
});

})();
(function() {
    'use strict';
	var app = angular.module('dataiku.recipes');

    // Creation modal controller
    app.controller("CsyncRecipeCreationController", function($scope, Fn, $stateParams, DataikuAPI, $controller) {
        $scope.recipeType = "csync";
        $scope.datasetsOnly = false;
        $scope.filterUsableInputsOn = "main";
        $controller("SingleOutputDatasetRecipeCreationController", {$scope:$scope});
        
        $scope.singleOutputRole.acceptsStreamingEndpoint = true; // add the possibility of streaming endpoints

        $scope.autosetName = function() {
            if ($scope.io.inputDataset) {
                var niceInputName = $scope.io.inputDataset.replace(/[A-Z]*\./,"");
                $scope.maybeSetNewDatasetName(niceInputName + "_copy");
            }
        };
    });


    app.controller("CsyncRecipeController", function($scope, $stateParams, $q, $controller, Assert, StateUtils, DataikuAPI, Dialogs, TopNav, RecipesUtils, PartitionDeps, ComputableSchemaRecipeSave, Logger) {
	    Assert.inScope($scope, 'recipe');

        $controller("_RecipeWithEngineBehavior", {$scope:$scope});
        $controller("_ContinuousRecipeInitStartedJobBehavior", {$scope:$scope});

        $scope.schemaModes = [
            ["FREE_SCHEMA_NAME_BASED", "Free output schema (name-based matching)"],
            ["STRICT_SYNC", "Maintain strict schema equality"]
        ];

        $scope.hooks.save = function(){
            if ($scope.recipe.params.schemaMode == "FREE_SCHEMA_NAME_BASED") {
                return $scope.hooks.origSaveHook();
            } else {
                var deferred = $q.defer();
                var recipeSerialized = angular.copy($scope.recipe);
                PartitionDeps.prepareRecipeForSerialize(recipeSerialized);
                ComputableSchemaRecipeSave.handleSave($scope, recipeSerialized, null, deferred);
                return deferred.promise;
            }
        };

        $scope.hooks.onRecipeLoaded = function() {
            Logger.info("On Recipe Loaded");
            $scope.hooks.updateRecipeStatus();
        };

        $scope.hooks.updateRecipeStatus = function() {
            var deferred = $q.defer();
            $scope.updateRecipeStatusBase(false).then(function() {
                // $scope.recipeStatus should have been set by updateRecipeStatusBase
                if (!$scope.recipeStatus) return deferred.reject();
                deferred.resolve($scope.recipeStatus);
            });
            return deferred.promise;
        };

        $scope.resyncSchema = function() {
            var input = RecipesUtils.getSingleInput($scope.recipe, "main");
            var output = RecipesUtils.getSingleOutput($scope.recipe, "main");
            Dialogs.confirmPositive($scope, 'Resynchronize schema',
                'The schema of "'+input.ref+'" will be copied to "'+output.ref+'". Are you sure you want to continue ?')
            .then(function() {
                 DataikuAPI.flow.recipes.basicResyncSchema($stateParams.projectKey, $scope.hooks.getRecipeSerialized()).error(setErrorInScope.bind($scope));
            });
        };

        TopNav.setTab(StateUtils.defaultTab("io"));

        $scope.recipe.params = $scope.recipe.params || {};
        $scope.params = $scope.recipe.params;

        $scope.$watch("recipe.params", $scope.updateRecipeStatusLater, true);
        $scope.enableAutoFixup();
        $scope.specificControllerLoadedDeferred.resolve();
        
        $scope.isStreamingEndpointToDataset = function() {
            let input = RecipesUtils.getSingleInput($scope.recipe, "main");
            let output = RecipesUtils.getSingleOutput($scope.recipe, "main");
            let inputComputable = $scope.computablesMap[input.ref] || {};
            let outputComputable = $scope.computablesMap[output.ref] || {};
            return outputComputable.type === 'DATASET' && inputComputable.type === 'STREAMING_ENDPOINT';
        };
	});
})();
const ACTIVITY_TYPE_SPARK_PIPELINE = 'SPARK_PIPELINE';
const ACTIVITY_TYPE_SQL_PIPELINE = 'SQL_PIPELINE';

function isPipeline(activity) {
    return [ACTIVITY_TYPE_SPARK_PIPELINE, ACTIVITY_TYPE_SQL_PIPELINE].includes(activity.activityType);
}

(function(){
'use strict';

const app = angular.module('dataiku.flow.runtime', []);

/**
* Simple directive to show the reason why an activity is/was required on a job page
*/
app.directive("activityRequiredReason", function (){
    return {
        scope: {
            activity : "=",
            sentence : '=',
            past : '='
        },
        templateUrl : "/templates/jobs/activity-required-reason.html"
    }
});

app.factory("JobStatusUtils", function(AnyLoc){
    var svc = {
        selectRecipes : function(activity, $element) {
            let recipeNames;
            if (isPipeline(activity)) {
                recipeNames = activity.pipelineRecipes.map(recipe => recipe.recipeName);
            } else {
                recipeNames = [activity.recipeName];
            }
            recipeNames.forEach(recipeName => {
                let elt = $element.find('svg [data-name="' + recipeName + '"][data-type="RECIPE"]')[0];
                d3.select(elt).classed("selected", true);
            })
        },

        statsifyActivity : function(activity, jobStatus) {
            activity.stateOrder =
                {"RUNNING" : -1, "FAILED": 0,  "DONE": 1, "WAITING" : 2,"NOT_STARTED" : 3 }
                [activity.state];

            if (activity.state == 'RUNNING') {
                activity.duration = new Date().getTime() - activity.startTime;
            } else if (activity.endTime > 0) {
                activity.duration = activity.endTime - activity.startTime;
            } else if (activity.startTime > 0 && jobStatus.baseStatus.jobEndTime > 0) {
                activity.duration = jobStatus.baseStatus.jobEndTime - activity.startTime;
            } else {
                activity.duration = 0;
            }
            activity.mainPartition = 'N/A';
            if (activity.targets.length >= 1) {
                var p = activity.targets[0].partition.id;
                if (p != "NP") {
                    activity.mainPartition = p;
                }
            }
            (function () {
                for (var tgtIdx in activity.targets) {
                    var tgt = activity.targets[tgtIdx];
                    if (tgt.type == "SAVED_MODEL") {
                        tgt.smId = AnyLoc.getLocFromFull(tgt.id).localId;
                        tgt.smProjectKey = AnyLoc.getLocFromFull(tgt.id).projectKey;
                    } else if (tgt.type == "MODEL_EVALUATION_STORE") {
                        tgt.mesId = AnyLoc.getLocFromFull(tgt.id).localId;
                        tgt.mesProjectKey = AnyLoc.getLocFromFull(tgt.id).projectKey;
                    } else if (tgt.type == "MANAGED_FOLDER") {
                        tgt.odbId = AnyLoc.getLocFromFull(tgt.id).localId;
                        tgt.odbProjectKey = AnyLoc.getLocFromFull(tgt.id).projectKey;
                    }
                }
            }());
            (function () {
                activity.fwpSources = [];
                activity.fwgpSources = [];
                activity.noneSources = [];
                activity.fwopSources = [];
                for (var srcIdx in activity.sources) {
                    var src = activity.sources[srcIdx];

                    if (src.type == "SAVED_MODEL") {
                        src.smId = AnyLoc.getLocFromFull(src.id).localId;
                        src.smProjectKey = AnyLoc.getLocFromFull(src.id).projectKey;
                    } else if (src.type == "MODEL_EVALUATION_STORE") {
                        src.mesId = AnyLoc.getLocFromFull(src.id).localId;
                        src.mesProjectKey = AnyLoc.getLocFromFull(src.id).projectKey;
                    } else if (src.type == "MANAGED_FOLDER") {
                        src.odbId = AnyLoc.getLocFromFull(src.id).localId;
                        src.odbProjectKey = AnyLoc.getLocFromFull(src.id).projectKey;
                    }

                    if (src.statsType == 'FILES_WITH_PROGRESS') {
                        for (var pidx in src.partitions) {
                            activity.fwpSources.push({
                                id : src.id, type : src.type,
                                'partition': src.partitions[pidx].id,
                                'files': src.partitions[pidx].totalFiles,
                                'bytes': src.partitions[pidx].totalSize,
                                'progress': src.partitions[pidx].readBytes / src.partitions[pidx].totalSize
                            });
                        }
                    } else if (src.statsType == 'FILES_WITH_GLOBAL_PROGRESS') {
                        var srcs = [];
                        var totalSize = 0;
                        for (var pidx in src.partitions) {
                            srcs.push({
                                id : src.id, type : src.type,
                                'partition': src.partitions[pidx].id,
                                'files': src.partitions[pidx].totalFiles,
                                'bytes': src.partitions[pidx].totalSize
                            });
                            totalSize += src.partitions[pidx].totalSize;
                        }
                        for (var srcIdx2 in srcs) {
                            srcs[srcIdx2].progress = src.totalReadBytes / totalSize;
                            activity.fwgpSources.push(srcs[srcIdx2]);
                        }
                    } else if (src.statsType == 'NONE') {
                        for (var pidx in src.partitions) {
                            activity.noneSources.push({
                                id : src.id, type : src.type,
                                'partition': src.partitions[pidx].id
                            });
                        }
                    } else if (src.statsType == 'FILES_WITHOUT_PROGRESS') {
                        for (var pidx in src.partitions) {
                            activity.fwopSources.push({
                                id : src.id, type : src.type,
                                'partition': src.partitions[pidx].id,
                                'files': src.partitions[pidx].totalFiles,
                                'bytes': src.partitions[pidx].totalSize
                            });
                        }
                    }
                }
            }());
        }

    }
    return svc;
});

/** Root directive of the whole status page */
app.directive("jobStatusBase", function(DataikuAPI, $stateParams, $state, Dialogs, Throttle, $rootScope, TopNav, ActivityIndicator, FutureProgressModal, $q, WT1){
    return {
        controller: function ($scope, $element, $timeout) {
            TopNav.setLocation(TopNav.TOP_JOBS, "jobs", TopNav.TABS_JOB, "activities");
            $stateParams.jobId && TopNav.setItem(TopNav.ITEM_JOB, $stateParams.jobId);

            $scope.filter = {};
            $scope.uiState = { isFlowVisible: true };

            $scope.setFlowVisibility = function(toggle) {
                $scope.uiState.isFlowVisible = toggle;
                $rootScope.$broadcast("reflow");
            }

            $scope.retryJob = function () {
                if(!$scope.retrying) {
                    $scope.retrying = true;
                    DataikuAPI.flow.jobs.retry($stateParams.projectKey, $stateParams.jobId).success(function (data) {
                        $state.transitionTo('projects.project.jobs.job', { projectKey:$stateParams.projectKey, jobId: data.id });
                        $scope.retrying = false;
                    }).error(setErrorInScope.bind($scope));
                }
            };

            $scope.abortJob = function () {
                Dialogs.confirm($scope, 'Aborting a job','Are you sure you want to abort this job ?').then(function() {
                    DataikuAPI.flow.jobs.abort($stateParams.projectKey, $stateParams.jobId).success(function(data) {
                        $scope.refreshStatus();
                    }).error(setErrorInScope.bind($scope));
                });
            };

            $scope.downloadJobDiagnosis = function(){
                ActivityIndicator.success("Preparing job diagnosis ...");
                downloadURL(DataikuAPI.flow.jobs.getJobDiagnosisURL($stateParams.projectKey, $stateParams.jobId));
            }

            $scope.setYarnLogsPerActivityId = function(result) {
                $scope.yarnLogs = {};
                if (result) {
                    result.forEach(function(yarnLog) {
                        $scope.yarnLogs[yarnLog.activityId] = $scope.yarnLogs[yarnLog.activityId] || [];
                        $scope.yarnLogs[yarnLog.activityId].push(yarnLog.yarnAppId);
                    });
                }
            };
            
            $scope.setK8SLogsPerActivityId = function(result) {
                $scope.k8sLogs = {};
                if (result) {
                    result.forEach(function(k8sLog) {
                        $scope.k8sLogs[k8sLog.activityId] = $scope.k8sLogs[k8sLog.activityId] || [];
                        $scope.k8sLogs[k8sLog.activityId].push(k8sLog.podName);
                    });
                }
            };
            
            $scope.fetchYarnLogs = function(){
                DataikuAPI.flow.jobs.fetchYarnLogs($stateParams.projectKey, $stateParams.jobId).success(function(data){
                    FutureProgressModal.show($scope, data, "Fetch Yarn logs").then(function(result){
                        if (result) { // undefined in case of abort
                            $scope.setYarnLogsPerActivityId(result)
                        }
                    });
                }).error(setErrorInScope.bind($scope));
            }

            $scope.hooks = { saveUIState : function(){} }

            $scope.refreshStatus = function () {
                var deferred = $q.defer();
                $scope.hooks.saveUIState();

                DataikuAPI.flow.jobs.getJobStatus($stateParams.projectKey, $stateParams.jobId).success(function (data) {
                    $scope.jobState = data.baseStatus.state;
                    $scope.jobDef = data.baseStatus.def;
                    $scope.jobDef.stepRun = data.stepRun;
                    $scope.setYarnLogsPerActivityId(data.yarnLogs)
                    $scope.setK8SLogsPerActivityId(data.k8sLogs)
                    $scope.setJobStatusData(data);

                    $timeout(function() { $rootScope.$broadcast("reflow"); }, 20);
                    deferred.resolve("updated");
                }).error(function (a,b,c) {
                    setErrorInScope.bind($scope)(a,b,c);
                    deferred.reject("not updated");
                });
                return deferred.promise;
            };

            var autoRefresh = Throttle().withScope($scope).withDelay(6000).wrap(function(force) {
                if (force || !$scope.jobState || $scope.jobState == "RUNNING" || $scope.jobState == "COMPUTING_DEPS") {
                    $scope.refreshStatus().then(function() { autoRefresh() ;}); // don't re-enqueue a status update until the current one is done
                }
            });

            autoRefresh();

            $scope.clearJobLogs = function(jobId = $stateParams.jobId) {

                if (!jobId) { return; }
        
                const title = 'Confirm logs deletion';
                const message = 'Are you sure you want to clear the logs for this job?';
        
                Dialogs.confirm($scope, title, message)
                    .then(() => {
                        WT1.event('job-delete', { modelBenchId : jobId });
                        DataikuAPI.flow.jobs
                            .clearLogs($stateParams.projectKey, jobId)
                            .success($scope.refreshStatus)
                            .error(setErrorInScope.bind($scope));
                    });
            };

            var jobStatusBaseStatusActivities = null;
            var jobStatusBaseStatusJobAllActivities = null;
            var jobStatusBaseStatusJobBeforePruneAllActivities = null;
            $scope.disabledActivities = [];

            $scope.setJobStatusData = function(data) {
            	$scope.elapsedTime = data && data.baseStatus ? (new Date().getTime()) - data.baseStatus.jobStartTime : 0;
                if (data == null) {
                    jobStatusBaseStatusActivities = null;
                    jobStatusBaseStatusJobAllActivities = null;
                    jobStatusBaseStatusJobBeforePruneAllActivities = null;
                    $scope.jobStatus = null;
                } else {
                    if (!data.baseStatus) {
                        jobStatusBaseStatusActivities = null;
                        jobStatusBaseStatusJobAllActivities = null;
                        jobStatusBaseStatusJobBeforePruneAllActivities = null;
                    } else {
                        jobStatusBaseStatusActivities = data.baseStatus.activities;
                        // a bit of fixup
                        angular.forEach(jobStatusBaseStatusActivities, function(activity, activityName) {
                            // the 'classic' bug-report generating glitch: when a job is aborted
                            // by a DSS restart, then the job is properly in ABORTED state but some
                            // activities are still in RUNNING and appear as such in the UI (blinking).
                            // so we set them to ABORTED so that the user is not confused
                            if (data.baseStatus.state == 'ABORTED' && activity.state == 'RUNNING') {
                                activity.state = 'ABORTED';
                            }
                        });
                        data.baseStatus.activities = null;
                        if (!data.baseStatus.job) {
                            jobStatusBaseStatusJobAllActivities = null;
                        } else {
                            jobStatusBaseStatusJobAllActivities = data.baseStatus.job.allActivities;
                            data.baseStatus.job.allActivities = null;
                        }
                        if (!data.baseStatus.jobBeforePrune) {
                            jobStatusBaseStatusJobBeforePruneAllActivities = null;
                        } else {
                            jobStatusBaseStatusJobBeforePruneAllActivities = data.baseStatus.jobBeforePrune.allActivities;
                            data.baseStatus.jobBeforePrune.allActivities = null;
                        }
                    }
                    $scope.jobStatus = data;
                }
            };

            $scope.validateRun = function() {
                DataikuAPI.flow.jobs.validateRunFully($stateParams.projectKey, $stateParams.jobId,
                    $scope.disabledActivities).success(function(data) {
                    autoRefresh(true);
                }).error(setErrorInScope.bind($scope));
            }

            $scope.getJobActivities = function() {
                return jobStatusBaseStatusActivities || {};
            };
            $scope.getJobAllActivities = function() {
                return jobStatusBaseStatusJobAllActivities || {};
            };
            $scope.getJobBeforePruneAllActivities = function() {
                return jobStatusBaseStatusJobBeforePruneAllActivities || {};
            };
            $scope.getInJobActivities = function(activityId) {
                return $scope.getJobActivities()[activityId];
            };
            $scope.getInJobAllActivities = function(activityId) {
                return $scope.getJobAllActivities()[activityId];
            };
            $scope.getInJobBeforePruneAllActivities = function(activityId) {
                return $scope.getJobBeforePruneAllActivities()[activityId];
            };
        }
    }
});

/** Directive for status page of a running or finished job (ie, after compute) */
app.directive('jobStatusRegular', function(Assert, DataikuAPI, $stateParams, $state,Dialogs, $location, TopNav, $rootScope, Debounce, $filter, JobStatusUtils, CreateModalFromTemplate) {
    return {
        controller: function ($scope, $element, $timeout) {
            $scope.logOptions = { compactLog : true};
            $scope.jobTotalEndedActivities = 0;

            if ($state.params.hideFlow === 'true') {
                $scope.uiState.isFlowVisible = false;
            }

            $scope.selectActivity = function(activity) {
                activity = $scope.activitiesFatTable.find(activityFatTable => activityFatTable.activityId === activity.activityId);
                if (!activity) { return; }
                $scope.selectedActivity = activity;
                $scope.smartTail();
                $scope.unhighlightActivities();
                d3.selectAll($element.find('svg .selected')).classed("selected", false);
                JobStatusUtils.selectRecipes(activity, $element);
            };

            $scope.hoverActivity = function(activity) {
                JobStatusUtils.selectRecipes(activity, $element);
            };

            $scope.unhoverActivity = function() {
                d3.selectAll($element.find('svg .selected')).classed("selected", false);
            };

            $scope.highlightActivity = function(activity) {
                let retrievedActivity = $scope.activitiesFatTable.filter(activityFatTable => activityFatTable.activityId === activity.activityId)[0];
                if (retrievedActivity) {
                    retrievedActivity.highlighted = true;
                }
            };

            $scope.unhighlightActivities = function() {
                $scope.activitiesFatTable.forEach(activityFatTable => activityFatTable.highlighted = false);
            };

            $scope.getActivitiesByDatasetName = function(datasetName) {
                if (!$scope.activitiesFatTable) { return; }
                return Object.values($scope.activitiesFatTable).filter(activity => {
                    let isTarget = activity.targets.filter(target => {
                        return target.datasetName === datasetName;
                    }).length > 0;
                    return isTarget;
                });
            };

            $scope.getActivitiesByRecipeName = function(recipeName) {
                if (!$scope.activitiesFatTable) { return; }
                return Object.values($scope.activitiesFatTable).filter(activity => {
                    return activity.recipeName == recipeName;
                });
            };

            /* Handle filter/sort of activities table */
            $scope.sortBy = [
                { 'value': 'stateOrder', 'label': 'Status' },
                { 'value': 'recipeName', 'label': 'Recipe' },
                { 'value': 'output', 'label': 'Output' },
                { 'value': 'startTime', 'label': 'Start Time' },
                { 'value': 'endTime', 'label': 'End Time' },
                { 'value': 'duration', 'label': 'Duration'}
            ];
            var rebuildActivitiesList = function() {
                $scope.activitiesFatTable = filterSortLimitTagsAndQ(
                    $filter,
                    $scope.activitiesFlat,
                    { q : $scope.filter.activities },
                    {
                        column : [$scope.order.column, 'partialExecutionOrder', 'activityId'],
                        reverse : $scope.order.reverse
                    },
                    2000000).formatted;

                $scope.totalFailedActivities = 0;
                $scope.totalDoneActivities = 0;
                $scope.totalWarningActivities = 0;
                $scope.totalAbortedActivities = 0;
                $scope.totalNotStartedActivities = 0;
                $scope.totalRunningActivities = 0;

                for (let i = 0; i < $scope.activitiesFatTable.length; i++) {
                    let activity = $scope.activitiesFatTable[i];

                    switch(activity.state) {
                        case 'FAILED':
                            $scope.totalFailedActivities++;
                        break;
                        case 'DONE':
                            if (activity.warnings.totalCount > 0) {
                                $scope.totalWarningActivities++;
                            } else {
                                $scope.totalDoneActivities++;
                            }
                        break;
                        case 'ABORTED':
                            $scope.totalAbortedActivities++;
                        break;
                        case 'SKIPPED':
                            $scope.totalAbortedActivities++;
                        break;
                        case 'NOT_STARTED':
                            $scope.totalNotStartedActivities++;
                        break;
                        case 'RUNNING':
                            $scope.totalRunningActivities++;
                        break;
                    }
                }
            }
            var rebuildActivitiesListDebounced = Debounce().withScope($scope).withDelay(10,200).wrap(rebuildActivitiesList);
            $scope.order = { column : "stateOrder" }
            $scope.$watch("order", rebuildActivitiesListDebounced, true);
            $scope.$watch("filter.activities", rebuildActivitiesListDebounced);

            $scope.onJobStatusUpdate = function() {

                TopNav.setItem(TopNav.ITEM_JOB, $stateParams.jobId, { name: $scope.jobStatus.baseStatus.def.name });
                
                $scope.activitiesFlat = $.map($scope.getJobActivities(), function(v, k) {
                    return v;
                });

                if (!$scope.jobStatus.removed) {
                    $scope.jobTotalWarningsCount = 0;
                    $scope.jobTotalEndedActivities = 0;

                    // Put an order on activity state
                    $.each($scope.activitiesFlat, function(idx, activity){
                        JobStatusUtils.statsifyActivity(activity, $scope.jobStatus);
                        if (activity.warnings) {
                            $scope.jobTotalWarningsCount += activity.warnings.totalCount;
                        }

                        if (activity.state !== 'NOT_STARTED' && activity.state !== 'RUNNING') {
                            $scope.jobTotalEndedActivities++;
                        }
                    });

                    rebuildActivitiesList();

                    /* If no activity selected yet, select the first OR the one pre-selected */
                    if (!$scope.selectedActivity) {
                        if ($rootScope.preSelectedActivity) {
                            $scope.selectActivity($rootScope.preSelectedActivity);
                            $rootScope.preSelectedActivity = null;
                        } else {
                            if ($scope.jobStatus.globalState.failed > 0) {
                                Assert.inScope($scope, 'activitiesFatTable');
                                for (let i = 0; i < $scope.activitiesFatTable.length; i++) {
                                    if ($scope.activitiesFatTable[i].state =="FAILED") {
                                        $scope.selectActivity($scope.activitiesFatTable[0]);
                                        break;
                                    }
                                }
                            } else if($scope.activitiesFlat.length) {
                                $scope.selectActivity($scope.activitiesFatTable[0]);
                            }
                        }

                    } else {
                        // "Re-select" it to update state
                        var previousId = $scope.selectedActivity.activityId;
                        $scope.selectedActivity = null;
                        for (let i = 0; i < $scope.activitiesFlat.length; i++) {
                            if ($scope.activitiesFlat[i].activityId == previousId) {
                                $scope.selectActivity($scope.activitiesFlat[i]);
                                break;
                            }
                        }
                        $scope.smartTail();
                    }
                    $scope.activityStats = {}
                    $scope.activityStats.runningRatio = $scope.jobStatus.globalState.running / $scope.jobStatus.globalState.total;
                    $scope.activityStats.not_startedRatio = $scope.jobStatus.globalState.notStarted / $scope.jobStatus.globalState.total;
                    $scope.activityStats.doneRatio = $scope.jobStatus.globalState.done / $scope.jobStatus.globalState.total;
                    $scope.activityStats.failedRatio = $scope.jobStatus.globalState.failed / $scope.jobStatus.globalState.total;
                }

                $timeout(function() { $rootScope.$broadcast("reflow"); });
            }

            $scope.$watch("jobStatus", function(nv, ov) {
                if (!nv) return;
                $scope.onJobStatusUpdate();
            }, true);

            var UIState = {};
            $scope.smartTail = function() {
                var saveLogState = function() {
                    var logPre = $('#logTailPre')[0];
                    UIState.logScroll = null;
                    UIState.logScrollFollow = false;
                    if(logPre) {
                        UIState.logScroll = logPre.scrollTop;
                        UIState.logScrollFollow = (logPre.scrollTop>=logPre.scrollHeight-logPre.clientHeight);
                    }
                };
                // It is very important to reapply changes AFTER the angular digest cycle
                var applyLogState = function() {
                    $timeout(function() {
                        var logPre = $('#logTailPre')[0];
                        if(UIState.logScroll != undefined && logPre) {
                            if(UIState.logScrollFollow) {
                                logPre.scrollTop = logPre.scrollHeight-logPre.clientHeight;
                            } else {
                                logPre.scrollTop = UIState.logScroll;
                            }
                        }
                    },0);
                };
                saveLogState();

                if ($scope.selectedActivity.state !== 'NOT_STARTED') {
                    DataikuAPI.flow.jobs.smartTailActivityLog($stateParams.projectKey, $stateParams.jobId, $scope.selectedActivity.activityId, 500).success(function (data) {
                        $scope.logTail = smartLogTailToHTML(data, $scope.logOptions.compactLog);
                        applyLogState();
                    }).error(function(data){
                        $scope.logTail = '';
                        applyLogState();
                    });
                }
            };

            $scope.showSummary = function() {
                $scope.closeContextualMenus();
                CreateModalFromTemplate("/templates/jobs/activity-summary-modal.html", $scope, null, function(modalScope){
                    modalScope.selectedActivity = $scope.selectedActivity;
                });
            };
        }
    };
});


/** Base directive for status page of a job in preview */
app.directive("jobPreview", function(Assert, DataikuAPI, $stateParams, $timeout, $rootScope, Debounce, $filter, TopNav, JobStatusUtils) {
    return {
        scope: true,
        controller: function($scope, $element){
            $scope.focusOnSelectedItem = function() {
                Assert.inScope($scope, 'selectedItemData');
                $scope.filter.activities = $scope.selectedItemData.uiFilterExpr;
                $scope.topNav.tab = "activities";
            };

            $scope.selectedItemData = {};

            $scope.$watch("jobStatus", function(nv, ov) {
                if (!nv) return;
                TopNav.setItem(TopNav.ITEM_JOB, $stateParams.jobId, {name: $scope.jobStatus.baseStatus.def.name});
                if ($scope.jobState == "WAITING_CONFIRMATION") {
                    DataikuAPI.flow.jobs.getPreviewResult($stateParams.projectKey, $stateParams.jobId).success(function(data){
                        $scope.jobPreviewResult = data;
                        $.each($scope.getJobPreviewAllActivities(), function(k, v){
                            $.each(v.targets, function(k2, v2) {
                                v.mainPartition = v2.partitionId;
                            });
                            if (v.mainPartition == 'NP') v.mainPartition = null;
                            var activityInJobStatus = $scope.getInJobActivities(k);
                            if (activityInJobStatus) {
                                v.activityType = activityInJobStatus.activityType;
                                v.pipelineRecipes = activityInJobStatus.pipelineRecipes;
                            }
                        });
                        $scope.jobPreviewResultFlat = $.map($scope.getJobPreviewAllActivities(), function(v, k){
                            return v;
                        });
                        rebuildActivitiesList();
                    })
                }
                $timeout(function() {$rootScope.$broadcast("reflow");},20);
            }, true);


            $scope.sortBy = [
                {'value': 'recipeName', 'label': 'Recipe' },
                {'value': 'targets[0].datasetName','label': 'Output dataset'},
                {'value': 'mainPartition','label': 'Output partition'}
            ];
            var rebuildActivitiesList = Debounce().withScope($scope).withDelay(10,200).wrap(function() {
                $scope.jobPreviewResultTable = filterSortLimitTagsAndQ($filter,
                    $scope.jobPreviewResultFlat, { q : $scope.filter.activities},
                    {
                        column : [$scope.order.column, 'partialExecutionOrder', 'activityId'],
                        reverse : $scope.order.reverse
                    },
                    20000000).formatted;
                if (!$scope.selectedActivity && $scope.jobPreviewResultTable.length) {
                    $scope.selectActivity($scope.jobPreviewResultTable[0]);
                }
            });
            $scope.order = { column : "recipeName" }
            $scope.$watch("order", rebuildActivitiesList, true);
            $scope.$watch("filter.activities", rebuildActivitiesList);
            rebuildActivitiesList();

            $scope.disableActivity = function(activity) {
                if ($scope.disabledActivities.indexOf(activity.activityId) < 0) {
                    $scope.disabledActivities.push(activity.activityId);
                }
                // recursively disable depending activities
                $.each($scope.jobPreviewResultTable, function(idx, activity2) {
                    if (!$scope.disabledActivities.includes(activity2.activityId)
                        && activity2.dependencies.includes(activity.activityId)) {
                            $scope.disableActivity(activity2, true);
                    }
                });
            }
            $scope.enableActivity = function(activity) {
                removeFirstFromArray($scope.disabledActivities, activity.activityId);
                // recursively enable dependencies.
                $.each(activity.dependencies, function(idx, depId) {
                    $scope.enableActivity($scope.getInJobPreviewAllActivities(depId));
                });
            }

            $scope.selectActivity = function(activity) {
                activity = $scope.jobPreviewResultTable.find(activityFatTable => activityFatTable.activityId === activity.activityId);
                if (!activity) { return; }
                $scope.selectedActivity = activity;
                $scope.unhighlightActivities();
                d3.selectAll($element.find('svg .selected')).classed("selected", false);
                JobStatusUtils.selectRecipes(activity, $element);
                let activityIndex = $scope.jobPreviewResultTable.findIndex(jobPreviewActivity => jobPreviewActivity.activityId === activity.activityId);
                $scope.$broadcast('scrollToLine', activityIndex);
            };

            $scope.highlightActivity = function(activity) {
                let retrievedActivity = $scope.jobPreviewResultTable.filter(jobPreviewActivity => jobPreviewActivity.activityId === activity.activityId)[0];
                if (retrievedActivity) {
                    retrievedActivity.highlighted = true;
                }
            };

            $scope.unhighlightActivities = function() {
                $scope.jobPreviewResultTable.forEach(jobPreviewActivity => jobPreviewActivity.highlighted = false);
            };

            $scope.showEnableActivity = function(activityId) {
                return $scope.disabledActivities.includes(activityId);
            }

            $scope.getActivitiesByDatasetName = function (datasetName) {
                if (!$scope.jobPreviewResultTable) { return; }
                return Object.values($scope.jobPreviewResultTable).filter(activity => {
                    let isTarget = activity.targets.filter(target => {
                        return target.datasetName === datasetName;
                    }).length > 0;
                    return isTarget;
                });
            };

            $scope.getActivitiesByRecipeName = function (recipeName) {
                if (!$scope.jobPreviewResultTable) { return; }
                return Object.values($scope.jobPreviewResultTable).filter(activity => {
                    return activity.recipeName == recipeName;
                });
            };

            let activitiesForRecipeName = function(recipeName) {
                let result = [];
                $.each($scope.getJobPreviewAllActivities(), function (activityId, activity) {
                    if (activityIncludesRecipe(activity, recipeName)) {
                        result.push(activity);
                    }
                });
                return result;
            };

            let activityIncludesRecipe = function(activity, recipeName) {
                return activity.recipes.map(recipe => recipe.name).includes(recipeName)
                    // For backward compatibility with jobs created by a version of DSS before 4.1.2
                    || (activity.recipeName && activity.recipeName === recipeName);
            };

            $scope.nbDisabledForRecipe = function(recipeName) {
                return $scope.disabledActivities
                    .map(activityId => $scope.getInJobPreviewAllActivities(activityId))
                    .filter(activity => activityIncludesRecipe(activity, recipeName))
                    .length;
            };
            $scope.getDisabledStateForRecipe = function(recipeName) {
                let disabled = $scope.nbDisabledForRecipe(recipeName);
                if (disabled === 0) {
                    return "recipe-enabled";
                }

                let total = activitiesForRecipeName(recipeName).length;
                if (disabled === total) {
                    return "recipe-disabled";
                }
                return "recipe-partial";
            };

            // TODO: Should use full recipe id !!
            $scope.disableAllForRecipe = function(recipeName){
                activitiesForRecipeName(recipeName).forEach($scope.disableActivity);
            };
            $scope.enableAllForRecipe = function(recipeName){
                activitiesForRecipeName(recipeName).forEach($scope.enableActivity);
            };

            $scope.getJobPreviewAllActivities = function() {
                if (!$scope.jobPreviewResult) return {};
                if (!$scope.jobPreviewResult.job) return {};
                if (!$scope.jobPreviewResult.job.allActivities) return {};
                return $scope.jobPreviewResult.job.allActivities;
            };
            $scope.getJobPreviewBeforePruneAllActivities = function() {
                if (!$scope.jobPreviewResult) return {};
                if (!$scope.jobPreviewResult.jobBeforePrune) return {};
                if (!$scope.jobPreviewResult.jobBeforePrune.allActivities) return {};
                return $scope.jobPreviewResult.jobBeforePrune.allActivities;
            };
            $scope.getInJobPreviewAllActivities = function(activityId) {
                return $scope.getJobPreviewAllActivities()[activityId];
            };
            $scope.getInJobPreviewBeforePruneAllActivities = function(activityId) {
                return $scope.getJobPreviewBeforePruneAllActivities()[activityId];
            };

        }

    }
});

/** Base directive for preview of clicked job in jobs list page */
app.directive("clickedJobPreview", function($state, $rootScope) {
    return {
        controller: function ($scope) {

            var jobStatusBaseStatusActivities = null;
            var jobStatusBaseStatusJobAllActivities = null;
            var jobStatusBaseStatusJobBeforePruneAllActivities = null;
            $scope.setJobStatusData = function(data) {
            	$scope.elapsedTime = data && data.baseStatus ? (new Date().getTime()) - data.baseStatus.jobStartTime : 0;
                if (data == null) {
                    jobStatusBaseStatusActivities = null;
                    jobStatusBaseStatusJobAllActivities = null;
                    jobStatusBaseStatusJobBeforePruneAllActivities = null;
                    $scope.jobStatus = null;
                } else {
                    if (!data.baseStatus) {
                        jobStatusBaseStatusActivities = null;
                        jobStatusBaseStatusJobAllActivities = null;
                        jobStatusBaseStatusJobBeforePruneAllActivities = null;
                    } else {
                        jobStatusBaseStatusActivities = data.baseStatus.activities;
                        // a bit of fixup
                        angular.forEach(jobStatusBaseStatusActivities, function(activity, activityName) {
                            // the 'classic' bug-report generating glitch: when a job is aborted
                            // by a DSS restart, then the job is properly in ABORTED state but some
                            // activities are still in RUNNING and appear as such in the UI (blinking).
                            // so we set them to ABORTED so that the user is not confused
                            if (data.baseStatus.state == 'ABORTED' && activity.state == 'RUNNING') {
                                activity.state = 'ABORTED';
                            }
                        });
                        data.baseStatus.activities = null;
                        if (!data.baseStatus.job) {
                            jobStatusBaseStatusJobAllActivities = null;
                        } else {
                            jobStatusBaseStatusJobAllActivities = data.baseStatus.job.allActivities;
                            data.baseStatus.job.allActivities = null;
                        }
                        if (!data.baseStatus.jobBeforePrune) {
                            jobStatusBaseStatusJobBeforePruneAllActivities = null;
                        } else {
                            jobStatusBaseStatusJobBeforePruneAllActivities = data.baseStatus.jobBeforePrune.allActivities;
                            data.baseStatus.jobBeforePrune.allActivities = null;
                        }
                    }
                    $scope.jobStatus = data;
                }
            };

            $scope.getJobActivities = function() {
                return jobStatusBaseStatusActivities || {};
            };
            $scope.getJobAllActivities = function() {
                return jobStatusBaseStatusJobAllActivities || {};
            };
            $scope.getJobBeforePruneAllActivities = function() {
                return jobStatusBaseStatusJobBeforePruneAllActivities || {};
            };
            $scope.getInJobActivities = function(activityId) {
                return $scope.getJobActivities()[activityId];
            };
            $scope.getInJobAllActivities = function(activityId) {
                return $scope.getJobAllActivities()[activityId];
            };
            $scope.getInJobBeforePruneAllActivities = function(activityId) {
                return $scope.getJobBeforePruneAllActivities()[activityId];
            };
            $scope.goToActivity = function(activity) {
                const job = $scope.selection.selectedObject;
                $rootScope.preSelectedActivity = activity;
                $state.go('projects.project.jobs.job', {'jobId': job.def.id });
            };
        }
    }
});
})();

(function(){
'use strict';

var app = angular.module('dataiku.controllers');

app.controller('FlowJobsBrowserController', function($scope, WT1, $stateParams, $state, DataikuAPI, Dialogs,
    $controller, $location, Notification, TopNav, Throttle, JobStatusUtils, $filter, $element) {

    $controller('_TaggableObjectsListPageCommon', {$scope: $scope});

    TopNav.setLocation(TopNav.TOP_JOBS, "jobs", TopNav.TABS_NONE, null);
    TopNav.setNoItem();

    $scope.maxDisplayedItems = 0;
    $scope.statusLabel = 'Any status';
    $scope.userLabel = 'All users'
    $scope.isJobsList = true;
    $scope.noWatch = true;
    $scope.noStar = true;
    $scope.noDelete = true;
    $scope.noTags = true;
    $scope.listItems;
    $scope.queryFilters = {
        status: '',
        user: '',
        search: ''
    }

    if ($scope.isDSSAdmin()) {
        DataikuAPI.admin.users.list().success(function(data) {
            $scope.users = data;
        }).error(setErrorInScope.bind($scope));
    }

    /* List common stuff */
    $scope.sortBy = [
        { value: '-def.initiationTimestamp', label: 'Newest' },
        { value: 'def.initiationTimestamp', label: 'Oldest' },
        { value: 'state', label: 'Status' },
        { value: 'def.initiator', label: 'User A to Z' },
        { value: '-def.initiator', label: 'User Z to A' },
        { value: '-(endTime - startTime)', label: 'Longest' },
        { value: 'endTime - startTime', label: 'Shortest' }
    ];

    $scope.sortCookieKey = 'jobs';
    $scope.maxItems = 40;

    $scope.list = function() {
        resetErrorInScope($scope);
          DataikuAPI.flow.jobs.listLastJobs($stateParams.projectKey, 100).success(function (data) {
            $scope.listItems = data;
            let now = Date.now();
            $scope.listItems.forEach(function(item) {
                item.timeSinceInitiation = now - item.def.initiationTimestamp;
                item.partitionsCount = 0;
                item.datasetsCount = 0;
                item.def.outputs.forEach(function(output) {
                    if (output.targetPartition) {
                        item.partitionsCount++;
                    }
                    if (output.targetDataset) {
                        item.datasetsCount++;
                    }
                });
                // Adding warning status on UX side
                if (item.warningsCount > 0) {
                    item.stateTitle = item.state + ' WITH WARNINGS';
                } else {
                    item.stateTitle = item.state;
                }
            });

            $scope.$broadcast("clearMultiSelect");
        }).error(setErrorInScope.bind($scope));
    };

    $scope.selection = $.extend({
        filterParams: {
            userQueryTargets: ["def.name", "state"],
            propertyRules: { name:"def.name", recipe:"def.recipe" }
        },
        orderQuery: $scope.sortBy[0].value,
        orderReversed: false,
        customFilterWatch: "queryFilters",
    }, $scope.selection || {});

    $scope.list();

    $scope.$on("$destroy", Notification.registerEvent("job-state-change", Throttle().withScope($scope).withDelay(10000).wrap(function() {
        $scope.list();
    })));

    $scope.isFiltering = function () {
        return $scope.queryFilters.search.length > 0 || $scope.queryFilters.status.length > 0 || $scope.queryFilters.user.length > 0;
    }

    $scope.resetFilters = function() {
        $scope.setStatusFilter('', 'Any status');
        $scope.setUserFilter('', 'All users');
        $scope.setSearchFilter('');
        $scope.selection.filteredObjects = $scope.listItems;
    }

    $scope.filterJobsList = function () {

        if (!$scope.selection) {
            return;
        }

        $scope.selection.allObjects = $scope.listItems || [];

        if (!$scope.selection.allObjects) {
            $scope.selection.allObjects = [];
            $scope.selection.loaded = false;
        } else {
            $scope.selection.loaded = true;
        }

        if ($scope.selection.allObjects.constructor !== Array) {
            $scope.selection.allObjects = $.map($scope.selection.allObjects, function(v,k) {v._name=k; return [v]});
        }

        $scope.selection.allObjects.forEach(function (c, i) {
            c.$idx = i;
        });

        // Filtering on full text query
        let filteredJobsList = $scope.selection.allObjects;

        // Filtering on users
        if ($scope.queryFilters.user && $scope.queryFilters.user.length) {
            filteredJobsList = $.grep(filteredJobsList, function(item) {
                return item.def.initiator === $scope.queryFilters.user;
            });
        }

        if ($scope.queryFilters.status && $scope.queryFilters.status.length) {
            filteredJobsList = $.grep(filteredJobsList, function(item) {
                return $scope.queryFilters.status === item.stateTitle;
            });
        }

        if ($scope.queryFilters.search && $scope.queryFilters.search.length) {
            filteredJobsList = $.grep(filteredJobsList, function(item) {
                return item.def.name.toLowerCase().indexOf($scope.queryFilters.search.toLowerCase()) > -1
                || (item.def.outputs && item.def.outputs[0] && item.def.outputs[0].targetDataset.toLowerCase().indexOf($scope.queryFilters.search.toLowerCase()) > -1)
                || (item.def.outputs && item.def.outputs[0] && item.def.outputs[0].targetPartition && item.def.outputs[0].targetPartition.toLowerCase().indexOf($scope.queryFilters.search.toLowerCase()) > -1);
            });
        }

        return filteredJobsList;
    }

    $scope.selection.customFilter = $scope.filterJobsList;

    $scope.setStatusFilter = function (status, statusLabel) {
        $scope.queryFilters.status = status;
        $scope.statusLabel = statusLabel;
    }

    $scope.setUserFilter = function (user, userLabel) {
        $scope.queryFilters.user = user;
        $scope.userLabel = userLabel;
    }

    $scope.handleJobStatusChange = function(evtType, message) {
        $.grep($scope.jobs, function(job) {
            return job.def.id == message.jobId;
        }).map(function(job) {
            if (job.attempts[0]) {
                if (job.attempts[0]) {
                    job.attempts[0].state = message.state;
                }
            }
        });
    };

    var jobStatusBaseStatusActivities = null;
    $scope.setJobStatusData = function(data) {
    	$scope.elapsedTime = data && data.baseStatus ? (new Date().getTime()) - data.baseStatus.jobStartTime : 0;
        if (data == null) {
            jobStatusBaseStatusActivities = null;
            $scope.jobStatus = null;
        } else {
            if (!data.baseStatus) {
                jobStatusBaseStatusActivities = null;
            } else {
                jobStatusBaseStatusActivities = data.baseStatus.activities;
                data.baseStatus.activities = null;
                if (data.baseStatus.job) {
                    data.baseStatus.job.allActivities = null;
                }
                if (data.baseStatus.jobBeforePrune) {
                    data.baseStatus.jobBeforePrune.allActivities = null;
                }
            }
            $scope.jobStatus = data;
        }
    };

    $scope.getJobActivities = function() {
        return jobStatusBaseStatusActivities || {};
    };
    $scope.getInJobActivities = function(activityId) {
        return $scope.getJobActivities()[activityId];
    };

    $scope.$stateParams = $stateParams;
    $scope.jobs = undefined;
    $scope.currentJob = undefined;
    $scope.setJobStatusData(undefined);

    $scope.clearListWithConfirmation = function(filter) {
        var title = 'Clear failed jobs';
        var msg = 'Are you sure you want to clear logs for all failed jobs? Note: this only removes job logs, not the jobs themselves.';
        if(filter == 'finished') {
            title = 'Clear finished jobs';
            msg = 'Are you sure you want to clear logs for all finished jobs? Note: this only removes job logs, not the jobs themselves.';
        }
        Dialogs.confirm($scope, title, msg).then(function() {
            $scope.clearList(filter);
        });
    };

    $scope.clearList = function(filter) {
        DataikuAPI.flow.jobs.clearLogsWithFilter($stateParams.projectKey,filter).success(function(data) {
            $scope.list();
        }).error(setErrorInScope.bind($scope));
    };

    $scope.viewJob = function (job) {
        $state.transitionTo('projects.project.jobs.job', { 'id': job.def.id });
    };

    $scope.filter = {}
    $scope.order = { column : "stateOrder" }
    var rebuildActivitiesList = function(activitiesFlat) {
        $scope.activitiesFatTable = filterSortLimitTagsAndQ(
            $filter,
            activitiesFlat,
            { q : $scope.filter.activities},
            {
                column : [$scope.order.column, 'partialExecutionOrder', 'activityId'],
                reverse : $scope.order.reverse
            },
            2000000).formatted;
    }

    var setJobStatus = function(jobId) {
        DataikuAPI.flow.jobs.getJobStatus($stateParams.projectKey, jobId).success(function (data) {
            $scope.setJobStatusData(data);
            var activitiesFlat = [];
            for (var actId in $scope.getJobActivities()) {
                if (!$scope.getJobActivities().hasOwnProperty(actId)) {
                    continue;
                }
                var activity = $scope.getInJobActivities(actId);
                if (activity.warnings) {
                    $scope.jobStatus.warningsCount += activity.warnings.totalCount;
                }
                if (activity.state == 'RUNNING') {
                    activity.duration = new Date().getTime() - activity.startTime;
                } else if (activity.endTime > 0) {
                    activity.duration = activity.endTime - activity.startTime;
                } else if (activity.startTime > 0 && $scope.jobStatus.baseStatus.jobEndTime > 0) {
                    activity.duration = $scope.jobStatus.baseStatus.jobEndTime - activity.startTime; // probably aborted
                } else {
                    activity.duration = 0;
                }
                activitiesFlat.push(activity);
            }
            $.each(activitiesFlat, function(idx, activity){
                JobStatusUtils.statsifyActivity(activity, $scope.jobStatus);
            });
            rebuildActivitiesList(activitiesFlat);
        }).error(setErrorInScope.bind($scope));
    }

    $scope.$watch('job',function(nv) {
        if (!nv) return;
        setJobStatus(nv.def.id);
    });

    $scope.selectActivity = function(activity) {
        activity = $scope.activitiesFatTable.find(activityFatTable => activityFatTable.activityId === activity.activityId);
        if (!activity) { return; }
        $scope.selectedActivity = activity;
        $scope.unhighlightActivities();
        d3.selectAll($element.find('svg .selected')).classed("selected", false);
        JobStatusUtils.selectRecipes(activity, $element);
        let activityIndex = $scope.activitiesFatTable.findIndex(activityFatTable => activityFatTable.activityId === activity.activityId);
        $scope.$broadcast('scrollToLine', activityIndex);
    };

    $scope.hoverActivity = function(activity) {
        JobStatusUtils.selectRecipes(activity, $element);
    };

    $scope.unhoverActivity = function() {
        d3.selectAll($element.find('svg .selected')).classed("selected", false);
    };

    $scope.highlightActivity = function(activity) {
        let retrievedActivity = $scope.activitiesFatTable.find(activityFatTable => activityFatTable.activityId === activity.activityId)[0];
        if (retrievedActivity) {
            retrievedActivity.highlighted = true;
        }
    };

    $scope.unhighlightActivities = function() {
        $scope.activitiesFatTable.forEach(activityFatTable => activityFatTable.highlighted = false);
    }

    $scope.getActivitiesByDatasetName = function (datasetName) {
        if (!$scope.activitiesFatTable) { return; }
        return Object.values($scope.activitiesFatTable).filter(activity => {
            let isTarget = activity.targets.filter(target => {
                return target.datasetName === datasetName;
            }).length > 0;
            return isTarget;
        });
    };

    $scope.getActivitiesByRecipeName = function (recipeName) {
        if (!$scope.activitiesFatTable) { return; }
        return Object.values($scope.activitiesFatTable).filter(activity => {
            return activity.recipeName == recipeName;
        });
    };

    $scope.hasDuration =function (item) {
        return item != null && item.duration > 0;
    };

    $scope.abortJob = function (jobId) {
        Dialogs.confirm($scope, 'Aborting a job','Are you sure you want to abort this job ?').then(function() {
            DataikuAPI.flow.jobs.abort($stateParams.projectKey, jobId).success(function(data) {
                $scope.list();
                setJobStatus(jobId);
            }).error(setErrorInScope.bind($scope));
        });
    };

    $scope.deleteSelected = function() {

        var toDelete = $scope.selection.selectedObjects;

        if (toDelete.length==0) {
            return;
        }

        var title = 'Confirm logs deletion';
        var message = 'Are you sure you want to clear the logs for the selected job?';

        if (toDelete.length>1) {
            title='Confirm multiple logs deletion';
            message = 'Are you sure you want to clear logs for the '+toDelete.length+' selected jobs?';
        }

        Dialogs.confirm($scope,title,message).then(function() {
            var cnt = toDelete.length;
            for (var k in toDelete){
                WT1.event("job-delete", {modelBenchId : toDelete[k].def.id});
                DataikuAPI.flow.jobs.clearLogs($stateParams.projectKey, toDelete[k].def.id).error(setErrorInScope.bind($scope))['finally'](function() {
                    cnt--;
                    if(cnt==0) {
                        $scope.list();
                    }
                });
            }
        });

    };
});

app.directive('multiBuildSupport', function($stateParams, DataikuAPI, Dialogs, CreateModalFromTemplate) {
    return {
        restrict: 'AE',
        link : function(scope, element, attrs) {

            function openBuildDownstreamModal(errorMessage) {
                return function(data) {
                    if (!data.length) {
                        Dialogs.error(scope, "Nothing to build", errorMessage);
                    } else {
                        CreateModalFromTemplate(
                            "/templates/flow-editor/tools/build-downstream-modal.html",
                            scope,
                            "BuildDownstreamController",
                            function(modalScope) {
                                modalScope.initModal(data);
                            }
                        );
                    }
                }
            }

            scope.buildSelectedComputables = function(selectedComputables) {
                // Get all buildable from backend and filter based on selection. TODO @flow Too slow?
                return DataikuAPI.flow.getComputables(selectedComputables)
                    .success(openBuildDownstreamModal("The selected items are not buildable."))
                    .error(setErrorInScope.bind(scope));
            };

            scope.buildAll = function() {
                DataikuAPI.flow.listDownstreamComputables($stateParams.projectKey)
                    .success(openBuildDownstreamModal("This project flow has no buildable dataset."))
                    .error(setErrorInScope.bind(scope));
            };

            scope.buildFromRecipe = function(recipeId) {
                DataikuAPI.flow.listDownstreamComputables($stateParams.projectKey, {runnable: recipeId})
                    .success(openBuildDownstreamModal())
                    .error(setErrorInScope.bind(scope));
            };

            scope.buildFromComputable = function(computableId) {
                DataikuAPI.flow.listDownstreamComputables($stateParams.projectKey, {computable: computableId})
                    .success(openBuildDownstreamModal("This dataset is not linked to any recipe."))
                    .error(setErrorInScope.bind(scope));
            };
        }
    }
});

app.directive('jobActivitiesList', function(Assert, Logger) {
    return {
        restrict: 'E',
        replace : 'true',
        scope : {
            activitiesFatTable: '=',
            rowHeight: '@',
            jobRemoved: '=',
            onActivityClick: '=',
            onMouseOverActivity: '=?',
            onMouseLeaveActivity: '=?'
        },
        templateUrl : "/templates/jobs/job-activities-list.html"
    }
});

app.directive('pipelineActivityTitle', function() {
    return {
        restrict: 'E',
        replace : true,
        scope: {
            activity: '='
        },
        link : function(scope) {
            scope.$watch('activity', function() {
                const activity = scope.activity;
                scope.showItem = isPipeline(activity);
                if (!scope.showItem) {
                    return;
                }
                scope.pipelineTypeText = (activity.activityType === ACTIVITY_TYPE_SPARK_PIPELINE ? 'Spark' : 'SQL');
                scope.activityCount = activity.pipelineRecipes.length;
            });
        },
        templateUrl : "/templates/jobs/pipeline-activity-title.html"
    }
});

}());

(function(){
    'use strict';

    var app = angular.module('dataiku.flow.runtime');

    /** Directive job regular status */
    app.directive('jobStatusGraph', function ($state, $stateParams, $rootScope, DataikuAPI, ContextualMenu, FlowGraph, FlowGraphSelection, FlowGraphHighlighting, StateUtils, GraphZoomTrackerService) {
        return {
            controller: function ($scope, $element, $attrs) {

                const MAX_NODES = 200;
                let directiveScope = $scope, jobId, shouldGetGraph, graphData, jobGraph;
                const isPreview = $attrs.preview !== undefined;

                // Whether or not the flow is too big to be directly rendered (on list page!)
                $scope.hasBigFlow = false;
                // To force big flow rendering (on user manual action)
                $scope.forceFlow = false;

                // Returns the targets of the given activity
                function getTargetsByRecipeName(recipeName) {
                    let targets = [];
                    let activities = $scope.getJobAllActivities();
                    Object.keys(activities).forEach(function(activityKey) {
                        let activity = activities[activityKey];
                        if (graphVizEscape('recipe_' + activity.recipeName) === recipeName) {
                            targets = targets.concat(activity.targets);
                        }
                    });
                    return targets;
                }

                function fadeOutActivity(recipeName, node, fadeOutRecipe=true) {
                    if (fadeOutRecipe) { node.classList.add('fade-out--no-filter') }
                    let targets = getTargetsByRecipeName(recipeName);
                    targets.forEach(function(target) {
                        d3.select('svg [data-id="' + graphVizEscape('dataset_' + target.projectKey + "." + target.datasetName) + '"]').classed("fade-out--no-filter", true);
                        d3.select('svg [data-id="' + graphVizEscape('managedfolder_' + target.projectKey + "." + target.datasetName) + '"]').classed("fade-out--no-filter", true);
                        d3.select('svg [data-id="' + graphVizEscape('savedmodel_' + target.projectKey + "." + target.datasetName) + '"]').classed("fade-out--no-filter", true);
                    });
                }

                function setStatus(element, classes, value) {
                    let statusValue = document.createElement('span');
                    let statusIcon =  document.createElement('i');
                    statusIcon.className = 'node-status__icon ' + classes;
                    statusValue.textContent = value;
                    statusValue.className = 'node-status__value';
                    element.appendChild(statusIcon);
                    element.appendChild(statusValue);
                }

                function setGraphData(serializedGraph) {
                    if (serializedGraph) {
                        $scope.nodesGraph = serializedGraph;
                        FlowGraph.set($scope.nodesGraph);
                        $scope.nodesGraph.filteredOutElementCount = Object.values(serializedGraph.filteredOutObjectsByType).reduce((a, b) => a + b, 0);
                        $scope.nodesGraph.nodesOnGraphCount = Object.keys(serializedGraph.nodes).length;
                        const displayedElementCount = Object.values(serializedGraph.includedObjectsByType).reduce((a,b)=>a+b, 0);
                        $scope.isFlowEmpty = ($scope.nodesGraph.filteredOutElementCount || 0) + displayedElementCount === 0;
                        $scope.allFilteredOut = !$scope.isFlowEmpty && displayedElementCount === 0;
                    }
                }

                function getGraph() {
                    let jobElements = [];
                    let jobAllActivities = $scope.getJobAllActivities();

                    Object.keys(jobAllActivities).forEach(function(activityKey) {
                        let activity = jobAllActivities[activityKey];
                        activity.recipes.forEach(recipe => jobElements.push(graphVizEscape('recipe_' + recipe.name)));
                        activity.sources.forEach(function(source) {
                            jobElements.push(graphVizEscape('dataset_' + source.projectKey + "." + source.datasetName));
                            jobElements.push(graphVizEscape('managedfolder_' + source.projectKey + "." + source.datasetName));
                            jobElements.push(graphVizEscape('savedmodel_' + source.projectKey + "." + source.datasetName));
                            jobElements.push(graphVizEscape('modelevaluationstore_' + source.projectKey + "." + source.datasetName));
                        });
                        activity.targets.forEach(function (target) {
                            jobElements.push(graphVizEscape('dataset_' + target.projectKey + "." + target.datasetName));
                            jobElements.push(graphVizEscape('managedfolder_' + target.projectKey + "." + target.datasetName));
                            jobElements.push(graphVizEscape('savedmodel_' + target.projectKey + "." + target.datasetName));
                            jobElements.push(graphVizEscape('modelevaluationstore_' + target.projectKey + "." + target.datasetName));
                        });
                        // For backward compatibility with jobs created by a version of DSS before 4.1.2
                        if (activity.recipeName) {
                            jobElements.push(graphVizEscape('recipe_' + activity.recipeName));
                        }
                    });

                    return jobElements;
                }

                const selectionStrategy = {
                    onItemClick: function(item) {
                        // Select the clicked item
                        d3.selectAll($element.find('svg .selected')).classed("selected", false);
                        let elt = $element.find('svg [data-id="' + item.id + '"]')[0];
                        d3.select(elt).classed("selected", true);

                        // Select activities matching the current item
                        let matchingActivities;

                        switch (item.nodeType) {
                            case 'LOCAL_DATASET':
                                matchingActivities = directiveScope.getActivitiesByDatasetName(item.name);
                                break;
                            case 'RECIPE':
                                matchingActivities = directiveScope.getActivitiesByRecipeName(item.name);
                                break;
                        }

                        if (matchingActivities != undefined) {
                            matchingActivities.forEach(function(activity, index) {
                                if (index === 0) {
                                    directiveScope.selectActivity(activity);
                                } else {
                                    directiveScope.highlightActivity(activity);
                                }
                            });
                        }
                    }
                };

                // Resize around the job nodes.
                $scope.$emit('setResizeStrategy', 'highlight');

                function setStatusOnGraph() {
                    $scope.svg = $element.find('svg');
                    $scope.jobStatus && $scope.svg && $.each($scope.jobStatus.stateByGraphNodeId, function (key, value) {
                        let svgDOM = $($scope.svg).get(0);
                        let node = svgDOM && svgDOM.querySelector('g[data-id="'+ key + '"]');
                        let nodeTotem = node && node.querySelector('.node-totem span');
                        let flowNode = FlowGraph.node(key);
                        let hasMultipleStatus = value.done + value.running + value.failed + value.notStarted + value.aborted + value.warning + value.skipped > 1;
                        let isJobFinished = $scope.jobStatus && $scope.jobStatus.baseStatus
                            && $scope.jobStatus.baseStatus.state != 'RUNNING'
                            && $scope.jobStatus.baseStatus.state != 'NOT_STARTED'
                            && $scope.jobStatus.baseStatus.state != 'WAITING_CONFIRMATION';

                        if (!node) {
                            return;
                        }

                        // Dynamically remove "never-built-computable" style where needed (successor of done recipes)
                        if (['DONE', 'WARNING'].includes(value.state)) {
                            node.setAttribute('data-state', value.state);
                            if (flowNode.successors) {
                                flowNode.successors.forEach(s => {
                                    let nodeElt = FlowGraph.d3NodeWithId(s);
                                    window.nodeElt = nodeElt;
                                    if (nodeElt) {
                                        $(nodeElt[0]).find('.never-built-computable').removeClass('never-built-computable')
                                    }
                                })
                            }
                        }

                        // Add global state and fade non-builded stuff if not in preview mode
                        switch (value.state) {
                            case 'DONE':
                                nodeTotem.className += ' node-totem__status-icon icon-dku-success text-success';
                                nodeTotem.setAttribute('title', 'DONE');
                                break;
                            case 'WARNING':
                                nodeTotem.className += ' node-totem__status-icon icon-dku-warning text-warning';
                                nodeTotem.setAttribute('title', 'WARNING');
                                break;
                            case 'FAILED':
                                nodeTotem.className += ' node-totem__status-icon icon-dku-error text-error';
                                nodeTotem.setAttribute('title', 'FAILED');
                                break;
                            case 'NOT_STARTED':
                                nodeTotem.className += ' node-totem__status-icon icon-dku-queued text-weak';
                                nodeTotem.setAttribute('title', 'NOT STARTED');
                                !isPreview && fadeOutActivity(key, node);
                                break;
                            case 'RUNNING':
                                nodeTotem.className += ' node-totem__status-icon';
                                // Make the icon spin only if the job is not finished. If job is finished do not spin because it means the activity has only partially run.
                                if (!isJobFinished) {
                                    // nodeTotem.className += ' icon-spin'; DISABLED for now, nasty animation bug in chrome svg, does not work at all
                                    nodeTotem.setAttribute('title', 'RUNNING');
                                } else {
                                    nodeTotem.setAttribute('title', 'PARTIALLY RAN');
                                }
                                let iconBar = document.createElement('span');
                                iconBar.className = 'dku-loader';
                                nodeTotem.appendChild(iconBar);
                                break;
                            case 'ABORTED':
                                nodeTotem.className += ' node-totem__status-icon icon-dku-pause text-debug';
                                !isPreview && fadeOutActivity(key, node);
                                nodeTotem.setAttribute('title', 'ABORTED');
                                break;
                            case 'SKIPPED':
                                nodeTotem.className += ' node-totem__status-icon icon-step-forward text-debug';
                                nodeTotem.setAttribute('title', 'SKIPPED');
                                !isPreview && fadeOutActivity(key, node);
                                break;
                        }

                        // Add status counts
                        if (hasMultipleStatus) {
                            let nodeStatus = makeSVG('foreignObject', {
                                x: -100,
                                y: 110,
                                width: 300,
                                height: 42,
                                class: 'node-status'
                            });

                            nodeTotem.parentElement.parentElement.appendChild(nodeStatus);

                            if (value.failed > 0) {
                                setStatus(nodeStatus, 'icon-dku-error text-error', value.failed);
                            }

                            if (value.warning > 0) {
                                setStatus(nodeStatus, 'icon-dku-warning text-warning', value.warning);
                            }

                            if (value.notStarted > 0) {
                                setStatus(nodeStatus, 'icon-dku-queued text-weak', value.notStarted);
                            }

                            if (value.skipped > 0) {
                                setStatus(nodeStatus, 'icon-step-forward text-debug', value.skipped);
                            }

                            if (value.aborted > 0) {
                                setStatus(nodeStatus, 'icon-dku-pause text-debug', value.aborted);
                            }

                            if (value.done > 0) {
                                setStatus(nodeStatus, 'icon-dku-success text-success', value.done);
                            }
                        }
                    });
                }

                function reset() {
                    FlowGraphHighlighting.removeHighlights();
                    FlowGraphHighlighting.removeFiltersRemoved();
                    let elements = document.querySelectorAll('.node-status');
                    elements.forEach(element => element.remove());
                    let nodes = FlowGraph.get() && FlowGraph.get().nodes;
                    if (nodes) {
                        $.each(FlowGraph.get().nodes, function (nodeId) {
                            let nodeElt = FlowGraph.d3NodeWithId(nodeId);
                            if (nodeElt) {
                                nodeElt.classed('out-of-focus', false)
                            }
                        });
                    }
                }

                function draw(force = false) {
                    if (graphData) {
                        // On jobs pages, if there is more than {MAX_NODES} nodes, consider we have a big flow (et Oli... wait what?) and we don't draw it
                        $scope.hasBigFlow = Object.keys(graphData.nodes).length >= MAX_NODES;

                        if (force === true) {
                            $scope.forceFlow = true;
                        }

                        setGraphData(graphData);

                        jobGraph = getGraph();

                        if (jobGraph && !$scope.hasBigFlow || $scope.forceFlow) {
                            $scope.$emit('drawGraph', null, true);

                            reset();

                            FlowGraphHighlighting.highlight(jobGraph);

                            d3.selectAll('svg .node:not(.highlight), svg .edge:not(.highlight)').classed('fade-out--no-filter filter-remove', true);
                            $.each(FlowGraph.get().nodes, function (nodeId) {
                                let nodeElt = FlowGraph.d3NodeWithId(nodeId);
                                nodeElt.classed('out-of-focus', true).classed('fade-out--no-filter', false);
                            });

                            setStatusOnGraph();

                            // Resize should be done around the job nodes.
                            $scope.$emit('setResizeStrategy', 'highlight');
                        }
                    }
                }

                function fetchGraph(force = false) {
                    DataikuAPI.flow.recipes.getGraph($stateParams.projectKey, $rootScope.tagFilter, true, false).success(function (data) {
                        graphData = data.serializedFilteredGraph.serializedGraph;
                        draw(force);
                    });
                }

                $scope.drawJobGraph = function (force = false) {

                    if (shouldGetGraph) {
                        if (force === false) {
                            // Quick call to check the number of potential nodes on the graph
                            DataikuAPI.taggableObjects.countAccessibleObjects($stateParams.projectKey).success((countsByType) => {
                                const possibleNodes = countsByType["DATASET"] + countsByType["RECIPE"] + countsByType["MANAGED_FOLDER"] + countsByType["STREAMING_ENDPOINT"] + countsByType["MODEL_EVALUATION_STORE"];
                                if (possibleNodes >= MAX_NODES) {
                                    // Mimic a MAX_NODES response
                                    graphData = {nodes: Array.from({length: MAX_NODES}, (v, i) => i).reduce((o, key) => Object.assign(o, {[key]: key}), {}), filteredOutObjectsByType: {}, includedObjectsByType: {}, datasetsKeptForRecipe: {}, realNodes: {}, zonesUsedByRealId: {}, hasZones: false, hasZoneSharedObjects: false, hasProjectZones: false, svg: ""};
                                    draw(force);
                                } else {
                                    fetchGraph(force);
                                }
                            });
                        } else if (force === true) {
                            fetchGraph(force);
                        }
                    } else {
                        draw(force);
                    }
                };


                $scope.$watch("jobStatus", function(jobStatus) {
                    $scope.hasBigFlow = false;
                    $scope.forceFlow = false;

                    // Disable flow zoom remembering while navigating on jobs flows
                    GraphZoomTrackerService.disable();

                    // Do not re-compute job graph if already known (for running jobs)
                    if (jobId && jobId === jobStatus.baseStatus.def.id) {
                        shouldGetGraph = false;
                    } else {
                        shouldGetGraph = true;
                        jobId = jobStatus.baseStatus.def.id;
                    }

                    // When a job is running, it is better to temporarily disable resizing to let the user navigate its job flow.
                    if (jobStatus.baseStatus.state === 'RUNNING') {
                        $scope.$emit('disableNextFlowResize');
                    }
                    $scope.drawJobGraph();
                    FlowGraphSelection.setSelectionStrategy(selectionStrategy);
                });

                // Come back to default flow selection strategy when
                $scope.$on('$destroy', _ => {
                    FlowGraphSelection.setSelectionStrategy();
                    $scope.$emit('setResizeStrategy', '');
                    reset();
                    // We don't re-enable zoom tracking because it would be too soon sp zoom would be persisted
                });
            },

            link: function($scope) {
                $scope.onItemDblClick = function(item, evt){
                    let destUrl = StateUtils.href.node(item);
                    fakeClickOnLink(destUrl, evt);
                };
                $scope.onItemContextualMenu = function(){
                    return false;
                };
                $scope.onContextualMenu = function(item, evt) {
                    ContextualMenu.prototype.closeAny();
                    return true;
                };
                $scope.$watch("rightColumnItem", function(nv, ov) {
                    if (!nv) return;
                    $scope.selectedItemData = $scope.jobStatus.stateByGraphNodeId[nv.id];
                });
                $scope.$watch("jobStatus", function(nv, ov){
                    if (nv && $scope.rightColumnItem) {
                        $scope.selectedItemData = $scope.jobStatus.stateByGraphNodeId[$scope.rightColumnItem.id];
                    }
                });
            }
        };
    });
})();