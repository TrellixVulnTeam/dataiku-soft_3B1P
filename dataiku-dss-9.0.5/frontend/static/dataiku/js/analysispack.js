(function(){
'use strict';

var app = angular.module('dataiku.ml.report', []);

/**
 * Controller for displaying results screen of a prediction model,
 * either in a PMLTask or a PredictionSavedModel
 *
 * Requires: $stateParams.fullModelId or $scope.fullModelId
 *
 * Must be inserted in another controller.
 */
app.controller("_PredictionModelReportController", function($state, $scope, $location, $rootScope, $controller, Assert,
    DataikuAPI, Debounce, $stateParams, ActivityIndicator, Fn, TopNav, BinaryClassificationModelsService, PartitionedModelsService, ActiveProjectKey){

    $controller("_ModelReportControllerBase", {$scope:$scope});

    $scope.uiState = $scope.uiState || {};

    $scope.areMetricsWeighted = function() {
        return $scope.modelData && !!$scope.modelData.coreParams.weight && ($scope.modelData.coreParams.weight.weightMethod == "SAMPLE_WEIGHT" || $scope.modelData.coreParams.weight.weightMethod == "CLASS_AND_SAMPLE_WEIGHT");
    };

    $scope.printWeightedIfWeighted = function() {
        return $scope.areMetricsWeighted() ? "Weighted" : "";
    }

    $scope.isTimeOrderingEnabled = function() {
        return $scope.modelData && !!$scope.modelData.coreParams.time && $scope.modelData.coreParams.time.enabled;
    };

    $scope.getAggregationExplanation = function(metricName, displayName) {
        return PartitionedModelsService.getAggregationExplanation(metricName, displayName || metricName);
    }

    function prepareFormat(modelData) {
        try {
            const pcd = modelData.perf.perCutData;
            const pdd = modelData.perf.densityData;
            const tr = modelData.preprocessing ? modelData.preprocessing.target_remapping : null;
            if (pcd) { // set default format for x, both y axes, and CMG in tooltip
                pcd.format = ['.02f', '.02f', '.02f', '.02f'];
            }
            modelData.classes = tr && tr.length ? tr.map(Fn.prop('sourceValue')) : (pdd ? Object.keys(pdd) : null);
            modelData.hasProbas = modelData.iperf && modelData.iperf.probaAware;
            if (pdd) { // Probability densities: make X coordinates
                pdd.x = pdd[modelData.classes[0]].incorrect.map(function(_, i, a) { return i / a.length; });
            }
        } catch(ignored) {
        }
    };
    
    $scope.currentGraphData = {};
    
    if ($scope.modelData) {
        $scope.fullModelId = $scope.fullModelId || $scope.modelData.fullModelId;
        prepareFormat($scope.modelData);
        $scope.headTaskCMW = $scope.modelData.headTaskCMW;
        computeCMG();

        $scope._selectPane();

        if ($scope.modelData.userMeta.activeClassifierThreshold) {
            updateGraphData($scope.modelData.userMeta.activeClassifierThreshold);
        }

        if ($scope.mlTasksContext) {
            $scope.mlTasksContext.model = $scope.modelData;
        }
        if ($scope.smContext) {
            $scope.smContext.model = $scope.modelData;
        }
    } else {

        const fullModelId = $stateParams.fullModelId || $scope.fullModelId;
        const p = DataikuAPI.ml.prediction.getModelDetails(fullModelId).success(function(modelData) {
            prepareFormat(modelData);
            $scope.modelData = modelData;
            $scope.headTaskCMW = modelData.headTaskCMW;
            computeCMG();

            $scope._selectPane();

            if (modelData.userMeta) {
                TopNav.setPageTitle(modelData.userMeta.name + " - Analysis");
                updateGraphData($scope.modelData.userMeta.activeClassifierThreshold);
            }

            if ($scope.mlTasksContext) {
                $scope.mlTasksContext.model = modelData;
            }
            if ($scope.smContext) {
                $scope.smContext.model = modelData;
            }

            if ($scope.onLoadSuccess) $scope.onLoadSuccess(); // used by saved-model-report-insight-tile

            // Signal to Puppeteer that the content of the element has been loaded and is thus available for content extraction
            $scope.puppeteerHook_elementContentLoaded = true;
        }).error(setErrorInScope.bind($scope))
          .error(function(data, status, headers, config, statusText) {
            if ($scope.onLoadError) $scope.onLoadError(data, status, headers, config, statusText);
        });

        if ($scope.noSpinner) p.noSpinner(); // used by saved-model-report-insight-tile
    }

    $scope.colors  = window.dkuColorPalettes.discrete[0].colors // adjacent colors are too similar
        .filter(function(c, i) { return i % 2 === 0; });        // take only even-ranked ones

    function isPrediction() {
        return $scope.modelData && this.indexOf($scope.modelData.coreParams.prediction_type) !== -1;
    }

    $scope.isClassification       = isPrediction.bind(['BINARY_CLASSIFICATION', 'MULTICLASS']);
    $scope.isBinaryClassification = isPrediction.bind(['BINARY_CLASSIFICATION']);
    $scope.isMulticlass           = isPrediction.bind(['MULTICLASS']);
    $scope.isRegression           = isPrediction.bind(['REGRESSION']);
    $scope.isPrediction           = Fn.cst(true);

    $scope.hasVariableImportance = function() {
        if (!$scope.modelData) return false;
        var iperf = $scope.modelData.iperf;
        return !!(iperf && iperf.rawImportance && iperf.rawImportance.variables && iperf.rawImportance.variables.length);
    };
    $scope.hasRawCoefficients = function() {
        if (!$scope.modelData) return false;
        var iperf = $scope.modelData.iperf;
        return !!(iperf && iperf.lmCoefficients);
    };

    $scope.hasDensityData = function() {
        return $scope.isClassification() &&
            $scope.modelData &&
            $scope.modelData.perf &&
            $scope.modelData.perf.densityData &&
            $scope.modelData.perf.densityData.x
    };

    $scope.hasNoAssociatedModel = function() {
        return !!$scope.evaluation
            && ($scope.evaluation.evaluation.modelType=='EXTERNAL'
                || $scope.evaluation.backingModelVersionDeleted);
    }

    $scope.hasNoAssociatedModelText = function() {
        if (!!$scope.evaluation) {
            if ($scope.evaluation.evaluation.modelType=='EXTERNAL') {
                return "Not available for model evaluations without a backing DSS model";
            }
            if ($scope.evaluation.backingModelVersionDeleted) {
                return "Not available as evaluated DSS model version is no longer available";
            }
        }
        return null;
    }

    $scope.tabNotAvailableText = function(tabName) {
        const tabModelNeeded = ["train", "pdp_plot", "individual_explanations", "interactive_scoring"];
        const tabProbaNeeded = ["pdp_plot", "subpopulation", "individual_explanations", "interactive_scoring"];
        const tabNoKeras = ["individual_explanations"];
        if (tabNoKeras.includes(tabName) && $scope.modelData && $scope.modelData.backendType == "KERAS") {
            return "Not available for Keras models";
        }
        if (tabModelNeeded.includes(tabName) && $scope.hasNoAssociatedModel()) {
            return $scope.hasNoAssociatedModelText();
        }
        // /!\ if no perf, tab is deactivated in any case (no matter its name)
        if ($scope.modelData && !$scope.modelData.perf) {
            return "Model performance was not computed (disabled or ground truth was missing)";
        }
        if ($scope.isClassification() && tabProbaNeeded.includes(tabName) && $scope.modelData.hasProbas === false) {
            return "Not available for non-probabilistic models";
        }
        if (tabName == "subpopulation" && $scope.isMulticlass()) {
            return "Not available for multi-class classification";
        }
        return null;
    }

    $scope.hasROCCurve = function() {
        return ($scope.isBinaryClassification() && $scope.modelData && $scope.modelData.perf && $scope.modelData.perf.rocVizData) ||
            ($scope.isMulticlass() && Object.keys($scope.modelData && $scope.modelData.perf && $scope.modelData.perf.oneVsAllRocCurves || {}).length);
    };

    $scope.isTreeModel = function() {
        return ['MLLIB_DECISION_TREE', 'DECISION_TREE_CLASSIFICATION', 'DECISION_TREE_REGRESSION'].indexOf($scope.getAlgorithm()) >=0;
    };

    $scope.isEnsembleModel = function(){
         var algo = $scope.getAlgorithm();
         return ['GBT_REGRESSION', 'GBT_CLASSIFICATION', 'RANDOM_FOREST_CLASSIFICATION', 'RANDOM_FOREST_REGRESSION',
            'MLLIB_GBT', 'MLLIB_RANDOM_FOREST'].indexOf(algo) >=0 && ! (
                algo == 'MLLIB_RANDOM_FOREST' && $scope.isMulticlass() //because we can't create summary correctly for this case
            );
    };

    // Cost Matrix Gain
    function computeCMG() {
        Assert.inScope($scope, 'modelData');

        const perCut = $scope.modelData.perf && $scope.modelData.perf.perCutData;
        if (!perCut) {
            return;
        }
        perCut.totalRows = $scope.modelData.trainInfo.testRows // 0 if k-fold
            || perCut.fn[0] + perCut.fp[0] + perCut.tn[0] + perCut.tp[0];
        perCut.cmg = perCut.cut.map(function(c, i) {
                return (this.fnGain * perCut.fn[i] + this.tnGain * perCut.tn[i] +
                        this.fpGain * perCut.fp[i] + this.tpGain * perCut.tp[i]
                    ) / (perCut.fn[i] + perCut.tn[i] +  perCut.fp[i] + perCut.tp[i]);
            }, $scope.headTaskCMW);
        if ($scope.currentCutData) {
            $scope.currentCutData.cmg = perCut.cmg[$scope.currentCutData.index];
        }
        const e = d3.extent(perCut.cmg);
        perCut.format[2] = e[1] - e[0] > 10 ? '1g' : '.02f';
    }

    $scope.uiState.displayMode = "records";

    $scope.getMaybeWeighted = function(x) {
        if (typeof x !== 'number') {
            return x; // for when it's percentage
        }
        return $scope.areMetricsWeighted() ? x.toFixed(2) : x.toFixed(0);
    };

    function getPercentString(p) {
        if (p < 0.01) {
            return "< 1 %";
        } else if (p > 1) {
            return "100 %";
        }
        else {
            return Math.round(p * 100) + " %";
        }
    }

    $scope.currentGraphData = {};
    function updateGraphData(nv) {
        if (nv === undefined) return;
        $scope.currentCutData = BinaryClassificationModelsService.findCutData($scope.modelData.perf, nv);
        angular.forEach($scope.currentCutData, // capitalized => graphed
            function(v, k) { if (k.charCodeAt(0) <= 90) {
              if ($scope.areMetricsWeighted()) this["Weighted " + k] = v;
              else this[k] = v;
          }},
          $scope.currentGraphData);
    }
    $scope.$watch("modelData.userMeta.activeClassifierThreshold", updateGraphData);

    // Handling of save
    if (!$scope.readOnly) {
        var simpleApiResult = function(msg, r) {
                r.success(function(){ ActivityIndicator.success(msg) })
                 .error(setErrorInScope.bind($scope));
        };
        var debouncedUpdateCMW = Debounce().withDelay(400, 1000).wrap(function() {
            if (!$scope.savedModel && !$scope.evaluation) {
                const fid = $stateParams.fullModelId || $scope.fullModelId;
                simpleApiResult("Weights saved", DataikuAPI.analysis.pml.saveCostMatrixWeights(fid, $scope.headTaskCMW));
            }
            computeCMG();
        });
        var saveMeta = function() {
            if ($scope.readOnly) return;
            if ($scope.evaluation) {
                let fme = makeFullModelEvalutionIdString(ActiveProjectKey.get(), $stateParams.mesId, $stateParams.runId);
                simpleApiResult("Saved", DataikuAPI.modelevaluations.saveEvaluationUserMeta(
                        fme, $scope.modelData.userMeta));
            } else {
                simpleApiResult("Saved", DataikuAPI.ml.saveModelUserMeta(
                        $stateParams.fullModelId || $scope.fullModelId, $scope.modelData.userMeta));
            }
        };
        var debouncedSaveMeta = Debounce().withDelay(400, 1000).wrap(saveMeta);
        var saveIfDataChanged = function(nv, ov) { if (nv && ov && !$scope.evaluation) this.call(); }; // only applies to saved models
        $scope.$watch("headTaskCMW",               saveIfDataChanged.bind(debouncedUpdateCMW), true);
        $scope.$watch("modelData.userMeta.activeClassifierThreshold", saveIfDataChanged.bind(debouncedSaveMeta), true);
    
        $scope.$watch("modelData.userMeta", function(nv, ov){
            if (nv && ov && (nv.name != ov.name || nv.description != ov.description || !_.isEqual(nv.labels, ov.labels))) {
                saveMeta();
            }
        }, true)
    }
});


app.controller("PredictionPerformanceMetricsController", function ($scope, BinaryClassificationModelsService) {
    $scope.mu = $scope.modelData.userMeta;
    let updateAssertionResult = function () {
        // used for initialization in multiclass & regression and for initialization and update for binary classification
        if (!$scope.modelData) return;
        let assertionsMetrics;

        if ($scope.isBinaryClassification()) {
            $scope.currentCutData = BinaryClassificationModelsService.findCutData($scope.modelData.perf, $scope.modelData.userMeta.activeClassifierThreshold);
            if ($scope.currentCutData !== undefined) {
                $scope.cci = $scope.currentCutData.index
            }
            if ($scope.modelData.perf.perCutData.assertionsMetrics) {
                assertionsMetrics = $scope.modelData.perf.perCutData.assertionsMetrics[$scope.cci];
            }
        } else {
            assertionsMetrics = $scope.modelData.perf.metrics.assertionsMetrics;
        }
        if (assertionsMetrics) {
            // Reordering assertion results as {assertionName: {... assertion results ...}} for ease of use
            $scope.assertionsResult = {hasAnyDroppedRows: false};
            for (let assertionMetric of assertionsMetrics.perAssertion) {
                $scope.assertionsResult[assertionMetric.name] = assertionMetric;
                let nbDropped = assertionMetric.nbDroppedRows;
                if (nbDropped > 0) {
                    $scope.assertionsResult.hasAnyDroppedRows = true;
                }
                let nbMatchingRows = assertionMetric.nbMatchingRows;
                let nbPassing = Math.round(assertionMetric.validRatio * (nbMatchingRows - nbDropped));
                let nbFailing = Math.round(nbMatchingRows - nbDropped - nbPassing);
                $scope.assertionsResult[assertionMetric.name].nbPassing = nbPassing;
                $scope.assertionsResult[assertionMetric.name].nbFailing = nbFailing;
                $scope.assertionsResult[assertionMetric.name].passingPercentage = Math.round(100 * nbPassing / nbMatchingRows);
                $scope.assertionsResult[assertionMetric.name].failingPercentage = Math.round(100 * nbFailing / nbMatchingRows);
                $scope.assertionsResult[assertionMetric.name].droppedPercentage = Math.round(100 * nbDropped / nbMatchingRows);
            }
        }
    };
    $scope.$watch("modelData.userMeta.activeClassifierThreshold", updateAssertionResult);
})

app.controller('PMLReportTrainController', function($scope, PMLSettings, SamplingData, MLDiagnosticsService, FullModelIdUtils) {
    var split = $scope.modelData.splitDesc.params,
        ttPolicy = split.ttPolicy,
        samplingMethods = arr2obj(SamplingData.streamSamplingMethods),
        partitionSelectionMethods = arr2obj(SamplingData.partitionSelectionMethods),
        tmp;

    $scope.mti = $scope.modelData.trainInfo;
    $scope.diagnostics = MLDiagnosticsService.groupByType($scope.modelData.trainDiagnostics);

    $scope.isMLBackendType = function(mlBackendType) {
        return $scope.modelData.coreParams.backendType === mlBackendType;
    };

    $scope.canDisplayDiagnostics = function() {
        const modelData = $scope.modelData;
        if (FullModelIdUtils.isPartition(modelData.fullModelId)) {
            return true;  // Always display diagnostics on a partition
        }

        // We cannot know from a Saved Model if we are on a partition base or not, so use smOrigin to check that
        if (!angular.isUndefined(modelData.smOrigin) && !angular.isUndefined(modelData.smOrigin.fullModelId)) {
            return !FullModelIdUtils.isAnalysisPartitionBaseModel(modelData.smOrigin.fullModelId);  // Do not display Diagnostics on partition base
        }

        return !FullModelIdUtils.isAnalysisPartitionBaseModel(modelData.fullModelId);;
    };

    // Make a nice array for train & test policy

    function selection(prefix, ds, sel) {
        if (ds) {
            this.push([prefix + 'dataset',  ds]);
        }
        this.push([prefix + 'sampling method', samplingMethods[sel.samplingMethod]]);
        this.push([prefix + 'partitions', partitionSelectionMethods[sel.partitionSelectionMethod]]);
        if (sel.partitionSelectionMethod === 'SELECTED') {
            this[this.length-1].push(': ', sel.selectedPartitions.join(', '));
        }
        if (['HEAD_SEQUENTIAL', 'RANDOM_FIXED_NB', 'COLUMN_BASED'].indexOf(sel.samplingMethod) >= 0) {
            this.push([prefix + 'record limit', sel.maxRecords]);
            if (sel.samplingMethod === 'COLUMN_BASED') {
                this.push([prefix + 'column', sel.column]);
            }
        } else if (sel.samplingMethod === 'RANDOM_FIXED_RATIO') {
            this.push([prefix + 'sampling ratio', sel.targetRatio]);
        }
    }

    if (ttPolicy === 'SPLIT_SINGLE_DATASET') {
        ttPolicy = split.ssdDatasetSmartName ? 'SPLIT_OTHER_DATASET' : 'SPLIT_MAIN_DATASET';
    } else if (ttPolicy === 'EXPLICIT_FILTERING_SINGLE_DATASET') {
        ttPolicy = split.efsdDatasetSmartName ? 'EXPLICIT_FILTERING_SINGLE_DATASET_OTHER' : 'EXPLICIT_FILTERING_SINGLE_DATASET_MAIN';
    }
    $scope.cvParams = [["policy", arr2obj(PMLSettings.task.trainTestPolicies)[ttPolicy]]];
    switch (ttPolicy) {
        case 'SPLIT_MAIN_DATASET':
        case 'SPLIT_OTHER_DATASET':
            selection.call($scope.cvParams, '', split.datasetSmartName, split.ssdSelection);
            $scope.cvParams.push(['split mode', arr2obj(PMLSettings.task.splitModes)[split.ssdSplitMode]]);
            if (split.kfold) {
                $scope.cvParams.push(['number of folds', split.nFolds]);
            } else {
                $scope.cvParams.push(['train ratio', split.ssdTrainingRatio]);
            }
            $scope.cvParams.push(['random seed', split.ssdSeed]);
            break;
        case 'EXPLICIT_FILTERING_SINGLE_DATASET':
            selection.call($scope.cvParams, 'Train ', split.eftdTrain.datasetSmartName, split.eftdTrain.selection);
            selection.call($scope.cvParams, 'Test  ', split.eftdTest .datasetSmartName, split.eftdTest .selection);
            break;
        case 'EXPLICIT_FILTERING_TWO_DATASETS':
            selection.call($scope.cvParams, 'Train ', split.eftdTrain.datasetSmartName, split.eftdTrain.selection);
            selection.call($scope.cvParams, 'Test  ', split.eftdTest .datasetSmartName, split.eftdTest .selection);
            break;
        case 'FIXED_ID_BASED': break;
    }
});

// For elements that are instantly loaded (raw text for example) we signal right away to Puppeteer that they are available for content extraction
app.directive('puppeteerHookElementContentLoaded', function() {
    return {
        scope: false,
        restrict: 'A',
        link: function($scope) {
            // Signal to Puppeteer that the content of the element has been loaded and is thus available for content extraction
            $scope.puppeteerHook_elementContentLoaded = true;
        }
    };
});

app.controller('DecisionChartController', function($scope, $stateParams, MLChartsCommon) {
    $scope.pcd = $scope.modelData.perf.perCutData;
    if (!$scope.modelData.trainInfo.kfold) {
        return;
    }

    // wrap lines with confidence area
    $scope.svgCallback = MLChartsCommon.makeSvgAreaCallback(scope =>
        scope.theData
            .map(series => Object.assign({}, series, { std: $scope.pcd[series.key.toLowerCase() + 'std'] }))
            .filter(_ => _.std) // only series with a stddev series
            .map(series => ({
                color: series.color,
                values: series.values
                    // filter NaN data to prevent erroneous path
                    .filter(d => typeof d.y === 'number' && !isNaN(d.y))
                    .map((d, i) => ({
                        x: d.x,
                        y0: Math.max(0, d.y - 2 * series.std[i]),
                        y1: Math.min(1, d.y + 2 * series.std[i])
                    }))
            }))
    );
});


app.controller('ClassificationDensityController', function($scope) {
    var pdd = $scope.modelData.perf.densityData;
    $scope.colorsRep = $scope.colors.slice(0, 2).concat($scope.colors.slice(0, 2))
    $scope.setDensityClass = function(nc) {
        var dd = pdd[nc];
        $scope.densityClass = nc;
        $scope.ys = [dd.incorrect, dd.correct];
        $scope.xm = [dd.incorrectMedian, dd.correctMedian];
        $scope.labels = $scope.isMulticlass() ? ['For all classes but ' + nc, 'For class ' + nc]
                : ['For class ' + $scope.modelData.classes[0], 'For class ' + $scope.modelData.classes[1]];
    }
    $scope.setDensityClass($scope.modelData.classes[$scope.isMulticlass() ? 0 : 1]);
});


app.factory("VariablesImportanceService", function($filter){
    return {
        build: function(rawImportance, colors) {
            var imp = rawImportance,
                name = $filter('mlFeature'),
                rgb = colors[0];

            rgb = rgb.replace('#', '').replace(/^([0-9a-f])([0-9a-f])([0-9a-f])$/, '$1$1'); // 6-digit hex
            rgb = parseInt(rgb, 16);
            rgb = ['rgba(', rgb >> 16, ',', rgb >> 8 & 255, ', ', rgb & 255, ', '].join('');

            imp = imp.variables.map(function(v, i) { return { r : v, v: name(v), i: this[i] }; }, imp.importances);
            imp = $filter('orderBy')(imp, '-i');

            var filtered_imp = imp.slice(0, 20);
            var importances = filtered_imp.map(function(o) { return [o.v, o.i]; });
            var fades       = filtered_imp.map(function(o) { return rgb + Math.min(o.i / .3 + .4, 1) + ')'; });
            return [importances, fades, imp];
        }
    }
})

app.controller('VariableImportanceController', function($scope, VariablesImportanceService, $filter, ExportUtils) {
    var arr = VariablesImportanceService.build($scope.modelData.iperf.rawImportance, $scope.colors);
    $scope.importances = arr[0];
    $scope.fades = arr[1];
    $scope.unfilteredImportances = arr[2];

    $scope.exportImportance = function(){
        var f = $filter("mlFeature");
        var data = $scope.unfilteredImportances.map(function(x){
            return [x.r, x.v, x.i];
        });
        ExportUtils.exportUIData($scope, {
            name : "Variables importance for model:" + $scope.modelData.userMeta.name,
            columns : [
                { name : "feature_name", type : "string"},
                { name : "feature_description", type : "string"},
                { name : "importance", type : "double"}
            ],
            data : data
        }, "Export variable importances");
    }
});

app.controller('_snippetMetricsCommon', function($scope, PartitionedModelsService) {
    /* Compute various stats with precise number of decimals for display in table */

    function getMetric(metricFieldName) {
        return $scope.display.metrics.find(m => metricFieldName === m.fieldName);
    }

    $scope.getAggregationExplanation = function(metric) {
        const metricName = metric.metricName || metric.fieldName.toUpperCase();
        const displayName = metric.shortName || metric.name || metric.fieldName;
        return PartitionedModelsService.getAggregationExplanation(metricName, displayName);
    }

    function getNumDecimalsFromMetric(numDecimalsOrMetric) {
        if (!numDecimalsOrMetric) { return 0; }

        if (typeof numDecimalsOrMetric === "number") {
            return numDecimalsOrMetric;
        }

        let metric = getMetric(numDecimalsOrMetric);
        let numDecimals = $scope.display.numDecimalsMetrics[metric.fieldName];

        if (metric.minDecimals) {
            numDecimals = Math.max(metric.minDecimals, numDecimals);
        }
        if (metric.maxDecimals) {
            numDecimals = Math.min(metric.maxDecimals, numDecimals);
        }

        return numDecimals;
    }

    $scope.formatMetric = function(value, metricFieldName, forcedNumDecimals) {
        let metric = getMetric(metricFieldName);

        let numDecimals;
        if (forcedNumDecimals) {
            numDecimals = forcedNumDecimals;
        } else {
            numDecimals = getNumDecimalsFromMetric(metricFieldName);
        }

        if (angular.isUndefined(value) || (value === 0 && metric.ignoreZero)) {
            return '-';
        }

        let exp = value > 10000;
        if (exp) {
            numDecimals = 4;
        }

        if (metric.percentage) {
            return getDetailedPercent(value, numDecimals).toFixed(numDecimals) + " %";
        } else {
            return getDetailedValue(value, numDecimals)[exp ? 'toPrecision': 'toFixed'](numDecimals);
        }
    };

    function getDetailedValue(value, numDecimals) {
        return (Math.round(value * Math.pow(10, numDecimals)) / Math.pow(10, numDecimals));
    }

    function getDetailedPercent (p, numDecimals) {
        return getDetailedValue(p * 100, numDecimals);
    }

    function getDiffWithAllDataset(metric, numDecimals) {
        switch (metric) {
            case 'actual':
                return getDetailedPercent($scope.data.perf.singleMetrics.actPos["ratio"], numDecimals)
                    - getDetailedPercent($scope.allDatasetPerf.singleMetrics.actPos["ratio"], numDecimals);
            case 'predicted':
                return getDetailedPercent($scope.data.perf.singleMetrics.predPos["ratio"], numDecimals)
                    - getDetailedPercent($scope.allDatasetPerf.singleMetrics.predPos["ratio"], numDecimals);
            default:
                return 0;
        }
    }

    $scope.isAboveAllDataset = function(metric) {
        return getDiffWithAllDataset(metric, getNumDecimalsFromMetric(metric)) > 0;
    };

    $scope.isBelowAllDataset = function(metric) {
        return getDiffWithAllDataset(metric, getNumDecimalsFromMetric(metric)) < 0;
    };

    $scope.getAbsoluteDiffWithAllDataset = function(metric, numDecimalsOrMetric) {
        const numDecimals = getNumDecimalsFromMetric(numDecimalsOrMetric);
        return Math.abs(getDiffWithAllDataset(metric, numDecimals).toFixed(numDecimals)) + " %";
    };

});

app.directive("partitionSummaryValue", function() {
    return {
        restrict: 'E',
        templateUrl: "/templates/ml/prediction-model/partition_summary-value.html",
        scope: {
            allDatasetPerf: "=",
            data : "=",
            threshold: "=",
            colors: "=",
            display: "=",
            classes: "=",
            partitionStates: '='
        },
        controller: function($scope, $controller) {
            $controller("_snippetMetricsCommon", {$scope: $scope});

            // VISUAL HELPERS

            $scope.getLinearGradient = function(ratio) {
                return 'linear-gradient(to right, #c6e8d3 0%, #c6e8d3 '+ (ratio * 100) +'%,rgba(0, 0, 0, 0) '+ (ratio * 100) +'%, rgba(0, 0, 0, 0) 100%)';
            };

            // INIT

            $scope.uiState = {
                isExpanded: false
            }

            $scope.onClick = function(event) {
                if ($scope.data.excluded) return;

                // If click event originates from info icon, we do not want to expand/hide subpop table row content,  as
                // a popover is being shown/hidden.
                if (event.originalEvent.composedPath().some(_ => _.className === "icon-info-sign")) return;
                $scope.uiState.isExpanded = !$scope.uiState.isExpanded;
            }

        }
    }
});


app.controller('VariableCoefficientController', function($scope, $filter, ListFilter, Debounce, ExportUtils, getNameValueFromMLFeatureFilter) {
    $scope.uiState = {
        advanced: false
    }
    var coefs = $scope.modelData.iperf.lmCoefficients.variables.map(function(v, i) {
            var splitedFeature = getNameValueFromMLFeatureFilter(v),
                o = {
                        full: v,
                        name: splitedFeature.name,
                        value: splitedFeature.value,
                        coef: this.coefs[i],
                        coefRescaled: this.rescaledCoefs ? this.rescaledCoefs[i] : undefined,
                        abs: Math.abs(this.coefs[i]),
                        rescaledAbs:  this.rescaledCoefs ? Math.abs(this.rescaledCoefs[i]) : undefined
                   };
            if (this.tstat)  { o.tstat = this.tstat[i]; }
            if (this.pvalue) { o.pvalue = this.pvalue[i]; }
            if (this.stderr) { o.stderr = this.stderr[i]; }
            if (this.rescaledStderr) { o.rescaledStderr = this.rescaledStderr[i]; }
            return o;
        }, $scope.modelData.iperf.lmCoefficients),
        maxCoef = Math.max.apply(Math, $scope.modelData.iperf.lmCoefficients.coefs.map(Math.abs)),
        maxRescaledCoef = $scope.modelData.iperf.lmCoefficients.rescaledCoefs ?
            Math.max.apply(Math, $scope.modelData.iperf.lmCoefficients.rescaledCoefs.map(Math.abs)) : undefined,
        filteredCoefs = coefs;

    function getVars() {
        filteredCoefs = !$scope.coefFilter ? coefs : ListFilter.filter(coefs, $scope.coefFilter);
        sortVars();
    }
    function sortVars() {
        var sort = ['+name', '+value'];
        var by = $scope.sort.by;
        if(!$scope.displayOptions.showRawCoefs){
            if(by == "abs"){
                by = "rescaledAbs";
            } else if(by == "coef") {
                by = "coefRescaled";
            }
        }

        if ($scope.sort.by !== 'name') { sort.unshift('+' + by); }
        sort[0] = ($scope.sort.reverse ? '-' : '+') + sort[0].substring(1);
        console.debug(sort);
        $scope.pagination.list = $filter('orderBy')(filteredCoefs, sort);
        $scope.pagination.page = 1;
        getCoeffs();
    }
    function getCoeffs() {
        $scope.pagination.update();
        $scope.coefs = $scope.pagination.slice;
    }

    $scope.exportCoefficients = function(){
        let lmc = $scope.modelData.iperf.lmCoefficients;
        let f = $filter("mlFeature");
        let data;
        if ($scope.uiState.advanced) {
            data = $filter("orderBy")(coefs, "-abs").map(function (x) {
                return [x.full, f(x.full), $scope.displayOptions.showRawCoefs ? x.coef : x.coefRescaled,
                    x.stderr === 0 ? "" : x.stderr,
                    x.tstat === 0 ? "" : x.tstat,
                    x.pvalue === 0 ? "" : x.pvalue]
            });
            data.push(["Intercept", null,
                    $scope.displayOptions.showRawCoefs  ? lmc.interceptCoef : lmc.rescaledInterceptCoef,
                    lmc.interceptStderr === 0 ? "" : lmc.interceptStderr,
                    lmc.interceptTstat === 0 ? "" : lmc.interceptTstat,
                    lmc.interceptPvalue === 0 ? "" : lmc.interceptPvalue
                    ]);

        } else {
            data = $filter("orderBy")(coefs, "-abs").map(function (x) {
                return [x.full, f(x.full), $scope.displayOptions.showRawCoefs ? x.coef : x.coefRescaled]
            });
            data.push(["Intercept", null,
                    $scope.displayOptions.showRawCoefs  ? lmc.interceptCoef : lmc.rescaledInterceptCoef]
                    );
        }

        let columns = [
                { name : "feature_name", type : "string"},
                { name : "feature_description", type : "string"},
                { name : "coefficient", type : "double"}
        ];
        if ($scope.uiState.advanced) {
            columns.push({ name : "stderr", type : "double"});
            columns.push({ name : "tstat", type : "double"});
            columns.push({ name : "pvalue", type : "double"});
        }

        ExportUtils.exportUIData($scope, {
            columns : columns,
            data : data
        }, "Export coefficients");
    };

    $scope.sorts = { name: 'Name', coef: 'Coefficient', abs: '| Coefficient |' };
    if ($scope.modelData.iperf.lmCoefficients.pvalue) {
        $scope.sorts['pvalue'] = 'Trust';
    }
    $scope.sort = { by: 'abs', reverse: true };
    $scope.baseWidth = function(){
        return 50 / ($scope.displayOptions.showRawCoefs ? maxCoef : maxRescaledCoef);
    };
    $scope.displayPossibleSmall = function(value){
        if(value < 1e-4) {
            return "< 1e-4";
        } else {
            return value.toFixed(4);
        }
    };
    $scope.getCoef = function(c){
         return $scope.displayOptions.showRawCoefs ? c.coef : c.coefRescaled;
    };
    var lmc = $scope.modelData.iperf.lmCoefficients;
    $scope.getIntercept = function(){
        return $scope.displayOptions.showRawCoefs ? lmc.interceptCoef : lmc.rescaledInterceptCoef;
    };
    $scope.getInterceptStderr = function(){
        return $scope.displayOptions.showRawCoefs ? lmc.interceptStderr : lmc.rescaledInterceptStderr;
    };
    $scope.getInterceptTstat = function(){
        return $scope.displayOptions.showRawCoefs ? lmc.interceptTstat : lmc.rescaledInterceptTstat;
    };
    $scope.getInterceptPvalue = function(){
        return $scope.displayOptions.showRawCoefs ? lmc.interceptPvalue : lmc.rescaledInterceptPvalue;
    };
    $scope.getStderr = function(c){
        return $scope.displayOptions.showRawCoefs ? c.stderr : c.rescaledStderr;
    };
    $scope.getAbs = function(c){
        return $scope.displayOptions.showRawCoefs ? c.abs : c.rescaledAbs;
    };
    $scope.coefFilter = '';
    $scope.displayOptions = {
        showRawCoefs: !$scope.modelData.iperf.lmCoefficients.rescaledCoefs
    }

    $scope.pagination = new ListFilter.Pagination([], 50);
    $scope.$watch('coefFilter', Debounce().withScope($scope).withDelay(75,150).wrap(getVars), true);
    $scope.$watch('sort', sortVars, true);
    $scope.$watch('displayOptions', sortVars, true);
    $scope.$watch('pagination.page', getCoeffs);
    getVars();
    // Signal to Puppeteer that the content of the element has been loaded and is thus available for content extraction
    $scope.puppeteerHook_elementContentLoaded = true;
});

app.controller('MultiClassConfusionMatrixController', function($scope, Fn, $filter, Assert) {
    Assert.trueish($scope.modelData.perf, 'no modelData.perf');
    Assert.trueish($scope.modelData.perf.confusion, 'no confusion matrix data');
    var perActual = $scope.modelData.perf.confusion.perActual;
    $scope.total = $scope.modelData.perf.confusion.totalRows;
    if ($scope.modelData.classes && $scope.modelData.classes.length) {
        $scope.cs = $scope.modelData.classes;
    } else {
        $scope.cs = $scope.modelData.perf.classes;
    }
    $scope.n = $scope.cs.length;
    $scope.displayMode = 'actual';

    var predictedClassCount = $scope.cs.map(Fn.cst(0)),
        all100 = $scope.cs.map(Fn.cst('100\u00a0%')),
        smartPC = $filter('smartPercentage'),
        data = {};
    data.records = $scope.cs.map(function(ca, i) { return $scope.cs.map(function(cp, j) {
            if (!perActual[ca] || !perActual[ca].perPredicted[cp]) return 0;
            predictedClassCount[j] += perActual[ca].perPredicted[cp];
            return perActual[ca].perPredicted[cp];
        }); });
    data.actual = data.records.map(function(cps, i) {
        if (!perActual[$scope.cs[i]]) return cps.map(_ => '-');
        return cps.map(function(cp) {
            return this > 0 ? smartPC(cp / this, 0, true) : '-';
        }, perActual[$scope.cs[i]].actualClassCount);
    });
    data.predicted = data.records.map(function(cps) { return cps.map(function(cp, j) {
            return predictedClassCount[j] > 0 ? smartPC(cp / predictedClassCount[j], 0, true) : '-';
        });
    });

    //if the  number of classes is large, don't display the table to avoid crashing the browser
    $scope.tableHidden = data.records.length > 50;
    $scope.showTable = function(){
        $scope.tableHidden = false;
    };
    $scope.data = data;
    $scope.sumActual = {
        records: $scope.cs.map(Fn.dict(perActual,{})).map(Fn.prop('actualClassCount')).map(x=> isNaN(x) ? 0 : x),
        actual: all100
    };
    $scope.sumPredicted = {
        records: predictedClassCount,
        predicted: all100
    };
    $scope.total = $scope.sumActual.records.reduce(function(x, y) {return Number(x)+Number(y);}, 0)

    // Signal to Puppeteer that the content of the element has been loaded and is thus available for content extraction
    $scope.puppeteerHook_elementContentLoaded = true;
});


app.controller('ROCCurveController', function($scope, ExportUtils) {
    $scope.setLabels = function () {
        if ($scope.areMetricsWeighted()) {
            $scope.data.xlabel = 'Weighted False Positive Rate';
            $scope.data.ylabel = 'Weighted True Positive Rate';
        } else {
            $scope.data.xlabel = 'False Positive Rate';
            $scope.data.ylabel = 'True Positive Rate';
        }

    }

    var perf = $scope.modelData.perf;
    if ($scope.isMulticlass()) {
        $scope.setRocClass = function(nv) {
            $scope.data = [perf.oneVsAllRocCurves[nv]];
            $scope.rocAuc = perf.oneVsAllRocAUC[nv];
            $scope.setLabels()
        };
        $scope.rocClass = $scope.modelData.classes[0];
        $scope.setRocClass($scope.rocClass);
        $scope.auc = perf.metrics.mrocAUC;
        $scope.aucstd = perf.metrics.mrocAUCstd;
    } else {
        $scope.data = perf.rocVizData;
        $scope.auc = perf.tiMetrics.auc;
        $scope.aucstd = perf.tiMetrics.aucstd;
        $scope.setLabels();
    }

    $scope.exportROCData = function(){
        var data = $scope.data[0].map(function(x){
            return [ x.x, x.y, x.p > 1 ? 1 : x.p ]
        })
        ExportUtils.exportUIData($scope, {
            name : "ROC data for model: " + $scope.modelData.userMeta.name,
            columns : [
                { name : "False positive rate", type : "double"},
                { name : "True positive rate", type : "double"},
                { name : "Proba threshold", type : "double"}
            ],
            data : data
        }, "Export ROC curve");
    }
});

app.controller('CalibrationCurveController', function($scope, ExportUtils) {
    $scope.setLabels = function() {
        if ($scope.areMetricsWeighted()) {
            $scope.data.xlabel = 'Weighted Average of Predicted Probability for Positive Class';
            $scope.data.ylabel = 'Weighted Frequency of Positive Class';
        } else {
            $scope.data.xlabel = 'Average of Predicted Probability for Positive Class';
            $scope.data.ylabel = 'Frequency of Positive Class';
        }
    }

    var perf = $scope.modelData.perf;
    if ($scope.isMulticlass()) {
        $scope.setCalibrationClass = function(nv) {
            $scope.data = [perf.oneVsAllCalibrationCurves[nv]];
            $scope.calibrationLoss = perf.oneVsAllCalibrationLoss[nv];
            $scope.setLabels();
        };
        $scope.calibrationClass = $scope.modelData.classes[0];
        $scope.setCalibrationClass($scope.calibrationClass);
        $scope.mCalibrationLoss = perf.metrics.mCalibrationLoss;
        $scope.mCalibrationLossStd = perf.metrics.mCalibrationLossstd;
    } else {
        $scope.data = [perf.calibrationData];
        $scope.calibrationLoss = perf.tiMetrics.calibrationLoss;
        $scope.setLabels();
    }
    var calibrationMethod = $scope.modelData.coreParams.calibration.calibrationMethod;
    if (calibrationMethod==="ISOTONIC") {
        $scope.uiState.calibrationMethod = "Isotonic Regression";
    } else if (calibrationMethod==="SIGMOID") {
        $scope.uiState.calibrationMethod = "Sigmoid (Platt scaling)";
    } else {
      $scope.uiState.calibrationMethod = "No calibration";
    }

    $scope.exportCalibrationData = function(){
        const data = $scope.data[0].filter(_ => _.n > 0).map(_ => [_.x, _.y, _.n]);
        ExportUtils.exportUIData($scope, {
            name : "Calibration data for model: " + $scope.modelData.userMeta.name,
            columns : [
                { name : "Average of Predicted Probability for Positive Class", type : "double"},
                { name : "Frequency of Positive Class", type : "double"},
                { name : "Count of Records", type : "double"}
            ],
            data : data
        }, "Export Calibration Curve");
    }

    $scope.hasCalibrationData = function(){
        return (typeof($scope.modelData.perf.calibrationData) !== "undefined") ||
               (typeof($scope.modelData.perf.oneVsAllCalibrationCurves) !== "undefined");
    }
});

app.controller('ErrorDistributionController', function($scope) {
    var rp = $scope.modelData.perf.regression_performance,
        fmt = d3.format('.3s');
    angular.forEach(rp, function(v, k) {    // *_error metrics into scope
        if (k.substr(-6) === '_error' && typeof v === 'number') {
            $scope[k.substr(0, k.length - 6)] = v.toPrecision(5);
        } });
    $scope.hasRawMinMax = function() {
        return $scope.modelData.perf.regression_performance.raw_min_error !== Number.MIN_VALUE &&
               $scope.modelData.perf.regression_performance.raw_max_error !== Number.MAX_VALUE;
    };
    $scope.bars = rp.error_distribution.map(function(p) {
        return { min: p.bin_min, max: p.bin_max, count: p.count }; });
});


app.controller("StdModelReportFeaturesHandlingController", function($scope, ListFilter){
    $scope.filter = {
        query : "",
        pagination : new ListFilter.Pagination([], 40)
    }

    $scope.uiState = {
        showAllPreprocessedFeatures:false
    }

    $scope.getLimitedZippedImpact = function(feature) {
        var impact = zip($scope.modelData.preprocessingReport.impact[feature]['values'],
                         $scope.modelData.preprocessingReport.impact[feature]['impacts']);
        impact.sort(function(a, b) { return Math.abs(b[1]) - Math.abs(a[1])})
        return impact.slice(0, 20);
    }

    $scope.updateList = function(){
        $scope.filteredList = ListFilter.filter($scope.features, $scope.filter.query);
        $scope.currentPageItems = $scope.filter.pagination.updateAndGetSlice($scope.filteredList);
    }
    $scope.$watch("filter", $scope.updateList, true);

    $scope.$watch("modelData", function(nv, ov) {
        if (nv) {
            $scope.features = [];
            $.each($scope.modelData.preprocessing.per_feature, function(k, v){
                v.name = k;

                v.hasReport =
                    (v.type == "CATEGORY" && v.role != "REJECT" && v.category_handling == "IMPACT") ||
                    (v.type == "TEXT" && v.role != "REJECT" && v.text_handling == "TOKENIZE_COUNTS")||
                    (v.type == "TEXT" && v.role != "REJECT" && v.text_handling == "TOKENIZE_TFIDF");

                $scope.features.push(v);
            });
            $scope.updateList();
        }
    });
});


app.controller("GridSearchReportController", function($scope, $filter, PMLSettings, ExportUtils, MLChartsCommon, NumberFormatter, Fn){
    $scope.fieldList = [
        {field:'score', name:'Score', metric: true},
        {field:'scoreStd', name:'Score StdDev', metric: true},
        {field:'fitTime', name:'Fit Time', metric: true},
        {field:'fitTimeStd', name:'Fit Time StdDev', metric: true},
        {field:'scoreTime', name:'Score Time', metric: true},
        {field:'scoreTimeStd', name:'Score Time StdDev', metric:true}
    ];

    $scope.uiState = {
        showConstantColumns: false,
        chartColumn: null,
        chartLogScale: null, // null = N/A (non-numeric dimension)
        showFitTime: false,
        view: '1D' // Initialize the tab view to 1D plots
    };

    $scope.selectView = function(view) {
        $scope.uiState.view = view;
    }

    $scope.$watch('modelData.iperf.gridCells', gridCells => {
        if (!gridCells) return;
        $scope.gridCells = gridCells;
        if (['SVC_CLASSIFICATION', 'SVM_REGRESSION'].includes($scope.modelData.modeling.algorithm)) {
            $scope.gridCells.forEach(function(cell){
                let gamma_value = cell.params.gamma;
                if (typeof gamma_value !== 'undefined' && !['auto', 'scale'].includes(gamma_value)){
                    cell.params['custom_gamma'] = gamma_value;
                    cell.params['gamma'] = 'custom';
                }
            })
        }
        $scope.paramColumns = gridCells.map(_ => Object.keys(_.params))   // [['a', 'b'], ['a', 'c']]
            .reduce((a, b) => a.concat(b.filter(_ => a.indexOf(_) < 0)), []);   // ['a', 'b', 'c']
        $scope.gridData = gridCells.map(cell =>
            $scope.paramColumns.map(_ => cell.params[_]).concat($scope.fieldList.map(_ => cell[_.field]))
                               .map(_ => (_ === null || _ === undefined) ? "" : _)
        );
        $scope.pairwiseDependencies = computeHyperparametersPairwiseDependencies();

        // compute data when hiding columns that don't change
        const columnChanges = $scope.paramColumns.map( (col, i) =>
            $scope.gridData.map(_ => _[i])  // values of that column
                .some((cell, j, values) => j > 0 && cell != values[j-1]) // at least 1 differs from the previous
        );
        $scope.changingParamColumns = $scope.paramColumns.filter((col, i) => columnChanges[i]);
        $scope.changingGridData = $scope.gridData.map((row, j) =>
            row.filter((col, i) => i >= $scope.paramColumns.length || columnChanges[i]));
        if ($scope.changingParamColumns.indexOf($scope.uiState.chartColumn) < 0) {
            $scope.uiState.chartColumn = $scope.changingParamColumns[0];
        }

        const metric = $scope.$eval('modelData.modeling.metrics.evaluationMetric');
        const customEvaluationMetricGIB = $scope.$eval('modelData.modeling.metrics.customEvaluationMetricGIB');
        if (metric) {
            $scope.scoreMetric = ' (' + (PMLSettings.names.evaluationMetrics[metric] || metric) + ')';
        } else {
            $scope.scoreMetric = '';
        }
        $scope.currentMetric = metric;
        $scope.customEvaluationMetricGIB = customEvaluationMetricGIB;
    });

    $scope.$watch('uiState.showConstantColumns', showConstantColumns => {
        let tableData;
        let tableColumns;
        if (showConstantColumns) {
            tableColumns = $scope.paramColumns;
            tableData = $scope.gridData;
        } else {
            tableColumns = $scope.changingParamColumns;
            tableData = $scope.changingGridData;
        }

        // Generate the grid data as a list of objects (field name, value) so that it can be interactively ordered by users
        $scope.displayColumns = tableColumns.map(col => ({field: col, name: col, metric:false})).concat($scope.fieldList);
        $scope.displayData = tableData.map(row => {
            return $scope.displayColumns.reduce((result, item, index) => {
                result[item.field] = row[index];
                return result;
            }, {});
        });
    });

    // Simple formatter for train time on tick grid
    function formatTimeShort(maxValue, seconds) {
        let components = [];
        if (maxValue >= 86400) {
            components = [
                {v: Math.floor(seconds / 86400), t: 'd'}, //
                {v: Math.round((seconds % 86400) / 3600), t: 'h' }];
        } else if (maxValue >= 3600) {
            components = [
                {v: Math.floor(seconds / 3600), t: 'h'},
                {v: Math.round((seconds % 3600) / 60), t: 'm'}];
        } else if (maxValue >= 60) {
            components = [
                {v: Math.floor(seconds / 60), t: 'm'},
                {v: Math.round(seconds % 60), t: 's'}];
        } else if (maxValue >= 10) {
            components = [{v: Math.round(seconds), t: 's'}];
        } else if (maxValue >= 1) {
            components = [{v: seconds.toFixed(1), t: 's'}];
        } else if (maxValue >= 0.1) {
            components = [{v: seconds.toFixed(2), t: 's'}];
        } else {
            components = [{v: seconds.toFixed(3), t: 's'}];
        }
        if (seconds === 0) {
            // Special case for 0: print it using the smallest component type.
            return "0" + components[components.length - 1].t;
        } else {
            let result = "";
            components.forEach(function (item) {
                if (item.v > 0) {
                    if (result.length > 0) {
                        result += " ";
                    }
                    result += item.v + item.t;
                }
            });
            return result;
        }
    }
    // Simple formatter for train time in tooltip
    function formatTimeFull(seconds) {
        let str = '';
        if (seconds >= 86400) {
            str += Math.floor(seconds / 86400) + "d ";
            seconds = seconds % 86400;
        }
        if (seconds >= 3600) {
            str += Math.floor(seconds / 3600) + "h ";
            seconds = seconds % 3600;
        }
        if (seconds >= 60) {
            str += Math.floor(seconds / 60) + "m ";
            seconds = seconds % 60;
        }
        return str + seconds.toFixed(3) + 's';
    }

    $scope.$watch('uiState.chartColumn', column => {
        const colIdx = $scope.paramColumns.indexOf(column);
        if (colIdx < 0) return;

        const scoreIdx = $scope.paramColumns.length;
        const fitTimeIdx = scoreIdx + 2;
        const colors = $scope.colors.slice(0, 3); // We need 3 colors: Score, Fit time & Best score marker
        const naturalSort = (a, b) => (a == b ? 0 : (a < b ? -1 : 1));

        let x       = $scope.gridData.map(_ => _[colIdx]);      // [1,  2,  1,  2]
        let score   = $scope.gridData.map(_ => _[scoreIdx]);    // [.7, .6, .9, .8]
        let fitTime = $scope.gridData.map(_ => _[fitTimeIdx]);  // [10, 15, 20, 25]

        // Group by X (avg, min, max)
        function groupByX(series, x) {
            const values = {};
            const min = {};
            const max = {};
            for (let i in x) {
                const curX = x[i];
                if (! (curX in values)) {
                    values[curX] = [];
                }
                values[curX].push(series[i]);
            }
            for (let curX in values) {
                min[curX] = Math.min(...values[curX]);
                max[curX] = Math.max(...values[curX]);
                values[curX] = values[curX].reduce((a, b) => a + b, 0) / values[curX].length;
            }
            return { avg: values, min, max };
        }
        score   = groupByX(score, x);   // score.avg:   {1: .8, 2: .7}
        fitTime = groupByX(fitTime, x); // fitTime.avg: {1: 15, 2: 20}

        // Build series for plotting
        // Ignore values with empty (curX === "") X value (the parameter is not used/defined at point)
        x = x.sort(naturalSort).filter((curX, i, x) => curX !== "" && (i == 0 || curX != x[i-1])); // [1,  2]
        for (let k of ['avg', 'min', 'max']) {
            score[k]   = x.map(curX => score[k][curX]);    // [.8, .7]
            fitTime[k] = x.map(curX => fitTime[k][curX]);  // [15, 20]
        }
        const minScore = Math.min(...score.min);
        const maxScore = Math.max(...score.max);
        const minAvgScore = Math.min(...score.avg);
        const maxAvgScore = Math.max(...score.avg);
        const maxFitTime = Math.max(...fitTime.max);
        const lib = PMLSettings.sort.lowerIsBetter($scope.currentMetric, $scope.customEvaluationMetricGIB) ? -1 : 1;
        const indexOfBestScore = lib > 0 ? score.avg.indexOf(maxAvgScore) : score.avg.indexOf(minAvgScore);

        /* If the scores are between 0 and 1 and the difference is big, force the scale to [0, 1].
         * Else, use a scale that goes just a bit beyond the boundaries so that the data does not
         * align to the angles of the chart (because it looks a bit ugly)
         */
        const scale = (function() {
            if (minScore >= 0 && maxScore <= 1) {
                if (maxAvgScore - minAvgScore >= 0.2) {
                    return [0, 1];
                } else {
                    const factor = Math.abs(maxScore - minScore) * 0.1;
                    const furtherMax = maxScore > 0 ? (maxScore + factor) : (maxScore - factor);
                    const furtherMin = minScore > 0 ? (minScore - factor) : (minScore + factor);
                    return [Math.max(0, furtherMin), Math.min(1, furtherMax)]
                }
            } else {
                const furtherMax = maxScore > 0 ? maxScore * 1.05 : maxScore * 0.95;
                const furtherMin = minScore > 0 ? minScore * 0.95 : minScore * 1.05;
                return [furtherMin, furtherMax];
            }
        })();
        const scale2 = [0, maxFitTime];

        // Prepare the formats
        const xAreNumbers = x.every(_ => typeof _ === "number");
        const format = [
            "",                                               // x (overwritten in updateChartXScale function)
            minScore > -10 && maxScore < 10 ? '.4g' : '.4s',  // y1
            formatTimeShort.bind(null, maxFitTime),           // y2 (axis)
            formatTimeFull                                    // y2 (tooltip)
        ];

        // svg callbacks: 1. draw area for min/max
        const svgAreaCallback = MLChartsCommon.makeSvgAreaCallback(scope =>
            [{
                color: colors[0],
                values: $scope.chart.x.map((curX, i) => ({x: curX, y0: score.min[i], y1: score.max[i]}))
            }, {
                color: colors[1],
                yScale: scope.ys2.scale.copy().range(scope.chart.yScale().range()),
                values: $scope.chart.x.map((curX, i) => ({x: curX, y0: fitTime.min[i], y1: fitTime.max[i]}))
            }]
        );

        // and 2. color left axis with the color for score and overload the click on legend
        const svgCallback = (svg, scope) => {
            svg.selectAll(".nv-y.nv-axis text").style('fill', colors[0]);

            // Declare this method in $scope to get access to 'svg'.
            $scope.showHideFitTime = function () {
                // Show/hide the curve
                let displayValue = $scope.uiState.showFitTime ? "": "none";
                svg.selectAll("g.nv-lineChart g.nv-line g.nv-series-1").style('display', displayValue);

                // Show/hide the area (if present)
                let area = svg.select('.tubes').selectAll('path');
                if (area && area.length > 0) {
                    area[0][1].style.opacity = $scope.uiState.showFitTime ? '.3' : '0';
                }

                // Show/hide the secondary axis
                svg.select("g.nv-lineChart g.secondary-axis").style('display', displayValue);

                // Show/hide the legend
                svg.selectAll("g.nv-legendWrap g.nv-series:nth-child(2)").classed("nv-disabled", !$scope.uiState.showFitTime);
            };
            $scope.showHideFitTime(); // Call this method once to initially hide the "fit time" series.

            // Manually handle the click on legend
            scope.chart.legend.updateState(false);
            scope.chart.legend.dispatch.on('legendClick.overload', function (d, index) {
                if (index === 1) { // We only care about showing/hiding the "fit time" series (located at index 1).
                    $scope.$apply(function() {
                        $scope.uiState.showFitTime = !$scope.uiState.showFitTime;
                    });
                }
            });

            // Add tick vertical line to highlight the best score
            if (indexOfBestScore >= 0) {
                const xMarkStrokeWidth = 2;
                let xBestScore = x[indexOfBestScore];
                if (!xAreNumbers) {
                    // For ordinal values, use corresponding index
                    xBestScore = x.indexOf(xBestScore);
                }
                let xTranslate = scope.chart.xScale()(xBestScore);
                // In case the best score is the the first one on the X axis, slightly shift the line so that it
                // does not overlap with the left y-axis.
                if (indexOfBestScore === 0) {
                    xTranslate += xMarkStrokeWidth;
                }
                let xMarkG = svg.select(".nv-lineChart").append("g").attr("class", "x mark")
                    .attr("transform", "translate(" + xTranslate + ", 0)");
                xMarkG.append("path").attr('d', "M0,0 V" + scope.axisHeight)
                    .attr('stroke-width', xMarkStrokeWidth).attr('stroke', colors[2]).attr('stroke-dasharray', '5,3');
            }

            // Format tooltip x values
            if ($scope.uiState.chartLogScale === null) {
                // Use same formatter as x axis for categories
                scope.chart.interactiveLayer.tooltip.headerFormatter($scope.chart.format[0]);
            } else {
                // Use simple formatter for numbers
                scope.chart.interactiveLayer.tooltip.headerFormatter($scope.chart.xNumericFormat);
            }

            svgAreaCallback(svg, scope);

            // Fix tooltips persisting when changing column (https://github.com/krispo/angular-nvd3/issues/530#issuecomment-246745836)
            d3.selectAll('.nvtooltip').remove();
        };
        $scope.chart = {
            format, x, colors, scale, scale2, svgCallback,
            xLabels: x, score: score.avg, fitTime: fitTime.avg
        };

        // ~Smart default for log scale
        if (!xAreNumbers) {
            $scope.uiState.chartLogScale = null;
        } else {
            const min = Math.min(...x);
            const max = Math.max(...x);
            if (min == 0) {
                $scope.uiState.chartLogScale = max > 10;
            } else if (max == 0) {
                $scope.uiState.chartLogScale = min < -10;
            } else {
                $scope.uiState.chartLogScale = Math.abs(max / min) > 10;
            }

            // Determine numeric formatter as a function of min and max values of x
            if ( min <= 0.01 || max >= 100 ) {
                $scope.chart.xNumericFormat = _ => MLChartsCommon.trimTrailingZeros(d3.format(".3e")(_));
            } else {
                $scope.chart.xNumericFormat = _ => MLChartsCommon.trimTrailingZeros(d3.format(".4g")(_));
            }
        }
        updateChartXScale($scope.uiState.chartLogScale);
    });

    $scope.$watch('uiState.showFitTime', function () {
        if ($scope.showHideFitTime) {
            $scope.showHideFitTime();
        }
    });

    function updateChartXScale(chartLogScale) {
        let x = $scope.chart.x;
        if (chartLogScale === null) {
            // cheat for ordinal values using a linear scale & a custom formatter
            $scope.chart.xScale = d3.scale.linear().domain([-0.1, x.length - 0.9]);
            $scope.chart.x = x.map((_, i) => i);
            $scope.chart.xTicks = $scope.chart.x;  // fixed ticks for ordinals
            $scope.chart.format[0] = function(xValue) {  // check multiLineChart directive for format array meaning
                // format x axis values: empty strings for values that are not in categories, label string otherwise
                if (xValue < 0 || xValue > x.length - 1) {
                    return "";
                } else {
                    return $scope.chart.xLabels[xValue]
                }
            };
        } else {
            if (chartLogScale) {
                $scope.chart.xScale = d3.scale.log();
                if (x[0] <= 0) {
                    // protect against <= 0
                    x = x.slice();
                    x[0] = 1e-23;
                    $scope.chart.xScale.clamp(true);
                }
                $scope.chart.xTicks = false; // default ticks for log scale
                // Format x values for log scale
                $scope.chart.format[0] = function(xValue) {
                    if (xValue === x[0] || xValue === x[x.length - 1]){
                        // print exact value for x axis limits
                        return $scope.chart.xNumericFormat(xValue);
                    } else {
                        // print the ticks
                        if (!["1", "2", "4"].includes(d3.format(".0e")(xValue)[0])){
                            // only print ticks 1, 2, and 4
                            return "";
                        }
                        return $scope.chart.xNumericFormat(xValue);
                    }
                }
            } else {
                $scope.chart.xTicks = false; // default ticks for linear scale
                $scope.chart.xScale = d3.scale.linear();
                $scope.chart.format[0] = $scope.chart.xNumericFormat; // simple formatting for linear scale
            }
            $scope.chart.xScale.domain([x[0], x[x.length - 1]]);
        }
    }
    $scope.$watch('uiState.chartLogScale', updateChartXScale);

    $scope.exportGridSearchData = function(){
        if (!$scope.gridCells) return;
        ExportUtils.exportUIData($scope, {
            name : "Hyperparameter search data for model: " + $scope.modelData.userMeta.name,
            columns : $scope.paramColumns.map(_ => ({name: _, type: 'string'}))
                    .concat($scope.fieldList.map(_ => ({name: _.name, type: 'double'}))),
            data : $scope.gridData
        }, "Export hyperparameter search data");
    };

    $scope.isXGBoost = function() {
        return $scope.mlTasksContext.model.modeling.algorithm.startsWith('XGBOOST');
    };

    function computeHyperparametersPairwiseDependencies() {
        const scoreIdx = $scope.paramColumns.length;

        // Compute indices of all combinations of hyperparams
        const pairsIndices = [].concat(
            ...$scope.paramColumns.map((_, idx) =>
                $scope.paramColumns.slice(idx + 1).map((_, idx2) => [idx, idx + 1 + idx2])
            )
        );

        // Fill pairwise dependencies data with gridData
        let dependencies = Array.from(pairsIndices, function (pairIndices) {
            const [param1Idx, param2Idx] = pairIndices;

            // Accumulate scores by unique (x, y) values
            const scoresByXY = $scope.gridData.reduce(function (acc, data) {
                const [x, y, score] = [data[param1Idx], data[param2Idx], data[scoreIdx]];
                // Ignore undefined values
                if (x !== '' && y !== '') {
                    // Convert (x, y) pair to string for indexing
                    let xyKey = JSON.stringify([x, y]);
                    if (!(xyKey in acc)) {
                        acc[xyKey] = [];
                    }
                    acc[xyKey].push(score);
                }
                return acc;
            }, {});

            // Average scores by unique (x, y) value
            for (let xyPair in scoresByXY) {
                scoresByXY[xyPair] = scoresByXY[xyPair].reduce((a, b) => a + b, 0) / scoresByXY[xyPair].length;
            }

            // Create separate x, y, score arrays
            const x = Object.keys(scoresByXY).map((_) => JSON.parse(_)[0]);
            const y = Object.keys(scoresByXY).map((_) => JSON.parse(_)[1]);
            const score = Object.values(scoresByXY);

            // Ignore dependencies where one of the parameters has only one value
            // (equivalent to 1D plot)
            const xUnique = new Set(x);
            const yUnique = new Set(y);
            if (xUnique.size === 1 || yUnique.size === 1) {
                return {};
            }

            return {
                xLabel: $scope.paramColumns[param1Idx],
                yLabel: $scope.paramColumns[param2Idx],
                x: x,
                xCategorical: !x.every((_) => typeof _ === 'number'),
                y: y,
                yCategorical: !y.every((_) => typeof _ === 'number'),
                score: score,
            };
        });

        // Clean empty dependencies
        dependencies = dependencies.filter((dependency) => !angular.equals(dependency, {}));

        return dependencies;
    }
});

app.filter("modelImportantParamName", function(){
    var dict = {
        "depth" : "Depth",
        "min_samples" : "Min samples",
        "trees": "Trees",
        "penalty" : "Penalty",
        "max_depth" : "Max depth",
        "criterion": "Split criterion",
        "alpha": "Alpha",
        "lambda" : "Lambda",
        "epsilon" : "Epsilon",
        "gamma" : "Gamma",
        "C" : "C",
        "kernel" : "Kernel",
        "loss" : "Loss",
        "k" : "K",
        "distance_weighting" : "Distance weighting",
        "layer_sizes" : "Layer sizes",
        "max_iters" : "Max iterations",
        "hidden_layers" : "Hidden layers",
        "activation" : "Activation",
        "dropout":  "Dropout",
        "l1" : "L1",
        "l2" : "L2",
        "strategy" :"Strategy",
        "smoothing" : "Smoothing",
        "learning_rate": "Learning rate",
        "features": "Features",
        "solver":  "Solver",
        "epochs": "Epochs"

    }
    return function(input) {
        if (input && input in dict) return dict[input];
        return input;
    }
})


app.controller('HyperparametersPairwiseDependenciesController', ['$scope', 'MLChartsCommon', function ($scope, MLChartsCommon) {
    function groupByCategoryReducer(categories) {
        let groupByCategory = function (acc, value, index) {
            let category = categories[index];
            acc[category] = acc[category] || [];
            acc[category].push(value);
            return acc;
        };
        return groupByCategory;
    }

    function groupDependenciesByY(acc, dependency) {
        if (
            (acc.has(dependency.xLabel) && !(!dependency.xCategorical && dependency.yCategorical)) ||
            (dependency.xCategorical && !dependency.yCategorical)
        ) {
            // xLabel already present in acc and not only y is categorical,
            // or only x is categorical => We use y as x axis
            acc.set(dependency.xLabel, acc.get(dependency.xLabel) || []);
            acc.get(dependency.xLabel).push({
                x: dependency.y,
                xLabel: dependency.yLabel,
                xCategorical: dependency.yCategorical,
                y: dependency.x,
                yLabel: dependency.xLabel,
                yCategorical: dependency.xCategorical,
                score: dependency.score,
            });
        } else {
            // Otherwise we use x as x axis
            acc.set(dependency.yLabel, acc.get(dependency.yLabel) || []);
            acc.get(dependency.yLabel).push(dependency);
        }
        return acc;
    }

    function setXScaleMultiline(x) {
        let xScale, xNumericFormat, xScaleFormat, xTicks;

        const min = Math.min(...x);
        const max = Math.max(...x);

        xNumericFormat = MLChartsCommon.makeAxisNumericFormatter(min, max, 3, 1);

        const logScale = min > 0 && max / min > 10;
        if (logScale) {
            xScale = d3.scale.log().domain([min, max]);
            xTicks = [];
            if (max / min >= 1e5) {
                // If ratio is too high, only print major vertical lines
                for (let tickValue of xScale.ticks()) {
                    if (tickValue / 10 ** Math.floor(Math.log10(tickValue)) === 1) {
                        xTicks.push(tickValue);
                    }
                }
                // Show maximum ~4 major ticks
                xTicks = xTicks.filter((_, idx) => {
                    if (idx % Math.floor(xTicks.length / 4) === 0) return true;
                });
            } else {
                xTicks = false; // Default log ticks
            }
            xScaleFormat = function (xValue) {
                if (xValue === x[0] || xValue === x[x.length - 1]) {
                    // print exact value for x axis limits
                    return xNumericFormat(xValue);
                } else {
                    // print the ticks
                    if (d3.format('.0e')(xValue)[0] !== '1') {
                        // only print major ticks (does not hide the vertical line for minor ticks)
                        return '';
                    }
                    return xNumericFormat(xValue);
                }
            };
        } else {
            xTicks = false; // Default linear ticks
            xScale = d3.scale.linear().domain([min, max]);
            xScaleFormat = xNumericFormat;
        }

        return { xScale, xScaleFormat, xTicks };
    }

    $scope.$watch('pairwiseDependencies', (pairwiseDependencies) => {
        let dependenciesByY = pairwiseDependencies.reduce(groupDependenciesByY, new Map());
        let columnLabelCounts = {};
        let plotsDataByYDict = {};
        for (const [yLabel, dependencies] of dependenciesByY) {
            for (const dependency of dependencies) {
                let plotData = {};
                if (dependency.xCategorical && dependency.yCategorical) {
                    plotData.plotType = 'CATEGORIES-HEATMAP';
                    plotData.x = dependency.x;
                    plotData.y = dependency.y;
                    plotData.xLabel = dependency.xLabel;
                    plotData.yLabel = dependency.yLabel;
                    plotData.score = dependency.score;
                } else if (dependency.xCategorical || dependency.yCategorical) {
                    plotData.plotType = 'MULTILINE';
                    plotData.legend = [...new Set(dependency.y)];
                    plotData.legendLabel = dependency.yLabel;
                    plotData.colors = $scope.colors.slice(0, plotData.legend.length);

                    const { xScale, xScaleFormat, xTicks } = setXScaleMultiline(dependency.x);
                    plotData.xScale = xScale;
                    plotData.xTicks = xTicks;

                    const categories = dependency.y;
                    plotData.x = Object.values(dependency.x.reduce(groupByCategoryReducer(categories), {}));
                    plotData.xLabel = dependency.xLabel;
                    plotData.score = Object.values(dependency.score.reduce(groupByCategoryReducer(categories), {}));

                    // Sort by ascending order for x
                    plotData.x.forEach(function (_, idx) {
                        let combinedArray = [];
                        for (let j = 0; j < plotData.x[idx].length; j++) {
                            combinedArray.push({ x: plotData.x[idx][j], score: plotData.score[idx][j] });
                        }

                        combinedArray.sort(function (a, b) {
                            return a.x < b.x ? -1 : a.x == b.x ? 0 : 1;
                        });

                        for (let k = 0; k < combinedArray.length; k++) {
                            plotData.x[idx][k] = combinedArray[k].x;
                            plotData.score[idx][k] = combinedArray[k].score;
                        }
                    });

                    /* If the scores are between 0 and 1 and the difference is big, force the scale to [0, 1].
                     * Else, use a scale that goes just a bit beyond the boundaries so that the data does not
                     * align to the angles of the chart (because it looks a bit ugly)
                     */
                    let minScore = Math.min(...dependency.score);
                    let maxScore = Math.max(...dependency.score);
                    plotData.scale = (function () {
                        if (minScore >= 0 && maxScore <= 1) {
                            if (maxScore - minScore >= 0.2) {
                                return [0, 1];
                            } else {
                                const factor = Math.abs(maxScore - minScore) * 0.1;
                                const furtherMax = maxScore > 0 ? maxScore + factor : maxScore - factor;
                                const furtherMin = minScore > 0 ? minScore - factor : minScore + factor;
                                return [Math.max(0, furtherMin), Math.min(1, furtherMax)];
                            }
                        } else {
                            const furtherMax = maxScore > 0 ? maxScore * 1.05 : maxScore * 0.95;
                            const furtherMin = minScore > 0 ? minScore * 0.95 : minScore * 1.05;
                            return [furtherMin, furtherMax];
                        }
                    })();

                    let yScaleFormat = MLChartsCommon.makeAxisNumericFormatter(minScore, maxScore, 3, 1);

                    plotData.format = [xScaleFormat, yScaleFormat];

                    plotData.svgCallback = function (svg, scope) {
                        scope.chart.yAxis.axisLabelDistance(-15);
                        scope.chart.interpolate(gaussianSmooth);

                        let tooltipNumericFormat = MLChartsCommon.makeTooltipNumericFormatter(3, 4);
                        scope.chart.tooltip.contentGenerator(function (d) {
                            return `
                                <table class="mlchart-tooltip__table">
                                    <tr>
                                        <td class="mlchart-tooltip__label">Score ${$scope.scoreMetric}</td>
                                        <td class="mlchart-tooltip__value">${tooltipNumericFormat(
                                            d.series[0].value
                                        )}</td>
                                    </tr>
                                    <tr>
                                        <td class="mlchart-tooltip__label">${plotData.xLabel}</td>
                                        <td class="mlchart-tooltip__value">${tooltipNumericFormat(d.value)}</td>
                                    </tr>
                                    <tr>
                                        <td class="mlchart-tooltip__label">${plotData.legendLabel}</td>
                                        <td class="mlchart-tooltip__value">${d.series[0].key}</td>
                                    </tr>
                                </table>`;
                        });

                        // Redraw after axis modification
                        svg.datum(scope.theData).call(scope.chart);
                    };
                } else {
                    plotData.plotType = 'CONTOUR';
                    plotData.x = dependency.x;
                    plotData.y = dependency.y;
                    plotData.xLabel = dependency.xLabel;
                    plotData.yLabel = dependency.yLabel;
                    plotData.score = dependency.score;
                }
                columnLabelCounts[plotData.xLabel] = (columnLabelCounts[plotData.xLabel] || 0) + 1;
                plotsDataByYDict[yLabel] = plotsDataByYDict[yLabel] || [];
                plotsDataByYDict[yLabel].push(plotData);
            }
        }

        // We sort the columns and rows so that we are the closest possible to a triangular matrix:
        // - Rows sorted by descending length
        // - Columns sorted by descending number of rows where they are present
        // We also fill empty cells with 'EMPTY' plots not to break the tabular shape in case it is not
        // possible to obtain a triangular matrix
        $scope.orderedColumns = Object.keys(columnLabelCounts).sort(
            (a, b) => -columnLabelCounts[a] + columnLabelCounts[b]
        );
        $scope.plotsDataByY = Object.entries(plotsDataByYDict)
            .sort((a, b) => -a[1].length + b[1].length)
            .map(([yLabel, plotsData]) => {
                const newPlotsData = $scope.orderedColumns.map((xLabel) => {
                    let plotsWithXLabel = plotsData.filter((plotData) => {
                        return plotData.xLabel === xLabel;
                    });
                    return plotsWithXLabel.length ? plotsWithXLabel[0] : { plotType: 'EMPTY' };
                });
                return [yLabel, newPlotsData];
            });

        // Compute plot width so that they all approximately fit on a 1200px wide screen
        $scope.maxRowLength = Math.max(...$scope.plotsDataByY.map((_) => _[1].length));
        $scope.plotWidth = Math.max(
            Math.min(
                Math.floor(900 / $scope.maxRowLength), // Aim at a total width of ~900px
                350 // Maximum width is 350
            ),
            250 // Minimum width is 250
        );
    });

    // Gaussian kernel interpolation function for cat/num plots
    function gaussianSmooth(points) {
        let gaussian = function (a, b, bandwidth) {
            return Math.exp(-Math.pow(a - b, 2) / (2 * bandwidth * bandwidth));
        };

        if (points.length <= 2) {
            return points.join('L'); // Linear interpolation for <= 2 points
        }

        const x = points.map((_) => _[0]);
        const bandwidth = (Math.max(...x) - Math.min(...x)) / Math.min(points.length, 7);

        // The interpolated line is defined by 50 x values
        return MLChartsCommon.linspace(Math.min(...x), Math.max(...x), 50)
            .map(function (xValue) {
                var numerator = d3.sum(points, (point) => gaussian(point[0], xValue, bandwidth) * point[1]);
                var denominator = d3.sum(points, (point) => gaussian(point[0], xValue, bandwidth));
                return [xValue, numerator / denominator];
            })
            .join('L');
    }
}]);

})();

(function(){
    'use strict';

    const app = angular.module('dataiku.ml.explainability', []);

    app.constant('epochShift', 2208988800); // 1900-01-01 (py models) to 1970-01-01 (mllib models)

    /**
     * This directive is used to display the template of the computation params form.
     */
    app.directive("computationParamsForm", function() {
        return {
            restrict: 'E',
            replace: true,
            templateUrl: "/templates/ml/prediction-model/computation-params-form.html",
            scope: true,
            link: function(scope) {
                scope.uiState.computationParams = {};
                angular.copy(scope.computationParams, scope.uiState.computationParams);

                scope.save = function() {
                    angular.copy(scope.uiState.computationParams, scope.computationParams);
                    scope.dismissPopin();
                }
            }
        }
    });

    app.directive("explanationParamsForm", function() {
        return {
            restrict: 'E',
            replace: true,
            templateUrl: "/templates/ml/prediction-model/explanation-params-form.html",
            scope: true,
            link: function(scope) {
                scope.uiState.explanationParams = {};
                angular.copy(scope.explanationParams, scope.uiState.explanationParams);

                scope.save = function() {
                    angular.copy(scope.uiState.explanationParams, scope.explanationParams);
                    if (scope.onExplanationParamsChange) {
                        scope.onExplanationParamsChange();
                    }
                    scope.dismissPopin();
                }
            }
        }
    });

    /**
     * This directive will add function `toggleComputationParamsPopin` in the scope.
     * It needs `computationParams` set in the parent scope.
     * As `dkuPopinOptions` needs a template as a string,
     * to be clearer the directive `computationParamsForm` is created to hold the template
     */
    app.directive("withComputationParamsPopin", function(openDkuPopin) {
        return {
            scope: true,
            restrict: 'A',
            link: function(scope, _, attrs) {
                scope.hideNbJobs = attrs.hideNbJobs;
                scope.popinOpen = false;
                scope.sampleSizeLabel = attrs.sampleSizeLabel ? attrs.sampleSizeLabel : "Sample size";
                scope.sampleSizeHelp = attrs.sampleSizeHelp ? attrs.sampleSizeHelp : "Number of records of the dataset to use for the computation";
                
                scope.toggleComputationParamsPopin = function($event) {
                    if (scope.popinOpen === false) {
                        function isElsewhere(elt, e) {
                            return $(e.target).parents(".dropdown-menu").length == 0;
                        }
                        const dkuPopinOptions = {
                            template: '<computation-params-form></computation-params-form>',
                            isElsewhere,
                            popinPosition: 'SMART',
                            onDismiss: () => {
                                scope.popinOpen = false;
                            }
                        };
                        scope.dismissPopin = openDkuPopin(scope, $event, dkuPopinOptions);
                        scope.popinOpen = true;
                    } else if (scope.dismissPopin) {
                        scope.dismissPopin();
                    }
                };
            }
        }
    });
})();

(function(){
    'use strict';
        
    var app = angular.module('dataiku.ml.explainability');

    app.controller('PdpPlotController', function($scope, DataikuAPI, $stateParams, FutureProgressModal, WT1, ActiveProjectKey, epochShift) {
        function preparePartialDependence(scope) {
            scope.labelsRemaping = {
                "__DKU_N/A__": "[No value]",
                "__DKU_OTHERS__": "[Others]",
                "__DKU_UNREPRESENTED__": "[Unrepresented in train]",
            }
            const distributionColor = "#D5D9D9";
            const pdData = scope.modelData.iperf.partialDependencies;
            scope.data = {};
            scope.heights = {};
            scope.distributions = {};
            scope.computedPostTraining = {};
            scope.isDate = {};
            scope.nbRecords = {};
            scope.nbPoints = {};
            scope.onSample = {};
            let classes = scope.modelData.classes;
            if (scope.isBinaryClassification()) {
                classes = [scope.modelData.classes[1]] // Need only the "positive" class
            }
            const nbOfClasses = classes ? classes.length : 1;
            (pdData || []).forEach(function(pd) {
                scope.computedPostTraining[pd.feature] = pd.computedPostTraining;
                scope.nbRecords[pd.feature] = pd.nbRecords;
                scope.onSample[pd.feature] = pd.onSample;
                // Numerical feature
                if (pd.featureBins) {
                    if (pd.isDate) {
                        pd.featureBins = pd.featureBins.map((d) => new Date(d - epochShift) * 1000)
                    }
                    scope.nbPoints[pd.feature] = pd.featureBins.length;
                    scope.data[pd.feature] = []
                    scope.isDate[pd.feature] = pd.isDate;
                    pd.data.forEach((data, i) => {
                        const binsWithoutDropped = pd.featureBins.filter((_, j) => {
                            return pd.indicesToDrop.indexOf(j) === -1;
                        });
                        const values = data.filter((_, j) => {
                            return pd.indicesToDrop.indexOf(j) === -1;
                        }).map((y, j) => {
                            return [binsWithoutDropped[j], y]
                        });
                        scope.data[pd.feature][i] =  {
                            key: classes ? classes[i] : "Partial dependence",
                            values,
                            color: scope.colors[i],
                            type: "line",
                            yAxis: 1,
                        }
                    })

                    if (pd.distribution) {
                        scope.data[pd.feature].push({
                            key : "Distribution",
                            yAxis: 2,
                            type: "bar",
                            color: distributionColor,
                            values : pd.distribution.map((d, i) => [pd.featureBins[i], d]),
                        });
                    }
                // Categorical feature
                } else if (pd.categories) {
                    if (pd.distribution) {
                        scope.distributions[pd.feature] = [{
                            color: distributionColor,
                            values : pd.distribution.map((d, i) => ({ label: pd.categories[i], value: d })),
                        }];
                    }
                    scope.nbPoints[pd.feature] = pd.categories.length;
                    scope.heights[pd.feature] = pd.categories.length * nbOfClasses *  15 + 400;
                    scope.data[pd.feature] = [];
                    pd.data.forEach((pdp, i) => {
                        scope.data[pd.feature][i] =  {
                            key: classes ? classes[i] : "Partial dependence",
                            values: [],
                        }
                        pdp.forEach((pdpValue, j) => {
                            let modality = pd.categories[j];
                            const isUnrepresented = pd.unrepresentedModalities.indexOf(modality) > -1;
                            if (scope.labelsRemaping[modality]) {
                                modality = scope.labelsRemaping[modality];
                                scope.nbPoints[pd.feature] -= 1;
                            }
                            if (isUnrepresented) {
                                modality += "*";
                            }
                            if (pd.indicesToDrop.indexOf(j) > -1) {
                                pdpValue = Number.NaN;
                                modality += "**"
                            }
                            scope.data[pd.feature][i].values.push({ label: modality, value: pdpValue, color: scope.colors[i]});
                        });
                    })
                }
            });

            scope.alreadyComputedFeatures = new Set(scope.features.filter(f => scope.data[f]));
            scope.alreadyPostTrainingComputedFeatures = scope.features.filter(f => scope.data[f] && scope.computedPostTraining[f])
        }
        const allFeaturesInfo = $scope.modelData.preprocessing.per_feature;
        $scope.authorizedFeaturetypes = ["CATEGORY", "NUMERIC"];
        $scope.features = Object.keys(allFeaturesInfo).filter((feature) => {
            return allFeaturesInfo[feature].role === "INPUT" && $scope.authorizedFeaturetypes.includes(allFeaturesInfo[feature].type);
        });
        $scope.isKFolding = $scope.modelData.splitDesc.params.kfold;
        $scope.featuresType = {};
        $scope.features.forEach(feature => $scope.featuresType[feature] = $scope.modelData.preprocessing.per_feature[feature].type)
        $scope.computationParams = {
            sample_size: 10000,
            random_state: 1337,
            n_jobs: 1,
            debug_mode: false,
        }

        preparePartialDependence($scope);
        if (! $scope.uiState.selectedFeature) {
            $scope.uiState.selectedFeature = $scope.features.find(f => $scope.data[f] && $scope.computedPostTraining[f]);
        }

        $scope.canCompute = function() {
            return $scope.uiState.selectedFeature && $scope.computationParams.n_jobs !== 0;
        }

        $scope.$watch('uiState.selectedFeature', (nv) => {
            if ($scope.nbRecords[nv]) {
                $scope.computationParams.sample_size = $scope.nbRecords[nv];
            }
            d3.selectAll(".pdp__chart svg > *").remove();
        });

        $scope.computedOnStr = function() {
            const nbRecords = $scope.nbRecords[$scope.uiState.selectedFeature];
            const onSample = $scope.onSample[$scope.uiState.selectedFeature];
            let dataset = "";
            if ($scope.isKFolding) {
                dataset = "dataset";
            } else {
                if ($scope.computedPostTraining[$scope.uiState.selectedFeature]) {
                    dataset = "test set";
                } else {
                    dataset = "train set"
                }
            }

            if (nbRecords) {
                if (!onSample) {
                    return `${nbRecords} rows (the full ${dataset})`;
                } else {
                    return `${nbRecords} rows (a sample of the ${dataset})`;
                }
            } else {
                return `the full ${dataset}`
            }
        }

        $scope.number

        $scope.hideBanner = function() {
            $scope.uiState.bannerHidden = true;
        }

        $scope.computeSelectedFeature = function() {
            const selectedFeat = $scope.uiState.selectedFeature;
            if (selectedFeat) {
                $scope.computePartialDependency([selectedFeat], $scope.computationParams);
            }
        }

        $scope.computeAll = function() {
            if ($scope.features.length > 0) {
                $scope.computePartialDependency($scope.features, $scope.computationParams);
            }
        }

        $scope.computePartialDependency = function(features, computationParams) {
            const wt1Payload = {
                computeAll: features.length > 1,
                predictionType: $scope.modelData.coreParams.prediction_type,
            }
            if (! wt1Payload.computeAll) {
                wt1Payload.featureType = $scope.featuresType[features[0]]
            }
            if ($stateParams.mesId) {
                DataikuAPI.modelevaluations.pdpComputationStart(makeFullModelEvalutionIdString(ActiveProjectKey.get(), $stateParams.mesId, $stateParams.runId),
                    features, computationParams).success((result) => {
                    FutureProgressModal.show($scope, result, "Computing Partial Dependence").then((data) => {
                        $scope.modelData.iperf.partialDependencies = data.partialDependencies;
                        preparePartialDependence($scope);
                    })
                }).error(setErrorInScope.bind($scope));
                WT1.event("doctor-compute-pdp", wt1Payload);
            } else {
                DataikuAPI.ml.prediction.pdpComputationStart($stateParams.fullModelId || $scope.fullModelId, features, computationParams).success((result) => {
                    FutureProgressModal.show($scope, result, "Computing Partial Dependence").then((data) => {
                        $scope.modelData.iperf.partialDependencies = data.partialDependencies;
                        preparePartialDependence($scope);
                    })
                }).error(setErrorInScope.bind($scope));
                WT1.event("doctor-compute-pdp", wt1Payload);
            }
        }

    });

})();

(function(){
    'use strict';

    var app = angular.module('dataiku.ml.explainability');
        

    app.controller("_SubpopTableUtilsController", function($scope, $filter, Fn, $interpolate, epochShift) {

        $scope.colorsRep = $scope.colors.slice(0, 2).concat($scope.colors.slice(0, 2));

        function getPercentString(v) {
            if (v < 0.01) {
                return "< 1 %";
            } else if (v > 1) {
                return "100 %";
            } else {
                return Math.round(v * 100) + " %";
            }
        }

        // Actually save "percentage" and "title" to be able
        // to search them when filtering
        function formatModalitiesInformation(data) {
            if (data) {
                if (data.modalities) {
                    data.modalities.forEach(function(modality) {
                        modality.weightedPercentage = modality.weightedCount / data.weightedNbRecords;
                        modality.weightedPercentageStr = getPercentString(modality.weightedPercentage);
                        modality.title = getValueTitle(modality, data.computed_as_type, data.isDate);
                        modality.longTitle = getValueLongTitle(modality, data.computed_as_type, data.isDate);
                    })
                }
                if (data.allDatasetModality) {
                    data.allDatasetModality.title = "";
                    data.allDatasetModality.longTitle = "";
                    data.allDatasetModality.weightedPercentage = 1;
                    data.allDatasetModality.weightedPercentageStr = "100 %";
                }
            }
        }

        function convertPyTimestampToDateStr(dateFormat) {
            return (tmstp) => {
                return d3.time.format(dateFormat)(new Date( 1000 * (tmstp - epochShift)));
            }
        }

        function getValueTitle(modality, computedAsType, isDate) {
            if (modality.missing_values) {
                return "Missing values";
            }
            switch(computedAsType) {
                case "CATEGORY": {
                    return modality.value;
                }
                case "NUMERIC": {
                    let formatData = isDate ? convertPyTimestampToDateStr("%Y/%m/%d") : (value => " " + $filter("smartNumber")(value) + " ");
                    const gt = modality.gte !== undefined ? "[" + formatData(modality.gte) : "(" + formatData(modality.gt);
                    const lt = modality.lte !== undefined ? formatData(modality.lte) + "]" : formatData(modality.lt) + ")";
                    return gt + ", " + lt;
                }
            }
        }

        // Different behaviour than getValueTitle only for numericals:
        // - slightly different presentation with "min < featureName <= max" instead of "(min, max]"
        // - put the full number, not a smartNumber version of it
        function getValueLongTitle(modality, computedAsType, isDate) {

            let longTitle = modality.weightedPercentageStr;
            if ($scope.areMetricsWeighted()) {
                longTitle += " (weighted out of " + modality.count + " rows)";
            } else if (angular.isDefined(modality.count)) {
                longTitle += " (" + modality.count + " rows)";
            }

            longTitle += " — ";
            if (computedAsType === "NUMERIC" && !modality.missing_values) {
                let formatData = isDate ? convertPyTimestampToDateStr("%Y-%m-%d %H:%M:%S") : (value => value);
                const gt = modality.gte !== undefined ? formatData(modality.gte) + " <= " : formatData(modality.gt) + " < ";
                const lt = modality.lte !== undefined ? " <= " + formatData(modality.lte) : " < " + formatData(modality.lt);
                return longTitle + gt + $scope.modelData.selectedSubpopFeat + lt;
            } else {
                return longTitle + getValueTitle(modality, computedAsType);
            }
        }

        function formatMultiClassifPerfData(perfData, index) {
            // CONFUSION MATRIX AND METRICS
            if (!perfData) {
                return;
            }

            perfData.singleMetrics =  {
                index: index,
                hammingLoss: perfData.metrics.hammingLoss,
                Precision: perfData.metrics.precision,
                Recall: perfData.metrics.recall,
                "F1-Score": perfData.metrics.f1,
                Accuracy: perfData.metrics.accuracy,
                logLoss:perfData.metrics.logLoss,
                auc:perfData.metrics.mrocAUC,
            };

            // ADD CUSTOM SCORE IF ANY
            if ($scope.modelData.modeling && $scope.modelData.modeling.metrics.evaluationMetric === "CUSTOM") {
                if (perfData.metrics.customScore !== undefined ) {
                    perfData.singleMetrics["customScore"] = perfData.metrics.customScore;
                }
            }
        }

        function formatBinaryClassifPerfData(perfData, cut) {

            // CONFUSION MATRIX AND METRICS
            let pcd = perfData && perfData.perCutData;
            if (!pcd) {
                return;
            }
            let i = 0;
            let iMax = pcd.cut.length - 1;
            if (cut >= pcd.cut[iMax]) {
                i = iMax;
            } else {
                while (pcd.cut[i] < cut && i <= iMax) {
                    i++;
                }
            }
            let headTaskCMW = $scope.modelData.headTaskCMW;
            let tp = pcd.tp[i], tn = pcd.tn[i], fp = pcd.fp[i], fn = pcd.fn[i];
            let actPos = tp + fn;
            let actNeg = tn + fp;
            let predPos = tp + fp;
            let predNeg = tn + fn;
            let eps = 0.01;
            perfData.singleMetrics =  {
                index: i, cut: pcd.cut[i],
                tp: {records: tp, actual: getPercentString(tp / (actPos + eps)), predicted: getPercentString(tp / (predPos + eps)), actualNum: tp / (actPos + eps)},
                tn: {records: tn, actual: getPercentString(tn / (actNeg + eps)), predicted: getPercentString(tn / (predNeg + eps)), actualNum: tn / (actNeg + eps)},
                fp: {records: fp, actual: getPercentString(fp / (actNeg + eps)), predicted: getPercentString(fp / (predPos + eps)), actualNum: fp / (actNeg + eps)},
                fn: {records: fn, actual: getPercentString(fn / (actPos + eps)), predicted: getPercentString(fn / (predNeg + eps)), actualNum: fn / (actPos + eps)},
                actPos: {records: tp + fn, actual: "100 %", ratio: actPos / (actPos + actNeg)},
                actNeg: {records: tn + fp, actual: "100 %", ratio: actNeg / (actPos + actNeg)},
                predPos: {records: tp + fp, predicted: "100 %", ratio: predPos / (predPos + predNeg)},
                predNeg: {records: tn + fn, predicted: "100 %", ratio: predNeg / (predPos + predNeg)},
                mcc: pcd.mcc[i], hammingLoss: pcd.hammingLoss[i],
                Precision: pcd.precision[i], Recall: pcd.recall[i],
                "F1-Score": pcd.f1[i], Accuracy: pcd.accuracy[i],
                logLoss:perfData.tiMetrics.logLoss,
                auc:perfData.tiMetrics.auc,
                lift:perfData.tiMetrics.lift,
                cmg: (headTaskCMW.tnGain * tn + headTaskCMW.tpGain * tp + headTaskCMW.fpGain * fp + headTaskCMW.fnGain * fn) / (tn + tp + fn + fp)
            };

            // ADD CUSTOM SCORE IF ANY
            if ($scope.modelData.modeling && $scope.modelData.modeling.metrics.evaluationMetric === "CUSTOM") {
                if (pcd.customScore !== undefined && pcd.customScore.length > 0) {
                    perfData.singleMetrics["customScore"] = pcd.customScore[i];
                } else if (perfData.tiMetrics.customScore !== undefined) {
                    perfData.singleMetrics["customScore"] = perfData.tiMetrics.customScore;
                }
            }

            // DENSITY CHART
            let pdd = perfData.densityData;
            let c = $scope.modelData.classes[1];
            let dd = pdd[c];
            if (pdd && Object.keys(pdd).length) {
                pdd.x = dd.incorrect.map(function(_, i, a) { return i / a.length; });
                pdd.ys = [dd.incorrect, dd.correct];
                pdd.xm = [cut];
                pdd.labels = ['class ' + $scope.modelData.classes[0], 'class ' + $scope.modelData.classes[1]];
                pdd.colors = $scope.colors.slice(0, 2).concat("#9467bd");
            }
        }

        function formatRegressionPerfData(perfData) {
            // ERROR DISTRIB CHART
            if (perfData.regression_performance) {
                const ed = perfData.regression_performance.error_distribution;
                if (ed) {
                    perfData.errorDistribBars = ed.map((p) => ({ min: p.bin_min, max: p.bin_max, count: p.count}))
                }
            }


            // SCATTER PLOT
            // remove duplicates in the scatter plot data - prevent d3 voronoi issue https://github.com/d3/d3/issues/1908
            let spd = perfData.scatterPlotData;
            if (spd) {
                let hashTbl = new Set();
                for (var i=spd.x.length-1;i>=0;i--) {
                    const key = spd.x[i] + '#' + spd.y[i];
                    if (hashTbl.has(key)) {
                        spd.x.splice(i,1);
                        spd.y.splice(i,1);
                    } else {
                        hashTbl.add(key);
                    }
                }
                perfData.spd = spd;
            }
        }

        function formatPerfDataAllModalities(data, thresholdFn = Fn.cst($scope.modelData.userMeta.activeClassifierThreshold)) {

            let formatFunc;
            if ($scope.isBinaryClassification()) {
                formatFunc = (mod) => formatBinaryClassifPerfData(mod.perf, thresholdFn(mod));
            } else if ($scope.isRegression()) {
                formatFunc = (mod) => formatRegressionPerfData(mod.perf);
            } else if ($scope.isMulticlass()) {
                formatFunc = (mod) => formatMultiClassifPerfData(mod.perf, mod.index);
            }

            if (data) {
                if (data.modalities) {
                    data.modalities.forEach(modality => {
                        if (!modality.excluded && modality.perf) {
                            formatFunc(modality); // NOSONAR: formatFunc is defined we are always in one the 3 handled cases
                        }
                    });
                }
                if (data.allDatasetModality && data.allDatasetModality.perf) {
                    formatFunc(data.allDatasetModality); // NOSONAR: formatFunc is defined we are always in one the 3 handled cases
                }
            }
        }

        $scope.getCurrentFeatureData = () => {
            return $scope.modelData.subPopulation[$scope.modelData.selectedSubpopFeat];
        };

        $scope.getNumModalities = () => {
            return $scope.getCurrentFeatureData().modalities.length;
        };

        $scope.isSelectedFeatureInput = () => {
            return $scope.per_feature && ($scope.per_feature[$scope.modelData.selectedSubpopFeat] || {}).role == "INPUT";
        };

        $scope.getNbRecords = () => {
            return $scope.getCurrentFeatureData().nbRecords;
        };

        $scope.getMetricName = function(metric) {
            if (!metric) { return '-'; }

            return metric.shortName || metric.name || metric.fieldName;
        };

        $scope.getMetricLongName = function(metric) {
            if (!metric) { return '-'; }

            return metric.name || metric.fieldName;
        };

        $scope.getModalityType = (plural) => {
            const featType = $scope.getCurrentFeatureData().computed_as_type;

            switch(featType) {
                case "NUMERIC":
                    return plural ? "bins" : "bin";
                case "CATEGORY":
                default:
                    return plural ? "modalities" : "modality";
            }
        }

        $scope.isScrolling = false;
        $scope.setAllDatasetScrolled = (userAction) => {
            $scope.isScrolling = (userAction.target.scrollTop > 0);
            $scope.$apply();
        };

        $scope.sortByMetric = (metricName) => {

            let ss = $scope.selection;
            let metric = $scope.uiState.display.metrics.find(m => m.fieldName === metricName);
            let modalities = $scope.getCurrentFeatureData().modalities;

            if ($scope.uiState.sortMetric === metricName) {
                ss.orderReversed = !ss.orderReversed;

                if (metricName !== "modality") {
                    // Put all excluded modalities at bottom
                    modalities.filter(modality => modality.excluded)
                        .forEach( modality => {
                            modality.sortMetric *= -1;
                        });
                }

                return;
            } else {
                ss.orderReversed = false;
            }

            $scope.uiState.sortMetric = metricName;

            // Set value of 'sortMetric'
            modalities.forEach( modality => {
                let sortMetric;
                // Distinguish "modality" because they are not actual metrics,
                if (metricName === "modality") {
                    sortMetric = - modality.index;
                } else {
                    if (!modality.excluded) {
                        // Use metric function or retrieve it from the object
                        if (angular.isDefined(metric)) {
                            sortMetric = metric.getMetricFromPerf(modality.perf);
                        } else {
                            sortMetric = $interpolate(`{{${metricName}}}`)(modality);
                        }
                    } else {
                        // Put all excluded modalities at bottom
                        if (ss.orderReversed) {
                            sortMetric = Number.MAX_VALUE;
                        } else {
                            sortMetric = - Number.MAX_VALUE;
                        }
                    }
                }
                modality.sortMetric = sortMetric;
            });

            ss.orderQuery = "-sortMetric";
        };

        $scope.isSortMetric = function(metricFieldName) {
            return $scope.uiState.sortMetric === metricFieldName;
        }

        function reinitializeSort() {
            let ss = $scope.selection;
            $scope.uiState.sortMetric = undefined;
            ss.orderQuery = undefined;
            ss.orderReversed = undefined;
        }

        function setNumDecimalsMetrics(subpopData) {

            let getArrayMinDiffNumDecimals = (arr) => {
                let minDiff = Number.MAX_VALUE;
                let sortedArr = arr.sort((a, b) => (a > b) ? 1 : -1);
                let diff;

                for (let i=0 ; i < sortedArr.length - 1; i++) {
                    diff = sortedArr[i + 1] - sortedArr[i];
                    if (diff < minDiff) {
                        minDiff = diff;
                    }
                }

                // minDiff > 10 => return 0
                // 10 => minDiff > 1 => return 1
                // 1 => minDiff > 0.1 => return 2
                // ...
                return Math.max(-Math.ceil(Math.log10(minDiff)), 0);
            };

            let numDecimalsMetrics = $scope.uiState.display.numDecimalsMetrics;
            let nonExcludedModalitiesPerf = subpopData.modalities.concat(subpopData.allDatasetModality).filter(modality => !modality.excluded)
                .map(modality => modality.perf);
            $scope.uiState.display.metrics.forEach(m => {
                let numDecimals = getArrayMinDiffNumDecimals(nonExcludedModalitiesPerf.map(perf => m.getMetricFromPerf(perf)));
                if (m.percentage) {
                    numDecimals = Math.max(numDecimals - 2, 0);
                }
                numDecimalsMetrics[m.fieldName] = numDecimals;
            });
        }

        function setDisplayedMetrics() {
            if ($scope.modelData.modeling) {
                $scope.uiState.display.modelMetric = $scope.uiState.display.metrics.find(m => $scope.modelData.modeling.metrics.evaluationMetric == (m.metricName || m.fieldName.toUpperCase()));
                $scope.uiState.display.modelMetric.displayed = true;
                $scope.uiState.display.modelMetric.isModelMetric = true;
            }

            $scope.uiState.display.metrics.filter(m => !m.isModelMetric)
            // Sorting first metrics that are 'byDefault'
                .sort((m1, m2) => (m1.byDefault === m2.byDefault) ? 0 : (m1.byDefault ? -1: 1))
                .slice(0, 3)
                .forEach(m => {m.displayed = true;});
        }

        function buildAllDatasetModality(data, allDatasetPerf) {
            if (data) {
                data.allDatasetModality = {
                    isAllDataset: true,
                    count: data.nbRecords,
                    perf: allDatasetPerf,
                    index: -1
                }
            }
        }

        $scope.formatTableResults = function(data, allDatasetPerf, thresholdFn) {
            setDisplayedMetrics();
            buildAllDatasetModality(data, allDatasetPerf);
            formatModalitiesInformation(data);
            formatPerfDataAllModalities(data, thresholdFn);
            setNumDecimalsMetrics(data);
            reinitializeSort();

        }

        // SETTINGS FOR FILTERING RESULTS

        $scope.selection = $.extend({
            filterParams: {
                userQueryTargets: ["title", "weightedPercentageStr"]
            }
        }, $scope.selection || {})

        // STATIC VARIABLES

        const probabilityCharts = [
            ["DENSITY", "Density Chart"],
            ["PROBA_DISTRIB", "Probability Distribution"]
        ];

        const confusionMatrixModes = [
            ["records", $scope.areMetricsWeighted() ? "Weighted record count" : "record count"],
            ["actual", $scope.areMetricsWeighted() ? "Weighted % of actual classes" : "% of actual classes"],
            ["predicted", $scope.areMetricsWeighted() ? "Weighted % of predicted classes" : "% of predicted classes"]
        ];


        // METRICS

        const bcSingleMetrics = [
            {
                fieldName: "auc",
                name: "ROC - AUC Score",
                shortName: "ROC AUC",
                metricName: "ROC_AUC",
                minDecimals: 2,
                maxDecimals: 4,
                byDefault: true
            },
            {
                fieldName: "Precision",
                minDecimals: 2,
                maxDecimals: 4,
                byDefault: true
            },
            {
                fieldName: "Recall",
                minDecimals: 2,
                maxDecimals: 4,
                byDefault: true
            },
            {
                fieldName: "Accuracy",
                minDecimals: 2,
                maxDecimals: 4
            },
            {
                fieldName: "F1-Score",
                name: "F1 Score",
                metricName: "F1",
                minDecimals: 2,
                maxDecimals: 4
            },
            {
                fieldName: "hammingLoss",
                name: "Hamming Loss",
                minDecimals: 2,
                maxDecimals: 4
            },
            {
                fieldName: "mcc",
                name: "Matthews Correlation Coefficient",
                shortName: "MC Coeff.",
                minDecimals: 2,
                maxDecimals: 4
            },
            {
                fieldName: "logLoss",
                metricName: "LOG_LOSS",
                name: "Log Loss",
                minDecimals: 2,
                maxDecimals: 4
            },
            {
                fieldName: "customScore",
                shortName: "Custom",
                name: "Custom Score",
                metricName: "CUSTOM",
                minDecimals: 2,
                maxDecimals: 4
            },
            {
                fieldName: "lift",
                shortName: "Lift",
                name: "Cumulative lift",
                metricName: "CUMULATIVE_LIFT",
                minDecimals: 2,
                maxDecimals: 4
            },
            {
                fieldName: "cmg",
                name: "Cost matrix",
                metricName: "COST_MATRIX",
                minDecimals: 2,
                maxDecimals: 4
            },
            // Put fake metrics for 'actual' and 'predicted' for highlighted columns
            {
                fieldName: 'actual',
                fake: true,
                percentage: true,
                maxDecimals: 1,
                getMetricFromPerf: perf => perf.singleMetrics.actPos["ratio"]
            },
            {
                fieldName: 'predicted',
                fake: true,
                percentage: true,
                maxDecimals: 1,
                getMetricFromPerf: perf => perf.singleMetrics.predPos["ratio"]
            }
        ];

        // Adding function to retrieve metric value from perf
        bcSingleMetrics.forEach( sm => {
            if (sm.getMetricFromPerf === undefined) {
                sm.getMetricFromPerf = (perf) => perf.singleMetrics[sm.fieldName];
            }
        });

        const regSingleMetrics = [
            {
                fieldName: "mae",
                shortName: "MAE",
                name: "Mean Absolute Error (MAE)",
                minDecimals: 1,
                maxDecimals: 2,
                byDefault: true
            },
            {
                fieldName: "rmse",
                shortName: "RMSE",
                name: "Root Mean Squared Error (RMSE)",
                minDecimals: 1,
                maxDecimals: 2,
                byDefault: true
            },
            {
                fieldName: "r2",
                shortName: " R2 Score",
                minDecimals: 2,
                maxDecimals: 4,
                byDefault: true
            },
            {
                fieldName: "pearson",
                shortName: "Pearson coeff.",
                name: "Pearson coefficient",
                minDecimals: 2,
                maxDecimals: 4
            },
            {
                fieldName: "mape",
                shortName: "MAPE",
                name: "Mean Absolute Percentage Error",
                minDecimals: 1,
                maxDecimals: 2,
                percentage: true
            },
            {
                fieldName: "evs",
                name: " Explained Variance Score",
                shortName: "Explained Var.",
                minDecimals: 2,
                maxDecimals: 4
            },
            {
                fieldName: "mse",
                shortName: "MSE",
                name: "Mean Squared Error (MSE)",
                minDecimals: 0,
                maxDecimals: 1
            },
            {
                fieldName: "rmsle",
                shortName: "RMSLE",
                name: "Root Mean Squared Logarithmic Error (RMSLE)",
                ignoreZero: true,
                minDecimals: 1,
                maxDecimals: 2
            },
            {
                fieldName: "customScore",
                shortName: "Custom",
                name: "Custom Score",
                metricName: "CUSTOM",
                minDecimals: 2,
                maxDecimals: 4
            }
        ];

        // Adding function to retrieve metric value from perf
        regSingleMetrics.forEach( sm => {
            sm.getMetricFromPerf = (perf) => perf.metrics[sm.fieldName];
        });

        const mcSingleMetrics = [
            {
                fieldName: "auc",
                name: "ROC - AUC Score",
                shortName: "ROC AUC",
                metricName: "ROC_AUC",
                minDecimals: 2,
                maxDecimals: 4,
                byDefault: true
            },
            {
                fieldName: "Precision",
                minDecimals: 2,
                maxDecimals: 4,
                byDefault: true
            },
            {
                fieldName: "Recall",
                minDecimals: 2,
                maxDecimals: 4,
                byDefault: true
            },
            {
                fieldName: "Accuracy",
                minDecimals: 2,
                maxDecimals: 4
            },
            {
                fieldName: "F1-Score",
                name: "F1 Score",
                metricName: "F1",
                minDecimals: 2,
                maxDecimals: 4
            },
            {
                fieldName: "hammingLoss",
                name: "Hamming Loss",
                minDecimals: 2,
                maxDecimals: 4
            },
            {
                fieldName: "logLoss",
                metricName: "LOG_LOSS",
                name: "Log Loss",
                minDecimals: 2,
                maxDecimals: 4
            },
            {
                fieldName: "customScore",
                shortName: "Custom",
                name: "Custom Score",
                metricName: "CUSTOM",
                minDecimals: 2,
                maxDecimals: 4
            }
        ];

        // Adding function to retrieve metric value from perf
        mcSingleMetrics.forEach( sm => {
            if (sm.getMetricFromPerf === undefined) {
                sm.getMetricFromPerf = (perf) => perf.singleMetrics[sm.fieldName];
            }
        });

        $scope.toggleMetricDisplay = function(metric) {
            if (!metric.isModelMetric) {
                metric.displayed = !metric.displayed;
            }
        };

        $scope.metricExists = function(metric) {
            return !metric.fake && metric.getMetricFromPerf($scope.getCurrentFeatureData().allDatasetModality.perf) !== undefined;
        };

        // INIT

        $scope.per_feature = $scope.modelData.preprocessing.per_feature;

        $scope.metricsWeighted = false;
        $scope.authorizedColTypes = ["CATEGORY", "NUMERIC"];
        $scope.authorizedColRoles = ["INPUT", "REJECT"];
        $scope.computedSubpopulations = new Set();

        let metrics;
        if ($scope.isBinaryClassification()) {
            metrics = bcSingleMetrics;
        } else if ($scope.isRegression()) {
            metrics = regSingleMetrics;
        } else if ($scope.isMulticlass()) {
            metrics = mcSingleMetrics;
        }

        $scope.uiState = {
            display: {
                predictionType: $scope.modelData.coreParams.prediction_type,
                probabilityCharts: probabilityCharts,
                probabilityChart: probabilityCharts[0][0],
                confusionMatrixModes: confusionMatrixModes,
                confusionMatrixMode: confusionMatrixModes[0][0],
                metrics: metrics,
                numDecimalsMetrics: {}
            },
            // Saving selection in uiState to be able to retrieve if switching tabs and coming back
            selection: $scope.selection,
            noValueComputed: !$scope.modelData.selectedSubpopFeat,
        };
    });

    app.controller("SubpopulationController", function($scope, DataikuAPI, $stateParams, FutureProgressModal, WT1, $filter, $controller, ActiveProjectKey) {
        $controller('_SubpopTableUtilsController', {$scope: $scope});

        $scope.computationParams = {
            sample_size: 10000,
            random_state: 1337,
            n_jobs: 1,
            debug_mode: false,
        }

        function processSubpopInfo(subpopInfo) {
            $scope.computedSubpopulations = new Set(subpopInfo.features
                .filter((f) => f.done_at).map((f) => f.feature));
            $scope.computedOn = subpopInfo.computedOn;
            $scope.onSample = subpopInfo.onSample;
            if (subpopInfo.onSample) {
                $scope.computationParams.sample_size = subpopInfo.sampleSize;
                $scope.computationParams.random_state = subpopInfo.randomState;
            }
            $scope.lastRandomState = subpopInfo.randomState;
            $scope.lastSampleSize = subpopInfo.sampleSize;
            // If not subpopulation displayed and at least one already computed, display it
            if ($scope.modelData.selectedSubpopFeat === undefined && $scope.computedSubpopulations.size > 0) {
                $scope.uiState.subpopFeature = $scope.computedSubpopulations.values().next().value;
            }
        }

        function retrieveSubpopulationsInfo() {
            var id = $stateParams.fullModelId || $scope.fullModelId;
            if ($stateParams.mesId) 
                DataikuAPI.modelevaluations.getSubpopulationsInfo(makeFullModelEvalutionIdString(ActiveProjectKey.get(), $stateParams.mesId, $stateParams.runId)).success(function(subpopInfo){
                    if (!$.isEmptyObject(subpopInfo)) {
                        processSubpopInfo(subpopInfo);
                    }
                }).error(setErrorInScope.bind($scope));
            else
                DataikuAPI.ml.prediction.getSubpopulationsInfo(id).success(function(subpopInfo){
                    if (!$.isEmptyObject(subpopInfo)) {
                        processSubpopInfo(subpopInfo);
                    }
                }).error(setErrorInScope.bind($scope));
        }

        function fetchSubpopulationResults(feature) {
            var id = $stateParams.fullModelId || $scope.fullModelId;
            if ($stateParams.mesId)  {
                if ($stateParams.mesId)  {
                    DataikuAPI.modelevaluations.getSubpopulation(makeFullModelEvalutionIdString(ActiveProjectKey.get(), $stateParams.mesId, $stateParams.runId), [feature]).success(function(data) {
                        updateWithNewSubpopulationResults(feature, data);
                    });
                }
            } else {
                DataikuAPI.ml.prediction.getSubpopulation(id, [feature]).success(function(data) {
                    updateWithNewSubpopulationResults(feature, data);
                });
            }
        }

        function updateWithNewSubpopulationResults(feature, subpopulationResults) {
            $scope.modelData.selectedSubpopFeat = feature;
            $scope.modelData.subPopulation = $scope.modelData.subPopulation || new Map();
            $scope.modelData.subPopulation[feature] = subpopulationResults.subpopulationAnalyses.find(sa => sa.feature === feature);
            $scope.modelData.allDatasetPerf = subpopulationResults.global.perf;
            retrieveSubpopulationsInfo();
            $scope.formatTableResults($scope.modelData.subPopulation[feature], $scope.modelData.allDatasetPerf);
            $scope.uiState.noValueComputed = false;
        }

        function selectFetchedSubpopulationResults(feature) {
            $scope.modelData.selectedSubpopFeat = feature;
            $scope.formatTableResults($scope.modelData.subPopulation[feature], $scope.modelData.allDatasetPerf);
        }

        function restoreSortbyMetricFromUiState() {
            let uiStateSelection = $scope.uiState.selection;
            let selection = $scope.selection;

            selection.orderReversed = uiStateSelection.orderReversed;
            selection.orderQuery = uiStateSelection.orderQuery;
            selection.filterQuery = uiStateSelection.filterQuery;
        }

        // Directly display results when an already computed feature is selected
        $scope.$watch("uiState.subpopFeature", function(newFeature, oldFeature) {
            if (!newFeature || newFeature === oldFeature ) {
                return;
            }
            if ($scope.computedSubpopulations.has(newFeature)) {
                if ($scope.modelData.subPopulation && $scope.modelData.subPopulation[newFeature]) {
                    selectFetchedSubpopulationResults(newFeature);
                } else {
                    fetchSubpopulationResults(newFeature);
                }
            }
        });

        $scope.$watch("modelData.userMeta.activeClassifierThreshold", function() {
            if ($scope.modelData.selectedSubpopFeat
                    && $scope.modelData.subPopulation && $scope.modelData.subPopulation[$scope.modelData.selectedSubpopFeat]) {
                $scope.formatTableResults($scope.modelData.subPopulation[$scope.modelData.selectedSubpopFeat], $scope.modelData.allDatasetPerf);
            }
        });

        $scope.canCompute = function() {
            return $scope.uiState.subpopFeature && $scope.computationParams.n_jobs !== 0;
        } 

        $scope.computeSubpopulation = function(feature) {

            if (!feature) {
                return;
            }

            if ($stateParams.mesId) {
                DataikuAPI.modelevaluations.subpopulationComputationStart(makeFullModelEvalutionIdString(ActiveProjectKey.get(), $stateParams.mesId, $stateParams.runId),
                        [feature], $scope.computationParams).success(function(data) {
                    var newScope = $scope.$new();
                    FutureProgressModal.show(newScope, data, "Computing Subpopulation").then(function(subpopulationResults) {
                        if (subpopulationResults) { // will be undefined if computation was aborted
                            updateWithNewSubpopulationResults(feature, subpopulationResults);
                        }
                    });
                }).error(setErrorInScope.bind($scope));

                // TODO: adjust the following
                WT1.event("me-compute-subpopulation", {
                    predictionType: $scope.evaluation.evaluation.predictionType,
                    feature_selection_params: $scope.evaluation.details.preprocessing.feature_selection_params,
                    metrics: $scope.evaluation.metrics,
                    weightMethod: $scope.evaluation.details.coreParams.weight.weightMethod
                });
            } else {
                var id = $stateParams.fullModelId || $scope.fullModelId;
                DataikuAPI.ml.prediction.subpopulationComputationStart(id, [feature], $scope.computationParams).success(function(data) {
                    var newScope = $scope.$new();
                    FutureProgressModal.show(newScope, data, "Computing Subpopulation").then(function(subpopulationResults) {
                        if (subpopulationResults) { // will be undefined if computation was aborted
                            updateWithNewSubpopulationResults(feature, subpopulationResults);
                        }
                    });
                }).error(setErrorInScope.bind($scope));

                WT1.event("pml-compute-subpopulation", {
                    backendType: $scope.modelData.backendType,
                    taskType: "PREDICTION",
                    predictionType: $scope.modelData.coreParams.prediction_type,
                    feature_selection_params: $scope.modelData.preprocessing.feature_selection_params,
                    metrics: $scope.modelData.modeling.metrics,
                    weightMethod: $scope.modelData.coreParams.weight.weightMethod
                });
            }
        }

        retrieveSubpopulationsInfo();

        // Save uiState into $scope.modelData to be able to restore the UI switching tabs and coming back
        if ($scope.modelData.$uiStateSubpopulation !== undefined) {
            $scope.uiState = $scope.modelData.$uiStateSubpopulation;
            restoreSortbyMetricFromUiState();
        } else {
            $scope.modelData.$uiStateSubpopulation = $scope.uiState;
        }

    });

    app.directive("subpopulationValue", function() {
        return {
            restrict: 'E',
            templateUrl: "/templates/ml/prediction-model/subpopulation-value.html",
            scope: {
                allDatasetPerf: "=",
                data : "=",
                threshold: "=",
                colors: "=",
                display: "=",
                classes: "=",
            },
            controller: function($scope, $controller) {
                $controller("_snippetMetricsCommon", {$scope: $scope});

                // VISUAL HELPERS

                $scope.getLinearGradient = function(ratio) {
                    return 'linear-gradient(to right, #9dccfe 0%, #9dccfe '+ (ratio * 100) +'%,rgba(0, 0, 0, 0) '+ (ratio * 100) +'%, rgba(0, 0, 0, 0) 100%)';
                };


                // INIT

                $scope.uiState = {
                    isExpanded: false,
                    excludedReasons: {
                        "DROPPED": "(all subpopulation dropped by the preprocessing)",
                        "NOTARGET": "(no target or weights on the subpopulation)",
                        "ONECLASS": "(only one class in subpopulation)"
                    }
                }

            }
        }
    });

})();

(function(){
    'use strict';

    var app = angular.module('dataiku.ml.explainability');
        

    app.controller("IndividualExplanationsController", function($scope, DataikuAPI, $stateParams, FutureProgressModal, ExportUtils, WT1, ActiveProjectKey) {
        
        const rangeLimit = { min: 0, max: 1 };
        const NUMBER_OF_BINS = 20;
        $scope.isKFolding = $scope.modelData.splitDesc.params.kfold;
        $scope.computationParams = {
            sample_size: Math.min(1000, maxRows()),
            random_state: 1337,
            n_jobs: 1,
            debug_mode: false,
        };
        $scope.uiState = {
            selectedFeature: undefined,
            showLowPredictions: true,
            showHighPredictions: true,
            nbExplanations: 3,
            method: "ICE",
            exportMode: false // true when the page is rendered by Model Document Generator
        };

        $scope.chartColor = '#D5D9D9';
        $scope.labels = [""];
        if ($scope.isMulticlass()) {
            // The classes that do not appear in test set should not be selectable to compute explanations
            $scope.selectableClasses = Object.keys($scope.modelData.perf.confusion.perActual);
        }

        $scope.selectedRange = {};
        $scope.forms = {};

        $scope.puppeteerPrepareForExport = function() {
            $scope.uiState.exportMode = true;
        };

        function getMultiClassificationDataToPlot(className) {
            const total = $scope.modelData.perf.confusion.totalRows;
            const actualRate = $scope.modelData.perf.confusion.perActual[className].actualClassCount / total;
            const otherRate = 1 - actualRate;
            const densityData = $scope.modelData.perf.densityData;
            const positiveClassDensityData = densityData[className];
            const median = positiveClassDensityData.incorrectMedian * otherRate + positiveClassDensityData.correctMedian * actualRate;
            return {
                x: densityData.x,
                y: positiveClassDensityData.correct.map(function (value, i) {
                    return value * actualRate + positiveClassDensityData.incorrect[i] * otherRate;
                }),
                median,
            };
        }

        function updateChartDataWithClass(className) {
            const data = getMultiClassificationDataToPlot(className);
            $scope.axes = {
                x: data.x,
                ys: [data.y]
            };
            $scope.average = data.median;
        }

        function maxRows() {
            if ($scope.isKFolding) {
                return $scope.modelData.trainInfo.fullRows;
            } else {
                return $scope.modelData.trainInfo.testRows;
            }
        }

        $scope.$watch("selectedClass", function (className) {
            if (className) {
                updateChartDataWithClass(className);
                updateResultsWithClass(className);
            }
        });

        $scope.$watch("axes", function () {
            let binSize = 0.01;
            if ($scope.isRegression()) {
                const predictions = $scope.modelData.perf.scatterPlotData.y;

                rangeLimit.max = d3.max(predictions);
                rangeLimit.min = d3.min(predictions);

                binSize = (rangeLimit.max - rangeLimit.min) / NUMBER_OF_BINS;
            }

            const { from, to } = getInitialBrushRange(10, binSize);
            $scope.selectedRange.from = from;
            $scope.selectedRange.to = to;

        }, true);

        if ($scope.isClassification()) {
            if ($scope.isMulticlass()) {
                $scope.selectedClass = $scope.modelData.classes[0];
            } else {
                const nbTrue = $scope.modelData.perf.perCutData.tp[0] + $scope.modelData.perf.perCutData.fn[0];
                const nbFalse = $scope.modelData.perf.perCutData.fp[0] + $scope.modelData.perf.perCutData.tn[0];
                const positiveRate = nbTrue / (nbTrue + nbFalse)
                const negativeRate = 1 - positiveRate;
                const densityData = $scope.modelData.perf.densityData;
                const positiveClassDensityData = densityData[$scope.modelData.classes[1]];
                $scope.average = positiveClassDensityData.correctMedian * positiveRate + positiveClassDensityData.incorrectMedian * negativeRate;
                $scope.axes = {
                    x: densityData.x,
                    ys: [positiveClassDensityData.correct.map(function (value, i) {
                        return value * positiveRate + positiveClassDensityData.incorrect[i] * negativeRate;
                    })]
                };
            }
            $scope.dataAxes = ["Predicted probability", "Probability density"];
            $scope.scale = d3.scale.linear().domain([0, 1]);
        } else if ($scope.isRegression()) {
            const predictions = $scope.modelData.perf.scatterPlotData.y;

            rangeLimit.max = d3.max(predictions);
            rangeLimit.min = d3.min(predictions);
            const x = d3.scale.linear().domain([rangeLimit.min, rangeLimit.max]);
            const data = d3.layout.histogram()
                .frequency(0)
                .bins(x.ticks(NUMBER_OF_BINS))
                (predictions);

            $scope.axes = {
                x: data.map(d => d.x),
                ys: [data.map(d => d.y)]
            };
            $scope.average = weightedMean($scope.axes.x, $scope.axes.ys[0]);
            $scope.dataAxes = ["Prediction", "Prediction density"];
            $scope.scale = d3.scale.linear().domain([rangeLimit.min, rangeLimit.max]);
        }

        function weightedMean(arrValues, arrWeights) {
            let cumSum = 0;
            let totalWeight = 0;
            for (let i = 0; i < arrValues.length; i++) {
                cumSum += arrValues[i] * arrWeights[i];
                totalWeight += arrWeights[i];
            }
            return cumSum / totalWeight;
        }

        function getInitialBrushRange(nbWantedRows, binSize) {
            let estimatedNbRowsInLeft = 0;
            let estimatedNbRowsInRight = 0;

            let xInfBrush, xSupBrush;
            for (let i=0; i < $scope.axes.x.length; i++) {
                if ($scope.isRegression()) {
                    estimatedNbRowsInLeft += $scope.axes.ys[0][i] * $scope.computationParams.sample_size;
                    estimatedNbRowsInRight += $scope.axes.ys[0][$scope.axes.x.length - i - 1] * $scope.computationParams.sample_size;
                } else {
                    estimatedNbRowsInLeft += binSize * $scope.axes.ys[0][i] * $scope.computationParams.sample_size;
                    estimatedNbRowsInRight += binSize * $scope.axes.ys[0][$scope.axes.x.length - i - 1] * $scope.computationParams.sample_size;
                }
                if (xInfBrush === undefined && estimatedNbRowsInLeft >= nbWantedRows) {
                    xInfBrush = $scope.axes.x[i];
                }
                if (xSupBrush === undefined && estimatedNbRowsInRight >= nbWantedRows) {
                    xSupBrush = $scope.axes.x[$scope.axes.x.length-i - 1];
                }
            }
            const middleRange = (rangeLimit.max - rangeLimit.min) / 2;
            if (!xInfBrush) {
                xInfBrush = middleRange;
            }
            if (!xSupBrush) {
                xSupBrush = middleRange;
            }
            return { from: xInfBrush, to: xSupBrush };
        }

        function setNumberOfRowsInLeftBrush() {
            let binSize = 0.01; // True only for classification but not needed in regression
            let estimatedNbRowsInLeft = 0;
            for (let i=0; i < $scope.axes.x.length; i++) {
                if ($scope.isRegression()) {
                    if ($scope.axes.x[i] <= $scope.selectedRange.from) {
                        estimatedNbRowsInLeft += $scope.axes.ys[0][i] * $scope.computationParams.sample_size;
                    }
                } else {
                    if ($scope.axes.x[i] <= $scope.selectedRange.from) {
                        estimatedNbRowsInLeft += binSize * $scope.axes.ys[0][i] * $scope.computationParams.sample_size;
                    }
                }
            }
            $scope.nbRowsLeft = Math.round(estimatedNbRowsInLeft);
        }

        function setNumberOfRowsInRightBrush() {
            let binSize = 0.01; // True only for classification but not needed in regression
            let estimatedNbRowsInRight = 0;
            for (let i=0; i < $scope.axes.x.length; i++) {
                if ($scope.isRegression()) {
                    if ($scope.axes.x[$scope.axes.x.length-i - 1] >= $scope.selectedRange.to) {
                        estimatedNbRowsInRight += $scope.axes.ys[0][$scope.axes.x.length - i - 1] * $scope.computationParams.sample_size;
                    }
                } else {
                    if ($scope.axes.x[$scope.axes.x.length-i - 1] >= $scope.selectedRange.to) {
                        estimatedNbRowsInRight += binSize * $scope.axes.ys[0][$scope.axes.x.length - i - 1] * $scope.computationParams.sample_size;
                    }
                }
            }
            $scope.nbRowsRight = Math.round(estimatedNbRowsInRight);
        }

        $scope.addBrush = function() {
            const epsilon = (rangeLimit.max - rangeLimit.min) / 1000;
            // clean up
            d3.selectAll(".line-chart-brush__right").remove();
            d3.selectAll(".line-chart-brush__left").remove();
            d3.selectAll(".x-average-mark").remove();

            const backgroundRect = d3.select(".nv-background rect");
            const backgroundG = d3.select(".nv-background")
            const brushHeight = Number(backgroundRect.style("height").split("px")[0]);
            const brushSvg = backgroundG.select(function() { return this.parentNode; });
            brushSvg.attr("height", backgroundRect.style("height"));

            const rightExtentRange = [$scope.selectedRange.to, rangeLimit.max];
            const leftExtentRange = [rangeLimit.min, $scope.selectedRange.from];

            if (leftExtentRange[1] > rightExtentRange[0]) {
                leftExtentRange[1] = rightExtentRange[0];
            }

            // avoid 0 width brushes
            if (leftExtentRange[1] === rangeLimit.min) {
                leftExtentRange[1] += epsilon;
            }
            if (rightExtentRange[0] === rangeLimit.max) {
                rightExtentRange[0] -= epsilon;
            }

            const width = backgroundG.node().getBoundingClientRect().width;
            const xScale = $scope.scale.range([0, width]);
            const brushHandlerHeight = 30;
            const brushHandlerWidth = 15;

            const onRightBrushed = function() {
                let rightExtent = rightBrush.extent();
                if (d3.event.mode === "move") { // disable brush moving
                    rightExtent = [$scope.selectedRange.to, rangeLimit.max];
                }  else if (rightExtent[1] === rightExtent[0]) {
                    rightExtent[0] -= epsilon; // avoid to have a brush with a width of 0
                    $scope.selectedRange.to = rightExtent[1];
                } else {
                    if (leftBrush && rightExtent[0] < leftBrush.extent()[1]) { // avoid to have a brush over the other
                        rightExtent[0] = leftBrush.extent()[1];
                    }
                    $scope.selectedRange.to = rightExtent[0];
                }
                $scope.$digest();
                d3.select(this).call(rightBrush.extent(rightExtent));
            };

            const onLeftBrushed = function() {
                let leftExtent = leftBrush.extent();
                if (d3.event.mode === "move") { // disable brush moving
                    leftExtent = [rangeLimit.min, $scope.selectedRange.from];
                } else if (leftExtent[1] === leftExtent[0]) {
                    leftExtent[1] += epsilon; // avoid to have a brush with a width of 0
                    $scope.selectedRange.from = leftExtent[0];
                } else {
                    if (rightBrush && leftExtent[1] > rightBrush.extent()[0]) { // avoid to have a brush over the other
                        leftExtent[1] = rightBrush.extent()[0];
                    }
                    $scope.selectedRange.from = leftExtent[1];
                }
                $scope.$digest();
                d3.select(this).call(leftBrush.extent(leftExtent));
            };
            // Add average mark
            brushSvg.append("path").attr("d", "M0,0 V" + (brushHeight-10))
                .attr("stroke-width", "1px").attr("stroke", $scope.chartColor).attr("stroke-dasharray", "5,3")
                .attr("transform", "translate(" + xScale($scope.average) + ", 10)").attr("class", "x-average-mark")
            brushSvg.append("text").attr("x", xScale($scope.average)).attr("y",  -1).attr("text-anchor", "middle").attr("class", "x-average-mark")
                .attr("fill", $scope.chartColor).text( $scope.isClassification() ? "Average probability" : "Average prediction");
            // make the brushes
            let leftBrush, rightBrush;
            if ($scope.uiState.showLowPredictions) {
                const leftBrushG = brushSvg.append("g").attr("class", "x line-chart-brush__left");
                leftBrush = d3.svg.brush().x(xScale).on("brush", onLeftBrushed).extent(leftExtentRange);
                const lB = leftBrushG.call(leftBrush);
                lB.selectAll(".extent").attr("y", 0).attr("height", brushHeight).style("cursor", "unset");
                leftBrushG.selectAll(".resize.e > rect").attr("y", 0).attr("height", brushHeight).attr("width", 5).style("visibility", "visible");
                leftBrushG.selectAll(".resize.e").append("rect").attr("x", -8).attr("y", (brushHeight / 2) - brushHandlerHeight /2).attr("height", brushHandlerHeight).attr("width", brushHandlerWidth);
            }
            if ($scope.uiState.showHighPredictions) {
                const rightBrushG = brushSvg.append("g").attr("class", "x line-chart-brush__right");
                rightBrush = d3.svg.brush().x(xScale).on("brush", onRightBrushed).extent(rightExtentRange);

                const rB = rightBrushG.call(rightBrush);
                rB.selectAll(".extent").attr("y", 0).attr("height", brushHeight).style("cursor", "unset");
                rightBrushG.selectAll(".resize.w > rect").attr("y", 0).attr("height", brushHeight).attr("width", 5).style("visibility", "visible");
                rightBrushG.selectAll(".resize.w").append("rect").attr("x", -8).attr("y", (brushHeight / 2) - brushHandlerHeight /2).attr("height", brushHandlerHeight).attr("width", brushHandlerWidth);
            }

            setNumberOfRowsInRightBrush();
            setNumberOfRowsInLeftBrush();
        };
        $scope.uiState.selectedColumn = findAnIdentifier();
        getExplanations();

        $scope.canCompute = function() {
            return $scope.forms.explanationsForm.nbExplanations.$valid && ($scope.uiState.showHighPredictions || $scope.uiState.showLowPredictions)
        };

        $scope.compute = function() {
            let computationParams = {
                low_predictions_boundary: $scope.selectedRange.from,
                high_predictions_boundary: $scope.selectedRange.to,
                nb_explanations: $scope.uiState.nbExplanations,
                class_to_compute: $scope.selectedClass,
                method: $scope.uiState.method,
                ...$scope.computationParams,
            };
            if ($stateParams.mesId) {
                DataikuAPI.modelevaluations.individualExplanationsComputationStart(makeFullModelEvalutionIdString(ActiveProjectKey.get(), $stateParams.mesId, $stateParams.runId),
                    computationParams).success((result) => {
                    FutureProgressModal.show($scope, result, "Computing Individual Explanations").then((explanationResults) => {
                        formatExplanationResults(explanationResults);
                    });
                }).error(setErrorInScope.bind($scope));
            } else {
                DataikuAPI.ml.prediction.individualExplanationsComputationStart($stateParams.fullModelId || $scope.fullModelId, computationParams)
                    .success((result) => {
                    FutureProgressModal.show($scope, result, "Computing Individual Explanations").then((explanationResults) => {
                        formatExplanationResults(explanationResults);
                    });
                }).error(setErrorInScope.bind($scope));
            }
            WT1.event("doctor-compute-explanations", {
                lowPredictionsBoundary: $scope.selectedRange.from,
                highPredictionsBoundary: $scope.selectedRange.to,
                nbExplanations: $scope.uiState.nbExplanations,
                predictionType: $scope.modelData.coreParams.prediction_type,
                sampleSize: $scope.computationParams.sample_size,
                method: $scope.uiState.method,
            });
        };

        function sortAndSplitExplanations() {
            const results = $scope.results;
            const explanations = {
                high: {
                    values: [],
                    index: [],
                },
                low: {
                    values: [],
                    index: [],
                }
            };
            for (let i=0; i<results.predictions.length; i++) {
                const prediction = results.predictions[i];
                explanations.high.values[i] = [];
                explanations.low.values[i] = [];
                if (prediction <= $scope.selectedRange.from) {
                    explanations.low.index.push(i);
                } else if (prediction >= $scope.selectedRange.to) {
                    explanations.high.index.push(i);
                }

                for (const feature in results.explanations) {
                    const explanation = {
                        featureName: feature,
                        featureValue: results.observations[feature][i],
                        value: results.explanations[feature][i],
                    };
                    if (prediction <= $scope.selectedRange.from) {
                        explanations.low.values[i].push(explanation);
                    } else if (prediction >= $scope.selectedRange.to) {
                        explanations.high.values[i].push(explanation);
                    }
                }
                explanations.low.values[i].sort((exp1, exp2) => Math.abs(exp2.value) - Math.abs(exp1.value));
                explanations.low.values[i] = explanations.low.values[i].slice(0, results.nbExplanations);

                explanations.high.values[i].sort((exp1, exp2) => Math.abs(exp2.value) - Math.abs(exp1.value));
                explanations.high.values[i] = explanations.high.values[i].slice(0, results.nbExplanations);
            }
            explanations.low.index.sort((i1, i2) => results.predictions[i1] - results.predictions[i2]);
            explanations.high.index.sort((i1, i2) => results.predictions[i2] - results.predictions[i1]);
            return explanations;
        }

        function findAnIdentifier() {
            const perFeature = $scope.modelData.preprocessing.per_feature;
            let defaultIdentifier; // default identifier is the first feature (sorted by alphabetical order)
            for (const feature in perFeature) {
                if (defaultIdentifier === undefined || feature < defaultIdentifier) {
                    defaultIdentifier = feature;
                }
                if (perFeature[feature].autoReason === "REJECT_IDENTIFIER") {
                    return feature;
                }
            }
            return defaultIdentifier;
        }

        function getExplanations() {
            if ($stateParams.mesId) {
                DataikuAPI.modelevaluations.getIndividualExplanations(makeFullModelEvalutionIdString(ActiveProjectKey.get(), $stateParams.mesId, $stateParams.runId))
                .success((allResults) => {
                    formatExplanationResults(allResults);
                });
            } else {
                DataikuAPI.ml.prediction.getIndividualExplanations($stateParams.fullModelId || $scope.fullModelId).success((allResults) => {
                    formatExplanationResults(allResults);
                });
            }
        }

        function formatExplanationResults(explanationResults) {
            if (explanationResults.perClass) {
                $scope.perClassResults = explanationResults.perClass;
                updateResultsWithClass($scope.selectedClass);
            }
        }

        function updateResultsWithClass(className) {
            if ($scope.perClassResults) {
                $scope.results = $scope.perClassResults[ $scope.isMulticlass() ? className : "unique" ]
                if ($scope.results) {
                    $scope.uiState.nbExplanations = $scope.results.nbExplanations;
                    $scope.computationParams.sample_size = $scope.results.nbRecords;
                    $scope.computationParams.random_state = $scope.results.randomState;
                    $scope.uiState.method = $scope.results.method;
                    $scope.selectedRange = {
                        from: $scope.results.lowPredictionsBoundary,
                        to: $scope.results.highPredictionsBoundary,
                    }
                    $scope.explanations = sortAndSplitExplanations($scope);
                }
            }
        }

        $scope.exportExplanations = function() {
            const exportColumns = Object.keys($scope.results.observations).map((feature) => {
                return { name: feature, type: "string"};
            });
            exportColumns.push({ name: $scope.isRegression() ? "predictions" : "probas", type: "string" });
            exportColumns.push({ name: "explanations", type: "string" });
            const indices = [...$scope.explanations.high.index, ...$scope.explanations.low.index];
            const data = [];
            for (let i=0; i < indices.length; i++) {
                const newRows = [];
                for (const col of Object.keys($scope.results.observations)) {
                    newRows.push($scope.results.observations[col][i]);
                }
                newRows.push($scope.results.predictions[i]);
                const explanationRow = {};
                const explanations = $scope.explanations.low.index.includes(i) ? $scope.explanations.low.values[i]: $scope.explanations.high.values[i];
                for (const explanation of explanations) {
                    explanationRow[explanation.featureName] = explanation.value;
                }
                newRows.push(JSON.stringify(explanationRow));
                data.push(newRows);
            }

            ExportUtils.exportUIData($scope, {
                name : "Individual explanations for model:" + $scope.modelData.userMeta.name,
                columns : exportColumns,
                data : data
            }, "Export explanations");
        };

        $scope.$watch("selectedRange.to", (newValue, oldValue) => { // FIX: trigger with high latency
            if (oldValue !== newValue) {
                setNumberOfRowsInRightBrush();
            }
        })

        $scope.$watch("selectedRange.from", (newValue, oldValue) => {
            if (oldValue !== newValue) {
                setNumberOfRowsInLeftBrush();
            }
        });

        $scope.$watch("computationParams.sample_size", () => {
            setNumberOfRowsInLeftBrush();
            setNumberOfRowsInRightBrush();
        });
    });

    app.factory("ExplanationBarUtils", function() {
        return {
            computeExplanationBarWidthFunc: function(explanationBarMaxWidth) {
                return (higherExplanation, currentExplanation) => {
                    const width = Math.trunc(Math.abs(currentExplanation / higherExplanation) * explanationBarMaxWidth);
                    return width === 0 ? 1 : width;
                }
            },

            computeExplanationXBarPositionFunc: function(explanationBarMaxWidth, explanationBarContainerWidth) {
                return (higherExplanation, currentExplanation) => {
                    const orientatedWidth = Math.trunc(currentExplanation / Math.abs(higherExplanation) * explanationBarMaxWidth);
                    if (orientatedWidth > 0) {
                        return Math.trunc(explanationBarContainerWidth / 2);
                    } else {
                        return Math.trunc(explanationBarContainerWidth / 2 + orientatedWidth)
                    }
                }
            },
        }
    });

    /**
     * This directive is used to display the explanations.
     */
    app.directive("individualExplanationCards", function(ExplanationBarUtils) {
        return {
            restrict: 'E',
            templateUrl: "/templates/ml/prediction-model/individual_explanation_cards.html",
            scope: {
                selectedColumn: '=',
                results: '=',
                isRegression: '=',
                explanations: '='
            },
            link: function(scope) {
                scope.explanationsHidden = [];
                scope.featuresShown = [];
                scope.subtitle = scope.isRegression ? 'Prediction' : 'Probability';
                const barMaxWidth = 40;
                scope.barContainerWidth = 100;
                scope.getBarWidth = ExplanationBarUtils.computeExplanationBarWidthFunc(barMaxWidth);
                scope.getXBarPosition = ExplanationBarUtils.computeExplanationXBarPositionFunc(barMaxWidth, scope.barContainerWidth);
                
                scope.toggleExplanations = function(index) {
                    scope.explanationsHidden[index] = !scope.explanationsHidden[index];
                }

                scope.toggleFeatures = function(index) {
                    scope.featuresShown[index] = !scope.featuresShown[index];
                }
            }
        }
    });


})();

(function(){
    'use strict';
        
    var app = angular.module('dataiku.ml.explainability');
        

    app.controller("InteractiveScoringController", function($scope, $timeout, DataikuAPI, WT1, $stateParams, Debounce, 
                                                            FutureWatcher, ExplanationBarUtils, localStorageService, CreateModalFromTemplate, 
                                                            ClipboardUtils, ActivityIndicator, ExportUtils, Dialogs, openDkuPopin, SpinnerService, epochShift) {
        if (! $scope.modelData) {
            return;
        }
        const perFeature = $scope.modelData.preprocessing.per_feature;
        const authorizedTypes = ['CATEGORY', 'NUMERIC', 'TEXT', 'VECTOR', 'IMAGE'];
        const authorizedRoles = ['INPUT'];
        let evaluationModelId = null;
        if ($scope.evaluation) {
            evaluationModelId = makeFullModelIdStringFromEvaluation($scope.evaluation.evaluation);
        }
        const fullModelId = evaluationModelId || $stateParams.fullModelId || $scope.fullModelId;
        const backendFormat = "YYYY-MM-DDTHH:mm:ss.SSS";
        const scorePrefix = 'proba_';
        const OTHERS_COLOR = '#ddd';

        let LOCAL_STORAGE_BUCKET_KEY,
            LOCAL_STORAGE_EXPLANATION_PARAMS_KEY,
            LOCAL_STORAGE_UI_STATE_KEY;
        if ($scope.insight && $scope.insight.id) {
            LOCAL_STORAGE_BUCKET_KEY = `dku.ml.interactivescoring.insight.${$scope.insight.id}.bucket`;
            LOCAL_STORAGE_EXPLANATION_PARAMS_KEY = `dku.ml.interactivescoring.insight.${$scope.insight.id}.explanationParams`;
            LOCAL_STORAGE_UI_STATE_KEY = `dku.ml.interactivescoring.insight.${$scope.insight.id}.uiState`;
        } else {
            LOCAL_STORAGE_BUCKET_KEY = `dku.ml.interactivescoring.${fullModelId}.bucket`;
            LOCAL_STORAGE_EXPLANATION_PARAMS_KEY = `dku.ml.interactivescoring.${fullModelId}.explanationParams`;
            LOCAL_STORAGE_UI_STATE_KEY = `dku.ml.interactivescoring.${fullModelId}.uiState`;
        }

        const nextTask = {
            "SCORE": null, "EXPLANATION": null,
        };

        const inputColumns = Object.keys(perFeature).filter(f => perFeature[f].role == "INPUT");

        // For dashboard
        $scope.userFeatures = null;

        $scope.computing = {
            "SCORE": false, "EXPLANATION": false,
        };
        $scope.ignoreFeatureTooltip = "Ignore feature: don't specify a value to the model";

        $scope.formatProba = (proba) => d3.format(",.2f")(proba*100);

        $scope.uiStateAlreadyLoaded = false;
        if (localStorageService.get(LOCAL_STORAGE_UI_STATE_KEY)) {
            $scope.uiState = localStorageService.get(LOCAL_STORAGE_UI_STATE_KEY);
            $scope.uiStateAlreadyLoaded = true;
        } else {
            $scope.uiState =  {
                features: [],
                preScriptFeatures: [],
                applyPreparationScript: null,
                couldNotRetrieveSchema: false,
                hasPreparationSteps: false,
                featureFilterOptions: [
                    { value: "index", label: "Dataset" },
                    { value: 'name', label: 'Name' },
                    { value: 'type', label: 'Type' }
                ],
            };
        }

        $scope.SCORE_VIEW = {
            COMPUTE: 'COMPUTE',
            COMPARE: 'COMPARE'
        };
        $scope.currentView = $scope.SCORE_VIEW.COMPUTE;
        $scope.showOtherFeatures = false;
        $scope.errors = {};

        $scope.labels = [''];
        $scope.barContainerWidth = 350;
        $scope.compareBarContainerWidth = 125;
        $scope.barMaxWidth = 100;
        $scope.compareBarMaxWidth = 50;

        $scope.getExplanationXBarPosition = ExplanationBarUtils.computeExplanationXBarPositionFunc($scope.barMaxWidth, $scope.barContainerWidth);
        $scope.getCompareExplanationXBarPosition = ExplanationBarUtils.computeExplanationXBarPositionFunc($scope.compareBarMaxWidth, $scope.compareBarContainerWidth);
        $scope.pickerFormat = "YYYY-MM-DD HH:mm";

        $scope.score = undefined;
        $scope.explanationParams = localStorageService.get(LOCAL_STORAGE_EXPLANATION_PARAMS_KEY) || {
            nbExplanations: 5,
            method: 'ICE',
        }

        $scope.bucket = localStorageService.get(LOCAL_STORAGE_BUCKET_KEY) || [];
        $scope.bucketCharts = [];
        $scope.scrollToLastItem = false;

        $scope.featureSortBy = {
            attribute: "index",
            isReversed: false,
        }

        $scope.getExplanationIncompatibility = function() {
            if ($scope.modelData.coreParams.backendType === "KERAS") {
                return "Cannot compute explanations for a model built with Keras";
            }
            return null;
        }

        $scope.sendBasicWT1Event = function() {
            WT1.event('interactive-scoring', {
                explanationParams: $scope.explanationParams,
                applyPreparationScript: $scope.uiState.applyPreparationScript
            })
        };

        // ----- UI interactions

        $scope.changeView = function(view) {
            $scope.currentView = view;
            $scope.scrollToLastItem = false;

            if (view === $scope.SCORE_VIEW.COMPARE) {
                WT1.event('interactive-scoring-compare-button', {
                    itemCount: $scope.bucket.length
                });
            }
        };

        $scope.changeEditMode = function(feature, newMode, triggerCompute=true) {
            feature.editMode = newMode;
            const featureOldValue = feature.value;
            switch(newMode) {
                case "UNSET":
                    feature.value = null;
                    break;
                case "DOMAIN":
                    if (feature.type === "NUMERIC" || feature.type === "DATE") {
                        if (feature.value === null || isNaN(feature.value)) {
                            feature.value = feature.defaultValue;
                        } else if (feature.value > feature.max) {
                            feature.value = feature.max;
                        } else if (feature.value < feature.min) {
                            feature.value = feature.min;
                        }
                    } else if (feature.type === "CATEGORY") {
                        if (!feature.possibleValues.includes(feature.value)) {
                            feature.value = feature.defaultValue;
                        }
                    }
                    break;
                case "RAW":
                    if (feature.type !== "NUMERIC") {
                        if (feature.value === null) {
                            feature.value = "";
                        }
                    }
                    break;
            }
            if (triggerCompute && featureOldValue !== feature.value) {
                onFeatureChange();
            }
        }

        $scope.toggleOtherFeatures = function() {
            $scope.showOtherFeatures = !$scope.showOtherFeatures;
        }

        $scope.isDoneLoading = function() {
            return Object.values($scope.computing).every(c => !c)  && $scope.score && ($scope.explanations || $scope.getExplanationIncompatibility());
        };

        $scope.toggleExplanationParamsPopin = function($event) {
            if (!$scope.popinOpen) {
                function isElsewhere(elt, e) {
                    return $(e.target).parents(".dropdown-menu").length == 0;
                }
                const dkuPopinOptions = {
                    template: '<explanation-params-form></explanation-params-form>',
                    isElsewhere,
                    popinPosition: 'SMART',
                    onDismiss: () => {
                        $scope.popinOpen = false;
                    }
                };
                $scope.dismissPopin = openDkuPopin($scope, $event, dkuPopinOptions);
                $scope.popinOpen = true;
            } else if ($scope.dismissPopin) {
                $scope.dismissPopin();
            }
        };

        $scope.fileUploaded = function(event, feature) {
            const file = event.srcElement.files[0];
            const reader = new FileReader();
            reader.onloadend = function(event){
                feature.value = event.target.result.split(",")[1]; // remove prefix "data:image/*;base64"
                $scope.onFeatureChange();
            }
            reader.readAsDataURL(file);
        }

        // ----- Feature formatting
        
        $scope.getFeatures = function() {
            return getFeaturesFromUiState($scope.uiState);
        }

        $scope.allFeaturesEmpty = function() {
            return $scope.getFeatures().every(f => f.value == undefined);
        } 

        $scope.getPredictedClassProba = function(score) {
            if ($scope.isClassification()) {
                return $scope.formatProba(score[scorePrefix + score.prediction]);
            }
        };

        $scope.getPositiveClassProba = function(score) {
            if ($scope.isBinaryClassification()) {
                return $scope.formatProba(score[scorePrefix + $scope.getPositiveClass()]);
            }
        };

        $scope.getProbaForBucketItem = function(score) {
            if ($scope.isMulticlass()) {
                return $scope.getPredictedClassProba(score);
            } else if ($scope.isBinaryClassification()) {
                return $scope.getPositiveClassProba(score);
            }
        }

        $scope.getFeatureComparator = function(inUserFeatures=true) {
            if ($scope.userFeatures && inUserFeatures) {
                return sortByListOfFeatures;
            } else {
                if (["index", "importance"].includes($scope.featureSortBy.attribute)) {
                    return sortByNumericValue;
                }
                return null; // default comparator
            }
        }

        function getIndexSortingAttibute() {
            return $scope.applyPreparationScript ? "preScriptIdx" : "index";
        }

        $scope.getFeatureOrderingExpression = function(inUserFeatures=true) {
            if ($scope.userFeatures && inUserFeatures) {
                return "name"; // in dashboard, the list of feature names will be used
            }
            if ($scope.featureSortBy.attribute === "type") {
                return [$scope.featureSortBy.attribute, hasFeatureImportance() ? "-importance" : getIndexSortingAttibute()];
            } else {
                return getIndexSortingAttibute();
            }
        }

        $scope.isSortReversed = function(inUserFeatures=true) {
            if ($scope.userFeatures && inUserFeatures) { 
                // no option to reverse sort in dashaboard
                return false;
            }
            return $scope.featureSortBy.isReversed;
        }

        function hasFeatureImportance() {
            return $scope.uiState.featureFilterOptions.map(o => o.value).includes("importance")
        }

        function sortByNumericValue(element1, element2) {
            return Number(element1.value) - Number(element2.value);
        }

        function sortByListOfFeatures(feature1, feature2) {
            return $scope.userFeatures.indexOf(feature1.value) - $scope.userFeatures.indexOf(feature2.value);
        }

        function getOtherFeatures() {
            if ($scope.tile) {
                if ($scope.tile.tileParams.advancedOptions.interactiveScoring) {
                    $scope.userFeatures = $scope.tile.tileParams.advancedOptions.interactiveScoring.featuresOrder;
                    return $scope.getFeatures()
                                 .map(f => f.name)
                                 .filter(col => !$scope.userFeatures.includes(col));
                } else {
                    return [];
                }
            }
        }

        $scope.hasFilteredOutFeatures = function() {
            const otherFeatures = getOtherFeatures();
            return $scope.userFeatures && otherFeatures && otherFeatures.length;
        }

        $scope.keepOnlyMainFeatures = function(feature) {
            if ($scope.userFeatures) {
                return $scope.userFeatures.includes(feature.name);
            }
            return !$scope.keepOnlyPartDimensions(feature);
        };

        $scope.keepOnlyPartDimensions = function(feature) {
            return feature.type == "PART_DIM";
        };

        $scope.keepOtherFeatures = function(feature) {
            const otherFeatures = getOtherFeatures();
            if (otherFeatures) {
                return otherFeatures.includes(feature.name);
            }
            return false;
        }

        // for binary classification
        $scope.getPositiveClass = function() {
            return $scope.modelData.classes ? $scope.modelData.classes[1] : '';
        };
        
        $scope.formatPrediction = function(prediction) {
            if ($scope.isRegression()) {
                return d3.format($scope.predictionFormat())(prediction);
            } else {
                return prediction;
            }
        }

        function getFeaturesFromUiState(uiState) {
            return uiState.applyPreparationScript ? uiState.preScriptFeatures : uiState.features;
        }

        function formatFeatures(features) {
            return features.map(feature => ({
                name: feature.name,
                value: feature.value,
                type: feature.type,
                importance: feature.importance,
            }));
        }

        function roundToXDigits(value, nDigits) {
            return parseFloat(value.toFixed(nDigits));
        }

        function smartNumberDigits(min, max) {
            if (min === max) {
                return 0;
            }
            const absoluteMin = Math.min(Math.abs(min), Math.abs(max));
            const differenceOrderOfMagnitude = Math.floor(Math.log10(max - min));
            if (differenceOrderOfMagnitude < 0) {
                return -differenceOrderOfMagnitude + 1;
            } else {
                return Math.max(max - min < 10 ? 1 : 0, -Math.floor(Math.log10(absoluteMin || 10)));
            }
        }

        function getFeatureInfo(collectorData, featuresStorageType, featureName, featureType) {
            let defaultValue;
            let defaultEditMode = "DOMAIN";
            switch (featureType) {
            case "NUMERIC":
                const isDate = featuresStorageType[featureName] === "date";
                const isInteger = featuresStorageType[featureName] === "bigint";

                const defaultNumValue = collectorData.per_feature[featureName].stats.median;
                const min = collectorData.per_feature[featureName].stats.min;
                const max = collectorData.per_feature[featureName].stats.max;
                const nDecimals = isInteger ? 0 : smartNumberDigits(min, max);
                defaultValue = isDate 
                    ? moment.unix(defaultNumValue - epochShift).utc().format($scope.pickerFormat) 
                    : roundToXDigits(defaultNumValue, nDecimals);
                return { 
                    value: defaultValue,
                    defaultValue,
                    min: roundToXDigits(min, nDecimals),
                    max: roundToXDigits(max, nDecimals),
                    type: isDate ? "DATE" : featureType,
                    defaultEditMode,
                    editMode: defaultEditMode,
                    nDecimals,
                }            
            case "CATEGORY":
                const possibleValues = [...(collectorData.per_feature[featureName].category_possible_values || [])];
                if (perFeature[featureName].dummy_drop === "DROP") {
                    const doppedModality = collectorData.per_feature[featureName].dropped_modality;
                    // when nan is the dropped modality it has been replaced by "__DKU_N/A__"
                    // and it will not be added to the possible values (can use ignore feature for that)
                    if (doppedModality !== undefined && doppedModality !== "__DKU_N/A__") {
                        possibleValues.push(doppedModality);
                    }
                }
                defaultValue = collectorData.per_feature[featureName].stats.mostFrequentValue;
                defaultEditMode = possibleValues && possibleValues.length ? "DOMAIN" : "RAW";
                return {
                    value: defaultValue,
                    defaultValue,
                    possibleValues,
                    defaultEditMode,
                    editMode: defaultEditMode,
                }
            case "VECTOR":
                defaultEditMode = "RAW";
                const vectorLength = collectorData.per_feature[featureName].vector_length || 0;
                defaultValue = "["+new Array(vectorLength).fill(0).join(", ")+"]";
                return { value: defaultValue, defaultValue , editMode: defaultEditMode, defaultEditMode};
            case "TEXT":
                defaultEditMode = "RAW";
                return { value: "", editMode: defaultEditMode, defaultEditMode };
            case "IMAGE":
                return { value: null, editMode: defaultEditMode, defaultEditMode };
            }
        }

        function formatFeaturesParams(featuresList) {
            const params = {
                features: []
            };
            featuresList.forEach((features, index) => {
                params.features[index] = {};
                features.forEach(feature => {
                    if (feature.value !== null) {
                        params.features[index][feature.name] = feature.type == "DATE" ? moment(feature.value).utc().format(backendFormat) : feature.value;
                    }
                });
            });
        
            return params;
        }

        // Scores/Explanations and charts

        $scope.predictionFormat = function () {
            const predictions = $scope.modelData.perf.scatterPlotData.y;
            const min = d3.min(predictions);
            const max = d3.max(predictions);
            return `.${smartNumberDigits(min, max)}f`;
        }

        function generateChartData() {
            if (! $scope.score) return;
            
            if ($scope.isClassification()) {
                const MAX_CLASSES = 6;
                $scope.predictions = getPredictionChartData($scope.score, MAX_CLASSES)
                $scope.threshold = $scope.isBinaryClassification() ? $scope.modelData.userMeta.activeClassifierThreshold : undefined;
            } else if ($scope.isRegression()) {
                $scope.prediction = $scope.score.prediction;
                const predictions = $scope.modelData.perf.scatterPlotData.y;
                const rangeLimit = { min: 0, max: 1 };
                rangeLimit.max = d3.max(predictions);
                rangeLimit.min = d3.min(predictions);
                const x = d3.scale.linear().domain([rangeLimit.min, rangeLimit.max]);
                const data = d3.layout.histogram()
                    .frequency(0)
                    .bins(x.ticks(20))
                    (predictions);

                $scope.axes = {
                    x: data.map(d => d.x),
                    ys: [data.map(d => d.y)]
                };
                $scope.xm = [$scope.prediction];
                $scope.dataAxes = ["Prediction", "Prediction density"];
                $scope.scale = d3.scale.linear().domain([rangeLimit.min, rangeLimit.max]);
            }
        }

        function sortAndFormatExplanations(allExplanations) {
            const allFormattedExplanations = []
            for (const explanationsForOneRow of allExplanations) {
                const formattedExplanations = [];
                if (!explanationsForOneRow)  {
                    allFormattedExplanations.push(null);
                } else {
                    for (const featureName in explanationsForOneRow) {
                        formattedExplanations.push({
                            feature: featureName,
                            value: explanationsForOneRow[featureName],
                        });
                    }
                    const sortedExplanations = formattedExplanations.sort((exp1, exp2) => Math.abs(exp2.value) - Math.abs(exp1.value));;
                    $scope.topExplanationValue = sortedExplanations[0].value;
                    sortedExplanations.forEach((explanation) => {
                        explanation.barWidthRatio =  ExplanationBarUtils.computeExplanationBarWidthFunc($scope.barMaxWidth)($scope.topExplanationValue, explanation.value) / $scope.barMaxWidth;
                    });
                    allFormattedExplanations.push(sortedExplanations);
                }
            } 
        return allFormattedExplanations;
        }

        if ($scope.uiStateAlreadyLoaded) {
            if (hasFeatureImportance()) {
                $scope.featureSortBy.attribute = "importance";
            }
            onFeatureChange();
            $scope.sendBasicWT1Event();
        } else {
            Promise.all([DataikuAPI.ml.prediction.getCollectorData(fullModelId),
                        DataikuAPI.ml.prediction.getColumnImportance(fullModelId),
                        DataikuAPI.ml.prediction.getSplitDesc(fullModelId)]).then(
                            ([collectorDataResp, columnImportanceResp, splitDescResp]) => {
                const collectorData = collectorDataResp.data;
                let perFeatureImportance;
                if (columnImportanceResp.data) {
                    const columns = columnImportanceResp.data.columns;
                    const importances = columnImportanceResp.data.importances;
                    perFeatureImportance = {};
                    columns.forEach((col, i) => perFeatureImportance[col] = importances[i]);
                    $scope.uiState.featureFilterOptions.push({value: "importance", label: "Importance"});
                    $scope.featureSortBy.attribute = "importance";
                }
                $scope.uiState.featuresStorageType = splitDescResp.data.schema.columns.reduce(
                    (obj, column) => Object.assign(obj, { [column.name]: column.type }), {});
                    
                $scope.uiState.features = Object.keys($scope.uiState.featuresStorageType)
                    .filter(featureName => authorizedTypes.includes(perFeature[featureName].type) && 
                                            authorizedRoles.includes(perFeature[featureName].role))
                    .map((name, index) => ({
                        index,
                        name,
                        type: perFeature[name].type,
                        role: perFeature[name].role,
                        importance: perFeatureImportance ? perFeatureImportance[name] : null,
                        ...getFeatureInfo(collectorData, $scope.uiState.featuresStorageType, name, perFeature[name].type)
                    }));

                if ($scope.isPartitionedModel() && $scope.isOnPartitionedBaseModel()) {
                    const dimensionNames = $scope.modelData.coreParams.partitionedModel.dimensionNames;
                    const donePartitions = Object.entries($scope.partitionedModelSnippets.partitions.summaries)
                                            .filter(([_, partition]) => partition.state.endsWith("DONE"))                        
                                            .map(([name, _]) => name.split("|"));

                    for (const [index, dimensionName] of dimensionNames.entries()) {
                        const possibleValues = [...new Set(donePartitions.map(part => part[index]))];
                        $scope.uiState.features.push({
                            name: dimensionName,
                            possibleValues,
                            defaultValue: donePartitions[0][index],
                            value: donePartitions[0][index],
                            type: "PART_DIM",
                        });
                    }
                }

                // Check if preparation script contains steps, if yes get the schema of the dataset before script
                DataikuAPI.ml.prediction.getPreparationScript(fullModelId).success((preparationScript) => {
                    $scope.uiState.hasPreparationSteps = preparationScript.steps.some(step => !step.disabled);
                    if ($scope.uiState.hasPreparationSteps) {
                        $scope.uiState.applyPreparationScript = true;
                        DataikuAPI.ml.prediction.getInputDatasetSchema(fullModelId).success((schema) => {
                            $scope.uiState.preScriptFeatures = schema.columns.map((col, index) =>  {
                                const f = $scope.uiState.features.find(f => f.name === col.name) ||
                                    { name: col.name, type: "TEXT", value: "", editMode: "RAW" };
                                f.preScriptIdx = index;
                                return f;
                            });
                            onFeatureChange();
                        }).catch((error) => {
                            if (error.status != 404) {
                                setErrorInScope.bind($scope)(error.data, error.status, error.headers);
                            } else {
                                $scope.uiState.applyPreparationScript = false;
                                $scope.uiState.couldNotRetrieveSchema = true;
                                onFeatureChange();
                            }
                        }).finally(() => {
                            $scope.sendBasicWT1Event();
                        });
                    } else {
                        onFeatureChange();
                        $scope.sendBasicWT1Event();
                    }
                }).catch(setErrorInScope.bind($scope));

            }).catch(setErrorInScope.bind($scope));
        }


        // ----- Comparator methods

        // We avoid having features before and after preparation script in the same comparator
        // If incompatible features are added to the comparator we offer two choices to the user:
        // cancel this adding or override the comprator content
        function protectBucketFromConflicts(needPreparationScript) {
            return new Promise((resolve, reject) => {
                if ($scope.bucket.length !== 0 &&
                    $scope.bucket[0].applyPreparationScript !== null &&
                    needPreparationScript !== null &&
                    $scope.bucket[0].applyPreparationScript !== needPreparationScript) {
                        CreateModalFromTemplate("templates/ml/prediction-model/interactive-scoring-conflict-dialog.html", $scope, null, function(newScope) {
                            newScope.showTips = true;
                            newScope.pasteAnyway = () => {
                                newScope.dismiss();
                                $scope.bucket = [];
                                resolve();
                            }
                            newScope.cancel = () => {
                                newScope.dismiss();
                                reject();
                            };
                        });
                } else {
                    resolve();
                }
            });
        }

        function safelyPasteInBucket(pastedItems) {
            const needPreparationScript = pastedItems[0].applyPreparationScript;
            protectBucketFromConflicts(needPreparationScript).then(() => {
                pasteInBucket(pastedItems);
            });
        }

        // Add current 
        function addToBucket() {
            const newItem = {
                name: '',
                score: $scope.score,
                explanation: $scope.explanations,
                features: $scope.getFeatures(),
                applyPreparationScript: $scope.uiState.applyPreparationScript,
            };
            // ignore any keys that aren't in the model's list of features
            //const features = $scope.uiState.features.map(feature => feature.name);
            newItem.features = formatFeatures(newItem.features);
            $scope.scrollToLastItem = true;
            $scope.bucket.push(newItem);
            ActivityIndicator.success("Added to comparator.");
            $scope.$apply();
        };

        $scope.safelyAddToBucket = function() {
            const needPreparationScript = $scope.uiState.applyPreparationScript;
            protectBucketFromConflicts(needPreparationScript).then(() => {
                addToBucket();
            });
        }

        $scope.removeFromBucket = function(index) {
            $scope.bucket[index].removing = true;
            
            $timeout(() => {
                $scope.bucket.splice(index, 1);
            }, 500);
        };

        $scope.removeAllFromBucket = function() {
            Dialogs.confirm($scope, "Clear all items", "Are you sure you want to clear all items in the comparator?").then(function () {
                $scope.bucket = [];
                ActivityIndicator.success('All items cleared from comparator.');
            });
        }

        // comparator item formatting
        function formatItems(items) {
            let formatedItems = angular.copy(items);

            return formatedItems.map(item => {
                Object.keys(item).forEach(key => {
                    if (key.startsWith('$')) {
                        delete item[key];
                    }
                });
                item.features = formatFeatures(item.features);

                return item;
            });
        }

        // Generates prediction chart under each item in the comparator
        function getPredictionChartData(predictions, maxClasses) {
            if (!$scope.isClassification()) return;

            // assign a color to each prediction
            let classes = $scope.modelData.classes.filter(pc => `${scorePrefix}${pc}` in predictions);
            let colorPalette = $scope.colors.slice(0, classes.length);
            let chartPredictions = classes.map((pc, index) => ({
                name: pc,
                value: predictions[`${scorePrefix}${pc}`],
                color: colorPalette[index]
            }));

            if ($scope.isBinaryClassification()) {
                chartPredictions = [chartPredictions[1], chartPredictions[0]];
            } else {
                chartPredictions.sort((p1, p2) => p2.value - p1.value);

                if (chartPredictions.length > maxClasses) {
                    chartPredictions = chartPredictions.slice(0, maxClasses - 1);
                    const othersPercentage = 1 - chartPredictions.reduce((total, prediction) => total + prediction.value, 0);
                    chartPredictions.push({
                        name: 'Others',
                        value: othersPercentage,
                        color: OTHERS_COLOR
                    });
                }
            }

            return chartPredictions;
        }

        $scope.$watch('bucket', function() {
            localStorageService.set(LOCAL_STORAGE_BUCKET_KEY, formatItems($scope.bucket));
            if ($scope.isClassification()) {
                $scope.bucketCharts = $scope.bucket.map(item => item.score ? getPredictionChartData(item.score, 3) : null);
            }

            if ($scope.bucket.length > 1) {
                const listOfFeatureValues = $scope.bucket[0].features.map((_, colIndex) => $scope.bucket.map(row => row.features[colIndex].value));
                const allEqual = arr => arr.every(v => v === arr[0]);
                for (const [i, featureValues] of listOfFeatureValues.entries()) {
                    for (const item of $scope.bucket) {
                        item.features[i].greyed = allEqual(featureValues);
                    }
                }
            } else if ($scope.bucket.length === 1) {
                $scope.bucket[0].features.forEach(f => f.greyed = false);
            }
        }, true);

        $scope.$watch("uiState", function() {
            localStorageService.set(LOCAL_STORAGE_UI_STATE_KEY, $scope.uiState);
        }, true);

        $scope.$watch("featureSortBy.attribute", function(nv, ov) {
            if (nv == "importance") {
                $scope.featureSortBy.isReversed = true;
            } else if (ov == "importance") {
                $scope.featureSortBy.isReversed = false;
            }
        });

        $scope.$on('$destroy', function() {
            localStorageService.set(LOCAL_STORAGE_BUCKET_KEY, $scope.bucket);
        });


        // ----- Copy/paste

        const copyType = 'interactive-scoring';

        $scope.copyValues = function(items) {
            let copy = {
                type: copyType,
                version: $scope.appConfig.version.product_version,
                samples: items.map(item => ({
                    name: item.name,
                    features: formatFeatures(item.features),
                    applyPreparationScript: item.applyPreparationScript,
                }))
            };

            ClipboardUtils.copyToClipboard(JSON.stringify(copy, null, 2), `Copied ${items.length} item${items.length === 1 ? '': 's'} to clipboard.`);
        };

        $scope.disableAllFeatures = function() {
            $scope.getFeatures().forEach(feature => $scope.changeEditMode(feature, "UNSET", false));
            onFeatureChange();
        }

        $scope.resetAllFeaturesToDefault = function() {
            $scope.getFeatures().forEach(feature => {
                feature.value = feature.defaultValue;
                feature.editMode = feature.defaultEditMode;
            });
            onFeatureChange();
        }

        $scope.openPasteDialog = function(pasteType) {
            let newScope = $scope.$new();

            CreateModalFromTemplate("/templates/ml/prediction-model/interactive_scoring_paste_modal.html", newScope, 'PasteModalController', function(modalScope) {
                modalScope.showTips = true;
                modalScope.copyType = 'interactive-scoring';
                modalScope.itemKey = 'samples';
                modalScope.pasteSingle = pasteType === $scope.SCORE_VIEW.COMPUTE;
                modalScope.pasteItems = pasteType === $scope.SCORE_VIEW.COMPUTE ? pasteFeatures : safelyPasteInBucket;
                modalScope.validateData = validatePastedData;
                modalScope.applyGenericFormat = formatCopiedData;
            });
        };

        function formatCopiedData(data) {
            if (Array.isArray(data.samples)) { 
                return data;
            } else {
                return { // May come from "Copy rows as JSON" in Dataset explore
                    type: copyType,
                    version: $scope.$root.appConfig.version.product_version,
                    samples: [{
                        name: "",
                        features: Object.entries(data).map(([name, value]) => { return {name , value} }),
                        applyPreparationScript: null,
                    }]
                }
            }
        }

        // immediately show preview state since we've already pasted
        $scope.openPasteModalFromKeydown = function(data) {
            try {
                data = JSON.parse(data);
            } catch(e) {}

            if (data && !Array.isArray(data.samples)) { // May come from "Copy rows as JSON" from Dataset explore
                data = formatCopiedData(data);  
                if (!validatePastedData(data.samples)) {
                    return;
                }
            }

            if (data && data.samples && data.samples.length && data.type === copyType) {
                let newScope = $scope.$new();

                CreateModalFromTemplate("/templates/ml/prediction-model/interactive_scoring_paste_modal.html", newScope, 'PasteModalController', function(modalScope) {
                    modalScope.uiState.editMode = false;
                    modalScope.uiState.items = data.samples;
                    modalScope.pasteSingle = $scope.currentView === $scope.SCORE_VIEW.COMPUTE;
                    modalScope.pasteItems = $scope.currentView === $scope.SCORE_VIEW.COMPUTE ? pasteFeatures : safelyPasteInBucket;
                    modalScope.validateData = validatePastedData;
                });
            }
        };

        $scope.getCurrentItem = function() {
            return {
                name: '',
                features: $scope.getFeatures(),
                applyPreparationScript: $scope.uiState.applyPreparationScript,
            };  
        };

        $scope.keydownCopy = function(event) {
            if ($scope.isDoneLoading() && $scope.currentView === $scope.SCORE_VIEW.COMPUTE) {
                $scope.copyValues([$scope.getCurrentItem()]);

                event.currentTarget.focus();
            }
        }

        function validatePastedData(pastedItems) {
            const allFeatures = $scope.getFeatures();

            // make sure at least one feature in each sample matches features used in the model
            return pastedItems.every(item => {
                return item.features.some(feature => {
                    return allFeatures.find(f => feature.name === f.name);
                });
            });
        }

        function pasteFeatures(pastedItems) {
            if (!pastedItems.length) return;
            const firstItem = pastedItems[0];
            $scope.uiState.applyPreparationScript = firstItem.applyPreparationScript;
            $scope.getFeatures().forEach(feature => {
                // take first set of features from list
                const pastedFeature = firstItem.features.find(f => feature.name === f.name);
                const pastedValue = pastedFeature ? pastedFeature.value : null;
                
                feature.editMode = getNewEditMode(feature, pastedValue);
                feature.value = pastedValue;
                feature.type = feature.type;
            });

            onFeatureChange();

            WT1.event('interactive-scoring-paste', {
                nbItems: pastedItems.length,
                type: 'features'
            });
        }

        // find the appropriate edit mode for the new value when pasted
        function getNewEditMode(feature, newValue) {
            if (newValue !== null) {
                if (feature.type === 'NUMERIC') {
                    if (newValue < feature.min || newValue > feature.max) {
                        return 'RAW';
                    }
                } else if (feature.type === "CATEGORY") {
                    if (!feature.possibleValues.includes(newValue)) {
                        return 'RAW';
                    }
                }

                return 'DOMAIN';
            }

            return 'UNSET';
        }

        function pasteInBucket(pastedItems) {
            const featureNames = $scope.getFeatures().map(feature => feature.name);
            const newItems = [];
            pastedItems.forEach(item => {
                newItems.push({ 
                    name: item.name,
                    features: featureNames.map(featureName => {
                        const matchedFeature = item.features.find(f => f.name === featureName) || {}
                        return {
                            name: featureName,
                            value: matchedFeature.value,
                            type: matchedFeature.type,
                        }
                    }),
                    applyPreparationScript: item.applyPreparationScript
                });
            });
            computeAll(newItems, null, () => {
                $scope.bucket = $scope.bucket.concat(angular.copy(newItems));
                $scope.scrollToLastItem = $scope.currentView === $scope.SCORE_VIEW.COMPARE ;
                ActivityIndicator.success(`${newItems.length} item${newItems.length === 1 ? '': 's'} successfully pasted.`);
            });

            WT1.event('interactive-scoring-paste', {
                nbItems: pastedItems.length,
                type: 'comparator'
            });
        }


        // ----- Export

        $scope.exportComparator = function() {
            // We supposed here that each item in the bucket have the same columns (theorically ensure when pasting or adding)
            const featureColumns = $scope.bucket[0].features.map((feature) => ({ name: feature.name, type: $scope.uiState.featuresStorageType[feature.name] || "string" }));
            const nameColumn = {
                name: 'score_name',
                type: 'string'
            };

            let predictionColumns = [];
            if ($scope.isClassification()) {
                predictionColumns = [...$scope.modelData.classes.map(c => ({
                    name: `${scorePrefix}${c}`,
                    type: 'string'
                })), {
                    name: 'prediction',
                    type: 'string'
                }];
            } else if ($scope.isRegression()) {
                predictionColumns = [{
                    name: 'prediction',
                    type: $scope.uiState.featuresStorageType[$scope.modelData.coreParams.target_variable]
                }];
            }

            const explanationColumns = [{
                name: 'explanations',
                type: 'string'
            }, {
                name: 'explanation_method',
                type: 'string'
            }];

            // for each bucket, 1) loop through the columns and find the associated value (if it exists)
            // and 2) add prediction information, and 3) explanations if present
            const data = $scope.bucket.map(item => {
                const featureValues = featureColumns.map(column => {
                    const feature = item.features.find(f => f.name === column.name);
                    
                    return feature ? feature.value : null;
                });
                let predictions = [item.score ? item.score.prediction[0] : null];
                // add proba for each class
                if ($scope.isClassification()) {
                    predictions = [...$scope.modelData.classes.map(c => item.score ? item.score[`${scorePrefix}${c}`] : null), ...predictions];
                }

                let values = [...featureValues, item.name, ...predictions]
                if ($scope.getExplanationIncompatibility() == null) {
                    const listOfExplanations = item.explanation.map(f => { return { [f.feature]: f.value }});
                    const explanationsStr = JSON.stringify(Object.assign({}, ...listOfExplanations));
                    values = [...values, explanationsStr, $scope.explanationParams.method]
                }
            
                return values;
            });
            
            let columns = [...featureColumns, nameColumn, ...predictionColumns];
            if ($scope.getExplanationIncompatibility() == null) {
                columns = [...columns, ...explanationColumns ]
            }

            ExportUtils.exportUIData($scope, {
                name : "Interactive scoring for model: " + $scope.modelData.userMeta.name,
                columns, 
                data : data
            }, 'Export Interactive Scoring');

            WT1.event('interactive-scoring-export-button', {
                explanationMethod: $scope.explanationParams.method,
                nbItems: data.length
            });
        }


        // ----- Backend handling and computing

        function startBackend() {
            return new Promise(function(resolve) {
                DataikuAPI.interactiveModel.startBackend(fullModelId).success(function(initialResponse) {
                    SpinnerService.lockOnPromise(FutureWatcher.watchJobId(initialResponse.jobId)
                        .success(function() {
                            resolve();
                        }).error(setErrorInScope.bind($scope)));
                }).error(setErrorInScope.bind($scope));
            });
        }

        async function startBackendIfNeeded() {
            const isBackendRunning = (await DataikuAPI.interactiveModel.backendStatus(fullModelId)).data;
            if (!isBackendRunning) {
                return await startBackend();
            }
        };

        function canCompute() {
            return !($scope.uiState.applyPreparationScript && $scope.uiState.couldNotRetrieveSchema) 
                && !$scope.allFeaturesEmpty();
        }

        function compute(actionFn, params, taskType, callback) {
            if (!$scope.computing[taskType]) {
                $scope.computing[taskType] = true;
                $scope.errors[taskType] = null;
                nextTask[taskType] = null;
                actionFn(params).noSpinner().success(function(data) {
                    if (nextTask[taskType]) { // if task was set during compute
                        $scope.computing[taskType] = false;
                        compute(actionFn, nextTask[taskType], taskType, callback);
                    } else {
                        callback(data);
                        $scope.computing[taskType] = false;
                    }
                }).error((error) => {
                    $scope.computing[taskType] = false;
                    if (nextTask[taskType]) { // if task was set during compute
                        compute(actionFn, nextTask[taskType], taskType, callback);
                    } else {
                        $scope.errors[taskType] = error;
                    }
                });
            } else {
                nextTask[taskType] = $scope.uiState;
            }
        };

        function computeScore() {
            const promiseFn = function(params) {
                return DataikuAPI.interactiveModel.computeScore(fullModelId, 
                    formatFeaturesParams([getFeaturesFromUiState(params)]),
                    params.applyPreparationScript);
            };

            return compute(promiseFn, $scope.uiState, "SCORE", (data) => {
                if ($scope.allFeaturesEmpty()) { // features way have been disabled during compute
                    $scope.score = null;
                } else {
                    $scope.score = data.scores[0];
                    generateChartData();
                }
            });
        }

        function computeExplanations() {
            const promiseFn = function(params) {
                return DataikuAPI.interactiveModel.computeExplanations(fullModelId,
                    formatFeaturesParams([getFeaturesFromUiState(params)]),
                    $scope.explanationParams.method, 
                    $scope.explanationParams.nbExplanations,
                    params.applyPreparationScript);
            };

            return compute(promiseFn, $scope.uiState, "EXPLANATION", function(data) {
                const allExplanations = sortAndFormatExplanations(data.explanations)
                if ($scope.allFeaturesEmpty()) { // features way have been disabled during compute
                    $scope.explanations = null;
                } else {
                    $scope.explanations = allExplanations.length ? allExplanations[0] : [];
                }
                $scope.outdatedExplanations = false;
            });
        }

        async function computeAll(bucketItems, currentFeatures, callback) {
            await startBackendIfNeeded();
            const allFeatures = bucketItems.map(item => item.features);
            if (currentFeatures) {
                allFeatures.push(currentFeatures);
            }
            const featuresParams = formatFeaturesParams(allFeatures);
            let computePromise;
            if ($scope.getExplanationIncompatibility()) {
                computePromise = DataikuAPI.interactiveModel.computeScore(fullModelId, 
                    featuresParams,
                    $scope.uiState.applyPreparationScript);
            } else {
                computePromise = DataikuAPI.interactiveModel.computeExplanations(fullModelId,
                    featuresParams,
                    $scope.explanationParams.method,
                    $scope.explanationParams.nbExplanations,
                    $scope.uiState.applyPreparationScript)
            }
            computePromise.success((results) => {
                const scores = results.scores;
                let explanations;
                if (results.explanations) {
                    explanations = sortAndFormatExplanations(results.explanations)
                }
                if (currentFeatures) {
                    $scope.score = scores.pop();
                    $scope.explanations = explanations ? explanations.pop() : null;
                }
                bucketItems.forEach((item, index) => {
                    item.explanation = explanations ? explanations[index] : null;
                    item.score = scores[index];
                });
                if (callback) {
                    callback();
                }
            }).catch(setErrorInScope.bind($scope));
        }

        $scope.onExplanationParamsChange = async function() {
            localStorageService.set(LOCAL_STORAGE_EXPLANATION_PARAMS_KEY, $scope.explanationParams);
            computeAll($scope.bucket, $scope.getFeatures());

            $scope.sendBasicWT1Event();
        };

        $scope.sendBasicWT1Event = function() {
            WT1.event('interactive-scoring', {
                explanationParams: $scope.explanationParams,
                applyPreparationScript: $scope.uiState.applyPreparationScript
            })
        };

        $scope.onFeatureChange = Debounce().withDelay(200, 200).withScope($scope).wrap(onFeatureChange);	
        const computeScoreDebounced = Debounce().withDelay(200, 200).withScope($scope).wrap(computeScore);	
        const computeExplanationsDebounced = Debounce().withDelay(1000, 1000).withScope($scope).wrap(computeExplanations);

        function onFeatureChange() {
            if ($scope.allFeaturesEmpty()) {
                $scope.score = null;
                $scope.explanations = null;
            } else {
                $scope.outdatedExplanations = true;
                if (canCompute()) {
                    computeFeature(true);
                }
            }
        };

        async function computeFeature(withDebounce) {
            await startBackendIfNeeded();
            if (withDebounce) {
                computeScoreDebounced();
                if (!$scope.getExplanationIncompatibility()) {
                    computeExplanationsDebounced();
                }
            } else {
                computeScore();
                if (!$scope.getExplanationIncompatibility()) {
                    computeExplanations();
                }       
            }
        }
    });

})();

(function() {
'use strict';

const app = angular.module('dataiku.ml.report');


app.controller('DecisionTreeController', function($scope, DataikuAPI, $stateParams){
    DataikuAPI.ml.prediction.getTreeSummary($stateParams.fullModelId || $scope.fullModelId).success(function(data) {
        if($.isEmptyObject(data)){
             $scope.noTreesFound = true;
             return;
        }
        $scope.treeData = data;
    }).error(function() {
        $scope.uiState.noTreesFound = true;
        setErrorInScope.apply($scope, arguments);
    });
});


app.controller('TreeEnsembleController', function($scope, DataikuAPI, $stateParams, Throttle){
    //mild makeover to address stricter input[type=range] validation in ng1.6
    $scope.uiState = { i: -1, nTrees: 0, warningHidden: false, wasClipped: false, selectedPartition: $scope.uiState ? $scope.uiState.selectedPartition : null};

    $scope.setIndex = function(i){ $scope.uiState.i = i; };
    $scope.nextTree = function(){ if($scope.uiState.i < $scope.uiState.nTrees) $scope.uiState.i++; };
    $scope.previousTree = function(){ if($scope.uiState.i > 1) $scope.uiState.i--; };
    $scope.hideWarning = function(){ $scope.uiState.warningHidden = true;};

    var throttled = Throttle().withScope($scope).withDelay(500).wrap(function(){
        if($scope.uiState.i <= 0) return;
        $scope.currentTree = {
            featureNames: $scope.treeData.featureNames,
            tree: $scope.treeData.trees[$scope.uiState.i - 1]
        };
    });

    $scope.$watch('uiState.i', function(nv, ov){
        if (nv <= 0) return;
        throttled();
    });

    var p = DataikuAPI.ml.prediction.getEnsembleSummary($scope.uiState.selectedPartition || $stateParams.fullModelId || $scope.fullModelId).success(function(data) {
              if($.isEmptyObject(data)){
                 $scope.uiState.noTreesFound = true;
                 return;
              }
              $scope.treeData = data;
              $scope.uiState.i = 1;
              $scope.uiState.nTrees = data.trees.length;
              $scope.uiState.wasClipped = data.was_clipped;
    }).error(function() {
        $scope.uiState.noTreesFound = true;
        setErrorInScope.apply($scope, arguments);
    });

    if ($scope.noSpinner) p.noSpinner();// used by saved-model-report-insight-tile
});


app.directive('decisionTreeControl', function(FeatureNameUtils) {
    return {
        replace: true,
        templateUrl : '/templates/ml/prediction-model/tree_summary_view.html',
        scope: {
            data: '=',
            classes: '=',
            coreParams: '=',
            disableTransitions: "=?"
        },
        link : function($scope, element, attrs) {

            var i = 0;
            var duration = 200;
            var squareSize = 30;
            var linkWidth = function(proportion){ return 0.5 + 30 * proportion; };
            var diagonal = d3.svg.diagonal().projection(function(d){ return [d.x, d.y]; });

            var container = $(element[0]).find("#treeContainer svg");
            var svg = d3.select(element[0]).select("#treeContainer svg > g");

            var tree = d3.layout.tree();

            var height;
            var width;
            var nodeIntervalHeight = 100;

            var depth = function(node){
                if(node.children){
                    return 1 + Math.max(depth(node.children[0]), depth(node.children[1]));
                } else {
                    return 1;
                }
            };

            var computeDimensions = function(){
                height = nodeIntervalHeight * depth(root);
                width = container.width();
                tree.size([width, height]);
                container.height(height);
            };

            var argmax = function(a){
                var max = a[0];
                var arg = 0;
                for(var i = 1; i < a.length; i++){
                    if(a[i] > max){
                        arg = i;
                        max = arg;
                    }
                }
                return arg;
            };

            var root = {};
            var nodeColor = {};
            $scope.colors = {};

            var createNodeColor = function(root){
                var reduce = function(n, reducer, accessor){
                    if(n.children){
                        return reducer(reduce(n.children[0], reducer, accessor), reduce(n.children[1], reducer, accessor));
                    } else {
                        return accessor(n);
                    }
                };

                if(root.predict || root.predict == 0){
                    //regression
                    var acc = function(d){return d.predict;};
                    nodeColor = d3.scale.linear()
                                   .domain([reduce(root, Math.min, acc), root.predict, reduce(root, Math.max, acc)])
                                   .range(["blue","#f2f2f2","red"]);
                } else if(root.probabilities.length == 2) {
                    //binary classification
                    var acc = function(d){return d.probabilities[0];};
                    var scale = d3.scale.linear()
                                 .domain([reduce(root, Math.min, acc), root.probabilities[0], reduce(root, Math.max, acc)])
                                 .range(["blue","#f2f2f2","red"]);
                    nodeColor = function(probabilities){return scale(probabilities[0]);};
                    $scope.colors = function(c){
                        if(c == 0){
                            return "red";
                        } else {
                            return "blue";
                        }
                    };
                } else {
                    var nFeat = root.probabilities.length;
                    var globalScale = d3.scale.category10();
                    var localScales = [];
                    for(var i = 0; i<nFeat; i++){
                        var col = globalScale(i % 10);
                        //create linear scale between the smallest possible prob and the biggest found in tree
                        var acc = function(d){ return d.probabilities[i]; };
                        var local = d3.scale.linear()
                                    .domain([1.0/nFeat, Math.max(reduce(root, Math.max, acc), 0.001 + 1.0/nFeat)])
                                    .range(["#f2f2f2", col]);
                        localScales.push(local);
                    }
                    nodeColor = function(probabilities){
                       var winner = argmax(probabilities);
                       return localScales[winner](probabilities[winner]);
                    };
                    $scope.colors = function(c){ return globalScale(c % 10); };
                }
            };


            var createGradients = function(root){

                var makeArray = function(node){
                    var res = [];
                    if(node.children){
                        var left = makeArray(node.children[0]);
                        var right = makeArray(node.children[1]);
                        res = left.concat(right);
                    }
                    res.push({color: nodeColor(node.probabilities || node.predict)});
                    return res;
                };

                var gradients = svg.append("defs").selectAll("linearGradient").data(makeArray(root)).enter()
                                .append("linearGradient")
                                .attr("id", function(d){return "gradient-" + d.color;})
                                .attr("spreadMethod", "pad")
                                .attr("x1", "0%")
                                .attr("x2", "0%")
                                .attr("x1", "0%")
                                .attr("y2", "100%")
                                //.attr("y");

                gradients.append("stop")
                        .attr("offset", "0%")
                        .attr("stop-color", function(d){ return d.color; })
                        .attr("stop-opacity", 1);

                gradients.append("stop")
                        .attr("offset", "100%")
                        .attr("stop-color", "white")
                        .attr("stop-opacity", 0);
            };

            var updateNodeInformation = function(node, updateScope){
                if(node.probabilities){
                    $scope.probabilities = node.probabilities;
                    $scope.predict = $scope.classes[argmax[node.probabilities]];
                    $scope.currentNodeColor = nodeColor(node.probabilities);
                    $scope.targetClassesProportions = node.targetClassesProportions;
                } else {
                    $scope.predict = node.predict.toFixed(2);
                    $scope.currentNodeColor = nodeColor($scope.predict);
                }
                $scope.nSamples = node.nSamples;
                $scope.nSamplesWeighted = node.nSamplesWeighted;
                $scope.proportion = (node.proportion * 100).toFixed(2) + "%";
                $scope.proportionWeighted = (node.proportionWeighted * 100).toFixed(2) + "%";
                updateBreadcrumb(node);
                if(updateScope){
                    $scope.$apply();
                }
            };


            //create a (childless) node at the given index
            var nodify = function(data, index, maxSamples, maxSamplesWeighted){
                var node = {};
                var tree = data.tree;
                $scope.warningMessage = tree.warningMessage;
                if(tree.nSamples) {
                    node.nSamples = tree.nSamples[index];
                    node.proportion = tree.nSamples[index]/parseFloat(maxSamples);
                }
                node.impurity = tree.impurity[index];
                if(tree.nSamplesWeighted) {
                    node.nSamplesWeighted = tree.nSamplesWeighted[index];
                    node.proportionWeighted = tree.nSamplesWeighted[index]/parseFloat(maxSamplesWeighted);
                }
                if (node.proportionWeighted && !node.proportion) {
                    node.proportion = node.proportionWeighted;
                }
                if(tree.leftChild[index] > 0){
                    node.feature = data.featureNames[tree.feature[index]];
                    node.threshold = tree.threshold[index];
                }
                if(tree.probas){
                    node.probabilities = tree.probas[index];
                    if (tree.targetClassesProportions) {
                        node.targetClassesProportions = tree.targetClassesProportions[index];
                    }
                } else {
                    node.predict = tree.predict[index];
                }
                return node;
            };

            //build a (recursive) tree from the data, which will be used to display the graph
            var treeify = function(data, index){
                var index = typeof index !== 'undefined' ?  index : 0;
                var maxSamples = data.tree.nSamples ? data.tree.nSamples[0] : null;
                var maxSamplesWeighted = data.tree.nSamplesWeighted ? data.tree.nSamplesWeighted[0] : null;
                var result = nodify(data, index, maxSamples, maxSamplesWeighted);
                if(data.tree.leftChild[index] > 0){
                    var left = treeify(data, data.tree.leftChild[index]);
                    left.isLeftChild = true;
                    var right = treeify(data, data.tree.rightChild[index]);
                    right.isLeftChild = false;
                    result.children = [left, right];
                }
                return result;
            };

            var collapse = function(d, height) {
                if (d.children) {
                    if(height == 0){
                        d._children = d.children;
                        d._children.forEach( function(node){ collapse(node, 0); } );
                        d.children = null;
                    } else {
                        d.children.forEach(function(node){ collapse(node, height - 1); });
                    }
                }
            };

            const splitDescription = function(feature, threshold, isTrue){
                const result = {};
                const featureElements = FeatureNameUtils.getAsTextElements(feature);
                if (featureElements.type == "countvec") {
                    let level = featureElements.value;
                    if(level == ""){
                        level = 'empty';
                    }
                    result.left = featureElements.feature + " contains " + level;
                    result.right = threshold.toFixed(2) + " times";
                    result.operator = isTrue ? ' \u2264 ' : ' > ';
                } else if (featureElements.type == "tfidfvec") {
                    let level = featureElements.rawValue;
                    if(level == ""){
                        level = 'empty';
                    }
                    result.left = featureElements.feature + ": tfidf of " + level;
                    result.right = threshold.toFixed(2);
                    result.operator = isTrue ? ' \u2264 ' : ' > ';
                } else if(featureElements.value != null){
                    let level = featureElements.value;
                    if(level == ""){
                        level = 'empty';
                    }
                    result.left = featureElements.feature;
                    result.right = level;
                    if (featureElements.type === "hashing" && threshold < 0) {
                        // Categorical hashing adds a number of columns to the dataset. For each sample, the categorical
                        // feature is hashed to an int value between 0 and n_features-1; this hash value is used to select
                        // one of the additional column. A non null value is put in this column only: +1 is the feature
                        // hashes to + the hash value, -1 if the feature hashes to - the hash value. In the current case
                        // (threshold is -0.5), the tree splits the samples hashing to - the hash value (put in the left
                        // child node) and those not hashing to - the hash value (the right child node). In the else loop
                        // below (threshold is 0.5), the split separates the samples hashing to + the hash value (in the
                        // right node) to those not hashing to it.
                        result.operator = isTrue ? featureElements.operator : featureElements.no_operator;
                        result.right = "-" + result.right;
                    } else {
                        //note : for dummies, split will always have 0 on the left, ie when isTrue=true
                        result.operator = isTrue? featureElements.no_operator : featureElements.operator;
                    }
                } else {
                    result.left = featureElements.feature;
                    result.right = threshold.toFixed(2);
                    result.operator = isTrue ? ' \u2264 ' : ' > ';
                }
                return result;
            };

            //given a node and the child the function was called from, builds the breadcrumb element which
            //gave the decision leading to this child
            var buildBreadcrumb = function(node, from){
                var isTrue = node.children[0] == from;
                var bcElem = {rule : splitDescription(node.feature, node.threshold, isTrue)};
                if(node.parent){
                     var bc = buildBreadcrumb(node.parent, node);
                     bc.push(bcElem);
                     return bc;
                } else {
                    return [bcElem];
                }
            };

            //given a node, builds the breadcrumb of decision rules leading to this node
            var updateBreadcrumb = function(from){
                if(from.parent){
                var bc = buildBreadcrumb(from.parent, from);
                    $scope.breadcrumb = bc;
                } else {
                    $scope.breadcrumb = [];
                }
            }

            var expandAll = function(node, shouldUpdate){
                if(node._children){
                    node.children = node._children;
                    node._children = null;
                }
                if(node.children){
                    expandAll(node.children[0], false);
                    expandAll(node.children[1], false);
                }
                if(shouldUpdate){
                    update(node);
                }
            };

            $scope.expandAll = function(){ expandAll(root, true);};

            $scope.reset = function(){
                collapse(root, 3);
                update(root, true);
            };

            //get the data and do any dependent calculations
            $scope.$watch('data', function(){
                if($scope.data){
                    root = treeify($scope.data);
                    createNodeColor(root);
                    createGradients(root);
                    root.x0 = width/2;
                    root.y0 = 0;
                    collapse(root, 3);
                    updateNodeInformation(root, false);
                    update(root);

                    // Signal to Puppeteer that the content of the element has been loaded and is thus available for content extraction
                    $scope.puppeteerHook_elementContentLoaded = true;
                }
            });


            computeDimensions();

            //recompute the layout whenever window is resized
            d3.select(window).on("resize.dtc", function(){update();});

            var update = function(source, noAnimation) {

              var actualDuration = (noAnimation || ($scope.disableTransitions)) ? 0 : duration;

              computeDimensions();

              // Compute the new tree layout.
              var nodes = tree.nodes(root).reverse();
              var links = tree.links(nodes);

              var levelWidth = 10;

              // Normalize for fixed-depth.
              nodes.forEach(function(d) { d.y = d.depth * nodeIntervalHeight; });

              // Update the nodes…
              var node = svg.selectAll("g.node")
                  .data(nodes, function(d) { return d.id || (d.id = ++i); });

              // Enter any new nodes at the parent's previous position.
              var nodeEnter = node.enter().append("g")
                  .attr("class", "node")
                  .attr("transform", function(d) { return "translate(" + source.x0 + "," + source.y0 + ")"; })
                  .style("cursor", function(d){
                    if(d._children || d.children){
                        return "pointer";
                    } else {
                        return "default";
                    }
                  })
                  .on("click", click)
                  .on("mouseover", function(d){
                    updateNodeInformation(d, true);
                  });

              nodeEnter.append("rect")
                  .attr("width", "1px")
                  .attr("height", "1px")
                  .style("fill", function(d) {
                    return nodeColor(d.probabilities ? d.probabilities: d.predict);
                  });

              node.selectAll("text").remove();
              node.selectAll("rect.tree-text-backdrop").remove();
              node.selectAll("rect.edge-fade").remove();

              node.append("text")
                 .text(function(d) {
                     if(d.children){
                        var desc = splitDescription(d.feature, d.threshold, false);
                        return desc.left + " " + desc.operator + " " + desc.right;
                     } else {
                        return "";
                     }
                   })
                  .attr("text-anchor", function(d) { return d.children || d._children ? "middle" : "middle"; })
                  .attr("x", function(d){return d.children? 60: 15;})
                  .attr("y", function(d){return d.children? 80: 45;})
                  .call(function(selection){selection.each(function(d){d.bbox = this.getBBox();});});

              node.insert("rect", "text").classed("tree-text-backdrop", true)
                  .attr("x", function(d){return d.bbox.x; })
                  .attr("y", function(d){return d.bbox.y; })
                  .attr("width", function(d){return d.bbox.width;})
                  .attr("height", function(d){return d.bbox.height;})
                  .style("fill", "rgba(255,255,255,0.7)");

              node.filter(function(d){return d._children; })
                          .append("rect").classed("edge-fade", true)
                          //.attr("x", function(d){ return d.bbox.x;})
                          //.attr("y", function(d){ return d.bbox.y - 3;})
                          .attr("x", function(d){ return squareSize/2 - linkWidth(d.proportion)/2;})
                          .attr("y", function(d){ return squareSize;})
                          .attr("width", function(d){ return linkWidth(d.proportion); })
                          .attr("height", 20)
                          .style("fill", function(d){ return "url(#gradient-" + nodeColor(d.probabilities || d.predict) + ")"; })

              // Transition nodes to their new position.
              var nodeUpdate = node.transition()
                  .duration(actualDuration)
                  .attr("transform", function(d) { return "translate(" + (d.x - squareSize / 2.0) +
                  "," + (d.y - squareSize / 2) + ")"; });

              nodeUpdate.select("rect")
                  .attr("width", "30px")
                  .attr("height", "30px");
                 // .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

              nodeUpdate.select("text")
                  .style("fill-opacity", 1);

              // Transition exiting nodes to the parent's new position.
              var nodeExit = node.exit().transition()
                  .duration(actualDuration)
                  .attr("transform", function(d) { return "translate(" + source.x + "," + source.y + ")"; })
                  .remove();

              nodeExit.select("rect")
                  .attr("width", "1px")
                  .attr("height", "1px");

              nodeExit.select("text")
                  .style("fill-opacity", 1e-6);

              // Update the links…
              var link = svg.selectAll("path.link")
                  .data(links, function(d) { return d.target.id; });

              // Enter any new links at the parent's previous position.
              var linkEnter = link.enter().insert("path", "g")
                  .attr("class", "link")
                  .attr("d", function(d) {
                    var o = {x: source.x0, y: source.y0};
                    return diagonal({source: o, target: o});
                  })
                  .style("fill", "none")
                  .style("stroke", function(d){
                    return nodeColor(d.target.probabilities ? d.target.probabilities: d.target.predict);
                  })
                  .style("stroke-width", function(d){ return linkWidth(d.target.proportion);});

              // Transition links to their new position.
              link.transition()
                  .duration(actualDuration)
                  .attr("d", function(d){
                        var parentWidth = linkWidth(d.source.proportion);
                        var width = linkWidth(d.target.proportion);
                        var dy;
                        if(d.target.isLeftChild){
                            dy = (width - parentWidth) / 2;
                        } else {
                            dy = (parentWidth - width)/ 2;
                        }
                        var src = {x: d.source.x + dy, y: d.source.y};
                        var coords = {source: src, target: d.target};
                        return diagonal(coords);
                  });

              // Transition exiting nodes to the parent's new position.
              link.exit().transition()
                  .duration(actualDuration)
                  .attr("d", function(d) {
                    var o = {x: source.x, y: source.y};
                    return diagonal({source: o, target: o});
                  })
                  .remove();

              // Stash the old positions for transition.
              nodes.forEach(function(d) {
                d.x0 = d.x;
                d.y0 = d.y;
              });

            }

            // Toggle children on click.
            function click(d) {
              if (d.children) {
                d._children = d.children;
                d.children = null;
              } else {
                d.children = d._children;
                d._children = null;
              }
              update(d);
            }

           $scope.$on('$destroy', function(){
                d3.select(window).on('resize.dtc', null);
           });

        }
    };
});

})();

(function(){
'use strict';

var app = angular.module('dataiku.ml.report');


/**
 * Controller for displaying results screen of a clustering model,
 * either in a PMLTask or a PredictionSavedModel
 *
 * Requires: $stateParams.fullModelId or $scope.fullModelId
 *
 * Must be inserted in another controller.
 */
app.controller("_ClusteringModelReportController", function($scope, $controller, DataikuAPI, Debounce, $stateParams, ActivityIndicator, categoricalPalette, CMLFilteringService){
    $controller("_ModelReportControllerBase", {$scope:$scope});

    $scope.fetchModelDetails = function(){
        return DataikuAPI.ml.clustering.getModelDetails($stateParams.fullModelId || $scope.fullModelId).success(function(data){
            $scope.modelData = data;
            onModelLoaded();
            $scope._selectPane();

            if ($scope.mlTasksContext) $scope.mlTasksContext.model = data;
            if ($scope.smContext) $scope.smContext.model = data;

            // Signal to Puppeteer that the content of the element has been loaded and is thus available for content extraction
            $scope.puppeteerHook_elementContentLoaded = true;
        }).error(setErrorInScope.bind($scope));
    };

    if (!$scope.modelData) {
        var p = $scope.fetchModelDetails()
            .success(function() {
                if ($scope.onLoadSuccess) $scope.onLoadSuccess(); // used by saved-model-report-insight-tile
            })
            .error(function(data, status, headers, config, statusText) {
                if ($scope.onLoadError) $scope.onLoadError(data, status, headers, config, statusText);     // used by saved-model-report-insight-tile
            });

        if ($scope.noSpinner) p.noSpinner();
    }


    /* ************ Handling of save **************** */

    function saveMeta() {
        if ($scope.readOnly) return;
        DataikuAPI.ml.saveModelUserMeta($stateParams.fullModelId || $scope.fullModelId, $scope.modelData.userMeta).success(function(){
            ActivityIndicator.success("Saved")
        }).error(setErrorInScope.bind($scope));
    }

    var debouncedSaveMeta = Debounce().withDelay(400,1000).wrap(saveMeta);
    $scope.$watch("modelData.userMeta", function(nv, ov) {
        if (!nv || !ov) return;
        debouncedSaveMeta();
    }, true);

    var onModelLoaded = function(){
        const { clusterMetas } = $scope.modelData.userMeta;
        $scope.clusterMetasSize = 0;
        if (clusterMetas) {
            $scope.clusterMetasSize = Object.keys(clusterMetas).length;
        }
    };

    var generateClusterColor = function(clusterId, i){
        var algo = $scope.modelData.modeling.algorithm;
        if(algo == "PY_ISOLATION_FOREST" || algo == "MLLIB_ISOLATION_FOREST"){
            if(clusterId == "regular"){
                return "green";
            } else if (clusterId == "anomalies") {
                return "orange";
            }
        }
        return categoricalPalette(i);
    }

    $scope.getClusterMeta = function(clusterId) {
        const { clusterMetas } = $scope.modelData.userMeta;
        if (!clusterMetas) {
            return null;
        }
        if (clusterMetas[clusterId] === undefined) {
            clusterMetas[clusterId] = {
                "name": clusterId,
                "color": generateClusterColor(clusterId, $scope.clusterMetasSize),
            }
            $scope.clusterMetasSize += 1;
        }
        return clusterMetas[clusterId];
    };

    $scope.scatterParams = {};

    $scope.hasHierarchy = function(){
        return ['PY_TWO_STEP', 'MLLIB_TWO_STEP'].indexOf($scope.getAlgorithm()) > -1;
    };

    $scope.hasAnomalies = function(){
        return ['PY_ISOLATION_FOREST', 'MLLIB_ISOLATION_FOREST'].indexOf($scope.getAlgorithm()) > -1;
    };

    $scope.getMetricNameFromModel = CMLFilteringService.getMetricNameFromModel.bind(CMLFilteringService);
    $scope.getMetricValueFromModel = CMLFilteringService.getMetricValueFromModel.bind(CMLFilteringService);
});


app.controller("CMLReportTrainController", function($scope, CMLSettings, MLDiagnosticsService) {
    $scope.mti = $scope.modelData.trainInfo;
    $scope.reduce = $scope.modelData.preprocessing.reduce;
    $scope.outliers = angular.extend({}, $scope.modelData.preprocessing.outliers);
    $scope.outliers.nope = $scope.outliers.method === 'NONE';
    $scope.outliers.method = arr2obj(CMLSettings.task.outliersMethods)[$scope.outliers.method]
                                || $scope.outliers.method;
    $scope.diagnostics = MLDiagnosticsService.groupByType($scope.modelData.trainDiagnostics);
    $scope.isMLBackendType = function(mlBackendType) {
        return $scope.modelData.coreParams.backendType === mlBackendType;
    };

    $scope.canDisplayDiagnostics = function() {
        return true;
    };
});

app.controller("ClusterEditController", function($scope){
    $scope.$watch('meta', function(){
        if($scope.meta){
            $scope.details = {
                name: $scope.meta.name,
                description: $scope.meta.description,
                color: $scope.meta.color
            };
        }
    });
    $scope.confirm = function(){
        $scope.meta.name = $scope.details.name;
        $scope.meta.description = $scope.details.description;
        $scope.meta.color = $scope.details.color;
        $scope.dismiss();
        if($scope.callback) $scope.callback();
    };
});

app.controller("CMLModelFactsController", function($scope, $controller, $state, $stateParams, categoricalPalette, Dialogs, DataikuAPI, CreateModalFromTemplate, WT1) {
    $controller("_MLReportSummaryController", {$scope:$scope});
    $controller("EvaluationLabelUtils", {$scope:$scope});

    $scope.$watch("modelData", function(nv, ov) {
        if (nv) $scope.facts = nv.facts;
         main();
    });

    var computeObservations = function(clusterLabel) {
        var observations;
        for (var i = 0; i < $scope.facts.clusters.length; i++) {
            var cluster_facts = $scope.facts.clusters[i];
            if (cluster_facts.cluster == clusterLabel) {
                observations = cluster_facts.facts;
                break;
            }
        };
        if (observations) {
            // prepare for displaying as sentences:
            observations.forEach(function(obs){
                if (obs.type == 'numerical') {
                    // It does not make much sense to compare percentages if signs are opposite
                    obs.sameSign = obs.mean/obs.global_mean > 0;
                    if (obs.sameSign) {
                        obs.negative = obs.global_mean < 0;
                        obs.relative_diff = Math.abs((obs.mean-obs.global_mean) * 100 / obs.global_mean);
                        obs.polarity = (obs.mean > obs.global_mean)? 'greater' : 'smaller';
                    } else {
                        // no formatting?...
                    }
                } else if (obs.type == 'categorical') {
                    obs.polarity = (obs.current_ratio > obs.global_ratio)? 'greater' : 'smaller';
                }
            });
            return observations;
        }
    }

    var main =function(){
        if (!$scope.selectedCluster && $scope.facts.clusters.length) {
            $scope.selectCluster($scope.facts.clusters[0]);
        }
    };

    $scope.selectCluster = function(cluster) {
        $scope.selectedCluster = cluster;
        $scope.observations = computeObservations($scope.selectedCluster.cluster);
    };

    $scope.editClusterDetails = function(meta){
        WT1.event("clustering-facts-edit-node");
        CreateModalFromTemplate("/templates/ml/clustering-model/cluster-details-edit.html", $scope,
            "ClusterEditController", function(newScope){
            newScope.meta = meta;
        });
    };

    // Signal to Puppeteer that the content of the element has been loaded and is thus available for content extraction
    $scope.puppeteerHook_elementContentLoaded = true;
});

app.factory('ClusteringHeatmapUtils', function(ExportUtils){
    var utils = {};

    utils.numericalDiff = function(m1, m2, s1, s2, n1, n2){
        var denom = Math.sqrt(s1 * s1 / n1 + s2 * s2 / n2);
        if(denom == 0.0){
            return m1 > m2 ? 100.0 : (m1 < m2 ? -100.0 : 0.0); //maybe a bit too hardcore
        }
        return (m1 - m2)/denom;
    };

    utils.categoricalDiff = function(p1, p2, n1, n2){
        var denom = Math.sqrt((p1 * (1 - p1) / n1) + (p2 * (1 - p2) / n2))
        if(denom == 0.0){
            return p1 > p2 ? 100.0 : (p1 < p2 ? -100.0 : 0.0); //maybe a bit too hardcore
        }
        return (p1 - p2)/denom;
    };

    utils.exportStacked = function(scope, data){
        var columns = [];
        var exportData = [];
        for(var j = 0; j < data.cluster_labels.length; j++){
            var cluster = scope.getClusterMeta(data.cluster_labels[j]).name;
            columns.push({ name : cluster + "_feature", type : "string" });
            columns.push({ name : cluster + "_is_numeric_feature", type : "boolean" });
            columns.push({ name : cluster + "_global_mean", type : "double" });
            columns.push({ name : cluster + "_mean", type : "double" });
            columns.push({ name : cluster + "_global_std", type : "double" });
            columns.push({ name : cluster + "_std", type : "double" });
            columns.push({ name : cluster + "_relative_importance", type : "double" });

            var cluster_data = [];
            for(var i=0; i<data.num_names.length; i++){
                var global_avg = data.num_averages[i];
                var avg = data.cluster_num_averages[j][i];
                var std = data.cluster_num_std_devs[j][i];
                var global_std = data.num_std_devs[i];
                var diff = utils.numericalDiff(avg, global_avg, std, global_std,
                    data.cluster_sizes[j], data.total_size);
                cluster_data.push([data.num_names[i], true, global_avg, avg, global_std, std, diff]);
            }
            for(var i=0; i<data.cat_names.length; i++){
                for(var k=0; k<data.levels[i].length; k++){
                    var name = data.cat_names[i] + "=" + data.levels[i][k];
                    var prop = data.cluster_proportions[j][i][k];
                    var global_prop = data.proportions[i][k];
                    var diff = utils.categoricalDiff(prop, global_prop, data.cluster_sizes[j], data.total_size);
                    cluster_data.push([name, false, prop, global_prop, null, null, diff]);
                }
            }
            cluster_data.sort(function(a,b){
                var da = Math.abs(a[6]);
                var db = Math.abs(b[6]);
                if(da[6] < db[6]){
                    return 1;
                } else if(da[6] > db[6]){
                    return -1;
                } else {
                    return 0;
                }
            });
            for(var t = 0; t < cluster_data.length; t++){
                if(!exportData[t]){
                    exportData.push(cluster_data[t]);
                } else {
                    exportData[t] = exportData[t].concat(cluster_data[t]);
                }
            }
        }

        ExportUtils.exportUIData(scope, {
            name : "Stacked columns clustering report for " + scope.modelData.userMeta.name,
            columns : columns,
            data : exportData
        }, "Export stacked data");

    };

    utils.exportTabular = function(scope, data){
        var exportData = [];
        for(var j = 0; j < data.cluster_labels.length; j++){
            var cluster_label = scope.getClusterMeta(data.cluster_labels[j]).name;

            for(var i = 0; i < data.num_names.length; i++){
                var global_avg = data.num_averages[i];
                var avg = data.cluster_num_averages[j][i];
                var std = data.cluster_num_std_devs[j][i];
                var global_std = data.num_std_devs[i];
                var diff = utils.numericalDiff(avg, global_avg, std, global_std,
                    data.cluster_sizes[j], data.total_size);
                exportData.push([cluster_label, data.num_names[i], true, global_avg, avg, global_std, std, null, null, diff]);
            }

            for(var i = 0; i < data.cat_names.length; i++){
                for(var k = 0; k < data.levels[i].length; k++){
                    var name = data.cat_names[i] + "=" + data.levels[i][k];
                    var prop = data.cluster_proportions[j][i][k];
                    var global_prop = data.proportions[i][k];
                    var diff = utils.categoricalDiff(prop, global_prop, data.cluster_sizes[j], data.total_size);
                    exportData.push([cluster_label, name, false, null, null, null, null, prop, global_prop, diff]);
                }
            }
        }

        //sort by cluster, then absolute diff
        exportData.sort(function(v1, v2){
            if(v1[0] < v2[0]){
                return -1;
            } else if(v1[0] > v2[0]){
                return 1;
            } else {
                var d1 = Math.abs(v1[9]);
                var d2 = Math.abs(v2[9]);
                if(d1 < d2){
                    return 1;
                } else if(d1 > d2){
                    return -1;
                } else {
                    return 0;
                }
            }
        });

        ExportUtils.exportUIData(scope, {
            name : "Tabular clustering report for " + scope.modelData.userMeta.name,
            columns : [
                { name : "cluster_label", type : "string" },
                { name : "feature", type : "string" },
                { name : "is_numeric_feature", type : "boolean" },
                { name : "global_mean", type : "double" },
                { name : "mean", type : "double" },
                { name : "global_std", type : "double" },
                { name : "std", type : "double" },
                { name : "proportion", type : "double" },
                { name : "global_proportion", type : "double" },
                { name : "relative_importance", type : "double" }
            ],
            data : exportData
        }, "Export tabular data");
    };

    return utils;
});

app.controller('ClusteringHeatmapController', function($scope, Dialogs, ClusteringHeatmapUtils, CreateModalFromTemplate, WT1){
    var data = $scope.modelData.heatmap;

    $scope.clusters = data.cluster_labels;

    var square = function(x){return x*x};

    /* Feature selectors */
    var selectNum = function(index){
        for(var i=0; i<data.num_names.length; i++){
            $scope.featureIndex.push(index);
            $scope.featureInfo.push({numerical: true, name: data.num_names[i]});
            index++;
            var dat = [];
            for(var j = 0; j<data.cluster_labels.length; j++){
                var global_avg = data.num_averages[i];
                var avg = data.cluster_num_averages[j][i];
                var std = data.cluster_num_std_devs[j][i];
                var global_std = data.num_std_devs[i];
                var diff = ClusteringHeatmapUtils.numericalDiff(avg, global_avg, std, global_std,
                    data.cluster_sizes[j], data.total_size);
                dat.push({
                    avg: avg,
                    std: std,
                    global_std: global_std,
                    global_avg: global_avg,
                    diff: diff
                });
            }
            $scope.data.push(dat);
        }
        return index;
    };

    //create sorted index of categorical features, so that those with less levels come first, allowing
    //to select "categorical" in the view with less risks of a warning due to many levels.
    $scope.cat_names = [];
    for(var i = 0; i < data.cat_names.length; i++){
        $scope.cat_names.push({index: i, name: data.cat_names[i]});
    }
    $scope.cat_names.sort(function(a,b){
        var l1 = data.levels[a.index].length;
        var l2 = data.levels[b.index].length;
        if(l1 == l2) return 0;
        return l1 < l2 ? -1 : 1;
    });

    var selectCat = function(f, index){
        for(var lev=0; lev<data.levels[f].length; lev++){
            $scope.featureIndex.push(index);
            $scope.featureInfo.push({numerical: false, name: data.cat_names[f] + "=" + data.levels[f][lev]});
            index++;
            var dat = [];
            for(var c=0; c<data.cluster_labels.length; c++){
                var prop = data.cluster_proportions[c][f][lev];
                var global_prop = data.proportions[f][lev];
                var diff = ClusteringHeatmapUtils.categoricalDiff(prop, global_prop, data.cluster_sizes[c], data.total_size);
                dat.push({
                    proportion: prop,
                    global_proportion: global_prop,
                    diff: diff,
                });
            }
            $scope.data.push(dat);
        }
        return index;
    };

    var selectAllCat = function(index){
        for(var f=0; f<data.cat_names.length; f++){
            index = selectCat(f, index);
        }
        return index;
    };

    var init = function(){
        $scope.selectedFeature = -1;
        $scope.selectedCluster = -1;
        $scope.featureIndex = [];
        $scope.data = [];
        $scope.featureInfo = [];
    };

    var createColors = function(){
        var max = 0;
        for(var i=0; i < $scope.data.length; i++){
            for(var j=0; j<$scope.data[i].length; j++){
                var a = Math.abs($scope.data[i][j].diff);
                if(a > max){
                    max = a;
                }
            }
        }
        var globalScale = d3.scale.linear().domain([-max, -10.0, -2.0, 0.0, 2.0, 10.0, max])
                                           .range(['#4285f4','#92abf9','#ccd4fc','#ffffff','#fbbab2','#ea746a','#ce1329']);
        $scope.getElementColor = function(fi, ci){
            return globalScale($scope.data[fi][ci].diff);
        };
    }

    var totalFeatures = data.num_names.length;
    for(var i=0; i<data.levels.length; i++){
        totalFeatures += data.levels[i].length;
    }
    var featureLimit = 100;

    $scope.selectAllFeatures = function(){
        var selection = function(){
            var index = 0;
            init();
            index = selectNum(index);
            selectAllCat(index);
            $scope.selectionMode = "ALL";
            createColors();
        };
        if(totalFeatures > featureLimit){
            Dialogs.confirm($scope, 'View all','There are ' + totalFeatures
            + ' features, viewing them all may cause poor performance.').then(selection);
        } else {
            selection();
        }
    };

    $scope.selectOnlyNumeric = function(){
        init();
        selectNum(0);
        $scope.selectionMode = "NUMERIC";
        createColors();
    };

    $scope.selectSpecificCat = function(f){
        var selection = function(){
            init();
            selectCat(f, 0);
            $scope.selectedCategorical = f;
            $scope.selectionMode = "CAT";
            createColors();
        };
        var nLevels = data.levels[f].length;
        if(nLevels > featureLimit){
            Dialogs.confirm($scope, 'View categorical feature','There are ' + nLevels
            + ' categories, viewing them all may cause poor performance.').then(selection);
        } else {
            selection();
        }

    };

    /* Instantiate indices */
    $scope.clusterIndex = [];
    for(var i =0; i<$scope.clusters.length; i++){
        $scope.clusterIndex.push(i);
    }

    //if too many features we only show numerical by default
    if(totalFeatures > featureLimit){
        $scope.selectOnlyNumeric();
    } else {
        $scope.selectAllFeatures();
    }


    $scope.selectedCluster = -1;
    $scope.selectedFeature = -1;

    /* offset functions for moving labels */

    $scope.tableWidth = 50 * $scope.clusters.length;
    $scope.additionalWidth = 0;
    if ($scope.tableWidth > 400) {
        $scope.additionalWidth = 220; // Leave some space at the end for the tooltip;
    }

    $scope.clusterOffset = function(){
        return - ($scope.selectedFeature == -1 ? 0 : (50 * $scope.featureIndex.indexOf($scope.selectedFeature)));
    };

    $scope.featureOffset = function(){
        return $scope.selectedCluster == -1 ? 0 : (50 * $scope.clusterIndex.indexOf($scope.selectedCluster) + 1);
    };

    /* Line/column sorting */

    $scope.sortDescending = true;

    $scope.sortFeatures = function(index){
        if(index != $scope.selectedCluster){
            $scope.sortDescending = true;
        } else {
            $scope.sortDescending = !$scope.sortDescending;
        }
        $scope.selectedCluster = index;
        $scope.selectedFeature = -1;
        $scope.featureIndex.sort(function(i, j){
            var x1 = Math.abs($scope.data[i][index].diff);
            var x2 = Math.abs($scope.data[j][index].diff);
            if(x1 == x2){
                return 0;
            } else {
                var s = x1 < x2 ? 1 : -1;
                return $scope.sortDescending ? s : -s;
            }
        });
    };

    $scope.sortClusters = function(index){
        if(index != $scope.selectedFeature){
            $scope.sortDescending = true;
        } else {
            $scope.sortDescending = !$scope.sortDescending;
        }
        $scope.selectedFeature = index;
        $scope.selectedCluster = -1;
        $scope.clusterIndex.sort(function(i, j){
            var x1 = Math.abs($scope.data[index][i].diff);
            var x2 = Math.abs($scope.data[index][j].diff);
            if(x1 == x2){
                return 0;
            } else {
                var s = x1 < x2 ? 1 : -1;
                return $scope.sortDescending ? s : -s;
            }
        });
    };

    $scope.reset = function(){
        $scope.selectedFeature = -1;
        $scope.selectedCluster = -1;

        var ftSize = $scope.featureIndex.length;
        $scope.featureIndex = [];
        for(var i =0; i<ftSize; i++){
            $scope.featureIndex.push(i);
        }

        $scope.clusterIndex = [];
        for(var i =0; i<$scope.clusters.length; i++){
                $scope.clusterIndex.push(i);
        }
    }

    $scope.editClusterDetails = function(ci){
        WT1.event("clustering-heatmap-edit-node");
        CreateModalFromTemplate("/templates/ml/clustering-model/cluster-details-edit.html", $scope,
            "ClusterEditController", function(newScope){
            newScope.meta = $scope.getClusterMeta($scope.clusters[ci]);
        });
    };

    /* Tooltips */

    var greyScale = d3.scale.linear().domain([-2, 0, 2]).range(["blue", "grey", "red"]);
    $scope.tooltipHtml = function(fi, ci) {
        var cluster = $scope.getClusterMeta($scope.clusters[ci]).name;
        var info = $scope.featureInfo[fi];

        var html = '<strong>Cluster: </strong>' + sanitize(cluster) + '<br/>' + '<strong>Feature: </strong>'  + sanitize(info.name) + '<br/>';

        var d = $scope.data[fi][ci];
        var diff = null;
        if(info.numerical){
            diff = (d.avg - d.global_avg)/d.global_avg;
        } else {
            diff = (d.proportion - d.global_proportion)/d.global_proportion;
        }
        var sign = diff > 0.0 ? '+' : '';
        var color = greyScale(diff);
        if(info.numerical){
            var stdDiff = (d.std - d.global_std)/d.std;
            var stdColor = greyScale(stdDiff);
            var stdSign = d.std > d.global_std ? '+' : '';
            html += '<strong>Average:</strong> ' + d.avg.toFixed(2) + '<em>(' + d.global_avg.toFixed(2) +
                " globally, <span style='color: " + color + "'>" + sign + (diff * 100).toFixed(2) + '%</span>)</em><br/>';
            html += '<strong>Std. Dev.:</strong> ' + d.std.toFixed(2) + '<em>(' + d.global_std.toFixed(2) +
                " globally, <span style='color: " + stdColor + "'>" + stdSign + (stdDiff * 100).toFixed(2) + '%</span>)</em>';
        } else {
            html += "<strong>" + (d.proportion * 100).toFixed(2) + "% of cluster <em>(" + (d.global_proportion * 100).toFixed(2) +
                "% globally, <span style='color: " + color + "'>" + sign + (diff * 100).toFixed(2) + '%</span>)</em>';
        }

        return "<div style='position: relative; background: white; z-index: 5'>" + html + '</div>';
    };

    /* Exports */

    $scope.exportTabular = function(){ClusteringHeatmapUtils.exportTabular($scope, data);};
    $scope.exportStacked = function(){ClusteringHeatmapUtils.exportStacked($scope, data);};

    // Signal to Puppeteer that the content of the element has been loaded and is thus available for content extraction
    $scope.puppeteerHook_elementContentLoaded = true;
    $scope.puppeteerPrepareForExport = function() {
        $scope.modelDocumentExport = true;
        $scope.$apply();
    }

});

app.directive('sortableHeatmap', function(){
    return {
        template: "<div id='content'></div>",
        scope:  {
            data: "=data"
        },
        link: function(scope, element){
            var width = 800;
            var height = 800;
            var tileSize = 50;
        }
    }
});

    (function() {

    var BRICK_STRIDE = 24;
    var BRICK_WIDTH = 22;
    var BRICK_MARGIN_TOP = 15;
    var BRICK_MAX_HEIGHT = 120;
    var LEFT_MARGIN_TO_CHART = 66;
    var RIGHT_MARGIN = 10;
    var possibleNumberOfBricks = [5, 6, 10, 12, 15, 20, 30, 60];

    app.directive("stackedHistograms", function(categoricalPalette, Dialogs, CreateModalFromTemplate, WT1) {
        return {
            restrict: 'E',
            templateUrl : '/templates/ml/clustering-model/cluster-profiling-stacked.html',
            link: function(scope, element) {
                scope.profilingUI = {profilingMode: 'average', variables: [], selectedVariable: null};

                var refresh = function() {
                    scope.profilingUI.variables = scope.modelData.clustersProfiling;
                    if (scope.profilingUI.selectedVariable) {
                        var found = false;
                        for(var k in scope.profilingUI.variables) {
                            var v = scope.profilingUI.variables[k];
                            if(v.variable == scope.profilingUI.selectedVariable.variable) {
                                scope.profilingUI.selectedVariable = v;
                                found = true;
                                break;
                            }
                        }
                        if(!found) {
                            scope.profilingUI.selectedVariable = null;
                        }
                    }
                };

                scope.$watch('profilingUI.profilingMode', refresh, true);

                scope.hover = {"id": -1};

                scope.editClusterDetails = function(meta){
                    WT1.event("clustering-profiling-edit-node");
                    CreateModalFromTemplate("/templates/ml/clustering-model/cluster-details-edit.html", scope,
                        "ClusterEditController", function(newScope){
                        newScope.meta = meta;
                    });
                };

                scope.$watch('modelData',function(nv, ov) {
                    refresh();
                    if(nv!=null && !scope.profilingUI.selectedVariable && scope.profilingUI.variables.length>0) {
                        scope.profilingUI.selectedVariable = scope.profilingUI.variables[0];
                    }
                });

                scope.categoricalPalette = categoricalPalette;

                var brickDataNumerical = function(per_cluster_data, nbBricks) {
                    if (per_cluster_data.distribution === undefined) {
                        return undefined;
                    }
                    var brickData = [];
                    for (var i = 0; i < nbBricks; i++) {
                        brickData.push({
                            x: LEFT_MARGIN_TO_CHART + BRICK_STRIDE * i,
                            y: 0
                        });
                    };
                    var groupSize = 60 / nbBricks;
                    for (var i = 0; i < 60; i++) {
                        var bucketId = (i / groupSize) | 0;
                        brickData[bucketId].y += per_cluster_data.distribution[i];
                    }
                    for (var i = 0; i < brickData.length; i++) {
                        var ratio = brickData[i].y / per_cluster_data.total_no_nan;
                        scope.max_ratio = Math.max(ratio, scope.max_ratio);
                        brickData[i].ratio = ratio;
                    };
                    return brickData;
                }

                var brickDataCategorical = function(per_cluster_data, nbBricks) {
                    if (per_cluster_data.distribution === undefined) {
                        return undefined;
                    }
                    var brickData = [];
                    var nbBricks = Math.min(nbBricks, per_cluster_data.distribution.length);
                    for (var i = 0; i < nbBricks; i++) {
                        var p = per_cluster_data.distribution[i];
                        scope.max_ratio = Math.max(scope.max_ratio, p.ratio);
                        brickData.push({
                            x: LEFT_MARGIN_TO_CHART + BRICK_STRIDE * i,
                            y: p.count,
                            ratio: p.ratio,
                        });
                    };
                    return brickData;
                }

                var aggregateData = function() {
                    if (!scope.profilingUI.selectedVariable.global) return;

                    scope.max_ratio = 0.;
                    var W = element.find(".right-area").first().innerWidth();
                    var maxNbBricks = (W - LEFT_MARGIN_TO_CHART - RIGHT_MARGIN) / 24.0;
                    var nbBricks = 5;

                    for (var i = 0; i < possibleNumberOfBricks.length; i++) {
                        var nbBricksCandidate = possibleNumberOfBricks[i];
                        if (maxNbBricks >= nbBricksCandidate) {
                            nbBricks = nbBricksCandidate;
                        }
                        else {
                            break;
                        }
                    };

                    var makeBrickData = {
                        "numerical": brickDataNumerical,
                        "categorical": brickDataCategorical
                    }[scope.profilingUI.selectedVariable.type];

                    scope.profilingUI.selectedVariable.global.brickData = makeBrickData(scope.profilingUI.selectedVariable.global, nbBricks);
                    for (var k = 0; k < scope.profilingUI.selectedVariable.per_cluster.length; k++) {
                        var per_cluster_data = scope.profilingUI.selectedVariable.per_cluster[k];
                        per_cluster_data.brickData = makeBrickData(per_cluster_data, nbBricks);
                    };

                    scope.profilingUI.selectedVariable.scale.max_ratio = scope.max_ratio;
                }

                scope.$watch("profilingUI.selectedVariable", aggregateData);


                scope.$on("reflow", aggregateData);
                $(window).on("resize", aggregateData);

                scope.$on("$destroy", function() {
                    $(window).off("resize", aggregateData);
                });
            }
        }

    })


    function horizontalLine(x1, x2) {
        return "M" + x1 + "," + 0 + "L" + x2 + "," + 0;
    }

    function whiskerPlot(g, whiskerData, xScale) {
        var height = 18;
        var halfHeight = height / 2;
        var median = whiskerData.median;
        var whiskerPlot = g.append("g")
            .attr("class", "whiskerPlot")
            .attr("transform", "translate(0," + halfHeight + ")")
        whiskerPlot.append("path")
                   .attr("d", horizontalLine(xScale(whiskerData.percentile9), xScale(whiskerData.percentile91)));
        whiskerPlot.append("rect")
                   .attr("x", xScale(whiskerData.percentile25))
                   .attr("y", -halfHeight)
                   .attr("width", Math.max(2, xScale(whiskerData.percentile75) - xScale(whiskerData.percentile25)) )
                   .attr("height", height)
                   .attr("rx", 6)
                   .attr("ry", 4);
        whiskerPlot.append("circle")
            .attr("cx", xScale(whiskerData.percentile9))
            .attr("cy", 0)
            .attr("r", 2)
        whiskerPlot.append("circle")
            .attr("cx", xScale(whiskerData.percentile91))
            .attr("cy", 0)
            .attr("r", 2)
        whiskerPlot.append("circle")
            .attr("cx", xScale(whiskerData.median))
            .attr("cy", 0)
            .attr("r", 2)
        return whiskerPlot;
    };

    app.directive("bzHistogram", function() {
        return {
            restrict: 'E',
            template: '<svg>\
                \
                <defs>\
                <pattern id="diagonalHatch" patternUnits="userSpaceOnUse" width="8" height="8">\
                    <path d="M-2,2 l4,-4 M0,8 l8,-8 M6,10 l4,-4" stroke="#feffff" stroke-width="1.5"></path>\
                </pattern>\
            </defs>\
            <g id="chart"></g>\
            <rect class="stripe" style="fill: url(#diagonalHatch)"></rect>\
            </svg>',
            scope: {
                data: '=data',
                color: '=color',
                scale: '=scale',
                categorical: '=categorical',
                showScale: '=showScale',
                hover: '=hover',
                whiskerData: '=whiskerData',
                nbBricks: '=nbBricks',
            },
            link: function(scope, element) {
                var svg = d3.select(element[0]).select("svg");
                var yScale, xScale;
                var refreshHistogram = function() {

                    if ((scope.data === undefined) || (scope.data.length == 0)) {
                        return;
                    }

                    xScale = d3
                        .scale
                        .linear()
                        .range([0, BRICK_STRIDE * scope.data.length])
                        .domain([scope.scale.min, scope.scale.max])

                    yScale = d3
                        .scale
                        .linear()
                        .domain([0, scope.scale.max_ratio])
                        .range([BRICK_MAX_HEIGHT, 0]);

                    scope.hover.id = -1;
                    scope.W = element.width();
                    scope.max_ratio = scope.scale.max_ratio;

                    var brickNodes = svg
                        .select("#chart")
                        .selectAll("rect.brick")
                        .data(scope.data)

                    brickNodes
                        .exit().remove()

                    brickNodes.enter()
                        .append("rect")
                        .attr('fill', scope.color)
                        .attr("width", BRICK_WIDTH)
                        .attr("class", "brick")
                        .attr("height", function(val) {
                            return  BRICK_MAX_HEIGHT - yScale(val.ratio);
                        })
                        .on("mouseover", function(val, hoverId) {
                            scope.hover.id = hoverId;
                            scope.$apply();
                        })

                    brickNodes
                        .attr("x", function(val) { return val.x; })
                        .attr('fill', scope.color)
                        .attr("y", function(val) {
                            return BRICK_MARGIN_TOP + yScale(val.ratio);
                        })
                        .attr("height", function(val) {
                            return  BRICK_MAX_HEIGHT - yScale(val.ratio);
                        })

                    scope.hover.id = -1;
                    updateHover();

                    svg.select("g.whisker-container").remove();
                    var whiskerContainer = svg
                       .append("g")
                       .attr("class", "whisker-container")
                       .attr("transform", "translate(" + LEFT_MARGIN_TO_CHART + ", " + (BRICK_MAX_HEIGHT + (scope.showScale ? 35: 15) + BRICK_MARGIN_TOP + 8) + ")")

                        var yAxis = d3.svg
                            .axis()
                            .scale(yScale)
                            .ticks(3)
                            .orient("left")
                            .tickFormat(function(d) { return (d*100 | 0) + "%"; });
                        svg.select("g.yaxis").remove();
                        svg.append("g")
                           .attr("class", "yaxis")
                           .attr("transform", "translate(" + (LEFT_MARGIN_TO_CHART - 26) + ", " + BRICK_MARGIN_TOP + ")")
                           .call(yAxis);

                    svg.select("g.xaxis").remove();
                    var svgAxis = svg.append("g")
                       .attr("class", "xaxis")
                       .attr("transform", "translate(" + LEFT_MARGIN_TO_CHART  + ", " + (BRICK_MAX_HEIGHT + BRICK_MARGIN_TOP + 7) + ")")

                    if (scope.categorical) {
                        if (scope.showScale) {
                        svgAxis
                        .selectAll("text.histogram-label")
                        .data(scope.scale.categories)
                        .enter()
                            .append("text")
                            .attr("class", "histogram-label")
                            .text(function(d) { return d; })
                            .attr("text-anchor", "end")
                            .attr("transform", function(data, i) {
                                var rotation = "rotate(-45) ";
                                var x = 13 + BRICK_STRIDE * i;
                                var y = 0;
                                var translation = "translate(" +  x + "," + y + ")";
                                return translation + rotation;
                            })
                        }
                        svgAxis.append("line")
                                .attr("x1", "0")
                                .attr("y1", "-6")
                                .attr("x2", BRICK_STRIDE * scope.data.length)
                                .attr("y2", "-6")
                                .attr("stroke", "black")
                                .attr("shape-rendering", "crispEdges")

                    } else {
                        whiskerPlot(whiskerContainer, scope.whiskerData, xScale)
                        var xAxis = d3.svg
                            .axis()
                            .scale(xScale)
                            .ticks(3)
                            .orient("bottom");
                        if (!scope.showScale) {
                            svgAxis.attr("class", "xaxis hide-labels");
                        }
                        svgAxis.call(xAxis);
                    }
                }

                function updateHover() {
                    svg.select('rect.stripe')
                       .attr("height", 0)
                       .attr("width", 0)
                    if ((scope.hover.id !== undefined) && (scope.hover.id >= 0) && (scope.data !== undefined) && (scope.hover.id < scope.data.length)) {
                        var val = scope.data[scope.hover.id];
                        if (val != undefined) {
                            svg.select('rect.stripe')
                               .attr("x", val.x)
                               .attr("y", BRICK_MARGIN_TOP + yScale(val.ratio))
                               .attr("height", BRICK_MAX_HEIGHT - yScale(val.ratio))
                               .attr("width", BRICK_WIDTH)
                        }
                    }
                }

                scope.$watch("data", refreshHistogram);
                scope.$watch("hover", updateHover, true);
            }
        }
    })
    })();

    app.directive('clusteringScatterControl', function(Assert, DataikuAPI, $filter,$stateParams) {
        return {
            scope : {
                result : '=',
                getClusterMeta: '=getClusterMeta',
                fullModelId : '=',
                params: '='
            },
            templateUrl : '/templates/ml/clustering-model/scatterplot.html',
            link : function($scope, element) {
                $scope.scatterShowOutliers = true;
                $scope.waiting = true;
                Assert.inScope($scope, 'result');
                Assert.trueish($scope.result.perf, 'No performance metrics');

                $scope.refreshForm = function() {
                    $scope.scatterVars = arrayDedup($.grep($scope.result.perf.cluster_description, function(elt) {
                        // Remove the "fake" variable cluster_size
                        return elt.variable != 'cluster_size';
                    })
                    .map(function(x) {
                        // Keep only variable names
                        return x.variable;
                    })
                    // Add the generated variables (PCA components)
                    .concat($scope.result.perf.reduce_vars));
                    if (($scope.params.scatterVar1 === undefined) && ($scope.params.scatterVar2 === undefined)) {
                        if ($scope.result.perf.reduce_vars.length >= 2) {
                          $scope.params.scatterVar1 = $scope.result.perf.reduce_vars[0];
                          $scope.params.scatterVar2 = $scope.result.perf.reduce_vars[1];
                        }
                        else {
                          $scope.params.scatterVar1 = $scope.scatterVars[Math.min(1,$scope.scatterVars.length-1)];
                          $scope.params.scatterVar2 = $scope.scatterVars[0];
                        }
                    }

                };

                $scope.refreshGraph = function() {
                    $scope.waiting = true;
                    DataikuAPI.ml.clustering.getScatterPlot($stateParams.projectKey,$scope.fullModelId, $scope.params.scatterVar2, $scope.params.scatterVar1).success(function(data) {
                      $scope.scatterData = data.points;
                      $scope.waiting = false;
                    }).error(function(data,status,headers){
                          setErrorInScope.bind($scope)(data, status, headers);
                          $scope.waiting = false;
                     });
                }
                $scope.$watch("runId", function(nv, ov) {
                    $scope.refreshForm();
                    $scope.refreshGraph();
                });
                $scope.$watch("params", $scope.refreshGraph.bind($scope), true);
            }
        }
    });

    app.directive('scatterClusterPlot', function($timeout)  {
        return {
            scope: {
                data: "=",
                axisX : '=',
                axisY : '=',
                showOutliers: '=',
                getClusterMeta: '=getClusterMeta'
            },
            template : '<svg />',
            link: function(scope, element) {

                var tooltip;

                function redrawAll() {
                    $timeout(function() {
                        var svg = element.find("svg").get(0);
                        $(svg).empty();

                        var width = $(element).width();
                        var height = $(element).height();

                        scope.chart = DKUCharts.basicChart(width, height)

                        scope.g = scope.chart.makeTopG(d3.select(svg));
                        updateData();
                    })
                }

                function updateData() {
                    var data = scope.values;
                    var g = scope.g;
                    var chart = scope.chart;

                    var xmin = Infinity, xmax = -Infinity, ymin = Infinity, ymax = -Infinity
                    for (var idx in data) {
                        xmin = Math.min(xmin, data[idx].x)
                        xmax = Math.max(xmax, data[idx].x)
                        ymin = Math.min(ymin, data[idx].y)
                        ymax = Math.max(ymax, data[idx].y)
                    }

                    var axX = scope.axisX;
                    var axY = scope.axisY;

                    var xAxis = d3.svg.axis().scale(chart.xscale).orient("bottom").ticks(10); // axes
                    var yAxis = d3.svg.axis().scale(chart.yscale).orient("left").ticks(10);

                    //var g = d3.select('#chart svg')

                    chart.xscale.domain([xmin, xmax]); // ok domain of axes xmin, max calculated in watch
                    chart.yscale.domain([ymin, ymax]);

                    // X axis and ticks
                    g.append("g")
                    .attr("class", "x axis") // x axis
                    .attr("transform", "translate(0," + chart.height + ")") // reverse it so it's ok i guess
                    .call(xAxis)
                    .append("text")
                    .attr("class", "label")
                    .attr("x", chart.width)
                    .attr("y", -6)
                    .style("text-anchor", "end")
                    .text(axX);
                    // Y axis and ticks
                    g.append("g")
                    .attr("class", "y axis")
                    .call(yAxis)
                    .append("text")
                    .attr("class", "label")
                    .attr("transform", "rotate(-90)")
                    .attr("y", 6)
                    .attr("dy", ".71em")
                    .style("text-anchor", "end")
                    .text(axY) // <--------------------------------------- can i have good text here ?

                    DKUCharts.drawGrid(g, chart.xscale, chart.yscale, chart.width, chart.height); // i'm gonna trust this one

                     $('.regression-scatter-plot-tooltip').remove();

                    var color = d3.scale.category10().domain(d3.range(0,10));

                    //tooltip
                    $('.regression-scatter-plot-tooltip').remove();
                    tooltip = d3.select("body").append("div")
                                .attr("class", "regression-scatter-plot-tooltip").style("left", "0").style("top", "0")
                                .style("opacity", 0)
                                .style("pointer-events", "none");

                    g.selectAll(".dot")
                    .data(data)
                    .enter().append("circle")
                    .attr("r", 3)
                    .attr("cx", function(d) { return chart.xscale(d.x) })
                    .attr("cy", function(d) { return chart.yscale(d.y) })
                    .style("fill", function(d) { return scope.getClusterMeta(d.cluster).color; })
                    .on("mouseover", function(d) {
                        var col = scope.getClusterMeta(d.cluster).color;
                        tooltip.transition()
                        .duration(300)
                        .style("opacity", 1);
                    tooltip.html("<table><tr><td>Cluster</td><th>{0}</th></tr><tr><td>{3}</td><th>{1}</th></tr><tr><td>{4}</td><th>{2}</th></tr></table>"
                        .format(sanitize(scope.getClusterMeta(d.cluster).name), sanitize(d.x), sanitize(d.y), sanitize(axX), sanitize(axY) ))
                        .style("left", (d3.event.pageX) + "px")
                        .style("top", (d3.event.pageY - 28) + "px")
                        .style("border",  "2px " + col + " solid");
                        })
                    .on("mouseout", function(d) {
                        tooltip.transition()
                        .duration(300)
                        .style("opacity", 0);
                    });
                    // Signal to Puppeteer that the content of the element has been loaded and is thus available for content extraction
                    scope.puppeteerHook_elementContentLoaded = true;
                }

                scope.$watch("[data, showOutliers]", function(nval, ov) {
                    if (nval[0] == null) return;
                    if (!scope.showOutliers){
                      scope.values = scope.data.filter(function(el) {
                          return el.cluster != 'cluster_outliers';
                      });
                    }
                    else {
                      scope.values = scope.data;
                    }
                    redrawAll();
                }, true);
                $(window).on('resize', redrawAll);
                scope.$on('$destroy', function() {
                    tooltip.remove();
                    $(window).off('resize', redrawAll);
                });
            }
        }
    });

    app.controller('ClusteringVariableImportanceController', function($scope, $filter, VariablesImportanceService, ExportUtils) {
        $scope.colors  = window.dkuColorPalettes.discrete[0].colors // adjascent colors are too similar
        .filter(function(c, i) { return i % 2 === 0; });        // take only even-ranked ones

        var arr = VariablesImportanceService.build($scope.modelData.perf.variables_importance, $scope.colors);
        $scope.importances = arr[0];
        $scope.fades = arr[1];
        $scope.unfilteredImportances = arr[2];
        $scope.exportImportance = function(){
            var f = $filter("mlFeature");
            var data = $scope.unfilteredImportances.map(function(x){
                return [x.r, x.v, x.i];
            });
            ExportUtils.exportUIData($scope, {
                name : "Variables importance for model:" + $scope.modelData.userMeta.name,
                columns : [
                    { name : "feature_name", type : "string"},
                    { name : "feature_description", type : "string"},
                    { name : "importance", type : "double"}
                ],
                data : data
            }, "Export variable importances");
        };
    });

    app.directive("heatGradient", function(){
        return {
                template: "<div class='heat-gradient'>" +
                            "<div id='text'><div>Low</div><div>High</div></div>" +
                            "<div id='gradient'></div></div>",
                replace: true,
                restrict: 'E'
            }
    })

    app.controller('AnomalyController', function($scope, DataikuAPI, $stateParams, $filter, Dialogs){
        $scope.features = null;
        $scope.data = null;
        $scope.index = 0;

        var cellScale = d3.scale.linear().domain([-3, 0, 3]).range(["#323dff", "#f2f2f2", "#e22828"]);

        //removes constant features
        var cleanData = function(data){
            var toKeep = [];
            var keepAll = true;
            for(var i = 0; i < data.averages.length; i++){
                if(data.standard_deviations[i] > 0.0){
                    toKeep.push(i);
                } else {
                    keepAll = false;
                }
            }
            if(!keepAll) {
                var prune = function(arr){
                    var newArr = [];
                    toKeep.forEach(function(i){newArr.push(arr[i]);});
                    return newArr;
                };
                for(i = 0; i < data.data.length; i++){
                    data.data[i] = prune(data.data[i]);
                }
                if(data.regular_data){
                    for(i = 0; i < data.regular_data.length; i++){
                        data.regular_data[i] = prune(data.regular_data[i]);
                    }
                }
                data.columns = prune(data.columns);
                data.averages = prune(data.averages);
                data.standard_deviations = prune(data.standard_deviations);
            }
        };

        var nVar = 0;
        var maxScore = 0;
        var scoreSd = 0;
        var computeScoreStats = function(scores){
            var scoreMean = 0;
            scores.forEach(function(s){
                scoreMean += s;
                scoreSd += s*s;
            });
            scoreMean /= scores.length;
            scoreSd /= scores.length;
            scoreSd = Math.sqrt(Math.max(0.0, scoreSd - scoreMean * scoreMean));
            if(scoreSd == 0.0){
                scoreSd = 1.0;
            }
            maxScore = Math.max.apply(Math, $scope.data.scores)
        };

        var columnIndex = [];
        var initColumnIndex = function(){
            var imps = $scope.modelData.perf.variables_importance;
            var importanceMapping = {}
            for(var i = 0; i < imps.variables.length; i++){
                importanceMapping[imps.variables[i]] = imps.importances[i];
            }
            for(i = 0; i < nVar; i++){
                columnIndex.push(i);
            }
            var importance = function(i){
                var fi = $scope.data.columns[i];
                if(fi in importanceMapping){
                    return importanceMapping[fi];
                } else {
                    return 0.0;
                }
            };
            columnIndex.sort(function(i, j){
                return importance(j) - importance(i);
            });
        }

        $scope.pagination = [];
        var pageSize = 10;
        var initPageSize = 20;
        var initPagination = function(){
            for(var i = 0; i < Math.min(initPageSize, nVar); i++){
                $scope.pagination.push(columnIndex[i]);
            }
        }

        $scope.seeMore = function(){
            var start = $scope.pagination.length;
            for(var i = start; i < Math.min(start + pageSize, nVar); i++){
                $scope.pagination.push(columnIndex[i]);
            }
        };

        $scope.isMore = function(){
            return $scope.pagination.length < nVar;
        }

        /* Handling of display-only features */
        var initExtra = function(){
            $scope.isExtra =  $scope.data.extra_profiling_columns !== undefined && $scope.data.extra_profiling_columns.length > 0;

            $scope.displayExtra = false;

            $scope.setDisplayExtra = function(b) {
                $scope.displayExtra = b;
            }
        }

        /* we use a (noncanonical) trick to renormalize dummies when computing the zScore. That way,
            we only have a positive z-score when the proba is < 1/nClasses (which makes sense).
            Could do something for negative z-scores, but it's not as bad at all.
        */
        var zScoreRenorm = [];
        var initRenorm = function(){
            var nCats = {};
            var cols = $scope.data.columns;
            for(var i = 0; i < nVar; i++){
                if(cols[i].startsWith("dummy")){
                    var els = cols[i].split(":");
                    var name = els[1];
                    if(name in nCats){
                        nCats[name] = nCats[name] + 1;
                    } else {
                        nCats[name] = 1;
                    }
                }
            }
            for(i = 0; i < nVar; i++){
                if(cols[i].startsWith("dummy")){
                    els = cols[i].split(":");
                    name = els[1];
                    zScoreRenorm.push(1.0 / nCats[name]);
                } else {
                    zScoreRenorm.push(1.0);
                }
            }
        };

        var init = function(){
            nVar = $scope.data.averages.length;
            computeScoreStats($scope.data.scores);
            initColumnIndex();
            initPagination();
            initRenorm();
            initExtra();
        }

        DataikuAPI.ml.clustering.getAnomalies($stateParams.fullModelId || $scope.fullModelId)
            .success(function(data) {
                var setData = function(){
                    cleanData(data);
                    $scope.data = data;
                    init();
                }
                var nCells = (data.data.length + 10) * pageSize;
                if(nCells > 10000){
                    Dialogs.confirm($scope,
                        "Large number of cells",
                        "The number of cells to display initially is very large (" + nCells + "). " +
                        "Displaying them all may lead to poor performance or even a browser crash. Do you wish to continue ?"
                        ).then(function(){
                            setData();
                        });
                } else {
                    setData();
                }



            });

        $scope.nIcons = function(i){
            var zScore = Math.abs((maxScore - $scope.data.scores[i]) / scoreSd);
            var n;
            if(zScore > 3){
                n = 5;
            } else if(zScore > 2) {
                n = 4;
            } else if(zScore > 1.5) {
                n = 3;
            } else if(zScore > 1) {
                n = 2;
            } else {
                n = 1;
            }
            return new Array(n);
        };

        $scope.getCellColor = function(featureIndex, value){
            var zScore = (value * zScoreRenorm[featureIndex] - $scope.data.averages[featureIndex])/$scope.data.standard_deviations[featureIndex];
            return cellScale(zScore);
        };

        $scope.cleanValue = function(x){
            const asNumber = parseFloat(x)
            if (isNaN(asNumber)) {
                return x;
            } else {
                return $filter("smartNumber")(x)
            }
        }

        var namer = $filter("mlFeature");
        $scope.tooltipHtml = function(featureIndex, value){
            var avg = $scope.cleanValue($scope.data.averages[featureIndex]);
            value = $scope.cleanValue(value);
            return '<div><strong>' + sanitize(namer($scope.data.columns[featureIndex])) + '</strong>: ' + value + ' (vs. ' + avg + ' globally)' + '</div>';
        };


    });

})();

(function(){
'use strict';

var app = angular.module('dataiku.ml.report');


app.controller("CoefficientPathController", function($scope, DataikuAPI, $stateParams){

    $scope.data = [];
    $scope.uiModel = {dataIndex: 0};

    DataikuAPI.ml.prediction.getCoefPath($stateParams.fullModelId || $scope.fullModelId).success(function(data) {
       if($.isEmptyObject(data)){
            $scope.noPathFound = true;
            return;
       }

       if(! $scope.isRegression()){
            $scope.data = [];
            for(var i = 0; i < $scope.modelData.classes.length; i++){
                $scope.data.push(data.path.map(function(a){ return a[i];}))
            }
            $scope.selectedClass = $scope.modelData.classes[0];
            $scope.classes = $scope.modelData.classes;
            $scope.uiModel.dataIndex = 0;
       } else {
            $scope.data = [data.path.map(function(a){ return a.map(function(x){ return x[0]; });})];
       }
       $scope.features = data.features;
       $scope.currentIndex = data.currentIndex;
    }).error(setErrorInScope.bind($scope));

});

app.directive("coefficientPath", function(){
    return {
        replace: true,
        templateUrl : '/templates/ml/prediction-model/coef_path_view.html',
        scope: {
            data: '=',
            features: '=',
            currentIndex: '='
        },
        link : function($scope, element, attrs) {

           $scope.slide = 300;
           $scope.windowParams = { displayHelp: true };
           $scope.hideHelp = function(){ $scope.windowParams.displayHelp = false; };
           var slideUnwatch = function(){
            //will be initialized later
           };

            $scope.$watch('data', function(){

            slideUnwatch();

            var width = 700;
            var height = 400;
            d3.select(element[0]).select("#coef-path-container").attr("width", width).attr("height", height);
            var graphSvg = d3.select(element[0]).select("#graph");

            /* Compute the x-axis values for the chart. These are the relative norm of the corresponding vector to plot. */
            var xValues = [];
            var norm = 0.0;
            for(var i = 0; i < $scope.data[0].length; i++){
                var t = $scope.data[$scope.data.length - 1][i];
                norm += t * t;
            }
            for(i = 0; i < $scope.data.length; i++){
                var normI = 0.0;
                for(var j = 0; j < $scope.data[i].length; j++){
                    t = $scope.data[i][j];
                    normI += t * t;
                }
                xValues.push(Math.sqrt(normI / norm));
            }

            /* Compute an index for the slider. This maps the index of the slider to the corresponding cutoff index */
            var sliderIndex = (function(){
                var index = [];
                var currentMapped = 0;
                for(var i = 0; i <= 299; i++){
                    var x = i * 1.0 / 300;
                    if(x > xValues[currentMapped]){
                        currentMapped++;
                    }
                    index.push(currentMapped);
                }
                index.push(xValues.length - 1);
                return index;
            })();

            var nCoef = function(x){
                var n = 0;
                for(var i = 0; i < x.length; i++){
                    if(Math.abs(x[i]) > 1e-6){
                        n++;
                    }
                }
                return n;
            }

            /* Compute the points (normalized 0 to 1) at which there is a coefficient switch */
            var cutoffs = (function(){
                var res = [];
                var cur = nCoef($scope.data[0]);
                for(var i = 1; i < xValues.length; i++){
                    var n = nCoef($scope.data[i]);
                    if(n != cur){
                        cur = n;
                        res.push(xValues[i]);
                    }
                }
                return res;
            })();

            var updateSlider = function(){
                $scope.selectedIndex = sliderIndex[$scope.slide];
                $scope.coefs = $scope.data[$scope.selectedIndex];
                $scope.nCoefs = nCoef($scope.coefs);
            }

            /* Transpose the data so we have series. Note : we might want to do this beforehand to avoid data duplication ?*/
            var series = [];
            for(i = 0; i < $scope.data[0].length; i++){
                var arr = [];
                for(j = 0; j < $scope.data.length; j++){
                    arr.push($scope.data[j][i]);
                }
                series.push(arr);
            }

            var maxY = d3.max($scope.data.map(function(a){ return d3.max(a); }));
            var minY = d3.min($scope.data.map(function(a){ return d3.min(a); }));
            var y = d3.scale.linear().domain([minY, maxY]).range([0, height]);
            var x = d3.scale.linear().domain([0,1]).range([0, width]);

            $scope.coefWidth = function(c){
                return 35 * Math.abs(c) / Math.max(Math.abs(maxY), Math.abs(minY));
            };

            $scope.coefIndex = [];
            for(i = 0; i < $scope.data[0].length; i++){
                $scope.coefIndex.push(i);
            }
            $scope.coefIndex.sort(function(i, j){
                var t = $scope.data.length - 1;
                return Math.abs($scope.data[t][j]) - Math.abs($scope.data[t][i]);
            });

            var index = [];
            for(i = 0; i < $scope.data.length; i++){
                index.push(i);
            }

            $scope.selectedFeature = null;

            $scope.colorScales = d3.scale.category10();

            $scope.featureTextColor = function(i){
                return $scope.selectedFeature == null || $scope.selectedFeature == i ? $scope.colorScales(i) : 'rgba(0,0,0,0.25)';
            }

            $scope.mouseoverCurve = function(i, apply){
                $scope.selectedFeature = i;
                graphSvg.selectAll("path")
                        .filter(function(d){ return !(d[0].fake) && d[0].feature != i;})
                        .attr('stroke-opacity', 0.25)
                        .attr('stroke', "black");
                if(apply){
                    $scope.$apply();
                }
            };

            $scope.mouseoutCurve = function(i, apply){
                $scope.selectedFeature = null;
                graphSvg.selectAll("path")
                        .filter(function(d){ return !(d[0].fake);})
                        .attr('stroke-opacity', 1.0)
                        .attr('stroke', function(d){ return d[0].color; });
                if(apply){
                    $scope.$apply();
                }
            };

            /**/
            var update = function(){
                graphSvg.selectAll('path').remove();
                graphSvg.selectAll('rect').remove();
                graphSvg.selectAll("line").remove();
                graphSvg.selectAll("polyline").remove();
                graphSvg.selectAll("text").remove();

                /*i: feature,
                    index: indices in the x-axis for which to paint,
                    color: color,
                    fake: is it just an overlay*/
                var paintCurve = function(i, index, color, fake){
                    var curve = graphSvg.append("path")
                                        .datum(index.map(function(d){ return {
                                                feature: i, ix: d, fake: fake, color: color};
                                        }))
                                        .attr("fill", "none")
                                        .attr("stroke", color)
                                        .attr("stroke-linejoin", "round")
                                        .attr("stroke-linecap", "round")
                                        .attr("stroke-width", fake ? 10 : 1.5)
                                        .attr("stroke-opacity", fake ? 0.0 : 1.0)
                                        .attr("d", d3.svg.line()
                                                       .x(function(d) { return x(xValues[d.ix]); })
                                                       .y(function(d) { return y(series[i][d.ix]); })
                                        );
                    if(fake){
                        curve.on("mouseover", function(d){
                            $scope.mouseoverCurve(d[0].feature, true);
                        })
                        .on("mouseout", function(d){
                            $scope.mouseoutCurve(d[0].feature, true);
                        });
                    }
                }

                var leftIndex = [];
                var rightIndex = [];
                for(var i = 0; i < $scope.data.length; i++){
                    if(i <= $scope.selectedIndex){
                        leftIndex.push(i);
                    }
                    if(i >= $scope.selectedIndex){
                        rightIndex.push(i);
                    }
                }

                /* create a rectangle to overlay the inactive coefficients */
                graphSvg.append("rect")
                        .attr("height", height)
                        .attr("width", (1.0 - xValues[$scope.selectedIndex]) * width)
                        .attr("x", xValues[$scope.selectedIndex] * width)
                        .attr("fill", "#eaeaea")
                        .attr("fill-opacity", "0.2");

                /* create vertical lines to show coefficient cutoffs */
                for(i = 0; i < cutoffs.length; i++){
                    graphSvg.append("line")
                        .attr("id", "sep-line")
                        .attr("stroke-dasharray", "5, 10")
                        .attr("x1", cutoffs[i] * width)
                        .attr("x2", cutoffs[i] * width)
                        .attr("y1", 0)
                        .attr("y2", height)
                        .attr("stroke", "#666666")
                        .attr("stroke-width", "0.3px");
                }

                /* create a polyline and text to track the current model */
                var paintRight = xValues[$scope.currentIndex] * width + 80 < width;
                var x1 = xValues[$scope.currentIndex] * width;
                var y1 = 0;
                var x2 = xValues[$scope.currentIndex] * width;
                var y2 = height + 30;
                var x3 = xValues[$scope.currentIndex] * width + (paintRight ? 40 : -40);
                var y3 = y2;
                var textX = xValues[$scope.currentIndex] * width + (paintRight ? 55 : -130);
                var textY = height + 35;
                graphSvg.append("polyline")
                        .attr("points", x1 + "," + y1 + " " + x2 + "," + y2 + " " + x3 + "," + y3)
                        .attr("stroke", "black")
                        .attr("stroke-dasharray", "8, 6")
                        .attr("stroke-width", $scope.currentIndex == $scope.selectedIndex ? "3px" : "1.5px")
                        .attr("fill", "none");
                graphSvg.append("text")
                        .text("Current model")
                        .attr("x", textX)
                        .attr("y", textY)
                        .attr("font-weight", $scope.currentIndex == $scope.selectedIndex ? "bold" : "regular");

                /* create a line to follow the current selected coefficients*/
                graphSvg.append("line")
                        .attr("id", "sep-line")
                        .attr("stroke-dasharray", "5, 10")
                        .attr("x1", xValues[$scope.selectedIndex] * width)
                        .attr("x2", xValues[$scope.selectedIndex] * width)
                        .attr("y1", 0)
                        .attr("y2", height)
                        .attr("stroke", $scope.selectedIndex == $scope.currentIndex ? "none" : "#666666")
                        .attr("stroke-width", "2.5px");

                /* paint the coefficient paths */
                for(i = 0; i < series.length; i++){
                    //we always paint a curve and then another transparent larger curve on top for mouse events.
                    //paint left section (active)
                    paintCurve(i, leftIndex, $scope.colorScales(i), false);
                    paintCurve(i, leftIndex, "black", true);
                    //paint inactive right section
                    paintCurve(i, rightIndex, d3.hcl($scope.colorScales(i)).brighter(3).rgb(), false);
                    paintCurve(i, rightIndex, "black", true);
                }

                /* paint the x axis */
                graphSvg.append("line")
                        .attr("x1", 0)
                        .attr("x2", width)
                        .attr("y1", y(0.0))
                        .attr("y2", y(0.0))
                        .attr("stroke", "black")
                        .attr("stroke-width", "1.5px");

            }

            updateSlider();
            update();

            slideUnwatch = $scope.$watch('slide', function(){
                var indexBefore = $scope.selectedIndex;
                updateSlider();
                if(indexBefore != $scope.selectedIndex){
                    update();
                }
            });

            });

        }
    };
});





})();
(function(){
'use strict';

var app = angular.module('dataiku.ml.report');


app.controller("ClusterHierarchyController", function($scope, $controller, $stateParams, Dialogs, DataikuAPI,
   FutureProgressModal, ActivityIndicator, CreateModalFromTemplate, WT1){

    WT1.event("clustering-hierarchy-page-open");

    $scope.hierarchyData = null;

    var retrieveData = function(){
        $scope.waiting = true;
        DataikuAPI.ml.clustering.getClusterHierarchy($stateParams.fullModelId || $scope.fullModelId).success(function(data) {
             $scope.hierarchyData = data;

             // create all cluster-meta to avoid constant saves while manipulating the graph.
             var registerNode = function(node){
                $scope.getClusterMeta("node_" + node.id);
                if(node.left_son){
                    registerNode(node.left_son);
                    registerNode(node.right_son)
                }
             };

             // Auto-name the root, well, "root"
             var rootNodeKey = "node_" + $scope.hierarchyData.root.id;
             if (! (rootNodeKey in $scope.clusterMetas)) {
                $scope.getClusterMeta(rootNodeKey).name = "root";
             }

             registerNode($scope.hierarchyData.root);

             $scope.waiting = false;
        }).error(function(data,status,headers){
              setErrorInScope.bind($scope)(data, status, headers);
              $scope.waiting = false;
        });
    };

    retrieveData();

    $scope.canCommit = true;

    $scope.hooks.dirty = function(){
        return $scope.diff;
    };

    $scope.$on("$destroy", function() { delete $scope.hooks.dirty; });

    $scope.diff = false;

    $scope.commit = function(leafIds){
        WT1.event("clustering-hierarchy-commit");
        var warning = "Are you sure you want to save this new clustering?";
        if($scope.getAlgorithm().startsWith("MLLIB")) warning += " This will trigger a Spark job.";
        Dialogs.confirm($scope, "Save clustering", warning).then(function(){
            WT1.event("clustering-hierarchy-commit-confirmed");
            $scope.modelData.userMeta.kept_hierarchy_node_ids = leafIds;
            DataikuAPI.ml.saveModelUserMeta($stateParams.fullModelId || $scope.fullModelId, $scope.modelData.userMeta).success(function(){
                  ActivityIndicator.success("Saved"); //maybe not necessary
                  DataikuAPI.ml.clustering.rescore($stateParams.fullModelId || $scope.fullModelId).success(function(data){
                      $scope.canCommit = false,
                      FutureProgressModal.show($scope, data, "Rescoring cluster hierarchy").then(function(result){
                      $scope.fetchModelDetails();
                          retrieveData();
                          $scope.canCommit = true;
                      })
                  }).error(setErrorInScope.bind($scope));
            }).error(setErrorInScope.bind($scope));
        });
    };

    $scope.edit = function(node, svgUpdateCallback){
        WT1.event("clustering-hierarchy-edit-node");
        CreateModalFromTemplate("/templates/ml/clustering-model/cluster-details-edit.html", $scope,
            "ClusterEditController", function(newScope){
            newScope.meta = $scope.getClusterMeta("node_" + node.id);
            newScope.callback = svgUpdateCallback;
        });
    };

});

app.directive("clusterHierarchy", function(Dialogs, ClusteringHeatmapUtils, WT1, getNameValueFromMLFeatureFilter){
    return {
        replace: true,
        templateUrl : '/templates/ml/clustering-model/cluster-hierarchy.html',
        scope: {
            data: '=',
            getClusterMeta: '=',
            edit: '=',
            commit: '=',
            canCommit: '=',
            readOnly: '=',
            diff: "="
        },
        link: function($scope, element) {

            var width = null;
            var height = null;
            var treeWidth = null;
            var container = $(element[0]).find("#container");
            d3.select(container[0]).select("svg").attr('height', 100000).append("defs");

            var svg = d3.select(container[0]).select("svg > g");
            var tree = d3.layout.cluster();

            var clusterWidth = 95;
            var clusterHeight = 18;

            var computeDimensions = function(){
                var leafCount = function(node){
                    if(node.collapsed || !node.left_son){
                        return 1;
                    } else {
                        return leafCount(node.left_son) + leafCount(node.right_son);
                    }
                };
                width = container.width();
                height = Math.max(400, (clusterHeight + 20) * leafCount(root));
                treeWidth = width - 100;
                tree.size([height, treeWidth]);
                container.height(height + 100);
            };

            tree.children(function(d){
                if(d.collapsed || !d.left_son){
                    return null;
                } else {
                    return [d.left_son, d.right_son];
                }
            });
            tree.sort(function(a,b){
                return d3.ascending(a.id, b.id);
            });

            $scope.editCluster = function(c){
                $scope.edit(c, function(){ update(root); });
            }

            var hasClusterParent = function(d){
                if(!d.parent){
                    return false;
                } else if(isCluster(d)){
                    return true;
                } else {
                    return hasClusterParent(d.parent);
                }
            };

            // Toggle children on click.
            var click = function(d) {
                if(hasClusterParent(d)){
                    d.collapsed = !d.collapsed;
                    update(d);
                    $scope.$apply(); //to recompute nLeaves
                }
            };

            var root = null;

            var collapseAll = function(node){
                if(node.left_son){
                    node.collapsed = true;
                    collapseAll(node.left_son);
                    collapseAll(node.right_son);
                } else {
                    node.collapsed = false;
                }
            }

            var collapseInit = function(node){
                if(isCluster(node)){
                    collapseAll(node);
                } else if(node.left_son) {
                    node.collapsed = false;
                    collapseInit(node.left_son);
                    collapseInit(node.right_son);
                } else {
                    node.collapsed = false;
                }
            }

            $scope.selectedNode = null;

            $scope.normalizeFeature = function(f){
                if(f === undefined) return;
                var splitedFeature = getNameValueFromMLFeatureFilter(f);
                if(splitedFeature.value){
                    return splitedFeature.name + " = " + splitedFeature.value;
                } else {
                    return f;
                }
            };

            $scope.featureSort = {
                sortBy: "default",
                sortDesc: false
            };

            $scope.featureIndex = [];

            var initFeatureIndex = function(){
                $scope.featureIndex = [];
                for(var i = 0; i < root.representative.length; i++){
                    $scope.featureIndex.push(i);
                }
            };

            var getParentChildScore = function(node){
                return function(i){
                    var parentValue = node.parent.representative[i];
                    var parentStd = node.parent.stds[i];
                    var parentWeight = node.parent.weight[i];
                    var value = node.representative[i];
                    var ratio;
                    if(parentStd == 0.0 || Number.isNaN(parentStd)){
                        ratio = value == 0.0 ? 0.0 : (value > 0.0 ? 2 : -2);//TODO
                    } else {
                        ratio = (value - parentValue)/parentStd;
                    }
                    return Math.abs(ratio);
                };
            };

            var getGlobalScore = function(node){
                return function(i){
                    return Math.abs(computeGlobalImportance(node, i));
                };
            };

            // scoreFeature is a function int => double on which to sort
            var applySorting = function(scoreFeature){
                var eps = $scope.featureSort.sortDesc ? -1 : 1;
                $scope.featureIndex.sort(function(a,b){
                    var aScore = scoreFeature(a);
                    var bScore = scoreFeature(b);
                    return eps * ((aScore < bScore) ? - 1 : (aScore > bScore ? 1 : 0));
                });
            };

            var sortDefault = function(){
                if($scope.featureSort.sortDesc){
                    $scope.featureIndex.reverse();
                }
            }

            var sortFeatureIndex = function(){
                initFeatureIndex();
                switch($scope.featureSort.sortBy){
                    case "global": applySorting(getGlobalScore($scope.selectedNode), root); break;
                    case "parent": applySorting(getParentChildScore($scope.selectedNode)); break;
                    default: sortDefault();
                }
            };

            var initDesc = function() {
                switch($scope.featureSort.sortBy){
                    case "global":
                    case "parent": $scope.featureSort.sortDesc = true; break;
                    default: $scope.featureSort.sortDesc = false; break;
                };
            };

            $scope.$watch('featureSort', function(nv, ov){
                if(nv && ov && nv.sortDesc === ov.sortDesc) {
                    initDesc();
                }
                WT1.event("clustering-hierarchy-sort-features", {
                    sortBy: $scope.featureSort ? $scope.featureSort.sortBy : "??",
                    sortDesc: $scope.featureSort ? $scope.featureSort.sortDesc : "??"
                });
                if(root)sortFeatureIndex();
            }, true);

            var ratioScales = d3.scale.linear().domain([-2, 0, 2]).range(["#0d52c1", "white", "#CE1329"]);
            $scope.arrowUp = function(featureIndex) {
                return $scope.selectedNode.representative[featureIndex] > $scope.selectedNode.parent.representative[featureIndex];
            };
            $scope.arrowColor = function(featureIndex){
                var value = $scope.selectedNode.representative[featureIndex];
                var parentValue = $scope.selectedNode.parent.representative[featureIndex];
                var parentStd = $scope.selectedNode.parent.stds[featureIndex];
                var ratio;
                if(parentStd == 0.0 || Number.isNaN(parentStd)){
                    ratio = value == 0.0 ? 0.0 : (value > 0.0 ? 2 : -2);
                } else {
                    ratio = (value - parentValue)/parentStd;
                }
                return ratioScales(ratio);
            };


            $scope.normalizeFeatureValue = function(feature, value){
                if(feature === undefined) return;
                if(feature.startsWith("dummy")){
                    return (Math.abs(value) * 100).toFixed(2) + "%";
                } else if (Math.abs(value) < .1 || Math.abs(value) >= 1000000) {
                    return value.toExponential(2);
                } else {
                    return value.toFixed(2);
                }
            };

            // utility to compute statistics
            var reduce = function(node, accessor, reducer){
                if(!node.left_son){
                    return accessor(node);
                } else {
                    var a = reduce(node.left_son, accessor, reducer);
                    var b = reduce(node.right_son, accessor, reducer)
                    return reducer(a,b);
                }
            };

            var featureScales = [];
            var globalScale;
            var computeColorScales = function(data){
                var max = 0.0;
                for(var i = 0; i < data.variable_names.length; i++){
                     max = Math.max(max, reduce(data.root, function(d){return Math.abs(computeGlobalImportance(d, i));}, Math.max));
                }
                max = Math.max(max, 10.0);
                globalScale = d3.scale.linear().domain([-max, -10.0, -2.0, 0.0, 2.0, 10.0, max])
                              .range(['#4285f4','#92abf9','#ccd4fc','#ffffff','#fbbab2','#ea746a','#ce1329']);
            };

            //replace squares by standard deviation to avoid recomputation
            var standardifyNode = function(n){
                n.stds = zip(n.representative, n.squares).map(x => Math.sqrt(Math.abs(x[1] / n.weight - x[0] * x[0]))); //should not need the Math.abs
                if(n.left_son){
                    standardifyNode(n.left_son);
                    standardifyNode(n.right_son);
                }
            };

            var computeGlobalImportance = function(node, featureIndex){
                var x = node.representative[featureIndex];
                var gx = root.representative[featureIndex];
                var importance;
                if($scope.features[featureIndex].startsWith("dummy:")){
                     importance = ClusteringHeatmapUtils.categoricalDiff(x, gx, node.weight, root.weight);
                } else {
                     importance = ClusteringHeatmapUtils.numericalDiff(x, gx, node.stds[featureIndex],
                                        root.stds[featureIndex], node.weight, root.weight);
                }

                return importance;
            };
            $scope.featureColor = function(featureIndex){
                if(featureIndex === undefined) return;
                var importance = computeGlobalImportance($scope.selectedNode, featureIndex);
                var col = globalScale(importance);
                return col;
            };

            var isCluster = function(d){
                return d && d.id in $scope.clusters;
            };
            $scope.isCluster = isCluster;

            /*
                labels each node with its cluster parent's id, if it has a cluster parent.
            */
            var computeClusterParents = function(node){
                var labelAll = function(n, i){
                    n.parent_cluster = i;
                    if(n.left_son){
                        labelAll(n.left_son, i);
                        labelAll(n.right_son, i);
                    }
                };
                if(isCluster(node)){
                    labelAll(node, node.id);
                } else if(node.left_son) {
                    computeClusterParents(node.left_son);
                    computeClusterParents(node.right_son);
                }
            };

            $scope.expandAll = function(){
                WT1.event("clustering-hierarchy-expand-all");
                var expandAll = function(node){
                    node.collapsed = false;
                    if(node.left_son){
                        expandAll(node.left_son);
                        expandAll(node.right_son);
                    }
                }
                expandAll(root);
                update(root);
            };

            $scope.collapse = function(){
                WT1.event("clustering-hierarchy-collapse");
                collapseInit(root);
                $scope.selectedNode = null;
                update(root);
            };

            $scope.reset = function(){
                 Dialogs.confirm($scope, "Reset clusters", "Do you want to reset the clustering to its current saved state ?").then(function(){
                   WT1.event("clustering-hierarchy-reset");
                   $scope.selectedNode = null;
                   initClusters();
                   $scope.diff = false;
                   svg.selectAll("rect.temporary").remove();
                   collapseInit(root);
                   computeClusterParents(root);
                   update(root);
                });
            };

            $scope.getName = function(nodeId){
                return $scope.getClusterMeta("node_" + nodeId).name;
            };

            var leaves = function(node){
                if(node.collapsed || ! node.left_son){
                    return [node.id];
                } else {
                    return leaves(node.left_son).concat(leaves(node.right_son));
                }
            };

            $scope.clusters = {};

            var computeDiff = function(){
                if(Object.keys($scope.clusters).length != $scope.data.active_ids.length){
                    $scope.diff = false;
                }
                for(var i = 0; i < $scope.data.active_ids.lenght; i++){
                    if(!($scope.data.active_ids[i] in $scope.clusters)){
                        $scope.diff = false;
                    }
                }
                $scope.diff = true;
            };

            checkChangesBeforeLeaving($scope, (function(_scope){return function() {return _scope.diff; }})($scope));

            /* Set a node as a cluster. If it does not have a cluster parent, it is set as a cluster and its
                cluster children are discarded. Otherwise, its cluster parent is discarded and the associated
                minimal set of clusters is added.
            */
            $scope.setAsCluster = function(node){
                if(hasClusterParent(node)){
                    WT1.event("clustering-hierarchy-set-as-cluster-has-cluster-parents");
                    var warning = "Setting this node as a cluster will also set its siblings as clusters.";
                    Dialogs.confirm($scope, "Set as cluster", warning).then(function(){
                        var n = node;
                        var toAdd = [node];
                        do {
                            if(n.parent.left_son == n){
                                toAdd.push(n.parent.right_son);
                            } else {
                                toAdd.push(n.parent.left_son);
                            }
                            n = n.parent;
                        } while(!isCluster(n));
                        delete $scope.clusters[n.id];
                        toAdd.forEach(function(c){ $scope.clusters[c.id] = {}});
                        computeDiff();
                        computeClusterParents(n);
                        svg.selectAll("rect.temporary").remove();
                        update(root);
                    });
                } else {
                    WT1.event("clustering-hierarchy-set-as-cluster-hasnt-cluster-parents");
                    var clusterSons = [];
                    var collectClusterSons = function(n){
                        if(isCluster(n)){
                            clusterSons.push(n);
                        } else {
                            collectClusterSons(n.left_son);
                            collectClusterSons(n.right_son);
                        }
                    };
                    collectClusterSons(node);
                    clusterSons.forEach(function(c){ delete $scope.clusters[c.id]; });
                    $scope.clusters[node.id] = {};
                    computeDiff();
                    computeClusterParents(node);
                    svg.selectAll("rect.temporary").remove();
                    update(root);
                }
            };

            $scope.commitClustering = function(){
                $scope.commit(Object.keys($scope.clusters));
            }

            var nLeaves = function(node){
                if(node.collapsed || !node.left_son){
                    return 1;
                } else {
                    return nLeaves(node.left_son) + nLeaves(node.right_son);
                }
            }

            $scope.nodeProportion = function(d){
                return (100 * (d.weight + 0.0)/root.weight).toFixed(2);
            };


            /*************************
                LAYOUT COMPUTATION
            *************************/

            /* helper functions for layout computation */

            var maxDepth = function(node, isLeaf){
                if(!isLeaf(node)){
                    return 1 + Math.max(maxDepth(node.children[0], isLeaf), maxDepth(node.children[1], isLeaf));
                } else {
                    return 0;
                }
            };

            var minLeafSeparation = 10; //we don't want leaves to be separated by less than 10px.

            /*
              Puts all nodes in the tree (as defined by the isLeaf function) in a list, in the post-order traversal
              order. This ensures leaves are put in order, followed by their parents in the same order, and so on.
            */
            var postOrderList = function(tree, isLeaf){
                var node = tree, nodes = [node], next = [], children, i, n;
                    while (node = nodes.pop()) {
                        next.push(node);
                        if(!isLeaf(node)){
                            nodes.push(node.left_son);
                            nodes.push(node.right_son);
                        }
                    }
                return next.reverse();
            };

            var isTerminalNode = function(n){ return n.collapsed || (!n.left_son); };

            /*
               Computes the cluster layout for a node and its descendants. Layout is stored in x, y.
               If positionLeaves is true, then the layout will also be computed for the leaves and the result
                will not be normalized. Otherwise, y-positions will be normalized with respect to leaf positioning.
                If a width is provided, the base layout will be built with that width, fully occupied. Otherwise,
                it will build it with width equal to the depth of the tree.
            */
            var computeBaseLayout = function(tree, treatAsLeaf, positionLeaves, width){
                var m = 1.0 * maxDepth(tree, treatAsLeaf);
                if(!width){
                    width = m;
                }
                var previousNode;
                var x = 0;
                postOrderList(tree,treatAsLeaf).forEach(function(node){
                    if(!treatAsLeaf(node)){
                        node.y = (node.left_son.y + node.right_son.y)/2;
                        node.x = Math.min(node.left_son.x, node.right_son.x) - width / m;
                    } else if (positionLeaves) {
                        node.y = previousNode ? x += (node.parent === previousNode.parent ? 1 : 2) * minLeafSeparation : 0;
                        node.x = m;
                        previousNode = node;
                    }
                });
            };

            /*
                Computes the bounding box for a tree, ie the coordinates of the smallest rectangle containing the tree,
                where coordinates are taken as the x,y properties of each node.
            */
            var computeBoundingBox = function(tree){
                var maxY = Number.NEGATIVE_INFINITY;
                var maxX = Number.NEGATIVE_INFINITY;
                var minY = Number.POSITIVE_INFINITY;
                var minX = Number.POSITIVE_INFINITY;
                var updateBoundingBox = function(node){
                    maxY = Math.max(node.y, maxY);
                    maxX = Math.max(node.x, maxX);
                    minY = Math.min(node.y, minY);
                    minX = Math.min(node.x, minX);
                    if(!isTerminalNode(node)){
                        updateBoundingBox(node.left_son);
                        updateBoundingBox(node.right_son);
                    }
                };
                updateBoundingBox(tree);
                return {
                    maxX: maxX,
                    maxY: maxY,
                    minX: minX,
                    minY: minY
                };
            };

            /**/
            var rescale = function(tree, x_scale, y_scale, x_offset, y_offset){
                var bb = computeBoundingBox(tree);
                var renormalizeNode = function(node){
                    node.x = x_offset + width * x_scale * (node.x - bb.minX);
                    node.y = y_offset + height * y_scale * (node.y - bb.minY);
                    if(!isTerminalNode(node)){
                        renormalizeNode(node.left_son);
                        renormalizeNode(node.right_son);
                    }
                };
                renormalizeNode(tree);
            };

            /* Renormalizes the tree, given a width and height, and offsets such that the upper-left corner of
                the bounding box for the tree should begin at that offset.*/
            var renormalize = function(tree, width, height, x_offset, y_offset) {
                var bb = computeBoundingBox(tree);
                var xScale = bb.maxX == bb.minX ? 1.0 : 1.0/(bb.maxX - bb.minX);
                var yScale = bb.maxY == bb.minY ? 1.0 : 1.0/(bb.maxY - bb.minY);
                var renormalizeNode = function(node){
                    node.x = x_offset + width * xScale * (node.x - bb.minX);
                    node.y = y_offset + height * yScale * (node.y - bb.minY);
                    if(!isTerminalNode(node)){
                        renormalizeNode(node.left_son);
                        renormalizeNode(node.right_son);
                    }
                };
                renormalizeNode(tree);
            };

            /* Recomputes the layout for the clustering.
            The logic of the algorithm is the following : we build the layout right to left
                - first, if a node is a "cluster" (or collapsed cluster), its opened children and itself are considered
                  as their own cluster layout, which is computed as d3 would the full layout.
                - we rescale each subtree layout so that they all have the same width
                - then, each subtree is positioned in order, with the same vertical distance in between subtrees, and roots
                  at the same height.
                - for the leftmost part of the layout, the layout is the same as a d3 cluster layout, but the leaves
                  are the cluster nodes, which already have their positions defined.
                - when all is done, we compute the bounding box for the whole thing and see if we can stretch it
                  vertically to occupy the whole screen, and then adjust for padding.
                - finally, we adjust horizontally, to add space for the cluster label boxes */
            var computeLayout = function(root, width, height, padding, clusterWidth){

                var subtrees = [];
                //collects all subtrees starting at a cluster, from top to bottom (right to left in tree order)
                //this terminates because every path from the root traverses a cluster
                var collectSubtrees = function(node){
                    if(isCluster(node)){
                        subtrees.push(node);
                    } else {
                        collectSubtrees(node.right_son);
                        collectSubtrees(node.left_son);
                    }
                };
                collectSubtrees(root);

                //compute the layout for every subtree, which will be correctly positioned.
                subtrees.forEach(function(tree){ computeBaseLayout(tree, function(node){ return !node.children; }, true); });
                var y_offset = 0;
                for(var i = 0; i < subtrees.length; i++){
                    var bb = computeBoundingBox(subtrees[i]);
                    var subtreeHeight = bb.maxY - bb.minY;
                    //we don't touch subtree height, but stretch the tree to fit half the window.
                    renormalize(subtrees[i], width / 2 - clusterWidth, subtreeHeight, width / 2, y_offset);
                    y_offset += subtreeHeight + 2 * clusterHeight;
                }

                //compute the root layout, but this time clusters are the leaves.
                computeBaseLayout(root, function(node){ return isCluster(node); }, false, width/2);

                //stretch if we can
                var bb = computeBoundingBox(root);
                var h = padding + bb.maxY - bb.minY;
                var nodeList = postOrderList(root, function(n){ return isTerminalNode(n); });
                if(!padding){
                    padding = 0;
                }
                if(h > 0 && h < height){
                    var scale = (1.0 * height)/h;
                    nodeList.forEach(function(n){ n.y = scale * n.y; });
                    bb.maxY *= scale;
                }
                //add padding
                var x_scale = (width - 2.0 * padding) / width;
                var y_scale = (h - 2.0 * padding) / height;
                nodeList.forEach(function(node){
                    node.x = padding + node.x * x_scale;
                    node.y = padding + node.y;
                });

                //rescale to take cluster width into account. We rescale left and right symmetrically, in order to keep
                //the padding but ensure the right clusterWidth
                var scaleRatio = (0.50 * width - padding - 0.5 * clusterWidth)/(0.5 * width - padding);
                var rescaleLeft = function(x){ return (x - padding) * scaleRatio + padding; };
                nodeList.forEach(function(node){
                    if(isCluster(node)){
                        return;
                    } else if(hasClusterParent(node)){
                        node.x = width - rescaleLeft(width - node.x);
                    } else {
                        node.x = rescaleLeft(node.x);
                    }
                });

            };

            var initClusters = function(){
                $scope.clusters = {};
                for(var i = 0; i < $scope.data.active_ids.length; i++){
                    $scope.clusters[$scope.data.active_ids[i]] = {};
                }
            };

            /*************************
                DATA UPDATE FUNCTION
            *************************/
            $scope.$watch('data', function(){
                if($scope.data){
                    root = $scope.data.root;
                    $scope.features = $scope.data.variable_names;
                    initClusters();
                    $scope.activeIds = $scope.data.active_ids;
                    collapseInit(root);
                    standardifyNode(root);
                    computeColorScales($scope.data);
                    computeClusterParents(root);
                    $scope.diff = false;
                    initFeatureIndex();
                    update(root);
                }
            });

            /************************
                SVG UPDATE FUNCTION
            ************************/
            var update = function(source) {

                $scope.nLeaves = nLeaves(root);

                computeDimensions();

                /* graphical utilities, need to be in update function because they require computed dimensions */

                var nodeRadius = function(d){
                  return 20 * Math.pow(d.weight / root.weight, 0.3);
                };

                var maxCurveLength = 40;
                var linkShape = function(d){
                    //adjust target and source positions to account for cluster label width
                    var sourceX = d.source.x;
                    var targetX = d.target.x;
                    if(isCluster(d.source)){
                        sourceX += clusterWidth / 2;
                    } else if(isCluster(d.target)){
                        targetX -= clusterWidth / 2;
                    }
                    var xDiff = targetX - sourceX;
                    var curveLength = Math.min(maxCurveLength, xDiff);
                    var diag = d3.svg.diagonal()
                                 .source(function(d) { return {"x":d.source.y, "y":sourceX}; })
                                 .target(function(d) { return {"x":d.target.y, "y":sourceX + curveLength}; })
                                 .projection(function(d) { return [d.y, d.x]; });
                    var line;
                    if(curveLength < xDiff){
                        line = "L " + d.target.x + "," + d.target.y;
                    } else {
                        line = "";
                    }
                    return diag(d) + line;
                }

                $scope.nodeColor = function(node){
                    return $scope.getClusterMeta("node_" + node.id).color;
                };

                var inactiveLinkColor = "#CCCCCC";
                var activeLinkColor = "#999999";

                var colorLeadingLinks = function(node, color){
                    if(node.parent){
                        svg.select("#link_" + node.parent.id + "_" + node.id).style("stroke", function(d){return color;});
                        colorLeadingLinks(node.parent, color);
                    }
                };
                var appendLeadingNames = function(node) {
                    if(!isCluster(node)){
                        var name = $scope.getName(node.id);
                        //clip name for overflow
                        if(name.length > 10){
                            name = name.substring(0,8) + "...";
                        }
                        svg.select("#nodegroup_" + node.id)
                            .append("text")
                            .attr("id", "text_" + node.id)
                            .text(name)
                            .attr("fill", node == $scope.selectedNode ? "#666" : "#CCC")
                            .attr("dx", 20)
                            .attr("dy", 4)
                            .on('mouseover', onNodeHover);
                    }

                    if(node.parent){
                        appendLeadingNames(node.parent);
                    }
                };
                var removeLeadingNames = function(node) {
                    if(!isCluster(node)){
                        svg.select("#text_" + node.id).remove();
                    }
                    if(node.parent){
                        removeLeadingNames(node.parent);
                    }
                };

                var onNodeHover = function(d){
                    if(!$scope.selectedNode || $scope.selectedNode.id != d.id){
                        //reset the previous path to default style
                        if($scope.selectedNode){
                            colorLeadingLinks($scope.selectedNode, inactiveLinkColor);
                            removeLeadingNames($scope.selectedNode);
                            svg.selectAll("rect.temporary").remove();
                            svg.selectAll("text.caret").remove();
                        }
                        $scope.selectedNode = d;
                        sortFeatureIndex();
                        showSelected(d);
                    }
                };

                var showSelected = function(node) {
                    var nodeGroup = svg.select("#nodegroup_" + node.id);

                    if (!$scope.readOnly) {
                        //add an invisible target for the dropdown click
                        nodeGroup
                            .append("rect")
                            .attr("x", isCluster(node)? clusterWidth / 2 - 22 : clusterWidth - 25)
                            .attr("y", -clusterHeight/2)
                            .attr("width", clusterHeight + 5)
                            .attr("height", clusterHeight)
                            .attr("fill-opacity", 0)
                            .attr("class", "temporary cursor-pointer")
                            .on("click", showNodeMenu);
                        //add a caret (no pointer events)
                        nodeGroup.append("text")
                            .attr("class", "caret cursor-pointer")
                            .style("font-family", "FontAwesome")
                            .text(String.fromCharCode(parseInt("F0D7", 16)))
                            .attr("x", isCluster(node) ? clusterWidth/2 - 15 : clusterWidth - 25)
                            .attr("y", 5)
                            .attr("fill", isCluster(node) ? "white" : "#333")
                            .attr("pointer-events", "none");
                    }


                    //for non-cluster nodes, add a transient cartouche under the name
                    if(!isCluster(node)){
                        nodeGroup.insert("rect", ":first-child")
                            .attr("class", "temporary")
                            .attr("width", clusterWidth )
                            .attr("height", clusterHeight )
                            .attr("rx", clusterHeight/2)
                            .attr("y", -clusterHeight/2)
                            .attr("x", -10)
                            .attr("fill", "#E2E2E2");
                    }

                    colorLeadingLinks(node, activeLinkColor);
                    appendLeadingNames(node);
                    safeApply($scope);
                };

                var $nodeMenu = container.find("ul.dropdown-menu");
                var showNodeMenu = function(d) {
                    $nodeMenu.css("left", d.x - clusterWidth/2 + 5);
                    $nodeMenu.css("top", d.y + clusterHeight/2 + 2);
                    $nodeMenu.css("display", "block");
                };

                var hideNodeMenu = function(e) {
                    if (e.target.classList[0] != 'caret' && e.target.classList[0] != 'temporary') {
                        $nodeMenu.css("display", "none");
                    }
                };

                //hide the menu when clicking outside it
                $('body').on('click', hideNodeMenu);
                $scope.$on("$destroy", function() { $('body').off('click', null, hideNodeMenu)});

                // Compute the new tree layout.
                var nodes = tree.nodes(root);
                var links = tree.links(nodes);

                var padding = 20;
                computeLayout(root, width, height, padding, clusterWidth);

                var node = svg.selectAll(".node").data(nodes, function(d) { return d.id; });
                var link = svg.selectAll(".link").data(links);

                node.exit().remove();
                link.exit().remove();
                svg.selectAll("text").remove();

                link.enter().insert("path", ":first-child").attr("class", "link");

                 link.attr("d", linkShape)
                    .attr("id",function(d){ return "link_" + d.source.id + "_" + d.target.id; })
                    .style("fill", "none")
                    .style("stroke",inactiveLinkColor)
                    .style("stroke-width", function(d){
                       return Math.max(2, 15 * d.target.weight/root.weight);
                    })
                    .on("mouseover", function(d) {
                        onNodeHover(d.target);
                    });

                if($scope.selectedNode){
                    showSelected($scope.selectedNode);
                }

                var nodeEntered = node.enter()
                    .append("g")
                    .attr("class", "node").attr("id", function(d){ return "nodegroup_" + d.id;});
                nodeEntered.append("rect");

                nodeEntered.attr("transform", function(d){
                       return "translate(" + 0 + ", " + d.x + ")";
                });

                node.attr("transform", function(d){
                     return "translate(" + d.x + ", " + d.y + ")";
                });

                node.select("rect")
                    .attr("width", function(d){ return isCluster(d) ? clusterWidth: nodeRadius(d); })
                    .attr("height", function(d){ return isCluster(d) ? clusterHeight: nodeRadius(d); })
                    .attr("rx", function(d){return (isCluster(d) ? clusterHeight: nodeRadius(d))/2;})
                    .attr("y", function(d){return -(isCluster(d) ? clusterHeight: nodeRadius(d))/2;})
                    .attr("x", function(d){return -(isCluster(d) ? clusterWidth : nodeRadius(d))/2;})
                    .attr("fill", function(d){
                        if(isCluster(d)){
                            return $scope.nodeColor(d);
                        } else if(!d.left_son){
                            return inactiveLinkColor;
                        } else {
                            return "white";
                        }
                    })
                    .style("stroke", function(d){
                        return "#666666";
                    })
                    .style("stroke-width", function(d){
                        if(isCluster(d) || !d.left_son){
                            return 0;
                        } else if($scope.selectedNode && $scope.selectedNode.id == d.id){
                            return 3;
                        } else {
                            return 1;
                        }
                    }).style("cursor", function(d){ return hasClusterParent(d) && d.left_son ? "pointer": "default"; })
                      .attr("id",function(d){return "node_" + d.id})
                      .on("click", click)
                      .on("mouseover", onNodeHover);

                 node.filter(function(d){
                    return isCluster(d);
                  })
                 .append("text").text(function(d){
                    var name = $scope.getName(d.id);
                    //clip name for overflow
                    if(name.length > 10){
                        return name.substring(0,8) + "...";
                    } else {
                        return name;
                    }
                 })
                 .attr("text-anchor", "middle")
                 .attr("fill", function(d){
                     return "white";
                 })
                 .style("pointer-events", "none")
                 //.attr("dx", )
                 .attr("dy", 4);

                 var linkExit = link.exit().remove();
                 var nodeExit = node.exit().remove();


                node.exit().remove();
            };
        }
    };
});


})();

(function(){
'use strict';

const app = angular.module('dataiku.ml.predicted', []);


/**
 * Shared stuff for predicted table and predicted charts.
 * Shared between analysis, saved models and insights
 */

app.directive("predictedTableBase", function($q, WT1, Assert, DataikuAPI, TopNav, MonoFuture, Logger) {
    return {
        scope: true,
        priority: 50,
        controller: function($scope, $stateParams, $state) {
            /* ********************* Callbacks for shakerExploreBase ******************* */

            $scope.shakerHooks.saveForAuto = function() {
                Assert.inScope($scope, 'mlTaskDesign');
                var deferred = $q.defer();

                var toSave = angular.copy($scope.mlTaskDesign);
                toSave.predictedScript = $scope.getShakerData();

                var fn = null;
                if ($scope.mlTaskDesign.taskType == "PREDICTION") {
                    fn = DataikuAPI.analysis.pml.saveSettings;
                } else if ($scope.mlTaskDesign.taskType == "CLUSTERING") {
                    fn = DataikuAPI.analysis.cml.saveSettings;
                } else {
                    throw "Unexpected taskType";
                }

                fn($stateParams.projectKey, $stateParams.analysisId, toSave).success(function(data) {
                    // Reset modification detector
                    $scope.originalShaker = toSave.script;
                    $scope.invalidScriptError = {};
                    // TODO @analysis make this common
                    for (var stepIdx in $scope.shaker.steps) {
                        var step = $scope.shaker.steps[stepIdx];
                        var err = $scope.validateStep(step);
                        if (err != null) {
                            $scope.invalidScriptError = {
                                index: stepIdx,
                                type: step.type,
                                message: err
                            };
                            Logger.info("script is invalid, not refreshing");
                            deferred.reject("Script is invalid");
                            return;
                        }
                    }
                    deferred.resolve();
                }).error(setErrorInScope.bind($scope));
                return deferred.promise;
            }

            /* ********************* Callbacks for shakerExploreBase ******************* */

            var monoFuturizedRefresh = MonoFuture($scope).wrap(DataikuAPI.analysis.predicted.predictedRefreshTable);

            $scope.shakerHooks.getRefreshTablePromise = function(filtersOnly, filterRequest) {
                return monoFuturizedRefresh($stateParams.fullModelId,
                    $scope.shaker,
                    filtersOnly, filterRequest);
            }

            $scope.shakerHooks.shakerForQuery = function(){
                var queryObj = angular.copy($scope.shaker);
                if ($scope.isRecipe) {
                    queryObj.recipeSchema = $scope.recipeOutputSchema;
                }
                queryObj.contextProjectKey = $stateParams.projectKey; // quick 'n' dirty, but there are too many call to bother passing the projectKey through them
                return queryObj;
            }

            $scope.shakerHooks.fetchDetailedAnalysis = function(setAnalysis, handleError, columnName, alphanumMaxResults, fullSamplePartitionId, withFullSampleStatistics) {
                // withFullSampleStatistics, fullSamplePartitionId are not relevant in this context
            	DataikuAPI.analysis.predicted.detailedColumnAnalysis($stateParams.fullModelId, $scope.shakerHooks.shakerForQuery(), columnName, alphanumMaxResults).success(function(data){
                        	setAnalysis(data);
                }).error(function(a, b, c) {
                    if (handleError) {
                        handleError(a, b, c);
                    }    
                    setErrorInScope.bind($scope)(a, b, c);
                });
    		};

            $scope.shakerHooks.getTableChunk = function(firstRow, nbRows, firstCol, nbCols, filterRequest) {
                return DataikuAPI.analysis.predicted.predictedGetTableChunk($stateParams.fullModelId,
                    $scope.shaker, firstRow, nbRows, firstCol, nbCols, filterRequest)
            }

            $scope.loadMLTask = function(){
                Assert.inScope($scope, 'shakerState');
                Assert.inScope($scope, 'shakerHooks');
                $scope.shakerWithSteps = false;

                DataikuAPI.analysis.mlcommon.getCurrentSettings($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId).success(function(data){
                    $scope.mlTaskDesign = data;

                    $scope.baseInit();
                    $scope.shaker = data.predictionDisplayScript;
                    $scope.originalShaker = angular.copy($scope.shaker);
                    $scope.fixupShaker();
                    $scope.refreshTable(false);
                }).error(setErrorInScope.bind($scope));
            }
        }
    }
});


app.directive("predictedChartsBase", function(){
    return {
        scope: true,
        priority: 50,

        controller: function() {
        }
    }
});


})();

(function(){
'use strict';

var app = angular.module('dataiku.ml.core', []);

/**
 * Filtering of prediction models
 */

app.factory("_MLFilteringServicePrototype", function(Fn) {
    return {
        setMainMetric: function(modelsList, prop, currentMetric, customEvaluationMetricGIB)  {
            if (!prop) prop = [];

            const computeMetric = (model) => {
                var modelProp = Fn.prop(prop)(model);
                var lib = this.MLSettings.sort.lowerIsBetter(currentMetric, customEvaluationMetricGIB) ? -1 : 1;
                modelProp.mainMetric = modelProp[this.metricMap[currentMetric]];
                modelProp.sortMainMetric = modelProp.mainMetric ? lib * modelProp.mainMetric : -1 * Number.MAX_VALUE;
                if (this.getMetricStdFromSnippet) {
                    modelProp.mainMetricStd = this.getMetricStdFromSnippet(modelProp, currentMetric);
                }
            };

            modelsList.forEach((m) => {
                computeMetric(m);

                if (m.partitions && m.partitions.summaries) {
                    Object.values(m.partitions.summaries)
                        .forEach(summary => summary.snippet && computeMetric(summary.snippet));
                }
            });
        },
        getMetricFromSnippet: function(model, metric) {
            return model[this.metricMap[metric]];
        },
    };
});

app.factory("PMLFilteringService", function(_MLFilteringServicePrototype, Assert, PMLSettings) {
    var svc = Object.create(_MLFilteringServicePrototype);
    svc.MLSettings = PMLSettings;
    svc.metricMap = {
        ACCURACY: 'accuracy',
        PRECISION: 'precision',
        RECALL: 'recall',
        F1: 'f1',
        CALIBRATION_LOSS: 'calibrationLoss',
        COST_MATRIX: 'costMatrixGain',
        CUMULATIVE_LIFT: 'lift',
        LOG_LOSS: 'logLoss',
        ROC_AUC: 'auc',
        EVS: 'evs',
        MAPE: 'mape',
        MAE: 'mae',
        MSE: 'mse',
        RMSE: 'rmse',
        RMSLE: 'rmsle',
        R2: 'r2',
        PEARSON: 'pearson',
        CUSTOM: 'customScore'
    };
    svc.getPossibleMetrics = function(mlTask) {
        var ret = [];
        switch(mlTask.predictionType) {
            case 'BINARY_CLASSIFICATION':
                ret = ['ACCURACY', 'PRECISION', 'RECALL', 'F1', 'COST_MATRIX', 'LOG_LOSS', 'ROC_AUC', 'CALIBRATION_LOSS', 'CUMULATIVE_LIFT'];
                break;
            case 'MULTICLASS':
                ret = ['ACCURACY', 'PRECISION', 'RECALL', 'F1', 'LOG_LOSS', 'ROC_AUC', 'CALIBRATION_LOSS'];
                break;
            case 'REGRESSION':
                ret = ['EVS', 'MAPE', 'MAE', 'MSE', 'RMSE', 'RMSLE', 'R2', 'PEARSON'];
        }
        if (mlTask.modeling && mlTask.modeling.metrics.customEvaluationMetricCode){
            ret.push('CUSTOM');
        }
        return ret.map(function(m) { return [m, PMLSettings.names.evaluationMetrics[m]] });
    };
    svc.getMetricStdFromSnippet = function(model, metric) {
        switch (metric) {
            case "LOG_LOSS" : return model.logLossstd;
            case "CUSTOM" : return model.customScorestd;
            default:
                return model[svc.metricMap[metric] + "std"];
        }
    }

    svc.getMetricValueFromModel = function(modelData, metric, currentCutData) {
        function getFromTIMetrics() {
            if (!(modelData.perf && modelData.perf.tiMetrics)) {
                return '<No metric available>';
            }
            if (!modelData.perf.tiMetrics[svc.metricMap[metric]]) {
                return '<'+metric+' not available>';
            }
            return modelData.perf.tiMetrics[svc.metricMap[metric]];
        };
        function getFromCurrentCutData(key) {
            Assert.trueish(currentCutData, 'no currentCutData');
            return currentCutData[key];
        };        
        
        Assert.trueish(modelData, 'no modelData');
        switch (modelData.coreParams.prediction_type) {
            case 'BINARY_CLASSIFICATION':
                Assert.trueish(metric, 'metric not specified');
                switch (metric) {
                    case "F1":
                        Assert.trueish(currentCutData, 'no currentCutData');
                        return getFromCurrentCutData("F1-Score");
                    case "RECALL":
                        Assert.trueish(currentCutData, 'no currentCutData');
                        return getFromCurrentCutData("Recall");
                    case "PRECISION":
                        Assert.trueish(currentCutData, 'no currentCutData');
                        return getFromCurrentCutData("Precision")
                    case "ACCURACY":
                        Assert.trueish(currentCutData, 'no currentCutData');
                        return getFromCurrentCutData("Accuracy")
                    case "COST_MATRIX":
                        Assert.trueish(currentCutData, 'no currentCutData');
                        return getFromCurrentCutData("cmg");
                    case "CUSTOM":
                        if (modelData.modeling && modelData.modeling.metrics) {
                            // we can know whether it's custom-with-proba or not
                            if (modelData.modeling.metrics.customEvaluationMetricNeedsProba) {
                                return getFromTIMetrics();
                            } else {
                                Assert.trueish(currentCutData, 'no currentCutData');
                                return getFromCurrentCutData("customScore");
                            }
                        } else {
                            // assume custom-with-proba
                            return getFromTIMetrics();
                        }
                    case "LOG_LOSS":
                    case "ROC_AUC":
                    case "CUMULATIVE_LIFT":
                        return getFromTIMetrics();
                }
                Assert.fail('Unknown metric ' + metric);
            case "MULTICLASS":
                if (metric === 'ROC_AUC') {
                    if (!(modelData.perf && modelData.perf.metrics)) {
                        return '<No metric available>';
                    }
                    if (!modelData.perf.metrics.mrocAUC) {
                        return '<multi ROC AUC not available>';
                    }
                    return modelData.perf.metrics.mrocAUC;
                }   // else FALLTHROUGH to perf.metric
            case "REGRESSION":
                Assert.trueish(metric, 'metric not specified');
                Assert.trueish(svc.metricMap[metric], 'cannot display metric '+metric);
                if (!(modelData.perf && modelData.perf.metrics)) {
                    return '<No metric available>';
                }
                if (!modelData.perf.metrics[svc.metricMap[metric]]) {
                    return '<'+svc.metricMap[metric]+' not available>';
                }
                return modelData.perf.metrics[svc.metricMap[metric]];
        }
    };

    return svc;
});

app.factory("CMLFilteringService", function(_MLFilteringServicePrototype, Assert, CMLSettings, Fn) {
    var svc = Object.create(_MLFilteringServicePrototype);
    svc.MLSettings = CMLSettings;
    svc.metricMap = { SILHOUETTE: 'silhouette', INERTIA: 'inertia', NB_CLUSTERS: 'nbClusters' };
    svc.getPossibleMetrics = Fn.cst(CMLSettings.task.evaluationMetrics);

    svc.getMetricNameFromModel = function(modelData) {
        Assert.trueish(modelData, 'no modelData');
        return modelData.actualParams.resolved.metrics.evaluationMetric;
    };

    svc.getMetricValueFromModel = function(modelData) {
        Assert.trueish(modelData, 'no modelData');
        let metricName = modelData.actualParams.resolved.metrics.evaluationMetric;
        metricName = svc.metricMap[metricName];
        let metricValue = modelData.perf.metrics[metricName];
        return metricValue;
    };

    return svc;
});

app.service("MLExportService", function(DataikuAPI, WT1, $stateParams, Dialogs, CreateModalFromTemplate, SpinnerService, FutureWatcher,
    FullModelIdUtils, FutureProgressModal, ActivityIndicator) {
    this.downloadFile = (scope, generateFile, getUrl) => {
        generateFile()
            .success(data => {
                SpinnerService.lockOnPromise(FutureWatcher.watchJobId(data.jobId)
                    .success(data => {
                        downloadURL(getUrl(data.result.exportId));
                    }).error(error => {
                        Dialogs.error(scope, "An error occured while exporting file", error.message);
                    }));
               })
            .error(error => {
                Dialogs.error(scope, "An error occured while exporting file", error.message);
            });
    };
    this.showDownloadModel = function(appConfig, type) {
        if (! appConfig.licensedFeatures) {
            return false;
        }
        switch (type) {
            case 'pmml': return appConfig.licensedFeatures.modelsPMMLExport;
            case 'jar':  return appConfig.licensedFeatures.modelsJarExport;
            case 'snowflakefunction': return appConfig.licensedFeatures.modelsJarExport;
            case 'docgen' : return true;
            default: return true;
        }
    };
    this.mayDownloadModel = function(appConfig, model, type) {
        switch (type) {
            case 'pmml': return model && model.pmmlCompatibility.compatible;
            case 'jar': return model && model.javaCompatibility.compatible;
            case 'snowflakefunction': return model && model.javaCompatibility.compatible;
            case 'docgen': return appConfig.graphicsExportsEnabled && model && !model.modeling.algorithm.endsWith('_ENSEMBLE') && !model.modeling.algorithm.endsWith('KERAS_CODE'); // Disable MDG for ensemble models
            default: return false;
        }
    };
    this.exportToSnowflakeFunction = function(scope, model) {
        console.info("ETSF", arguments);
        CreateModalFromTemplate("/templates/analysis/prediction/model/export-to-snowflake-function-modal.html", scope, null, function(modalScope){
            DataikuAPI.sqlNotebooks.listConnections($stateParams.projectKey).success(function(connections) {
                scope.snowflakeConnectionNames = connections.nconns.filter((c) => c.type == "Snowflake").map((c) => c.name);
            }).error(setErrorInScope.bind(scope));

            modalScope.exportOptions = {
            }
            modalScope.export = function(){
                DataikuAPI.ml.prediction.exportToSnowflakeFunction(modalScope.exportOptions.snowflakeConnectionName,
                            model.fullModelId, modalScope.exportOptions.functionName).success(function(data){
                    modalScope.dismiss();
                    FutureProgressModal.show(scope, data, "Exporting to Snowflake").then(() => {
                        ActivityIndicator.success("Successfully exported to Snowflake function")
                    });
                }).error(setErrorInScope.bind(modalScope));
            }
        });
    }
    this.downloadModel = function(scope, model, type, partitionName) {
        if (type == 'docgen') {
            if (scope.appConfig.graphicsExportsEnabled) {
                if (!model.modeling.algorithm.endsWith('_ENSEMBLE') && !model.modeling.algorithm.endsWith('KERAS_CODE')) {
                    CreateModalFromTemplate("/templates/analysis/prediction/model/download-documentation-modal.html",
                        scope, "DownloadModelDocumentationController", undefined, undefined, 'static');
                } else if (model.modeling.algorithm.endsWith('KERAS_CODE')){
                    Dialogs.error(scope, "Model is not compatible", "Model backend not supported: KERAS");
                } else {
                    Dialogs.error(scope, "Model is not compatible", "Ensemble models are not compatible with documentation export.");
                }
            } else {
                CreateModalFromTemplate("/templates/exports/graphics-export-disabled-modal.html", scope);
            }
            
        } else if (type === 'jar-thin' || type === 'jar-fat') {
            if (model.javaCompatibility.compatible) {
                const downloadPrompt = (id) => {
                    Dialogs.prompt(
                        scope,
                        "Download model JAR",
                        "Fully-qualified class name for the model",
                        "com.company.project.Model",
                        { pattern: "^((?:[a-z]\\w*\\.)*)?([A-Z]\\w*)$" }
                    ).then( name => {
                        WT1.event("model-export", {exportType: type});
                        this.downloadFile(scope, () => DataikuAPI.ml.prediction.createScoringModelFile(type, id, "&fullClassName=" + encodeURIComponent(name)),
                            (exportId) => DataikuAPI.ml.prediction.getScoringModelDownloadURL(type, exportId));
                    });
                };
                if (! partitionName) {
                    downloadPrompt(model.fullModelId);
                } else {
                    const choices = [
                        {
                            id: FullModelIdUtils.getBase(model.fullModelId),
                            title: "Full model, with all partitions"
                        }, {
                            id: model.fullModelId,
                            title: "Single model partition",
                            desc: partitionName
                        }
                    ];
                    Dialogs.select(
                        scope,
                        "Export partitioned model",
                        "Do you want to export the full model or just the current partition?",
                        choices,
                        choices[0]
                    ).then((selected) => { downloadPrompt(selected.id); });
                }
            } else {
                Dialogs.error(scope, "Model is not compatible with Jar export", model.javaCompatibility.reason);
            }
        } else if (type === 'pmml' && ! model.pmmlCompatibility.compatible) {
            Dialogs.error(scope, "Model is not compatible with PMML export", model.pmmlCompatibility.reason);
        } else {
            WT1.event("model-export", {exportType: type});
            this.downloadFile(scope, () => DataikuAPI.ml.prediction.createScoringModelFile(type, model.fullModelId),
             (exportId) => DataikuAPI.ml.prediction.getScoringModelDownloadURL(type, exportId));
        }
    }
});

app.filter("gridParameter", function(){
    return function(par){
        if (par.vals) {
             return par.vals.join(", ");
        } else if (par.val) {
            return par.val;
        } else if (par.cnt) {
            return par.cnt + " value(s)";
        } else if (par.min && par.max) {
            return "(" + par.min + ", " + par.max + ")";
        }
    };
});

app.directive("gridDescription", function(){
    return {
        scope: {desc: '=', trained: '=', gridsearchData: "="},
        restrict: 'A',
        templateUrl: '/templates/ml/model-snippet-grid-description.html'
    };
});

app.directive("modelSnippet", function($state, PMLSettings, $rootScope) {
    return {
        scope: { snippetData: '=', snippetSource : '@', taskType : '=', smData : '=', makeActive : '=', hideSelectors: '@', currentMetric: "="},
        templateUrl: '/templates/ml/model-snippet.html',
        link: function($scope) {
            $scope.$state = $state;
            $scope.appConfig = $rootScope.appConfig;
            $scope.out = $scope.$parent;
        }
    };
});

app.filter('niceModelState', function ($filter) {
    return function (state, source) {
        if (!state) {
            return '-';
        }
        if (state.startsWith('REUSED_')) {
            return 'Re-used';
        } else if (state === 'DONE') {
            return 'Trained';
        }

        return $filter('niceConst')(state);
    }
});

app.directive("modelState", function($state) {
    return {
        scope: { state: '=', model: '=', sRefPrefix: '=', displayDiagnosticsPopup: '=', displayDiagnostics: '='},
        templateUrl: '/templates/ml/model-snippet-state.html',
        link: function($scope) {
            $scope.$state = $state;
        }
    };
});


app.directive("modelsTable", function($state, DataikuAPI){
    return {
        scope:true,
        link : function($scope, element) {
            $scope.saveMeta = function(snippetData) {
                DataikuAPI.ml.saveModelUserMeta(snippetData.fullModelId, snippetData.userMeta)
                            .error(setErrorInScope.bind($scope.$parent));
            }
        }
    }
});


app.filter('mlMetricFormat', function() {
    // probably 0 is suspicious in any metric but for already identified cases, we do not display 0
    var ignoreZerosForMetrics = [
        'INERTIA', // Inertia is missing for all but K-means, don't display it
        'RMSLE', // RMSLE cannot be computed sometimes (negative values in log)
    ];

    var usePercentageForMetrics = [
        'MAPE'
    ];

    return function(metricValue, metricName, precision, sigma, exp) {
        if ( (metricValue === undefined) || ('<No metric available>' == metricValue)) {
            return "-";
        }
        if (ignoreZerosForMetrics.indexOf(metricName) >= 0 && metricValue == 0) {
            return "-";
        }

        var percent = usePercentageForMetrics.indexOf(metricName) >= 0;
        var sigmaPrecision;
        var pc = '';

        if(typeof precision === 'number') {
            sigmaPrecision = precision;
        } else {
            precision = 4;
            sigmaPrecision = 2;
        }

        if (percent) {
            pc = '%';
            metricValue *= 100;
            sigma = (sigma || 0) * 100;
            precision = Math.max(1, precision - 2);
            sigmaPrecision = Math.max(1, sigmaPrecision - 2);
        }

        var abs = Math.abs(metricValue);
        if (abs >= 10000 && !percent)    { exp = true; }    // big numbers in exp notation
        else if (abs >= 100) { precision = 0; exp = false; } // medium numbers w/o decimals

        return (metricValue || 0)[exp ? 'toPrecision' : 'toFixed'](precision) + pc +
            (sigma ? ' <span class="sigma">(\u00b1\u00a0' + (2 * sigma)[exp ? 'toPrecision' : 'toFixed'](sigmaPrecision) + pc + ')</span>' : '');
    };
});

app.filter("mlMetricName", function($filter, PMLSettings, CMLSettings, Fn) {
    var allMetrics = angular.extend({},
            PMLSettings.names.evaluationMetrics,
            CMLSettings.names.evaluationMetrics);
    return function(input, snippetData){
        if (input == "CUMULATIVE_LIFT") {
            return $.isNumeric(snippetData.liftPoint) ? "Lift at " + Math.round(snippetData.liftPoint* 100) + "%" : "Lift";
        } else {
            return allMetrics[input] || $filter("niceConst")[input]
        }
    }
});

app.filter('mlScoreAssess', function() {
    var SCORES = { // all lowercase and attached for easy access
        auc: [ ["...too good to be true?", 1], ["excellent", .9], ["very good", .8], ["good", .7],
               ["fair", .6], ["not very good...", .5], ["worse than random guess :("] ],
        pearson: [ ["...too good to be true?", 1], ["very good", .8], ["good", .7], ["fair", .5], ["not very good..."] ],
        pvalue: [ ["\u2605\u2605\u2605", .001], ["\u2605\u2605\u2606", .01],
                  ["\u2605\u2606\u2606", .05 ], ["\u2606\u2606\u2606", 1] ]
    }, LOWER_BETTER = ['pvalue'];

    function test(k) {
        if (k.length === 1 || (this.lt ? this.score <= k[1] : this.score >= k[1])) {
            this.ret = k[0];
            return true;
        }
        return false;
    }

    return function(score, metric) {
        metric = metric.toLowerCase().split('_').join(''); // accomodate constants
        if (! metric in SCORES) { throw "Unkown metric: " + metric; }
        var ctx = { score: +score, grades: SCORES[metric], ret: null,
                lt: LOWER_BETTER.indexOf(metric) !== -1 };
        return ctx.grades.some(test, ctx) ? ctx.ret : "";
    };
});



app.filter('mlFeature', function($filter, Fn, FeatureNameUtils) {
    return function(input, asHtml) {
        if(asHtml){
            return FeatureNameUtils.getAsHtmlString(input);
        } else {
            return FeatureNameUtils.getAsText(input);
        }
    };
});

// FMI parsing methods should be equivalent to the ones defined in com.dataiku.dip.analysis.ml.FullModelId
app.service("FullModelIdUtils", function(){
    function parseAnalysisModel(fullModelId) {
        const analysisPattern = /^A-(\w+)-(\w+)-(\w+)-(s[0-9]+)-(pp[0-9]+(?:-part-(\w+)|-base)?)-(m[0-9]+)$/;
        const matchingResult = fullModelId.match(analysisPattern);
        if (!matchingResult) {
            throw new Error("Invalid analysis model id: " + fullModelId);
        } else {
            const [_, projectKey, analysisId, mlTaskId, sessionId, ppsId, partitionName, modelId] = matchingResult;
            return { projectKey, analysisId, mlTaskId, sessionId, ppsId, partitionName, modelId,
                partitionedBase: ppsId.endsWith('-base')};
        }
    }

    function parseSavedModel(fullModelId) {
        const savedModelPattern = /^S-(\w+)-(\w+)-(\w+)(?:-part-(\w+)-(v?\d+))?$/;
        const matchingResult = fullModelId.match(savedModelPattern);
        if (!matchingResult) {
            throw new Error("Invalid saved model id: " + fullModelId);
        } else {
            const [_, projectKey, savedModelId, versionId, partitionName, partitionVersion] = matchingResult;
            return { projectKey, savedModelId, versionId, partitionName, partitionVersion };
        }
    }

    function buildAnalysisModelFmi(fmiComponents) {
        // ppsId holds potential partition info
        return "A-{0}-{1}-{2}-{3}-{4}-{5}".format(fmiComponents.projectKey, fmiComponents.analysisId,
                                                 fmiComponents.mlTaskId, fmiComponents.sessionId,
                                                 fmiComponents.ppsId, fmiComponents.modelId);
    }

    function buildSavedModelFmi(fmiComponents) {
        let fmi = "S-{0}-{1}-{2}".format(fmiComponents.projectKey, fmiComponents.savedModelId, fmiComponents.versionId);
        if (fmiComponents.partitionName) {
            fmi += "-part-{0}-{1}".format(fmiComponents.partitionName, fmiComponents.partitionVersion);
        }
        return fmi;
    }

    function isAnalysis(fullModelId) {
        return fullModelId.startsWith("A");
    }

    function isSavedModel(fullModelId) {
        return fullModelId.startsWith("S");
    }

    function parse(fullModelId) {
        if (isAnalysis(fullModelId)) {
            return parseAnalysisModel(fullModelId);
        } else if (isSavedModel(fullModelId)) {
            return parseSavedModel(fullModelId);
        } else {
            throw new Error("Invalid model id: " + fullModelId);
        }
    }

    // Enforcing projectKey to be current Project and not the one hard coded in fullModelId
    // to prevent from breaking when changing projectKey of analysis (e.g. importing project
    // and changing projectKey)
    // See FullModelId.buildFmiWithEnforcedProjectKey() in the backend
    function parseWithEnforcedProjectKey(fmi, projectKey) {
        const elements = parse(fmi);
        elements.projectKey = projectKey;
        return {elements, fullModelId: buildAnalysisModelFmi(elements)};
    }

    return {
        parse: parse,
        getBase: function(fullModelId) {
            if (isAnalysis(fullModelId)) {
                const fmiComponents = parseAnalysisModel(fullModelId);
                fmiComponents.ppsId = fmiComponents.ppsId.replace(/-part-(\w+)/, "-base")
                return buildAnalysisModelFmi(fmiComponents);
            } else if (isSavedModel(fullModelId)) {
                const fmiComponents = parseSavedModel(fullModelId);
                delete fmiComponents.partitionName;
                return buildSavedModelFmi(fmiComponents);
            } else {
                throw new Error("Invalid model id: " + fullModelId);
            }
        },
        buildAnalysisModelFmi,
        buildSavedModelFmi,
        parseWithEnforcedProjectKey,
        isAnalysisPartitionBaseModel: function (fullModelId) {
            if (isAnalysis(fullModelId)) {
                const parts = parse(fullModelId);
                return parts.partitionedBase;
            }
            return false;
        },
        isPartition: function (fullModelId) {
            const parts = parse(fullModelId);
            return !angular.isUndefined(parts.partitionName);
        }
    }
});

app.controller("_ModelUtilsController", function($scope) {
    $scope.getAlgorithm = function(){
        if($scope.modelData &&
            $scope.modelData.actualParams &&
            $scope.modelData.actualParams.resolved &&
            $scope.modelData.actualParams.resolved.algorithm) {
            return $scope.modelData.actualParams.resolved.algorithm;
        } else if ($scope.modelData &&
            $scope.modelData.modeling &&
            $scope.modelData.modeling.algorithm) {
            return $scope.modelData.modeling.algorithm;
        }

    };

    $scope.isPartitionedModel = function() {
        return $scope.modelData
            && $scope.modelData.coreParams
            && $scope.modelData.coreParams.partitionedModel
            && $scope.modelData.coreParams.partitionedModel.enabled;
    };
});

app.controller("_ModelReportControllerBase", function($scope, $rootScope, $controller, $location, $timeout, DataikuAPI) {
    
    $controller("_ModelUtilsController", {$scope:$scope});

    DataikuAPI.analysis.mlcommon.getDiagnosticsDefinition().success(function(data) {
        $scope.diagnosticsDefinition = data;
    });

    $scope._selectPane = function() {
        $scope.uiState = $scope.uiState || {};

        if (!$scope.noUrlChange) {
            const stateChangeListener = $rootScope.$on('$stateChangeSuccess', (e, toState, toParams, fromState) => {
                if (fromState.name !== toState.name) {
                    $location.hash("").replace();
                    stateChangeListener();
                }
            });

            $scope.uiState.settingsPane = $location.hash() || 'summary';
            if ($location.hash() === '') {
                $location.hash($scope.uiState.settingsPane).replace();
            }
            $scope.$watch("uiState.settingsPane", function (nv, ov) {
                if (nv && ov && nv != ov) {
                    $location.hash(nv);
                }
            });
            $scope.$on("$locationChangeSuccess", function (angularEvent, newUrl, oldUrl) {
                var newHash = newUrl.split("#")[1];
                if (newHash) {
                    $scope.uiState.settingsPane = newHash;
                }
            })
        }
    };

    $scope.hooks = {};

});

app.controller('MLReportPreparationController', function($scope, Assert, ShakerProcessorsUtils) {
    Assert.inScope($scope, 'modelData');
    $scope.steps = $scope.modelData.trainedWithScript.steps;
    $scope.getStepDescription = ShakerProcessorsUtils.getStepDescription;
    $scope.getStepIcon        = ShakerProcessorsUtils.getStepIcon;
});


app.controller("_MLReportSummaryController", function($scope) {
    $scope.editState = {
        editing : false,
    }
    $scope.startEdit = function(){
        $scope.editState.editing = true;
        $scope.editState.name = $scope.modelData.userMeta.name;
        $scope.editState.description = $scope.modelData.userMeta.description;
    }
    $scope.cancelEdit = function(){
        $scope.editState.editing = false;
    }
    $scope.validateEdit = function() {
        $scope.modelData.userMeta.name = $scope.editState.name;
        $scope.modelData.userMeta.description = $scope.editState.description;
        $scope.editState.editing = false;
    }
});

app.controller("_ModelViewsController", function($scope, $rootScope, $state, $stateParams, $controller) {
    $scope.uiState = {};
    $scope.appConfig = $rootScope.appConfig;
    $scope.$state = $state;

    $scope.webAppConfig = {};
    $scope.webAppType = null;
    $scope.runningWebAppId = null;

    if ($stateParams.analysisId) {
        $controller("TrainedModelSkinsController", {$scope});
    } else {
        $controller("SavedModelVersionSkinsController", {$scope});
    }
});


app.controller("EvaluationLabelUtils", function($scope) {
    const DATASET_RE = /^[^:]*dataset:/i;
    const MODEL_RE = /^[^:]*model:/i;
    const EVALUATION_RE = /^[^:]*evaluation:/i;

    const DOMAIN_MAPPING = [
        {re: DATASET_RE, icon: "icon-dataset universe-color dataset"},
        {re: MODEL_RE, icon: "icon-machine_learning_regression universe-color saved_model"},
        {re: EVALUATION_RE, icon: "icon-model-evaluation-store universe-color saved_model"},
    ];

    $scope.setIcon = function(label) {
        if (label.key) {
            for (const mapping of DOMAIN_MAPPING) {
                if (mapping.re.test(label.key)) {
                    return mapping.icon;
                }
            }
        }
        return "icon-dku-edit";
    }
});

app.controller("PMLReportSummaryController", function($scope, $controller, DataikuAPI, PMLFilteringService, SmartId, StateUtils, $stateParams, ActiveProjectKey, Debounce, PMLSettings, $filter) {
    $controller("_MLReportSummaryController", {$scope:$scope});
    $controller("EvaluationLabelUtils", {$scope:$scope});

    const fullModelId = $stateParams.fullModelId || $scope.fullModelId;
    
    $scope.SmartId = SmartId;
    $scope.StateUtils = StateUtils;

    if ($scope.versionsContext) {
        $scope.$watch("versionsContext.activeMetric", function() {
            $scope.activeMetric = $scope.versionsContext.activeMetric;
        });
        $scope.activeMetric = $scope.versionsContext.activeMetric;
    } else if ($scope.mlTasksContext) {
        $scope.$watch("mlTasksContext.activeMetric", function() {
            $scope.activeMetric = $scope.mlTasksContext.activeMetric;
        });
        $scope.activeMetric = $scope.mlTasksContext.activeMetric;
    }

    $scope.getMetricValueFromModel = PMLFilteringService.getMetricValueFromModel.bind(PMLFilteringService);

    $scope.saveModelUserMeta = function(nv, ov) {
        if ((ov != nv) || nv && !_.isEqual(nv.labels, ov.labels)) {
            DataikuAPI.ml.saveModelUserMeta(fullModelId, $scope.modelData.userMeta)
                                .error(setErrorInScope.bind($scope));
        }
    }
    $scope.saveEvaluationLabels = function(nv, ov) {
        if ((ov != nv) || nv && !_.isEqual(nv, ov)) {
            let fme = makeFullModelEvalutionIdString(ActiveProjectKey.get(), $stateParams.mesId, $stateParams.runId);
            DataikuAPI.modelevaluations.saveEvaluationLabels(fme, $scope.modelData.modelEvaluation.labels)
                .error(setErrorInScope.bind($scope));
        }
    }

    $scope.refreshMetrics = function(predictionType) {
        $scope.possibleMetrics = [];
        if (!predictionType) {
            return;
        }
    
        let toDropdownElems = function(a) {
            return a.map(function(m) { return [m, PMLSettings.names.evaluationMetrics[m]] });
        };
        if ('BINARY_CLASSIFICATION' === predictionType) {
            $scope.possibleMetrics.push([null, 'Binary classification']);
            $scope.possibleMetrics = $scope.possibleMetrics.concat(toDropdownElems(['ACCURACY', 'PRECISION', 'RECALL', 'F1', 'COST_MATRIX', 'LOG_LOSS', 'ROC_AUC', 'CALIBRATION_LOSS', 'CUMULATIVE_LIFT', 'CUSTOM']));
        }
        if ('MULTICLASS' === predictionType) {
            $scope.possibleMetrics.push([null, 'Multiclass classification']);
            $scope.possibleMetrics = $scope.possibleMetrics.concat(toDropdownElems(['ACCURACY', 'PRECISION', 'RECALL', 'F1', 'LOG_LOSS', 'ROC_AUC', 'CALIBRATION_LOSS', 'CUSTOM']));
        }
        if ('REGRESSION' === predictionType) {
            $scope.possibleMetrics.push([null, 'Regression']);
            $scope.possibleMetrics = $scope.possibleMetrics.concat(toDropdownElems(['EVS', 'MAPE', 'MAE', 'MSE', 'RMSE', 'RMSLE', 'R2', 'PEARSON', 'CUSTOM']));
        }
        if ($scope.uiState.currentMetric && $scope.possibleMetrics.filter(_ => _[0] == $scope.uiState.currentMetric).length == 0) {
            // old selected metric isn't possible anymore
            $scope.uiState.currentMetric = null;
        }
        if ($scope.uiState.currentMetric == null) {
            if ('BINARY_CLASSIFICATION' === predictionType) {
                $scope.uiState.currentMetric = 'ROC_AUC';
            }
            if ('MULTICLASS' === predictionType) {
                $scope.uiState.currentMetric = 'ROC_AUC';
            }
            if ('REGRESSION' === predictionType) {
                $scope.uiState.currentMetric = 'R2';
            }
        }
        $scope.uiState.currentMetrics = $scope.possibleMetrics.map(pm => pm[0]).filter(x => x);
        $scope.refreshCurrentMetricNames();
    }

    $scope.refreshCurrentMetricNames = function() {
        if ($scope.uiState.currentMetrics) {
            $scope.uiState.currentFormattedNames = $scope.uiState.currentMetrics.map(cur => {
                return {
                    key: PMLFilteringService.metricMap[cur],
                    label: $scope.possibleMetrics.find(x => x[0] === cur)[1],
                    code: cur
                };
            });
        } else {
            $scope.uiState.currentFormattedNames = [];
        }
        $scope.refreshMetricsValues();
    }

    $scope.getMetricValue = function(metrics,metricCode) {
        return $filter('nicePrecision')(metrics[PMLFilteringService.metricMap[metricCode]],2);
    }

    $scope.refreshMetricsValues = function() {
        let metrics = ($scope.evaluation&&$scope.evaluation.metrics)?$scope.evaluation.metrics:null;

        $scope.uiState.formattedMetrics = {};
        if (!metrics || !Object.keys(metrics).length) {
            $scope.uiState.noperf = true;
            return;
        }

        for (let metricCode of $scope.uiState.currentMetrics) {
            $scope.uiState.formattedMetrics[PMLFilteringService.metricMap[metricCode]] = $scope.getMetricValue(metrics, metricCode);
        }
    }

    $scope.$watch("modelData", () => {
        if ($scope.modelData) $scope.refreshMetrics($scope.modelData.coreParams.prediction_type)
    });

    $scope.$watch("modelData.userMeta.labels", Debounce().withDelay(400, 1000).wrap($scope.saveModelUserMeta));
    $scope.$watch("modelData.modelEvaluation.labels", Debounce().withDelay(400, 1000).wrap($scope.saveEvaluationLabels));
});

app.controller("PartPMLReportSummaryController", function($scope, $controller, $stateParams, DataikuAPI) {
    $controller("PMLReportSummaryController", {$scope: $scope});
    $controller('_SubpopTableUtilsController', {$scope: $scope});

    $scope.dimensionsList = function() {
        return $scope.modelData.coreParams.partitionedModel.dimensionNames
            .map(dim => `<b>${sanitize(dim)}</b>`)
            .join(' and ');
    };

    $scope.getCurrentFeatureData = () => {
        return $scope.partitionsPerf;
    };

    const mergeSnippetsWithModalities = (data, snippets) => {
        data.modalities.forEach((modality) => {
            let snippet;
            if (modality.value && modality.value in snippets.partitions.summaries) {
                snippet = snippets.partitions.summaries[modality.value].snippet;
                // 'status' corresponds:
                //  * for ANALYSIS, to trainInfo.state (ModelTrainState)
                //  * for SAVED, to trainInfo.state if partition was trained or REUSED_... if partition was reused (PartitionState)
                snippet["status"] = snippets.partitions.summaries[modality.value].state;
                modality.snippet= snippet;
            }
        });

        data.allDatasetModality.snippet = snippets;
    };

    const getThreshold = (snippets) => (mod) => {
        if (mod.value && mod.value in snippets.partitions.summaries) {
            const partSnippet = snippets.partitions.summaries[mod.value].snippet;
            if (partSnippet && partSnippet.userMeta) {
                return partSnippet.userMeta.activeClassifierThreshold;
            }
        }

        return snippets.baseModel;
    };

    const preparePartitionsPerf = (partSnippets) => {
        DataikuAPI.ml.prediction.getPartitionsPerf(partSnippets.fullModelId)
            .then(resp => {
                $scope.formatTableResults(resp.data, resp.data.allDatasetPerf, getThreshold(partSnippets));
                mergeSnippetsWithModalities(resp.data, partSnippets);

                $scope.partitionsPerf = resp.data;
            }, setErrorInScope.bind($scope));
    };

    $scope.$watch('partitionedModelSnippets', function(partSnippets) {
        if (!partSnippets) {
            return;
        }

        preparePartitionsPerf(partSnippets);
    });
});

app.controller("PMLReportDriftController", function($scope, $controller, $stateParams, DataikuAPI, ActiveProjectKey, FutureProgressModal, ModelEvaluationUtils, WT1) {
    $scope.fullModelId = $stateParams.fullModelId || $scope.fullModelId;
    $scope.mesId = $stateParams.mesId;
    $scope.runId = $stateParams.runId;
    $scope.driftState.dataDriftResult = undefined;
    $scope.uiState = {
        selectedReference: null,
        refDensityData: null,
        pdd: null,
        currentClass: null,
        refPredValueCount: null,
        curPredValueCount: null,
        pdfs: null
    };

    $scope.dataDriftParams = {
        nbBins: 20,
        confidenceLevel: 0.95,
        psiThreshold: 0.2,
        columns: {} // Full auto by default
    };

    $scope.colors = window.dkuColorPalettes.discrete[0].colors.filter((_,idx) => idx%2 === 0);

    $scope.computePddForClass = function(className) {
        $scope.driftState.pdd = null;
        if ($scope.driftState.refDensityData && (className != null) && Object.keys($scope.driftState.refDensityData).length
            && Object.keys($scope.evaluation.details.perf.densityData).length) {
            $scope.driftState.pdd = {};
            let dd = $scope.driftState.refDensityData[className];
            let dd2 = $scope.evaluation.details.perf.densityData[className];
            let dd_values = dd.correct.map((val, idx) => val + dd.incorrect[idx]);
            let dd2_values = dd2.correct.map((val, idx) => val + dd2.incorrect[idx]);
            $scope.driftState.pdd.x = dd.correct.map(function(_, i, a) { return i / a.length; });
            $scope.driftState.pdd.ys = [dd_values, dd2_values];
            $scope.driftState.pdd.labels = ['class ' + className + ' reference', 'class ' + className + ' current'];
            $scope.driftState.pdd.colors = $scope.colors.slice(0, 2).concat("#9467bd");
        } else {
            $scope.driftState.pdd = null;
        }
    }

    $scope.computePredictionHistogram = function() {
        const source = [['Class', 'Current', 'Reference']];
        for (const currentClass of $scope.driftState.classes) {
            source.push([
                currentClass,
                $scope.driftState.curPredValueCount[currentClass].pct,
                $scope.driftState.refPredValueCount[currentClass].pct
            ]);
        }
        const colors = window.dkuColorPalettes.discrete[0].colors.filter((x,idx) => idx%2 === 0)
        $scope.driftState.predHistogramOptions = {
            tooltip: {},
            dataset: {
                source
            },
            xAxis: {type: 'category', name: 'Predicted class', nameLocation: 'middle', nameGap: 25},
            yAxis: {name: '% of predicted classes', nameLocation: 'middle', nameGap: 25},
            series: [
                {type: 'bar', color: colors[0]},
                {type: 'bar', color: colors[1]}
            ]
        }
    }

    $scope.computeDataDrift = function() {
        const referenceId = makeModelLikeIDStringFromObject($scope.driftState.selectedReference.ref);
        const currentId = makeFullModelEvalutionIdString(ActiveProjectKey.get(), $stateParams.mesId, $stateParams.runId);
        WT1.event("compute-drift")
        const promise = DataikuAPI.modelevaluations.computeDataDrift(ActiveProjectKey.get(), referenceId, currentId, $scope.dataDriftParams);
        const copiedParams = angular.copy($scope.dataDriftParams);
        promise.success((result) => {
            $scope.driftState.univariateCols = [];
            FutureProgressModal.show($scope, result, "Computing Data Drift").then((driftResults) => {
                $scope.driftState.dataDriftResult = driftResults;
                $scope.driftState.dataDriftParamsOfResult = copiedParams;
                generateDriftVersusImportanceChart();
            });
        }).error(setErrorInScope.bind($scope));

        return promise;
    }

    function getPerfValueCountFromPerCutData(cutToFind, pcd) {
        if (!pcd) {
            return;
        }
        let i = 0;
        let iMax = pcd.cut.length - 1;
        if (cutToFind >= pcd.cut[iMax]) {
            i = iMax;
        } else {
            while (pcd.cut[i] < cutToFind && i <= iMax) {
                i++;
            }
        }
        var tp = pcd.tp[i], tn = pcd.tn[i], fp = pcd.fp[i], fn = pcd.fn[i];
        var predPos = tp + fp;
        var predNeg = tn + fn;
        var ret = {};
        ret[$scope.driftState.classes[1]] = { records: predPos, pct: ((100.*predPos)/(predPos+predNeg)).toFixed(2) };
        ret[$scope.driftState.classes[0]] = { records: predNeg, pct: ((100.*predNeg)/(predPos+predNeg)).toFixed(2) };
        return ret;
    }

    function getPerfValueCountFromConfusion(confusion) {
        if (!confusion) {
            return;
        }
        let ret = {};
        for (const currentClass of $scope.driftState.classes) {
            ret[currentClass] = { records: 0 };
        }

        for (const actualClass in confusion.perActual) {
            for(let predictedClass in confusion.perActual[actualClass].perPredicted) {
                ret[predictedClass].records += confusion.perActual[actualClass].perPredicted[predictedClass];
            }
        }

        const count = confusion.totalRows;
        for (const currentClass of $scope.driftState.classes) {
            ret[currentClass].pct = ((100.*ret[currentClass].records) / count).toFixed(2);
        }
        return ret;
    }

    function getPerfValueCountFromSavedModel(data) {
        if (data.perf && data.perf.perCutData) {
            return getPerfValueCountFromPerCutData(data.userMeta.activeClassifierThreshold, data.perf.perCutData);
        }
        return getPerfValueCountFromConfusion(data.perf.confusion);
    }

    function getPerfValueCountFromEvaluation(data) {
        if (data.evaluation.details.perf && data.evaluation.details.perf.perCutData) {
            return getPerfValueCountFromPerCutData(data.evaluation.details.userMeta.activeClassifierThreshold, data.evaluation.details.perf.perCutData);
        }

        let ret = {};
        const tops = data.evaluation.evaluatedDataStatistics.univariate[data.evaluation.evaluation.predictionVariable].top;
        const nbRows = data.evaluation.evaluatedDataStatistics.nbRows;
        for (let curClass of $scope.driftState.classes) {
            let topClass = tops.find(t => t.value === curClass);
            if (!topClass) {
                ret[curClass] = { records: 0, pct: 0. };
            } else {
                ret[curClass] = { records: topClass.count, pct: ((topClass.count*100.)/nbRows).toFixed(2) };
            }
        }
        return ret;
    }

    function generateDriftVersusImportanceChart() {
        if(!$scope.driftState.dataDriftResult.driftModelResult.driftVersusImportance.columnImportanceScores) {
            $scope.driftVersusImportanceChart = null;
            return;
        }

        $scope.driftVersusImportanceChart = {
            animation: false,
            tooltip: {
                trigger: 'item',
                axisPointer: { type: 'cross', label: { formatter: ({value})=> Math.round(100 * value) + '%'  } }
            },
            grid: { left: 40, top: 20, right: 20, bottom: 30, containLabel: true },
            xAxis: {
                type: 'value',
                min: 0,
                name: "Drift model feature importance (%)",
                nameLocation: "middle",
                nameGap: 30,
                axisLabel: { formatter: value => Math.round(100 * value) + '%' }
            },
            yAxis: {
                type: 'value',
                min: 0,
                name: "Original model feature importance (%)",
                nameLocation: "middle",
                nameGap: 40,
                axisLabel: { formatter: value => Math.round(100 * value) + '%' }
            },
            series: {
                type: 'scatter',
                symbolSize: 10,
                data: _.zip(
                    $scope.driftState.dataDriftResult.driftModelResult.driftVersusImportance.columnDriftScores,
                    $scope.driftState.dataDriftResult.driftModelResult.driftVersusImportance.columnImportanceScores,
                    $scope.driftState.dataDriftResult.driftModelResult.driftVersusImportance.columns,
                ),
                tooltip: {
                    formatter: ({value}) => '<b>Column: '+sanitize(value[2])+'</b><br>'
                            + 'Drift model feature importance: '+ Math.round(100 * value[0]) + '%<br>'
                            + 'Original model feature importance: '+ Math.round(100 * value[1]) + '%<br>'
                },
                itemStyle: {
                    color: value => dkuColorPalettes.discrete[0].colors[value.dataIndex % dkuColorPalettes.discrete[0].colors.length]
                }
            }
        };
    }

    $scope.isPvalueRejected = function(pvalue) {
        const confidenceLevel = $scope.driftState.dataDriftParamsOfResult && $scope.driftState.dataDriftParamsOfResult.confidenceLevel;
        if(confidenceLevel == null) {
            return false;
        }
        const significanceLevel = 1 - confidenceLevel;
        if (pvalue != null) {
            return pvalue <= significanceLevel;
        }
        return false;
    }

    $scope.isPSIAboveThreshold = function(psi) {
        const threshold = $scope.driftState.dataDriftParamsOfResult && $scope.driftState.dataDriftParamsOfResult.psiThreshold;
        if ((threshold != null) && (psi != null)) {
            return psi > threshold;
        }
        return false;
    }

    $scope.isDriftDetected = function() {
        return $scope.driftState.dataDriftResult
            && $scope.driftState.dataDriftResult.driftModelResult.driftModelAccuracy.pvalue <= (1 - $scope.dataDriftParams.confidenceLevel);
    }

    function listClassesFromPreprocessing(preprocessing) {
        return preprocessing.target_remapping.map(mapping => mapping.sourceValue);
    }

    $scope.computePredictionDrift = function() {
        if ("DOCTOR_MODEL_EVALUATION" === $scope.driftState.selectedReference.refType) {
            DataikuAPI.ml.prediction.getModelDetails(makeFullModelIdStringFromObject($scope.driftState.selectedReference.ref)).success(function(data) {
                if ("REGRESSION" === $scope.evaluation.evaluation.predictionType) {
                    let xs = [];
                    let ys = [];
                    let labels = [];
                    const refDataAvailable = data.perf && data.perf.predictionPDF;
                    const curDataAvailable = $scope.evaluation.details.perf && $scope.evaluation.details.perf.predictionPDF;
                    if (refDataAvailable) {
                        xs.push(data.perf.predictionPDF.x);
                        ys.push(data.perf.predictionPDF.pdf)
                        labels.push('Reference');
                    }
                    if (curDataAvailable) {
                        xs.push($scope.evaluation.details.perf.predictionPDF.x);
                        ys.push($scope.evaluation.details.perf.predictionPDF.pdf)
                        labels.push('Current');
                    }
                    $scope.driftState.unavailableReference = !refDataAvailable;
                    $scope.driftState.unavailableCurrent = !curDataAvailable;

                    $scope.driftState.pdfs = {
                        xs: xs,
                        ys: ys,
                        colors: $scope.colors.slice(0, 2),
                        labels: labels
                    };
                } else {
                    const refDataAvailable = data.perf && data.perf.densityData;
                    const curDataAvailable = $scope.evaluation.details.perf && $scope.evaluation.details.perf.densityData;
                    $scope.driftState.unavailableReference = !refDataAvailable;
                    $scope.driftState.unavailableCurrent = !curDataAvailable;

                    if(refDataAvailable && curDataAvailable) {
                        $scope.driftState.refDensityData = data.perf.densityData;
                        const refClasses = listClassesFromPreprocessing(data.preprocessing);
                        const curClasses = listClassesFromPreprocessing($scope.evaluation.details.preprocessing);
                        $scope.driftState.classes = _.sortedUniq(_.sortBy(refClasses.concat(curClasses)));
                        $scope.driftState.currentClass = $scope.driftState.classes[0];
                        $scope.computePddForClass($scope.driftState.classes[0]);
                        $scope.driftState.refPredValueCount = getPerfValueCountFromSavedModel(data);
                        $scope.driftState.curPredValueCount = getPerfValueCountFromEvaluation($scope);
                        $scope.computePredictionHistogram();
                    }
                }
            }).error(setErrorInScope.bind($scope));
        } else if ("MODEL_EVALUATION" === $scope.driftState.selectedReference.refType) {
            DataikuAPI.modelevaluationstores.getEvaluation($scope.driftState.selectedReference.ref.projectKey,
                                                            $scope.driftState.selectedReference.ref.id,
                                                            $scope.driftState.selectedReference.ref.runId).success(function(data) {
                if ("REGRESSION" === $scope.evaluation.evaluation.predictionType) {
                    let xs = [];
                    let ys = [];
                    let labels = [];
                    const refDataAvailable = data.evaluation.details.perf && data.evaluation.details.perf.predictionPDF;
                    const curDataAvailable = $scope.evaluation.details.perf && $scope.evaluation.details.perf.predictionPDF;
                    if (refDataAvailable) {
                        xs.push(data.evaluation.details.perf.predictionPDF.x);
                        ys.push(data.evaluation.details.perf.predictionPDF.pdf)
                        labels.push('Reference');
                    }
                    if (curDataAvailable) {
                        xs.push($scope.evaluation.details.perf.predictionPDF.x);
                        ys.push($scope.evaluation.details.perf.predictionPDF.pdf)
                        labels.push('Current');
                    }
                    $scope.driftState.unavailableReference = !refDataAvailable;
                    $scope.driftState.unavailableCurrent = !curDataAvailable;

                    $scope.driftState.pdfs = {
                        xs: xs,
                        ys: ys,
                        colors: $scope.colors.slice(0, 2),
                        labels: labels
                    };
                } else {
                    const refDataAvailable = data.evaluation.details.perf && data.evaluation.details.perf.densityData;
                    const curDataAvailable = $scope.evaluation.details.perf && $scope.evaluation.details.perf.densityData;
                    $scope.driftState.unavailableReference = !refDataAvailable;
                    $scope.driftState.unavailableCurrent = !curDataAvailable;

                    if(refDataAvailable && curDataAvailable) {
                        $scope.driftState.refDensityData = data.evaluation.details.perf.densityData;
                        const refClasses = listClassesFromPreprocessing(data.evaluation.details.preprocessing);
                        const curClasses = listClassesFromPreprocessing($scope.evaluation.details.preprocessing);
                        $scope.driftState.classes = _.sortedUniq(_.sortBy(refClasses.concat(curClasses)));
                        $scope.driftState.currentClass = $scope.driftState.classes[0];
                        $scope.computePddForClass($scope.driftState.classes[0]);
                        $scope.driftState.refPredValueCount = getPerfValueCountFromEvaluation(data);
                        $scope.driftState.curPredValueCount = getPerfValueCountFromEvaluation($scope);
                        $scope.computePredictionHistogram();
                    }
                }
            }).error(setErrorInScope.bind($scope));
        }
    }

    DataikuAPI.modelevaluationstores.listWithAccessible(ActiveProjectKey.get()).success(function(data){
        $scope.storeList = data;
    });
    DataikuAPI.savedmodels.listWithAccessible($stateParams.projectKey).success(function(data){
        $scope.modelList = data;
    });

    $scope.computePerformanceDrift = function() {
        if ("DOCTOR_MODEL_EVALUATION" === $scope.driftState.selectedReference.refType) {
            DataikuAPI.modelevaluations.getFMIEvaluationInfo($stateParams.projectKey, makeFullModelIdStringFromObject($scope.driftState.selectedReference.ref)).success(function(data) {
                let ref = ModelEvaluationUtils.makeRefDisplayItemFromFMInfo(data, $scope.modelList);
                ref.metrics = data.metrics;
                let cur = ModelEvaluationUtils.makeRefDisplayItemFromEvaluation($scope.evaluation.evaluation, $scope.storeList);
                cur.metrics = $scope.evaluation.metrics;
                $scope.driftState.perfDriftRefs = [cur, ref];
            }).error(setErrorInScope.bind($scope));
        } else if ("MODEL_EVALUATION" === $scope.driftState.selectedReference.refType) {
            DataikuAPI.modelevaluationstores.getEvaluation($scope.driftState.selectedReference.ref.projectKey,
                                                            $scope.driftState.selectedReference.ref.id,
                                                            $scope.driftState.selectedReference.ref.runId).success(function(data) {
                let ref = ModelEvaluationUtils.makeRefDisplayItemFromEvaluation(data.evaluation.evaluation, $scope.storeList);
                ref.metrics = data.evaluation.metrics;
                let cur = ModelEvaluationUtils.makeRefDisplayItemFromEvaluation($scope.evaluation.evaluation, $scope.storeList);
                cur.metrics = $scope.evaluation.metrics;
                $scope.driftState.perfDriftRefs = [cur, ref];

            }).error(setErrorInScope.bind($scope));
        }
    }

    $scope.getColumnParams = function(columnName) {
        const params = $scope.dataDriftParams.columns[columnName];
        return params ? params : { handling: 'AUTO', enabled: true };
    }

    $scope.changeColumnEnabled = function(columnName, enabled) {
        const previousColumnParams = $scope.getColumnParams(columnName);
        const newColumnParams = { ... previousColumnParams, enabled };

        $scope.changeColumnParams(columnName, newColumnParams);
    }

    $scope.changeColumnParams = function(columnName, newColumnParams) {
        $scope.dataDriftParams.columns[columnName] = newColumnParams;
        $scope.computeDataDrift();
    }

    $scope.changeColumnHandling = function(columnName, handling) {
        const previousColumnParams = $scope.getColumnParams(columnName);
        const newColumnParams = { ... previousColumnParams, handling };

        $scope.changeColumnParams(columnName, newColumnParams);
    }

    $scope.driftingColumns = function() {
        let driftingColumns = [];
        for (const [columnName, columnDrift] of Object.entries($scope.driftState.dataDriftResult.univariateDriftResult.columns)) {
            if($scope.isPvalueRejected(columnDrift.chiSquareTestPvalue)
                || $scope.isPvalueRejected(columnDrift.ksTestPvalue)
                || $scope.isPSIAboveThreshold(columnDrift.populationStabilityIndex)) {
                    driftingColumns.push(columnName);
                }
        }
        return driftingColumns;
    }

    $scope.sortValue = function(sortColumn) {
        return columnReport => {
            const univariateResult = $scope.driftState.dataDriftResult.univariateDriftResult.columns[columnReport.name];
            if(univariateResult && univariateResult[sortColumn] != null) {
                return univariateResult[sortColumn];
            }
            return columnReport[sortColumn];
        };
    }

    $scope.$watch('driftState.currentClass', function(nv) {
        $scope.computePddForClass(nv);
    });

    $scope.perfDriftLabel = function(item) {
        return item.perfDriftLabel;
    }

    $scope.preselectBestReferences = function() {
        if ($scope.driftState.selectedReference || !$scope.currentMEReference) {
            return;
        }
        if (!$scope.compatibleReferences || !$scope.compatibleReferences.length) {
            return;
        }
        const matchingReferences = $scope.compatibleReferences.filter(cr => (cr.trainDataSetName === $scope.currentMEReference.trainDataSetName)
            && (cr.modelName === $scope.currentMEReference.modelName));
            if (matchingReferences && matchingReferences.length) {
            let matchingSavedModels = matchingReferences.find(cr => "DOCTOR_MODEL_EVALUATION" === cr.refType);
            if (matchingSavedModels && matchingSavedModels.length) {
                matchingSavedModels.sort((sm1,sm2) => sm1.trainDataSetOrder < sm2.trainDataSetOrder);
                $scope.driftState.selectedReference = matchingSavedModels[matchingSavedModels.length - 1];
            } else {
                $scope.driftState.selectedReference = matchingReferences[matchingReferences.length-1];
            }
        }
    }


    $scope.displayParams = null;
    $scope.cloneDisplayParams = function() {
        $scope.displayParams = angular.copy($scope.modelEvaluationStore.displayParams);
    }

    $scope.$watch('compatibleReferences', $scope.preselectBestReferences);

    $scope.$watch('modelEvaluationStore.displayParams', $scope.cloneDisplayParams);
});

app.service("ModelEvaluationUtils", function($stateParams) {
    function addOrderToTitle(title, order) {
        if (!title) {
            return null;
        }
        if (!order) {
            return title;
        }
        if (!isNaN(order)) {
            let intOrder = parseInt(order);
            if (intOrder > 1451606400) // 2016/1/1 00:00:00
                return title + " " + moment(intOrder).format("YYYY-MM-DD HH:mm:ss");
        }
        return title + " " + order;
    }

    function processDatasetOrder(datasetParams) {
        return processOrder(datasetParams.generationDate);
    }

    function processOrder(order) {
        if (!order) {
            return null;
        }
        if (!isNaN(order)) {
            let intOrder = parseInt(order);
            if (intOrder > 1451606400) // 2016/1/1 00:00:00
                return moment(intOrder).format("YYYY-MM-DD HH:mm:ss");
            return intOrder;
        }
        return order;
    }

    var makeRefDisplayItemFromEvaluation = function (evaluation, storeList) {
        if (!evaluation) {
            return null;
        }
        if (!storeList) {
            storeList = [];
        }
        let modelUniqueId = null;
        const trainDataSetOrder = evaluation.trainDataParams?processDatasetOrder(evaluation.trainDataParams):null;
        let trainDataSetName = (evaluation.trainDataParams && evaluation.trainDataParams.datasetName)?evaluation.trainDataParams.datasetName: "Unknown train dataset";
        trainDataSetName = addOrderToTitle(trainDataSetName, trainDataSetOrder);

        const modelOrder = (evaluation.modelParams && evaluation.modelParams.trainEndTime)?processOrder(evaluation.modelParams.trainEndTime):null;
        let modelName = (evaluation.modelParams && evaluation.modelParams.versionName)?evaluation.modelParams.versionName:"Unknown model";
        if ("SAVED_MODEL" === evaluation.modelType) {
            modelUniqueId = "S-" + evaluation.ref.projectKey + "-" + evaluation.modelParams.ref + "-" + evaluation.modelParams.versionId;
        }

        // cheating a bit : setting evaluation dataset generation date to evaluation creation date - which is right as of now
        evaluation.dataParams.generationDate = evaluation.created;
        const evaluationDataSetOrder = evaluation.dataParams?processDatasetOrder(evaluation.dataParams):null;
        let evaluationDatasetName = (evaluation.dataParams && evaluation.dataParams.ref)?evaluation.dataParams.ref:"Unknown test dataset";
        evaluationDatasetName = addOrderToTitle(evaluationDatasetName, evaluationDataSetOrder);

        const store = storeList.find(s => (s.id === evaluation.ref.id) && (s.projectKey === evaluation.ref.projectKey));
        const storeStr = (store ? store.name : evaluation.ref.id) + ($stateParams.projectKey == evaluation.ref.projectKey ? '' : ` in ${evaluation.ref.projectKey}`);
        const isFromCurrentMES = $stateParams.projectKey == evaluation.ref.projectKey && $stateParams.mesId == evaluation.ref.id;

        return {
            trainDataSetName: trainDataSetName,
            trainDataSetOrder: trainDataSetOrder,
            evaluationDatasetName: evaluationDatasetName,
            evaluationDataSetOrder: evaluationDataSetOrder,
            modelName: modelName,
            modelUniqueId: modelUniqueId,
            modelOrder: modelOrder,
            runId: evaluation.ref.runId,
            ref: evaluation.ref,
            refStr: `${evaluation.ref.runId}` + (isFromCurrentMES ? '' : ` (store: ${storeStr})`),
            refType: "MODEL_EVALUATION",
            labels: evaluation.labels.reduce((map, obj) => {
                    map.set(obj.key, obj.value);
                    return map;
                }, new Map())
        };
    };

    var makeRefDisplayItemFromFMInfo = function(smInfo, savedModelList) {
        if (!savedModelList) {
            savedModelList = [];
        }
        const trainDataSetOrder = smInfo.trainDataParams?processDatasetOrder(smInfo.trainDataParams):null;
        let trainDataSetName = (smInfo.trainDataParams && smInfo.trainDataParams.datasetName)?smInfo.trainDataParams.datasetName: "Unknown train dataset";
        trainDataSetName = addOrderToTitle(trainDataSetName, trainDataSetOrder);

        const modelOrder = (smInfo.modelParams && smInfo.modelParams.trainEndTime)?processOrder(smInfo.modelParams.trainEndTime):null;
        let modelName = (smInfo.modelParams && smInfo.modelParams.versionName)?smInfo.modelParams.versionName:"Unknown model";

        const sm = savedModelList.find(s => (s.id === smInfo.ref.smId) && (s.projectKey === smInfo.ref.projectKey));
        const smStr = (sm ? sm.name : smInfo.ref.smId) + ($stateParams.projectKey == smInfo.ref.projectKey ? '' : ` in ${smInfo.ref.projectKey}`);

        const labels = smInfo.labels?smInfo.labels.reduce((map, obj) => {
                map.set(obj.key, obj.value);
                return map;
            }, new Map()):new Map();
        return {
            trainDataSetName: trainDataSetName,
            trainDataSetOrder: trainDataSetOrder,
            evaluationDatasetName: null,
            evaluationDataSetOrder: -1, // ###TODO change this
            modelName: modelName,
            modelOrder: modelOrder,
            modelUniqueId: smInfo.ref.fullId,
            ref: smInfo.ref,
            refStr: `${smStr}, version ${smInfo.ref.smVersionId}`,
            refType: "DOCTOR_MODEL_EVALUATION",
            labels: labels
        };
    };

    var makeRefDisplayItemFromModelLikeInfo = function(mli, storeList, savedModelList) {
        if (!mli) {
            return null;
        }
        if (mli instanceof Array) {
            return mli.map(cur => makeRefDisplayItemFromModelLikeInfo(cur, storeList, savedModelList));
        }
        if ("DOCTOR_MODEL_EVALUATION" === mli.modelLikeType) {
            return makeRefDisplayItemFromFMInfo(mli, savedModelList);
        } else if("MODEL_EVALUATION" === mli.modelLikeType) {
            return makeRefDisplayItemFromEvaluation(mli, storeList);
        } else {
            throw new Error(`Unknown model-like type ${mli.modelLikeType}`) ;
        }
    }

    var computeReferenceLabels = function(references) {
        if (!references || !references.length) {
            return [];
        }
        let labeledReferences = references.map(r => {
            if ("DOCTOR_MODEL_EVALUATION" === r.refType) {
                r.inputDriftLabel = `Dataset ${r.trainDataSetName} used to train model ${r.modelName}`;
                r.perfDriftLabel = `Model ${r.modelName} trained on ${r.trainDataSetName}`;
            } else if ("MODEL_EVALUATION" === r.refType) {
                r.inputDriftLabel  = `Dataset ${r.evaluationDatasetName} used to evaluate Model ${r.modelName} trained on ${r.trainDataSetName}`;
                r.perfDriftLabel = `Model ${r.modelName} trained on ${r.trainDataSetName} evaluated on ${r.evaluationDatasetName}`;
            } else {
                throw new Error(`Unknown model-like type ${r.refType}`) ;
            }
            r.inputDriftLabel += ` (${r.refStr})`;
            r.perfDriftLabel += ` (${r.refStr})`;
            return r;
        });
        return labeledReferences;
    }

    return {
        makeRefDisplayItemFromEvaluation,
        makeRefDisplayItemFromFMInfo,
        makeRefDisplayItemFromModelLikeInfo,
        computeReferenceLabels
    };
});

})();

(function(){
'use strict';

var app = angular.module('dataiku.ml.core');

app.factory("MLChartsCommon", function() {

    function linspace(start, end, n) {
        if (n === 1) {
            return [start];
        }
        return Array.from(Array(n), (_, i) => start + (i * (end - start)) / (n - 1));
    }

    // TODO: replace trimTrailingZeros with '~' based formatter when updating d3js version to 5+ (e.g. d3.format(".4~g"))
    // From https://github.com/d3/d3-format/blob/v2.0.0/src/formatTrim.js (incorporated in d3 in version 5)
    function trimTrailingZeros(s) {
        out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
            switch (s[i]) {
                case '.':
                    i0 = i1 = i;
                    break;
                case '0':
                    if (i0 === 0) i0 = i;
                    i1 = i;
                    break;
                default:
                    if (!+s[i]) break out;
                    if (i0 > 0) i0 = 0;
                    break;
            }
        }
        return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }

    /**
     * Returns a numeric formatter function in exponent notation, with maximum `fractionDigits` after the decimal point
     * @param {number} fractionDigits : Maximum number of digits after the decimal point (integer)
     */
    function exponentFormat(fractionDigits) {
        return (_) => trimTrailingZeros(d3.format(`.${fractionDigits}e`)(_));
    }

    /**
     * Returns a numeric formatter function in fixed point notation, with maximum `fractionDigits` after the decimal point
     * @param {number} fractionDigits : Maximum number of digits after the decimal point (integer)
     */
    function fixedPointFormat(fractionDigits) {
        return (_) => trimTrailingZeros(d3.format(`.${fractionDigits}f`)(_));
    }

    /**
     * Returns a numeric formatter function in decimal notation, rounded to `significantDigits` significant digits
     * @param {number} significantDigits : Maximum number of significant digits (integer)
     */
    function decimalRoundedFormat(significantDigits) {
        return (_) => trimTrailingZeros(d3.format(`.${significantDigits}r`)(_));
    }

    /**
     * Returns a numeric formatter function, mostly useful for axes.
     * It behaves in the following way:
     *  - For extreme values higher than 10**(exponentThreshold) or lower than 10**(-exponentThreshold) we use the exponent
     *    notation with exponentFractionDigits digits after the decimal point
     *  - Otherwise we use fixed point notation and make sure that our formatter is precise enough by computing the order of
     *    magnitude of the difference between min and max values, and adapting the precision of the formatter accordingly
     * @param {number} min : Minimum value in the data
     * @param {number} max : Maximum value in the data
     * @param {number} exponentThreshold : Order of magnitude at which we switch to exponent notation
     * @param {number} exponentFractionDigits : Maximum number of digits after the decimal point in exponent notation (integer)
     */
    function makeAxisNumericFormatter(min, max, exponentThreshold, exponentFractionDigits) {
        const absoluteMin = Math.min(Math.abs(min), Math.abs(max));
        const absoluteMax = Math.max(Math.abs(min), Math.abs(max));
        if ((absoluteMin !== 0 && absoluteMin <= 10 ** -exponentThreshold) || absoluteMax >= 10 ** exponentThreshold) {
            return exponentFormat(exponentFractionDigits);
        } else {
            // Here we compute the difference of max and min, NOT absoluteMax and absoluteMin
            // because we are formatting an axis and only care about extreme values of the axis
            // range.
            const differenceOrderOfMagnitude = Math.floor(Math.log10(max - min));
            if (differenceOrderOfMagnitude < 0) {
                return fixedPointFormat(-differenceOrderOfMagnitude + 1);
            } else {
                return fixedPointFormat(Math.max(0, -Math.floor(Math.log10(absoluteMin))));
            }
        }
    }

    return {
        // Helper to install the redraw event on window resize, reflow event, and install the unregisterer
        installRedrawListener : function installRedrawListener(scope, redrawFn) {
            $(window).on('resize', redrawFn);
            scope.$on('$destroy', function() {
                $(window).off('resize', redrawFn);
            });
            scope.$on('reflow',redrawFn);
            scope.$on('resize',redrawFn);
        },
        /**
         * Callback maker for areas on multiLineChart.
         * @param computeAreas (scope) => Array of area series
         *     [{color: string, values: [{x, y0, y1}, ...][, yScale: d3 scale]}, ...]
         *     if yScale is not specified, the chart's yScale is used
         */
        makeSvgAreaCallback: function makeSvgAreaCallback(computeAreas) {
            return function svgAreaCallback(svg, scope) {
                const areas = computeAreas(scope);
                const area = (xScale, yScale) =>
                    d3.svg.area()
                        .x (_ => xScale(_.x))
                        .y0(_ => yScale(_.y0))
                        .y1(_ => yScale(_.y1));
                if (svg.select('.tubes').empty()) {
                    svg.append('g').attr('class', 'tubes').attr('transform',
                        `translate(${scope.margin.left}, ${scope.margin.top + 20})`);
                }

                const areaFn = _ => area(scope.chart.xScale(), _.yScale || scope.chart.yScale())(_.values),
                    paths = svg.select('.tubes').selectAll('path').data(areas);
                paths.transition().duration(scope.chart.duration()).attr('d', areaFn);
                paths.enter().append("path").attr('d', areaFn).attr('fill', _ => _.color);
                paths.exit().remove();

                function setAreaOpacity(fadeDelay){
                    let disabled = [];
                    svg.selectAll('.nv-legend .nv-series')
                        .each(function(_, i) { disabled[i] = this.classList.contains('nv-disabled'); });
                    let paths_ = svg.select('.tubes').selectAll('path');
                    if (fadeDelay) {
                        paths_ = paths_.transition().duration(fadeDelay);
                    }
                    paths_.attr('style', (_, i) => `opacity: ${disabled[i] ? '0' : '.3'}`);
                }
                setAreaOpacity(0);

                // must come after stateChange switched .nv-disabled
                scope.chart.dispatch.on('stateChange.tubes', function (e) {
                    // can't use e.disabled, bugged on data update: http://stackoverflow.com/questions/23015095
                    setTimeout(setAreaOpacity.bind(null, 100), 100);
                });
            }
        },
        /**
         * Builds a color scale legend
         * @param {d3 selection} svg : d3 selection where the color legend is to be drawn
         * @param {number} width : Width of the color bar
         * @param {number} height : Height of the color bar
         * @param {Object} margins : Object containing top, right, bottom, left margins, in pixels
         * @param {nTicks} nTicks : Number of ticks to be drawn on the legend
         * @param {Array} colorScaleArray : Array containing the hex codes of the colors to be used
         * @param {number} minValue : Minimum value of the scale
         * @param {number} maxValue : Maximum value of the scale
         * @param {boolean} isLog : true if scale is logarithmic, false otherwise
         * @param {string} label : legend label
         * @param {boolean} hideLabel : boolean to hide the color scale label
         */
        makeColorScale: function (svg, width, height, margins, nTicks, colorScaleArray, minValue, maxValue, isLog, label, hideLabel) {
            let numericFormat = makeAxisNumericFormatter(minValue, maxValue, 2, 1);

            if (isLog) {
                minValue = Math.log10(minValue);
                maxValue = Math.log10(maxValue);
            }

            svg = svg.append('g').attr('transform', `translate(${margins.left}, ${margins.top})`);
            // Fill color scale legend
            // append gradient bar
            let gradientUUID = window.crypto.getRandomValues(new Uint32Array(1))[0].toString(16);
            let gradient = svg
                .append('defs')
                .append('linearGradient')
                .attr('id', `gradient-${gradientUUID}`)
                .attr('x1', '0%') // bottom
                .attr('y1', '100%')
                .attr('x2', '0%') // to top
                .attr('y2', '0%')
                .attr('spreadMethod', 'pad');

            // programatically generate the gradient for the legend
            // this creates an array of [pct, colour] pairs as stop
            // values for legend
            let pct = linspace(0, 100, colorScaleArray.length).map(function (d) {
                return Math.round(d) + '%';
            });

            let colourPct = d3.zip(pct, colorScaleArray);

            colourPct.forEach(function (d) {
                gradient.append('stop').attr('offset', d[0]).attr('stop-color', d[1]).attr('stop-opacity', 1);
            });

            svg.append('rect')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('width', width)
                .attr('height', height)
                .style('fill', `url(#gradient-${gradientUUID})`);

            // create a scale and axis for the legend
            var scale = d3.scale.linear().domain([minValue, maxValue]).range([height, 0]);

            let axis = d3.svg.axis().scale(scale).orient('right').ticks(nTicks).tickSize(width);
            if (isLog) {
                axis.tickFormat((_) => numericFormat(10 ** _));
            } else {
                axis.tickFormat(numericFormat);
            }

            svg.append('g').call(axis).selectAll('line').style('fill', 'none').style('stroke', 'black');

            if (!hideLabel) {
                svg.append('g')
                    .attr(
                        'transform',
                        `translate(-5, ${0.2 * height})`
                    )
                    .append('text')
                    .style('text-anchor', 'middle')
                    .style('font-weight', 'bold')
                    .attr('transform', 'rotate(-90)')
                    .text(isLog ? `${label} (log)` : label);
            }

            svg.select('.domain').remove();
        },
        /**
         * Returns a numeric formatter function, mostly useful for tooltips.
         * @param {number} exponentThreshold : Order of magnitude at which we switch to exponent notation
         * @param {number} precision : Precision (either number of digits after decimal point for exponent
         *                             notation, or significant digits for decimal notation) (integer)
         */
        makeTooltipNumericFormatter: function(exponentThreshold, precision){
            return function (value) {
                const absValue = Math.abs(value);
                if ((absValue !== 0 && absValue <= 10 ** -exponentThreshold) || absValue >= 10 ** exponentThreshold) {
                    return exponentFormat(precision)(value);
                } else {
                    return decimalRoundedFormat(precision + 1)(value);
                }
            }
        },
        linspace: linspace,
        trimTrailingZeros: trimTrailingZeros,
        decimalRoundedFormat: decimalRoundedFormat,
        exponentFormat: exponentFormat,
        fixedPointFormat: fixedPointFormat,
        makeAxisNumericFormatter: makeAxisNumericFormatter
    };
});

/* Register a ML chart directive with standard setup.
 * Includes: No-Op on empty data, defered + debounced redraw, resize/reflow listener.
 * Note: `watcher` & `draw` are $injected, may have `scope` & `element` arguments.
 *       `watcher` can ask new & old `watch`ed values with `newValue` & `oldValue` args/$inject.
 */
function chartDirective(name, scopeDef, watch, watcher, draw, ext, destroy) {
    app.directive(name, function ($timeout, $injector, MLChartsCommon, Debounce) {
        return angular.extend({ restrict: 'A', scope: scopeDef, link: function(scope, element, attrs, ctrl) {
            var locals = { scope: scope, element: element, attrs: attrs, ctrl: ctrl },
                locals2 = angular.extend({}, locals),
                redrawLater = Debounce().withDelay(100,100).wrap($timeout.bind(app, function() {
                    if (scope.theData) {
                        $injector.invoke(draw, this, locals);
                        // Signal that the content of the element has been loaded and is thus available for content extraction (for Model Document Generator)
                        const loadedStateField = scope.loadedStateField ? scope.loadedStateField : "puppeteerHook_elementContentLoaded";
                        console.info("Marking chart as loaded using " + loadedStateField + " scope field");
                        scope[loadedStateField] = true;
                        if (scope.$parent) {
                            scope.$parent[loadedStateField] = true;
                        }
                    }
                }, 10));
            function addWatcher(w) {
                scope.$watch(w, function (newValue, oldValue) {
                    if (!newValue) { return; }
                    locals2.newValue = newValue;
                    locals2.oldValue = oldValue;
                    scope.theData = $injector.invoke(watcher, this, locals2);
                    redrawLater();
                }, true);
            }
            if ($.isArray(watch)) {
                for (var i=0;i<watch.length;i++) {
                    addWatcher(watch[i]);
                }
            } else {
                addWatcher(watch);
            }
            MLChartsCommon.installRedrawListener(scope, redrawLater);
            if (typeof destroy === "function") {
                scope.$on('$destroy', destroy);
            }
        } }, ext || {});
    });
}

// prefixes: bc = binary classification, r = regression

/** 
 * Vertical or horizontal bar chart
 * Accept as data either an array of tuple2 [[k, v], ...] for ordered data,
 *      or an object {k: v} for unordered data.
 * `colors` can be replaced with a `color` attribute for constant color.
 */
chartDirective('discreteBarChart',
    { 
        data: '=', 
        colors: '=', 
        format: '@', 
        horizontal: '=?',
        loadedStateField: "=?", disableTransitions: "=?"
    }, 
    "data",
    function(scope, attrs, Fn) {
        const LABELS_MIN_WIDTH = 10;
        const LABELS_MAX_WIDTH = 200;
        const LABELS_MARGIN = 8;
        const isHorizontal = !!scope.horizontal;
        const color = attrs.color;
        const useKey = !Array.isArray(scope.colors);
        const data = (Array.isArray(scope.data) ? scope.data : obj2arr(scope.data)).map((k, i) => {
            return { 
                value: k[1], 
                label: k[0],
                color: color || scope.colors[useKey || typeof k === 'number' ? k : i] 
            }; 
        });

        scope.settings = angular.extend({ maxLabel: 30 }, scope.$eval(attrs.discreteBarChart) || {});
        scope.maxLength = Math.min(scope.settings.maxLabel,
            Math.max.apply(Math, data.map(Fn(Fn.prop('label'), Fn.prop('length')))));

        scope.margins = {};

        if (isHorizontal) {            
            scope.margins.top = 0;
            scope.margins.bottom = 20; 
            const longestLabelWidth = Math.max(...data.map(d => getTextWidth(d.label)));
            scope.margins.left = Math.max(LABELS_MIN_WIDTH, Math.min(LABELS_MAX_WIDTH, longestLabelWidth)) + LABELS_MARGIN;
        } else {
            scope.margins.top = 10;
            scope.margins.bottom = 30; 
            scope.margins.left = 50;
        }

        return [{ values: data }];
    }, function(scope, element, attrs, ctrl, Fn) {
        const width = element.width();
        const height = element.height();
        const isHorizontal = !!scope.horizontal;
        const chart = nv.models[isHorizontal ? 'multiBarHorizontalChart' : 'discreteBarChart']()
            .height(height)
            .width(width)
            .margin(scope.margins)
            .x(Fn.prop('label'))
            .y(Fn.prop('value'))
            .color(Fn.prop('color'))
            .showValues(true);
        const fmt = d3.format(scope.format);
        const svg = d3.select(element.get(0));

        let transitionDuration = 500;
        if (scope.disableTransitions) {
            console.info("Disabling chart transitions");
            chart.duration(0);
            transitionDuration = 0;
        }

        chart.tooltip.enabled(false);

        if (chart.staggerLabels) { chart.staggerLabels(false); }

        chart.valueFormat(fmt);
        chart.yAxis.tickFormat(fmt);

        if (scope.settings.scale) { chart.forceY(scope.settings.scale); }

        svg.datum(scope.theData).transition().duration(transitionDuration).call(chart);

        if ('svgTitles' in attrs && scope.maxLength >= scope.settings.maxLabel) {
            svg.selectAll('.nv-axis.nv-' + (isHorizontal ? 'x' : 'y') + ' .tick text')[0].forEach((text) => {
                var elt = d3.select(text), t = elt.text();
                if (t.length > scope.settings.maxLabel) {
                    elt.attr('data-title', sanitize(t));
                    elt.text(t.substr(0, scope.settings.maxLabel - 2) + '\u2026');
                }
            });
            ctrl.update();
        }

        if (isHorizontal) { // hack to get the wanted color
            svg.selectAll('.nv-bar rect').each(function(d, i) {
                d3.select(this).style("fill", d.color); 
            });
        }
    }, { require: '?svgTitles' });


/*
function chartDirective(name, scopeDef, watch, watcher, draw, ext, destroy) {

    
*/
chartDirective('predictionBarChart',
    { data: '=', colors: '=', threshold: '=?'  }, "data",
    function(scope, attrs, Fn) {
        return scope.data.map((d, i) => ({
            key: d.name,
            values: [{
                x: '',
                y: d.value * 100,
                color: d.color
            }]
        }));
    }, function(scope, element, $filter, $timeout) {
        const width = element.width();
        const height = element.height();
        const margin = 200;
        const tickFormat = d3.format('d');
        const chart = nv.models['multiBarHorizontalChart']()
                .height(height)
                .width(width - margin)
                .forceY([0,1])
                .showLegend(false)
                .showControls(false)
                .showValues(true)
                .groupSpacing(0.4); // for height of bar
        const svg = d3.select(element.get(0)).attr('class', 'prediction-chart');
        svg.select(".prediction-chart__legend").remove();
        svg.select(".prediction-chart__threshold").remove();
        d3.selectAll(".nvtooltip").remove();

        chart.yAxis.tickFormat(tickFormat);
        chart.yAxis.ticks(6, 'd');

        chart.tooltip.enabled(true);
        chart.multibar.stacked(true);

        // create custom legend
        const RECT_SIZE = 16;
        const RECT_SPACING = 24;
        const legend = svg.append('g')
            .attr('class', 'prediction-chart__legend')
            .attr('transform', `translate(${width - margin + 20}, ${height - margin})`)  
        // generate legend marker
        legend.selectAll('rect')
            .data(scope.theData)
            .enter()
            .append('rect')
            .attr('width', RECT_SIZE)
            .attr('height', RECT_SIZE)
            .attr('y', (d, i) => {
                return i * RECT_SPACING;
            })
            .style('fill', function(d) { 
                return d.values[0].color;
            });

        // add legend text
        const legendText = legend.selectAll('text')
            .data(scope.theData)
            .enter()
            .append('text')
            .attr('class', 'prediction-chart__legend-label')
            .attr('dx', RECT_SPACING)
            .attr('dy', (d, i) => {
                return i * RECT_SPACING + RECT_SPACING / 2;
            });
        // to allow a mix of bold and normal text
        legendText.append('tspan')
            .attr('style', 'font-weight: 500;')
            .text(function(d) {
                return $filter("gentleTruncate")(d.key, 30) + ' - ';
            });
        legendText.append('tspan')
            .text(function(d) {
                return formatPercentage(d.values[0].y)
            });
        // for hovering in case of truncated text
        legendText.append('title')
            .text(function(d) {
                return d.key;
            });

        chart.tooltip.contentGenerator(selection => {
            return `
                <div class="prediction-chart__tooltip">
                    ${sanitize(selection.data.key)} - ${sanitize(formatPercentage(selection.data.y))}
                </div>
            `;
        });

        svg.datum(scope.theData).transition().duration(500).call(chart);

        // draw threshold line if it exists
        if (typeof scope.threshold !== 'undefined') {
            // ensure bar is visible before adding threshold line
            $timeout(() => {
                const barHeight = d3.select('.nv-bar rect').node().getBoundingClientRect().height;
                const THRESHOLD_MARGIN = 20;
                const thresholdPercentage = scope.threshold * 100;

                svg.append('rect')
                    .attr('class', 'prediction-chart__threshold')
                    .attr('x', chart.margin().left + chart.yAxis.scale()(thresholdPercentage))
                    .attr('y', chart.margin().top + chart.xAxis.scale()('') - THRESHOLD_MARGIN / 2)
                    .attr('width', 1)
                    .attr('height', barHeight + THRESHOLD_MARGIN);
            });

            legend.append('line')
                .attr('class', 'prediction-chart__legend-threshold')
                .attr('x1', RECT_SIZE / 2)
                .attr('x2', RECT_SIZE / 2)
                .attr('y1', -RECT_SIZE / 2)
                .attr('y2', -RECT_SIZE - RECT_SIZE / 2);
            legend.append('text')
                .attr('class', 'prediction-chart__legend-label')
                .attr('dx', RECT_SPACING)
                .attr('dy', (d, i) => {
                    return -RECT_SPACING / 2;
                })
                .text('Threshold - ' + d3.format(".1f")(scope.threshold*100) + '%');
        }
        
        svg.selectAll('.nv-group rect').each(function(d) {
            d3.select(this).style("fill", d.color); 
        });

        function formatPercentage(value) {
            return d3.format(".2f")(value) + '%';
        }
    });

/* Draw a multi grouped horizontal bar chart with a horizontal bar chart next to it. Both has the same size. 
   Each group of the first one is the same size than one group in the second one.
   - `chart1Data`: the main data to build the multi bar chart, has to be like: 
    [
        {
            "key": "Class 1",
            "color": "#d67777",
            "values": [
            { 
                "label" : "Modality A" ,
                "value" : -1.8746444827653
            } ...
            ]
        },
        {
            "key": "Class 2",
            "color": "#4f99b4",
            "values": [
            { 
                "label" : "Modality A" ,
                "value" : 25.307646510375
            } ...
        } ...
    ]
    - `chart2Data`: the data to built the distribution chart, has to be like `chart1Data` but with a length of one
    - `chart1SvgId`: the id of the svg element in the HTML where you want the multi bar chart
    - `chart2SvgId`: the id of the svg element in the HTML where you want the simple bar chart
    - `chart1Title`: the title of the first chart
    - `chart2Title`: the title of the second chart
*/
chartDirective('multiGroupedHBarChartWithHBarChart',
    { chart1Data: '=', chart2Data: '=', chart1SvgId: '=', chart2SvgId: '=', chart1Title: '=', chart2Title: '=' }, "chart1Data",
    function(scope) {
        return scope.chart1Data;
    }, function(scope) {
        d3.selectAll(".nvtooltip").remove(); // bug of nvd3, tooltip stays
        const nbOfGroups = scope.chart1Data[0].values.length;
        const groupSpacing = 0.2;
        const fmt = d3.format(".3n");
        const defaultMarginTop = 50;
        const marginBottom = 50;
        const chart2Svg = d3.select(`#${scope.chart2SvgId}`);
        const chart2Format = d3.format(",.1%");

        const mainChart = nv.models.multiBarHorizontalChart()
                .groupSpacing(groupSpacing)
                .x(d => d.label)
                .y(d => d.value)
                .margin({ top: scope.legendHeight || defaultMarginTop, right: 20, bottom: marginBottom, left: 175 })
                .showValues(false)
                .showControls(false)
                .valueFormat(fmt);
        mainChart.yAxis.tickFormat(fmt);
        mainChart.yAxis.axisLabel(scope.chart1Title);

        const svg = d3.select(`#${scope.chart1SvgId}`);
        if (scope.height) {
           mainChart.height(scope.height);
        }

        svg.datum(scope.chart1Data).transition().call(mainChart).each("end", () => {
            scope.legendHeight = mainChart.legend.height();
            mainChart.margin({ top: scope.legendHeight });
            mainChart.update();
            buildHBarChart(scope.chart2Title , chart2Svg, scope.chart2Data, scope.height, scope.legendHeight, chart2Format);
            const maxHeight = parseInt(svg.style("height").split("px")[0]);
            const height = scope.height || maxHeight;
            translateTicksVertically(svg, height - marginBottom - scope.legendHeight, nbOfGroups, groupSpacing);

            // Watch legend change, if new class has been (de)selected
            mainChart.dispatch.on("stateChange", function(e) {
                const numberSelectedClasses = e.disabled.filter(d => !d).length;
                scope.height = numberSelectedClasses * nbOfGroups * 15 + 400;
                translateTicksVertically(svg, scope.height - scope.legendHeight - marginBottom, nbOfGroups, groupSpacing);
                mainChart.height(scope.height);
                mainChart.update();
                buildHBarChart(scope.chart2Title, chart2Svg, scope.chart2Data, scope.height, scope.legendHeight, chart2Format);
            });
        });
    }
)

function translateTicksVertically(svg, innerChartHeight, nbOfGroup, groupSpacing) {
    const spaceSize = (innerChartHeight * groupSpacing) / nbOfGroup;
    const groupSize = (innerChartHeight * (1 - groupSpacing)) / nbOfGroup;
    const yTranslation = (spaceSize + groupSize) / 2;
    svg.selectAll(".tick line").attr("transform", "translate(0, " + yTranslation + ")");
}

function buildHBarChart(title, svg, data, height, marginTop, format) {
    const chart = nv.models.multiBarHorizontalChart()
                .groupSpacing(0.2)
                .margin({ top: marginTop, bottom: 50, left: 5 })
                .showValues(true)
                .x((d) => d.label)
                .y(d => d.value)
                .showXAxis(false)
                .showLegend(false)
                .showControls(false);
    if (height) {
        chart.height(height);
    }

    chart.yAxis.axisLabel(title);
    chart.yAxis.tickFormat(format);
    chart.tooltip.enabled(false);
    chart.valueFormat(format);

    svg.datum(data).transition().duration(500).call(chart);
}

/* Draw a multi lines chart (on the left axis) with a vertical bar chart (on the right axis)
   - `data`: the data used to draw the lines and the bar chart
    [
        {
            "key": "Class 1",
            "color": "#d67777",
            "type": "line",
            "values": [
                [x1, y2],
                [x2, y2]
            ]
        },{
            "key": "Distribution",
            "color": "#D5D9D9",
            "type": "bar",
            "values": [
                [x1, y2],
                [x2, y2]
            ]
        }(...)
    ]
    - `xlabel`: the label of the x axis
    - `y1Label`: the label of the left axis
    - `y2Label`: the label of the right axis
    - `isDate`: boolean - are the x values dates ?
*/
chartDirective('multiLinesWithBarChart',
    { data: '=', xlabel: "=", isDate: '=' , y1Label: '=', y2Label: '='}, "data",
    function(scope) {
        return scope.data;
    }, function(scope, element) {
        d3.selectAll(".nvtooltip").remove(); // bug of nvd3, tooltip stays
        const svg = d3.select(element.get(0))
        const distanceBetweenXTicks = scope.data[0].values[1][0] - scope.data[0].values[0][0];
        const chart = nv.models.multiChart()
            .margin({ top: 0, right: 50, bottom: 100, left: 100 })
            .x(d => d[0])
            .y(d => d[1])
            .height(svg.style.height)
        const yAxis1Fmt = d3.format('.3n');
        const yAxis2Fmt = d3.format(".1%");
        
        //The chart changes its internal id every time data is reloaded. 
        // This breaks the tooltips in Firefox (but not in Chrome for some reason).
        // Need to lock it down.
        chart.bars2.id(scope.xlabel.replace(/\W+/, '-'));

        chart.tooltip.contentGenerator(data => {
            let yvalue, xvalue = data.value;
            const color = data.series[0].color;
            const key = data.series[0].key;
            if (data.point) { // data from a point of a line
                xvalue = formatFloat(scope.isDate, xvalue)
                yvalue = yAxis1Fmt(data.series[0].value)
            } else { // data from a bar
                xvalue = "[{0}, {1})".format(formatFloat(scope.isDate, xvalue), formatFloat(scope.isDate, xvalue + distanceBetweenXTicks))
                yvalue = yAxis2Fmt(data.series[0].value);
            }
            return tooltipHTML(xvalue, color, key, yvalue);
        });
        chart.bars2.groupSpacing(0);
        chart.legendRightAxisHint("");
        
        chart.xAxis.axisLabel(scope.xlabel || "Values")
                    .showMaxMin(false)
                    .axisLabelDistance(40)
                    .tickFormat(d => formatFloat(scope.isDate, d));

        if (scope.isDate) {
            chart.xAxis.rotateLabels(-45);
        }

        chart.yAxis1.axisLabel(scope.y1Label)
                    .tickFormat(yAxis1Fmt)
                    .showMaxMin(false)
                    .axisLabelDistance(40);
        
        chart.yAxis2.axisLabel(scope.y2Label)
                    .tickFormat(yAxis2Fmt)
                    .showMaxMin(true)
                    .tickValues([0]);

        svg.datum(scope.data)
            .transition()
            .duration(500)
            .call(chart).each("end", () => {
                chart.margin({ top: chart.legend.height() });
                chart.update();
            });
});

function formatFloat(isDate, d) {
    if (isDate) {
        return d3.time.format("%Y-%m-%d %H:%M")(new Date(d));
    } else {
        return d3.format('.3n')(d); 
    }
}

function tooltipHTML(xvalue, color, key, yvalue) {
    return `
    <table>
        <thead>
            <tr>
                <td colspan="3">
                    <strong class="x-value">${xvalue}</strong>
                </td>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td class="legend-color-guide">
                    <div style="background-color:${color}"></div>
                </td>
                <td class="key">${key}</td>
                <td class="value">${yvalue}</td>
            </tr>
        </tbody>
    </table>`
}


/** Generic multi-line plot, possibly with second y-axis and x-markers.
 * ys*      Array(N) of primary value series
 * ys2*     Array(M) of secondary value series. Keep M <= 1 to avoid confusion
 *          (right axis is labelled with the first y2 color).
 * x or xs* Array(N + M) (if xs) of abscissa series, or a single series (if x).
 * xMarks   Array(P) of x values to mark
 * xMarkLabelPosition   String ('top' | 'bottom') containing position of x-mark label
 * xTicks   Array(Q) of x values to tick on x axis
 * labels*  Array(N + M) of label for curves.
 * colors*  Array(N + M [+ P]) of colors for curves and markers.
 * formats* String or Array(1-4) of format strings (x, [y1, [y2, y2 values in tooltip]]])
 *          single string = same for all, array < 4 = each one falls back to the previous
 * options  Object of Array(N+M) of objects: line options, will be added as-is
 *          single object = same for all lines
 * axes     Array (1-3) of axis labels (x, [y1, [y2]])
 * scale    Array([y1min, y1max]) for a linear Y scale to force
 * scale2   Array([y2min, y2max]) same for right axis
 * callback Function(svg, scope) to be called after (re)drawing
 **/
chartDirective('multiLineChart',
    { ys: '=', x: '=?', xs: '=?', labels: '=', colors: '=', format: '=',
        ys2: '=?', xMarks: '=?', xMarkLabelPosition: '=?', xTicks: '=?', options: '=?', axes: '=?',
        scale: '=?', scale2: '=?', xScale: '=?', callback: '=?', disableInteractiveLayer: '=?', hideLegend: "=?",
        loadedStateField: "=?", disableTransitions: "=?", disableInteractiveGuideline: "=?"},
    '[ys, ys2, axes, xScale]',
    function(scope, attrs, Fn) {
        if (scope.x && scope.x.length) { scope.xs = [scope.x]; }
        if (!scope.xs || !scope.xs.length || !scope.ys || !scope.ys.length
            || !scope.labels || !scope.labels.length) { return null; }
        scope.scale = scope.scale || // fatten ys = [[y1], [y2], ...]
            (function(_) { return [d3.min(_),d3.max(_)]; })([].concat.apply([], scope.ys));
        if (scope.ys2 && scope.ys2.length && scope.ys2[0] && scope.ys2[0].length) {
            var y2 = [].concat.apply([], scope.ys2), scale2;
            scope.ys2.scale = scale2 = d3.scale.linear().range(scope.scale)
                .domain(scope.scale2 || [Math.min.apply(null, y2), Math.max.apply(null, y2)]);
        }
        if (scope.xScale == null) {
            scope.xScale = d3.scale.linear().domain(function(_) { return [d3.min(_),d3.max(_)]; }([].concat.apply([], scope.xs)));
        }
        scope.callback = typeof scope.callback === 'function' ? scope.callback : Fn.NOOP;
        return scope.ys.concat(scope.ys2 || []).map(function(ys, i){
            var t = i < scope.ys.length ? Fn.SELF : scale2;
            return angular.extend({
                    key: scope.labels[i],
                    values: ys.map(function(y, j) {
                        return { x: scope.xs[i % scope.xs.length][j], y: t(y) }; }),
                    color: scope.colors[i]
                }, !this ? {} : Array.isArray(this) ? this[i] : this);
        }, scope.options);
    },
    function(scope, element, Fn) {
        var width = element.width(),
            height = element.height(),
            scale2 = scope.ys2 && scope.ys2.scale.copy(),
            margin = {top: 10, right: scale2 ? 80 : 20, bottom: 60, left: 70},
            cw = width - margin.left - margin.right,
            ch = height - margin.top - margin.bottom - (scope.hideLegend ? 0 : 20),
            axes = (Array.isArray(scope.axes) ? scope.axes : []).concat(['', '', '']),
            fmts = (Array.isArray(scope.format) ? scope.format : [scope.format]),
            chart = nv.models.lineChart() .margin(margin),
            elt = element.get(0),
            par = elt.parentElement,
            svg = d3.select(elt);
        // cleanup
        chart.useInteractiveGuideline(!scope.disableInteractiveGuideline);
        chart.interactiveLayer.tooltip.enabled(!scope.disableInteractiveLayer);
        chart.interactiveLayer.showGuideLine(!scope.disableInteractiveLayer);
        chart.showLegend(!scope.hideLegend);
        svg.select(".secondary-axis").remove();
        svg.selectAll(".x.mark").remove();

        fmts = fmts.map(_ => typeof _ === 'function' ? _ : d3.format(_));
        chart.forceY(scope.scale);
        if (scope.disableTransitions) {
            console.info("Disabling chart transitions");
            chart.duration(0);
        }
        chart.forceX(scope.xScale.domain());    // force chart X domain
        chart.xDomain(scope.xScale.domain());   // force-preserve X domain down the line
        chart.xScale(scope.xScale.copy().range([0, cw]));
        chart.xAxis.axisLabel(axes[0]) .tickFormat(fmts[0]);
        chart.yAxis.axisLabel(axes[1]) .tickFormat(fmts[1 % fmts.length]);
        if (scope.xTicks) {
            chart.xAxis.tickValues(scope.xTicks);
        }
        svg.datum(scope.theData).call(chart);

        // y2 (different scale normalized on the first, axis displayed on the right)
        if (scale2) {
            // display a second y axis
            var format2 = fmts.length > 2 ? fmts[2] : chart.yAxis.tickFormat();
            svg.select(".nv-lineChart").append("g").attr("class", "y axis secondary-axis")
                .style("fill", scope.colors[scope.ys.length])
                .attr("transform", "translate(" + cw + ", 0)")
                .call(d3.svg.axis().scale(scale2.range([ch, 0])).tickFormat(format2).orient("right"));
            if (axes.length > 2) {
                svg.select(".secondary-axis").append("text").text(axes[2]).attr("text-anchor", "middle")
                    .attr("x", 0 - ch / 2).attr("y", 60).attr("transform", "rotate(-90)");
            }
            // hack the tooltip to adjust the scale of the ys2 series, using a non-replaceable formatter
            var tt = chart.interactiveLayer.tooltip, vf = tt.valueFormatter();
            scale2 = scope.ys2.scale.copy().range(scale2.domain()).domain(scope.scale);
            if (fmts.length > 3) {
                format2 = fmts[3];
            }
            tt.valueFormatter(function(y, i) {
                return i < scope.ys.length ? vf(y, i) : format2(scale2(y)); });
            tt.valueFormatter = function(_) { if (_) { vf = _; return tt; } return vf; };
        }

        // Vertical markers
        (scope.xMarks || []).filter(Fn.unique()).forEach(function (xMark, i) {
            scope.xMarkLabelPosition = scope.xMarkLabelPosition || 'bottom';
            const xMarkColor = scope.colors[scope.theData.length + i];
            const xMarkG = svg.select(".nv-lineChart").append("g").attr("class", "x mark")
                    .attr("transform", "translate(" + chart.xScale()(xMark) + ", 0)");
            const xMarkLabelXOffset = scope.xMarkLabelPosition === 'bottom' ? 0 : 4;
            const xMarkLabelYOffset = (scope.xMarkLabelPosition === 'bottom' ? ch : 0) + 16;
            const textAnchor = scope.xMarkLabelPosition === 'bottom' ? 'middle' : 'start';

            xMarkG.append("path").attr('d', "M0,0 V" + ch)
                .attr('stroke-width', 1).attr('stroke', xMarkColor).attr('stroke-dasharray', '5,3');
            xMarkG.append("text").attr('x', xMarkLabelXOffset).attr('y', xMarkLabelYOffset).attr("text-anchor", textAnchor)
                .attr('fill', xMarkColor).text(chart.xAxis.tickFormat()(xMark));
        });

        // Fix horizontal position bug when SVG's parent has position: relative
        var parStyle = window.getComputedStyle(par);
        if (parStyle.position === 'relative' && !par.querySelector('style.nvTooltipFix')) {
            var st = document.createElement('style');
            if (!par.id) { par.id = chart.interactiveLayer.tooltip.id() + 'p'; }
            st.innerHTML = ['#', par.id, ' .nvtooltip { margin-left: -', par.offsetLeft, 'px; }'].join('');
            par.insertBefore(st, null);
        }

        scope.callback(svg, angular.extend(scope, {chart: chart, margin: margin, axisHeight:ch}));
    });


chartDirective('distributionChart', { data: '=', xMarks: '=?', colors: '=', xFormat: '@?', yFormat: '@?' , axes: '=?'}, "data",
    function(scope, element, Fn) { return {
        xScale: d3.scale.linear().domain([scope.data[0].min, scope.data[scope.data.length - 1].max]),
        yScale: d3.scale.linear().domain([0, d3.max(scope.data, Fn.prop('count'))]).nice()
    }; }, function (scope, element, Fn) {
        var margin = {top: 20, right: 20, bottom: 40, left: 40}, gap = 6,
            w = element.width() - margin.left - margin.right,
            h = element.height() - margin.top - margin.bottom,
            xs = scope.theData.xScale.range([margin.left, w + margin.left]),
            ys = scope.theData.yScale.range([h + margin.top, margin.top]),
            bw = xs(scope.data[0].max) - xs(scope.data[0].min),     y0 = ys(0),
            xFormat = scope.xFormat ? d3.format(scope.xFormat) : scope.theData.xScale.tickFormat(),
            yFormat = scope.yFormat ? d3.format(scope.yFormat) : scope.theData.yScale.tickFormat(),
            xAxis = d3.svg.axis().scale(xs).orient('bottom').tickFormat(xFormat)
                    .tickValues([0, scope.data[0].min].concat(scope.data.map(Fn.prop('max')))),
            yAxis = d3.svg.axis().scale(ys).orient('left').tickFormat(yFormat)
                    .tickValues(ys.ticks(10)).tickSize(w),
            svg = d3.select(element.get(0)).html('');
        
        if (scope.axes) {

            // Increase margins to let space for axis labels
            margin.left += 5;
            margin.bottom += 5;

            let xAxisLabel = scope.axes[0];
            svg.append('g').attr('class', 'x-axis-labels')
               .append('text')
               .style("font-size", "13px")
               .attr('text-anchor', "middle")
               .attr('x', margin.left + w / 2)
               .attr('y', 35 + h + margin.top)
               .text(xAxisLabel);
            
            let yAxisLabel = scope.axes[1];
            svg.append('g').attr('class', 'y-axis-labels')
                .append('text')
                .attr("transform", "rotate(-90, 12, " + (margin.top + h / 2) + ")")
                .attr('text-anchor', "middle")
                .style("font-size", "13px")
                .attr('x', 12)
                .attr('y', margin.top + h / 2)
                .text(yAxisLabel);
        }

        
        svg .append('g').attr('class', 'x axis')
            .attr('transform', 'translate(0, ' + (h + margin.top) + ')').call(xAxis);
        svg .append('g').attr('class', 'y axis')
            .attr('transform', 'translate(' + (w + margin.left) + ', 0)').call(yAxis)
            .select('.domain').attr('d', 'M-' + w + ',' + margin.top + 'v' + h);
        svg.append('g').attr('class', 'bars') //.transition().duration(500)
            .selectAll('.bar').data(scope.data).enter().append('rect').attr('class', 'bar')
                .attr('x', function(d) { return xs(d.min) + gap / 2; }) .attr('width', bw - gap)
                .attr('y', Fn(Fn.prop('count'), ys))
                .attr('height', function(d) { return y0 - ys(d.count); })
                .attr('fill', scope.colors[0]);
        svg.append('g').attr('class', 'labels')
            .selectAll('.label').data(scope.data).enter().append('text').attr('class', 'label')
                .attr('x', Fn(Fn.prop('min'), xs)) .attr('dx', bw / 2)
                .attr('y', Fn(Fn.prop('count'), ys)) .attr('dy', -6)
                .attr('text-anchor', 'middle') .text(Fn(Fn.prop('count'), yFormat));
        svg.append('g').attr('class', 'marks')
            .selectAll('.mark').data((scope.xMarks || []).filter(Fn.unique())).enter().append('path')
                .attr('class', 'mark').attr('stroke', Fn.from(scope.colors.slice(1), 1))
                .attr('stroke-dasharray', '5,3')
                .attr('d', function(d) { return ['M', xs(0), ',', margin.top, 'v', h].join(''); })
    });


chartDirective('bcPerBinLiftChart', { data: "=", loadedStateField: "=?", disableTransitions: "=?" }, "data",
    function(scope, element) {
        return [{
            key: "Per-bin lift chart",
            values: scope.data.bins.map(function(p) { return { x: p.percentile_idx + 1, y: p.bin_lift }; })
        }];
    }, function (scope, element, Fn) {
        var width = element.width(),
            height = element.height(),
            margin = {top: 10, right: 20, bottom: 60, left: 70},
            max = Math.ceil(d3.max(scope.theData[0].values, Fn.prop('y'))),
            chart = nv.models.discreteBarChart()
                .width(width) .height(height) .margin(margin)
                .color(function(d) { return d.y > 1 ? 'steelblue' : 'lightblue' })
                .showValues(true) .staggerLabels(false)
                .forceY([0, max]),
            svg = d3.select(element.get(0)).html('');

        chart.tooltip.enabled(false);
        chart.xAxis.axisLabel("Observations by decreasing probability decile") ;
        chart.yAxis.axisLabel("Lift on bin") ;
        let transitionDuration = 500;
        if (scope.disableTransitions) {
            console.info("Disabling chart transitions");
            chart.duration(0);
            transitionDuration = 0;
        }
        svg.datum(scope.theData).transition().duration(transitionDuration).call(chart);
        var heightOfOne = chart.yAxis.scale()(1);
        svg.append('g').attr('class','liftmedline').append('path') // Median line
            .attr('d', ['M', margin.left, ',', heightOfOne + margin.top, ' H', width - margin.right].join(''))
            .style("stroke", "LightCoral").style("stroke-width", "2").style("stroke-dasharray", "3");
    });


chartDirective('bcPerBinProbaDistribChart', 
    {data: "=", bins: "=", threshold: "=", modelClasses: "=", colors: "="},
    "data",
    function(scope) {
        return {"probaDistribs": scope.data.probaDistribs.map((probaDistrib, i) => {
                                    return {
                                        key: "actual " + scope.modelClasses[i], 
                                        values: probaDistrib.map(d => ({value: d})),
                                        color: scope.colors[i]
                                    }
                                 }), 
                 "bins": scope.data.bins, 
                 "threshold": scope.threshold
                }
    },
    function(scope, element) {
        let width = element.width(),
            height = element.height(),
            margin = {top: 25, right: 20, bottom: 40, left: 60},
            max = scope.theData.probaDistribs.reduce((acc, curr) => Math.max(acc, curr.values.reduce((acc2, curr2) => Math.max(acc2, curr2.value), 0)), 0);

        let chart = nv.models.multiBarChart()
                             .width(width)
                             .height(height)
                             .margin(margin)
                             .x((_, i) => {
                                 return ((scope.theData.bins[i] + scope.theData.bins[i + 1]) / 2).toFixed(2);
                             })
                             .y((d) => d.value)
                             .staggerLabels(false)
                             .showControls(false)
                             .forceY([0, max]);
        
        let svg = d3.select(element.get(0)).html('');
        
        
        chart.xAxis.axisLabel("Predicted probability");
        chart.yAxis.axisLabel("# of rows");

        chart.tooltip.contentGenerator( function(data) {
            var index = data.index;
            return [
                        "<p><strong>" + data.data.key + "</strong></p>",
                        "<p>Predicted probability: " + scope.theData.bins[index] + " - " + scope.theData.bins[index + 1] + "</p>",
                        "<p># of rows: " + data.data.value
                   ].join('');
        });
        chart.options({tooltip: {chartContainer: document.body }});


        svg.datum(scope.theData.probaDistribs).transition().duration(500).call(chart);

        let chartHeight = height - margin.top - margin.bottom,
            chartWidth = width - margin.left - margin.right;
        let xScale = d3.scale.linear().domain([scope.theData.bins[0], scope.theData.bins[scope.theData.bins.length - 1]])
                                      .range([0, chartWidth]);
        var thresholdMarkColor = "#9467bd";
        var thresholdMarkG = svg.select(".nv-multibar").append("g").attr("class", "threshold mark")
                .attr("transform", "translate(" + xScale(scope.theData.threshold) + ", 0)");
        thresholdMarkG.append("path").attr('d', "M0,0 V" + chartHeight)
            .attr('stroke-width', 1).attr('stroke', thresholdMarkColor).attr('stroke-dasharray', '5,3');    
        thresholdMarkG.append("text")
                      .attr("x", 0)
                      .attr("y", chartHeight + 15)
                      .attr("text-anchor", "middle")
                      .text(scope.theData.threshold.toFixed(2))
                      .attr("fill", thresholdMarkColor);
        }
);


app.directive('bcGainChart', function (Fn) { return {
    priority: 10, // before multi-line-chart
    scope: false,
    link: function(scope, elt, attrs) { scope.$watch(attrs.data, function(data) {
        if (!data) return;

        var ys = data.folds && data.folds.length ? data.folds : [data.bins];
        function remap(y) { return [0].concat(y.map(this)); }
        scope.xs = ys.map(remap, Fn.prop('cum_size'));
        scope.ys = ys.map(remap, Fn.prop('cum_lift'));

        // wizard: linear until 1, precise break point appended to avoid linear interpolation
        var wizSlope = data.wizard.total / data.wizard.positives,
            wizard = scope.xs[0].map(function(x, i) { return Math.min(x * wizSlope, 1); }),
            wizX   = scope.xs[0].slice(0), x1 = wizard.indexOf(1);
        wizard.splice(x1, 0, 1);   wizX.splice(x1, 0, 1 / wizSlope);
        scope.ys.push(wizard);     scope.xs.push(wizX);

        scope.ys.push(scope.xs[0].map(Fn.SELF)); // Random: y(x) = x

        scope.labels = ys.length === 1
            ? ['Cumulative Gain', 'Wizard (perfect model)', 'Random model']
            : ys.map(function(_, i) { return 'Cumul. Gain, fold ' + (i+1); })
                .concat('Wizard', 'Random model');
    }); }
}; });


app.controller("PMLTaskModelsRankingController", function ($scope) {
        function sortModelsForDisplay() {
            $scope.orderedModels = ($scope.selection.sessionModels || [])
                .map(x => {
                    if (x.trainInfo && x.trainInfo.state !== "DONE") {
                        x.sortMainMetric = -999999999;
                    }
                    return x;
                }).sort((a, b) => -(a.sortMainMetric - b.sortMainMetric));
        }

        $scope.$watch("selection.sessionModels", sortModelsForDisplay, true);
    }
);

chartDirective('gridsearchResults',
    {selectedModel: '=', allModels: '=', currentMetric: '=', sessionId: '='},
    ["selectedModel", "allModels", "currentMetric", 'sessionId'],
    function(scope, Collections) {
        return scope.allModels.filter(function(model){ return model.sessionId === scope.sessionId && model.mainMetric });
    }, function(scope, element, $filter, Fn) {
        var changeSelectedModel = function(nv) {
            scope.selectedModel = nv;
            scope.$apply();
        };
        var margin = {top: 0, right: 0, bottom: 50, left: 5},
            width = element.width() - margin.left - margin.right,
            height = element.height() - margin.top - margin.bottom,
            chart = d3.select(element.get(0)).html(''),
            miny = d3.min(scope.theData.map(function(c){ return c.mainMetric })),
            maxy = d3.max(scope.theData.map(function(c){ return c.mainMetric })),
            ydiff = Math.max(maxy - miny, Math.abs(0.01*miny));

        maxy = maxy + 0.15 * ydiff;

        chart.attr('viewBox','0 0 '+width+' '+height);
        var main = chart.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
            .attr('width', width).attr('height', height).attr('class', 'main');

        var y = d3.scale.linear().domain([miny, maxy]).range([ height, 0 ]);


        var threshold = 10; // in px
        // If there are some overlapping texts adapt smoothly to threshold
        // compute distances between scores, min with threshold and compensate with greater y
        scope.theData = scope.theData.sort(function(a,b){ return b.mainMetric-a.mainMetric }); // ascending mainMetric order
        var dists = [], i;
        for (i=1;i<scope.theData.length;i++) {
            dists.push(y(scope.theData[i].mainMetric) - y(scope.theData[i-1].mainMetric));
        }
        var distToGet = 0;
        dists = dists.map(function(o){ distToGet += Math.max(threshold-o, 0); return Math.max(threshold, o) });
        var totalOverDist = dists.filter(function(o){return o>threshold}).reduce(Fn.SUM,0);
        dists = dists.map(function(o) { return o>threshold ? o - (o/totalOverDist)*distToGet : o });
        if (scope.theData.length>0) {
            scope.theData[0].y = y(scope.theData[0].mainMetric);
        }
        for (i=1;i<scope.theData.length;i++) {
            scope.theData[i].y = scope.theData[i-1].y + dists[i-1];
        }

        var textx = width - 20,
        mins = d3.min(scope.theData.map(function(c){ return c.mainMetric })),
        maxs = d3.max(scope.theData.map(function(c){ return c.mainMetric }));
        main.append('line').attr({x1:textx,x2:textx,y1:height-10,y2:10,class:'domain','stroke-dasharray': '2,5'});
        main.append('text').attr({x:textx,y:0}).style('text-anchor','middle').text(maxs ? maxs.toFixed(2) : '');
        main.append('text').attr({x:textx,y:height+10}).style('text-anchor','middle').text(mins ? mins.toFixed(2) : '');
        main.append('text').attr({x:0,y:height+20}).text(function(d){
            var txt = 'Final model score on test set';
            txt += scope.theData.length==0 ? '' : ' ('+$filter('mlMetricName')(scope.currentMetric, scope.theData[0])+')';
            return txt;
        });

        var div = d3.select('body').selectAll('div.gridsearch.tooltip').data([0]);
        div.enter().append('div').attr("class", "tooltip gridsearch").style("opacity", 0);

        var pointlines = main.selectAll("g.doctor-results-graph-line")
            .data(scope.theData).enter().append("g")
            .attr('transform', function(d){ return 'translate(0 ' + d.y + ')' })
            .attr('class', function(d){ return (d.fullModelId === (scope.selectedModel||{}).fullModelId) ?
                "selected doctor-results-graph-line" : "doctor-results-graph-line";
            });
        var showPopup = function(d) {
            changeSelectedModel(d);
            div.transition().duration(200).style("opacity", 1);
            div.html(d.mainMetric.toFixed(3)).style("left", (d3.event.pageX - 22) + "px").style("top", (d3.event.pageY - 32) + "px");
        };
        var hidePopup = function(d) {
            div.transition().duration(500).style("opacity", 0);
        };
        pointlines.append("line")
            .attr({x1:0,y1:0,x2:20,y2:0,fill:"#2d2d2d"})
            .attr("stroke", function(d){ return d.color })
            .on("mouseover", showPopup).on("mouseout", hidePopup);
        pointlines.append("circle")
            .attr({cx:0,cy:0,r:3})
            .attr("fill", "#2d2d2d")
            .attr("stroke", function(d){ return d.color })
            .on("mouseover", showPopup).on("mouseout", hidePopup);
        pointlines.append("circle")
            .attr({cx:20,cy:0,r:3,fill:"#2d2d2d"})
            .attr("stroke", function(d){ return d.color })
            .on("mouseover", showPopup).on("mouseout", hidePopup);

        pointlines.append("text").attr({x:30,y:4})
            .text(function(d){ return d.userMeta.name })
            .attr("fill", function(d){ return d.color })
            .on("mouseover", function(d) { changeSelectedModel(d) });
    }, {}, function() {
        d3.select('body').selectAll('div.gridsearch.tooltip').remove();
    }
);

function objdiff(a,b) {
    var diff = {};
    angular.forEach(a, function(v,k){
        if (a[k] != b[k] && a[k] !== undefined && b[k] !== undefined) {
            diff[k] = [a[k], b[k]];
        }
    });
    return diff;
}

chartDirective('gridsearchCurve',
    { sessionId: '=', selectedModel: '=', allModels: '=', currentMetric: '=', lowerIsBetter: '=', showEveryResult: '=', customEvaluationMetricGib: '='},
    ["sessionId", "selectedModel", "allModels", "currentMetric"],
    function(scope, Collections) {
        return Object.values(scope.allModels).filter(function(snippet){
            return snippet.sessionId === scope.sessionId && snippet.gridsearchData && snippet.gridsearchData.gridPoints.length > 0;
        }).map(function(snippet){
            var values = [], cumTime = 0, bestParams = {}, lastbestParams = {};
            var metric = snippet.gridsearchData.metric;
            var maxScore = scope.lowerIsBetter(metric, scope.customEvaluationMetricGib) ? Number.MAX_VALUE : -1 * Number.MAX_VALUE;
            snippet.gridsearchData.gridPoints.sort(function(a,b){ return (a.finishedAt-b.finishedAt) })
            .forEach(function(gridPoint){
                const thisPointTrainTime = gridPoint.time / 1000 / snippet.gridsearchData.nSplits || 1;
                cumTime += thisPointTrainTime;
                if (scope.showEveryResult) {
                    maxScore = gridPoint.score;
                } else {
                    maxScore = scope.lowerIsBetter(metric, scope.customEvaluationMetricGib) ? Math.min(maxScore, gridPoint.score) : Math.max(maxScore, gridPoint.score);
                }
                lastbestParams = bestParams;
                if (values.length == 0) {
                    values.push({x:0, y:maxScore, p:{}, pd:{}});
                }
                bestParams = maxScore == gridPoint.score ? gridPoint.parameters : bestParams;
                values.push({x:cumTime, y:maxScore, time: thisPointTrainTime, p:angular.copy(bestParams), pd:objdiff(lastbestParams, bestParams)});
            });
            return {
                values: values,
                metric: metric,
                model: snippet,
                xlast: values.length>0 ? values[values.length-1].x : 0,
                ylast: values.length>0 ? values[values.length-1].y : 0,
            };
        });
    }, function(scope, element, $filter) {
        var changeSelectedModel = function(nv) {
            scope.selectedModel = nv;
            scope.$apply();
        };
        let maxx = d3.max(scope.theData.map(function(c){ return d3.max(c.values, function(d){ return d.x }) })),
            maxy = d3.max(scope.theData.map(function(c){ return d3.max(c.values, function(d){ return d.y }) })),
            miny = d3.min(scope.theData.map(function(c){ return d3.min(c.values, function(d){ return d.y }) })),
            yAxisFormatFn = d3.format('04.3f'),
            yAxisLabelChars = Math.max(yAxisFormatFn(maxy).length, yAxisFormatFn(miny).length),
            margin = {top: 0, right: 10, bottom: 15, left: 23 + Math.round(yAxisLabelChars * 5.5)},
            width = element.width() - margin.left - margin.right,
            height = element.height() - margin.top - margin.bottom,
            chart = d3.select(element.get(0)).html(''),
            baseTime = 30, powTime = 2, minx = -1,
            ydiff = Math.max(maxy - miny, Math.abs(0.01*miny)),
            tooltipScope = scope.$parent;

        maxy = maxy + 0.3 * ydiff;
        miny = miny - 0.3 * ydiff;
        maxx = Math.pow(powTime,(Math.max(0,Math.ceil(
            log10(maxx/baseTime)/log10(powTime)
        ))))*baseTime;
        var minFormat = maxx > 120;

        // the main object where the chart and axis will be drawn
        var main = chart.append('g')
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
            .attr('width', width).attr('height', height).attr('class', 'main');

        var x = d3.scale.linear().domain([minx, maxx]).range([ 0, width ]);
        var xAxis = d3.svg.axis().scale(x).orient('bottom').ticks(8).tickSize(0,0).tickFormat(function(d){
            var m = Math.floor(d/60), s = Math.floor(d) % 60;
            if (!minFormat && m < 1) { return s + 's' }
            else if (!minFormat && m < 2) { return m + ':' + ("0" + s).slice(-2) }
            else { return m }
        });
        main.append('g').attr('transform', 'translate(0,' + height + ')').attr('class', 'main axis date').call(xAxis);

        //attr('x',width-60).attr('y',height-5)

        var y = d3.scale.linear().domain([miny, maxy]).range([ height, 0 ]);
        var yAxis = d3.svg.axis().scale(y).orient('left').ticks(4).tickSize(0,0).tickFormat(yAxisFormatFn);
        main.append('g').attr('transform', 'translate(0,0)').attr('class', 'main axis date').call(yAxis);


        chart.append('text').attr('text-anchor','middle').attr("transform", "rotate(-90, 12, " + height/2 + ")").attr('fill','#9d9d9d').attr('x',12).attr('y',height/2).text(function(){
            let txt = $filter('mlMetricName')(scope.theData[0].metric, scope.theData[0].model);
            if (!txt.toLowerCase().endsWith('score')) {
                txt += " score";
            }
            if(scope.theData[0].model.sampleWeightsEnabled) txt += " (weighted)";
            return txt;
        });

        main.selectAll("line.horizontalGrid").data(y.ticks(6)).enter().append("line").attr({
            class:"horizontalGrid", x1 : x(minx), x2 : width, y1 : y, y2 : y});

        main.selectAll("line.verticalGrid").data(x.ticks(6)).enter().append("line").attr({
            class:"verticalGrid", x1: x, x2: x, y1: y(maxy), y2: y(miny)});

        main.append('text').attr('text-anchor','end').attr('x',width).attr('y',height-8).text('Time '+ (minFormat ? '(min)':'(s)'));

        var pointlines = main.append("svg:g").selectAll("g").data(scope.theData).enter().append("g")
            .attr('class', function(d){ return d.model.fullModelId === (scope.selectedModel||{}).fullModelId ?
                    "selected gridsearch-scores-graph-line" : "gridsearch-scores-graph-line";
            });
        var line = d3.svg.line()
            .interpolate("monotone")
            .x(function(d) { return x(d.x); })
            .y(function(d) { return y(d.y); });
        var showPopup = function(d, model) {
            changeSelectedModel(model || d3.select(this.parentNode).datum().model);
            var html = '<table class="tooltip-table"><tr><td></td><td>' + sanitize($filter('mlMetricName')(scope.theData[0].metric, scope.theData[0].model)) + "</td><td>" +
                sanitize((d.y||d.ylast||0).toFixed(3)) + "</td></tr>";

            angular.forEach(d.p, function(v,k) {
                if (d.pd[k]) {
                    html += "<tr><td></td><td>" + sanitize(k) + "</td><td>" + sanitize(v) + "<span style='font-weight: normal'> (was " + sanitize(d.pd[k][0]) + ")</span></td></tr>";
                } else {
                    html += "<tr><td></td><td>" + sanitize(k) + "</td><td>" + sanitize(v) + "</td></tr>";
                }
            });
            html += "<tr><td></td><td>Train time</td><td>" + sanitize(durationHHMMSS(d.time)) + "</td></tr>";
            html += "</table>";

            tooltipScope.setTooltipContent(html);
            tooltipScope.showTooltip(margin.left + x(d.xlast || d.x), margin.top + y(d.ylast || d.y));
        };
        var hidePopup = function() {
            tooltipScope.hideTooltip();
        };
        pointlines.append("path").datum(function(d){return d.values})
            .attr("d", line).attr("zzstroke-width", 2).attr("fill", "none")
            .attr('stroke', function(d){ return d3.select(this.parentNode).datum().model.color })
            .on("mouseover", function(d) {
                changeSelectedModel(d3.select(this.parentNode).datum().model);
            });
        pointlines.selectAll("circle")
            .data(function(d){ return d.values })
            .enter().append("circle")
                .attr("opacity", function(d, i) { // Hide if there is going to be a X instead
                    var p = d3.select(this.parentNode).datum();
                    return (i === p.values.length - 1 && p.model.trainInfo.state === "FAILED") ? 0 : 1;
                })
                .attr('stroke', function(d){ return d3.select(this.parentNode).datum().model.color })
                .attr('fill', function(d){ return d3.select(this.parentNode).datum().model.color }) // overriden by css if :not(:hover)
                .attr("r", (d, i) => i == 0 ? 0 : 3)
                .attr("cx", function(e) { return x(e.x) }).attr("cy", function(e) { return y(e.y) })
                .attr("stroke-width","2px").on("mouseover", showPopup).on("mouseout", hidePopup);

        pointlines.append("g").each(function(d) {
            var g = d3.select(this);
            if (d.model.trainInfo.state === 'FAILED') {
                // Draw a nice X with 2 lines
                g.append("line")
                    .attr("x1", -5).attr("y1", 5).attr("x2", 5).attr("y2", -5)
                    .attr('stroke', function(d){ return d.model.color; })
                    .attr("stroke-width", "3px");

                g.append("line")
                    .attr("x1", -5).attr("y1", -5).attr("x2", 5).attr("y2", 5)
                    .attr('stroke', function(d){ return d.model.color; })
                    .attr("stroke-width", "3px");

                g.attr("transform", function(d) {
                    return "translate(" + x(d.xlast) + "," + y(d.ylast) + ")";
                });
            } else {
                g.append("circle")
                    .attr('cx',function(d){ return x(d.xlast) }).attr('cy',function(d){ return y(d.ylast) })
                    .attr('stroke', function(d){ return d.model.color; }) // overriden by css if :not(.DONE)
                    .attr('fill', function(d){ return d.model.color })
                    .attr("stroke-width","2px")
                    .attr('r', 5)
                    .attr('class', function(d){ return 'end-circle ' + d.model.trainInfo.state })
                    .on("mouseover", function(d) { showPopup(d.values[d.values.length-1], d.model); }).on("mouseout", hidePopup);
            }
        });
    }, {}, function() {
        d3.select('body').selectAll('div.gridsearch.tooltip').remove();
    }
);


chartDirective('kerasEpochCurve',
    { sessionId: '=', allModels: '=', currentMetric: '=', lowerIsBetter: '=', showEveryResult: '=', customEvaluationMetricGib: '='},
    ["sessionId", "allModels", "currentMetric"],
    function(scope) {
        let selectedModel =  Object.values(scope.allModels).filter(function(snippet){
            return snippet.sessionId === scope.sessionId && snippet.modelTrainingInfo && snippet.modelTrainingInfo.epochs.length > 0;
        })[0];

        let testValues = [];
        let trainValues = [];
        let cumTime = 0;
        let metric = selectedModel.modelTrainingInfo.metric;
        selectedModel.modelTrainingInfo.epochs
                     .sort(function(a,b){ return a.epoch-b.epoch })
                     .forEach(function(epochPoint){
                            const thisPointTrainTime = epochPoint.time / 1000;
                            cumTime += thisPointTrainTime;
                            const testScoreWithSign = scope.lowerIsBetter(metric, scope.customEvaluationMetricGib) ? - epochPoint.testScore : epochPoint.testScore;
                            const trainScoreWithSign = scope.lowerIsBetter(metric, scope.customEvaluationMetricGib) ? - epochPoint.trainScore : epochPoint.trainScore;
                            testValues.push({x: parseInt(epochPoint.epoch), y: testScoreWithSign, time: thisPointTrainTime, epoch: epochPoint.epoch, type: "Test"});
                            trainValues.push({x: parseInt(epochPoint.epoch), y: trainScoreWithSign, time: thisPointTrainTime, epoch: epochPoint.epoch, type:"Train"});
                     });

        const trainData = {
                metric: metric,
                model: selectedModel,
                values: trainValues,
                xlast: trainValues.length>0 ? trainValues[trainValues.length-1].x : 0,
                ylast: trainValues.length>0 ? trainValues[trainValues.length-1].y : 0,
                color: "#00bcd4"
        };

        const testData = {
                metric: metric,
                model: selectedModel,
                values: testValues,
                xlast: testValues.length>0 ? testValues[testValues.length-1].x : 0,
                ylast: testValues.length>0 ? testValues[testValues.length-1].y : 0,
                color: "#4caf50"
        };

        return [trainData, testData];

    }, function(scope, element, $filter) {

        let maxx = d3.max(scope.theData.map(function(c){ return d3.max(c.values, function(d){ return d.x }) })),
            maxy = d3.max(scope.theData.map(function(c){ return d3.max(c.values, function(d){ return d.y }) })),
            miny = d3.min(scope.theData.map(function(c){ return d3.min(c.values, function(d){ return d.y }) })),
            yAxisFormatFn = d3.format('04.3f'),
            yAxisLabelChars = Math.max(yAxisFormatFn(maxy).length, yAxisFormatFn(miny).length),
            margin = {top: 0, right: 10, bottom: 15, left: 23 + Math.round(yAxisLabelChars * 5.5)},
            width = element.width() - margin.left - margin.right,
            height = element.height() - margin.top - margin.bottom,
            chart = d3.select(element.get(0)).html(''),
            minx = -1,
            ydiff = Math.max(maxy - miny, Math.abs(0.01*miny)),
            tooltipScope = scope.$parent,
            numEpochs = (scope.theData && scope.theData.length > 0) ? scope.theData[0].values.length : 0;

        maxy = maxy + 0.3 * ydiff;
        miny = miny - 0.3 * ydiff;
        maxx = (maxx == 0) ? 1 : maxx + 1;

        // the main object where the chart and axis will be drawn
        var main = chart.append('g')
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
            .attr('width', width).attr('height', height).attr('class', 'main');

        var x = d3.scale.linear().domain([minx, maxx]).range([ 0, width ]);
        var xAxis = d3.svg.axis().scale(x).orient('bottom').ticks(Math.min(numEpochs + 1, 8)).tickSize(0,0).tickFormat(function(d) { return d;});

        main.append('g').attr('transform', 'translate(0,' + height + ')').attr('class', 'main axis date').call(xAxis);

        var y = d3.scale.linear().domain([miny, maxy]).range([ height, 0 ]);
        var yAxis = d3.svg.axis().scale(y).orient('left').ticks(4).tickSize(0,0).tickFormat(yAxisFormatFn);
        main.append('g').attr('transform', 'translate(0,0)').attr('class', 'main axis date').call(yAxis);


        chart.append('text').attr('text-anchor','middle').attr("transform", "rotate(-90, 12, " + height/2 + ")").attr('x',12).attr('y',height/2).text(function(){
            let txt = $filter('mlMetricName')(scope.theData[0].metric, scope.theData[0].model);
            if (!txt.toLowerCase().endsWith('score')) {
                txt += " score";
            }
            if(scope.theData[0].model.sampleWeightsEnabled) txt += " (weighted)";
            return txt;
        });

        main.selectAll("line.horizontalGrid").data(y.ticks(6)).enter().append("line").attr({
            class:"horizontalGrid", x1 : x(minx), x2 : width, y1 : y, y2 : y});

        main.selectAll("line.verticalGrid").data(x.ticks(6)).enter().append("line").attr({
            class:"verticalGrid", x1: x, x2: x, y1: y(maxy), y2: y(miny)});

        main.append('text').attr('text-anchor','end').attr('x',width).attr('y',height-8).text('Epoch #');

        var pointlines = main.append("svg:g").selectAll("g").data(scope.theData).enter().append("g").attr("class", "keras-epoch-scores-graph-line");

        var line = d3.svg.line()
            .interpolate("monotone")
            .x(function(d) { return x(d.x); })
            .y(function(d) { return y(d.y); });

        var showPopup = function(d, model) {
            var html = '<table class="tooltip-table"><tr><td></td><td><strong style="color: #333">'+d.type+'</strong></td></tr>';

            html+='<tr><td></td><td>' + sanitize($filter('mlMetricName')(scope.theData[0].metric, scope.theData[0].model)) + "</td><td>" +
                sanitize((d.y||d.ylast||0).toFixed(3)) + "</td></tr>";

            html += "<tr><td></td><td>Epoch #</td><td>" + sanitize(d.epoch) + "</td></tr>";
            html += "<tr><td></td><td>Train time</td><td>" + sanitize(durationHHMMSS(d.time)) + "</td></tr>";
            html += "</table>";

            tooltipScope.setTooltipContent(html);


            // Placing tooltip
            let xTooltip = margin.left + x(d.xlast || d.x);
            const yTooltip = margin.top + y(d.ylast || d.y);

            // Put tooltip on left if would go out of svg
            const tooltipWidth = $(".svg-tooltip").outerWidth();
            const svgWidth = $('svg.keras-epoch-curve').width();

            if (xTooltip + tooltipWidth > svgWidth) {
                xTooltip -= $(".svg-tooltip").outerWidth() + 3;
            }
            tooltipScope.showTooltip(xTooltip, yTooltip);

        };
        var hidePopup = function() {
            tooltipScope.hideTooltip();
        };

        pointlines.append("path").datum(function(d){return d.values})
            .attr("d", line).attr("zzstroke-width", 2).attr("fill", "none")
            .attr('stroke', function(d){ return d3.select(this.parentNode).datum().color; })
            .attr('stroke-width', "2px")
            .attr('stroke-opacity', "1")
        pointlines.selectAll("circle")
            .data(function(d){ return d.values })
            .enter().append("circle")
                .attr("opacity", function(d, i) { // Hide if there is going to be a X instead
                    var p = d3.select(this.parentNode).datum();
                    return (i === p.values.length - 1 && p.model.trainInfo.state === "FAILED") ? 0 : 1;
                })
                .attr('stroke', function(d){ return d3.select(this.parentNode).datum().color; })
                .attr("r", 3)
                .attr("cx", function(e) { return x(e.x) }).attr("cy", function(e) { return y(e.y) })
                .attr('fill', function(d){ return d3.select(this.parentNode).datum().color; }) // overriden by css if :not(:hover)
                .attr("stroke-width","2px").on("mouseover", showPopup).on("mouseout", hidePopup)
                .attr('stroke-opacity', "1")

        pointlines.append("g").each(function(d) {
            var g = d3.select(this);
            if (d.model.trainInfo.state === 'FAILED') {
                // Draw a nice X with 2 lines
                g.append("line")
                    .attr("x1", -5).attr("y1", 5).attr("x2", 5).attr("y2", -5)
                    .attr('stroke', function(d){ return d.color; })
                    .attr("stroke-width", "3px");

                g.append("line")
                    .attr("x1", -5).attr("y1", -5).attr("x2", 5).attr("y2", 5)
                    .attr('stroke', function(d){ return d.color; })
                    .attr("stroke-width", "3px");

                g.attr("transform", function(d) {
                    return "translate(" + x(d.xlast) + "," + y(d.ylast) + ")";
                });
            } else {
                g.append("circle")
                    .attr('cx',function(d){ return x(d.xlast) }).attr('cy',function(d){ return y(d.ylast) })
                    .attr('stroke', function(d){ return d.color; }) // overriden by css if :not(.DONE)
                    .attr('fill', function(d){ return d.color; })
                    .attr("stroke-width","2px")
                    .attr('r', 5)
                    .attr('class', function(d){ return 'end-circle ' + d.model.trainInfo.state })
                    .on("mouseover", function(d) { showPopup(d.values[d.values.length-1], d.model); }).on("mouseout", hidePopup);
            }
        });
    }, {}, function() {
        d3.select('body').selectAll('div.gridsearch.tooltip').remove();
    }
);

app.directive('kerasEpochProgress', function (Fn, MLChartsCommon) { return {
    scope: {sessionId: "=", allModels: "="},
    link: function(scope, element, attrs) {

        // Graph parameters

        let width,
            height,
            main,
            gradientArcIntervalID = null;


        const perEpochArc = {
            radius: 57,
            arcWidth: 2,
            startAngle: 0,
            endAngle: 2 * Math.PI
        };

        const globalArc = {
            radius: 68,
            arcWidth: 4,
            startAngle: 230 * Math.PI / 180,
            endAngle: 2 * Math.PI + 130 * Math.PI / 180,
        };


        function buildGraph() {

            let chart = d3.select(element.get(0)).html('');

            width = element.width();
            height = element.height();

            main = chart.append('g')
                        .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')')
                        .attr('class', 'main');

            // Text inside progress chart

            let text = main.append("text")
                .attr("class", "epoch-number")
                .attr("fill", "#ffffff")
                .attr("text-anchor", "middle");

            text.append("tspan")
                .text("Epoch")
                .attr("style", "font-size: 18px;")
                .attr("y", -15);

            text.append("tspan")
                .attr("class", "epoch-number")
                .attr("style", "font-size: 18px;")
                .attr("y", 5)
                .attr("x", 0);

            text.append("tspan")
                .attr("class", "epoch-progress")
                .attr("style", "font-size: 14px;")
                .attr("y", 25)
                .attr("x", 0);

            // Background arc for global arc

            let backgroundArc = d3.svg.arc()
                .innerRadius(function(d) { return d.radius - d.arcWidth;})
                .outerRadius(function(d) { return d.radius;})
                .startAngle(function(d) { return d.startAngle;})
                .endAngle(function(d) { return d.endAngle;})

            main.append("path")
                .attr('class', 'arc-complementary')
                .attr("fill", "#708a97")
                .attr("d", backgroundArc(globalArc));


            // Background arc with moving gradient for perEpoch arc
            // To achieve the result, we draw a lot of small adjacent arcs with evolving colors
            // and make them move periodically

            function getGradientArcData(numArcs, arc) {

                const colorScale = d3.scale
                                   .linear()
                                   .domain([0, 0.25, 0.5, 0.75, 1])
                                   .range(["#5F7D8C", "#AABFCA", "#5F7D8C", "#AABFCA", "#5F7D8C"]);

                let data = [];
                for (let i = 0; i < (numArcs - 1); i++) {
                    data[i] = {
                        i: i,
                        radius: arc.radius,
                        arcWidth: arc.arcWidth,
                        color: colorScale(i / numArcs)
                    };
                }

                return data;

            }

            const numArcsInGradient = 200;
            const gradientData = getGradientArcData(numArcsInGradient, perEpochArc);

            let gradientArc = d3.svg.arc()
                .innerRadius(function(d) { return d.radius - d.arcWidth;})
                .outerRadius(function(d) { return d.radius;})
                .startAngle(function(d) { return d.i / numArcsInGradient * 2 * Math.PI;})
                .endAngle(function(d) { return 1.01 * (d.i + 1) / numArcsInGradient * 2 * Math.PI;}) // We multiply by 1.01 to make arcs overlap

            main.selectAll("path.gradient-arc")
                .data(gradientData, function(d) { return d.i;})
                .enter()
                .append("path")
                .attr("class", "gradient-arc")
                .attr("fill", function(d) { return d.color;})
                .attr("d", gradientArc);

            if (gradientArcIntervalID !== null) {
                clearInterval(gradientArcIntervalID);
            }

            gradientArcIntervalID = setInterval(function() {
                gradientData.forEach(function(d) {
                    d.i = (d.i + 1) % numArcsInGradient;
                });
                main.selectAll("path.gradient-arc")
                    .data(gradientData, function(d) { return d.i;})
                    .attr("fill", function(d) { return d.color;})
                    .attr("d", gradientArc);
            }, 10);

        }

        // Retrieving data

        function getData() {
            let selectedModel =  Object.values(scope.allModels).filter(function(snippet){
                return snippet.sessionId === scope.sessionId && snippet.modelTrainingInfo;
            })[0];

            const currentTraining = selectedModel.modelTrainingInfo.currentNumStepsTraining;
            const totalTraining = selectedModel.modelTrainingInfo.nbStepsTrainingPerEpoch;

            const currentScoring = selectedModel.modelTrainingInfo.currentNumStepsScoring;
            const totalScoring = selectedModel.modelTrainingInfo.nbStepsScoringPerEpoch;

            // We split the time spent on one epoch between training and scoring and
            // empirically decide how to split it
            const shareTraining = 90;
            const percentagePerEpoch = Math.floor(shareTraining * currentTraining / totalTraining + (100 - shareTraining) * currentScoring / totalScoring);

            const currentEpoch = selectedModel.modelTrainingInfo.currentEpoch + 1;
            const totalEpochs = selectedModel.modelTrainingInfo.nbEpochs;
            const percentageGlobal = Math.floor( 100 * ((currentEpoch - 1) + (percentagePerEpoch / 100))/ totalEpochs );

            return {
                currentEpoch: currentEpoch,
                totalEpochs: totalEpochs,
                percentagePerEpoch: percentagePerEpoch,
                percentageGlobal: percentageGlobal
            }

        }

        // Moving arcs (perEpoch and global) and change text

        function customInterpolate(startArc, endArc) {
            const start = startArc.percentage;
            let end = endArc.percentage;

            if (start > end) {
                end += 100;
            }

            const i = d3.interpolate(start, end);

            const newArcValue = angular.copy(startArc);
            return function(t) {
                const newPercentage = i(t)
                newArcValue.percentage = (newPercentage != 100) ? newPercentage % 100 : 100;
                return newArcValue;
            }
        }

        function arcTween(d) {
            let interpolator = customInterpolate(this._current, d);
            this._current = interpolator(0);
            return function (t) {
                return progressArc(interpolator(t));
            };
        }

        let progressArc = d3.svg.arc()
            .innerRadius(function(d) { return d.radius - d.arcWidth;})
            .outerRadius(function(d) { return d.radius;})
            .startAngle(function(d) { return d.minAngle;})
            .endAngle(function(d) { return d.minAngle + (d.maxAngle - d.minAngle) * d.percentage / 100; });


        const textPercentFormat = d3.format("02f");

        function drawMovingArcs(data) {

            const arcs = [
                {
                    type : "perEpoch",
                    radius: 57,
                    arcWidth: 2,
                    minAngle: 0,
                    maxAngle: 2 * Math.PI,
                    percentage: data.percentagePerEpoch
                },
                {
                    type : "global",
                    radius: 68,
                    arcWidth: 4,
                    minAngle: 230 * Math.PI / 180,
                    maxAngle: 2 * Math.PI + 130 * Math.PI / 180,
                    percentage: data.percentageGlobal
                },
            ];


            main.selectAll("path.arc")
                .data(arcs, function(d) {return d.type;})
                .enter()
                .append("path")
                .attr('class', 'arc')
                .attr("fill", "#ffffff")
                .attr("d", progressArc)
                .each(function(d) {this._current = d;})

            main.selectAll("path.arc")
                .data(arcs, function(d) {return d.type;})
                .transition()
                .duration(500)
                .attrTween("d", arcTween);


            main.select("tspan.epoch-number")
                .text(data.currentEpoch + "/" + data.totalEpochs);

            main.select("tspan.epoch-progress")
                .text(textPercentFormat(data.percentagePerEpoch) + "%");

        }


        // Init & watchers

        buildGraph();

        scope.$watch("allModels", function(nv) {
            let data = getData();
            drawMovingArcs(data);
        }, true);

        scope.$watch("sessionId", function(nv) {
            let data = getData();
            drawMovingArcs(data);
        }, true);

        MLChartsCommon.installRedrawListener(scope, function() {
            let data = getData();
            buildGraph();
            drawMovingArcs(data);
        });

    }
}; });

chartDirective('bcRocCurve', { data: '=', colors: '=', loadedStateField: "=?", disableTransitions: "=?" }, "data",
    function(scope) { return scope.data.map(function(d, i, a) {
        return { values: d, key: "Fold #" + (i+1), color: a.length > 1 ? scope.colors[i] : 'url(#ppg)' }; });
    }, function(scope, element) {
        d3.selectAll('.nvtooltip').style('opacity', '0');
        var width = element.width(),
            height = element.height(),
            margin = {top: 10, right: 20, bottom: 50, left: 60},
            folds = scope.theData.length > 1,
            chart = nv.models.lineChart()
                .width(width) .height(height) .margin(margin)
                .forceX([0, 1]) .forceY([0, 1])
                .showLegend(false);
                
        chart.tooltip.contentGenerator( function(data) {
            var p = parseFloat(data.point.p);
            return ['<p>', folds ? '<strong>' + data.series[data.point.series].key + '</strong><br>' : '',
                'At p = ' + (Math.round(p * 100) / 100), '</p>',
                '<ul class="unstyled" style="padding-left: 0.8em; padding-right: 0.8em;">',
                '  <li>', Math.round(parseFloat(data.point.y) * 100), '% true  positive</li>',
                '  <li>', Math.round(parseFloat(data.point.x) * 100), '% false positive</li>',
                '</ul>'].join('');
        });
        const svg = d3.select(element.get(0)).html('');
        chart.xAxis.axisLabel(scope.data.xlabel).tickFormat(d3.format('%'));
        chart.yAxis.axisLabel(scope.data.ylabel).tickFormat(d3.format('%'));
        chart.options({tooltip: {chartContainer: document.body }});

        // Median line
        svg.append('g').attr('class','rocmedline').append("path")
            .attr('d', ['M', margin.left, ',', height - margin.bottom,
                       ' L',  width - margin.right, ',', margin.top].join(''))
            .style("stroke", "LightCoral").style("stroke-width", "2").style("stroke-dasharray", "3");

        if (! folds) { // Color gradient, skewed to reflect predicted probability
            var colorScale = d3.scale.linear().range(scope.colors.slice(0, 2));
            svg.append("linearGradient").attr("id", "ppg").attr("gradientUnits", "userSpaceOnUse")
                .attr("x1", "0%").attr("y1", "100%").attr("x2", "100%").attr("y2", "0%")
                .selectAll("stop").data(scope.theData[0].values).enter().append("stop")
                    .attr("offset", function(d) { return Math.round((d.x + d.y) * (1-d.p) * 50) + '%'; })
                    .attr("stop-color", function(d) { return colorScale(d.p); });
        }

        let transitionDuration = 500;
        if (scope.disableTransitions) {
            console.info("Disabling chart transitions");
            chart.duration(0);
            transitionDuration = 0;
        }

        svg.datum(scope.theData).transition().duration(transitionDuration).call(chart);

        if (! folds) { // Append color legend
            var legend = svg.append("g"),
                llg = legend.append("linearGradient").attr("id", "ppgl");
            llg.append("stop").attr("offset", "0%"  ).attr("stop-color", colorScale(0));
            llg.append("stop").attr("offset", "100%").attr("stop-color", colorScale(1));
            legend.attr("transform", "translate(" + (width - 200) + "," + (height - 100) + ")");
            legend.append("rect").attr("x", 10).attr("y", 5).
                attr("width", 100).attr("height", 20).attr("fill", "url(#ppgl)");
            legend.append("text").text("Predicted proba.").attr("x", 60).attr('text-anchor', 'middle');
            legend.append("text").text("0").attr("y", 20);
            legend.append("text").text("1").attr("y", 20).attr("x", 115);
        }
    });

chartDirective('bcCalibrationCurve', { data: '=', colors: '=', loadedStateField: "=?", disableTransitions: "=?" }, "data",
    function(scope) { return scope.data.map(function(d, i, a) {
        return { values: d, key: "Fold #" + (i+1), color: a.length > 1 ? scope.colors[i] : 'url(#ppg)' }; });
    }, function(scope, element) {
        d3.selectAll('.nvtooltip').style('opacity', '0');
        var width = element.width(),
            height = element.height(),
            margin = {top: 10, right: 20, bottom: 50, left: 60},
            folds = scope.theData.length > 1,
            chart = nv.models.lineChart()
                .width(width) .height(height) .margin(margin)
                .forceX([0, 1]) .forceY([0, 1])
                .showLegend(false);
            chart.tooltip.contentGenerator( function(data) {
                return ['<p>', folds ? '<strong>' + data.series[data.point.series].key + '</strong><br>' : '',
                    '</p>',
                    '<ul class="unstyled" style="padding-left: 0.8em; padding-right: 0.8em;">',
                    '  <li>', Math.round(parseFloat(data.point.y)*100), '% frequency of positives</li>',
                    '  <li>', Math.round(parseFloat(data.point.x)*100), '% average probability of predicted positive</li>',
                    '  <li>', Math.round(parseFloat(data.point.n)), ' test elements in bin</li>',
                    '</ul>'].join('');
            });
        const svg = d3.select(element.get(0)).html('');
        chart.xAxis.axisLabel(scope.data.xlabel).tickFormat(d3.format('%'));
        chart.yAxis.axisLabel(scope.data.ylabel).tickFormat(d3.format('%'));
        chart.options({tooltip: {chartContainer: document.body }});

        // Median line
        svg.append('g').attr('class','calmedline').append("path")
            .attr('d', ['M', margin.left, ',', height - margin.bottom,
                       ' L',  width - margin.right, ',', margin.top].join(''))
            .style("stroke", scope.colors[0]).style("stroke-width", "2").style("stroke-dasharray", "3");

        var colorScale = d3.scale.linear().range(scope.colors.slice(0, 2));
        svg.append("linearGradient")
           .attr("id", "ppg")
           .attr("x1", "0").attr("y1", "0").attr("x2", "1").attr("y2", "0")
           .selectAll("stop").data(scope.theData[0].values).enter().append("stop")
                .attr("offset", function(d, i) { return d.x; })
                .attr("stop-color", function(d) { return colorScale(Math.abs(2*(d.y - d.x))); });

        let transitionDuration = 500;
        if (scope.disableTransitions) {
            console.info("Disabling chart transitions");
            chart.duration(0);
            transitionDuration = 0;
        }

        svg.datum(scope.theData).transition().duration(transitionDuration).call(chart);

        // Append color legend
        var legend = svg.append("g"),
            llg = legend.append("linearGradient").attr("id", "ppgl");
        llg.append("stop").attr("offset", "0%"  ).attr("stop-color", colorScale(0));
        llg.append("stop").attr("offset", "100%").attr("stop-color", colorScale(1));
        legend.attr("transform", "translate(" + (width - 200) + "," + (height - 100) + ")");
        legend.append("rect").attr("x", 10).attr("y", 5).
            attr("width", 100).attr("height", 20).attr("fill", "url(#ppgl)");
        legend.append("text").text("Calibration loss").attr("x", 60).attr('text-anchor', 'middle');
        legend.append("text").text("0").attr("y", 20);
        legend.append("text").text("0.5").attr("y", 20).attr("x", 115);
});

chartDirective('rScatterPlot', { data: '=', colors: '=', loadedStateField: "=?", disableTransitions: "=?" }, "data",
    function(scope) {
        var errors = scope.data.x.map(function(x, i) { return Math.abs(x - this[i]); }, scope.data.y),
            maxErr = d3.max(errors),
            colorScale = d3.scale.linear().range(['green', 'orange', 'red']).domain([0, maxErr / 2, maxErr])
        return [{
            key: "Values",
            values: scope.data.x.map((x, i) => { return { x: x, y: scope.data.y[i], error: errors[i], color: colorScale(errors[i])}})
        }]
    }, function(scope, element, $timeout) {
        var all = [].concat.apply(scope.data.x, scope.data.y);
        var width = element.width(),
            height = element.height(),
            margin = {top: 10, right: 20, bottom: 40, left: 60},
            fmt = d3.format('.3s'),
            domain = [d3.min(all), d3.max(all)],
            chart = nv.models.scatterChart()
                .width(width) .height(height) .margin(margin)
                .forceX(domain).forceY(domain).showLegend(false),
            elt = element.get(0),
            svg = d3.select(elt).html('');

        chart.tooltip.contentGenerator( function(data) {
                return ['<p>Error = ' + fmt(data.point.error), '</p>'].join(''); })
        chart.xAxis.axisLabel('Actual values').tickFormat(fmt);
        chart.yAxis.axisLabel('Predicted values').tickFormat(fmt);

        let transitionDuration = 500;
        if (scope.disableTransitions) {
            console.info("Disabling chart transitions x2");
            // Does not work - as of nvd3 1.8.6 - (see https://github.com/novus/nvd3/issues/2048)...
            chart.duration(0);
            // ...so we work around the issue with the following lines:
            chart.xAxis.duration(0);
            chart.yAxis.duration(0);
            chart.distX.duration(0);
            chart.distY.duration(0);
            chart.scatter.duration(0);
            transitionDuration = 0;
        }

        svg.datum(scope.theData).transition().duration(transitionDuration).call(chart);

        svg.append('g').datum(scope.theData).transition().duration(transitionDuration).call(chart);
        svg.append('g').attr('class','scattermedline').append("path") // Median line
            .style("stroke", "LightCoral").style("stroke-width", "2").style("stroke-dasharray", "3")
            .attr('d', ['M', margin.left, ',', height - margin.bottom,
                        'L', width - margin.right, ',', margin.top].join(''));
        d3.selectAll('.nv-point')
        .attr({
            'fill':   (d) => d[0].color
        })
    });

/** Generic categorical heatmap with tooltip.
 * x        Array of x values (categorical)
 * y        Array of y values (categorical)
 * values   Array of values to fill the heatmap
 * xLabel   X axis label
 * yLabel   Y axis label
 * valuesLabel   Values label
 * callback Function(svg, scope) to be called after (re)drawing [Optional]
 * hideTooltip Boolean to disable tooltip [Optional]
 * hideLegend Boolean to hide the legend [Optional]
 * hideXLabel Boolean to hide the x axis label [Optional]
 * hideYLabel Boolean to hide the y axis label [Optional]
 * hideValuesLabel Boolean to hide the y color scale label [Optional]
 **/
chartDirective('categoriesHeatmap',
    {
        x: '=',
        y: '=',
        values: '=',
        xLabel: '=',
        yLabel: '=',
        valuesLabel: '=',
        callback: '=?',
        hideTooltip: '=?',
        hideLegend: '=?',
        hideXLabel: '=?',
        hideYLabel: '=?',
        hideValuesLabel: '=?',
    },
    '[x, y, values]',
    function (scope, Fn) {
        if (!scope.x || !scope.y || !scope.values || !scope.xLabel || !scope.yLabel || !scope.valuesLabel) {
            return null;
        }
        scope.callback = typeof scope.callback === 'function' ? scope.callback : Fn.NOOP;
        return scope.x.map((xVal, i) => ({ x: xVal, y: scope.y[i], value: scope.values[i] }));
    },
    function (scope, element, MLChartsCommon) {
        element.css('position', 'relative');

        // Compute min and max values
        let minValue = Math.min(...scope.values),
            maxValue = Math.max(...scope.values);
        // set the dimensions and margins of the graph and legend
        let fullWidth = element.width();
        let fullHeight = element.height();
        let legendFullWidth = !scope.hideLegend ? 57 : 0;
        let margin = { top: 15, right: 15, bottom: 40, left: 55 };
        let width = fullWidth - margin.left - margin.right - legendFullWidth;
        let height = fullHeight - margin.top - margin.bottom;
        let elt = element.get(0);
        // Initialize graph, legend, and tooltip
        let containerSvg = d3
            .select(elt)
            .html('')
            .append('svg')
            .attr('width', fullWidth)
            .attr('height', fullHeight);
        let svg = containerSvg.append('g').attr('transform', `translate(${margin.left}, ${margin.top})`);

        // Build X scale and axis:
        let xScale = buildXScaleAxis();


        // Build Y scale and axis:
        let yScale = buildYScaleAxis();

        // Build color scale
        // Sequential color scale from https://colorbrewer2.org/#type=sequential&scheme=GnBu&n=9
        let colorScaleArray = ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'];

        const valueslog = (minValue > 0) && (maxValue / minValue > 10);

        let colorScale = d3.scale.linear().range(colorScaleArray);

        if (valueslog) {
            colorScale.domain(
                MLChartsCommon.linspace(Math.log10(minValue), Math.log10(maxValue), colorScaleArray.length)
            );
        } else {
            colorScale.domain(MLChartsCommon.linspace(minValue, maxValue, colorScaleArray.length));
        }

        // If not hidden, build color legend
        if (!scope.hideLegend) {
            let legendMargin = { top: 25, right: 37, bottom: 50, left: 12 };
            let legendWidth = legendFullWidth - legendMargin.left - legendMargin.right;
            let legendHeight = fullHeight - legendMargin.top - legendMargin.bottom;
            let legendSvg = containerSvg
                .append('g')
                .attr('transform', `translate(${margin.left + width + margin.right}, 0)`);

            // Set number of ticks, not to clutter the plot for small dimensions
            let nVerticalTicks = Math.floor(fullHeight / 100) + 3;

            MLChartsCommon.makeColorScale(
                legendSvg,
                legendWidth,
                legendHeight,
                legendMargin,
                nVerticalTicks,
                colorScaleArray,
                minValue,
                maxValue,
                valueslog,
                scope.valuesLabel,
                scope.hideValuesLabel
            );
        }

        // Draw the color rectangles in the graph with or without tooltip
        drawRectsAndTooltip(
            svg,
            scope.xLabel,
            scope.yLabel,
            scope.valuesLabel,
            scope.theData,
            xScale,
            yScale,
            colorScale,
            margin,
            scope.hideTooltip
        );

        // Final callback
        scope.callback(svg, scope);

        function buildXScaleAxis() {
            let xUnique = d3.map(scope.theData, (d) => d.x).keys();

            let xScale = d3.scale.ordinal().domain(xUnique).rangeRoundBands([0, width], 0.05);
            let xAxis = svg
                .append('g')
                .attr('transform', `translate(0, ${height})`)
                .call(d3.svg.axis().scale(xScale).orient('bottom').tickSize(0));
            xAxis.selectAll('text').style('text-anchor', 'middle');
            xAxis.select('.domain').remove();

            if (!scope.hideXLabel) {
                svg.append('text')
                    .style('text-anchor', 'middle')
                    .attr('x', 0.5 * width)
                    .attr('y', height + 30)
                    .style('font-weight', 'bold')
                    .text(scope.xLabel);
            }

            return xScale
        }

        function buildYScaleAxis() {
            let yUnique = d3.map(scope.theData, (d) => d.y).keys();

            let yScale = d3.scale.ordinal().domain(yUnique).rangeRoundBands([height, 0], 0.05);
            let yAxis = svg
                .append('g')
                .attr('transform', 'translate(-7, 0)')
                .call(d3.svg.axis().scale(yScale).orient('left').tickSize(0));
            yAxis.selectAll('text').attr('transform', 'rotate(-90)').style('text-anchor', 'middle');
            yAxis.select('.domain').remove();

            if (!scope.hideYLabel) {
                svg.append('g')
                    .attr('transform', `translate(${-0.5 * margin.left}, ${0.5 * height})`)
                    .append('text')
                    .style('text-anchor', 'middle')
                    .style('font-weight', 'bold')
                    .attr('transform', 'rotate(-90)')
                    .text(scope.yLabel);
            }

            return yScale;
        }

        /**
         * Function that draws the colored rectangles and moves/updates/shows/hides the tooltip
         * @param {d3 selection} svg : d3 selection of the plot
         * @param {string} xLabel x axis label
         * @param {string} yLabel y axis label
         * @param {string} valuesLabel values label
         * @param {Object[]} theData Array of objects { x, y, value }
         * @param {d3 scale} xScale Scaling function for x Axis
         * @param {d3 scale} yScale Scaling function for y Axis
         * @param {d3 scale} colorScale Scaling function for values colors
         * @param {Object} margin svg margins
         * @param {boolean} hideTooltip Boolean to disable tooltip
         */
        function drawRectsAndTooltip(
            svg,
            xLabel,
            yLabel,
            valuesLabel,
            theData,
            xScale,
            yScale,
            colorScale,
            margin,
            hideTooltip
        ) {
            // Draw the colored rectangles
            svg.selectAll()
            .data(theData, function (d) {
                return d.x + ':' + d.y;
            })
            .enter()
            .append('rect')
            .attr('x', function (d) {
                return xScale(d.x);
            })
            .attr('y', function (d) {
                    return yScale(d.y);
                })
                .attr('rx', 4)
                .attr('ry', 4)
                .attr('width', xScale.rangeBand())
                .attr('height', yScale.rangeBand())
                .style('fill', function (d) {
                    return colorScale(d.value);
                })
                .style('stroke-width', 4)
                .style('stroke', 'none')
                .style('opacity', 0.8);

            if (!hideTooltip) {
                // Tooltip values formatters
                const tooltipNumericFormat = MLChartsCommon.makeTooltipNumericFormatter(3, 4);

                const tooltip = d3
                    .select(elt)
                    .append('div')
                    .style('opacity', 0)
                    .style('background-color', 'rgba(255,255,255,0.9)')
                    .style('border', 'solid')
                    .style('border-width', '1px')
                    .style('border-radius', '5px')
                    .style('position', 'absolute')
                    .style('padding', '5px');

                const getTooltipHtml = function (x, y, value, xLabel, yLabel, valuesLabel) {
                    return `
                        <table class="mlchart-tooltip__table">
                            <tr>
                                <td class="mlchart-tooltip__label">${valuesLabel}</td>
                                <td class="mlchart-tooltip__value">${value}</td>
                            </tr>
                            <tr>
                                <td class="mlchart-tooltip__label">${xLabel}</td>
                                <td class="mlchart-tooltip__value">${x}</td>
                            </tr>
                            <tr>
                                <td class="mlchart-tooltip__label">${yLabel}</td>
                                <td class="mlchart-tooltip__value">${y}</td>
                            </tr>
                        </table>`;
                };

                // Three function that change the tooltip when user hover / move / leave a cell
                const mouseover = function (d) {
                    tooltip
                        .html(
                            getTooltipHtml(
                                d.x,
                                d.y,
                                tooltipNumericFormat(d.value),
                                xLabel ? xLabel : 'x',
                                yLabel ? yLabel : 'y',
                                valuesLabel ? valuesLabel : 'value'
                            )
                        )
                        .style('opacity', 1);
                    d3.select(this).style('stroke', 'black');
                };

                const mousemove = function (d) {
                    let mousePosition = d3.mouse(this);
                    let distance = 5; // Shift the tooltip from the cursor
                    let leftOffset = -0.7 * tooltip.node().offsetWidth + margin.left - distance;
                    let topOffset = -tooltip.node().offsetHeight + margin.top - distance;

                    if (mousePosition[0] + leftOffset < 0) {
                        leftOffset = -0.3 * tooltip.node().offsetWidth + margin.left + distance;
                    }
                    if (mousePosition[1] + topOffset < 0) {
                        topOffset = margin.top + distance;
                    }

                    tooltip
                        .style('left', mousePosition[0] + leftOffset + 'px')
                        .style('top', mousePosition[1] + topOffset + 'px');
                };

                const mouseleave = function (d) {
                    tooltip.style('opacity', 0).style('left', '0').style('top', '0').html('');
                    d3.select(this).style('stroke', 'none');
                };

                svg.selectAll('rect').on('mouseover', mouseover).on('mousemove', mousemove).on('mouseleave', mouseleave);
            }
        }

    }
);


/** Generic contour plot based on plotly.js contour plot algorithms
 * x        Array of x values (numerical)
 * y        Array of y values (numerical)
 * values   Array of values to fill the contourplot
 * xLabel   X axis label
 * yLabel   Y axis label
 * valuesLabel   Values label
 * nContours: Number of contours to be computed [Optional, 15 by default]
 * callback Function(svg, scope) to be called after (re)drawing [Optional]
 * hideLegend Boolean to hide the legend [Optional]
 * hidePoints Boolean to hide the points [Optional]
 * hideXLabel Boolean to hide the x axis label [Optional]
 * hideYLabel Boolean to hide the y axis label [Optional]
 * hideValuesLabel Boolean to hide the y color scale label [Optional]
 **/
chartDirective('contourPlot',
    {
        x: '=',
        y: '=',
        values: '=',
        xLabel: '=',
        yLabel: '=',
        valuesLabel: '=',
        nContours: '=?',
        callback: '=?',
        hideLegend: '=?',
        hidePoints: '=?',
        hideXLabel: '=?',
        hideYLabel: '=?',
        hideValuesLabel: '=?',
    },
    '[x, y, values]',
    function (scope, Fn) {
        if (!scope.x || !scope.y || !scope.values || !scope.xLabel || !scope.yLabel || !scope.valuesLabel) {
            return null;
        }
        scope.nContours = typeof scope.nContours === 'number' ? scope.nContours : 15;
        scope.callback = typeof scope.callback === 'function' ? scope.callback : Fn.NOOP;
        return scope.x.map((xVal, i) => ({ x: xVal, y: scope.y[i], value: scope.values[i] }));
    },
    function (scope, element, ContourPlotFactory, MLChartsCommon) {
        element.css('position', 'relative');

        // Compute min and max values
        let minValue = Math.min(...scope.values);
        let maxValue = Math.max(...scope.values);
        // set the dimensions and margins of the graph
        let fullWidth = element.width();
        let fullHeight = element.height();
        let legendFullWidth = !scope.hideLegend ? 57 : 0;
        let margin = { top: 15, right: 15, bottom: 40, left: 55 };
        let width = fullWidth - margin.left - margin.right - legendFullWidth;
        let height = fullHeight - margin.top - margin.bottom;
        let elt = element.get(0);
        // Initialize graph, legend, and tooltip
        let containerSvg = d3
            .select(elt)
            .html('')
            .append('svg')
            .attr('width', fullWidth)
            .attr('height', fullHeight);
        let svg = containerSvg.append('g').attr('transform', `translate(${margin.left}, ${margin.top})`);

        // Set number of ticks, not to clutter the plot for small dimensions
        let nHorizontalTicks = Math.floor(fullWidth / 100) + 2;
        let nVerticalTicks = Math.floor(fullHeight / 100) + 3;

        /**
         * @typedef {Object} Axis
         * @property {d3 axis} axis d3 axis to be called by the svg selection
         * @property {boolean} isLog True if the axis is logarithmic, False otherwise
         * @property {d3 scale} scale d3 scaling function (value -> pixel)
         */

        /**
         * Function that builds a generic d3 numerical axis
         * @param {number[]} data Array of numeric values
         * @param {number} nTicks Number of ticks on the axis
         * @param {number} size Size of the axis in pixels (height or width typically)
         * @param {boolean} vertical Whether it is a vertical axis or not
         * @returns {Axis}
         */
        let buildAxis = function (data, nTicks, size, vertical) {
            const min = Math.min(...data);
            const max = Math.max(...data);
            const numericFormat = MLChartsCommon.makeAxisNumericFormatter(min, max, 3, 1);

            const isLog = min > 0 && max / min > 10;

            const rangeInterval = vertical ? [size, 0] : [0, size];
            const domainInterval = isLog ? [Math.log10(min), Math.log10(max)] : [min, max];
            const scale = d3.scale.linear().range(rangeInterval).domain(domainInterval);

            const tickFormat = isLog ? (_) => numericFormat(10 ** _) : numericFormat;
            let axis = d3.svg.axis().scale(scale).tickSize(4).ticks(nTicks).tickFormat(tickFormat);
            if (vertical) {
                axis.orient('left');
            }

            return { axis, isLog, scale };
        };

        // Build X scale and axis:
        const xAxis = buildAxis(scope.x, nHorizontalTicks, width, false);

        let xAxisSvg = svg
            .append('g')
            .attr('transform', `translate(0, ${height})`)
            .call(xAxis.axis);
        xAxisSvg.select('.domain').remove();
        xAxisSvg.selectAll('line').style('stroke', 'black');

        if (!scope.hideXLabel) {
            svg.append('text')
                .style('text-anchor', 'middle')
                .attr('x', 0.5 * width)
                .attr('y', height + 30)
                .style('font-weight', 'bold')
                .text(xAxis.isLog ? `${scope.xLabel} (log)` : scope.xLabel);
        }

        // Build Y scale and axis:
        const yAxis = buildAxis(scope.y, nVerticalTicks, height, true);

        let yAxisSvg = svg.append('g').attr('transform', 'translate(0, 0)').call(yAxis.axis);
        yAxisSvg.select('.domain').remove();
        yAxisSvg.selectAll('line').style('stroke', 'black');

        if (!scope.hideYLabel) {
            svg.append('g')
                .attr('transform', `translate(-43, ${0.5 * height})`)
                .append('text')
                .style('text-anchor', 'middle')
                .style('font-weight', 'bold')
                .attr('transform', 'rotate(-90)')
                .text(yAxis.isLog ? `${scope.yLabel} (log)` : scope.yLabel);
        }

        // Build color scale

        // Sequential color scale from https://colorbrewer2.org/#type=sequential&scheme=GnBu&n=9
        let colorScaleArray = ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'];

        const valueslog = (minValue > 0) && (maxValue / minValue > 10);

        let colorScale = d3.scale.linear().range(colorScaleArray);

        if (valueslog) {
            colorScale.domain(
                MLChartsCommon.linspace(Math.log10(minValue), Math.log10(maxValue), colorScaleArray.length)
            );
        } else {
            colorScale.domain(MLChartsCommon.linspace(minValue, maxValue, colorScaleArray.length));
        }

        // If not hidden, build color legend
        if (!scope.hideLegend) {
            let legendMargin = { top: 25, right: 37, bottom: 50, left: 12 };
            let legendWidth = legendFullWidth - legendMargin.left - legendMargin.right;
            let legendHeight = fullHeight - legendMargin.top - legendMargin.bottom;
            let legendSvg = containerSvg
                .append('g')
                .attr('transform', `translate(${margin.left + width + margin.right}, 0)`);

            MLChartsCommon.makeColorScale(
                legendSvg,
                legendWidth,
                legendHeight,
                legendMargin,
                nVerticalTicks,
                colorScaleArray,
                minValue,
                maxValue,
                valueslog,
                scope.valuesLabel,
                scope.hideValuesLabel
            );
        }

        // Draw the contours and fills
        ContourPlotFactory.drawContours(
            svg,
            scope.x,
            scope.y,
            scope.values,
            xAxis.isLog,
            yAxis.isLog,
            valueslog,
            width,
            height,
            colorScale,
            scope.nContours
        );

        // If not hidden, draw the points with tooltip
        if (!scope.hidePoints) {
            let tooltip = d3
                .select(elt)
                .append('div')
                .style('opacity', 0)
                .style('background-color', 'rgba(255,255,255,0.9)')
                .style('border', 'solid')
                .style('border-width', '1px')
                .style('border-radius', '5px')
                .style('position', 'absolute')
                .style('padding', '5px');

            drawPointsWithTooltip(
                svg,
                tooltip,
                scope.xLabel,
                scope.yLabel,
                scope.valuesLabel,
                scope.theData,
                margin,
                xAxis,
                yAxis
            );
        }

        // Final callback
        scope.callback(svg, scope);

        /**
         * Function that draws the data points and moves/updates/shows/hides the tooltip
         * @param {d3 selection} svg : d3 selection of the plot
         * @param {d3 selection} tooltip d3 selection of the tooltip div
         * @param {string} xLabel x axis label
         * @param {string} yLabel y axis label
         * @param {string} valuesLabel values label
         * @param {Object[]} theData Array of objects { x, y, value }
         * @param {Object} margin svg margins
         * @param {Axis} xAxis
         * @param {Axis} yAxis
         */
        function drawPointsWithTooltip(
            svg,
            tooltip,
            xLabel,
            yLabel,
            valuesLabel,
            theData,
            margin,
            xAxis,
            yAxis
        ) {
            // Tooltip values formatters, more precise than axes
            let tooltipNumericFormat = MLChartsCommon.makeTooltipNumericFormatter(3, 4);

            let getTooltipHtml = function (x, y, value, xLabel, yLabel, valuesLabel) {
                return `
                    <table class="mlchart-tooltip__table">
                        <tr>
                            <td class="mlchart-tooltip__label">${valuesLabel}</td>
                            <td class="mlchart-tooltip__value">${value}</td>
                        </tr>
                        <tr>
                            <td class="mlchart-tooltip__label">${xLabel}</td>
                            <td class="mlchart-tooltip__value">${x}</td>
                        </tr>
                        <tr>
                            <td class="mlchart-tooltip__label">${yLabel}</td>
                            <td class="mlchart-tooltip__value">${y}</td>
                        </tr>
                    </table>`;
            };

            // Three function that change the tooltip when user hover / move / leave a cell
            let mouseover = function (d) {
                tooltip
                    .html(
                        getTooltipHtml(
                            tooltipNumericFormat(d.x),
                            tooltipNumericFormat(d.y),
                            tooltipNumericFormat(d.value),
                            xLabel ? xLabel : 'x',
                            yLabel ? yLabel : 'y',
                            valuesLabel ? valuesLabel : 'value'
                        )
                    )
                    .style('opacity', 1);
                d3.select(this).attr('r', 5).style('stroke', 'white');
            };

            let mousemove = function (d) {
                let mousePosition = d3.mouse(this);
                let distance = 5; // Shift the tooltip from the cursor
                let leftOffset = -0.7 * tooltip.node().offsetWidth + margin.left - distance;
                let topOffset = -tooltip.node().offsetHeight + margin.top - distance;

                if (mousePosition[0] + leftOffset < 0) {
                    leftOffset = -0.3 * tooltip.node().offsetWidth + margin.left + distance;
                }
                if (mousePosition[1] + topOffset < 0) {
                    topOffset = margin.top + distance;
                }

                tooltip
                    .style('left', mousePosition[0] + leftOffset + 'px')
                    .style('top', mousePosition[1] + topOffset + 'px');
            };

            let mouseleave = function (d) {
                tooltip.style('opacity', 0).style('left', '0').style('top', '0').html('');
                d3.select(this).attr('r', 3).style('stroke', 'none');
            };

            // Draw the points
            svg.selectAll('.dot')
                .data(theData)
                .enter()
                .append('circle')
                .attr('r', 3)
                .attr('cx', (d) => (xAxis.isLog ? xAxis.scale(Math.log10(d.x)) : xAxis.scale(d.x)))
                .attr('cy', (d) => (yAxis.isLog ? yAxis.scale(Math.log10(d.y)) : yAxis.scale(d.y)))
                .style('fill', 'black')
                .style('opacity', 0.7)
                .style('stroke-width', 1.5)
                .on('mouseover', mouseover)
                .on('mousemove', mousemove)
                .on('mouseleave', mouseleave);
        }
    }
);

chartDirective('univariateDataDistributionChart',
    {data: "=", colors: "="},
    "data",
    function(scope) {
        let binNames;
        if (scope.data.binNames) {
            binNames = scope.data.binNames.slice();
            binNames.push("Others");
        }
        return {
            "binNames": binNames,
            "binCounts": [scope.data.binCountsReference, scope.data.binCountsCurrent].map(
                (serial, i) => {
                    let sum = serial.reduce((acc, curr) => acc + curr, 0);
                    return {
                        values: serial.map( (v, j) => {
                            return {
                                value: v/sum,
                                count: v,
                                category: binNames?binNames[j]:undefined,
                                binIndex: j
                            }
                        }),
                        key: i?"Reference":"Current",
                        color: scope.colors[i]
                    }
                }
            ),
            "binEdges": scope.data.binEdges
        };
    },
    function(scope, element) {
        let width = element.width(),
            height = element.height(),
            margin = {top: 5, right: 5, bottom: 5, left: 5},
            max = scope.theData.binCounts.reduce((acc, curr) => Math.max(acc, curr.values.reduce((acc2, curr2) => Math.max(acc2, curr2.value), 0)), 0);

        let binX;
        if (scope.theData.binNames) {
            binX = scope.theData.binNames;
        } else {
            binX = [];
            for (let i = 0 ; i < scope.theData.binEdges.length -1 ; i++) {
                binX.push(((scope.theData.binEdges[i] + scope.theData.binEdges[i+1])/2).toFixed(2));
            }
        }
        let chart = nv.models.multiBarChart()
                             .width(width)
                             .height(height)
                             .margin(margin)
                             .x((_, i) => binX[i])
                             .y((d) => d.value)
                             .staggerLabels(false)
                             .showControls(false)
                             .showLegend(false)
                             .forceY([0, max])
                             .showXAxis(false)
                             .showYAxis(false)
                             .wrapLabels(true);

        let svg = d3.select(element.get(0)).html('');

        chart.tooltip.contentGenerator( function(data) {
            if (scope.theData.binNames) {
                return [
                    "<p><strong>Origin:</strong>&nbsp;" + data.data.key + "</p>",
                    "<p><strong>Category:</strong>&nbsp;" + data.data.category + "</p>",
                    "<p><strong>Count:</strong>&nbsp;" + data.data.count + "</p>",
                    "<p><strong>%:</strong>&nbsp;" + (data.data.value*100.).toFixed(2) + "</p>"
                ].join('');
            } else {
                return [
                    "<p><strong>Origin:</strong>&nbsp;" + data.data.key + "</p>",
                    "<p><strong>Bin:</strong>&nbsp;" + scope.theData.binEdges[data.data.binIndex] + " - " + scope.theData.binEdges[data.data.binIndex + 1] + "</p>",
                    "<p><strong>Count:</strong>&nbsp;" + data.data.count + "</p>",
                    "<p><strong>%:</strong>&nbsp;" + (data.data.value*100.).toFixed(2) + "</p>"
                ].join('');
            }
        });
        chart.options({tooltip: {chartContainer: document.body }});

        svg.datum(scope.theData.binCounts).transition().duration(100).call(chart);
    }
);
})();

(function () {
    'use strict';

    var app = angular.module('dataiku.ml.core');

    app.factory('ContourPlotFactory', function () {
        // Most functions in this factory are copied/adapted from Plotly.js 1.54.7,
        // by Plotly, Inc, released under the MIT license
        // https://github.com/plotly/plotly.js/tree/v1.54.7

        // More precisely blocks with a link to https://github.com/plotly/plotly.js/blob/v1.54.7/...
        // are directly copied/slightly modified from the Plotly.js code, while others without
        // the link are custom.

        // List of blocks copied from Plotly.js:
        // - findEmpties
        // - interp2d
        // - setContours
        // - emptyPathinfo
        // - makeCrossings
        // - setConvert
        // - findAllPaths
        // - closeBoundaries
        // - svg paths smoothing
        // - contours drawing

        let contourPlotFactory = {
            drawContours: drawContours,
        };

        // ----------------------------- draw contour plot------------------------------------------

        /**
         * Draw the contour plot
         *
         * @param {d3 selection} svg : d3 selection of the plot that will contain the contour plot
         * @param {number[]} x : Array of x values
         * @param {number[]} y : Array of y values
         * @param {number[]} z : Array of z values
         * @param {boolean} xlog : true if x scale is logarithmic, false otherwise
         * @param {boolean} ylog : true if y scale is logarithmic, false otherwise
         * @param {boolean} zlog : true if z scale is logarithmic, false otherwise
         * @param {number} width : plot width
         * @param {number} height : plot height
         * @param {d3 scale} colorScale : d3 color scale
         * @param {number} nContours: number of contours to be computed
         */
        function drawContours(svg, x, y, z, xlog, ylog, zlog, width, height, colorScale, nContours) {
            if (xlog) {
                x = x.map(Math.log10);
            }
            if (ylog) {
                y = y.map(Math.log10);
            }
            if (zlog) {
                z = z.map(Math.log10);
            }

            // First convert x, y to sorted deduplicated arrays
            // and z to an interpolated grid
            let { xUnique, yUnique, zGrid } = interpolateGrid(x, y, z);

            // Compute contours
            let contours = setContours(Math.min(...z), Math.max(...z), nContours);

            let xaxis = {
                width: width,
                range: [Math.min(...xUnique), Math.max(...xUnique)],
                letter: 'x',
            };

            let yaxis = {
                height: height,
                range: [Math.min(...yUnique), Math.max(...yUnique)],
                letter: 'y',
            };

            // Create empty paths
            let pathinfo = emptyPathinfo(contours, xaxis, yaxis, xUnique, yUnique, zGrid, 1);
            // Make crossings
            makeCrossings(pathinfo);
            // Find all paths
            findAllPaths(pathinfo);

            // Compute perimeter
            let leftedge = c2p(xaxis)(xUnique[0], true);
            let rightedge = c2p(xaxis)(xUnique[xUnique.length - 1], true);
            let bottomedge = c2p(yaxis)(yUnique[0], true);
            let topedge = c2p(yaxis)(yUnique[yUnique.length - 1], true);
            let perimeter = [
                [leftedge, topedge],
                [rightedge, topedge],
                [rightedge, bottomedge],
                [leftedge, bottomedge],
            ];

            // Make black background
            makeBackground(svg, perimeter);

            // Make contour fills
            makeFills(svg, pathinfo, perimeter, colorScale);
        }

        // ----------------------------- interpolateGrid -------------------------------------------

        function interpolateGrid(x, y, z) {
            let xUnique = x
                    .concat()
                    .sort((a, b) => a - b)
                    .filter(function (el, i, a) {
                        return i === a.indexOf(el);
                    }),
                yUnique = y
                    .concat()
                    .sort((a, b) => a - b)
                    .filter(function (el, i, a) {
                        return i === a.indexOf(el);
                    }),
                zGrid = new Array(yUnique.length),
                xHash = {},
                yHash = {};

            for (let row = 0; row < zGrid.length; row++) {
                zGrid[row] = new Array(xUnique.length);
            }

            for (let idx = 0; idx < x.length; idx++) {
                xHash[x[idx]] = xHash[x[idx]] !== undefined ? xHash[x[idx]] : xUnique.indexOf(x[idx]);
                yHash[y[idx]] = yHash[y[idx]] !== undefined ? yHash[y[idx]] : yUnique.indexOf(y[idx]);

                let row = yHash[y[idx]],
                    col = xHash[x[idx]];

                zGrid[row][col] = z[idx];
            }

            let empties = findEmpties(zGrid);

            return {
                xUnique: xUnique,
                yUnique: yUnique,
                zGrid: interp2d(zGrid, empties),
            };
        }

        // ----------------------------- findEmpties -------------------------------------------
        // https://github.com/plotly/plotly.js/blob/v1.54.7/src/traces/heatmap/find_empties.js

        /* Return a list of empty points in 2D array z
         * each empty point z[i][j] gives an array [i, j, neighborCount]
         * neighborCount is the count of 4 nearest neighbors that DO exist
         * this is to give us an order of points to evaluate for interpolation.
         * if no neighbors exist, we iteratively look for neighbors that HAVE
         * neighbors, and add a fractional neighborCount
         */
        function findEmpties(z) {
            var empties = [];
            var neighborHash = {};
            var noNeighborList = [];
            var nextRow = z[0];
            var row = [];
            var blank = [0, 0, 0];
            var rowLength = z[0].length;
            var prevRow;
            var i;
            var j;
            var thisPt;
            var p;
            var neighborCount;
            var newNeighborHash;
            var foundNewNeighbors;

            for (i = 0; i < z.length; i++) {
                prevRow = row;
                row = nextRow;
                nextRow = z[i + 1] || [];
                for (j = 0; j < rowLength; j++) {
                    if (row[j] === undefined) {
                        neighborCount =
                            (row[j - 1] !== undefined ? 1 : 0) +
                            (row[j + 1] !== undefined ? 1 : 0) +
                            (prevRow[j] !== undefined ? 1 : 0) +
                            (nextRow[j] !== undefined ? 1 : 0);

                        if (neighborCount) {
                            // for this purpose, don't count off-the-edge points
                            // as undefined neighbors
                            if (i === 0) neighborCount++;
                            if (j === 0) neighborCount++;
                            if (i === z.length - 1) neighborCount++;
                            if (j === row.length - 1) neighborCount++;

                            // if all neighbors that could exist do, we don't
                            // need this for finding farther neighbors
                            if (neighborCount < 4) {
                                neighborHash[[i, j]] = [i, j, neighborCount];
                            }

                            empties.push([i, j, neighborCount]);
                        } else noNeighborList.push([i, j]);
                    }
                }
            }

            while (noNeighborList.length) {
                newNeighborHash = {};
                foundNewNeighbors = false;

                // look for cells that now have neighbors but didn't before
                for (p = noNeighborList.length - 1; p >= 0; p--) {
                    thisPt = noNeighborList[p];
                    i = thisPt[0];
                    j = thisPt[1];

                    neighborCount =
                        ((neighborHash[[i - 1, j]] || blank)[2] +
                            (neighborHash[[i + 1, j]] || blank)[2] +
                            (neighborHash[[i, j - 1]] || blank)[2] +
                            (neighborHash[[i, j + 1]] || blank)[2]) /
                        20;

                    if (neighborCount) {
                        newNeighborHash[thisPt] = [i, j, neighborCount];
                        noNeighborList.splice(p, 1);
                        foundNewNeighbors = true;
                    }
                }

                if (!foundNewNeighbors) {
                    throw 'findEmpties iterated with no new neighbors';
                }

                // put these new cells into the main neighbor list
                for (thisPt in newNeighborHash) {
                    neighborHash[thisPt] = newNeighborHash[thisPt];
                    empties.push(newNeighborHash[thisPt]);
                }
            }

            // sort the full list in descending order of neighbor count
            return empties.sort(function (a, b) {
                return b[2] - a[2];
            });
        }

        // ----------------------------- interp2d -------------------------------------------
        // https://github.com/plotly/plotly.js/blob/v1.54.7/src/traces/heatmap/interp2d.js

        var INTERPTHRESHOLD = 1e-2;
        var NEIGHBORSHIFTS = [
            [-1, 0],
            [1, 0],
            [0, -1],
            [0, 1],
        ];

        function correctionOvershoot(maxFractionalChange) {
            // start with less overshoot, until we know it's converging,
            // then ramp up the overshoot for faster convergence
            return 0.5 - 0.25 * Math.min(1, maxFractionalChange * 0.5);
        }

        /*
         * interp2d: Fill in missing data from a 2D array using an iterative
         *   poisson equation solver with zero-derivative BC at edges.
         *   Amazingly, this just amounts to repeatedly averaging all the existing
         *   nearest neighbors, at least if we don't take x/y scaling into account,
         *   which is the right approach here where x and y may not even have the
         *   same units.
         *
         * @param {array of arrays} z
         *      The 2D array to fill in. Will be mutated here. Assumed to already be
         *      cleaned, so all entries are numbers except gaps, which are `undefined`.
         * @param {array of arrays} emptyPoints
         *      Each entry [i, j, neighborCount] for empty points z[i][j] and the number
         *      of neighbors that are *not* missing. Assumed to be sorted from most to
         *      least neighbors, as produced by heatmap/find_empties.
         */
        function interp2d(z, emptyPoints) {
            var maxFractionalChange = 1;
            var i;

            // one pass to fill in a starting value for all the empties
            iterateInterp2d(z, emptyPoints);

            // we're don't need to iterate lone empties - remove them
            for (i = 0; i < emptyPoints.length; i++) {
                if (emptyPoints[i][2] < 4) break;
            }
            // but don't remove these points from the original array,
            // we'll use them for masking, so make a copy.
            emptyPoints = emptyPoints.slice(i);

            for (i = 0; i < 100 && maxFractionalChange > INTERPTHRESHOLD; i++) {
                maxFractionalChange = iterateInterp2d(z, emptyPoints, correctionOvershoot(maxFractionalChange));
            }

            return z;
        }

        function iterateInterp2d(z, emptyPoints, overshoot) {
            var maxFractionalChange = 0;
            var thisPt;
            var i;
            var j;
            var p;
            var q;
            var neighborShift;
            var neighborRow;
            var neighborVal;
            var neighborCount;
            var neighborSum;
            var initialVal;
            var minNeighbor;
            var maxNeighbor;

            for (p = 0; p < emptyPoints.length; p++) {
                thisPt = emptyPoints[p];
                i = thisPt[0];
                j = thisPt[1];
                initialVal = z[i][j];
                neighborSum = 0;
                neighborCount = 0;

                for (q = 0; q < 4; q++) {
                    neighborShift = NEIGHBORSHIFTS[q];
                    neighborRow = z[i + neighborShift[0]];
                    if (!neighborRow) continue;
                    neighborVal = neighborRow[j + neighborShift[1]];
                    if (neighborVal !== undefined) {
                        if (neighborSum === 0) {
                            minNeighbor = maxNeighbor = neighborVal;
                        } else {
                            minNeighbor = Math.min(minNeighbor, neighborVal);
                            maxNeighbor = Math.max(maxNeighbor, neighborVal);
                        }
                        neighborCount++;
                        neighborSum += neighborVal;
                    }
                }

                if (neighborCount === 0) {
                    throw 'iterateInterp2d order is wrong: no defined neighbors';
                }

                // this is the laplace equation interpolation:
                // each point is just the average of its neighbors
                // note that this ignores differential x/y scaling
                // which I think is the right approach, since we
                // don't know what that scaling means
                z[i][j] = neighborSum / neighborCount;

                if (initialVal === undefined) {
                    if (neighborCount < 4) maxFractionalChange = 1;
                } else {
                    // we can make large empty regions converge faster
                    // if we overshoot the change vs the previous value
                    z[i][j] = (1 + overshoot) * z[i][j] - overshoot * initialVal;

                    if (maxNeighbor > minNeighbor) {
                        maxFractionalChange = Math.max(
                            maxFractionalChange,
                            Math.abs(z[i][j] - initialVal) / (maxNeighbor - minNeighbor)
                        );
                    }
                }
            }

            return maxFractionalChange;
        }

        // ----------------------------- setContours ---------------------------------------------
        // https://github.com/plotly/plotly.js/blob/v1.54.7/src/traces/contour/set_contours.js

        function setContours(zmin, zmax, ncontours) {
            /**
             * return the smallest element from (sorted) array arrayIn that's bigger than val,
             * or (reverse) the largest element smaller than val
             * used to find the best tick given the minimum (non-rounded) tick
             * particularly useful for date/time where things are not powers of 10
             * binary search is probably overkill here...
             */
            function roundUp(val, arrayIn, reverse) {
                var low = 0;
                var high = arrayIn.length - 1;
                var mid;
                var c = 0;
                var dlow = reverse ? 0 : 1;
                var dhigh = reverse ? 1 : 0;
                var rounded = reverse ? Math.ceil : Math.floor;
                // c is just to avoid infinite loops if there's an error
                while (low < high && c++ < 100) {
                    mid = rounded((low + high) / 2);
                    if (arrayIn[mid] <= val) low = mid + dlow;
                    else high = mid - dhigh;
                }
                return arrayIn[low];
            }
            let roundBase10 = [2, 5, 10];
            let contours = {};
            let roughContourSize = (zmax - zmin) / ncontours;
            let base = Math.pow(10, Math.floor(Math.log(roughContourSize) / Math.LN10));
            contours.size = base * roundUp(roughContourSize / base, roundBase10);
            contours.start = zmin - contours.size;
            // move the end of the contours a little to prevent losing the last contour to rounding errors
            contours.end = zmax + contours.size / 1e6;

            // if you set a small ncontours, *and* the ends are exactly on zmin/zmax
            // there's an edge case where start > end now. Make sure there's at least
            // one meaningful contour, put it midway between the crossed values
            if (contours.start > contours.end) {
                contours.start = contours.end = (contours.start + contours.end) / 2;
            }

            return contours;
        }

        // ----------------------------- emptyPathinfo -------------------------------------------
        // https://github.com/plotly/plotly.js/blob/v1.54.7/src/traces/contour/empty_pathinfo.js
        function emptyPathinfo(contours, xaxis, yaxis, xUnique, yUnique, zGrid, smoothing) {
            setScale(xaxis);
            setScale(yaxis);

            var pathinfo = [];

            for (var ci = contours.start; ci < contours.end; ci += contours.size) {
                pathinfo.push({
                    level: ci,
                    // all the cells with nontrivial marching index
                    crossings: {},
                    // starting points on the edges of the lattice for each contour
                    starts: [],
                    // all unclosed paths (may have less items than starts,
                    // if a path is closed by rounding)
                    edgepaths: [],
                    // all closed paths
                    paths: [],
                    x: xUnique,
                    y: yUnique,
                    xaxis: xaxis,
                    yaxis: yaxis,
                    z: zGrid,
                    smoothing: smoothing,
                });

                if (pathinfo.length > 1000) {
                    // Too many contours, clipping at 1000
                    break;
                }
            }
            return pathinfo;
        }

        // ----------------------------- makeCrossings -------------------------------------------
        // https://github.com/plotly/plotly.js/blob/v1.54.7/src/traces/contour/make_crossings.js
        var constants = {
            // some constants to help with marching squares algorithm
            // where does the path start for each index?
            BOTTOMSTART: [1, 9, 13, 104, 713],
            TOPSTART: [4, 6, 7, 104, 713],
            LEFTSTART: [8, 12, 14, 208, 1114],
            RIGHTSTART: [2, 3, 11, 208, 1114],

            // which way [dx,dy] do we leave a given index?
            // saddles are already disambiguated
            NEWDELTA: [
                null,
                [-1, 0],
                [0, -1],
                [-1, 0],
                [1, 0],
                null,
                [0, -1],
                [-1, 0],
                [0, 1],
                [0, 1],
                null,
                [0, 1],
                [1, 0],
                [1, 0],
                [0, -1],
            ],

            // for each saddle, the first index here is used
            // for dx||dy<0, the second for dx||dy>0
            CHOOSESADDLE: {
                104: [4, 1],
                208: [2, 8],
                713: [7, 13],
                1114: [11, 14],
            },

            // after one index has been used for a saddle, which do we
            // substitute to be used up later?
            SADDLEREMAINDER: {
                1: 4,
                2: 8,
                4: 1,
                7: 13,
                8: 2,
                11: 14,
                13: 7,
                14: 11,
            },
        };

        // Calculate all the marching indices, for ALL levels at once.
        // since we want to be exhaustive we'll check for contour crossings
        // at every intersection, rather than just following a path
        // TODO: shorten the inner loop to only the relevant levels
        function makeCrossings(pathinfo) {
            var z = pathinfo[0].z;
            var m = z.length;
            var n = z[0].length; // we already made sure z isn't ragged in interp2d
            var twoWide = m === 2 || n === 2;
            var xi;
            var yi;
            var startIndices;
            var ystartIndices;
            var label;
            var corners;
            var mi;
            var pi;
            var i;

            for (yi = 0; yi < m - 1; yi++) {
                ystartIndices = [];
                if (yi === 0) ystartIndices = ystartIndices.concat(constants.BOTTOMSTART);
                if (yi === m - 2) ystartIndices = ystartIndices.concat(constants.TOPSTART);

                for (xi = 0; xi < n - 1; xi++) {
                    startIndices = ystartIndices.slice();
                    if (xi === 0) startIndices = startIndices.concat(constants.LEFTSTART);
                    if (xi === n - 2) startIndices = startIndices.concat(constants.RIGHTSTART);

                    label = xi + ',' + yi;
                    corners = [
                        [z[yi][xi], z[yi][xi + 1]],
                        [z[yi + 1][xi], z[yi + 1][xi + 1]],
                    ];
                    for (i = 0; i < pathinfo.length; i++) {
                        pi = pathinfo[i];
                        mi = getMarchingIndex(pi.level, corners);
                        if (!mi) continue;

                        pi.crossings[label] = mi;
                        if (startIndices.indexOf(mi) !== -1) {
                            pi.starts.push([xi, yi]);
                            if (twoWide && startIndices.indexOf(mi, startIndices.indexOf(mi) + 1) !== -1) {
                                // the same square has starts from opposite sides
                                // it's not possible to have starts on opposite edges
                                // of a corner, only a start and an end...
                                // but if the array is only two points wide (either way)
                                // you can have starts on opposite sides.
                                pi.starts.push([xi, yi]);
                            }
                        }
                    }
                }
            }
        }

        // modified marching squares algorithm,
        // so we disambiguate the saddle points from the start
        // and we ignore the cases with no crossings
        // the index I'm using is based on:
        // http://en.wikipedia.org/wiki/Marching_squares
        // except that the saddles bifurcate and I represent them
        // as the decimal combination of the two appropriate
        // non-saddle indices
        function getMarchingIndex(val, corners) {
            var mi =
                (corners[0][0] > val ? 0 : 1) +
                (corners[0][1] > val ? 0 : 2) +
                (corners[1][1] > val ? 0 : 4) +
                (corners[1][0] > val ? 0 : 8);
            if (mi === 5 || mi === 10) {
                var avg = (corners[0][0] + corners[0][1] + corners[1][0] + corners[1][1]) / 4;
                // two peaks with a big valley
                if (val > avg) return mi === 5 ? 713 : 1114;
                // two valleys with a big ridge
                return mi === 5 ? 104 : 208;
            }
            return mi === 15 ? 0 : mi;
        }

        //  ----------------------------------- setConvert ---------------------------------------
        // https://github.com/plotly/plotly.js/blob/v1.54.7/src/plots/cartesian/set_convert.js

        function c2p(axis) {
            function l2p(v) {
                return d3.round(axis._b + axis._m * v, 2);
            }

            return l2p;
        }

        function setScale(axis) {
            let rl0 = axis.range[0],
                rl1 = axis.range[1],
                axLetter = axis.letter;

            if (axLetter === 'y') {
                axis._m = axis.height / (rl0 - rl1);
                axis._b = -axis._m * rl1;
            } else {
                axis._m = axis.width / (rl1 - rl0);
                axis._b = -axis._m * rl0;
            }
        }

        // ----------------------------------- findAllPaths ---------------------------------------
        // https://github.com/plotly/plotly.js/blob/v1.54.7/src/traces/contour/find_all_paths.js

        function findAllPaths(pathinfo, xtol, ytol) {
            var cnt, startLoc, i, pi, j;

            // Default just passes these values through as they were before:
            xtol = xtol || 0.01;
            ytol = ytol || 0.01;

            for (i = 0; i < pathinfo.length; i++) {
                pi = pathinfo[i];

                for (j = 0; j < pi.starts.length; j++) {
                    startLoc = pi.starts[j];
                    makePath(pi, startLoc, 'edge', xtol, ytol);
                }

                cnt = 0;
                while (Object.keys(pi.crossings).length && cnt < 10000) {
                    cnt++;
                    startLoc = Object.keys(pi.crossings)[0].split(',').map(Number);
                    makePath(pi, startLoc, undefined, xtol, ytol);
                }
            }
        }

        function equalPts(pt1, pt2, xtol, ytol) {
            return Math.abs(pt1[0] - pt2[0]) < xtol && Math.abs(pt1[1] - pt2[1]) < ytol;
        }

        // distance in index units - uses the 3rd and 4th items in points
        function ptDist(pt1, pt2) {
            var dx = pt1[2] - pt2[2];
            var dy = pt1[3] - pt2[3];
            return Math.sqrt(dx * dx + dy * dy);
        }

        function makePath(pi, loc, edgeflag, xtol, ytol) {
            var locStr = loc.join(',');
            var mi = pi.crossings[locStr];
            var marchStep = getStartStep(mi, edgeflag, loc);
            // start by going backward a half step and finding the crossing point
            var pts = [getInterpPx(pi, loc, [-marchStep[0], -marchStep[1]])];
            var m = pi.z.length;
            var n = pi.z[0].length;
            var startLoc = loc.slice();
            var startStep = marchStep.slice();
            var cnt;

            // now follow the path
            for (cnt = 0; cnt < 10000; cnt++) {
                // just to avoid infinite loops
                if (mi > 20) {
                    mi = constants.CHOOSESADDLE[mi][(marchStep[0] || marchStep[1]) < 0 ? 0 : 1];
                    pi.crossings[locStr] = constants.SADDLEREMAINDER[mi];
                } else {
                    delete pi.crossings[locStr];
                }

                marchStep = constants.NEWDELTA[mi];
                if (!marchStep) {
                    break;
                }

                // find the crossing a half step forward, and then take the full step
                pts.push(getInterpPx(pi, loc, marchStep));
                loc[0] += marchStep[0];
                loc[1] += marchStep[1];
                locStr = loc.join(',');

                // don't include the same point multiple times
                if (equalPts(pts[pts.length - 1], pts[pts.length - 2], xtol, ytol)) pts.pop();

                var atEdge =
                    (marchStep[0] && (loc[0] < 0 || loc[0] > n - 2)) ||
                    (marchStep[1] && (loc[1] < 0 || loc[1] > m - 2));

                var closedLoop =
                    loc[0] === startLoc[0] &&
                    loc[1] === startLoc[1] &&
                    marchStep[0] === startStep[0] &&
                    marchStep[1] === startStep[1];

                // have we completed a loop, or reached an edge?
                if (closedLoop || (edgeflag && atEdge)) break;

                mi = pi.crossings[locStr];
            }

            var closedpath = equalPts(pts[0], pts[pts.length - 1], xtol, ytol);
            var totaldist = 0;
            var distThresholdFactor = 0.2 * pi.smoothing;
            var alldists = [];
            var cropstart = 0;
            var distgroup, cnt2, cnt3, newpt, ptcnt, ptavg, thisdist, i, j, edgepathi, edgepathj;

            /*
             * Check for points that are too close together (<1/5 the average dist
             * *in grid index units* (important for log axes and nonuniform grids),
             * less if less smoothed) and just take the center (or avg of center 2).
             * This cuts down on funny behavior when a point is very close to a
             * contour level.
             */
            for (cnt = 1; cnt < pts.length; cnt++) {
                thisdist = ptDist(pts[cnt], pts[cnt - 1]);
                totaldist += thisdist;
                alldists.push(thisdist);
            }

            var distThreshold = (totaldist / alldists.length) * distThresholdFactor;

            function getpt(i) {
                return pts[i % pts.length];
            }

            for (cnt = pts.length - 2; cnt >= cropstart; cnt--) {
                distgroup = alldists[cnt];
                if (distgroup < distThreshold) {
                    cnt3 = 0;
                    for (cnt2 = cnt - 1; cnt2 >= cropstart; cnt2--) {
                        if (distgroup + alldists[cnt2] < distThreshold) {
                            distgroup += alldists[cnt2];
                        } else break;
                    }

                    // closed path with close points wrapping around the boundary?
                    if (closedpath && cnt === pts.length - 2) {
                        for (cnt3 = 0; cnt3 < cnt2; cnt3++) {
                            if (distgroup + alldists[cnt3] < distThreshold) {
                                distgroup += alldists[cnt3];
                            } else break;
                        }
                    }
                    ptcnt = cnt - cnt2 + cnt3 + 1;
                    ptavg = Math.floor((cnt + cnt2 + cnt3 + 2) / 2);

                    // either endpoint included: keep the endpoint
                    if (!closedpath && cnt === pts.length - 2) newpt = pts[pts.length - 1];
                    else if (!closedpath && cnt2 === -1) newpt = pts[0];
                    // odd # of points - just take the central one
                    else if (ptcnt % 2) newpt = getpt(ptavg);
                    // even # of pts - average central two
                    else {
                        newpt = [
                            (getpt(ptavg)[0] + getpt(ptavg + 1)[0]) / 2,
                            (getpt(ptavg)[1] + getpt(ptavg + 1)[1]) / 2,
                        ];
                    }

                    pts.splice(cnt2 + 1, cnt - cnt2 + 1, newpt);
                    cnt = cnt2 + 1;
                    if (cnt3) cropstart = cnt3;
                    if (closedpath) {
                        if (cnt === pts.length - 2) pts[cnt3] = pts[pts.length - 1];
                        else if (cnt === 0) pts[pts.length - 1] = pts[0];
                    }
                }
            }
            pts.splice(0, cropstart);

            // done with the index parts - remove them so path generation works right
            // because it depends on only having [xpx, ypx]
            for (cnt = 0; cnt < pts.length; cnt++) pts[cnt].length = 2;

            // don't return single-point paths (ie all points were the same
            // so they got deleted?)
            if (pts.length < 2) return;
            else if (closedpath) {
                pts.pop();
                pi.paths.push(pts);
            } else {
                // edge path - does it start where an existing edge path ends, or vice versa?
                var merged = false;
                for (i = 0; i < pi.edgepaths.length; i++) {
                    edgepathi = pi.edgepaths[i];
                    if (!merged && equalPts(edgepathi[0], pts[pts.length - 1], xtol, ytol)) {
                        pts.pop();
                        merged = true;

                        // now does it ALSO meet the end of another (or the same) path?
                        var doublemerged = false;
                        for (j = 0; j < pi.edgepaths.length; j++) {
                            edgepathj = pi.edgepaths[j];
                            if (equalPts(edgepathj[edgepathj.length - 1], pts[0], xtol, ytol)) {
                                doublemerged = true;
                                pts.shift();
                                pi.edgepaths.splice(i, 1);
                                if (j === i) {
                                    // the path is now closed
                                    pi.paths.push(pts.concat(edgepathj));
                                } else {
                                    if (j > i) j--;
                                    pi.edgepaths[j] = edgepathj.concat(pts, edgepathi);
                                }
                                break;
                            }
                        }
                        if (!doublemerged) {
                            pi.edgepaths[i] = pts.concat(edgepathi);
                        }
                    }
                }
                for (i = 0; i < pi.edgepaths.length; i++) {
                    if (merged) break;
                    edgepathi = pi.edgepaths[i];
                    if (equalPts(edgepathi[edgepathi.length - 1], pts[0], xtol, ytol)) {
                        pts.shift();
                        pi.edgepaths[i] = edgepathi.concat(pts);
                        merged = true;
                    }
                }

                if (!merged) pi.edgepaths.push(pts);
            }
        }

        // special function to get the marching step of the
        // first point in the path (leading to loc)
        function getStartStep(mi, edgeflag, loc) {
            var dx = 0;
            var dy = 0;
            if (mi > 20 && edgeflag) {
                // these saddles start at +/- x
                if (mi === 208 || mi === 1114) {
                    // if we're starting at the left side, we must be going right
                    dx = loc[0] === 0 ? 1 : -1;
                } else {
                    // if we're starting at the bottom, we must be going up
                    dy = loc[1] === 0 ? 1 : -1;
                }
            } else if (constants.BOTTOMSTART.indexOf(mi) !== -1) dy = 1;
            else if (constants.LEFTSTART.indexOf(mi) !== -1) dx = 1;
            else if (constants.TOPSTART.indexOf(mi) !== -1) dy = -1;
            else dx = -1;
            return [dx, dy];
        }

        /*
         * Find the pixel coordinates of a particular crossing
         *
         * @param {object} pi: the pathinfo object at this level
         * @param {array} loc: the grid index [x, y] of the crossing
         * @param {array} step: the direction [dx, dy] we're moving on the grid
         *
         * @return {array} [xpx, ypx, xi, yi]: the first two are the pixel location,
         *   the next two are the interpolated grid indices, which we use for
         *   distance calculations to delete points that are too close together.
         *   This is important when the grid is nonuniform (and most dramatically when
         *   we're on log axes and include invalid (0 or negative) values.
         *   It's crucial to delete these extra two before turning an array of these
         *   points into a path, because those routines require length-2 points.
         */
        function getInterpPx(pi, loc, step) {
            var locx = loc[0] + Math.max(step[0], 0);
            var locy = loc[1] + Math.max(step[1], 0);
            var zxy = pi.z[locy][locx];
            var xa = pi.xaxis;
            var ya = pi.yaxis;

            if (step[1]) {
                var dx = (pi.level - zxy) / (pi.z[locy][locx + 1] - zxy);

                return [
                    c2p(xa)((1 - dx) * pi.x[locx] + dx * pi.x[locx + 1], true),
                    c2p(ya)(pi.y[locy], true),
                    locx + dx,
                    locy,
                ];
            } else {
                var dy = (pi.level - zxy) / (pi.z[locy + 1][locx] - zxy);
                return [
                    c2p(xa)(pi.x[locx], true),
                    c2p(ya)((1 - dy) * pi.y[locy] + dy * pi.y[locy + 1], true),
                    locx,
                    locy + dy,
                ];
            }
        }

        // ----------------------------------- closeBoundaries ---------------------------------------
        // https://github.com/plotly/plotly.js/blob/v1.54.7/src/traces/contour/close_boundaries.js

        function closeBoundaries(pathinfo) {
            var pi0 = pathinfo[0];
            var z = pi0.z;
            var i;

            var edgeVal2 = Math.min(z[0][0], z[0][1]);

            for (i = 0; i < pathinfo.length; i++) {
                var pi = pathinfo[i];
                pi.prefixBoundary =
                    !pi.edgepaths.length && (edgeVal2 > pi.level || (pi.starts.length && edgeVal2 === pi.level));
            }
        }

        // ----------------------------------- svg paths smoothing ---------------------------------------
        // https://github.com/plotly/plotly.js/blob/v1.54.7/src/components/drawing/index.js#L772

        // generalized Catmull-Rom splines, per
        // http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
        var CatmullRomExp = 0.5;
        function smoothopen(pts, smoothness) {
            if (pts.length < 3) {
                return 'M' + pts.join('L');
            }
            var path = 'M' + pts[0];
            var tangents = [];
            var i;
            for (i = 1; i < pts.length - 1; i++) {
                tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));
            }
            path += 'Q' + tangents[0][0] + ' ' + pts[1];
            for (i = 2; i < pts.length - 1; i++) {
                path += 'C' + tangents[i - 2][1] + ' ' + tangents[i - 1][0] + ' ' + pts[i];
            }
            path += 'Q' + tangents[pts.length - 3][1] + ' ' + pts[pts.length - 1];
            return path;
        }

        function smoothclosed(pts, smoothness) {
            if (pts.length < 3) {
                return 'M' + pts.join('L') + 'Z';
            }
            var path = 'M' + pts[0];
            var pLast = pts.length - 1;
            var tangents = [makeTangent(pts[pLast], pts[0], pts[1], smoothness)];
            var i;
            for (i = 1; i < pLast; i++) {
                tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));
            }
            tangents.push(makeTangent(pts[pLast - 1], pts[pLast], pts[0], smoothness));

            for (i = 1; i <= pLast; i++) {
                path += 'C' + tangents[i - 1][1] + ' ' + tangents[i][0] + ' ' + pts[i];
            }
            path += 'C' + tangents[pLast][1] + ' ' + tangents[0][0] + ' ' + pts[0] + 'Z';
            return path;
        }

        function makeTangent(prevpt, thispt, nextpt, smoothness) {
            var d1x = prevpt[0] - thispt[0];
            var d1y = prevpt[1] - thispt[1];
            var d2x = nextpt[0] - thispt[0];
            var d2y = nextpt[1] - thispt[1];
            var d1a = Math.pow(d1x * d1x + d1y * d1y, CatmullRomExp / 2);
            var d2a = Math.pow(d2x * d2x + d2y * d2y, CatmullRomExp / 2);
            var numx = (d2a * d2a * d1x - d1a * d1a * d2x) * smoothness;
            var numy = (d2a * d2a * d1y - d1a * d1a * d2y) * smoothness;
            var denom1 = 3 * d2a * (d1a + d2a);
            var denom2 = 3 * d1a * (d1a + d2a);
            return [
                [
                    d3.round(thispt[0] + (denom1 && numx / denom1), 2),
                    d3.round(thispt[1] + (denom1 && numy / denom1), 2),
                ],
                [
                    d3.round(thispt[0] - (denom2 && numx / denom2), 2),
                    d3.round(thispt[1] - (denom2 && numy / denom2), 2),
                ],
            ];
        }

        // ----------------------------------- contours drawing ---------------------------------------
        // https://github.com/plotly/plotly.js/blob/v1.54.7/src/traces/contour/plot.js

        /**
         * Append element to DOM only if not present.
         *
         * @param {d3 selection} parent : parent selection of the element in question
         * @param {string} nodeType : node type of element to append
         * @param {string} className (optional) : class name of element in question
         * @param {fn} enterFn (optional) : optional fn applied to entering elements only
         * @return {d3 selection} selection of new layer
         */
        function ensureSingle(parent, nodeType, className) {
            var sel = parent.select(nodeType + (className ? '.' + className : ''));
            if (sel.size()) return sel;

            var layer = parent.append(nodeType);
            if (className) layer.classed(className, true);

            return layer;
        }

        function makeBackground(plotgroup, perimeter) {
            var bggroup = ensureSingle(plotgroup, 'g', 'contourbg');

            var bgfill = bggroup.selectAll('path').data([0]);
            bgfill.enter().append('path');
            bgfill.exit().remove();
            bgfill.attr('d', 'M' + perimeter.join('L') + 'Z').style('stroke', 'none');
        }

        function makeFills(plotgroup, pathinfo, perimeter, colorScale) {
            var boundaryPath = 'M' + perimeter.join('L') + 'Z';

            closeBoundaries(pathinfo);

            var fillgroup = ensureSingle(plotgroup, 'g', 'contourfill');

            var fillitems = fillgroup.selectAll('path').data(pathinfo);
            fillitems.enter().append('path');
            fillitems.exit().remove();
            fillitems.each(function (pi) {
                // join all paths for this level together into a single path
                // first follow clockwise around the perimeter to close any open paths
                // if the whole perimeter is above this level, start with a path
                // enclosing the whole thing. With all that, the parity should mean
                // that we always fill everything above the contour, nothing below
                var fullpath = (pi.prefixBoundary ? boundaryPath : '') + joinAllPaths(pi, perimeter);

                if (!fullpath) {
                    d3.select(this).remove();
                } else {
                    d3.select(this)
                        .attr('d', fullpath)
                        .style('stroke', 'none')
                        .style('fill', function (d) {
                            return colorScale(d.level);
                        });
                }
            });

            // Add clipPath element to clip paths that could go outside of the box after
            // smoothing. This seemingly overcomplicated method can be replaced by:
            // fillgroup.style('clip-path', `path(${boundaryPath})`)
            // when chrome is compatible with defining the path in the CSS property
            // (already works in firefox)
            let clipPathUUID = window.crypto.getRandomValues(new Uint32Array(1))[0].toString(16);
            fillgroup.style('clip-path', `url(#${clipPathUUID})`)
                .append('clipPath')
                .attr('id', clipPathUUID)
                .append('path')
                .attr('d', boundaryPath);
        }

        function joinAllPaths(pi, perimeter) {
            var fullpath = '';
            var i = 0;
            var startsleft = pi.edgepaths.map(function (v, i) {
                return i;
            });
            var newloop = true;
            var endpt;
            var newendpt;
            var cnt;
            var nexti;
            var possiblei;
            var addpath;

            function istop(pt) {
                return Math.abs(pt[1] - perimeter[0][1]) < 0.01;
            }
            function isbottom(pt) {
                return Math.abs(pt[1] - perimeter[2][1]) < 0.01;
            }
            function isleft(pt) {
                return Math.abs(pt[0] - perimeter[0][0]) < 0.01;
            }
            function isright(pt) {
                return Math.abs(pt[0] - perimeter[2][0]) < 0.01;
            }

            while (startsleft.length) {
                addpath = smoothopen(pi.edgepaths[i], pi.smoothing);
                fullpath += newloop ? addpath : addpath.replace(/^M/, 'L');
                startsleft.splice(startsleft.indexOf(i), 1);
                endpt = pi.edgepaths[i][pi.edgepaths[i].length - 1];
                nexti = -1;

                // now loop through sides, moving our endpoint until we find a new start
                for (cnt = 0; cnt < 4; cnt++) {
                    // just to prevent infinite loops
                    if (!endpt || endpt.length < 2) {
                        break;
                    }

                    if (istop(endpt) && !isright(endpt)) newendpt = perimeter[1];
                    // right top
                    else if (isleft(endpt)) newendpt = perimeter[0];
                    // left top
                    else if (isbottom(endpt)) newendpt = perimeter[3];
                    // right bottom
                    else if (isright(endpt)) newendpt = perimeter[2]; // left bottom
                    else newendpt = []; // error case

                    for (possiblei = 0; possiblei < pi.edgepaths.length; possiblei++) {
                        var ptNew = pi.edgepaths[possiblei][0];
                        // is ptNew on the (horz. or vert.) segment from endpt to newendpt?
                        if (newendpt.length) {
                            if (Math.abs(endpt[0] - newendpt[0]) < 0.01) {
                                if (
                                    Math.abs(endpt[0] - ptNew[0]) < 0.01 &&
                                    (ptNew[1] - endpt[1]) * (newendpt[1] - ptNew[1]) >= 0
                                ) {
                                    newendpt = ptNew;
                                    nexti = possiblei;
                                }
                            } else if (Math.abs(endpt[1] - newendpt[1]) < 0.01) {
                                if (
                                    Math.abs(endpt[1] - ptNew[1]) < 0.01 &&
                                    (ptNew[0] - endpt[0]) * (newendpt[0] - ptNew[0]) >= 0
                                ) {
                                    newendpt = ptNew;
                                    nexti = possiblei;
                                }
                            }
                        }
                    }

                    endpt = newendpt;

                    if (nexti >= 0) break;
                    fullpath += 'L' + newendpt;
                }

                if (nexti === pi.edgepaths.length) {
                    break;
                }

                i = nexti;

                // if we closed back on a loop we already included,
                // close it and start a new loop
                newloop = startsleft.indexOf(i) === -1;
                if (newloop) {
                    i = startsleft[0];
                    fullpath += 'Z';
                }
            }

            // finally add the interior paths
            for (i = 0; i < pi.paths.length; i++) {
                fullpath += smoothclosed(pi.paths[i], pi.smoothing);
            }

            return fullpath;
        }

        return contourPlotFactory;
    });
})();

(function(){
'use strict';

var app0 = angular.module('dataiku.analysis', []);

var app = angular.module('dataiku.analysis.core', []);


/** List of analyses */
app.controller("AnalysesListController", function($scope, $controller, $stateParams, DataikuAPI, CreateModalFromTemplate, DatasetUtils, $state, TopNav) {

    $controller('_TaggableObjectsListPageCommon', {$scope: $scope});
    $controller('AnalysisCoreController', {$scope: $scope});

    $scope.sortBy = [
        { value: 'name', label: 'Name' },
        { value: 'inputDatasetSmartName', label: 'Dataset' },
        { value: '-lastModifiedOn', label: 'Last modified'}, // Appears not to be filled up correctly
    ];
    $scope.selection = $.extend({
        filterQuery: {
            userQuery: '',
            tags: [],
            interest: {
                starred: '',
            },
            inputDatasetSmartName: []
        },
        filterParams: {
            userQueryTargets: ["name", "tags", "inputDatasetSmartName"],
            propertyRules: {tag: 'tags', dataset: "inputDatasetSmartName"},
            exactMatch: ['inputDatasetSmartName']
        },
        orderQuery: "-lastModifiedOn",
        orderReversed: false
    }, $scope.selection || {});

    if ($stateParams.datasetId) {
        $scope.selection.filterQuery.inputDatasetSmartName.push($stateParams.datasetId);
    }

    $scope.maxItems = 20;

    $scope.list = function() {
        DataikuAPI.analysis.listHeads($stateParams.projectKey, true).success(function(data) {
            $scope.listItems = data;
            $scope.listItems.forEach(item => {
                item.nbModels = item.mlTasks.reduce((sum, task) => sum + task.modelCount, 0);
                item.nbSessions = item.mlTasks.reduce((sum, task) => sum + task.sessionCount, 0);
                item.computedIcon = 'icon-dku-nav_analysis';
                if (item.nbMLTasks === 1) {
                    switch(item.mlTasks[0].taskType) {
                        case 'PREDICTION':
                            if (item.mlTasks[0].backendType === 'KERAS') {
                                item.computedIcon = 'icon-dku-deeplearning-prediction';
                            } else {
                                item.computedIcon = 'icon-dku-automl-prediction';
                            }
                        break;

                        case 'CLUSTERING':
                            item.computedIcon = 'icon-dku-automl-clustering';
                        break;
                    }
                }
            });
            $scope.restoreOriginalSelection();
        }).error(setErrorInScope.bind($scope));
    };

    TopNav.setLocation(TopNav.TOP_ANALYSES, 'analyses', TopNav.TABS_NONE, null);
    TopNav.setNoItem();
    $scope.list();

    /* Tags handling */

    $scope.$on('selectedIndex', function(e, index){
        // an index has been selected, we unselect the multiselect
        $scope.$broadcast('clearMultiSelect');
    });

    /* Specific actions */
    $scope.goToItem = function(data) {
        $state.go("projects.project.analyses.analysis.script", {projectKey : $stateParams.projectKey, analysisId : data.id});
    }

    $scope.newAnalysis = function() {
        CreateModalFromTemplate("/templates/analysis/new-analysis-modal.html", $scope, "NewAnalysisModalController");
    }

    DatasetUtils.listDatasetsUsabilityForAny($stateParams.projectKey).success(data => {
    	// Move the usable flag where it's going to be read
        data.forEach(x => {
            x.usable = x.usableAsInput;
            x.usableReason = x.inputReason;
        });
        $scope.availableDatasets = data;
    }).error(setErrorInScope.bind($scope));
});


app.controller("NewAnalysisModalController", function($scope, $state, $stateParams, DataikuAPI, DatasetUtils){

    DatasetUtils.listDatasetsUsabilityForAny($stateParams.projectKey).success(function(data){
    	// move the usable flag where it's going to be read
        data.forEach(function(x) {
            x.usable = x.usableAsInput;
            x.usableReason = x.inputReason;
        });
        $scope.availableDatasets = data;
        // set the usable flag here instead of in the UsabilityComputer, like the other places seem to do
        angular.forEach($scope.availableDatasets, function(x) {
            x.usable=true;
        });
    }).error(setErrorInScope.bind($scope));

    $scope.newAnalysis = {}

    $scope.$watch("newAnalysis.datasetSmartName", function(nv, ov) {
        if (nv && !$scope.newAnalysis.name) {
            $scope.newAnalysis.name = "Analyze " + $scope.newAnalysis.datasetSmartName;
        }
    });

     $scope.create = function(){
        DataikuAPI.analysis.create($stateParams.projectKey, $scope.newAnalysis.datasetSmartName, $scope.newAnalysis.name).success(function(data) {
            $state.go("projects.project.analyses.analysis.script", {
                projectKey : $stateParams.projectKey,
                analysisId : data.id
            })
        }).error(setErrorInScope.bind($scope));
    }
});


app.controller("NewAnalysisOnDatasetModalController",
        function($scope, $state, $stateParams, DataikuAPI, DatasetUtils, $timeout, Fn){

    var focus1stInput = $timeout.bind(null, function() { $(".modal").find('input').focus(); }, 0);

    $scope.$watch("datasetSmartName", function(nv) {
        if (!nv) return;
        DataikuAPI.analysis.listOnDataset($stateParams.projectKey, $scope.datasetSmartName, !!$scope.forMLTask)
            .success(function(data) {
                $scope.existingAnalyses = data;
                $scope.hasMLTasks = !!$scope.forMLTask &&
                    data.map(Fn.propStr('mlTasks.length')).reduce(Fn.SUM, 0) > 0;
                $scope.newData.name = "Analyze " + $scope.datasetSmartName;
                if (data.length == 0) {
                    focus1stInput();
                }
            }).error(setErrorInScope.bind($scope));
    });

    $scope.newData = {};
    $scope.createAnother = function() {
        $scope.existingAnalyses.length = 0;
        focus1stInput();
    };
    $scope.create = function() {
        DataikuAPI.analysis.create($stateParams.projectKey, $scope.datasetSmartName, $scope.newData.name)
            .success(function(data) {
                $state.go("projects.project.analyses.analysis." + ($scope.forMLTasks ? 'ml.list' : 'script'),
                    { projectKey: $stateParams.projectKey, analysisId: data.id });
            }).error(setErrorInScope.bind($scope));
    };
});


app.controller("AnalysisCoreController", function($scope, $stateParams, $rootScope, WT1, TopNav, DataikuAPI, CreateModalFromTemplate, CreateExportModal, ExportUtils, Dialogs, $state, $q, DatasetUtils) {
    
    if ($state.is('projects.project.analyses.list')) {
        let selectedObjectListener = $scope.$watch("selection.selectedObject", (nv) => {
            if (nv) {
                $stateParams.analysisId = $scope.selection.selectedObject.id;
                $scope.analysisDataContext.inputDatasetLoc = DatasetUtils.getLocFromSmart($stateParams.projectKey, $scope.selection.selectedObject.inputDatasetSmartName);
            }
        });
        $scope.$on("$destroy", selectedObjectListener);
    }

    $scope.analysisId = $stateParams.analysisId;

    $scope.analysisDataContext = {};
    $scope.mlTasksContext = {};

    $scope.appConfig = $rootScope.appConfig;

    $scope.createShakerRecipe = function() {
        CreateModalFromTemplate("/templates/shaker/add-to-flow.html", $scope, "AddAnalysisToFlowController");
    };

    $scope.exportProcessedData = function() {
        DataikuAPI.analysis.getCore($stateParams.projectKey, $stateParams.analysisId).success(function(acp) {
            var datasetLoc = DatasetUtils.getLocFromSmart($stateParams.projectKey, acp.inputDatasetSmartName);
            DataikuAPI.datasets.get(datasetLoc.projectKey, datasetLoc.name, $stateParams.projectKey).success(function(dataset){
                var partitionLoader = (!dataset.partitioning.dimensions.length)?null:(function() {
                    var deferred = $q.defer();
                    DataikuAPI.datasets.listPartitions(dataset).success(function(data) {
                        deferred.resolve(data);
                    }).error(function() {
                        deferred.reject();
                    });
                    return deferred.promise;
                });
                var features = {
                        advancedSampling : true,
                        partitionListLoader : partitionLoader,
                        isDownloadable : true
                };
                var dialog = {
                        title : 'Prepared Dataset "'+dataset.name+'"',
                        warn : null
                };
                CreateExportModal($scope, dialog, features).then(function(params) {
                    DataikuAPI.analysis.exportProcessedData($stateParams.projectKey, $stateParams.analysisId,
                                                            params).success(function(data){
                        ExportUtils.defaultHandleExportResult($scope, params, data);
                    }).error(setErrorInScope.bind($scope));
                });
            }).error(setErrorInScope.bind($scope));
        }).error(setErrorInScope.bind($scope));
    }

    $scope.clearMLTasksContext = function(){
        $scope.mlTasksContext.type = null;
        $scope.mlTasksContext.activeMetric = null;
    }

    $scope.changeDataset = function() {
        DataikuAPI.analysis.getCore($stateParams.projectKey, $stateParams.analysisId).success(function(acp) {
        	var newScope = $scope.$new();
        	newScope.analysisCoreParams = acp;
            CreateModalFromTemplate("/templates/analysis/change-dataset-modal.html", newScope, "ChangeDatasetOnAnalysisModalController");
        }).error(setErrorInScope.bind($scope));
    };

    $scope.saveCustomFields = function(analysis, newCustomFields) {
        WT1.event('custom-fields-save', {objectType: 'ANALYSIS'});
        let oldCustomFields = angular.copy(analysis.customFields);
        analysis.customFields = newCustomFields;
        return DataikuAPI.analysis.saveCore(analysis, {summaryOnly: true})
            .success(function() {
                $rootScope.$broadcast('customFieldsSaved', TopNav.getItem(), analysis.customFields);
            })
            .error(function(a, b, c) {
                analysis.customFields = oldCustomFields;
                setErrorInScope.bind($scope)(a, b, c);
            });
    };

    $scope.editCustomFields = function() {
        DataikuAPI.analysis.getSummary($stateParams.projectKey, $stateParams.analysisId).success(function(data) {
            let analysisCoreParams = data.object;
            let modalScope = angular.extend($scope, {objectType: 'ANALYSIS', objectName: analysisCoreParams.name, objectCustomFields: analysisCoreParams.customFields});
            CreateModalFromTemplate("/templates/taggable-objects/custom-fields-edit-modal.html", modalScope).then(function(customFields) {
                $scope.saveCustomFields(analysisCoreParams, customFields);
            });
        }).error(setErrorInScope.bind($scope));
    };
});


app.controller("ChangeDatasetOnAnalysisModalController", function($scope, $state, $stateParams, DataikuAPI, DatasetUtils, $timeout, Fn, Dialogs, DKUtils){
    DatasetUtils.listDatasetsUsabilityForAny($stateParams.projectKey).success(function(data){
        $scope.availableDatasets = data;
        // set the usable flag here instead of in the UsabilityComputer, like the other places seem to do
        angular.forEach($scope.availableDatasets, function(x) {
            x.usable = x.smartName != $scope.analysisCoreParams.inputDatasetSmartName;
        });
    }).error(setErrorInScope.bind($scope));

    $scope.change = function(datasetSmartName) {
    	var usableDataset = null;
        angular.forEach($scope.availableDatasets, function(x) {
        	if ( x.smartName == datasetSmartName) {
        		usableDataset = x;
        	}
        });

    	Dialogs.confirm($scope, "Change input to " + usableDataset.name, "Are you sure you want to use  as input to this analysis? Columns and features might be different "
    			+ "and prevent some script steps and/or models from functioning.").then(function() {
    		$scope.analysisCoreParams.inputDatasetSmartName = datasetSmartName;
    		DataikuAPI.analysis.saveCore($scope.analysisCoreParams).success(function(data) {
    			DKUtils.reloadState();
    		}).error(setErrorInScope.bind($scope));
        });
    };
});


app.controller("AddAnalysisToFlowController", function($scope, $controller, $stateParams, $state, DataikuAPI, $q, DatasetUtils) {
    $scope.recipeType = "shaker";
    $controller("SingleOutputDatasetRecipeCreationController", {$scope:$scope});
    $scope.io.inputDataset = DatasetUtils.makeSmart($scope.analysisDataContext.inputDatasetLoc, $stateParams.projectKey);


    // addDatasetUniquenessCheck($scope, DataikuAPI, $stateParams.projectKey);
    // fetchManagedDatasetConnections($scope, DataikuAPI);

    $scope.$watch("io.inputDataset", function(nv, ov){
        if (!nv) return;
        var datasetLoc = DatasetUtils.getLocFromSmart( $stateParams.projectKey, $scope.io.inputDataset);
        DataikuAPI.datasets.get(datasetLoc.projectKey, datasetLoc.name, $stateParams.projectKey).success(function(dataset){
            $scope.dataset = dataset;
            $scope.dataset.partitioned = dataset.partitioning && dataset.partitioning.dimensions && dataset.partitioning.dimensions.length
        }).error(setErrorInScope.bind($scope));
    })


    $scope.options = {
        fallbackToString: true,
        cleanupColumnNames: true,
        exportCharts : true,
    }
    $scope.buildAfterCreation = false;

    $scope.showOutputPane = function(){
        return true;
    }

    $scope.autosetName = function() {
            var niceInputName = $scope.analysisDataContext.inputDatasetLoc.name.replace(/[A-Z]*\./,"");
            $scope.maybeSetNewDatasetName(niceInputName + "_prepared");
    }

    function buildDataset(projectKey, outputDataset) {
        var deferred = $q.defer();
        var jd = {};
        jd.type = "NON_RECURSIVE_FORCED_BUILD";
        jd.refreshHiveMetastore = true;
        jd.projectKey = projectKey;
        jd.outputs = [{targetDataset : outputDataset, targetDatasetProjectKey : projectKey}];
        DataikuAPI.flow.jobs.start(jd).success(function(data) {
            deferred.resolve();
        }).error(function(a, b, c) {
            setErrorInScope.bind($scope)(a, b,c);
            $scope.recipeWT1Event("recipe-run-start-failed");
            deferred.reject();
        });
        return deferred.promise;
    }

    $scope.createRecipe = function() {
        var createOutput = $scope.io.newOutputTypeRadio == 'create';
        var outputName =createOutput ? $scope.newOutputDataset.name : $scope.io.existingOutputDataset;
        $scope.options.inputDataset = $scope.io.inputDataset;

        DataikuAPI.analysis.addToFlow(
            $stateParams.projectKey,
            $stateParams.analysisId,
            createOutput,
            outputName,
            $scope.getDatasetCreationSettings(),
            $scope.options
        ).success(function(data){
            $scope.dismiss();

            if ($scope.buildAfterCreation) {
                buildDataset($stateParams.projectKey, outputName).then(function(){
                    $state.transitionTo('projects.project.flow', {
                        projectKey : $stateParams.projectKey,
                        id : 'dataset_' + $stateParams.projectKey + '.' + outputName
                    });
                });
            } else {
                $state.transitionTo('projects.project.recipes.recipe', {
                    projectKey : $stateParams.projectKey , recipeName : data.id, newlyCreated:true
                });
            }
        }).error(setErrorInScope.bind($scope));
    }
});


app.controller("AnalysisSummaryController", function($scope, $rootScope, $stateParams, $timeout, DataikuAPI, TopNav, ActivityIndicator) {
    TopNav.setLocation(TopNav.TOP_ANALYSES, null, TopNav.TABS_ANALYSIS, "summary");

    DataikuAPI.analysis.getSummary($stateParams.projectKey, $stateParams.analysisId).success(function(data) {
        $scope.analysisCoreParams = data.object;
        $scope.objectTimeline = data.timeline;
        $scope.objectInterest = data.interest;

        TopNav.setItem(TopNav.ITEM_ANALYSIS, $stateParams.analysisId, {name: $scope.analysisCoreParams.name, inputDatasetSmartName: $scope.analysisCoreParams.inputDatasetSmartName});
        TopNav.setPageTitle($scope.analysisCoreParams.name + " - Analysis");

    }).error(setErrorInScope.bind($scope));

    $scope.$on("objectSummaryEdited", function(){
        DataikuAPI.analysis.saveCore($scope.analysisCoreParams, {summaryOnly: true}).success(function(data) {
            ActivityIndicator.success("Saved");
        }).error(setErrorInScope.bind($scope));
    });

    $scope.$on('customFieldsSummaryEdited', function(event, customFields) {
        $scope.saveCustomFields($scope.analysisCoreParams, customFields);
    });
});


app.directive('analysisRightColumnSummary', function(DataikuAPI, $state, $stateParams, $rootScope, $controller, GlobalProjectActions, QuickView, ActiveProjectKey, ActivityIndicator, MLTasksNavService) {
    return {
        templateUrl :'/templates/analysis/right-column-summary.html',
        link : function($scope) {

            $controller('_TaggableObjectsMassActions', { $scope });

            $scope.QuickView = QuickView;

            function setUIState() {
                $scope.analysisData.uiState = $scope.analysisData.uiState || { showAllMLTasks: false, showAllSavedModels: false };
            }

            function prepareMLTasks() {
                // Compute icons
                $scope.analysisData.mlTasks.forEach(mlTask => {
                    switch(mlTask.taskType) {
                        case 'PREDICTION':
                            if (mlTask.backendType === 'KERAS') {
                                mlTask.computedIcon = 'icon-dku-deeplearning-prediction';
                            } else {
                                mlTask.computedIcon = 'icon-dku-automl-prediction';
                            }
                        break;
    
                        case 'CLUSTERING':
                            mlTask.computedIcon = 'icon-dku-automl-clustering';
                        break;
                    }
                });

                // Sort
                $scope.analysisData.mlTasks.sort((a, b) => { return a.lastModifiedOn - b.lastModifiedOn } );

                const activeMLTaskId = MLTasksNavService.getActiveMLTaskId($scope.selection.selectedObject.id);

                // Last opened ml task takes precedence over modification date sorting.
                if (activeMLTaskId) {
                    const activeMLTaskIndex = $scope.analysisData.mlTasks.findIndex(mlTask => mlTask.mlTaskId === activeMLTaskId);
                    Array.move($scope.analysisData.mlTasks, activeMLTaskIndex, 0);
                }
            }
            
            $scope.refreshData = function() {
                $scope.insight = $scope.selection.selectedObject;

                DataikuAPI.analysis.getSummary($scope.selection.selectedObject.projectKey, $scope.selection.selectedObject.id, true).success(data => {
                    // TODO use sequenceId
                    $scope.analysisData = { analysis: data.object, mlTasks: data.mlTasks, savedModels: data.savedModels };
                    $scope.analysis = $scope.analysisData.analysis;
                    setUIState();
                    prepareMLTasks();

                    $rootScope.$broadcast('objectMetaDataRefresh', { 
                        tags: $scope.analysis.tags,
                        shortDesc: $scope.analysis.shortDesc,
                        description: $scope.analysis.description,
                        checklists: $scope.analysis.checklists,
                        customFields: $scope.analysis.customFields
                    });
                });
            };

            /* Auto save when summary is modified */
            $scope.$on("objectSummaryEdited", function(){
                DataikuAPI.analysis.saveCore($scope.selection.selectedObject, {summaryOnly: true}).success(function(data) {
                    ActivityIndicator.success("Saved");
                }).error(setErrorInScope.bind($scope));
            });

            $scope.refreshTimeline = function(){
                DataikuAPI.timelines.getForObject(ActiveProjectKey.get(), "ANALYSIS", $scope.selection.selectedObject.id)
                .success(function(data){
                    $scope.objectTimeline = data;
                })
                .error(setErrorInScope.bind($scope));
            };

            $scope.deleteAnalysis = function() {
                GlobalProjectActions.deleteTaggableObject($scope, 'ANALYSIS', $scope.selection.selectedObject.id, $scope.selection.selectedObject.name)
            };

            $scope.duplicate = function() {
                DataikuAPI.analysis.duplicate(ActiveProjectKey.get(), $scope.selection.selectedObject.id).success(function(data) {
                    if ($scope.list) {
                        $scope.list();
                        $scope.selection.selectedObject = null;
                    } else {
                        $state.transitionTo("projects.project.analyses.analysis.script",{
                            projectKey : $stateParams.projectKey,
                            analysisId : data.id
                        });
                    }
                }).error(setErrorInScope.bind($scope));
            };

            $scope.$watch("selection.selectedObject", function(nv, ov) {
                if (!nv) return;
                $scope.analysisData = {analysis: nv, mlTasks: []}; // display temporary (incomplete) data
                if (!$scope.selection.selectedObject) {
                    $scope.objectTimeline = null;
                    $scope.acp = null;
                }
            });

            $scope.$watch("selection.confirmedItem", function(nv, ov) {
                if (!nv) return;
                $scope.refreshData();
            });

            const customFieldsListener = $rootScope.$on('customFieldsSaved', $scope.refreshData);
            $scope.$on("$destroy", customFieldsListener);
        }
    }
});

app.controller("AnalysisPageRightColumnActions", async function($controller, $scope, $rootScope, $stateParams, DataikuAPI, ActiveProjectKey) {

    $controller('_TaggableObjectPageRightColumnActions', {$scope: $scope});

    $scope.data = (await DataikuAPI.analysis.getSummary(ActiveProjectKey.get(), $stateParams.analysisId)).data;

    const analysis = $scope.data.object;
    analysis.nodeType = "ANALYSIS";
    analysis.interest = $scope.data.interest;

    $scope.selection = {
        selectedObject : analysis,
        confirmedItem : analysis
    };

    function updateUserInterests() {
        DataikuAPI.interests.getForObject($rootScope.appConfig.login, "ANALYSIS", ActiveProjectKey.get(), $stateParams.analysisId).success(function(data) {

            $scope.selection.selectedObject.interest = data;

        }).error(setErrorInScope.bind($scope));
    }

    updateUserInterests();
    const interestsListener = $rootScope.$on('userInterestsUpdated', updateUserInterests);
    $scope.$on("$destroy", interestsListener);
});

})();

(function() {
'use strict';


const app = angular.module('dataiku.analysis.script', []);

/**
 * This acts as the controller of the analysis script page.
 * It is a directive for easy composition with the common shaker stuff
 *
 * It is loaded after shakerExploreBase
 */
app.directive("analysisScript", function($q, Assert, DataikuAPI, WT1, TopNav, DatasetUtils, computeColumnWidths) {
    return {
        scope: true,
        controller: function($scope, $stateParams, $state) {

            /* ********************* Callbacks for shakerExploreBase ******************* */

            var savedParams;

            $scope.shakerHooks.saveForAuto = function() {
                Assert.inScope($scope, 'analysisCoreParams');
                var deferred = $q.defer();

                var toSave = angular.copy($scope.analysisCoreParams);
                // fat-free
                toSave.script = $scope.getShakerData();
                savedParams.script = savedParams.script || {};
                savedParams.script.origin = "ANALYSIS";
                if (angular.equals($scope.analysisCoreParams.script, savedParams.script)) {
                	deferred.resolve();
                    return deferred.promise;
                }
                DataikuAPI.analysis.saveCore(toSave).success(function(data) {
                    // Reset modification detector
                    $scope.originalShaker = toSave.script;
                    deferred.resolve();
                }).error(setErrorInScope.bind($scope));
                return deferred.promise;
            };

            $scope.shakerHooks.setColumnMeaning = function(column, newMeaning) {
                Assert.inScope($scope, 'shaker');
                Assert.trueish($scope.shaker.analysisColumnData, 'analysisColumnData is null');

                var colData = $scope.shaker.analysisColumnData[column.name];
                if (!colData){
                    colData = {}
                    $scope.shaker.analysisColumnData[column.name] = colData;
                }
                colData.meaning = newMeaning;

                $scope.autoSaveAutoRefresh();
            };

            $scope.shakerHooks.updateColumnDetails = function(column) {
                Assert.inScope($scope, 'shaker');
                Assert.trueish($scope.shaker.analysisColumnData, 'analysisColumnData is null');

                $scope.shaker.analysisColumnData[column.name] = column;
                $scope.autoSaveAutoRefresh();
            };

            $scope.shakerHooks.updateColumnWidth = function(name, width) {
                Assert.inScope($scope, 'shaker');
                Assert.trueish($scope.shaker.columnWidthsByName, 'columnWidthsByName is null');

                $scope.shaker.columnWidthsByName[name] = width;
                $scope.autoSaveAutoRefresh();
            };

            $scope.clearResize = function() {
                Assert.inScope($scope, 'shaker');
                Assert.trueish($scope.shaker.columnWidthsByName, 'columnWidthsByName is null');

                const minColumnWidth = 100;
                $scope.shaker.columnWidthsByName = computeColumnWidths($scope.table.initialChunk, $scope.table.headers, minColumnWidth, $scope.hasAnyFilterOnColumn, $scope.shaker.columnWidthsByName, true)[1];
                $scope.autoSaveAutoRefresh();
            }

            /* ********************* Misc stuff ******************* */

            /* BEGIN DIRTY TO DESTROY */

            $scope.$watch("projectSummary", function(nv, ov) {
                $scope.shakerWritable = $scope.isProjectAnalystRW();
                $scope.shakerState.writeAccess = $scope.isProjectAnalystRW();
            });

            /* END DIRTY TO DESTROY */

            /* ********************* Main ******************* */

            WT1.event("analysis-script-open");
            TopNav.setLocation(TopNav.TOP_ANALYSES, null, TopNav.TABS_ANALYSIS, "script");
            TopNav.setItem(TopNav.ITEM_ANALYSIS, $stateParams.analysisId);

            // Verify that shakerExploreBase is loaded
            Assert.inScope($scope, 'shakerState');
            Assert.inScope($scope, 'shakerHooks');

            $scope.shakerState.isInAnalysis = true;
            $scope.shakerState.origin = "ANALYSIS";

            DataikuAPI.analysis.getCore($stateParams.projectKey, $stateParams.analysisId).success(function(data) {
                var inputDatasetLoc = DatasetUtils.getLocFromSmart($stateParams.projectKey, data.inputDatasetSmartName);
                // set the context required for baseInit
                $scope.inputDatasetProjectKey = inputDatasetLoc.projectKey;
                $scope.inputDatasetName = inputDatasetLoc.name;
                $scope.inputDatasetSmartName = data.inputDatasetSmartName;
                $scope.analysisDataContext.inputDatasetLoc = inputDatasetLoc;
                $scope.baseInit();

                $scope.analysisCoreParams = data;
                savedParams = angular.copy(data);

                TopNav.setItem(TopNav.ITEM_ANALYSIS, $stateParams.analysisId, {name:data.name, dataset : data.inputDatasetSmartName});
                TopNav.setPageTitle(data.name);

                // Load shaker and call initial refresh

                $scope.shaker = data.script;
                $scope.shaker.origin = "ANALYSIS";
                $scope.originalShaker = angular.copy($scope.shaker.script);

                $scope.fixupShaker();
                $scope.requestedSampleId = null;
                $scope.refreshTable(false);

                // TODO @analysis
                // TopNav.setItemData({"name" : data.name })

            }).error(setErrorInScope.bind($scope));
        }
    }
});

app.directive("visualMlAccessCheck", function() {	
    return {	
        restrict: 'A',
        transclude: true,
        templateUrl: '/templates/analysis/visual-ml-access-check.html'
    }	
});

app.directive('datasetColumnsViewColumn', function(Assert, CreateModalFromTemplate, ContextualMenu, $state, DataikuAPI, WT1) {
    return {
        restrict: 'A',
        replace: false,
        scope: false,
        link: function(scope, element, attrs) {
            scope.isType = function(x) {
                return this.column.selectedType.name == x;
            };

            scope.possibleMeanings = [];
            scope.$watch("column.possibleTypes", function() {
            	if (scope.column.possibleTypes == null) return;
            	scope.possibleMeanings = $.map(scope.column.possibleTypes, function(t) {
            		return t.name;
            	});
            });

            scope.setColumnMeaning = function(newMeaning) {
                Assert.trueish(scope.shakerHooks.setColumnMeaning, 'no setColumnMeaning function');
                scope.shakerHooks.setColumnMeaning(scope.column, newMeaning);
            };

            scope.editColumnUDM = function(){
                CreateModalFromTemplate("/templates/meanings/column-edit-udm.html", scope, null, function(newScope){
                    newScope.initModal(scope.column.name, scope.setColumnMeaning);
                });
            }
        }
    };
});

app.directive("analysisColumns", function(Fn, ListFilter, DataikuAPI, Logger,
            CreateModalFromDOMElement, CreateModalFromTemplate,
            Debounce, MonoFuture, $filter, ShakerSuggestionsEngine, $stateParams) {

    var extractName = Fn.prop('name'),
        compInfos = ['cardinality', 'mode', 'min', 'max', 'mean', 'sum', 'median', 'stddev'],
        validInfos = ['okPercentage', 'nokPercentage', 'emptyPercentage', 'nonemptyPercentage'],
        extraInfos = ['missingCount', 'presentCount', 'invalidCount'];

    function refreshColumns($scope) {
        var cf = $scope.columnFilter;
        cf._cols = $scope.table.headers;
        cf.types = cf._cols.map(Fn.prop(['selectedType', 'name'])).filter(Fn.unique()).sort();
        cf.hasFetchedInfos = false;
        cf.hasFetchedFullInfos = false;
        cf.hasFetchedFullInfosForPartitionId = null;
        updateColumnsInfo($scope);
        if ($scope.clearQuickColumnsCache) {
            $scope.clearQuickColumnsCache();
        }
    }

    function copyPropFromData(data, fromProp, c, toProp) {
        c[toProp] = c.name in data && fromProp in data[c.name] ? data[c.name][fromProp] : null;
    }

    function fetchFullInfo($scope, callback) {
        var cf = $scope.columnFilter;
        cf.hasFetchedFullInfos = null;
        var partitionId = $scope.uiState.fullPartitionId;
        DataikuAPI.shakers.multiColumnFullAnalysis($stateParams.projectKey,
            $scope.inputDatasetProjectKey, $scope.inputDatasetName, $scope.shakerHooks.shakerForQuery()
                , partitionId, cf._cols.map(extractName)).success(function(data) {
            compInfos.forEach([].forEach.bind(cf._cols, function(c) {
                copyPropFromData(data, this, c, 'full_comp_' + this);
                copyPropFromData(data, this + '_current', c, 'full_comp_' + this + '_current');
                copyPropFromData(data, this + '_reason', c, 'full_comp_' + this + '_reason');
            }));
            validInfos.forEach([].forEach.bind(cf._cols, function(c) {
                copyPropFromData(data, this, c, 'full_' + this);
                copyPropFromData(data, this + '_current', c, 'full_' + this + '_current');
                copyPropFromData(data, this + '_reason', c, 'full_' + this + '_reason');
            }));
            extraInfos.forEach([].forEach.bind(cf._cols, function(c) {
                copyPropFromData(data, this, c, 'full_' + this);
            }));
            cf.hasFetchedFullInfos = true;
            cf.hasFetchedFullInfosForPartitionId = partitionId;
            callback($scope);
        }).error(setErrorInScope.bind($scope));
    }

    function fetchInfo($scope, callback) {
        var cf = $scope.columnFilter;
        cf.hasFetchedInfos = null;
        $scope.monoFetch.exec(
            DataikuAPI.shakers.multiColumnAnalysis(
                $stateParams.projectKey,
                $scope.inputDatasetProjectKey, $scope.inputDatasetName, $scope.inputStreamingEndpointId, $scope.shakerHooks.shakerForQuery(),
                $scope.requestedSampleId, cf._cols.map(extractName), '*'))
        .success((function(data) {
                if (!data.hasResult) return;
                data = data.result;
                compInfos.forEach([].forEach.bind(cf._cols, function(c) {
                    copyPropFromData(data, this, c, 'comp_' + this);
                }));
                cf.hasFetchedInfos = true;
                callback($scope);
            }).bind(this))
        .error(setErrorInScope.bind($scope));
    }

    function prepareInfoValuesForDisplay(cf) {
        var comp = cf.info.substr(0, 5) === 'comp_';
        if (comp) {
            cf._cols.forEach(function(c) {
                if (c.info === null || this === 'comp_cardinality') { /* no special formatting */ }
                else switch (c.selectedType.name) {
                case 'DoubleMeaning':
                    c.info = c.info.toFixed(4);
                    break;
                case 'Date':
                    if (this == 'comp_sum') {
                        c.info = null; // sum is meaningless for dates
                    } else {
                        c.info = $filter(this === 'comp_stddev' ? 'friendlyDurationShort' : 'date')(c.info);
                    }
                    break;
                default:
                    if (['comp_mean', 'comp_sum', 'comp_average', 'comp_stddev'].indexOf(this) > -1) {
                        c.info = c.info.toFixed(4);
                    }
                }
            }, cf.info);
        } else {
            if (cf.info.substr(-10) === 'Percentage') {
                cf._cols.forEach(function(c) { c.info = c.info != null ? c.info.toFixed(2) + '%' : null; });
            }
        }
    }

    function updateColumnsInfo($scope) {
        var cf = $scope.columnFilter;
        if (!cf._cols || cf._cols.length===0) {return;}
        if ($scope.uiState.useFullSampleStatistics) {
            if (cf.hasFetchedFullInfos == false || (cf.hasFetchedFullInfos == true && cf.hasFetchedFullInfosForPartitionId != $scope.uiState.fullPartitionId)) {
                fetchFullInfo($scope, function() {
                    updateColumnsInfo($scope);
                    if (cf.validity.valid || cf.validity.invalid || cf.validity.missing) {
                        filterColumns($scope);
                    }
                });
            } else if (cf.hasFetchedFullInfos == true) {
                cf._cols.forEach(Fn.assign('info', Fn.prop('full_' + cf.info))); // put the info in the column object
                cf._cols.forEach(Fn.assign('info_current', Fn.prop('full_' + cf.info + '_current')));
                cf._cols.forEach(Fn.assign('info_reason', Fn.prop('full_' + cf.info + '_reason')));
                prepareInfoValuesForDisplay(cf);
            }
        } else {
            if (cf.hasFetchedInfos == false) {
                fetchInfo($scope, function() {
                    updateColumnsInfo($scope);
                });
            } else if (cf.hasFetchedInfos == true) {
                cf._cols.forEach(Fn.assign('info', Fn.prop(cf.info))); // put the info in the column object
                prepareInfoValuesForDisplay(cf);
            }
        }
    }

    function selectActions($scope) {
        if ($scope.selection === undefined || $scope.selection.selectedObjects === undefined) {return;}
        var selectedObjects = $scope.selection.selectedObjects;
        if (selectedObjects.length === 0) {
            $scope.massColumnActions = $scope.massColumnActions2 = $scope.hasMoreMassColumnActions =
                $scope.suggestedTypes = $scope.otherTypes = null;
            return;
        }
        var maps = ShakerSuggestionsEngine.computeColumnSuggestions(selectedObjects, CreateModalFromDOMElement,
                CreateModalFromTemplate, undefined, undefined, $scope.appConfig),
            colTypes = selectedObjects.map(Fn.prop('possibleTypes')).filter(Array.isArray)
                .map(function (pts) { return pts.map(extractName); });
        $scope.massColumnActions = maps[0];
        $scope.massColumnActions2 = maps[1];
        $scope.hasMoreMassColumnActions = maps[2] > 0;
        var suggestedTypesNames = colTypes.slice(1).reduce(
                function(ts, ts2) { return ts.filter(Fn.inArray(ts2)); }, colTypes[0]);
        $scope.otherTypes = [];
        $scope.suggestedTypes = [];
        angular.forEach($scope.types, function(v,k) {
            if (Fn.not(Fn.inArray(suggestedTypesNames))(k)) {
                $scope.otherTypes.push({id:k, name:v});
            } else {
                $scope.suggestedTypes.push({id:k, name:v});
            }
        });
    }

    return {
        scope: false,
        controller: function($scope) {
            $scope.uiState = {};
            $scope.monoFetch = MonoFuture($scope);
            $scope.columnFilter = {
                _cols: $scope.table.headers,
                info: 'okPercentage',
                types: [],
                validity: { valid: false, invalid: false, missing: false },
            };

            function customFilter(objects) {
                var cf = $scope.columnFilter;
                if (cf.validity.valid || cf.validity.invalid || cf.validity.missing) {
                    objects = objects.filter((function(v, i, m, o) {
                        return (v && o.selectedType.nbNOK + o.selectedType.nbEmpty === 0)
                            || (i && o.selectedType.nbNOK   > 0)
                            || (m && o.selectedType.nbEmpty > 0);
                    }).bind(null, cf.validity.valid, cf.validity.invalid, cf.validity.missing));
                }
                return objects;
            }

            $scope.selection = {
                customFilter: customFilter,
                customFilterWatch: 'columnFilter.validity',
                orderQuery: '$idx',
            };

            $scope.$watch('table.headers', refreshColumns.bind(null, $scope));
            $scope.$watch('columnFilter.info', updateColumnsInfo.bind(null, $scope));
            $scope.$watch('uiState.useFullSampleStatistics', updateColumnsInfo.bind(null, $scope));
            $scope.$watch('uiState.fullPartitionId', updateColumnsInfo.bind(null, $scope));
            $scope.$watch('selection.selectedObjects', selectActions.bind(null, $scope));

            $scope.deleteColumns = function(selectedColumns) {
                var colNames = selectedColumns.map(Fn.prop('name'));
                $scope.addStepNoPreview('ColumnsSelector', { keep: false, appliesTo: 'COLUMNS', columns: colNames });
                $scope.mergeLastColumnDeleters();
                $scope.autoSaveForceRefresh();
            };
            $scope.renameColumns = function(selectedColumns) {
                var colNames = selectedColumns.map(Fn.prop('name'));
                CreateModalFromTemplate('/templates/shaker/modals/shaker-rename-columns.html', $scope, 'MassRenameColumnsController', function(newScope) {
                    newScope.$apply(function() { newScope.setColumns(colNames); });
                    newScope.doRenameColumns = function(renamings) {
                        var cols = $scope.table.headers;
                        renamings.forEach(function(renaming) {
                            cols.forEach(function(h) { if (h.name === renaming.from) h.name = renaming.to; });
                        });
                        $scope.addStepNoPreview("ColumnRenamer", { renamings : renamings });
                        $scope.mergeLastColumnRenamers();
                        $scope.autoSaveForceRefresh();
                    };
                });
            };
            $scope.changeType = function changeType(selectedColumns, typeName) {
                var colNames = selectedColumns.map(Fn.prop('name'));
                Logger.info("Set meaning", typeName, "on ", colNames);
                colNames.forEach(function(c){
                    $scope.shakerHooks.setColumnMeaning({name:c}, typeName);
                });
                $scope.autoSaveForceRefresh();
            };
            $scope.blur = function() {
                if (document.activeElement.tagName === 'INPUT') { document.activeElement.blur(); }
            };
            $scope.renameColumn = function(column, name) {
                if (column.name !== name) {
                    var old = column.name;
                    column.name = name; // for selection tracking
                    $scope.addStepNoPreviewAndRefresh("ColumnRenamer", {
                        renamings : [
                            { from : old, to : name }
                        ]
                    });
                    $scope.mergeLastColumnRenamers();
                }
            };
            $scope.analyzeColumn = function(column) {
                // Parent's (note the analySe) but prev/next limited to filtered columns
                $scope.analyseColumn(column, $scope.selection.filteredObjects);
            };
            $scope.initColumn = function(columnScope) {
                if (columnScope.column) {
                    var maps = ShakerSuggestionsEngine.computeColumnSuggestions(columnScope.column,
                            CreateModalFromDOMElement, CreateModalFromTemplate, undefined, undefined, $scope.appConfig);
                    columnScope.actions = maps[0];
                    columnScope.actions2 = maps[1];
                    columnScope.name = columnScope.column.name
                }
            };
            $scope.massColumnActions = $scope.massColumnActions2 = [];

            $scope.types = ($scope.appConfig.meanings.labelsMap);
            $scope.columnTypes = function columnTypes(col, probable) {
                var f = Fn.inArray((col.possibleTypes || []).map(extractName));
                f = probable ? f : Fn.not(f);
                var ret = {};
                angular.forEach($scope.types, function(v, k) {
                    if ( f(v) )
                        ret[k] = v;
                });
                return ret;
            };

            $scope.$watch('table.headers', refreshColumns.bind(null, $scope));
            $scope.$watch('columnFilter.info', updateColumnsInfo.bind(null, $scope));
            $scope.$watch('uiState.useFullSampleStatistics', function() {
                updateColumnsInfo.bind(null, $scope)();
            });
            $scope.$watch('uiState.fullPartitionId', function() {
                updateColumnsInfo.bind(null, $scope)();
            });

            // as callback for when the full sample statistics are ready
            $scope.refreshColumnsInfo = function() {
                $scope.columnFilter.hasFetchedFullInfos = false;
                updateColumnsInfo($scope);
            }
        }
    }
});

})();

(function() {
'use strict';

const app = angular.module('dataiku.analysis.script');


app.directive('analysisCharts', function($q, $timeout, Logger, Assert, DataikuAPI, WT1, ActivityIndicator, TopNav, DatasetUtils, ChartChangeHandler) {
return {
        scope: true,
        controller: function ($scope, $stateParams, $state) {
            if ($stateParams.chartIdx) {
                $scope.currentChart.index = parseInt($stateParams.chartIdx);
            }

            /* ********************* Execute Callbacks for chartsCommon ******************* */

            function getDataSpec() {
                const currentChart = $scope.charts[$scope.currentChart.index];
                Assert.trueish(currentChart, "No current chart");
                const dataSpec = {
                    datasetProjectKey : $scope.inputDatasetProjectKey,
                    datasetName : $scope.inputDatasetName,
                    script: angular.copy($scope.shaker),
                    copySelectionFromScript: currentChart.copySelectionFromScript,
                    sampleSettings : currentChart.refreshableSelection,
                    engineType : "LINO"
                }
                dataSpec.script.origin = "ANALYSIS";
                return dataSpec;
            }

            $scope.getExecutePromise = function(request, saveShaker = true, noSpinner = false) {
                const currentChart = $scope.charts[$scope.currentChart.index];
                Assert.trueish(currentChart, "No current chart");
                Assert.trueish(currentChart.summary, "Current chart summary is not ready");

                (saveShaker !== false) && $scope.saveShaker();
                if (request) {
                    let promise = DataikuAPI.shakers.charts.getPivotResponse($stateParams.projectKey, getDataSpec(), request, currentChart.summary.requiredSampleId);

                    if (noSpinner === true) {
                        promise = promise.noSpinner();
                    }

                    return promise;
                }
            };

            $scope.saveChart = function(){
                $scope.saveShaker();
            };

            $scope.$on("chartSamplingChanged", function(){
                $scope.clearCachedSummaries();
                $scope.fetchColumnsSummaryForCurrentChart().then(function(){
                    Logger.info("Sample reloaded, executing chart");
                    $scope.$broadcast("forceExecuteChart");
                });
            });

            $scope.getDefaultNewChart = function() {
                var newChart = null;
                if ($scope.charts.length > 0) {
                    // Copy to retrieve the same sample, copySample and engine settings
                    newChart = angular.copy($scope.charts[$scope.charts.length - 1]);
                    newChart.def = ChartChangeHandler.defaultNewChart();
                } else {
                    newChart = {
                        def : ChartChangeHandler.defaultNewChart(),
                        copySelectionFromScript : true,
                        maxDataBytes: 150*1024*1024
                    }
                }
                newChart.engineType = "LINO";
                return newChart;
            }

            function acpIsDirty(ignoreThumbnailChanges) {
                try {
                    var savedACP2 = angular.copy(savedACP);
                    var acp = angular.copy($scope.acp);

                    if (ignoreThumbnailChanges) {
                        acp.charts.forEach(function(chart){
                            chart.def.thumbnailData = null;
                        });
                        savedACP2.charts.forEach(function(chart){
                            chart.def.thumbnailData = null;
                        });
                    }
                    return !angular.equals(acp, savedACP2);
                } catch (e) {
                    Logger.error(e);
                    return true;
                }
            }

            $scope.saveShaker = function() {
                Logger.info("Save ACP");

                var ignoreThumbnailChanges = !$scope.isProjectAnalystRW();
                if (!acpIsDirty(ignoreThumbnailChanges)) {
                    Logger.info("No changes: don't save shaker")
                    return;
                }

                if ($scope.isProjectAnalystRW()){
                    DataikuAPI.analysis.saveCore($scope.acp).success(function(data) {
                        ActivityIndicator.success("Charts saved");
                    }).error(setErrorInScope.bind($scope));
                } else {
                    ActivityIndicator.warning("You don't have write access - not saving");
                }
            };

            /* ********************* Load callback ******************* */

            var cachedColumnSummaries = {};

            $scope.clearCachedSummaries = function(){
                $scope.charts.forEach(function(x) {
                    x.summary = null;
                });
                cachedColumnSummaries = {};
            }

            $scope.fetchColumnsSummaryForCurrentChart = function(forceRefresh){
                var currentChart = $scope.charts[$scope.currentChart.index];
                var dataSpec = getDataSpec();
                var cacheKey = JSON.stringify(dataSpec).dkuHashCode();

                var promise = null;
                if (cachedColumnSummaries[cacheKey] != null && !forceRefresh) {
                    Logger.info("Already cached for", dataSpec);
                    promise = $q.when(cachedColumnSummaries[cacheKey]);
                } else {
                    Logger.info("No cache for", dataSpec);
                    promise = DataikuAPI.shakers.charts.getColumnsSummary($stateParams.projectKey, dataSpec)
                        .error(setErrorInScope.bind($scope))
                        .then(function(response) {
                        cachedColumnSummaries[cacheKey] = response.data;
                        return response.data;
                    })
                }

                return promise.then(function(data){
                    currentChart.summary = data;
                    $scope.makeUsableColumns(data);
                });
            }

            /* ********************* Main ******************* */

            var savedACP;
            var main = function(){
                WT1.event("analysis-charts-open");
                TopNav.setLocation(TopNav.TOP_ANALYSES, null, TopNav.TABS_ANALYSIS, "charts");
                TopNav.setItem(TopNav.ITEM_ANALYSIS, $stateParams.analysisId);

                DataikuAPI.analysis.getCore($stateParams.projectKey, $stateParams.analysisId).success(function(data) {
                    $scope.acp = data;
                    $scope.shaker = data.script;
                    $scope.charts = data.charts;
                    savedACP = angular.copy(data);
                    TopNav.setItem(TopNav.ITEM_ANALYSIS, $stateParams.analysisId, {name:data.name, dataset: data.inputDatasetSmartName});
                    TopNav.setPageTitle(data.name);

                    var inputDatasetLoc = DatasetUtils.getLocFromSmart($stateParams.projectKey, data.inputDatasetSmartName);
                    // set the context required for baseInit
                    $scope.analysisDataContext.inputDatasetLoc = inputDatasetLoc;
                    $scope.inputDatasetProjectKey = inputDatasetLoc.projectKey;
                    $scope.inputDatasetName = inputDatasetLoc.name;

                    DataikuAPI.datasets.get($scope.inputDatasetProjectKey, $scope.inputDatasetName, $stateParams.projectKey).success(function(data){
                        $scope.dataset = data;
                    }).error(setErrorInScope.bind($scope));

                    if ($scope.charts.length === 0) {
                        $scope.addChart();
                    }
                    $scope.$watch("charts[currentChart.index]", function(nv){
                        Logger.info("Chart changed, fetching summary and executing");
                        if (nv) {
                            $scope.fetchColumnsSummaryForCurrentChart().then(function(){
                                // Fixes a race condition that used to happen sometimes when explores.get returned before the
                                // event listeners in chart_logic.js were properly set up, causing the forceExecuteChart to be missed
                                // and nothing to be drawn.
                                $scope.forceExecuteChartOrWait();
                            })
                        }
                    });
                }).error(setErrorInScope.bind($scope));
            }

            main();
        }
    }
})


app.directive("analysisChartSamplingEditor", function(DataikuAPI, $controller, $stateParams, $timeout, WT1, $q, CreateModalFromTemplate, DatasetUtils, ChartUtils) {
    return {
        scope : {
            dataset: '=',
            chart : '=',
            script : '='
        },
        templateUrl : "/templates/analysis/charts-sampling-editor-tab.html",
        controller : function($scope){
            $scope.canCopySelectionFromScript = true;
            $controller("_ChartOnDatasetSamplingEditorBase", {$scope:$scope});

            $scope.save = function() {
                if ($scope.chart.refreshableSelection) {
                    $scope.chart.refreshableSelection._refreshTrigger =
                            ($scope.chart.refreshableSelection._refreshTrigger||0)+1;
                }

                // $scope.validateChange().then(function(){
                    // $scope.origSampling = angular.copy($scope.sampling);
                    $scope.$emit("chartSamplingChanged");
                // }).catch(function() {
                    // $scope.sampling = angular.copy($scope.origSampling);
                // });
            };
            $scope.saveNoRefresh = function() {
                $scope.$emit("chartSamplingChanged");
            };

        }
    }
});

app.directive('columnAnalysis', function(DataikuAPI, $stateParams) { return {
    scope: { ids: '=', column: '=', callback: '=?', cache: '=?',
        isNumeric: '=?', isDate: '=?', asList: '=?' , distinctValues: '=?'},
    templateUrl: '/templates/analysis/column-analysis.html',
    transclude: true,
    link: function(scope, element, attrs) {
        if (scope.cache === true) {
            scope.cache = {};
        }
        scope.$watch('column', function(column) {
            function fixupData(data) {
                if (typeof scope.callback === 'function') { // not sure it's still used
                    scope.callback(data);
                }
                if (typeof data.missing === 'number') { // if not 0 but rounded to 0.0%, force emphasize => 0.1%
                    data.pcEmpty = data.missing ? ((Math.round(data.missing * 1000) || 1) / 10) : 0.0;
                }
                if (typeof data.bad === 'number') { // same
                    data.pcNOK = data.bad ? ((Math.round(data.bad * 1000) || 1) / 10) : 0.0;
                }
            };

            const key = column;
            function setData(data) {
                if (!data) return;
                if (scope.cache) {
                    scope.cache[key] = data;
                }

                const analysisData = scope.isNumeric && data.numericalAnalysis || !scope.isNumeric && data.alphanumFacet;
                if (!analysisData) return;

                scope.data = analysisData;
                scope.distinctValues = scope.data.totalNbValues;
                fixupData(scope.data);
            };

            scope.count = attrs.alphaFacets && parseInt(attrs.alphaFacets) || 7;
            if (scope.cache && key in scope.cache) {
                setData(scope.cache[key]);
            } else if (scope.ids) {
                DataikuAPI.shakers.detailedColumnAnalysis.apply(DataikuAPI.shakers,[$stateParams.projectKey].concat(scope.ids()).concat(scope.column).concat(50))
                .success(function(data){
                    setData(data);
                }).error(setErrorInScope.bind(scope.$parent || scope));
            }
        });
    }
}; });

})();

(function(){
'use strict';

var app = angular.module('dataiku.analysis.mlcore',['dataiku.ml.core', 'dataiku.ml.report']);

app.factory("MLTasksNavService", function($state, $stateParams, Fn, Assert, localStorageService) {
    /** Choose to which ml task to go based on the list */
    const ret  = {
        getActiveMLTaskId: (analysisId) => localStorageService.get("analysis." + analysisId + ".activeMLTask"),
        setMlTaskIdToGo: function(analysisId, mlTaskId) {
            return localStorageService.set("analysis." + analysisId + ".activeMLTask", mlTaskId);
        },
        mlTaskIdToGo: function(analysisMLTasks, analysisId) {
            Assert.trueish(analysisMLTasks.length, "No ML task");
            var goTo = ret.getActiveMLTaskId(analysisId);
            if (!goTo || !analysisMLTasks.some(Fn(Fn.prop('mlTaskId'), Fn.eq(goTo)))) {
                goTo = analysisMLTasks[0].mlTaskId;
            }
            Assert.trueish(goTo, "No ML task to go to");
            return goTo;
        },
        link: Fn.dict({ PREDICTION: 'predmltask', CLUSTERING: 'clustmltask' }, false),
        goToCorrectMLTask: function(analysisMLTasks, analysisId) {
            var goTo = ret.mlTaskIdToGo(analysisMLTasks, analysisId),
                mlTask = analysisMLTasks.filter(Fn(Fn.prop('mlTaskId'), Fn.eq(goTo)))[0],
                link = mlTask && ret.link(mlTask.taskType);
            Assert.trueish(link, "cannot resolve ML task link from taskType");
            $state.go("projects.project.analyses.analysis.ml." + link + ".list.results", {
                    projectKey: $stateParams.projectKey,
                    analysisId: $stateParams.analysisId,
                    mlTaskId: goTo
                }, {location: "replace"});
        }
    };
    return ret;
});


/**
 * The MLTasks list page. We only stay on this page if there is no ML task yet
 */
app.controller("AnalysisMLTasksController", function($scope, DataikuAPI, $q, CreateModalFromTemplate, $state, $stateParams, TopNav, MLTasksNavService){
    TopNav.setLocation(TopNav.TOP_ANALYSES, null, TopNav.TABS_ANALYSIS, "models");
    TopNav.setItem(TopNav.ITEM_ANALYSIS, $stateParams.analysisId);

    DataikuAPI.analysis.getCore($stateParams.projectKey, $stateParams.analysisId).success(function(data) {
        $scope.analysisCoreParams = data;
        TopNav.setItem(TopNav.ITEM_ANALYSIS, $stateParams.analysisId,
            {name: data.name, inputDatasetSmartName: data.inputDatasetSmartName});
        TopNav.setPageTitle(data.name + " - Analysis");

        DataikuAPI.analysis.listMLTasks($stateParams.projectKey, $stateParams.analysisId).success(function(data){
            $scope.analysisMLTasks = data;
            if ($scope.analysisMLTasks.length) {
                MLTasksNavService.goToCorrectMLTask($scope.analysisMLTasks, $stateParams.analysisId);
            }
        });
    }).error(setErrorInScope.bind($scope));

    $scope.createNewMLTask = CreateModalFromTemplate.bind(null,
        "/templates/analysis/new-mltask-modal.html", $scope, "AnalysisNewMLTaskController");
});

app.directive('iframeOnload', [function () {
    return {
        scope: {
            callBack: '&iframeOnload'
        },
        link: function (scope, element, attrs) {
            element.on('load', function () {
                scope.$apply(function () {
                    scope.callBack();
                });
            })
        }
    }
}]);


app.controller("AnalysisNewMLTaskController", function($scope, $rootScope, $controller, $state, $location, $timeout, DataikuAPI){
    $controller("DatasetLabController", { $scope: $scope });
    $scope.datasetSmartName = $scope.analysisCoreParams.inputDatasetSmartName;

    // Override default template creation functions in order to reuse the current Analysis instead of creating new one.
    $scope.createPredictionTemplate = function(policyId = $scope.predictionTaskData.selectedPolicy.id) {
        const taskData = $scope.predictionTaskData;

        DataikuAPI.analysis.pml.createAndGuess(
            $scope.analysisCoreParams.projectKey,
            $scope.analysisCoreParams.id,
            taskData.targetVariable,
            taskData.backendType,
            taskData.backendName,
            policyId
        ).success(data => {
            $rootScope.mlTaskJustCreated = true;
            if (policyId === 'DEEP') {
                $state.go('projects.project.analyses.analysis.ml.predmltask.list.design', { mlTaskId: data.id });
                $timeout(() => $location.hash('keras-build'));
            } else if (policyId === 'ALGORITHMS' || policyId === 'CUSTOM') {
                $state.go('projects.project.analyses.analysis.ml.predmltask.list.design', { mlTaskId: data.id });
                $timeout(() => $location.hash('algorithms.sessions'));
            } else {
                $state.go('projects.project.analyses.analysis.ml.predmltask.list.results', { mlTaskId: data.id });
            }
        }).error(setErrorInScope.bind($scope));
    };

    $scope.createClusteringTemplate = function() {
        DataikuAPI.analysis.cml.createAndGuess(
            $scope.analysisCoreParams.projectKey,
            $scope.analysisCoreParams.id,
            $scope.clusteringTaskData.backendType,
            $scope.clusteringTaskData.backendName,
            $scope.clusteringTaskData.selectedPolicy.id
        ).success(data => {
            $rootScope.mlTaskJustCreated = true;
            if ($scope.clusteringTaskData.selectedPolicy.id  === 'ALGORITHMS' || $scope.clusteringTaskData.selectedPolicy.id === 'CUSTOM') {
                $state.go("projects.project.analyses.analysis.ml.clustmltask.list.design", { mlTaskId: data.id });
                $timeout(() => $location.hash('algorithms.sessions'));
            } else {
                $state.go("projects.project.analyses.analysis.ml.clustmltask.list.results", { mlTaskId: data.id });
            }
        }).error(setErrorInScope.bind($scope));
    };
});
})();

(function(){
'use strict';

const app = angular.module('dataiku.analysis.mlcore');

app.controller("_MLTaskFeaturesController", function($scope, $controller, $timeout, $stateParams, $rootScope, Assert, DataikuAPI, Fn, Dialogs, PMLSettings, $q, CreateModalFromTemplate) {
    Assert.inScope($scope, "analysisCoreParams");

    // List of roles that should not be impacted by mass actions
    const PROTECTED_ROLES = ["TARGET", "WEIGHT"];

    $scope.featureAutoHandlingReason = {
        "REJECT_ZERO_VARIANCE" : "DSS has rejected this feature because all values of this feature are equal.",
        "REJECT_MISSING" : "DSS has rejected this feature because too many values are missing in this feature.",
        "REJECT_IDENTIFIER" : "DSS has rejected this feature because this feature looks like a unique identifier.",
        "REJECT_DEFAULT_TEXT_HANDLING" : "DSS rejects text features by default.",
        "REJECT_CARDINALITY": "DSS has rejected this feature because it had too many categories for the task at hand.",
        "REJECT_COPY_TARGET": "DSS does not copy feature handling to the target.",
        "REJECT_COPY_WEIGHT": "DSS does not copy feature handling to the sample weight."
    };

    $scope.featureAutoHandlingShortReason = {
        "REJECT_ZERO_VARIANCE" : "too many equal values",
        "REJECT_MISSING" : "too many missing values",
        "REJECT_IDENTIFIER" : "unique ID",
        "REJECT_DEFAULT_TEXT_HANDLING" : "text feature",
        "REJECT_CARDINALITY": "too many categories"
    };

    $scope.categoryHandlingModes = [
        ["DUMMIFY", "Dummy-encoding (vectorization)"],
        ["FLAG_PRESENCE", "Replace by 0/1 flag indicating presence"],
    ];

    $scope.vectorHandlingModes = [
        ["UNFOLD", "Unfold (create one column per element)"],
    ];

    $scope.imageHandlingModes = [
        ["CUSTOM", "Custom preprocessing"]
    ];

    $scope.h2oCategoryHandlingModes = [
        ["NONE", "Let H2O handle the feature"],
        ["DUMMIFY", "Dummy-encoding (vectorization)"]
    ];

    $scope.dummyClippingModes = [
        ["MAX_NB_CATEGORIES", "Max nb. categories"],
        ["CUMULATIVE_PROPORTION", "Cumulative proportion"],
        ["MIN_SAMPLES", "Minimum samples"],
    ];

    $scope.dummyDrops = [
        ["AUTO", "Let DSS decide"],
        ["NONE", "Don't drop"],
        ["DROP", "Drop one dummy"]
    ];
    $scope.categoryMissingHandlingModes = [
        ["NONE", "Treat as a regular value"],
        ["IMPUTE", "Impute ..."],
        ["DROP_ROW", "Drop rows (don't predict them either)"]
    ];
    $scope.vectorMissingHandlingModes = [
        ["DROP_ROW", "Drop rows (don't predict them either)"],
        ["IMPUTE", "Impute ..."],
        ["NONE", "Fail if missing values found"]
    ];
    $scope.imageMissingHandlingModes = [
        ["DROP_ROW", "Drop rows (don't predict them either)"],
        ["NONE", "Fail if missing values found"]
    ];
    $scope.categoryMissingHandlingImputeWithModes = [
        ["MODE", "Most frequent value"],
        ["CONSTANT", "A constant value"]
    ];
    $scope.vectorMissingHandlingImputeWithModes = [
        ["MODE", "Most frequent value"],
        ["CONSTANT", "A vector filled with a single value"]
    ];

    $scope.numericalHandlingModes = [
        ["REGULAR", "Keep as a regular numerical feature"],
        ["FLAG_PRESENCE", "Replace by 0/1 flag indicating presence"],
        ["BINARIZE", "Binarize based on a threshold"],
        ["QUANTILE_BIN", "Quantize"]
    ];
    $scope.numericalMissingHandlingModes = [
        ["IMPUTE", "Impute ..."],
        ["DROP_ROW", "Drop rows (don't predict them either)"]
    ];
    $scope.numericalMissingHandlingImputeWithModes = [
        ["MEAN", "Average of values"],
        ["MEDIAN", "Median of values"],
        ["CONSTANT", "A constant value"]
    ];

    $scope.textHandlingModes = [
        ["TOKENIZE_HASHING", "Tokenize and hash"],
        ["TOKENIZE_HASHING_SVD", "Tokenize, hash and apply SVD"],
        ["TOKENIZE_COUNTS", "Count vectorization"],
        ["TOKENIZE_TFIDF", "TF/IDF vectorization"]
    ];
    $scope.rescalingModes = [
        ["NONE", "No rescaling"],
        ["MINMAX", "Min-max rescaling"],
        ["AVGSTD", "Standard rescaling"]
    ];
    $scope.binarizeThresholdModes = [
        ["MEAN", "Average of values"],
        ["MEDIAN", "Median of values"],
        ["CONSTANT", "A constant value"]
    ];

    $scope.sendToInputModes = [
        ["MAIN", "Main input"],
        ["OTHER", "Other input"]
    ];

    if($scope.isMLBackendType('PY_MEMORY') || $scope.isMLBackendType('KERAS')){
            $scope.categoryHandlingModes.push(
                    ["HASHING", "Feature hashing (for high cardinality)"],
                    ["CUSTOM", "Custom preprocessing"]
            );
            $scope.numericalHandlingModes.push(["CUSTOM", "Custom preprocessing"]);
            $scope.textHandlingModes.push(["CUSTOM", "Custom preprocessing"])
        if ($scope.mlTasksContext.activeMLTask.taskType === 'PREDICTION') {
            $scope.categoryHandlingModes.push(["IMPACT", "Impact-coding"]);
        }
    }

    function fillInitialCustomHandlingCode(nv, ov){
        if (nv == "CUSTOM" &&
                ($scope.selection.selectedObject.customHandlingCode == null ||
                    $scope.selection.selectedObject.customHandlingCode.length == 0) ) {
            if ($scope.isMLBackendType("KERAS") && $scope.selection.selectedObject.type === "TEXT") {
                $scope.selection.selectedObject.customHandlingCode =
                "from dataiku.doctor.deep_learning.preprocessing import TokenizerProcessor\n\n" +
                "# Defines a processor that tokenizes a text. It computes a vocabulary on all the corpus.\n" + 
                "# Then, each text is converted to a vector representing the sequence of words, where each \n" +
                "# element represents the index of the corresponding word in the vocabulary. The result is \n" + 
                "# padded with 0 up to the `max_len` in order for all the vectors to have the same length.\n\n" +
                "#   num_words  - maximum number of words in the vocabulary\n" +
                "#   max_len    - length of each sequence. If the text is longer,\n" +
                "#                it will be truncated, and if it is shorter, it will be padded\n" +
                "#                with 0.\n" +
                "processor = TokenizerProcessor(num_words=10000, max_len=32)";
            } else if ($scope.selection.selectedObject.type === "CATEGORY" ||  $scope.selection.selectedObject.type === "TEXT") {
                $scope.selection.selectedObject.customHandlingCode =
                    "from sklearn.feature_extraction import text\n\n"+
                    "# Applies count vectorization to the feature\n" +
                    "processor = text.CountVectorizer()\n";

            } else if ($scope.selection.selectedObject.type == "NUMERIC") {
                $scope.selection.selectedObject.customHandlingCode =
                    "from sklearn import preprocessing\nimport numpy as np\n\n"+
                    "# Applies log transformation to the feature\n" +
                    "processor = preprocessing.FunctionTransformer(np.log1p)\n";
                $scope.selection.selectedObject.customProcessorWantsMatrix = true;
            }
            $timeout(function() {
            // Force recomputation of all "remaining-height" directives
            $rootScope.$broadcast('reflow');
        });
        }
    }

    $scope.$watch("selection.selectedObject.category_handling", fillInitialCustomHandlingCode);
    $scope.$watch("selection.selectedObject.text_handling", fillInitialCustomHandlingCode);
    $scope.$watch("selection.selectedObject.numerical_handling", fillInitialCustomHandlingCode);


    $scope.$watch('selection.selectedObject', function(nv, ov) {
        $timeout(function() {
            // Force recomputation of all "remaining-height" directives
            $rootScope.$broadcast('reflow');
        });
        // We wait in order to make sure the layout has been updated
        // (so that the computation of the real remaining height is correct)
        if (nv) {$scope.fixupFeatureConfiguration(nv, ov);}
    }, true);

    $scope.fixupFeatureConfiguration = function(feature, oldFeature) {
        if(feature.role == 'REJECT' || PROTECTED_ROLES.includes(feature.role)) {

            // For KERAS backend, need to check that feature is special in order to 
            // create/delete Special input accordingly when rejecting/accepting a
            // feature
            if ($scope.isMLBackendType('KERAS')) {
                handleSwitchingToSpecialFeature(feature, oldFeature);
            }

            return;
        }
        if (feature.type=='CATEGORY') {
            if (!feature.category_handling) {
                feature.category_handling = "DUMMIFY";
            }
            if (feature.category_handling == "DUMMIFY" && !feature.max_nb_categories) {
                feature.max_nb_categories = 100;
            }
            if (feature.category_handling == "DUMMIFY" && !feature.max_cat_safety) {
                feature.max_cat_safety = 200;
            }
            if (feature.category_handling == "DUMMIFY" && !feature.dummy_drop) {
                feature.dummy_drop = "AUTO";
            }
            if (feature.category_handling == "DUMMIFY" && !feature.cumulative_proportion) {
                feature.cumulative_proportion = 0.95;
            }
            if (feature.category_handling == "DUMMIFY" && !feature.min_samples) {
                feature.min_samples = 10;
            }
            if (feature.category_handling == "DUMMIFY" && !feature.dummy_clip) {
                feature.dummy_clip = "CUMULATIVE_PROPORTION";
            }

            if (feature.category_handling == "HASHING" && !feature.nb_bins_hashing) {
                feature.nb_bins_hashing = 1048576;
            }

            if(feature.missing_handling=='IMPUTE') {
                if (feature.missing_impute_with != "MODE" && feature.missing_impute_with != "CONSTANT") {
                    feature.missing_impute_with = "MODE";
                }
            } else if (!feature.missing_handling) {
                feature.missing_handling = 'IMPUTE';
                feature.missing_impute_with = "MODE";
            }

        } else if (feature.type=='NUMERIC') {
            if (!feature.numerical_handling) {
                feature.numerical_handling = "REGULAR";
                feature.rescaling = "AVGSTD"
            }

            if (feature.missing_handling=='IMPUTE') {
                if (["MEAN", "MEDIAN", "CONSTANT"].indexOf(feature.missing_impute_with) < 0) {
                    feature.missing_impute_with ="MEDIAN";
                }
            } else if (!feature.missing_handling) {
                feature.missing_handling = 'IMPUTE';
                feature.missing_impute_with = 'MEDIAN';
            }

            feature.category_handling = undefined;

        } else if (feature.type == "TEXT") {
            if (!feature.text_handling) {
                feature.text_handling = "TOKENIZE_HASHING_SVD";
            }
            if (!feature.hashSize) {
                feature.hashSize = 200000;
            }
            if (!feature.hashSVDSVDLimit) {
                feature.hashSVDSVDLimit = 50000;
            }
            if (!feature.hashSVDSVDComponents) {
                feature.hashSVDSVDComponents = 100;
            }
            if (!feature.minRowsRatio) {
                feature.minRowsRatio = 0.001;
            }
            if (!feature.maxRowsRatio) {
                feature.maxRowsRatio = 0.8;
            }
            if (!feature.maxWords) {
                feature.maxWords = 0;
            }
            if (!feature.ngramMinSize) {
                feature.ngramMinSize = 1;
            }
            if (!feature.ngramMaxSize) {
                feature.ngramMaxSize = 1;
            }
            if (!feature.stopWordsMode) {
                feature.stopWordsMode = "NONE";
            }
        } else if (feature.type == "VECTOR") {
            if (!feature.vector_handling) {
                feature.vector_handling = "UNFOLD";
            }

            if(feature.missing_handling=='IMPUTE') {
                if (!feature.missing_impute_with) {
                    feature.missing_impute_with = "MODE";
                } else if (feature.missing_impute_with == "CONSTANT" && !feature.impute_constant_value) {
                    feature.impute_constant_value = "0"
                }
            } else if (!feature.missing_handling) {
                feature.missing_handling = "DROP_ROW";
            }
        } else if (feature.type === "IMAGE") {
            if (!feature.image_handling) {
                feature.image_handling = "CUSTOM";
            }

            if (!feature.missing_handling) {
                feature.missing_handling = "DROP_ROW";
            }
        }

        if ($scope.isMLBackendType('KERAS')) {
            handleSwitchingToSpecialFeature(feature, oldFeature);
        }
    };

    var datasetColumns = [];
    DataikuAPI.datasets.get($scope.analysisCoreParams.projectKey, $scope.analysisCoreParams.inputDatasetSmartName, $stateParams.projectKey)
        .success(function(dataset) {
            datasetColumns = dataset.schema.columns.map(Fn.prop('name'));
            addDataSetColumnId();
        }).error(setErrorInScope.bind($scope));
    var addDataSetColumnId = function() {
        if (datasetColumns.length === 0) {
            return;
        }
        angular.forEach($scope.mlTaskDesign.preprocessing.per_feature, function(feature) {
            feature.datasetColumnId = datasetColumns.indexOf(feature._name);
        });
    }
    $scope.$watch('mlTaskDesign.preprocessing.per_feature', addDataSetColumnId);

    $scope.acceptDSSChange = function(feature) {
        Assert.trueish(feature.state.dssWantsToSet, "unexpected call to acceptDSSChange");
        var oldState = feature.state;
        $.each(feature.state.dssWantsToSet, function(k, v){feature[k] = v;});
        feature.state = {
            userModified : false,
            recordedMeaning : oldState.recordedMeaning
        };
    }


    $scope.groupSet = function(newContent) {
        for(let i in $scope.selection.selectedObjects) {
            let feature = $scope.selection.selectedObjects[i];
            if(PROTECTED_ROLES.includes(feature.role)) {
                continue;
            }
            let modified = false;
            for(let k in newContent) {
                if(feature[k]!==newContent[k]) {
                    feature[k]=newContent[k];
                    modified = true;
                }
            }
            if(modified) {
                if (!feature.state) feature.state = {};
                feature.state.userModified = true;
                $scope.fixupFeatureConfiguration(feature);
            }
        }
    };

    $scope.isGroupSetUseful = function(newContent) {
        for(let i in $scope.selection.selectedObjects) {
            let feature = $scope.selection.selectedObjects[i];
            if(PROTECTED_ROLES.includes(feature.role)) {
                continue;
            }
            for(let k in newContent) {
                if(feature[k]!== newContent[k]) {
                    return true;
                }
            }
        }
        return false;
    };

    $scope.groupCheck = function(newContent) {
        return !$scope.isGroupSetUseful(newContent);
    };

    $scope.imputeWithConstant = function() {
        var options = {type: 'text'};
        if ($scope.selection.selectedObjects.some(function(f) { return f.role !== 'TARGET' && f.type === 'NUMERIC'; })) {
            options.type = 'number';    // can only set a numeric constant
        }
        Dialogs.prompt($scope, "Impute with constant " + options.type, "Imputed value", "", options)
            .then(function(value) {
                $scope.groupSet({
                    missing_handling: 'IMPUTE',
                    missing_impute_with: 'CONSTANT',
                    impute_constant_value: options.type === 'number' ? parseFloat(value) : value
                });
            });
    };

    $scope.sendToDeepLearningInput = function() {
        var inputs = $scope.mlTaskDesign.modeling.keras.kerasInputs
                           .filter(function(input) {
                                return !PMLSettings.isSpecialInput(input, $scope.mlTaskDesign.preprocessing.per_feature);
                            }).map(function(input) {
                                return {title: input};
                           });
        Dialogs.select($scope, 'Send to Deep Learning input', 'Please select the input', inputs, inputs[0]).then(function(selectedInput) {
                $scope.selection.selectedObjects.forEach(function(featParams) {
                    if (featParams.role == "TARGET") {
                        return;
                    }
                    if (!PMLSettings.isSpecialFeature(featParams)) {
                        featParams.sendToInput = selectedInput.title;
                    }
                });
            });
    }

    $scope.columnAnalysisCache = {};
    $scope.columnAnalysisIds = function() {
        var acp = $scope.analysisCoreParams;
        return [acp.projectKey, acp.inputDatasetSmartName, acp.script, null];
    };


    // ONLY NEEDED FOR KERAS BACKEND

    // Goal is to detect when change in Feature settings requires to
    // automatically create/delete Deep Learning Input, for example when
    // switching to Text > Custom preprocessing

    function getNewInputName(featureName, currentInputs) {
        var newInputName = featureName + "_preprocessed";

        if (currentInputs.indexOf(newInputName) == -1) {
            return newInputName;
        } else {
            var i = 1;
            while (true) {
                var suffix = "_" + i;
                if (currentInputs.indexOf(newInputName + suffix) == -1) {
                    return newInputName + suffix
                }
                i += 1;
            }
        }
    }

    function handleSwitchingToSpecialFeature(nv, ov) {
        // Only want to catch when the same feature changes and:
        //   - becomes special or is not anymore
        //   - is special and its role changes (rejected or accepted)

        // First verify that this is the same feature
        if (nv == ov || !nv || !ov || nv._name !== ov._name) {
            return;
        }

        const nvSpecial = PMLSettings.isSpecialFeature(nv);
        const ovSpecial = PMLSettings.isSpecialFeature(ov);

        // Then treat switching INPUT/REJECT case
        if (nv.role !== ov.role && nvSpecial && ovSpecial) {

            // Must create new special input if feature was rejected
            if (nv.role === "INPUT" && ov.role === "REJECT") {
                createNewSpecialInputAndAssignToFeature(nv);
            }
            // Must delete special input if feature was rejected
            if (nv.role === "REJECT" && ov.role === "INPUT") {
                deleteSpecialInputAndSendFeatureToMain(nv)
            }

            return;
        }

        // Finally treat case where feature becomes/is not anymore special
        // Discard cases when "specialty" of feature does not change
        if (nvSpecial === ovSpecial ) {
            return;
        }

        if (nvSpecial) {
            // Must create new input for the special feature
            createNewSpecialInputAndAssignToFeature(nv);
        } else {
            // Must delete Input of special feature and put it in main
            deleteSpecialInputAndSendFeatureToMain(nv);
        }
    }

    function createNewSpecialInputAndAssignToFeature(feature) {
        // Must create new input for the special feature
        var newInputName = getNewInputName(feature._name, $scope.mlTaskDesign.modeling.keras.kerasInputs);

        $scope.mlTaskDesign.modeling.keras.kerasInputs.push(newInputName);
        feature.sendToInput = newInputName;
    }

    function deleteSpecialInputAndSendFeatureToMain(feature) {
        // Must delete Input of special feature and put it in main
        var inputTodelete = feature.sendToInput;

        var inputIndex = $scope.mlTaskDesign.modeling.keras.kerasInputs.indexOf(inputTodelete);
        $scope.mlTaskDesign.modeling.keras.kerasInputs.splice(inputIndex, 1);

        feature.sendToInput = "main";
    }

    $scope.isSpecialFeature = function() {
        var featureData = $scope.selection.selectedObject;
        return PMLSettings.isSpecialFeature(featureData);
    };

    $scope.isNotSpecialInputOrIsSpecialSelection = function(input) {
        var featureData = $scope.selection.selectedObject;
        return PMLSettings.isSpecialFeature(featureData) || !PMLSettings.isSpecialInput(input, $scope.mlTaskDesign.preprocessing.per_feature);
    };

    $scope.setSubsampleFit = function() {
        let deferred = $q.defer();
        let newScope = $scope.$new();

        newScope.uiState = {
            preprocessingFitSampleRatio: $scope.mlTaskDesign.preprocessing.preprocessingFitSampleRatio,
            preprocessingFitSampleSeed: $scope.mlTaskDesign.preprocessing.preprocessingFitSampleSeed
        };

        CreateModalFromTemplate("templates/analysis/prediction/set-subsample-fit-modal.html", 
            newScope,
            null,
            function(scope) {

                scope.acceptDeferred = deferred;

                scope.validate = function () {
                    scope.acceptDeferred.resolve(scope.uiState);
                    scope.dismiss();
                };

                scope.showHideMore = function() {
                    scope.uiState.showMore = !scope.uiState.showMore;
                };

        });
        deferred.promise.then(function(data) {
            $scope.mlTaskDesign.preprocessing.preprocessingFitSampleRatio = data.preprocessingFitSampleRatio;
            $scope.mlTaskDesign.preprocessing.preprocessingFitSampleSeed = data.preprocessingFitSampleSeed;
        });
    }

});


})();

(function(){
'use strict';

var app = angular.module('dataiku.analysis.mlcore');


app.directive("modelTrainProgress", function(ProgressStackMessageBuilder, MLDiagnosticsService) {
    return {
        scope : {
            progress : "=",
            gridsearchData: '=',
            trainDiagnostics: '='
        },
        templateUrl : "/templates/analysis/mlcommon/train-progress.html",
        link : function(scope) {
            scope.$watch("trainDiagnostics", () => {
                scope.groupedDiagnostics = MLDiagnosticsService.groupByStepAndType(scope.trainDiagnostics);
            }, true); // diagnostics can be added to the current step or edited
            scope.$watch("progress", () => {
                if (scope.progress && scope.progress.stack) {
                    scope.stackMessage = ProgressStackMessageBuilder.buildFull(scope.progress.stack);
                } else {
                    scope.stackMessage = '';
                }

                scope.allProgress = [];

                scope.progress.top_level_done.forEach(item => {
                    item.type = 'DONE';
                    scope.allProgress.push(item);
                })

                scope.allProgress.push({ type : "CURRENT", message : scope.stackMessage });

                scope.progress.top_level_todo.forEach(item => {
                    scope.allProgress.push({ type : "TODO", str : item });
                });

            }, true);

            scope.displaySearchProgress = (item) => {
                const searchingSteps = [
                    "Hyperparameter searching", // for regular grid search
                    "Fitting global model", // when training in k-fold
                ];
                return searchingSteps.includes(item.message) && scope.gridsearchData && scope.gridsearchData.gridPoints.length;
            };

            scope.displaySearchTimeProgress = (item) => {
                // we display time progress for searches that are bound by timeout, i.e. when gridSize is 0
                return scope.displaySearchProgress(item) && scope.gridsearchData.gridSize === 0;
            }

            scope.getSearchProgress = () => {
                const gsd = scope.gridsearchData;
                if (!gsd) {
                    return "";
                }
                let gridProgress = "(" + gsd.gridPoints.length + "/" + ((gsd.gridSize !== 0) ? gsd.gridSize : "?") + ")";
                return gridProgress;
            };

            scope.getSearchTimeProgress = () => {
                return durationHHMMSS(Math.max(0, (now - parseInt(scope.progress.stack[0].startTimestamp, 10)) / 1000)) + " / " + durationHHMM(scope.gridsearchData.timeout * 60);
            };
        }
    }
});


app.directive("analysisPredictedTableBase", function($q, Assert, DataikuAPI, Logger){
    return {
        scope: true,
        priority: 30,
        controller: function($scope, $stateParams, $state) {
            Logger.info("APTB");
            /* ********************* Callbacks for shakerExploreBase ******************* */

            $scope.shakerHooks.saveForAuto = function(){
                Assert.inScope($scope, "mlTaskDesign");
                var deferred = $q.defer();

                var toSave = angular.copy($scope.mlTaskDesign);
                toSave.predictedScript = $scope.getShakerData();

                var fn = null;
                if ($scope.mlTaskDesign.taskType == "PREDICTION") {
                    fn = DataikuAPI.analysis.pml.saveSettings;
                } else if ($scope.mlTaskDesign.taskType == "CLUSTERING") {
                    fn = DataikuAPI.analysis.cml.saveSettings;
                } else {
                    throw "Unexpected taskType";
                }

                fn($stateParams.projectKey, $stateParams.analysisId, toSave).success(function(data) {
                    // Reset modification detector
                    $scope.originalShaker = toSave.script;
                    $scope.invalidScriptError = {};
                    // TODO @analysis make this common
                    for (var stepIdx in $scope.shaker.steps) {
                        var step = $scope.shaker.steps[stepIdx];
                        var err = $scope.validateStep(step);
                        if (err != null) {
                            $scope.invalidScriptError = { index : stepIdx , type : step.type, message : err };
                            Logger.info("script is invalid, not refreshing");
                            deferred.reject("Script is invalid");
                            return;
                        }
                    }
                    deferred.resolve();
                }).error(setErrorInScope.bind($scope));
                return deferred.promise;
            }

            $scope.loadMLTask = function(){
                Assert.inScope($scope, "shakerState");
                Assert.inScope($scope, "shakerHooks");

                DataikuAPI.analysis.mlcommon.getCurrentSettings($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId).success(function(data){
                    $scope.mlTaskDesign = data;

                    $scope.baseInit();
                    $scope.shaker = data.predictionDisplayScript;
                    $scope.originalShaker = angular.copy($scope.shaker);
                    $scope.fixupShaker();
                    $scope.refreshTable(false);
                }).error(setErrorInScope.bind($scope));
            }
            $scope.shakerReadOnlyActions = true;
            $scope.shakerState.isPredictedDataTable = true;
        }
    }
});


app.directive("analysisPredictedChartsBase", function($q, $timeout, Assert, DataikuAPI, Logger, ActivityIndicator, ChartChangeHandler) {
    return {
        scope: true,
        priority: 30,
        controller: function($scope, $stateParams, $state) {
            /* ********************* Execute Callbacks for chartsCommon ******************* */

            $scope.getExecutePromise = function(request) {
                $scope.saveShaker();
                if(request) {
                    return DataikuAPI.analysis.predicted.chartsGetPivotResponse($stateParams.fullModelId,
                        request,
                        $scope.summary.requiredSampleId);
                }
            };

            $scope.getDefaultNewChart = function() {
                return {
                    def: ChartChangeHandler.defaultNewChart(),
                    maxDataBytes: 150*1024*1024
                };
            };

            $scope.saveShaker = function() {
                // UGLY FIXME
                $scope.shaker.charts = $scope.charts;

                Assert.inScope($scope, "mlTaskDesign");

                var toSave = angular.copy($scope.mlTaskDesign);
                toSave.predictedScript = $scope.shaker;

                var fn = null;
                if ($scope.mlTaskDesign.taskType == "PREDICTION") {
                    fn = DataikuAPI.analysis.pml.saveSettings;
                } else if ($scope.mlTaskDesign.taskType == "CLUSTERING") {
                    fn = DataikuAPI.analysis.cml.saveSettings;
                } else {
                    throw "Unexpected taskType";
                }

                if ($scope.isProjectAnalystRW()){
                    fn($stateParams.projectKey, $stateParams.analysisId, toSave).success(function(data) {
                        ActivityIndicator.success("Charts saved");
                    }).error(setErrorInScope.bind($scope));
                } else {
                    ActivityIndicator.warning("You don't have write access - not saving");
                }
            };

            $scope.saveChart = $scope.saveShaker;

            /* ********************* Load callback ******************* */

            $scope.fetchColumnsSummary = function(){
                return DataikuAPI.analysis.predicted.chartsGetColumnsSummary($stateParams.fullModelId).success(function(data) {
                    $scope.summary = data;
                    $scope.makeUsableColumns(data);
                }).error(setErrorInScope.bind($scope));
            }

            $scope.onSettingsLoaded = function(){
                if ($scope.charts.length === 0) {
                    $scope.addChart();
                }

                Logger.info("Data loaded, get summary");
                $scope.fetchColumnsSummary().then(function(){
                    $scope.$watch("charts[currentChart.index]", function(nv){
                        Logger.info("Chart changed, executing");
                        $scope.forceExecuteChartOrWait();
                    });
                });
            }
        }
    }
});

app.controller("_MLModelBaseController", function($scope, $stateParams, DataikuAPI, TopNav, $state, Dialogs){
    TopNav.setItem(TopNav.ITEM_ANALYSIS, $stateParams.analysisId);

    DataikuAPI.analysis.getCore($stateParams.projectKey, $stateParams.analysisId).success(function(data) {
        $scope.analysisCoreParams = data;
        TopNav.setItem(TopNav.ITEM_ANALYSIS, $stateParams.analysisId, {name : data.name, dataset: data.inputDatasetSmartName});
    }).error(setErrorInScope.bind($scope));

    $scope.$on("$destroy", function(){
        $scope.clearMLTasksContext();
    });

    $scope.deleteTrainedAnalysisModel = function() {
        if ($scope.modelData) {
            Dialogs.confirm($scope,'Model deletion','Are you sure you want to delete this model?').then(function() {
                DataikuAPI.ml.deleteModels([$stateParams.fullModelId]).success(function(data) {
                    $state.go("projects.project.analyses.analysis.ml.list");
                }).error(setErrorInScope.bind($scope));
            });
           
        }
    }

});

app.controller("TrainedModelSkinsController", function($scope, $rootScope, $state, VirtualWebApp) {
    $scope.$watch('uiState.skin', function() {
        VirtualWebApp.changeSkin($scope, 'ANALYSIS', $scope.uiState.skin, $scope.uiState, 'skin-holder',
            $scope.modelData.fullModelId, null, true);
    }, true);
});
})();

(function(){
'use strict';

const app = angular.module('dataiku.analysis.mlcore');

app.directive('featureDescription', function(){
    return {
        scope: { feature: '=' },
        templateUrl: '/templates/analysis/mlcommon/one-feature.html',
        link: function(scope, element, attrs) {
            var params = {
                placement: 'right',
                animation: false,
                container: 'body',
                html: true,
                template: '<div class="tooltip feature-description" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
            };
            element.tooltip(params);
            // Remove other tooltips on hover out
            element.hover(function() { $(this).tooltip('show'); }, function() {
                $('.tooltip').not(element.next()).remove();
            });
            scope.$watch('feature', function() {
                element.attr('data-original-title', element.find('.sub-feature').html());
                element.attr('title', '');
            })
        },
    }
});


app.directive("diagnosticIcon", function() {
    return {
        scope: { size: "@" },
        template:'<svg class="diagnostic-icon-wrapper-{{size}}" xmlns="http://www.w3.org/2000/svg">' +
            '<circle cx="50%" cy="50%" r="{{ size === \'large\' ? 10 : 8}}" class="diagnostic-icon-stethoscope-{{size}}"></circle>' +
            '<text x="50%" y="{{ size === \'large\' ? 70 : 80}}%" class="diagnostic-icon">&#xf0f1;</text></svg>',
    };
});

app.directive("diagnosticsModal", function() {
    return {
        scope: { diagnostics: '=', displayPopup: '=', textContent: "@", popupContent: "@", iconSize: "@" },
        templateUrl: '/templates/ml/diagnostics-modal.html',
        link: ($scope, element, attrs) => {
            $scope.maxLength = attrs.maxLength || 120; // Number of characters per message
            $scope.iconPlacement = attrs.iconPlacement || "left"; // Number of characters per message
            $scope.maxDiagnostics = attrs.maxDiagnostics || 5; // Number of diagnostics to display in the popup

            const firstNDiagnostics = (firstN) => {
                if (!$scope.diagnostics) {
                    return null;
                }

                const diagnostics = {};
                let total = 0;
                for (const diagnostic of $scope.diagnostics) {
                    if (attrs.state && attrs.state !== diagnostic.step) { // Skip if only display for a single state
                        continue;
                    }

                    diagnostics[diagnostic.displayableType] = diagnostics[diagnostic.displayableType] || [];
                    diagnostics[diagnostic.displayableType].push(diagnostic.message);
                    total++;

                    if (total >= firstN) { // Reached max numbers of diagnostics to display
                        return diagnostics;
                    }
                }
                return diagnostics;
            }

            $scope.$watch("diagnostics", () => {
                $scope.filteredDiagnostics = firstNDiagnostics($scope.maxDiagnostics);
            }, true);
        }
    };
});

app.controller('EnsembleModalController', function($scope){
    $scope.params = {};
    $scope.getMethod = function(){ return $scope.params.method; };
});


app.controller("_MLTaskDesignController", function($scope, $controller, $state, $stateParams, $rootScope, TopNav, Fn,
    Dialogs, DataikuAPI, MLTasksNavService, CreateModalFromTemplate, Collections, $timeout, CodeMirrorSettingService,
    PMLSettings, WT1, $q, MLDiagnosticsDefinition) {

    DataikuAPI.analysis.listHeads($stateParams.projectKey).success(function(data) {
        $scope.analyses = data;
    });

    MLDiagnosticsDefinition.fetch(data => { $scope.diagnosticsDefinition = data; });

    $scope.backendTypeNames = {
        "PY_MEMORY": "Python in-memory",
        "MLLIB": "MLLib",
        "H20": "H20",
        "VERTICA": "Vertica",
        "KERAS": "Keras"
    };

    $scope.displayTypes = {
        CLUSTERING: "Clustering",
        BINARY_CLASSIFICATION: "Classification",
        MULTICLASS: "Classification",
        REGRESSION: "Regression"
    };

    $scope.getCustomAlgorithm = function(custom_id) {
        if (custom_id.startsWith('custom_python_')) {
            return $scope.mlTaskDesign.modeling.custom_python[custom_id.slice(14)];
        } else if (custom_id.startsWith('custom_mllib_')) {
            return $scope.mlTaskDesign.modeling.custom_mllib[custom_id.slice(13)];
        }
    };

    $scope.isPluginAlgorithm = function(alg) {
        return alg.algKey.startsWith("CustomPyPredAlgo_");
    }

    $scope.getPluginAlgorithmSettings = function(pluginModelId) {
        return $scope.mlTaskDesign.modeling.plugin_python[pluginModelId] || {};
    };

    $scope.getPluginAlgorithm = function(algKey) {
        return $scope.algorithms["PY_MEMORY"].find(alg => alg.algKey === algKey);
    }

    $scope.getAlgorithmModeling = function(algKey) {
        const alg = Collections.indexByField($scope.algorithms[$scope.mlTaskDesign.backendType], 'algKey')[algKey];
        if (!alg) {
            throw new Error("Algorithm not found: " + algKey);
        } else if (alg.isCustom) {
            return $scope.getCustomAlgorithm(algKey);
        } else if ($scope.isPluginAlgorithm(alg)) {
            return $scope.getPluginAlgorithmSettings(alg.algKey);
        } else {
            return $scope.mlTaskDesign.modeling[alg.paramsName || algKey];
        }
    };

    $scope.isMLBackendType = function(mlBackendType){
        // mlTasksContext is initialized much faster than mlTaskDesign
        if (!$scope.mlTasksContext || !$scope.mlTasksContext.activeMLTask) return false; // might not be initialized
        return $scope.mlTasksContext.activeMLTask.backendType == mlBackendType;
    };

    $scope.isBayesianSearchWithSkopt = function() {
        if (!$scope.mlTaskDesign 
            || !$scope.mlTaskDesign.modeling
            || !$scope.mlTaskDesign.modeling.gridSearchParams) {
            return false;
        }
        const gridSearchParams = $scope.mlTaskDesign.modeling.gridSearchParams;
        return (gridSearchParams.strategy === "BAYESIAN" && gridSearchParams.bayesianOptimizer === "SCIKIT_OPTIMIZE");
    }

    $scope.isSparkBased = function(){
        return $scope.mlTaskDesign.backendType == 'MLLIB' || $scope.mlTaskDesign.backendType == 'H2O';
    };

    $scope.removeCustomAlgorithm = function(custom_id) {
        var idx;
        if (custom_id.startsWith('custom_python_')) {
            idx = parseInt(custom_id.slice(14));
            $scope.mlTaskDesign.modeling.custom_python.splice(idx, 1);
        } else if (custom_id.startsWith('custom_mllib_')) {
            idx = parseInt(custom_id.slice(13));
            $scope.mlTaskDesign.modeling.custom_mllib.splice(idx, 1);
        }
        var algs = $scope.algorithms[$scope.mlTaskDesign.backendType]
            .filter(function(o){return (!o.condition||o.condition())});
        var balgs = $scope.base_algorithms[$scope.mlTaskDesign.backendType]
            .filter(function(o){return (!o.condition||o.condition())});
        $scope.uiState.algorithm = algs[balgs.length+idx-1].algKey;
    };

    function updateCustomAlgorithms(nv) {
        if (!nv) { return }
        $scope.algorithms = angular.copy($scope.base_algorithms);
        if (!$scope.mlTaskDesign) {return}
        
        if ($scope.isMLBackendType("MLLIB")) {
            $scope.editorOptionsCustom = CodeMirrorSettingService.get("text/x-scala");
        } else {
            $scope.editorOptionsCustom = CodeMirrorSettingService.get("text/x-python");
        }
        
        var i;
        for (i=0;i<$scope.mlTaskDesign.modeling.custom_python.length;i++) {
            $scope.algorithms.PY_MEMORY.push({
                name: $scope.mlTaskDesign.modeling.custom_python[i].name || "Custom python model",
                algKey: 'custom_python_' + i,
                isCustom: true,
            });
        }
        for (i=0;i<$scope.mlTaskDesign.modeling.custom_mllib.length;i++) {
            $scope.algorithms.MLLIB.push({
                name: $scope.mlTaskDesign.modeling.custom_mllib[i].name || "Custom mllib model",
                algKey: 'custom_mllib_' + i,
                isCustom: true,
            })
        }
    }

    $scope.getAlgorithmSettings = function(alg) {
        if (alg.isCustom) {
            return $scope.getCustomAlgorithm(alg.algKey)
        } else if (alg.algKey.startsWith("CustomPyPredAlgo_")) {
            return $scope.getPluginAlgorithmSettings(alg.algKey);
        } else {
            return $scope.mlTaskDesign.modeling[alg.paramsName || alg.algKey];
        }
    };

    $scope.retrieveCodeEnvsInfo = function() {
        if ($scope.appConfig.isAutomation) {
            return;
        }
        // On Design node, listing all available envs for this MLtask, along with compatibility to run ML, for 
        // further use:
        // * in "Hypeparamaters" tab for prediction and bayesian search to make sure a proper env is used
        // * in "Runtime environment" to make sure a proper env is used
        if ($scope.isMLBackendType("PY_MEMORY") || $scope.isMLBackendType("KERAS")) {
            DataikuAPI.codeenvs.listWithVisualMlPackages($stateParams.projectKey).success(function(data) {
                $scope.codeEnvsCompat = data;
            }).error(setErrorInScope.bind($scope));
        }
    };

    $scope.copyFeaturesHandling = function(exportSettings) {
        if ($scope.dirtySettings()) {
            $scope.saveSettings();
        }
        DataikuAPI.projects.listHeads(exportSettings ? 'WRITE_CONF' : null).success(function(projectData) {
            CreateModalFromTemplate("/templates/analysis/mlcommon/settings/copy-settings.html", $scope, null, function(newScope) {
                newScope.title = "Copy features handling " + (exportSettings ? "to" : "from");
                newScope.totem = "icon-" + (exportSettings ? "copy" : "paste");
                newScope.infoMessages = ["Features handling will be copied based on their names"];
                if ($scope.mlTaskDesign.taskType === "PREDICTION") {
                    newScope.infoMessages.push("Pasting features handling on the "
                                               + (exportSettings ? "selected " : "current ")
                                               + "model will not change the role of its target variable "
                                               + ($scope.isSampleWeightEnabled() ? " nor of its sample weight " : ""));
                }
                newScope.projects = projectData;
                newScope.selectProject = function() {
                    DataikuAPI.analysis.listHeads(newScope.selectedProjectKey).success(function(analysisData) {
                        newScope.analyses = analysisData;
                        newScope.selectedAnalysisId = undefined;
                        newScope.selectedTask = undefined;
                    }).error(setErrorInScope.bind($scope));
                };
                newScope.selectAnalysis = function () {
                    DataikuAPI.analysis.listMLTasks(newScope.selectedProjectKey, newScope.selectedAnalysisId)
                    .success(function(taskData) {
                        newScope.tasks = taskData;
                        newScope.descriptions = [];
                        newScope.tasks.forEach(task => {
                            // task can be selected if it is not the current one
                            task.isNotSelectable = task.mlTaskId === $stateParams.mlTaskId
                                            && newScope.selectedAnalysisId === $stateParams.analysisId
                                            && newScope.selectedProjectKey === $stateParams.projectKey;
                            newScope.descriptions.push($scope.displayTypes[task.predictionType || task.taskType] + " ("
                            + ($scope.backendTypeNames[task.backendType] || $scope.mlTaskDesign.backendType)
                            + ")");
                        });
                        newScope.selectedTask = undefined;
                    }).error(setErrorInScope.bind($scope));
                };
                if (newScope.projects.some(_ => _.projectKey === $stateParams.projectKey)) {
                    newScope.selectedProjectKey = $stateParams.projectKey;
                    newScope.analyses = $scope.analyses;
                    newScope.selectedAnalysisId = $stateParams.analysisId;
                    newScope.selectAnalysis();
                }
                newScope.confirm = function() {
                    if (exportSettings) {
                        DataikuAPI.analysis.mlcommon.copyFeatureSettings($stateParams.projectKey, $stateParams.analysisId,
                            $stateParams.mlTaskId, newScope.selectedProjectKey, newScope.selectedAnalysisId,
                            newScope.selectedTask.mlTaskId).error(setErrorInScope.bind($scope));
                    } else {
                        DataikuAPI.analysis.mlcommon.copyFeatureSettings(newScope.selectedProjectKey, newScope.selectedAnalysisId,
                            newScope.selectedTask.mlTaskId, $stateParams.projectKey, $stateParams.analysisId,
                            $stateParams.mlTaskId).success(function(data) {
                                // Keep existing order of features
                                for (let featureName in $scope.mlTaskDesign.preprocessing.per_feature) {
                                    Object.assign($scope.mlTaskDesign.preprocessing.per_feature[featureName], data.preprocessing.per_feature[featureName]);
                                }
                            }).error(setErrorInScope.bind($scope));
                    }
                    WT1.event("mltask-copy-features-handling", {
                        export: exportSettings,
                        sameProject: $stateParams.projectKey === newScope.selectedProjectKey,
                        sameAnalysis: $stateParams.analysisId === newScope.selectedAnalysisId,
                        typeDest: newScope.selectedTask.taskType === "CLUSTERING" ? "CLUSTERING" : newScope.selectedTask.predictionType,
                        typeSrc: $scope.mlTaskDesign.taskType === "CLUSTERING" ? "CLUSTERING" : $scope.mlTaskDesign.predictionType
                    });
                    newScope.dismiss();
                };
                newScope.cancel = function() {
                    newScope.dismiss();
                };
            });
        }).error(setErrorInScope.bind($scope));
    };


    $scope.$watch('mlTaskDesign.modeling.custom_python', updateCustomAlgorithms, true);
    $scope.$watch('mlTaskDesign.modeling.custom_mllib', updateCustomAlgorithms, true);

    $scope.displayWeightWarning = function(algKey) {
        return $scope.isSampleWeightEnabled() && $scope.algosWithoutWeightSupport.has(algKey);
    };

});



/**
 * Injected into all controllers that display a single ML task.
 * It handles:
 *   - the global nav handle to switch between ML tasks
 *   - setting the top nav
 */
app.controller("_MLTaskBaseController", function($scope, $state, Collections, DataikuAPI, TopNav, $stateParams,
    $location, CreateModalFromTemplate, Dialogs, ActivityIndicator, Fn, $q, Throttle, MLTasksNavService, $rootScope,
    algorithmsPalette, DatasetUtils, WT1, PartitionedModelsService){
    TopNav.setLocation(TopNav.TOP_ANALYSES, null, TopNav.TABS_ANALYSIS, "models");
    TopNav.setItem(TopNav.ITEM_ANALYSIS, $stateParams.analysisId);

    $scope.selection = {
        partialProperty: 'sessionId'
    };
    $scope.sessionInfo = {};
    $scope.hooks = {};
    $scope.uiState = {
        currentMetric: ''
    };

    $scope.uiState.settingsPane = $location.hash().split('.')[0] || 'learning';
    $scope.uiState.viewMode = $location.hash().split('.')[1] || 'sessions';
    if ($location.hash() === '') {
        $location.hash($scope.uiState.settingsPane + '.' + $scope.uiState.viewMode).replace();
    }

    $scope.$watch("uiState", function(nv, ov) {
        if (nv && ov && (nv.settingsPane !== ov.settingsPane || nv.viewMode !== ov.viewMode)) {
            $location.hash(nv.settingsPane + '.' + nv.viewMode);
        }
    }, true);
    $scope.$on("$locationChangeSuccess", function(angularEvent, newUrl, oldUrl){
         // Do not update uiState if we leave the page: newUrl != current ($state.href("."))
         // Otherwise the uiState update will trigger the watch above and modify the new $location.hash()
        if (!newUrl.includes($state.href("."))) {
            return;
        }

        const newHash = newUrl.split("#")[1];
        if (newHash) {
            $scope.uiState.settingsPane = newHash.split('.')[0] || 'learning';
            $scope.uiState.viewMode = newHash.split('.')[1] || 'sessions';
        }
    })

    $scope.listMLTasks = function() {
        return DataikuAPI.analysis.listMLTasks($stateParams.projectKey, $stateParams.analysisId).success(function(data){
            $scope.mlTasksContext.type = "mltasks";
            $scope.mlTasksContext.analysisMLTasks = data;
            $scope.mlTasksContext.activeMLTask = null;
            for (var i in data) {
                if (data[i].mlTaskId == $stateParams.mlTaskId) {
                    $scope.mlTasksContext.activeMLTask = data[i];
                }
            }
        }).error(setErrorInScope.bind($scope));
    }

    $scope.createNewMLTask = function() {
        CreateModalFromTemplate("/templates/analysis/new-mltask-modal.html", $scope, "AnalysisNewMLTaskController");
    };

    $scope.renameMLTask = function() {
        DataikuAPI.analysis.mlcommon.getCurrentSettings($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId)
        .success(function(mlTaskDesign){
            Dialogs.prompt($scope, "Rename modeling task", "Rename modeling task", mlTaskDesign.name).then(function(newName) {
                var fn;
                if (mlTaskDesign.taskType == "PREDICTION") {
                    fn = DataikuAPI.analysis.pml.saveSettings;
                } else if (mlTaskDesign.taskType == "CLUSTERING") {
                    fn = DataikuAPI.analysis.cml.saveSettings;
                } else {
                    throw "Unknown mlTaskDesign Type"
                }
                mlTaskDesign.name = newName;
                fn($stateParams.projectKey, $stateParams.analysisId, mlTaskDesign).success(function(data){
                    $state.go("projects.project.analyses.analysis.ml.list");
                });
            });
        }).error(setErrorInScope.bind($scope));
    };

    $scope.deleteMLTask = function() {
        Dialogs.confirm($scope, "Delete modeling task", "Do you want to delete this modeling task ?").then(function(data){
            DataikuAPI.analysis.mlcommon.deleteMLTask($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId).success(function(data) {
                $state.go("projects.project.analyses.analysis.ml.list");
            }).error(setErrorInScope.bind($scope));
        });
    };

    $scope.duplicateMLTask = function() {
        const DEFAULT_ANALYSIS = {id: "new", name: "Create a new analysis…"};
        if ($scope.dirtySettings()) {
            $scope.saveSettings();
        }
        DataikuAPI.projects.listHeads('WRITE_CONF').success(function(writableProjects) {
            if (writableProjects.length == 0) {
                Dialogs.error($scope, "No writable project", "You don't have write access to any project, can't duplicate model.");
                return;
            }
            const currentProjectWritable = writableProjects.some(_ => _.projectKey === $stateParams.projectKey);
            CreateModalFromTemplate("/templates/analysis/mlcommon/duplicate-mltask.html", $scope, null, function(newScope) {
                newScope.totem = "icon-machine_learning_" +
                                ($scope.mlTaskDesign.taskType === "CLUSTERING" ? "clustering" : "regression");
                newScope.projects = writableProjects;
                newScope.selectedProject = currentProjectWritable ? $stateParams.projectKey : writableProjects[0].projectKey;

                newScope.$watch('selectedProject', function(project) {
                    if (!project) return;
                    DatasetUtils.listDatasetsUsabilityForAny(project).success(function(datasets) {
                        newScope.availableDatasets = datasets;
                        newScope.selectedDataset = project == $stateParams.projectKey ?
                                $scope.analysisCoreParams.inputDatasetSmartName : undefined;
                    }).error(setErrorInScope.bind(newScope));
                });
                newScope.$watch('selectedDataset', function(dataset) {
                    newScope.analyses = undefined;
                    if (!dataset) return;
                    const selectedDataset = newScope.availableDatasets.find(_ => _.smartName === dataset);

                    // Use selectedProject instead of contextProject because we do not need to check exposed objects
                    DataikuAPI.datasets.get(newScope.selectedProject, selectedDataset.name, newScope.selectedProject)
                        .then(({data}) => newScope.columnNames = data.schema.columns.map(_ => _.name))
                        .then(() => DataikuAPI.analysis.listOnDataset(newScope.selectedProject, dataset))
                        .then(({data}) => {
                            const analyses = data;
                            analyses.unshift(Object.assign({newName: "Analyze " + newScope.selectedDataset}, DEFAULT_ANALYSIS));
                            newScope.analyses = analyses;
                            newScope.selectedAnalysis = analyses[0];
                            if (newScope.selectedProject == $stateParams.projectKey
                                    && newScope.selectedDataset == $scope.analysisCoreParams.inputDatasetSmartName) {
                                newScope.selectedAnalysis = analyses.find(_ => _.id === $scope.analysisCoreParams.id);
                            }
                        })
                        .catch(setErrorInScope.bind(newScope));
                });

                // checks whether the target is in the feature columns of the dataset or not;
                // if not, a dropdown is displayed with the actual features so the user can pick a new target
                // the check is only done if the selected analysis has no step or is new,
                // else the target could have been created by the script => checked in backend
                function checkDatasetContainsTarget() {
                    newScope.features = {};
                    if ($scope.mlTaskDesign.taskType == "CLUSTERING"
                            || ! newScope.selectedAnalysis
                            || newScope.selectedAnalysis.id === $stateParams.analysisId) {
                        return;
                    }
                    if (newScope.selectedAnalysis.id == "new" || newScope.selectedAnalysis.nbSteps === 0) {
                        if (! newScope.columnNames.includes($scope.mlTaskDesign.targetVariable)) {
                            newScope.features.available = newScope.columnNames;
                        }
                    }
                }
                newScope.$watch('selectedAnalysis', checkDatasetContainsTarget);

                function duplicate() {
                    if ($scope.mlTaskDesign.taskType == "PREDICTION") {
                        DataikuAPI.analysis.pml.duplicate(
                            $stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId,
                            newScope.selectedProject, newScope.selectedAnalysis.id, newScope.features.selected
                        ).success(function(result) {
                            if (result.success) {
                                $state.go("projects.project.analyses.analysis.ml.predmltask.list.design", {
                                    projectKey: newScope.selectedProject,
                                    analysisId: newScope.selectedAnalysis.id,
                                    mlTaskId: result.newMlTaskId.id
                                });
                            } else {
                                newScope.features.available = result.possibleTargets;
                            }
                        }).error(setErrorInScope.bind(newScope));
                    } else {
                        DataikuAPI.analysis.cml.duplicate($stateParams.projectKey, $stateParams.analysisId,
                            $stateParams.mlTaskId, newScope.selectedProject, newScope.selectedAnalysis.id
                        ).success(function(data) {
                                $state.go("projects.project.analyses.analysis.ml.clustmltask.list.design", {
                                    projectKey: newScope.selectedProject,
                                    analysisId: newScope.selectedAnalysis.id,
                                    mlTaskId: data.id
                                });
                        }).error(setErrorInScope.bind(newScope));
                    }
                }

                newScope.confirm = function () {
                    if (newScope.selectedAnalysis.id == "new") {
                        DataikuAPI.analysis.create(newScope.selectedProject, newScope.selectedDataset,
                            newScope.selectedAnalysis.newName).success(function (data) {
                                newScope.selectedAnalysis.id = data.id;
                                duplicate();
                        }).error(setErrorInScope.bind(newScope));
                    } else {
                        duplicate();
                    }

                    WT1.event("mltask-duplicate", {
                        sameProject: $stateParams.projectKey == newScope.selectedProject,
                        sameDataset: $scope.analysisCoreParams.inputDatasetSmartName == newScope.selectedDataset,
                        sameAnalysis: $stateParams.analysisId == newScope.selectedAnalysis.id,
                        taskType: $scope.mlTaskDesign.taskType == "CLUSTERING" ? "CLUSTERING" : $scope.mlTaskDesign.predictionType,
                    });
                };
            });
        }).error(setErrorInScope.bind($scope));
    };

    $scope.mlTaskFeatures = function(features, roles) {
        if (!features) {return 0}
        return $.map(features, function(v,k){
            v._name = k;
            return v;
        }).filter(function(f){
            return roles.indexOf(f.role) !== -1;
        });
    }

    $scope.getEnabledModels = function(models) {
        var enabledModels = [];
        for (var name in models) {
            if (name === 'custom_mllib' || name === 'custom_python') {
                const enabledCustomModels = models[name].filter(m => m.enabled);
                enabledModels = enabledModels.concat(enabledCustomModels);
            } else if (name.startsWith("plugin_python")) {
                const enabledPluginModels = Object.values(models[name]).filter(m => m.enabled);
                enabledModels = enabledModels.concat(enabledPluginModels);
            } else if (models[name].enabled) {
                enabledModels.push(models[name]);
            }
        }
        return enabledModels;
    };

    $scope.dirtySettings = function() {
        return !angular.equals($scope.savedSettings, dkuDeepCopy($scope.mlTaskDesign, $scope.SettingsService.noDollarKey));
    };

    $scope.setMlTaskDesign = function(mlTaskDesign) {
        $scope.mlTaskDesign = mlTaskDesign;
    };

    $scope.beforeUpdateSettingsCallback = function(settings) {
        // Do nothing. Will be overriden in PMLTaskBaseController
    }

    $scope.updateSettings = function(settings) {
        $scope.beforeUpdateSettingsCallback(settings);
        $scope.setMlTaskDesign(settings);
        $scope.saveSettings();
    }

    $scope.removeTaskStatus = function() {
        $scope.mlTaskStatus = null;
    }

    $scope.trainDirectly = function() {
        $scope.touchMlTask();
        // Remove the mltaskstatus to prevent the fugitive "no model trained"
        $scope.mlTaskStatus = null;
        $scope.MLAPI.trainStart($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId)
            .success(function(){
                $scope.initialRefreshAndAutoRefresh();
            }).error(setErrorInScope.bind($scope));
    };

    function updateSessionModels(){
        if ($scope.selection && $scope.selection.allObjects && $scope.sessionTask && $scope.sessionTask.sessionId) {
            $scope.selection.sessionModels = $scope.selection.allObjects.filter(function(x){
                return x.sessionId == $scope.sessionTask.sessionId;
            });
        }
    }

    $scope.$watch("selection.allObjects", updateSessionModels, true);
    $scope.$watch("sessionTask", updateSessionModels, true);

    $scope.abortTraining = function(){
        CreateModalFromTemplate("/templates/analysis/mlcommon/abort-train-modal.html", $scope, null, function(newScope) {
            newScope.confirm = function() {
                var toAbort = $scope.selection.allObjects
                .filter(function(o){ return o.trainInfo.state === 'PENDING' || o.trainInfo.state === 'RUNNING' });
                DataikuAPI.analysis.mlcommon
                    .trainAbort($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId)
                    .success(function(){
                        ActivityIndicator.success("Abort requested");
                        toAbort.map(function(o){ o.trainInfo.$userRequestedState = "ABORTED" });
                        refreshStatusAndModelSnippets();
                    }).error(setErrorInScope.bind($scope));
                newScope.dismiss();
            }
            newScope.finalize = function() {
                var toAbort = $scope.selection.allObjects
                .filter(function(o){return o.trainInfo.state === 'RUNNING' || o.trainInfo.state === 'PENDING'});
                DataikuAPI.analysis.mlcommon.stopGridSearchSession($scope.analysisCoreParams.projectKey,
                $scope.analysisCoreParams.id, $scope.sessionTask.id, $scope.sessionTask.sessionId)
                    .success(function(data){
                        toAbort.map(function(o){ o.trainInfo.$userRequestedState = "FINALIZE" });
                        $scope.refreshStatus();
                    }).error(setErrorInScope.bind($scope));
                newScope.dismiss();
            }
        });
    };

    // init & refresh

    // Refreshing mltaskStatus (general refresh)

    $scope.selectRunningOrFirstSession = function() {
        if ($scope.mlTaskStatus.fullModelIds.length > 0) {
            var sids = $scope.mlTaskStatus.fullModelIds.filter(function(o){ return o.training });
            if (sids.length === 0) { sids = $scope.mlTaskStatus.fullModelIds }
            sids = sids.map(Fn.propStr('fullModelId.sessionId'))
               .map(function(sid){ return parseInt(sid.slice(1)) }).sort(function(a,b){ return b-a });
            $scope.getSessionTaskIfChanged("s" + sids[0], true);
        }
    }

    $scope.refreshStatus = function() {
        return $scope.MLAPI.getTaskStatus($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId)
            .success(function(data){
                $scope.mlTaskStatus = data;
            })
            .error(setErrorInScope.bind($scope));
    };

    const refreshStatusAndModelSnippets = function(){
         $scope.refreshStatus().then(function(){
                    $scope.getModelSnippets($scope.mlTaskStatus.fullModelIds
                        .filter(function(o){ return o.training })
                        .map(function(o){ return o.id }));
                    if (!$scope.mlTaskStatus.training && !$scope.mlTaskStatus.guessing && $scope.modelSnippets) {
                        // last call, refresh remaining models
                        $scope.getModelSnippets(Object.values($scope.modelSnippets)
                            .filter(function(o){ return o.trainInfo.state === 'RUNNING' || o.trainInfo.state === 'PENDING' })
                            .map(Fn.prop('fullModelId')));
                    }
                });
    }

    $scope.initialRefreshAndAutoRefresh = function() {
        var deferred = $q.defer(),
            refreshStartDate = new Date(),
            refreshFirstDelay = 1000,
            refreshLastDelay = 15 * 1000,
            refreshGrowLength = 120 * 1000,
            throttle = Throttle().withScope($scope).withDelay(refreshFirstDelay);
        var autoRefresh = throttle.wrap(function() {
            if ($scope.mlTaskStatus.training || $scope.mlTaskStatus.guessing) {
                refreshStatusAndModelSnippets();

                // Delay progressively grows from refreshFirstDelay to refreshLastDelay over time (refreshGrowLength)
                // Scaling of the delay is to the power of 2, until we reach refreshLastDelay
                var newDelay = refreshFirstDelay + Math.round( (refreshLastDelay-refreshFirstDelay)
                    * Math.min((new Date() - refreshStartDate) / refreshGrowLength)**2, 1);
                throttle.withDelay(newDelay);
                autoRefresh();
            }
        });
        $scope.refreshStatus().then(function() {
            $scope.selectRunningOrFirstSession();
            $scope.refreshStatus().then(function(){
                deferred.resolve();
                $scope.getModelSnippets($scope.mlTaskStatus.fullModelIds
                    .filter(function(o){ return o.training || !($scope.modelSnippets && o.id in $scope.modelSnippets)})
                    .map(function(o){ return o.id }));
            }, function() {
                deferred.reject();
            });
            autoRefresh();
        });
        return deferred.promise;
    };

    // Refreshing sessionTasks (task info)

    $scope.$watch('mlTaskStatus.guessing', function(nv){
        if (nv === false) {
            $scope.initMlTaskDesign();
        }
    });

    $scope.getSessionTask = function(sessionId) {
        return $scope.MLAPI.getSessionTask($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId, sessionId)
            .then((response) => {
                return response.data;
            }, setErrorInScope.bind($scope));
    };

    $scope.getPretrainEquivalentMLTask = function(fullModelId, usePostTrain){
        return $scope.MLAPI.getPretrainEquivalentMLTask(fullModelId, usePostTrain)
            .then((response) => {
                return response.data;
            }, setErrorInScope.bind($scope));
    };

    $scope.setPossibleMetrics = function() {
        $scope.possibleMetrics = $scope.FilteringService.getPossibleMetrics($scope.mlTaskStatus.headSessionTask);
        if ($scope.mlTaskStatus.headSessionTask.modeling && !$scope.uiState.currentMetric) {
            $scope.uiState.currentMetric = $scope.mlTaskStatus.headSessionTask.modeling.metrics
                ? $scope.mlTaskStatus.headSessionTask.modeling.metrics.evaluationMetric
                : $scope.possibleMetrics[0][0];
        }
        $scope.possibleMetricsHooks = $scope.possibleMetrics.map((m) => m[0]);
    }

    var sessions = {};
    $scope.getSessionTaskIfChanged = function(newSessionId, dropCache) {
        if (!newSessionId || (!dropCache && $scope.sessionTask && $scope.sessionTask.sessionId === newSessionId)) { return }
        if (!dropCache && sessions[newSessionId]) { $scope.sessionTask = sessions[newSessionId] ; return }
        $scope.getSessionTask(newSessionId).then(function(sessionTask) {
            $scope.sessionTask = sessionTask;
            $scope.sessionTask.sessionId = newSessionId;
            $scope.setPossibleMetrics();
            sessions[newSessionId] = $scope.sessionTask;
        });
    }

    // Refreshing snippets

    $scope.setContainerUsageMetrics = function () {
        if (!$scope.mlTaskStatus || !$scope.modelSnippets || !$scope.mlTaskDesign || !$scope.mlTaskDesign.modeling || !$scope.mlTaskDesign.modeling.gridSearchParams || !$scope.mlTaskDesign.modeling.gridSearchParams.distributed) {
            return;
        }
        angular.forEach($scope.modelSnippets, function (snippet) {
            snippet.maxKubernetesContainers = $scope.mlTaskDesign.modeling.gridSearchParams.nContainers;
            if (snippet.partitionedModelEnabled) {
                snippet.maxKubernetesContainers *= PartitionedModelsService.getPartitionsSnippetStateSize(snippet, 'RUNNING');
            }
            snippet.containerUsageMetrics = $scope.mlTaskStatus.fullModelIds.filter((_) => _.id === snippet.fullModelId)[0].containerUsageMetrics;
        });
    };

    $scope.setAlgorithmColors = function() {
        if (!($scope.mlTasksContext.activeMLTask.backendType in $scope.base_algorithms)){
            return;
        }

        var algList = $scope.base_algorithms[$scope.mlTasksContext.activeMLTask.backendType].filter(function(o){return !o.condition||o.condition()});
        var algKeyList = algList.map(Fn.prop('algKey'))
        var offset = 1;
        angular.forEach($scope.modelSnippets, function(snippet, k){
            var idx = algKeyList.indexOf(snippet.algorithm.toLowerCase());

            if (idx === -1) {
                idx = algKeyList.length + offset;
                offset++;
            }
            snippet.color = algorithmsPalette(idx);
            snippet.algorithmOrder = idx;
        });
    }

    $scope.setMainMetric = function() {
        if ( !$scope.mlTaskStatus || !$scope.modelSnippets || !$scope.mlTaskDesign || !$scope.mlTaskDesign.modeling) { return }
        $scope.FilteringService.setMainMetric(Object.values($scope.modelSnippets),
            [],
            $scope.uiState.currentMetric,
            $scope.mlTaskDesign.modeling.metrics.customEvaluationMetricGIB);
    }

    $scope.libMetric = function(metric) {
        return $scope.SettingsService.sort.lowerIsBetter(metric, $scope.sessionTask.modeling.metrics.customEvaluationMetricGIB);
    }

    $scope.setMetricScales = function() {
        if ($scope.sessionTask&&$scope.sessionTask.modeling) {
            $scope.metricScales = {}
            $scope.possibleMetrics.map(Fn.prop(0)).forEach(function(metric) {
                var metrics = Object.values($scope.modelSnippets).map(Fn.prop(this.metricMap[metric])),
                    rev = $scope.libMetric(metric),
                    min = d3.min(metrics), max = d3.max(metrics);
                $scope.metricScales[metric] = min === max ? Fn.cst('grey') :
                    d3.scale.linear().range(['red', 'orange', 'green'])
                        .domain([rev ? max : min, (max + min) / 2, rev ? min : max]);
            }, $scope.FilteringService);
        }
    }

    $scope.getModelSnippets = function(fullModelIds, getAll) { // getAll calls getModelSnippets with an empty list -> long call
        if (!$scope.modelSnippets) { $scope.modelSnippets = {} }
        if (!getAll && fullModelIds.length==0) { return }
        return $scope.MLAPI.getModelSnippets($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId, fullModelIds, getAll).then(function(response){
            angular.forEach(response.data, function(model, fmi) {
                $scope.modelSnippets[fmi] = Collections.updateNoDereference($scope.modelSnippets[fmi], model);
            });
            $scope.setMetricScales();
            $scope.setAlgorithmColors();
            $scope.setMainMetric();
            $scope.setContainerUsageMetrics();
        });
    }

    // init

    $scope.compareFMIs = function(b,a) {
        var af = a.fullModelId, bf = b.fullModelId;
        if (af.sessionId !== bf.sessionId) return parseInt(af.sessionId.slice(1)) - parseInt(bf.sessionId.slice(1));
        if (af.preprocessingId !== bf.preprocessingId) return parseInt(af.preprocessingId.slice(2)) - parseInt(bf.preprocessingId.slice(2));
        return parseInt(af.modelId.slice(1)) - parseInt(bf.modelId.slice(1));
    }

    DataikuAPI.analysis.getCore($stateParams.projectKey, $stateParams.analysisId).success(function(data) {
        $scope.analysisCoreParams = data;
        TopNav.setItem(TopNav.ITEM_ANALYSIS, $stateParams.analysisId, {name:data.name, dataset: data.inputDatasetSmartName});
        TopNav.setPageTitle(data.name + " - Analysis");
    }).error(setErrorInScope.bind($scope));

    $scope.listMLTasks().then($scope.initialRefreshAndAutoRefresh);

    $scope.$watch("mlTaskDesign.modeling.metrics", (nv) => {
        if (nv) {
            $scope.headIds = $scope.mlTaskStatus.fullModelIds
                .sort($scope.compareFMIs)
                .map(o => o.id).slice(0, 1);
            $scope.getModelSnippets([], true).then(() => {
                console.log("loaded mdg");
                $scope.puppeteerHook_elementContentLoaded = true;
            }); // get all snippets (long call)
            $scope.getModelSnippets($scope.headIds); // first quick call to display outline
        }
    });

    $scope.$on("$destroy", $scope.clearMLTasksContext);

    MLTasksNavService.setMlTaskIdToGo($stateParams.analysisId, $stateParams.mlTaskId);
    checkChangesBeforeLeaving($scope, $scope.dirtySettings, null, [$scope.sRefPrefix + '.list.design', $scope.sRefPrefix + '.list.results',]);

    if ($rootScope.mlTaskJustCreated === true) {
        delete $rootScope.mlTaskJustCreated;
        $scope.mlTaskJustCreated = true;
        $scope.touchMlTask = function() { delete $scope.mlTaskJustCreated; };
    } else {
        $scope.touchMlTask = function(){
            // nothing to touch, not just created
        };
    }

    $scope.prepareGuessPolicies = function(policies) {
        policies.forEach(policy => {
            // Disabled every policy that does not support current backend type
            if (!policy.supported_backends.includes($scope.mlTaskDesign.backendType)) {
                policy.disabled = true;
            }

            // Inject current backend type in custom algorithms policy description
            if (policy.id === 'CUSTOM') {
                policy.description = `Train your own ${ $scope.mlTaskDesign.backendType === 'PY_MEMORY' ? 'Python' : 'Scala' } models.`;
            }
        });
        return policies;
    }
    
    $scope.switchGuessPolicy = function(policy) {

        if (policy.disabled) { return; }

        if ($scope.dirtySettings()) {
            $scope.saveSettings();
        }
        
        CreateModalFromTemplate("/templates/analysis/mlcommon/settings/change-algorithm-presets-modal.html", $scope, null, function(newScope) {
            newScope.taskType = $scope.mlTaskDesign.taskType.toLowerCase();
            newScope.confirm = function() {
                $scope.MLAPI.changeGuessPolicy($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId, policy.id).then(function(response){
                        $scope.setMlTaskDesign(response.data);
                        $scope.saveSettings();
                        $scope.uiState.algorithm = $scope.base_algorithms[$scope.mlTaskDesign.backendType]
                            .find(_ => !_.condition || _.condition()).algKey;
                }, setErrorInScope.bind($scope));
                newScope.dismiss();
            };
            newScope.cancel = function() {
                newScope.dismiss();
            };
        });
    };

    $scope.$watch("selection.selectedObject", function(nv){
        $scope.getSessionTaskIfChanged((nv||{}).sessionId)
    });

    $scope.$watch('uiState.currentMetric', $scope.setMainMetric);

});


app.controller("_MLTaskResultsController", function($scope, $timeout, $state, $stateParams, ActivityIndicator,
    CreateModalFromTemplate, DataikuAPI, Fn, Dialogs, Collections, PartitionedModelsService, FullModelIdUtils,
    MLDiagnosticsService) {
    angular.extend($scope, PartitionedModelsService);
    angular.extend($scope, MLDiagnosticsService);

    $scope.partiallyAbortTraining = function(fullModelIds){
        var gsModels;
        if (!$scope.isModelOptimizing) {
            gsModels = [];
        } else {
            gsModels = fullModelIds.map(function(o){return $scope.modelSnippets[o]})
                .filter($scope.isModelOptimizing)
                .map(Fn.prop("fullModelId"));
        }
        CreateModalFromTemplate("/templates/analysis/mlcommon/abort-train-modal.html", $scope, null, function(newScope) {
            newScope.gsModels = gsModels;
            newScope.confirm = function() {
                DataikuAPI.analysis.mlcommon
                    .trainAbortPartial($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId, fullModelIds)
                    .success(function(){
                        ActivityIndicator.success("Abort requested");
                        fullModelIds.forEach(function(fmi){
                            $scope.modelSnippets[fmi].trainInfo.$userRequestedState = 'ABORTED';
                        });
                    }).error(setErrorInScope.bind($scope));
                newScope.dismiss();
            }
            newScope.finalize = function() {
                DataikuAPI.analysis.mlcommon.stopGridSearch(gsModels)
                    .success(function(data){
                        gsModels.map(function(fmi){ $scope.modelSnippets[fmi].trainInfo.$userRequestedState = 'FINALIZE' });
                        $scope.refreshStatus();
                    })
                    .error(setErrorInScope.bind($scope));
                newScope.dismiss();
            }
        });
    };

     function revertScriptToSession(projectKey, analysisId, mlTaskDesignId, sessionId) {
        return DataikuAPI.analysis.mlcommon.revertScriptToSession(projectKey, analysisId, mlTaskDesignId, sessionId)
        .then(function(response) {
            return response.data;
        }, setErrorInScope.bind($scope));
     };

    $scope.revertDesignToSession = function(sessionId) {
        $scope.getSessionTask(sessionId).then(function(sessionDesign){
            CreateModalFromTemplate("/templates/analysis/mlcommon/dump-session-design-modal.html", $scope, null, function(newScope) {
                newScope.sessionId = sessionId.slice(1);
                newScope.sessionDesign = sessionDesign;
                newScope.algorithms = {};
                newScope.selectAlgorithms = false;
                var algByKey = Collections.indexByField($scope.base_algorithms[$scope.mlTaskDesign.backendType], 'algKey');
                angular.forEach(sessionDesign.modeling, function(v,k) {
                    if (v.enabled) {
                        // for some reason XGBoost is referred to by its algKey "xgboost_regression" / "xgboost_classification" in base_algorithms
                        // but its key is xgboost in mlTask TODO: set this straight
                        if (k === "xgboost") {
                            newScope.algorithms[k] = {
                                enabled: true,
                                name: "XGBoost"
                            };
                        } else {
                            newScope.algorithms[k] = {
                                enabled: true,
                                name: algByKey[k].name
                            };
                        }
                    }
                });
                angular.forEach(sessionDesign.modeling.custom_mllib, function(v,k) {
                    if (v.enabled) {
                        newScope.algorithms["custom_mllib_"+k] = {
                            enabled: true,
                            name: "Custom MLLIB algorithm #" + k,
                        };
                    }
                });
                angular.forEach(sessionDesign.modeling.custom_python, function(v,k) {
                    if (v.enabled) {
                        newScope.algorithms["custom_python_"+k] = {
                            enabled: true,
                            name: "Custom python algorithm #" + k,
                        };
                    }
                });
                newScope.noEnabledAlgorithms = function() {
                    return $.map(newScope.algorithms, function(v,k) {return !v.enabled}).reduce(Fn.AND,true);
                }
                newScope.confirm = function() {
                    revertScriptToSession(newScope.projectSummary.projectKey, newScope.analysisId, newScope.mlTaskDesign.id, sessionId).then(function(scriptFile) {
                        $scope.analysisCoreParams.script = scriptFile;
                        if (newScope.selectAlgorithms) {
                            angular.forEach(newScope.algorithms, function(v,k) {
                                if (k.startsWith("custom_mllib_")) {
                                    newScope.sessionDesign.modeling.custom_mllib[parseInt(k.slice(13))].enabled = v.enabled;
                                } else if (k.startsWith("custom_python_")) {
                                    newScope.sessionDesign.modeling.custom_python[parseInt(k.slice(14))].enabled = v.enabled;
                                } else {
                                    newScope.sessionDesign.modeling[k].enabled = v.enabled;
                                }
                            });
                        }
                        $scope.updateSettings(newScope.sessionDesign);
                        $state.go('^.design');
                        newScope.dismiss();
                    });
                }
            });
        });
    }
    
    $scope.revertDesignToModel = function(fullModelId, algorithm){
        const idTokens = FullModelIdUtils.parse(fullModelId);
        const sessionId = idTokens.sessionId;
        CreateModalFromTemplate("/templates/analysis/mlcommon/dump-model-design-modal.html", $scope, null, function(newScope) {
            newScope.sessionId = sessionId.slice(1);            
            newScope.canChoose = ("SCIKIT_MODEL" !== algorithm && !$scope.isPartitionedSession(sessionId));
            if (newScope.canChoose) {
                newScope.dumpMode = "OPTIMIZED";
            } else {
                newScope.dumpMode = "INITIAL";
            }
            newScope.confirm = function() {
                revertScriptToSession(newScope.projectSummary.projectKey, newScope.analysisId, newScope.mlTaskDesign.id, sessionId).then(function(scriptFile) {
                    $scope.analysisCoreParams.script = scriptFile;
                    if (newScope.dumpMode=="OPTIMIZED") {
                        $scope.revertDesignToGridsearchedModel(fullModelId);
                        newScope.dismiss();
                    } else {
                        $scope.revertDesignToPretrainModel(fullModelId);
                        newScope.dismiss();
                    }
                });
            }
        });
    }

    $scope.revertDesignToPretrainModel = function (fullModelId) {
        $scope.getPretrainEquivalentMLTask(fullModelId,false).then(function(sessionDesign){
            $scope.updateSettings(sessionDesign);
            $state.go('^.design');
        });
    }

    $scope.revertDesignToGridsearchedModel = function (fullModelId) {
        $scope.getPretrainEquivalentMLTask(fullModelId, true).then(function(sessionDesign) {
            $scope.updateSettings(sessionDesign);
            $state.go('^.design');
        });
    }

    $scope.isMLBackendType = function(mlBackendType){
        if (!$scope.mlTaskDesign) return false; // might not be initialized
        return $scope.mlTaskDesign.backendType == mlBackendType;
    };

    $scope.isSparkBased = function(){
        return $scope.mlTaskDesign.backendType == 'MLLIB' || $scope.mlTaskDesign.backendType == 'H2O';
    };

    $scope.updateOrderQueryMetric = function(metric) {
        var ss = $scope.selection;
        ss.orderQuery = '-sortMainMetric';
        if ($scope.uiState.currentMetric === metric) {
            ss.orderReversed = !ss.orderReversed;
        } else {
            ss.orderReversed = false;
        }
        $scope.uiState.currentMetric = metric;
        $timeout($scope.updateSorted);
    }

    $scope.canDeleteSelectedModels = function() {
        return (!$scope.selection.selectedObjects.map(Fn.prop("trainInfo"))
            .map(function(o){return o.state=='RUNNING';})
            .reduce(function(a,b){return a&&b},true));
    }

    $scope.canCreateEnsemble = function(){
        // only watch for design taskType (front-end should not allow creating various taskType / targets inside single MLTask)
        if ($scope.mlTasksContext.activeMLTask.taskType != "PREDICTION" || $scope.selection.selectedObjects.length < 2){
            return false;
        }
        return $scope.selection.selectedObjects.every(function(so){ return so.trainInfo.state == "DONE"; });
    };

    $scope.createEnsemble = function(){
        var fmis = $scope.selection.selectedObjects.map(function(o){ return o.fullModelId; });

        DataikuAPI.analysis.pml.checkCanEnsemble(fmis).success(function(data){
            CreateModalFromTemplate("/templates/analysis/prediction/create-ensemble-modal.html", $scope, "EnsembleModalController", function(newScope){
                newScope.fmis = fmis;
                newScope.params.method = (data.availableMethods && data.availableMethods.length) ? data.availableMethods[0].method : null;
                newScope.canEnsemble = data.canEnsemble;
                newScope.reason = data.reason;
                newScope.availableMethods = data.availableMethods;
                var methodMap = {};
                for(var i = 0; i < newScope.availableMethods.length; i++){
                    var par = newScope.availableMethods[i];
                    methodMap[par.method] = par.description;
                }
                newScope.getSelectedMethodDescription = function(){
                    return methodMap[newScope.getMethod()];
                };
                newScope.showTiesWarning = function(){
                    if(newScope.getMethod()==='VOTE'){
                        if($scope.mlTaskDesign.predictionType==="BINARY_CLASSIFICATION"){
                            return ((fmis.length % 2)===0); // show warning only if even number of models
                        } else {
                            // for c classes, and m models the condition for no-ties guaranty is that
                            // m > c and
                            // m % 2 ≠ 0, ..., m % c ≠ 0 which is, more often than not, false.
                            return ($scope.mlTaskDesign.predictionType==="MULTICLASS");
                        }
                    } else {
                        return false;
                    }
                };
                newScope.submit = function(){
                    DataikuAPI.analysis.pml.createEnsemble(
                        $stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId, fmis, newScope.getMethod()
                    ).success(function(){
                        $scope.removeTaskStatus();
                        $scope.initialRefreshAndAutoRefresh();
                        newScope.dismiss();
                    }).error(setErrorInScope.bind($scope));
                };
            });
        }).error(setErrorInScope.bind($scope));
    };

    $scope.allStarredModels = function() {
        var selectedObjects = $scope.selection.selectedObjects.filter(function(o){return o.trainInfo.state==='DONE';})
        return selectedObjects.map(Fn.prop("userMeta"))
            .map(Fn.prop("starred"))
            .reduce(function(a,b){return a&&b},true);
    }
    $scope.canStarSelectedModels = function() {
        return $scope.selection.selectedObjects.map(Fn.prop("trainInfo"))
            .map(function(o){return o.state=='DONE';})
            .reduce(function(a,b){return a&&b},true);
    }
    $scope.starSelectedModels = function(star) {
        var selectedObjects = $scope.selection.selectedObjects.filter(function(o){return o.trainInfo.state==='DONE';})
        selectedObjects.map(function(m){
            m.userMeta.starred = star;
        });
    }

    $scope.isModelFinalizing = function(model) {
        let key = $scope.isMLBackendType("KERAS") ? "modelTrainingInfo" : "gridsearchData";
        if (!model||!model[key]) { return false }
        return model[key].isFinalizing && $scope.isModelRunning(model);
    }

    $scope.isModelOptimizing = function(model) {
        // Interrupting model is currently not supported for partitioned models
        if (model.partitionedModelEnabled) {
            return false;
        }
        if (!$scope.isMLBackendType("KERAS")) {
            if (!model) { return false }
            const doingGridSearch = model.gridsearchData && !model.gridsearchData.isFinalizing && model.gridsearchData.gridPoints.length > 0;
            return doingGridSearch && $scope.isModelRunning(model);
        } else {
            if (!model||!model.modelTrainingInfo) { return false }
            return !model.modelTrainingInfo.isFinalizing
                && $scope.anySessionModelHasOptimizationResults()
                && !$scope.anyModelHasAllEpochsFinished()
                && $scope.isModelRunning(model);
        }
    };

    $scope.hasOptimizingModels = function(sessionId) {
        return $scope.selection && $scope.selection.allObjects && $scope.selection.allObjects
            .some(function(model) {
                return model.sessionId === sessionId
                    && $scope.isModelOptimizing(model);
            });
    }

    $scope.isModelOptimizationResumable = function(model) {
        // Resuming optimization is not supported for KERAS algorithms
        if ($scope.isMLBackendType("KERAS")) {
            return false;
        }

        // Resuming optimization is not supported for partitioned models
        if (model.partitionedModelEnabled) {
             return false;
        }
        
        const searchProgress = $scope.getModelSearchProgress(model);
        return $scope.isModelDone(model) 
            && ($scope.isModelOptimizationBoundByTimeout(model) || (searchProgress !== undefined && searchProgress < 1));
    };

    $scope.isModelOptimizationBoundByTimeout = function(model) {
        const gsd = model.gridsearchData;
        if (!gsd) {
            return false;
        }
        return (gsd.gridSize === 0 && gsd.timeout > 0);
    };
    
    $scope.getModelSearchProgress = function(model) {
        const gsd = model.gridsearchData;
        if (!gsd) {
            return undefined;
        }

        if (gsd.gridSize !== 0) {
            return model.gridsearchData.gridPoints.length / model.gridsearchData.gridSize;
        } else if (gsd.timeout > 0) { // model search is bound by timeout, need to look at time spent
            return  Math.min(1, (model.trainInfo.hyperparamsSearchTime / 1000) / (gsd.timeout * 60));
        }
        return 0;
    };

    $scope.isModelDone = function(model) {
        if (!model||!model.trainInfo) { return false }
        return model.trainInfo.state === 'DONE';
    }

    $scope.isModelPending = function(model) {
        if (!model||!model.trainInfo) { return false }
        return model.trainInfo.state === 'PENDING';
    }

    $scope.isModelFailedOrAborted = function(model) {
        if (!model||!model.trainInfo) { return false }
        return model.trainInfo.state === 'FAILED' || model.trainInfo.state === 'ABORTED';
    }
    $scope.isModelFailed = function(model) {
        if (!model||!model.trainInfo) { return false }
        return model.trainInfo.state === 'FAILED';
    }

    $scope.isModelRetrainable = function(model) {
        return  !$scope.mlTaskStatus.training
            && $scope.mlTasksContext.activeMLTask.taskType === "PREDICTION"
            && !$scope.isMLBackendType("KERAS")
            && ($scope.isModelAborted(model)
                || model.partitionedModelEnabled && $scope.getPartitionsSnippetStateSize(model, "ABORTED") > 0);
    }

    $scope.hasResumableModels = function(sessionId) {
        return $scope.selection && $scope.selection.allObjects
            && $scope.selection.allObjects.some(function(model) {
                return model.sessionId === sessionId
                    && ($scope.isModelOptimizationResumable(model) || $scope.isModelRetrainable(model));
            });
    }

    $scope.isModelAborted = function(model) {
        if (!model||!model.trainInfo) { return false }
        return model.trainInfo.state === 'ABORTED';
    }

    $scope.isModelRunning = function(model) {
        if (!model||!model.trainInfo) { return false }
        return model.trainInfo.state === 'RUNNING' || model.trainInfo.state === 'PENDING';
    }

    $scope.isBestModelScore = function(model, sameSession) {
        return model.sortMainMetric >= $scope.selection.allObjects
            .filter(o => !sameSession || o.sessionId === model.sessionId)
            .map(Fn.prop('sortMainMetric'))
            .reduce(Fn.MAX,-Number.MAX_VALUE);
    }

    $scope.sessionRunningCount = function(sessionId) {
        if (!$scope.selection||!$scope.selection.allObjects){return false;}
        return $scope.selection.allObjects.filter(function(o){return o.sessionId===sessionId})
            .map($scope.isModelRunning).map(function(o){return o?1:0}).reduce(Fn.SUM,0);
    }

    $scope.isSessionRunning = function(sessionId) {
        if (!$scope.selection||!$scope.selection.allObjects){return false;}
        return $scope.selection.allObjects.filter(function(o){return o.sessionId===sessionId})
            .map(function(m){return m.trainInfo.state === 'RUNNING' || m.trainInfo.state === 'PENDING'})
            .reduce(Fn.OR,false);
    }

    $scope.isPartitionedSession = function(sessionId) {
        if (!$scope.selection || !$scope.selection.allObjects) { return false; }

        return $scope.selection.allObjects
            .filter(o => o.sessionId === sessionId)
            .every(m => m.partitionedModelEnabled);
    };

    $scope.getAggregationExplanation = function(metricName) {
        const displayName = $scope.possibleMetrics.find(_ => _[0] === metricName)[1];
        return PartitionedModelsService.getAggregationExplanation(metricName, displayName);
    }

    $scope.getSessionStartDate = function(sessionId) {
        var minDate = 0;
        $scope.getSessionModels($scope.selection.allObjects, sessionId).forEach(function(x) {
            if (x && x.trainInfo && x.trainInfo.startTime) {
                minDate = Math.max(minDate, x.trainInfo.startTime)
            }
        });
        if (minDate == 0) {
            return null;
        } else {
            return new Date(minDate);
        }
    }

    $scope.getSessionEndDate = function(sessionId) {
        var maxDate = 0;
        $scope.getSessionModels($scope.selection.allObjects, sessionId).forEach(function(x) {
            if (x && x.trainInfo && x.trainInfo.endTime) {
                maxDate = Math.max(maxDate, x.trainInfo.endTime)
            }
        });
        if (maxDate == 0) {
            return null;
        } else {
            return new Date(maxDate);
        }
    }


    $scope.deleteSession = function(sessionId) {
        var fullModelIds = $scope.selection.allObjects
            .filter(function(o){return !$scope.isModelRunning(o) && o.sessionId === sessionId})
            .map(Fn.prop("fullModelId"));
        Dialogs.confirm($scope, "Delete " + fullModelIds.length + " models",
        "Do you want to delete these models ?").then(function() {
            DataikuAPI.ml.deleteModels(fullModelIds).success(function(data){
                fullModelIds.forEach(function(fmi){ delete $scope.modelSnippets[fmi] })
                $scope.refreshStatus().then($scope.selectRunningOrFirstSession);
            });
        });
    }

    $scope.deleteModel = function(model) {
        if ($scope.isModelRunning(model)) { return; }
        Dialogs.confirm($scope, "Delete this model", "Do you want to delete this model ?").then(function() {
            DataikuAPI.ml.deleteModels([model.fullModelId]).success(function(data){
                delete $scope.modelSnippets[model.fullModelId];
                if (Object.values($scope.modelSnippets)
                    .filter(function(s){ return s.sessionId === $scope.sessionTask.sessionId }).length === 0) {
                    $scope.refreshStatus().then($scope.selectRunningOrFirstSession);
                }
            });
        });
    }

    $scope.deleteSelectedModels = function() {
        var fullModelIds = $scope.selection.selectedObjects
            .filter(function(o) { return o.trainInfo.state !== 'RUNNING' })
            .map(Fn.prop("fullModelId"));
        Dialogs.confirm($scope, "Delete " + fullModelIds.length + " models",
        "Do you want to delete these models ?").then(function() {
            DataikuAPI.ml.deleteModels(fullModelIds).success(function(data){
                fullModelIds.forEach(function(fmi){ delete $scope.modelSnippets[fmi] });
                if (Object.values($scope.modelSnippets)
                    .filter(function(s){ return s.sessionId === $scope.sessionTask.sessionId }).length === 0) {
                    $scope.refreshStatus().then($scope.selectRunningOrFirstSession);
                }
            });
        });
    };

    $scope.toggleStarred = function(snippetData) {
        snippetData.userMeta.starred = !snippetData.userMeta.starred;
        DataikuAPI.ml.saveModelUserMeta(snippetData.fullModelId, snippetData.userMeta)
                            .error(setErrorInScope.bind($scope.$parent));
        $scope.$emit('refresh-list');
    }

    $scope.getSessions = function(models){
        return models.map(function(m){
            return m.sessionId;
        }).filter(function(value, index, self){
            return self.indexOf(value) === index;
        }).sort(function(a, b){
            return parseInt(b.slice(1))-parseInt(a.slice(1))
        });
    };

    $scope.getSessionModels = function(models, sessionId) {
        return (models || []).filter(m => m.sessionId === sessionId);
    };

    $scope.$watch("uiState.viewMode", function(nv){
        if (nv==='sessions') {
            $scope.selection.orderQuery = ['-sessionDate','algorithmOrder'];
        } else {
            $timeout(function(){
                $scope.$broadcast('redrawFatTable');
            });
            $scope.selection.orderQuery = [];
        }
    });

    $scope.scrollToModel = (selectedModel) => {
        if (!selectedModel) { return }
        const selectedModelDOM = document.getElementById(selectedModel.fullModelId);
        if (selectedModelDOM) {
            selectedModelDOM.scrollIntoView();
        }
    };

    function getAllAlgorithmTypes() {
        let allAlgorithmTypes = [];
        Object.keys($scope.algorithmCategories).forEach((key, index) => {
            allAlgorithmTypes = allAlgorithmTypes.concat($scope.algorithmCategories[key])
        });
        return allAlgorithmTypes;
    }

    $scope.resetCategories = function() {
        for (let key of Object.keys($scope.selection.filterCategory)) {
            $scope.selection.filterCategory[key] = false;
        }
    }
    
    $scope.uiState.filterAlgorithms = false;
    $scope.clearModelsListFilters = function() {
        $scope.uiState.filterAlgorithms = false;
        $scope.clearFilters();
        $scope.resetCategories();
    }
    $scope.algorithmsFilter = function (filteredObjects) {
        if ($scope.selection.filterCategory) {
            for (let key of Object.keys($scope.selection.filterCategory)) {
                if (key === "Others" && $scope.selection.filterCategory["Others"]) {
                    filteredObjects = filteredObjects.filter(x => getAllAlgorithmTypes().includes(x.algorithm));
                }
                else if ($scope.selection.filterCategory[key]) {
                    filteredObjects = filteredObjects.filter(x => !$scope.algorithmCategories[key].includes(x.algorithm));
                }
            }
        }
        return filteredObjects;
    };
    $scope.algorithmCategoriesWithOthers = Object.keys($scope.algorithmCategories).concat("Others");
});

app.service("MLDiagnosticsDefinition", (DataikuAPI) => {
    const promise = DataikuAPI.analysis.mlcommon.getDiagnosticsDefinition(); // eager fetch
    return {
        fetch: function(callback) {
            promise.success(callback);
        }
    };
});

app.service("MLDiagnosticsService", () => {
    return {
        groupByStepAndType: (trainDiagnostics) => {
            if (!trainDiagnostics || !trainDiagnostics.diagnostics) {
                return {};
            }

            const groupedDiagnostics = {};
            for (const diagnostic of trainDiagnostics.diagnostics) {
                groupedDiagnostics[diagnostic.step] = groupedDiagnostics[diagnostic.step] || {};
                const groupedStep = groupedDiagnostics[diagnostic.step];
                groupedStep[diagnostic.displayableType] = groupedStep[diagnostic.displayableType] || [];

                const messages = groupedStep[diagnostic.displayableType];
                messages.push(diagnostic.message);
            }

            return groupedDiagnostics;
        },
        groupByType: (trainDiagnostics) => {
            if (!trainDiagnostics || !trainDiagnostics.diagnostics) {
                return {};
            }

            const groupedDiagnostics = {};
            for (const diagnostic of trainDiagnostics.diagnostics) {
                groupedDiagnostics[diagnostic.type] = groupedDiagnostics[diagnostic.type] || [];
                const messages = groupedDiagnostics[diagnostic.type];
                messages.push(diagnostic.message);
            }

            return groupedDiagnostics;
        },
        hasDiagnostics: (model) => {
            if (!model) {
                return false;
            }

            const _hasDiagnostics = model => ((model.trainDiagnostics && model.trainDiagnostics.diagnostics) || []).length > 0;

            if (!model.partitionedModelEnabled) {
                return _hasDiagnostics(model);
            } else {
                return model.partitions &&  // check warnings in each summary
                    Object.values(model.partitions.summaries).map(s => s.snippet).some(_hasDiagnostics);
            }
        },
        countDiagnostics: model => {
            if (!model) {
                return 0;
            }

            const _countDiagnostics = model => {
                if (!model.trainDiagnostics || !model.trainDiagnostics.diagnostics) {
                    return 0;
                }

                return model.trainDiagnostics.diagnostics.length;
            }

            let total = 0;
            if (!model.partitionedModelEnabled) {
                total = _countDiagnostics(model);
            } else { // check warnings in each summary
                for (const s of Object.values(model.partitions.summaries)) {
                    if (s.state === "FAILED") {
                        continue;
                    }
                    total += _countDiagnostics(s.snippet);
                }
            }

            return total;
        },
        getDiagnosticsTextForPartitions: model => {
            if (!model || !model.partitionedModelEnabled) {
                return null;
            }

            let countWithDiagnostics = 0;
            for (const s of Object.values(model.partitions.summaries)) {
                if (s.state !== "FAILED" && Object.keys((s.snippet.trainDiagnostics && s.snippet.trainDiagnostics.diagnostics) || []).length > 0) {
                    countWithDiagnostics++;
                }
            }

            const totalPartitions = Object.values(model.partitions.summaries).length;
            if (countWithDiagnostics === 1) {
                return `On one partition out of ${totalPartitions}`;
            } else {
                return `On ${countWithDiagnostics} out of ${totalPartitions} partitions`;
            }
        }
    };
});

app.factory("VisualMlCodeEnvCompatibility", function() {
    return {
        isCompatible: function(envSelection, envCompatList, isDeepLearning, isSkopt) {
            if (!envSelection || !envCompatList || !envCompatList.envs) {
                return false;
            }

            let envCompat;
            switch(envSelection.envMode) {
                case "USE_BUILTIN_MODE":
                    envCompat = envCompatList.builtinEnvCompat;
                    break;
                case "INHERIT": {
                    if (!envCompatList.resolvedInheritDefault) { // Project code-env is builtin
                        envCompat =  envCompatList.builtinEnvCompat;
                    } else {
                        envCompat = envCompatList.envs.find(env => env.envName == envCompatList.resolvedInheritDefault);
                    }
                    break;
                }
                case "EXPLICIT_ENV":
                    envCompat = envCompatList.envs.find(env => env.envName == envSelection.envName);
                    break;
            }

            return envCompat && (
                isDeepLearning ? envCompat.deepLearning
                     : isSkopt ? envCompat.regularMlWithBayesian
                     : envCompat.regularMl
                 ).compatible;
        }
    }
})

app.directive("codeEnvSelectionWithMlPackagesForm", function(VisualMlCodeEnvCompatibility){
    return {
        restrict: 'A',
        templateUrl : '/templates/analysis/mlcommon/code-env-selection-with-ml-packages-form.html',
        scope: {
            envSelection: '=codeEnvSelectionWithMlPackagesForm',
            codeEnvsCompat: "=",
            isDeepLearning: "=",
            isSkopt: "="
        },
        link: function($scope, element, attrs) {

            $scope.envModes = [
                ['USE_BUILTIN_MODE', 'Use DSS builtin env'],
                ['INHERIT', 'Inherit project default'],
                ['EXPLICIT_ENV', 'Select an environment']
            ];

            $scope.isCompatible = function() {
                return VisualMlCodeEnvCompatibility.isCompatible($scope.envSelection, $scope.codeEnvsCompat, $scope.isDeepLearning, $scope.isSkopt);
            };

            function setDefaultValue() {
                if (!$scope.envSelection) { // not ready
                    return;
                }
                const atLeastOneEnv = $scope.sortedCodeEnvs && $scope.sortedCodeEnvs.length > 0;
                if ($scope.envSelection.envMode == "EXPLICIT_ENV" && $scope.envSelection.envName == null && atLeastOneEnv) {
                    $scope.envSelection.envName = $scope.sortedCodeEnvs[0].envName;
                }
            }
            $scope.$watch("envSelection.envMode", setDefaultValue);

            // Artificially add null value to description list when selected env does not match any listed envs
            // to prevent from breaking the UI (this can happen if selected env has been deleted for example)
            function addNullValueToDescriptionsIfNameNotInList() {
                const isExplicit = $scope.envSelection && $scope.envSelection.envMode === "EXPLICIT_ENV";
                const atLeastOneEnv = $scope.sortedCodeEnvs && $scope.sortedCodeEnvs.length > 0;
                if (!isExplicit || !atLeastOneEnv) {
                    return;
                }
                const listHasNullFirst = ($scope.envDescriptions[0] === null);
                if (!$scope.sortedCodeEnvs.some(x => x.envName === $scope.envSelection.envName)) {
                    if (!listHasNullFirst) {
                        $scope.envDescriptions.unshift(null);
                    }
                } else if (listHasNullFirst) {
                    $scope.envDescriptions.shift();
                }
            }
            $scope.$watch("envSelection.envName", addNullValueToDescriptionsIfNameNotInList);

            function getIncompatibleDesc(reasons, defaultDesc) {
                if (!reasons || reasons.length === 0) {
                    return  `<span class='text-warning'>${defaultDesc}</span>`;
                } else if (reasons.length === 1) {
                    return `<span class='text-warning'>${reasons[0]}</span>`;
                } else {
                    return reasons.map(r => `<p class='text-warning'>${r}</p>`).join('');
                }
            }

            function fillEnvsData() {
                if ($scope.codeEnvsCompat.resolvedInheritDefault == null) {
                    $scope.envModes[1][1] = "Inherit project default (DSS builtin env)";
                } else {
                    $scope.envModes[1][1] = "Inherit project default (" + $scope.codeEnvsCompat.resolvedInheritDefault + ")";
                }
    
                $scope.sortedCodeEnvs = $scope.codeEnvsCompat.envs.map( env => {
                    let envDesc;
                    if ($scope.isDeepLearning) {
                        if (env.deepLearning.compatible) {
                            env.compatible = true;
                            if (env.deepLearning.supportsGpu) {
                                envDesc = "has required packages for Deep Learning (GPU or CPU).";
                            } else {
                                envDesc = "has required packages for Deep Learning (CPU).";
                            }
                        } else {
                            env.compatible = false;
                            envDesc = getIncompatibleDesc(env.deepLearning.reasons,
                                "seems incompatible with Deep Learning models");
                        }
                    } else if ($scope.isSkopt) {
                        if (env.regularMlWithBayesian.compatible) {
                            env.compatible = true;
                            envDesc = "has required packages for visual ML with bayesian search.";
                        } else {
                            env.compatible = false;
                            envDesc = getIncompatibleDesc(env.regularMlWithBayesian.reasons,
                                "seems incompatible with visual ML models with bayesian search");
                        }
                    } else {
                        if (env.regularMl.compatible) {
                            env.compatible = true
                            envDesc = "has required packages for visual ML.";
                        } else {
                            env.compatible = false;
                            envDesc = getIncompatibleDesc(env.regularMl.reasons,
                                "seems incompatible with run visual ML models");
                        }
                    }
                    env.envDesc = envDesc;
                    return env;
                }).sort((env1, env2) => (env1.compatible === env2.compatible) ? 0 : (env1.compatible ? -1 : 1));
    
                $scope.envDescriptions = $scope.sortedCodeEnvs.map(env => env.envDesc);
                addNullValueToDescriptionsIfNameNotInList();
            }
            $scope.$watch("[ codeEnvsCompat, isDeepLearning, isSkopt ]", fillEnvsData, true);

        }
    }
});

app.directive('modelsTableData', ['computeColumnWidths', '$window', function(computeColumnWidths, $window) {
    return {
        scope : false,
        restrict : 'A',
        link: function($scope, element) {
            $scope.displayedTableColumns = [];
            $scope.displayedTableRows = [];

            // To correct table width on window resize
            angular.element($window).on('resize', function(){
                $scope.$apply($scope.adjustColumnWidths);
            });

            $scope.$on("$destroy",function (){
                angular.element($window).off("resize"); //remove the handler added earlier
            });

            $scope.adjustColumnWidths = function() {
                let maxWidth = element.prop("clientWidth") - 16; // The -16px is to take into account the fatTable
                                                                 // vertical scrollbar width on firefox

                if ($scope.computedTableWidth < maxWidth) {
                    $scope.displayedColumnsWidths = [];
                    let totalWidth = 0; // Keep track of the total width to correct rounding error
                    $scope.computedColumnWidths.forEach(function(width) {
                       let newWidth = Math.round(width * maxWidth/$scope.computedTableWidth);
                       totalWidth += newWidth;
                       $scope.displayedColumnsWidths.push(newWidth);
                    });
                    if (totalWidth > maxWidth) {
                        // Correct width rounding error (usually difference is 0 or 1), by removing
                        // the difference to last column's width
                        $scope.displayedColumnsWidths.push(
                            $scope.displayedColumnsWidths.splice(-1, 1)[0] - (totalWidth - maxWidth)
                        );
                    }
                } else {
                    $scope.displayedColumnsWidths = $scope.computedColumnWidths;
                }
            }

            var refreshDisplayedColumns = function() {
                $scope.displayedTableColumns = [
                    {isModelSel: true},
                    {isModelName: true},
                    {isModelTrainTime: true},
                    {isModelTrainTimeMetric: true}
                ];

                let header = [
                    {name: "sel", ncharsToShow: 5},
                    {name: "Name", ncharsToShow: 25},
                    {name: "Trained", ncharsToShow: 20},
                    {name: "Train time", ncharsToShow: 6}
                ];

                if ($scope.mlTaskDesign.backendType=='PY_MEMORY' && $scope.mlTaskDesign.taskType=='PREDICTION') {
                    $scope.displayedTableColumns.push({isSampleWeights: true});
                    header.push({name: "Sample weights", ncharsToShow: 5})
                }

                if ($scope.possibleMetrics) {
                    $scope.possibleMetrics.forEach(function(metric) {
                        $scope.displayedTableColumns.push({isModelMetric: true, metric: metric});
                        header.push({name: "MMMMM MMMMM", ncharsToShow: 10}) // Dummy name of length 11 for all metrics
                    });
                }

                $scope.displayedTableColumns.push({isModelStarred: true});
                header.push({name: "star", ncharsToShow: 1})

                $scope.computedColumnWidths = computeColumnWidths([], header, 30, () => false, {}, true)[0];
                $scope.computedTableWidth =  $scope.computedColumnWidths.reduce((a, b) => a + b);
                $scope.adjustColumnWidths();
            };

            var refreshDisplayedRows = function() {

                // build rows for the fattable
                $scope.displayedTableRows = [];
                if ($scope.selection.filteredObjects) {
                    $scope.selection.filteredObjects.forEach(function(summ) {
                        var row = [
                            {isModelSel: true, summ: summ},
                            {isModelName: true, summ: summ},
                            {isModelTrainTime: true, summ: summ},
                            {isModelTrainTimeMetric: true, summ: summ}
                        ];
                        if ($scope.mlTaskDesign.backendType=='PY_MEMORY' && $scope.mlTaskDesign.taskType=='PREDICTION') {
                            row.push({isSampleWeights: true, summ: summ});
                        }
                        if ($scope.possibleMetrics) {
                            $scope.possibleMetrics.forEach(function(metric) {
                                row.push({isModelMetric: true, metric: metric, summ: summ});
                            });
                        }
                        row.push({isModelStarred: true, summ: summ});
                        $scope.displayedTableRows.push(row);
                    });
                }

            };

            refreshDisplayedColumns();

            $scope.$watchCollection('selection.filteredObjects', function() {
                refreshDisplayedRows();
            });

            $scope.$on('redrawFatTable', function() {
                refreshDisplayedColumns();
                refreshDisplayedRows();
            });
       }
    };
}])

})();

(function(){
'use strict';

var app = angular.module('dataiku.analysis.mlcore');

/**
 * Controllers and services for the summary views
 * of a MLTask
 */


})();
(function(){
'use strict';

let app = angular.module('dataiku.analysis.mlcore');

app.service('PMLSettings', function(Fn) {
    var cst = {
        taskF: function(backend){ return {
            bcEvaluationMetrics: function(backend){
                var base = [
                    ["F1", "F1 Score"],
                    ["ACCURACY", "Accuracy"],
                    ["PRECISION", "Precision"],
                    ["RECALL", "Recall"],
                    ["COST_MATRIX", "Cost matrix"],
                    ["ROC_AUC", "AUC"],
                    ["LOG_LOSS", "Log Loss"],
                    ["CUMULATIVE_LIFT", "Cumulative lift"]
                ];
                if(backend == "PY_MEMORY" || backend == "KERAS"){
                    base.push(["CUSTOM", "Custom code"]);
                }
                return base;
            }(backend),
            mcEvaluationMetrics: function(backend){
                var base = [
                    ["F1", "F1 Score"],
                    ["ACCURACY", "Accuracy"],
                    ["PRECISION", "Precision"],
                    ["RECALL", "Recall"],
                    ["ROC_AUC", "AUC"],
                    ["LOG_LOSS", "Log Loss"]
                ];
                if(backend == "PY_MEMORY" || backend == "KERAS"){
                    base.push(["CUSTOM", "Custom code"]);
                }
                return base;
            }(backend),
            regressionEvaluationMetrics: function(backend){
                var base = [
                    ["EVS", "Explained Variance Score"],
                    ["MAPE", "Mean Absolute Percentage Error"],
                    ["MAE", "Mean Absolute Error"],
                    ["MSE", "Mean Squared Error"],
                    ["RMSE", "Root Mean Square Error"],
                    ["RMSLE", "Root Mean Square Logarithmic Error"],
                    ["R2", "R2 Score"]
                ];
                if(backend == "PY_MEMORY" || backend == "KERAS"){
                    base.push(["CUSTOM", "Custom code"]);
                }
                return base;
            }(backend),
            crossvalModesRandom: function(backend){
                var base = [
                    ["SHUFFLE", "Simple train/validation split"],
                    ["KFOLD", "K-fold"]
                ]
                if(backend == "PY_MEMORY"){
                    base.push(["CUSTOM", "Custom code"]);
                }
                return base;
            }(backend),
            getCrossvalModesRandomForDocumentation(crossValidationStrategy, mlTaskDesign) {
                let crossvalModeDoc;

                switch (crossValidationStrategy) {
                    case 'SHUFFLE': 
                        crossvalModeDoc = 'Simple train/validation split';
                    break;

                    case 'KFOLD':
                        crossvalModeDoc = `${mlTaskDesign.modeling.gridSearchParams.nFolds}-fold cross-validation`;
                    break;

                    case 'CUSTOM':
                        crossvalModeDoc = 'Custom Code';
                    break;
                }

                return crossvalModeDoc;
            },
            crossvalModesWithTime: [["TIME_SERIES_SINGLE_SPLIT", "Time-based train/validation split"],
                                    ["TIME_SERIES_KFOLD", "Time-based K-fold (with overlap)"],
                                    ["CUSTOM", "Custom code"]],
            getCrossvalModesWithTimeForDocumentation(crossValidationStrategy, mlTaskDesign) {
                let crossvalModeDoc;

                switch (crossValidationStrategy) {
                    case 'TIME_SERIES_SINGLE_SPLIT': 
                        crossvalModeDoc = 'Simple train/validation split';
                    break;

                    case 'TIME_SERIES_KFOLD':
                        crossvalModeDoc = `Time-based ${mlTaskDesign.modeling.gridSearchParams.nFolds}-fold (with overlap)`;
                    break;

                    case 'CUSTOM':
                        crossvalModeDoc = 'Custom code';
                    break;
                }

                return crossvalModeDoc;
            }
        }}, task: {
            predictionTypes: [
                ["BINARY_CLASSIFICATION", "Two-class classification"],
                ["MULTICLASS", "Multiclass classification"],
                ["REGRESSION", "Regression"]
            ],
            thresholdOptimizationMetrics: [
                ["F1", "F1 Score"],
                ["ACCURACY", "Accuracy"],
                ["COST_MATRIX", "Cost matrix"]
            ],
            trainTestPolicies: [
                ["SPLIT_MAIN_DATASET", "Split the dataset"],
                ["EXPLICIT_FILTERING_SINGLE_DATASET_MAIN", "Explicit extracts from the dataset"],
                ["EXPLICIT_FILTERING_TWO_DATASETS", "Explicit extracts from two datasets"],
                ["SPLIT_OTHER_DATASET", "Split another dataset"],
                ["EXPLICIT_FILTERING_SINGLE_DATASET_OTHER", "Explicit extracts from another dataset"],
                //["FIXED_ID_BASED", "Use fixed identifiers from two datasets"]
            ],
            trainTestPoliciesDesc: function(inputDatasetSmartName) { return [
                "Split a subset of "+inputDatasetSmartName,
                "Use two extracts from "+inputDatasetSmartName+", one for train, one for test",
                "Use two extracts from two different datasets, one for train, one for test",
                "Split a subset of another dataset, compatible with "+inputDatasetSmartName,
                "Use two extracts from another dataset, one for train, one for test",
            ]},
            splitModes: [ ["RANDOM", "Randomly"],
                          ["SORTED", "Based on time variable"]]
        }, names: {
            evaluationMetrics: {
                PRECISION: "Precision",
                RECALL: "Recall",
                F1: "F1 Score",
                ACCURACY: "Accuracy",
                EVS : "EVS",
                MAPE : "MAPE",
                MAE : "MAE",
                MSE : "MSE",
                RMSE: "RMSE",
                RMSLE: "RMSLE",
                R2: "R2 Score",
                PEARSON: "Correlation",
                COST_MATRIX: "Cost Matrix Gain",
                LOG_LOSS: "Log Loss",
                ROC_AUC: "ROC AUC",
                CUSTOM: "Custom score",
                CALIBRATION_LOSS : "Calibration Loss",
                CUMULATIVE_LIFT : "Lift"
            },
            algorithms: {
                a_lm: "Linear Models",
                b_rf: "Random Forests",
                c_svm: "Support Vector Machines",
                d_sgd: "Stochastic Gradient Descent",
                e_gbm: "Gradient Boosting",
                f_dt: "Decision Tree",
                g_other: "Others"
            }
        }, filter: {
            algorithms: {
                a_lm: ['RIDGE_REGRESSION', 'LASSO_REGRESSION', 'LEASTSQUARE_REGRESSION', 'LOGISTIC_REGRESSION', 'GLM_H2O', 'MLLIB_LOGISTIC_REGRESSION', 'MLLIB_LINEAR_REGRESSION', 'SPARKLING_GLM'],
                b_rf: ['RANDOM_FOREST_REGRESSION', 'RANDOM_FOREST_CLASSIFICATION', 'DISTRIBUTED_RF_H2O', 'MLLIB_RANDOM_FOREST', 'SPARKLING_RF'],
                c_svm: ['SVC_CLASSIFICATION', 'SVM_REGRESSION'],
                d_sgd: ['SGD_CLASSIFICATION', 'SGD_REGRESSION'],
                e_gbm: ['GBM_H2O', 'GBT_CLASSIFICATION', 'GBT_REGRESSION', 'XGBOOST_CLASSIFICATION', 'XGBOOST_REGRESSION', 'SPARKLING_GBM', 'MLLIB_GBT'],
                f_dt: ['DECISION_TREE_CLASSIFICATION', 'MLLIB_DECISION_TREE'],
                g_other: ['SCIKIT_MODEL', 'DEEP_LEARNING_H2O', 'SPARKLING_NB', 'SPARKLING_DEEP_LEARNING', 'MLLIB_NAIVE_BAYES']
            }
        }, sort: {
            lowerBetter: ['MAE', 'MSE', 'RMSE', 'RMSLE', 'LOG_LOSS', 'MAPE', "CALIBRATION_LOSS"]
        }, normalizedMetrics: [ // metrics that are between 0 and 1
            "ROC_AUC", "PRECISION", "RECALL", "F1", "ACCURACY", "EVS", "R2",  "CALIBRATION_LOSS"
        ] ,algorithmCategories : {
            "Linear Models": ['RIDGE_REGRESSION', 'LASSO_REGRESSION', 'LEASTSQUARE_REGRESSION', 'LOGISTIC_REGRESSION', 'GLM_H2O', 'MLLIB_LOGISTIC_REGRESSION', 'MLLIB_LINEAR_REGRESSION', 'SPARKLING_GLM'],
            "Random Forests": ['RANDOM_FOREST_REGRESSION', 'RANDOM_FOREST_CLASSIFICATION', 'DISTRIBUTED_RF_H2O', 'MLLIB_RANDOM_FOREST', 'SPARKLING_RF'],
            "Support Vector Machines": ['SVC_CLASSIFICATION', 'SVM_REGRESSION'],
            "Stochastic Gradient Descent": ['SGD_CLASSIFICATION', 'SGD_REGRESSION'],
            "Gradient Boosting": ['GBM_H2O', 'GBT_CLASSIFICATION', 'GBT_REGRESSION', 'XGBOOST_CLASSIFICATION', 'XGBOOST_REGRESSION', 'SPARKLING_GBM', 'MLLIB_GBT'],
            "Decision Tree": ['DECISION_TREE_CLASSIFICATION', 'MLLIB_DECISION_TREE']
        }, noDollarKey: function(k) {
            return !k.startsWith('$') && k != "_name" && k != "datasetColumnId" && k != "userModified";
        }, isSpecialFeature: function(featParams) {
            // ONLY FOR KERAS (DEEP LEARNING) BACKEND

            if (!featParams || featParams.role === "REJECT") {
                return false;
            }

            var featType = featParams.type;

            if (featType === "TEXT") {

                var handling = featParams.text_handling;
                if (handling === "CUSTOM") {
                    return true;
                }
            }

            if (featType === "IMAGE") {

                var handling = featParams.image_handling;
                if (handling === "CUSTOM") {
                    return true;
                }
            }

            return false;
        }
    };
    cst.sort.lowerIsBetter = function (e, customEvaluationMetricGIB) {
        if (e === "CUSTOM") {
            if (customEvaluationMetricGIB == undefined) {return false;}
            else {return !customEvaluationMetricGIB;}
        }
        return (cst.sort.lowerBetter.indexOf(e) !== -1);
    }

    // Consider that input is "Special" if it contains special features
    // In practice, each special input has its own input
    cst.isSpecialInput = function (inputName, perFeature) {
        if (!inputName || !perFeature) {
            return false;
        }
        return Object.values(perFeature).some(f => f.sendToInput == inputName && cst.isSpecialFeature(f));
    };

    return cst;
});

app.service("PartitionedModelsService", function(PMLSettings, Logger) {

    let cst = {
        getPartitionsSnippetStateSize: (snippetData, ...states) => {
            if (!snippetData || !snippetData.partitions || !snippetData.partitions.states) {
                return 0;
            }
    
            return Object.entries(snippetData.partitions.states)
                .reduce((total, pair) => {
                    const [state, amount] = pair;
                    if (states.includes(state)) {
                        return total + amount;
                    }
                    return total;
                }, 0);
        },
    
        getTotalAmountOfPartitions: (snippetData) => {
            if (!snippetData || !snippetData.partitions || !snippetData.partitions.states) {
                return 0;
            }
    
            return Object.values(snippetData.partitions.states)
                .reduce((total, amount) => total + amount, 0);
        },
    
        getPartitionResultMetricGradient: (snippetData, sortMainMetric, currentMetric) => {
            
            // We are dealing here with sort Metric that may be infinite (i.e. the corresponding metric
            // is undefined)
            if (sortMainMetric === undefined || Math.abs(sortMainMetric) === Number.MAX_VALUE) {
                return "none";
            }
    
            let ratio;
            if (PMLSettings.normalizedMetrics.includes(currentMetric) 
               && !PMLSettings.sort.lowerBetter.includes(currentMetric)) {
                ratio = sortMainMetric;
            } else {
    
                const existingMetricsList = Object.values(snippetData.partitions.summaries)
                                                  .map( summary => summary.snippet.sortMainMetric)
                                                 // Remove infinite values that may have been introduce for sorting purpose
                                                  .filter(m => Math.abs(m) < Number.MAX_VALUE);
                const metricsMax = Math.max(...existingMetricsList);
                const metricsMin = Math.min(...existingMetricsList);                    
                const minRatio = 0.05;
                const maxRatio = 1;
    
                if (metricsMax === metricsMin) {
                    ratio = maxRatio;
                } else {
                    ratio = minRatio + maxRatio * (sortMainMetric - metricsMin) / (metricsMax - metricsMin) 
                }
            }
    
            const greenBaseColor = "#29AF5D";
            return 'linear-gradient(to right, '+ greenBaseColor +' 0%, ' + greenBaseColor + ' '+ (ratio * 100) +'%,rgba(0, 0, 0, 0) '+ (ratio * 100) +'%, rgba(0, 0, 0, 0) 100%)';
        },

        getAggregationExplanation: (metricName, displayName) => {
            switch (metricName) {
                case "ACCURACY":
                case "PRECISION":
                case "RECALL":
                case "F1":
                case "COST_MATRIX":
                case "MCC":
                case "HAMMINGLOSS":
                    return "{0} of the global model, using optimal threshold for each partition.".format(displayName);
                // same as MSE/MAPE/MAE but here the name is displayed in lower case instead
                case "LOG_LOSS":
                    return "Log loss of the global model (equal to the average log loss per partition, weighted by test weight).";
                // same as CUMULATIVE_LIFT/CALIBRATION_LOSS but here the name is displayed in upper case instead
                case "ROC_AUC":
                        return "Average ROC AUC per partition weighted by test weight as an approximation of the true ROC AUC.";
                case "CUMULATIVE_LIFT":
                case "CALIBRATION_LOSS":
                    const displayNameLowerCase = displayName.toLowerCase();
                    return "Average {0} per partition weighted by test weight as an approximation of the true {1}.".format(displayNameLowerCase, displayNameLowerCase);
                case "CUSTOM":
                    return "Average custom score per partition weighted by test weight.\n"
                           + "It may be an approximation of the true custom score depending on the way it has been defined.";
                case "MSE":
                case "MAPE":
                case "MAE":
                        return "{0} of the global model (equal to the average {1} per partition, weighted by test weight).".format(displayName, displayName);
                case "RMSE":
                case "RMSLE":
                case "R2":
                case "EVS":
                case "PEARSON":
                    return "{0} of the global model.".format(displayName);
                default:
                    Logger.error("Metric name is not valid");
            }
        }
    }

    return cst;

});

app.service("BinaryClassificationModelsService", function () {
    function getPercentString(p) {
        if (p < 0.01) {
            return "< 1 %";
        } else if (p > 1) {
            return "100 %";
        }
        else {
            return Math.round(p * 100) + " %";
        }
    }
    return {
        findCutData: (modelDataPerf, cutToFind) => {
            let pcd = modelDataPerf && modelDataPerf.perCutData;
            if (!pcd || !pcd.cmg) {
                return;
            }
            // Cut values are rounded because of a 0.025 step increase that led to some numerical discrepencies and bad comparisons
            // See also classification_scoring.py::decision_for_all_cuts_generator()
            const round = v => Math.round(1000 * v) / 1000;
            cutToFind = round(cutToFind);
            let i = 0;
            for (i = 0; i < pcd.cut.length - 1; i++) {
                if (round(pcd.cut[i]) >= cutToFind) {
                    break;
                }
            }
            var tp = pcd.tp[i], tn = pcd.tn[i], fp = pcd.fp[i], fn = pcd.fn[i];
            var actPos = tp + fn;
            var actNeg = tn + fp;
            var predPos = tp + fp;
            var predNeg = tn + fn;
            var eps = 0.01;
            let ret = { // capitalized = will be graphed
                index: i, cut: round(pcd.cut[i]),
                tp: {
                    records: tp,
                    actual: getPercentString(tp / (actPos + eps)),
                    predicted: getPercentString(tp / (predPos + eps))
                },
                tn: {
                    records: tn,
                    actual: getPercentString(tn / (actNeg + eps)),
                    predicted: getPercentString(tn / (predNeg + eps))
                },
                fp: {
                    records: fp,
                    actual: getPercentString(fp / (actNeg + eps)),
                    predicted: getPercentString(fp / (predPos + eps))
                },
                fn: {
                    records: fn,
                    actual: getPercentString(fn / (actPos + eps)),
                    predicted: getPercentString(fn / (predNeg + eps))
                },
                actPos: {records: tp + fn, actual: "100 %"},
                actNeg: {records: tn + fp, actual: "100 %"},
                predPos: {records: tp + fp, predicted: "100 %"},
                predNeg: {records: tn + fn, predicted: "100 %"},
                mcc: pcd.mcc[i], hammingLoss: pcd.hammingLoss[i],
                Precision: pcd.precision[i], Recall: pcd.recall[i],
                "F1-Score": pcd.f1[i], Accuracy: pcd.accuracy[i],
                customScore: (pcd.customScore ? pcd.customScore[i] : null)
            };
            if (pcd.cmg) {
                ret["cmg"] = pcd.cmg[i];
            }
            return ret;
        }
    };
});

app.controller("DeepLearningPMLController", function ($scope, $timeout, $interval, $controller, DataikuAPI, PMLSettings, PMLFilteringService,
                                                      $state, $stateParams, TopNav, Collections, Dialogs, CreateModalFromTemplate, Fn, Logger, $q, CodeBasedEditorUtils) {
    const inputsShown = {};

    function insertCode(codeToInsert) {
        //timeout to make sure of an angular safe apply
        $timeout(function() {
            $scope.cm.replaceSelection(`${codeToInsert}\n`, "around");
        });

        $scope.cm.focus();
    }

    function fillFitCodeKeras() {
        if ($scope.mlTaskDesign.modeling.keras.fitCode === undefined) {
            // language=Python
            const stepsPerEpochCode = $scope.mlTaskDesign.modeling.keras.trainOnAllData ? "" : "                        steps_per_epoch=" + $scope.mlTaskDesign.modeling.keras.stepsPerEpoch + ",\n";
            const fitCode = "# A function that builds train and validation sequences.\n" +
                "# You can define your custom data augmentation based on the original train and validation sequences\n\n" +
                "#   build_train_sequence_with_batch_size        - function that returns train data sequence depending on\n" +
                "#                                                 batch size\n" +
                "#   build_validation_sequence_with_batch_size   - function that returns validation data sequence depending on\n" +
                "#                                                 batch size\n" +
                "def build_sequences(build_train_sequence_with_batch_size, build_validation_sequence_with_batch_size):\n" +
                "    \n" +
                "    batch_size = " + $scope.mlTaskDesign.modeling.keras.batchSize + "\n" +
                "    \n" +
                "    train_sequence = build_train_sequence_with_batch_size(batch_size)\n" +
                "    validation_sequence = build_validation_sequence_with_batch_size(batch_size)\n" +
                "    \n" +
                "    return train_sequence, validation_sequence\n\n\n" +
                "# A function that contains a call to fit a model.\n\n" +
                "#   model                 - compiled model\n" +
                "#   train_sequence        - train data sequence, returned in build_sequence\n" +
                "#   validation_sequence   - validation data sequence, returned in build_sequence\n" +
                "#   base_callbacks        - a list of Dataiku callbacks, that are not to be removed. User callbacks can be added to this list\n" +
                "def fit_model(model, train_sequence, validation_sequence, base_callbacks):\n" +
                "    epochs = " + $scope.mlTaskDesign.modeling.keras.epochs + "\n" +
                "    model.fit_generator(train_sequence,\n" +
                "                        epochs=epochs,\n" +
                stepsPerEpochCode +
                "                        callbacks=base_callbacks,\n" +
                "                        shuffle=" + ($scope.mlTaskDesign.modeling.keras.shuffleData ? "True" : "False") + ")\n";
            $scope.mlTaskDesign.modeling.keras.fitCode = fitCode;
        }
    }

    // Allow transition of Inputs area only on click
    $scope.addEventOnTransition = function() {
        $(".keras-inputs__wrapper").on("transitionend", function() {
            $scope.uiState.canTransition = false;
        })
    };

    $scope.showHideInputs = function() {
        $scope.uiState.canTransition = true;
        $scope.uiState.displayInput = !$scope.uiState.displayInput;
    };

    $scope.startEditInput = function(input) {
        $scope.uiState.currentlyEditing=input;
        $scope.uiState.newEditInputName=input;
    };

    $scope.isBeingEdited = function(input) {
        return $scope.uiState.currentlyEditing === input;
    };

    $scope.editInputIfValid = function() {
        if (!$scope.isValidEditInput()) {
            return;
        }
        var inputIndex = $scope.mlTaskDesign.modeling.keras.kerasInputs.indexOf($scope.uiState.currentlyEditing);
        $scope.mlTaskDesign.modeling.keras.kerasInputs[inputIndex] = $scope.uiState.newEditInputName;

        // Modifying input for each feature in it
        Object.values($scope.mlTaskDesign.preprocessing.per_feature).forEach(function(featParams) {
            if (featParams["sendToInput"] === $scope.uiState.currentlyEditing) {
                featParams["sendToInput"] = $scope.uiState.newEditInputName;
            }
        });

        // Resetting UI variables
        $scope.uiState.currentlyEditing=null;
        $scope.uiState.newEditInputName='';
    };

    $scope.isValidEditInput = function() {
        // Has not change name so far
        if ($scope.uiState.newEditInputName === $scope.uiState.currentlyEditing) {
            return true;
        }
        if ($scope.uiState.newEditInputName === "") {
            return false;
        }
        if ($scope.mlTaskDesign.modeling.keras.kerasInputs.indexOf($scope.uiState.newEditInputName) > -1) {
            return false;
        }
        return true;
    }

    $scope.cancelEditInput = function() {
        // Resetting UI variables
        $scope.uiState.currentlyEditing=null;
        $scope.uiState.newEditInputName='';
    };

    $scope.deleteInput = function(input) {
        Dialogs.confirm($scope, "Delete Deep Learning Input", "Do you want to delete this input ? All its features will be sent to the 'main' input").then(function(data){
            const inputIndex = $scope.mlTaskDesign.modeling.keras.kerasInputs.indexOf(input);
            $scope.mlTaskDesign.modeling.keras.kerasInputs.splice(inputIndex, 1);

            // Sending all features to 'main' input
            Object.values($scope.mlTaskDesign.preprocessing.per_feature).forEach(function (featParams) {
                if (featParams["sendToInput"] === input) {
                    featParams["sendToInput"] = "main";
                }
            });
        });
    };

    $scope.createInputIfValid = function() {
        if (!$scope.isValidNewInput()) {
            return;
        }
        $scope.mlTaskDesign.modeling.keras.kerasInputs.push($scope.uiState.newInputName);
        $scope.uiState.creatingNewInput = false;
        $scope.uiState.newInputName = '';

    };

    $scope.isValidNewInput = function() {
        if (!$scope.uiState.newInputName) {
            return false;
        }
        return $scope.mlTaskDesign.modeling.keras.kerasInputs.indexOf($scope.uiState.newInputName) <= -1;

    };

    $scope.isCreatingInput = function() {
        return $scope.uiState.creatingNewInput;
    };

    $scope.startCreatingInput = function() {
        $scope.uiState.creatingNewInput = true
    };

    $scope.cancelCreateInput = function() {
        $scope.uiState.creatingNewInput = false;
        $scope.uiState.newInputName = '';
    };

    $scope.insertInput = function(input) {

        if (!$scope.isSpecialInput(input)) {
            var code = "input_" + input + " = Input(shape=input_shapes[\""+input+"\"], name=\""+input+"\")";
            insertCode(code);
        } else {


            let deferred = $q.defer();
            let newScope = $scope.$new();
            newScope.input = input;
            newScope.uiState = {processorCodeShown: true};
            newScope.perFeature = $scope.mlTaskDesign.preprocessing.per_feature;

            newScope.insertReadOnlyOptions = $scope.codeMirrorSettingService.get('text/x-python');
            newScope.insertReadOnlyOptions["readOnly"]= "nocursor";
            newScope.insertReadOnlyOptions["lineNumbers"]= false;
            newScope.insertReadOnlyOptions["foldGutter"]= false;

            CreateModalFromTemplate("templates/analysis/prediction/insert-special-input-modal.html",
                newScope,
                null,
                function(scope) {

                    scope.acceptDeferred = deferred;

                    scope.uiState.insertInput = input;
                    scope.uiState.insertFeature = Object.keys(scope.perFeature)
                        .find(featName => scope.perFeature[featName]["sendToInput"] === input);
                    scope.uiState.insertFeatParams = scope.perFeature[scope.uiState.insertFeature];
                    scope.uiState.insertStartInputCode = "input_" + input + " = Input(shape=";
                    scope.uiState.insertEndInputCode = ", name=\""+input+"\")";

                    scope.insertSpecialInput = function () {
                        const inputCode = scope.uiState.insertStartInputCode + scope.uiState.insertInputShape + scope.uiState.insertEndInputCode;
                        scope.acceptDeferred.resolve(inputCode);
                        scope.dismiss();
                    };

                    scope.showHideProcessorCode = function() {
                        scope.uiState.processorCodeShown = !scope.uiState.processorCodeShown;
                    };
                });
            deferred.promise.then(function(inputCode) {
                insertCode(inputCode);
            });
        }
    };

    $scope.showHideInput = function(input) {
        inputsShown[input] = ! inputsShown[input];
    };

    $scope.isShown = function(input) {
        return inputsShown[input];
    };

    $scope.getNumFeatures = function(input) {
        return Object.values($scope.mlTaskDesign.preprocessing.per_feature)
            .filter(function(p) { return p["sendToInput"] === input && p["role"] === "INPUT" ;})
            .length
    };

    $scope.filterFeatures = function(input) {
        return function(feat) {
            return feat.sendToInput === input && feat.role === "INPUT";
        };
    };

    $scope.isSpecialInput = function(input) {
        return $scope.SettingsService.isSpecialInput(input, $scope.mlTaskDesign.preprocessing.per_feature);
    };

    function getSpecialInputType(input) {
        const specialFeature = Object.values($scope.mlTaskDesign.preprocessing.per_feature)
            .find(function(p) { return p["sendToInput"] === input && p["role"] === "INPUT" ;});
        return specialFeature.type;
    }

    $scope.getSpecialInputIcon = function(input) {
        const specialInputType = getSpecialInputType(input);
        let iconClass;
        if (specialInputType === "TEXT") {
            iconClass = "icon-italic";
        } else if (specialInputType === "IMAGE") {
            iconClass = "icon-picture";
        } else {
            iconClass = "";
        }
        return iconClass;
    };

    $scope.isMainInput = function(input) {
        return input === 'main';
    };

    $scope.isEditable = function(input) {
        return (!$scope.isSpecialInput(input) && !$scope.isMainInput(input));
    };

    $scope.getEditTitle = function(input) {
        if ($scope.isMainInput(input)) {
            return "Main input cannot be edited"
        } else if ($scope.isSpecialInput(input)) {
            return "Special input cannot be edited"
        } else {
            return "Edit input"
        }
    };

    $scope.getInsertTitle = function(input) {
        if ($scope.getNumFeatures(input) === 0) {
            return "Empty Input cannot be inserted";
        } else {
            return "Insert";
        }
    };

    $scope.isInsertable = function(input) {
        return $scope.getNumFeatures(input) > 0;
    };

    function getTextNetworkAndAddInput(input, inputInNetworks) {
        let inputVarName = "input_" + input;
        const feature = Object.keys($scope.mlTaskDesign.preprocessing.per_feature)
                              .find(featName => $scope.mlTaskDesign.preprocessing.per_feature[featName]["sendToInput"] === input);
        inputInNetworks.push(inputVarName);
        return "    # This input will receive preprocessed text from '" + feature + "' column\n" +
               "    " + inputVarName + " = Input(shape=(32,), name=\""+input+"\")\n" +
               "    x_" + input + " = Embedding(output_dim=512, input_dim=10000, input_length=32)(input_" + input + ")\n" +
               "    x_" + input + " = Flatten()(x_" + input + ")\n\n";
    }

    $scope.fillBuildCodeKeras = function(keepAndCommentPrevious) {
        if (keepAndCommentPrevious || $scope.mlTaskDesign.modeling.keras.buildCode === undefined) {

            let predictionLine;
            let lossFunction;
            let problemType;
            if ($scope.mlTaskDesign.predictionType === "REGRESSION") {
                predictionLine = "    predictions = Dense(1)(x)";
                lossFunction = "mse";
                problemType = "regression";
            } else {
                predictionLine = "    predictions = Dense(n_classes, activation='softmax')(x)";
                if ($scope.mlTaskDesign.predictionType === "BINARY_CLASSIFICATION") {
                    lossFunction = "binary_crossentropy";
                    problemType = "binary classification";
                } else {
                    lossFunction = "categorical_crossentropy";
                    problemType = "multiclass classification";
                }
            }

            // Retrieve Text special inputs that may have been guessed
            const specialTextInputNames = $scope.mlTaskDesign.modeling.keras.kerasInputs.filter(x => $scope.isSpecialInput(x) && getSpecialInputType(x) === "TEXT");
            const hasSpecialTextInputs = specialTextInputNames.length >= 1;
            const hasMain = $scope.getNumFeatures("main") >= 1;
            const numRealInputs = $scope.mlTaskDesign.modeling.keras.kerasInputs.length - (hasMain ? 0 : 1);
            let actualInputsInNetwork = [];

            let startNetwork = "";
            let lastLayerSoFar;
            if (hasMain || numRealInputs === 0) {
                const mainInputVarName ="input_main";
                startNetwork += '    # This input will receive all the preprocessed features\n' +
                                '    # sent to \'main\'\n' +
                                '    ' + mainInputVarName +' = Input(shape=input_shapes["main"], name="main")\n\n';
                lastLayerSoFar = mainInputVarName;
                actualInputsInNetwork.push(mainInputVarName);
            }
            if (hasSpecialTextInputs) {
                specialTextInputNames.forEach( input => {
                    startNetwork += getTextNetworkAndAddInput(input, actualInputsInNetwork);
                    lastLayerSoFar = "x_" + input;
                });
            }
            if (numRealInputs > 1) {
                const concatLayers = [];
                if (hasMain) {
                    concatLayers.push("input_main");
                }
                specialTextInputNames.forEach( input => {
                    concatLayers.push("x_" + input);
                })
                startNetwork += "    x = concatenate([" + concatLayers.join(", ") + "])\n\n";
                lastLayerSoFar = "x";
            }

            let layerImportLine = "from keras.layers import Input, Dense";
            if (hasSpecialTextInputs) {
                layerImportLine += ", Embedding, Flatten";
            }
            if (numRealInputs > 1) {
                layerImportLine += ", concatenate"
            }

            // language=Python
            let buildCode = layerImportLine + "\n" +
                              "from keras.models import Model\n\n" +
                              "# Define the keras architecture of your model in 'build_model' and return it. Compilation must be done in 'compile_model'.\n" +
                              "#   input_shapes  - dictionary of shapes per input as defined in features handling\n" +
                              "#   n_classes - For classification, number of target classes\n" +
                              "def build_model(input_shapes, n_classes=None):\n\n" +
                              startNetwork +
                              "    x = Dense(64, activation='relu')(" + lastLayerSoFar + ")\n" +
                              "    x = Dense(64, activation='relu')(x)\n" +
                              "\n" +
                              predictionLine + "\n" +
                              "\n" +
                              "    # The 'inputs' parameter of your model must contain the\n" +
                              "    # full list of inputs used in the architecture\n" +
                              "    model = Model(inputs=[" + actualInputsInNetwork.join(", ") + "], outputs=predictions)\n" +
                              "\n" +
                              "    return model\n" +
                              "\n" +
                              "# Compile your model and return it\n" +
                              "#   model   - model defined in 'build_model'\n" +
                              "def compile_model(model):\n" +
                              "    \n" +
                              "    # The loss function depends on the type of problem you solve.\n" +
                              "    # '" + lossFunction + "' is appropriate for a " + problemType + ".\n" +
                              "    model.compile(optimizer='rmsprop',\n" +
                              "                  loss='" + lossFunction + "')\n" +
                              "\n" +
                              "    return model";

            if (keepAndCommentPrevious && $scope.mlTaskDesign.modeling.keras.buildCode) {
                 buildCode = buildCode + "\n\n### PREVIOUS CODE\n" +
                    $scope.mlTaskDesign.modeling.keras.buildCode.replace(/^/gm, '# ');
            }

            $scope.mlTaskDesign.modeling.keras.buildCode = buildCode;
            $scope.saveSettings();
        }
    };

    $scope.switchFitMode = function() {
        if (!$scope.mlTaskDesign.modeling.keras.advancedFitMode) {
            fillFitCodeKeras();
        }
        $scope.mlTaskDesign.modeling.keras.advancedFitMode = !$scope.mlTaskDesign.modeling.keras.advancedFitMode;
    };

    $scope.editorOptions = CodeBasedEditorUtils.editorOptions('text/x-python', $scope, true);
    $scope.validateRecipe = function () {
        const deferred = $q.defer();
        try {
            $scope.runningValidation = true;
            DataikuAPI.analysis.pml.validateArchitecture(
                $scope.mlTaskDesign.modeling.keras.buildCode,
                $scope.mlTaskDesign.envSelection,
                $stateParams.projectKey
            ).success(data => {
                $scope.valCtx.showPreRunValidationError = false;
                $scope.valCtx.validationResult = data;
                deferred.resolve(data);
            }).error(setErrorInScope.bind($scope));
        } finally {
            $scope.runningValidation = false;
        }
        return deferred.promise;
    };

    $scope.gotoLine = function(cm, line) {
        if(cm && line>0) {
            var pos = {ch:0,line:line-1};
            cm.scrollIntoView(pos);
            cm.setCursor(pos);
            cm.focus();
        }
    };
    $scope.goToKerasArchitecture = function () {
        $scope.uiState.settingsPane = "keras-build";
        $scope.uiState.viewMode = "sessions";
    };

    $scope.$watch('mlTaskDesign', (nv) => {
        if (nv) {
            $scope.fillBuildCodeKeras();

            // Display Inputs area by default if there are more than one input
            if ($scope.mlTaskDesign && $scope.mlTaskDesign.modeling.keras && $scope.mlTaskDesign.modeling.keras.kerasInputs.length > 1) {
                $scope.uiState.displayInput = true;
            }
        }
    });

    // Required for architecture code validation:
    $scope.valCtx = {};
    $scope.recipe = {type:'python', params: {}}

    // Retrieving list of containers to know if computation will occur on a container or not
    let listContainersWithDefault = null;
    DataikuAPI.containers.listNamesWithDefault($stateParams.projectKey).success(function(data) {
                listContainersWithDefault = data;
    }).error(setErrorInScope.bind($scope));

    $scope.inContainer = function(selectedContainer) {
        if (selectedContainer.containerMode === "NONE" || listContainersWithDefault === null) {
            return false;
        } else if (selectedContainer.containerMode === "INHERIT") {
            return listContainersWithDefault.resolvedInheritValue != null;
        } else {
            return true;
        }
    };


});

app.controller("PMLTaskBaseController", function($scope, $timeout, $interval, $controller, DataikuAPI, PMLSettings, PMLFilteringService,
                                                 $state, $stateParams, TopNav, Collections, Dialogs, CreateModalFromTemplate, Fn, Logger, Debounce,
                                                 $q, CodeMirrorSettingService, Assert, Notification, StringUtils, $rootScope) {
    $scope.MLAPI = DataikuAPI.analysis.pml;
    $scope.FilteringService = PMLFilteringService;
    $scope.SettingsService = PMLSettings;
    $scope.codeMirrorSettingService = CodeMirrorSettingService;
    $scope.sRefPrefix = 'projects.project.analyses.analysis.ml.predmltask';
    $scope.algorithmCategories = PMLSettings.algorithmCategories;

    $scope.isXgboostGpuAllowed = function(){
        return $scope.mlTaskDesign.envSelection.envMode==="EXPLICIT_ENV";
    }

    $scope.isClassification = function(){
        if (!$scope.mlTaskDesign) return false;
        return $scope.mlTaskDesign.predictionType in {"BINARY_CLASSIFICATION":true, "MULTICLASS":true};
    }
    $scope.h2oEnabled = function(){
        if (!$scope.appConfig) return false;
        return $scope.appConfig.h2oEnabled;
    }
    $scope.isRegression = function(){
        if (!$scope.mlTaskDesign) return false;
        return $scope.mlTaskDesign.predictionType == "REGRESSION";
    }
    $scope.isBinaryClassification = function(){
        if (!$scope.mlTaskDesign) return false;
        return $scope.mlTaskDesign.predictionType == "BINARY_CLASSIFICATION";
    }
    $scope.isMulticlass = function(){
        if (!$scope.mlTaskDesign) return false;
        return $scope.mlTaskDesign.predictionType == "MULTICLASS";
    }

    $scope.isMLBackendType = function(mlBackendType){
        if (!$scope.mlTaskDesign) return false;
        return $scope.mlTaskDesign.backendType == mlBackendType;
    };

    $scope.isPythonBased = function(mlBackendType){
        return $scope.isMLBackendType('KERAS') || $scope.isMLBackendType('PY_MEMORY');
    };
    $scope.base_algorithms = {
        PY_MEMORY: [
            {name:'Random Forest', algKey:'random_forest_classification',condition:$scope.isClassification},
            {name:'Random Forest', algKey:'random_forest_regression',condition:$scope.isRegression},

            {name:'Gradient tree boosting', algKey:'gbt_classification',condition:$scope.isClassification},
            {name:'Gradient tree boosting', algKey:'gbt_regression',condition:$scope.isRegression},

            {name:'Logistic Regression', algKey:'logistic_regression',condition:$scope.isClassification},

            {name:'Ordinary Least Squares', algKey:'leastsquare_regression',condition:$scope.isRegression},
            {name:'Ridge Regression', algKey:'ridge_regression',condition:$scope.isRegression},
            {name:'Lasso Regression', algKey:'lasso_regression',condition:$scope.isRegression},

            {name:'XGBoost', algKey:'xgboost_classification',condition:$scope.isClassification, paramsName:'xgboost'},
            {name:'XGBoost', algKey:'xgboost_regression', condition: $scope.isRegression, paramsName:'xgboost'},

            {name:'Decision Tree', algKey:'decision_tree_classification',condition:$scope.isClassification},
            {name:'Decision Tree', algKey:'decision_tree_regression',condition:$scope.isRegression},

            {name:'Support Vector Machine', algKey:'svc_classifier',condition:$scope.isClassification, paramsName:'svc_classifier'},
            {name:'Support Vector Machine', algKey:'svm_regression',condition:$scope.isRegression, paramsName:'svm_regression'},

            {name:'Stochastic Gradient Descent', algKey:'sgd_classifier',condition:$scope.isClassification},
            {name:'Stochastic Gradient Descent', algKey:'sgd_regression',condition:$scope.isRegression},

            {name:'KNN', algKey:'knn'},
            {name:'Extra Random Trees', algKey:'extra_trees'},
            {name:'Neural Network', algKey:'neural_network'},
            {name:'Lasso Path', algKey:'lars_params'},
            {name:'Deep Learning (H2O)', algKey:'deep_learning_h2o',condition:$scope.h2oEnabled},
            {name:'GLM (H2O)',  algKey:'glm_h2o',condition:function(){return $scope.h2oEnabled()&&$scope.isRegression()}},
            {name:'Gradient Boosting (H2O)',  algKey:'gbm_h2o',condition:$scope.h2oEnabled},
            {name:'Random Forest (H2O)',  algKey:'distributed_rf_h2o',condition:$scope.h2oEnabled},
        ],
        MLLIB: [
            {name:'Linear Regression',algKey:'mllib_linreg',condition:$scope.isRegression},
            {name:'Logistic Regression',algKey:'mllib_logit',condition:$scope.isClassification},
            {name:'Decision Tree',algKey:'mllib_dt'},
            {name:'Random Forest',algKey:'mllib_rf'},
            {name:'Gradient tree boosting',algKey:'mllib_gbt',condition:Fn.not($scope.isMulticlass)},
            {name:'Naive Bayes',algKey:'mllib_naive_bayes',condition:$scope.isMulticlass},
        ],
        H2O :[
            {name:'Deep Learning',algKey:'deep_learning_sparkling'},
            {name:'Generalized Linear Model',algKey:'glm_sparkling'},
            {name:'Gradient Boosting',algKey:'gbm_sparkling'},
            {name:'Random Forest',algKey:'rf_sparkling'},
            {name:'Naive Bayes',algKey:'nb_sparkling',condition:$scope.isClassification},
        ],
        KERAS: [
            {name: "Deep Learning with Keras", algKey: "keras"}
        ]
    };

    function enrichBaseAlgorithmsWithPlugins() {
        DataikuAPI.analysis.pml.listCustomPythonAlgos($stateParams.projectKey).success(function(data) {
            // Add custom algorithms from plugins if they are not here
            data.map(alg => {
                return {
                    algKey: alg.pyPredAlgoType,
                    name: alg.desc.meta.label,
                    customInfo: alg,
                    pluginDesc: $rootScope.appConfig.loadedPlugins.find(plugin => plugin.id === alg.ownerPluginId),
                    condition: function() {
                        const regCond = alg.desc.predictionTypes.includes("REGRESSION") && $scope.isRegression();
                        const binCond = alg.desc.predictionTypes.includes("BINARY_CLASSIFICATION") && $scope.isBinaryClassification();
                        const multCond = alg.desc.predictionTypes.includes("MULTICLASS") && $scope.isMulticlass();
                        return regCond || binCond || multCond;
                    }
                }
            }).filter(alg => ! $scope.base_algorithms["PY_MEMORY"].map(_ => _.algKey).includes(alg.algKey))
              .forEach(alg => {
                  // Adding Custom algos to algo list
                  $scope.base_algorithms["PY_MEMORY"].push(alg);

                  // Adding custom algo without sample weights support to dedicated list
                  if (!alg.customInfo.desc.supportsSampleWeights) {
                      $scope.algosWithoutWeightSupport.add(alg.algKey);
                  }
              });
        }).error(setErrorInScope.bind($scope));
    }

    $scope.algosWithoutWeightSupport = new Set(['lasso_regression', 'knn', 'neural_network', 'lars_params']);

    enrichBaseAlgorithmsWithPlugins();

    $scope.$watch("mlTaskDesign.backendType", function (nv, ov) {
        if (nv) {
            if (nv !== ov && nv === 'KERAS') {
                $controller("DeepLearningPMLController", {$scope: $scope});
            }
        }
    }, true);

    $controller("_MLTaskBaseController",{$scope:$scope});

    $scope.beforeUpdateSettingsCallback = function(settings) {
        $scope.fillUISplitParams(settings.splitParams);
    };

    $scope.onChangePredictionType = function(){
        if ($scope.dirtySettings()) {
            $scope.saveSettings();
        }
        CreateModalFromTemplate("/templates/analysis/prediction/change-target-or-type-modal.html", $scope, null, function(newScope) {
            newScope.newType = $scope.uiState.predictionType;
            // allows to retrieve the old prediction type if the modal is exited by clicking outside of it
            $scope.uiState.predictionType = $scope.mlTaskDesign.predictionType;
            newScope.change = "prediction type";
            newScope.loseMetrics = true;
            newScope.loseAssertions = true;
            newScope.loseAlgo = $scope.mlTaskDesign.backendType !== "KERAS"
                                && ((newScope.newType === "REGRESSION") !== $scope.isRegression());
            newScope.loseArchitecture = $scope.mlTaskDesign.backendType === "KERAS";
            newScope.loseWeight = ($scope.mlTaskDesign.weight.weightMethod === "CLASS_WEIGHT" || $scope.mlTaskDesign.weight.weightMethod === "CLASS_AND_SAMPLE_WEIGHT")
                                                    && newScope.loseAlgo;
            newScope.confirm = function(redetect) {
                DataikuAPI.analysis.pml.reguessWithType($stateParams.projectKey, $stateParams.analysisId,
                    $stateParams.mlTaskId, newScope.newType, redetect).then(function(response){
                        $scope.setMlTaskDesign(response.data);
                        $scope.uiState.predictionType = $scope.mlTaskDesign.predictionType;

                        if ($scope.mlTaskDesign.backendType === "KERAS") {
                            $scope.fillBuildCodeKeras(true);
                        }
                        $scope.saveSettings();
                        $scope.uiState.algorithm = $scope.base_algorithms[$scope.mlTaskDesign.backendType]
                            .find(_ => !_.condition || _.condition()).algKey;
                        $scope.customCodeSnippetCategories = [$scope.isRegression() ? "py-regressor" : "py-classifier"];
                }, setErrorInScope.bind($scope));
                newScope.dismiss();
            };
            newScope.cancel = function() {
                $scope.uiState.predictionType = $scope.mlTaskDesign.predictionType;
                newScope.dismiss();
            };
        });
    };

    $scope.onChangeTargetFeature = function() {
        if ($scope.dirtySettings()) {
            $scope.saveSettings();
        }
        CreateModalFromTemplate("/templates/analysis/prediction/change-target-or-type-modal.html", $scope, null, function(newScope) {
            newScope.targetVariable = $scope.uiState.targetVariable;
            // allows to retrieve the old target variable if the modal is exited by clicking outside of it
            $scope.uiState.targetVariable = $scope.mlTaskDesign.targetVariable;
            newScope.renameMLTask = true;
            newScope.loseAssertions = true;
            newScope.change = "target";
            newScope.loseWeight = $scope.mlTaskDesign.weight.sampleWeightVariable === newScope.targetVariable;
            newScope.loseArchitecture = $scope.mlTaskDesign.backendType === "KERAS";
            newScope.oldName = $scope.mlTaskDesign.targetVariable;
            newScope.newName = StringUtils.transmogrify("Predict " + newScope.targetVariable,
                                                        $scope.mlTasksContext.analysisMLTasks.map(_ => _.name));
            newScope.confirm = function(redetect) {
                DataikuAPI.analysis.pml.reguessWithTarget($stateParams.projectKey, $stateParams.analysisId,
                    $stateParams.mlTaskId, newScope.targetVariable, redetect).then(function(response){
                        $scope.setMlTaskDesign(response.data);
                        if (newScope.renameMLTask) {
                            $scope.mlTaskDesign.name = newScope.newName;

                        }
                        if ($scope.mlTaskDesign.backendType === "KERAS") {
                            $scope.fillBuildCodeKeras(true);
                        }
                        $scope.saveSettings();
                        $scope.uiState.targetVariable = $scope.mlTaskDesign.targetVariable;
                        $scope.uiState.algorithm = $scope.base_algorithms[$scope.mlTaskDesign.backendType]
                            .find(_ => !_.condition || _.condition()).algKey;
                    $scope.customCodeSnippetCategories = [$scope.isRegression() ? "py-regressor" : "py-classifier"];
                }, setErrorInScope.bind($scope));
                newScope.dismiss();
            };
            newScope.cancel = function() {
                $scope.uiState.targetVariable = $scope.mlTaskDesign.targetVariable;
                newScope.dismiss();
            };
        });
    };
    $scope.checkSplitParams = function(splitParams, checkSingle) {
        if (!splitParams) {
            throw new Error('No split params');
        }
        var error = null;
        if (splitParams.ttPolicy === 'EXPLICIT_FILTERING_TWO_DATASETS') {
            if (!splitParams.eftdTest || !splitParams.eftdTest.datasetSmartName) {
                error = 'No test dataset specified.';
            }
            if (!splitParams.eftdTrain || !splitParams.eftdTrain.datasetSmartName) {
                error = error ? 'No train nor test dataset specified.' : 'No train dataset specified.';
            }
        } else if (checkSingle) { // not in settings, so EFSD_MAIN / SPLIT_MAIN should have filled the dataset
            if (    ('ssdDatasetSmartName' in splitParams && !splitParams.ssdDatasetSmartName)
                 || ('efsdDatasetSmartName' in splitParams && !splitParams.efsdDatasetSmartName)) {
                error = 'No dataset specified.';
            }
        } else if ( ($scope.uiSplitParams.policy === "SPLIT_OTHER_DATASET" && !splitParams.ssdDatasetSmartName)
                    || ($scope.uiSplitParams.policy === "EXPLICIT_FILTERING_SINGLE_DATASET_OTHER" && !splitParams.efsdDatasetSmartName)) {
            error = 'No dataset specified.';    // in settings + in explicit dataset
        }
        if (error) {
            Dialogs.ack($scope, 'Incorrect Train/Test settings', error);
            return false;
        }
        return true;
    };
    $scope.dumpUISplitParams = function(){
        const sp = $scope.mlTaskDesign.splitParams;
        if (!sp) {
            throw new Error('No split params');
        }
        if ($scope.uiSplitParams.policy == "SPLIT_MAIN_DATASET") {
            sp.ttPolicy = "SPLIT_SINGLE_DATASET";
            sp.ssdDatasetSmartName = null;
        } else if ($scope.uiSplitParams.policy == "SPLIT_OTHER_DATASET") {
            sp.ttPolicy = "SPLIT_SINGLE_DATASET";
        } else if ($scope.uiSplitParams.policy == "EXPLICIT_FILTERING_SINGLE_DATASET_MAIN") {
            sp.ttPolicy = "EXPLICIT_FILTERING_SINGLE_DATASET";
            sp.efsdDatasetSmartName = null;
        } else if ($scope.uiSplitParams.policy == "EXPLICIT_FILTERING_SINGLE_DATASET_OTHER") {
            sp.ttPolicy = "EXPLICIT_FILTERING_SINGLE_DATASET";
        } else {
            sp.ttPolicy = $scope.uiSplitParams.policy;
        }
        Logger.info("DUMP UI SPLIT", sp, $scope.uiSplitParams);
    };
    $scope.saveSettings = function() {
        Assert.inScope($scope, "mlTaskDesign");
        $scope.dumpUISplitParams();

        return DataikuAPI.analysis.pml.saveSettings($stateParams.projectKey, $stateParams.analysisId, $scope.mlTaskDesign)
            .success(function(data){
                resetErrorInScope($scope);
                $scope.savedSettings = dkuDeepCopy($scope.mlTaskDesign, PMLSettings.noDollarKey);
                $scope.listMLTasks();
            }).error(setErrorInScope.bind($scope));
    };

    $scope.newTrainSessionModalDisplayed = false;

    $scope.onTrainModalResolution = function() {
        $scope.newTrainSessionModalDisplayed = false;
        $scope.uiState.$userRequestedState = false;
        $scope.initialRefreshAndAutoRefresh();
        if ($state.current.name !== $scope.sRefPrefix + '.list.results') {
            $state.go($scope.sRefPrefix + '.list.results');
        } else {
            $scope.uiState.viewMode = "sessions";
        }
    };

    function newTrainSessionCallback() {
        return DataikuAPI.analysis.pml.getUpdatedSettings($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId).then(function(response){
            if ($scope.checkSplitParams(response.data.splitParams, true)) {
                DataikuAPI.analysis.pml.saveSettings($stateParams.projectKey, $stateParams.analysisId, response.data).success(function(data){
                    $scope.savedSettings = dkuDeepCopy($scope.mlTaskDesign, PMLSettings.noDollarKey);
                    if (!$scope.newTrainSessionModalDisplayed) {
                        $scope.newTrainSessionModalDisplayed = true;
                        CreateModalFromTemplate("/templates/analysis/prediction/pre-train-modal.html", $scope, "PMLTaskPreTrainModal").then(function() {
                            $scope.onTrainModalResolution();
                        }, function(){
                            $scope.newTrainSessionModalDisplayed = false;
                        });
                    }
                }).error(setErrorInScope.bind($scope));
            }
        },setErrorInScope.bind($scope));
    }
    $scope.newTrainSession = function() {
        if ($scope.dirtySettings()) { $scope.saveSettings().then(newTrainSessionCallback) }
        else { newTrainSessionCallback() }
    };

    $scope.uiSplitParams = {};

    // watchers & init

    DataikuAPI.analysis.mlcommon.getLastPreprocessingStatus($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId)
        .success(function(data){ $scope.lastPreprocessingStatus = data; })
        .error(setErrorInScope.bind($scope));

    $scope.fillUISplitParams = function(splitParams) {
        if (!splitParams) {
            throw new Error('No split params');
        }
        if (splitParams.ttPolicy == 'SPLIT_SINGLE_DATASET') {
            if (splitParams.ssdDatasetSmartName == null) {
                $scope.uiSplitParams.policy = "SPLIT_MAIN_DATASET";
            } else {
                $scope.uiSplitParams.policy = "SPLIT_OTHER_DATASET";
            }
        } else if (splitParams.ttPolicy == "EXPLICIT_FILTERING_SINGLE_DATASET") {
            if (splitParams.efsdDatasetSmartName == null) {
                $scope.uiSplitParams.policy = "EXPLICIT_FILTERING_SINGLE_DATASET_MAIN";
            } else {
                $scope.uiSplitParams.policy = "EXPLICIT_FILTERING_SINGLE_DATASET_OTHER";
            }
        } else {
            $scope.uiSplitParams.policy = splitParams.ttPolicy;
        }
    };

    // to be run if not guessing
    $scope.initMlTaskDesign = function() {
        $scope.$watch("analysisCoreParams", function(nv, ov) {
            if (!nv) return;
            DataikuAPI.analysis.pml.getUpdatedSettings($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId).success(function(data){
                $scope.setMlTaskDesign(data);
                
                DataikuAPI.analysis.pml.listGuessPolicies().success(data => {
                    $scope.guessPolicies = data.auto.concat(data.expert).filter(policy => ![
                        'ALGORITHMS', // useless (choose from all)
                        'DEEP' // incompatible interface
                    ].includes(policy.id));
                    $scope.guessPolicies = $scope.prepareGuessPolicies($scope.guessPolicies);
                }).error(setErrorInScope.bind($scope));    

                $scope.savedSettings = dkuDeepCopy($scope.mlTaskDesign, PMLSettings.noDollarKey);
                if (data.backendType in $scope.base_algorithms) {
                    $scope.uiState.algorithm = $scope.base_algorithms[data.backendType]
                        .filter(function (o) {
                            return (!o.condition || o.condition())
                        })[0].algKey;
                    $scope.fillUISplitParams($scope.mlTaskDesign.splitParams);
                    $scope.customCodeSnippetCategories = [$scope.isRegression() ? "py-regressor" : "py-classifier"];
                }
            }).error(setErrorInScope.bind($scope));
        });
    }

    // Weighting strategy
    $scope.setWeightOptions = function(){
        if($scope.isRegression()) {
            $scope.uiState.weightMethods = [['NO_WEIGHTING', 'No weighting'],
                                            ['SAMPLE_WEIGHT', 'Sample weights']];
        } else {
          $scope.uiState.weightMethods = [['NO_WEIGHTING', 'No weighting'],
                                          ['SAMPLE_WEIGHT', 'Sample weights'],
                                          ['CLASS_WEIGHT', 'Class weights'],
                                          ['CLASS_AND_SAMPLE_WEIGHT', 'Class and sample weights'],
                                        ];
        }
    }

    $scope.$watch('mlTaskDesign.predictionType', (nv) => {
        if (nv) {
            $scope.setWeightOptions();
        }
    });

    $scope.$watch('mlTaskDesign.partitionedModel', Debounce().withScope($scope).withDelay(300, 300).wrap((nv, ov) => {
        if (nv) {
            if (nv.enabled) {
                const sampleSelection = $scope.mlTaskDesign.splitParams.ssdSelection;
                const partitionSelection = nv.ssdSelection;

                const partitionModelSettings = {
                    partitionSelectionMethod: partitionSelection.partitionSelectionMethod,
                    selectedPartitions: partitionSelection.selectedPartitions,
                    latestPartitionsN: partitionSelection.latestPartitionsN
                }
    
                // set sample partition method to partition model partition method
                Object.assign(sampleSelection, partitionModelSettings);
            } else if (ov && ov.enabled && !nv.enabled) {
                // partitioned models unchecked
                $scope.mlTaskDesign.splitParams.ssdSelection.partitionSelectionMethod = 'ALL';
            }
        } 
    }), true)

    $scope.onChangeWeightMethod = function() {
      if($scope.uiState.weightMethod==="NO_WEIGHTING" || $scope.uiState.weightMethod==="CLASS_WEIGHT"){
          // free previous weight variable by setting its role as INPUT
          if($scope.mlTaskDesign.weight.sampleWeightVariable) {
              if ($scope.mlTaskDesign.preprocessing.per_feature[$scope.mlTaskDesign.weight.sampleWeightVariable]) {
                  $scope.mlTaskDesign.preprocessing.per_feature[$scope.mlTaskDesign.weight.sampleWeightVariable].role = "INPUT";
              }
          }
          // reinitialize the weight variable params in UI and mlTaskDesign
          $scope.uiState.sampleWeightVariable = null;
          $scope.mlTaskDesign.weight.sampleWeightVariable = null;
      }
      $scope.mlTaskDesign.weight.weightMethod = $scope.uiState.weightMethod;
      $scope.saveSettings();
    };

    $scope.onChangeSampleWeightVariable = function() {
        if($scope.uiState.sampleWeightVariable){
            var deferred = $q.defer();
            CreateModalFromTemplate("/templates/analysis/prediction/change-weight-modal.html", $scope, null, function(newScope) {
                newScope.deferred = deferred;
                newScope.confirm = function() {
                    // free previous weight variable by setting its role as INPUT
                    if($scope.mlTaskDesign.weight.sampleWeightVariable){
                        if ($scope.mlTaskDesign.preprocessing.per_feature[$scope.mlTaskDesign.weight.sampleWeightVariable]) {
                            $scope.mlTaskDesign.preprocessing.per_feature[$scope.mlTaskDesign.weight.sampleWeightVariable].role = "INPUT";
                        }
                    }
                    $scope.mlTaskDesign.weight.sampleWeightVariable = $scope.uiState.sampleWeightVariable;
                    let featureData = $scope.mlTaskDesign.preprocessing.per_feature[$scope.uiState.sampleWeightVariable];
                    featureData.role = "WEIGHT";
                    if (featureData.type != "NUMERIC") {
                        featureData.missing_handling = "IMPUTE";
                        featureData.missing_impute_with = "MEAN";
                        featureData.numerical_handling = "REGULAR";
                        featureData.rescaling = "AVGSTD";
                        featureData.type = "NUMERIC";
                    }
                    $scope.saveSettings();
                    newScope.deferred.resolve("changed")
                    newScope.dismiss();
                };
                newScope.cancel = function() {
                    newScope.deferred.reject("cancelled")
                    newScope.dismiss();
                };
                newScope.$on("$destroy",function() {
                    if(newScope.deferred) {
                        newScope.deferred.reject("destroyed");
                    }
                    newScope.deferred = null;
                });
            });
            deferred.promise.then(function(a) {
                // nothing to do here
            }, function(a) {
                // reset the UI weight variable to the saved weight variable
                $scope.uiState.sampleWeightVariable = $scope.mlTaskDesign.weight.sampleWeightVariable;
            });
        }
    };

    $scope.isSampleWeightEnabled = function() {
        var weightMethod = $scope.mlTaskDesign.weight.weightMethod;
        return weightMethod=='SAMPLE_WEIGHT' || weightMethod=='CLASS_AND_SAMPLE_WEIGHT';
    }

    $scope.potentialWeightFeatures = function() {
        var per_feature = $scope.mlTaskDesign.preprocessing.per_feature;
        return Object.keys(per_feature).filter(x=>per_feature[x].role!=="TARGET");
    }

    $scope.uiState.calibrationMethods = [['NO_CALIBRATION', 'None'], ['SIGMOID', 'Sigmoid (Platt scaling)'], ['ISOTONIC', 'Isotonic Regression']];

    $scope.isCalibrationEnabled = function() {
        return $scope.mlTaskDesign.calibration.calibrationMethod!='NO_CALIBRATION';
    }

    //Time-based Ordering
    $scope.uiState.gsModes = [['TIME_SERIES_SINGLE_SPLIT', 'Time-based train/validation split'], ['TIME_SERIES_KFOLD', 'Time-based K-fold (with overlap)']];

    $scope.isTimeOrderingEnabled = function() {
        return !!$scope.mlTaskDesign.time && $scope.mlTaskDesign.time.enabled;
    };

    $scope.isTimeVariable = function(feature) {
        return !!$scope.mlTaskDesign.time && $scope.mlTaskDesign.time.enabled && $scope.mlTaskDesign.time.timeVariable == feature._name;
    };

});


app.controller("PMLTaskResultController", function($scope, $timeout, $controller, DataikuAPI, PMLSettings, PMLFilteringService,
            $state, $stateParams, TopNav, Collections, Dialogs, CreateModalFromTemplate, Fn, Logger, WT1, FutureWatcher, $q) {

    angular.extend($scope, PMLSettings.taskF($scope.mlTasksContext.activeMLTask.backendType));
    angular.extend($scope, PMLSettings.task);
    $scope.metricMap = PMLFilteringService.metricMap;
    $controller("_MLTaskResultsController",{$scope:$scope});

    let tensorboardUrls = {};
    $scope.getTensorboardUrl = function(sessionId) {
        if (sessionId in tensorboardUrls) {
            return tensorboardUrls[sessionId];
        }
        tensorboardUrls[sessionId] = null;
        let webAppId = `TENSORBOARD_${$scope.analysisCoreParams.projectKey}-${$stateParams.analysisId}-${$stateParams.mlTaskId}-${sessionId}`
        DataikuAPI.webapps.getBackendUrl($scope.analysisCoreParams.projectKey, webAppId, null).success(function(data) {
            $timeout(function() {
                tensorboardUrls[sessionId] = data.location;
            });
        }).error(setErrorInScope.bind($scope));
        return null;
    };
    $scope.canShowTensorboard = function () {
        return $scope.sessionTask.backendType === 'KERAS';
    };

    $scope.$watch('sessionTask', (nv) => {
        if (nv) {
            if (nv.tensorboardStatus === undefined) {
                nv.tensorboardStatus = {
                    isShown: false,
                    isBackendReady: false,
                    isFrontendReady: false,
                    showIfFrontIsNotReady: false,
                    fullScreen: false
                };
            } else {
                nv.tensorboardStatus.isFrontendReady = false;
                nv.tensorboardStatus.showIfFrontIsNotReady = true;
            }
        }
    });

    $scope.showHideTensorboard = function () {
        $scope.sessionTask.tensorboardStatus.showIfFrontIsNotReady = false;
        $scope.sessionTask.tensorboardStatus.fullScreen = false;
        $scope.sessionTask.tensorboardStatus.isBackendReady = false;
        $scope.sessionTask.tensorboardStatus.isFrontendReady = false;
        $scope.sessionTask.tensorboardStatus.isShown = !$scope.sessionTask.tensorboardStatus.isShown;
        if ($scope.sessionTask.tensorboardStatus.isShown) {
            let sessionId = $scope.selection.sessionModels[0].sessionId;
            DataikuAPI.webapps.startTensorboard($scope.analysisCoreParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId, sessionId).success(function (result) {
                if (result && result.jobId && !result.hasResult) { // There is a backend still starting, wait for it
                    FutureWatcher.watchJobId(result.jobId)
                        .success(function (data) {
                            $scope.sessionTask.tensorboardStatus.isBackendReady = true;
                        }).error(function (data, status, headers, config, statusText, xhrStatus) {
                        $scope.sessionTask.tensorboardStatus.isShown = false;
                        setErrorInScope.bind($scope)(data, status, headers, config, statusText, xhrStatus);
                    })
                } else {
                    $scope.sessionTask.tensorboardStatus.isBackendReady = true;
                }
            }).error(setErrorInScope.bind($scope));
        }

    };
    $scope.anySessionModelNeedsHyperparameterSearch = function () {
        return ($scope.selection.sessionModels || []).some(function (x) {
            return (x.gridLength != 1 || x.pluginAlgoCustomGridSearch) && !x.partitionedModelEnabled;
        })
    };
    $scope.anySessionModelHasOptimizationResults = function () {
        if ($scope.isMLBackendType("KERAS")) {
            return ($scope.selection.sessionModels || []).some(function (x) {
                return x.modelTrainingInfo;
            });
        } else {
            return ($scope.selection.sessionModels || []).some(function (x) {
                return x.gridsearchData && x.gridsearchData.gridPoints && x.gridsearchData.gridPoints.length > 0;
            })
        }
    };

    $scope.anyModelHasOneEpochFinished = function() {
        return ($scope.selection.sessionModels || []).some(function(model) {
            return (model.modelTrainingInfo && model.modelTrainingInfo.epochs && model.modelTrainingInfo.epochs.length > 0);
        });
    };

    $scope.anyModelHasAllEpochsFinished = function() {
        return ($scope.selection.sessionModels || []).some(function(model) {
            return (model.modelTrainingInfo && model.modelTrainingInfo.nbEpochs == model.modelTrainingInfo.epochs.length);
        });
    };

    $scope.anyModelHasFailedOrAborted = function() {
        return $scope.anyModelHasFailed() || $scope.anyModelAborted();
    }

    $scope.anyModelHasFailed = function() {
        return ($scope.selection.sessionModels || []).some(function(model) {
            return model.trainInfo.state === 'FAILED';
        });
    };

    $scope.anyModelAborted = function() {
        return ($scope.selection.sessionModels || []).some(function(model) {
            return model.trainInfo.state === 'ABORTED';
        });
    }

    $scope.stopGridSearch = function(fullModelIds, setUiState = false) {
        Dialogs.confirm($scope, "Suspend optimization for this model",
            "Do you want to suspend the optimization for this model?").then(function() {
                WT1.event("stop-grid-search", {});
                DataikuAPI.analysis.mlcommon.stopGridSearch(fullModelIds)
                    .success(() => {
                        fullModelIds.forEach(fmi => { $scope.modelSnippets[fmi].trainInfo.$userRequestedState = "FINALIZE" });
                        if (setUiState) {
                            $scope.uiState.$userRequestedState = 'FINALIZE';
                        }
                        $scope.refreshStatus();
                    }).error(setErrorInScope.bind($scope));
            });
    };

    $scope.retrainModel = function(sessionId, fullModelIds, setUiState = false) {
        WT1.event("start-retrain-model", {});
        return DataikuAPI.analysis.pml.retrainStart($scope.analysisCoreParams.projectKey,
            $scope.analysisCoreParams.id, $stateParams.mlTaskId, sessionId, fullModelIds)
            .success(() => {
                fullModelIds.forEach(fmi => { $scope.modelSnippets[fmi].trainInfo.$userRequestedState = false });
                if (setUiState) {
                    $scope.uiState.$userRequestedState = false;
                }
                $scope.initialRefreshAndAutoRefresh();
            }).error(setErrorInScope.bind($scope));
    };

    $scope.stopGridSearchSession = function(sessionId) {
        const fullModelIds = $scope.selection.allObjects
            .filter(model => model.sessionId === sessionId && $scope.isModelOptimizing(model))
            .map(Fn.prop('fullModelId'));

        $scope.stopGridSearch(fullModelIds, true);
    };

    $scope.retrainSession = function(sessionId) {
        const fullModelIds = $scope.selection.allObjects
            .filter(function(model) {
                return model.sessionId === sessionId
                    && ($scope.isModelOptimizationResumable(model) || $scope.isModelRetrainable(model));
            })
            .map(Fn.prop('fullModelId'));

        $scope.retrainModel(sessionId, fullModelIds, true);
    };
});

app.controller("PMLTaskDesignController", function($scope, $timeout, $controller, Assert, DataikuAPI, PMLSettings, PMLFilteringService,
            $state, $stateParams, TopNav, Collections, Dialogs, CreateModalFromTemplate, Fn, Logger, WT1) {
    $scope.$state = $state;
    angular.extend($scope, PMLSettings.taskF($scope.mlTasksContext.activeMLTask.backendType));
    angular.extend($scope, PMLSettings.task);
    $controller("_MLTaskDesignController",{$scope:$scope});
    $scope.reguessAll = function(){
        Dialogs.confirm($scope, "Reguess settings", "Are you sure you want to reguess all settings ? Your changes will be lost.").then(function(){
            DataikuAPI.analysis.pml.reguessWithType($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId,
                $scope.mlTaskDesign.predictionType, true).success(function(data){
                    $scope.setMlTaskDesign(data);
                    $scope.savedSettings = dkuDeepCopy($scope.mlTaskDesign, PMLSettings.noDollarKey);
                })
        });
    };

    $scope.isValidMetric = function(metric){
        return !($scope.isSparkBased() && metric[0] == "CUSTOM");
    };

    $scope.uiState.generatorPage = "manual_interactions";

    $scope.countNumericCombinations = function() {
        var n = Object.keys($scope.mlTaskDesign.preprocessing.per_feature)
                    .map(Fn(Fn.dict($scope.mlTaskDesign.preprocessing.per_feature), Fn.prop('type')))
                    .filter(Fn.eq('NUMERIC')).length;
        return n < 2 ? 0 : (n * (n-1) / 2); // n take 2
    };

    $scope.addInteraction = function(){
        var prep = $scope.mlTaskDesign.preprocessing;
        var fs = Object.keys(prep.per_feature).filter(function(f){ return prep.per_feature[f].role == "INPUT"; });
        var interaction = {
            column_1: fs[0],
            column_2: fs.length > 1 ? fs[1] : fs[0],
            rescale: true,
            max_features: 100
        }
        var ints = prep.feature_generation.manual_interactions.interactions;
        if(!ints){
            ints = [];
            prep.feature_generation.manual_interactions.interactions = ints;
        }
        ints.push(interaction);
    };

    $scope.activeFeatures = function(){
        var feats = [];
        for(var f in $scope.mlTaskDesign.preprocessing.per_feature){
            if($scope.mlTaskDesign.preprocessing.per_feature[f].role == 'INPUT'){
                feats.push(f);
            }
        }
        feats.sort();
        return feats;
    };

    $scope.removeInteraction = function(i){
        $scope.mlTaskDesign.preprocessing.feature_generation.manual_interactions.interactions.splice(i, 1);
    };

    $scope.willDummify = function(interaction){
        var isNumeric = function(f){
            return $scope.mlTaskDesign.preprocessing.per_feature[f].type == "NUMERIC";
        };
        return ! (isNumeric(interaction.column_1) && isNumeric(interaction.column_2));
    };

    $scope.addCustomPython = function() {
        $scope.mlTaskDesign.modeling.custom_python = $scope.mlTaskDesign.modeling.custom_python || [];

        var code = null;
        if ($scope.isRegression()){
            code = "# This sample code uses a standard scikit-learn algorithm, the Adaboost regressor.\n\n" +
                   "# Your code must create a 'clf' variable. This clf must be a scikit-learn compatible\n" +
                   "# model, ie, it should:\n" +
                   "#  1. have at least fit(X,y) and predict(X) methods\n" +
                   "#  2. inherit sklearn.base.BaseEstimator\n" +
                   "#  3. handle the attributes in the __init__ function\n" +
                   "#     See: https://doc.dataiku.com/dss/latest/machine-learning/custom-models.html\n\n" +
                   "from sklearn.ensemble import AdaBoostRegressor\n\n"+
                   "clf = AdaBoostRegressor(n_estimators=20)\n"
        } else {
            code = "# This sample code uses a standard scikit-learn algorithm, the Adaboost classifier.\n\n" +
                   "# Your code must create a 'clf' variable. This clf must be a scikit-learn compatible\n" +
                   "# classifier, ie, it should:\n" +
                   "#  1. have at least fit(X,y) and predict(X) methods\n" +
                   "#  2. inherit sklearn.base.BaseEstimator\n" +
                   "#  3. handle the attributes in the __init__ function\n" +
                   "#  4. have a classes_ attribute\n" +
                   "#  5. have a predict_proba method (optional)\n" +
                   "#     See: https://doc.dataiku.com/dss/latest/machine-learning/custom-models.html\n\n" +
                   "from sklearn.ensemble import AdaBoostClassifier\n\n" +
                   "clf = AdaBoostClassifier(n_estimators=20)\n"
        }

        var expectedAlgKey = 'custom_python_' + $scope.mlTaskDesign.modeling.custom_python.length;
        $scope.uiState.algorithm = expectedAlgKey;
        $scope.mlTaskDesign.modeling.custom_python.push({
            enabled: true,
            name: "Custom Python model",
            code: code
        });
    };

    $scope.addCustomMLLib = function() {
        $scope.mlTaskDesign.custom_mllib = $scope.mlTaskDesign.custom_mllib || [];

        let code = null;
        if ($scope.isRegression()) {
            code = "// This sample code uses a standard MLlib algorithm, the RandomForestRegressor.\n\n" +
                   "// import the Estimator from spark.ml\n" +
                   "import org.apache.spark.ml.regression.RandomForestRegressor\n\n" +
                   "// instantiate the Estimator\n" +
                   "new RandomForestRegressor()\n" +
                   "   .setLabelCol(\"" + $scope.mlTaskDesign.targetVariable + "\")  // Must be the target column\n" +
                   "   .setFeaturesCol(\"__dku_features\")  // Must always be __dku_features\n" +
                   "   .setPredictionCol(\"prediction\")  // Must always be prediction\n" +
                   "   .setNumTrees(50)\n" +
                   "   .setMaxDepth(8)";
       } else {
            code = "// This sample code uses a standard MLlib algorithm, the RandomForestClassifier.\n\n" +
                   "// import the Estimator from spark.ml\n" +
                   "import org.apache.spark.ml.classification.RandomForestClassifier\n\n" +
                   "// instantiate the Estimator\n" +
                   "new RandomForestClassifier()\n" +
                   "   .setLabelCol(\"" + $scope.mlTaskDesign.targetVariable + "\")  // Must be the target column\n" +
                   "   .setFeaturesCol(\"__dku_features\")  // Must always be __dku_features\n" +
                   "   .setPredictionCol(\"prediction\")    // Must always be prediction\n" +
                   "   .setNumTrees(50)\n" +
                   "   .setMaxDepth(8)";
       }

        var expectedAlgKey = 'custom_mllib_' + $scope.mlTaskDesign.modeling.custom_mllib.length;
        $scope.uiState.algorithm = expectedAlgKey;
        $scope.mlTaskDesign.modeling.custom_mllib.push({
            enabled: true,
            name: "Custom MLlib model",
            initializationCode: code
        });
    };

    $scope.getAlgorithmTemplate = function() {
        if (!$scope.uiState || !$scope.uiState.algorithm) {
            return;
        } else if ($scope.uiState.algorithm.startsWith("CustomPyPredAlgo_")) {
            return '/templates/analysis/prediction/settings/algorithms/'+$scope.mlTaskDesign.backendType.toLowerCase()+'/plugin-model.html'

        } else if ($scope.uiState.algorithm.startsWith("custom")) {
            return '/templates/analysis/prediction/settings/algorithms/'+$scope.mlTaskDesign.backendType.toLowerCase()+'/custom.html'
        } else {
            Assert.inScope($scope, 'algorithms');
            const availableAlgorithms = $scope.algorithms[$scope.mlTaskDesign.backendType];
            const alg = Collections.indexByField(availableAlgorithms, 'algKey')[$scope.uiState.algorithm];
            if ($scope.uiState.algorithm.startsWith("xgboost")) {
                return '/templates/analysis/prediction/settings/algorithms/'+$scope.mlTaskDesign.backendType.toLowerCase()+'/xgboost.html';
            } else {
                return '/templates/analysis/prediction/settings/algorithms/'+$scope.mlTaskDesign.backendType.toLowerCase()+'/'+(alg.paramsName || $scope.uiState.algorithm)+'.html'
            }
        }
    };


    $scope.copyAlgorithmSettings = function(exportSettings) {
        if ($scope.dirtySettings()) {
                $scope.saveSettings();
        }
        DataikuAPI.projects.listHeads(exportSettings ? 'WRITE_CONF' : null).success(function(projectData) {
             CreateModalFromTemplate("/templates/analysis/mlcommon/settings/copy-settings.html", $scope, null, function(newScope) {
                 newScope.projects = projectData;
                 newScope.title = newScope.title = "Copy "
                                + ($scope.mlTaskDesign.backendType === "KERAS" ? "architecture " : " algorithms ")
                                + (exportSettings ? "to" : "from");
                 newScope.totem = "icon-" + (exportSettings ? "copy" : "paste");
                 newScope.infoMessages = ["You can only choose a "
                                    + ($scope.mlTaskDesign.predictionType === "REGRESSION" ? "regression" : "classification (binary or multiclass)")
                                    + " model using a "
                                    + ($scope.backendTypeNames[$scope.mlTaskDesign.backendType] || $scope.mlTaskDesign.backendType)
                                    + " engine"];
                 newScope.selectProject = function() {
                     DataikuAPI.analysis.listHeads(newScope.selectedProjectKey).success(function(analysisData) {
                         newScope.analyses = analysisData;
                         newScope.selectedAnalysisId = undefined;
                         newScope.selectedTask = undefined;
                     }).error(setErrorInScope.bind($scope));
                 };
                 newScope.selectAnalysis = function () {
                    DataikuAPI.analysis.listMLTasks(newScope.selectedProjectKey, newScope.selectedAnalysisId)
                    .success(function(taskData) {
                        newScope.descriptions = [];
                        newScope.tasks = taskData;
                        newScope.tasks.forEach(task => {
                            // task can be selected if it is not the current one + has same pred type + same backend
                            task.isNotSelectable = task.mlTaskId === $stateParams.mlTaskId
                                                && newScope.selectedAnalysisId === $stateParams.analysisId
                                                && newScope.selectedProjectKey === $stateParams.projectKey
                                                || task.backendType !== $scope.mlTaskDesign.backendType
                                                || task.taskType !== "PREDICTION"
                                                || ((task.predictionType === "REGRESSION") !== $scope.isRegression());
                            newScope.descriptions.push($scope.displayTypes[task.predictionType || task.taskType] + " ("
                            + ($scope.backendTypeNames[task.backendType] || task.backendType) + ")");
                        });
                        newScope.selectedTask = undefined;
                    }).error(setErrorInScope.bind($scope));
                 };
                 if (newScope.projects.some(_ => _.projectKey === $stateParams.projectKey)) {
                      newScope.selectedProjectKey = $stateParams.projectKey;
                      newScope.analyses = $scope.analyses;
                      newScope.selectedAnalysisId = $stateParams.analysisId;
                      newScope.selectAnalysis();
                  }
                 newScope.confirm = function() {
                    if (exportSettings) {
                        DataikuAPI.analysis.pml.copyAlgorithmSettings($stateParams.projectKey, $stateParams.analysisId,
                            $stateParams.mlTaskId, newScope.selectedProjectKey, newScope.selectedAnalysisId,
                            newScope.selectedTask.mlTaskId).error(setErrorInScope.bind($scope));
                    } else {
                        DataikuAPI.analysis.pml.copyAlgorithmSettings(newScope.selectedProjectKey, newScope.selectedAnalysisId,
                            newScope.selectedTask.mlTaskId, $stateParams.projectKey, $stateParams.analysisId,
                            $stateParams.mlTaskId).success(function(data) {
                                $scope.setMlTaskDesign(data);
                        }).error(setErrorInScope.bind($scope));
                    }
                    WT1.event("mltask-copy-algorithms", {
                        export: exportSettings,
                        sameProject: $stateParams.projectKey === newScope.selectedProjectKey,
                        sameAnalysis: $stateParams.analysisId === newScope.selectedAnalysisId,
                        typeDest: newScope.selectedTask.predictionType,
                        typeSrc: $scope.mlTaskDesign.predictionType
                    });
                     newScope.dismiss();
                 };
                 newScope.cancel = function() {
                     newScope.dismiss();
                 };
             });
         }).error(setErrorInScope.bind($scope));
    };

    $scope.$watch("mlTaskDesign.modeling.metrics.evaluationMetric", function(nv, ov) {
        if (nv && nv == "CUSTOM" && !$scope.mlTaskDesign.modeling.metrics.customEvaluationMetricCode) {
            $scope.mlTaskDesign.modeling.metrics.customEvaluationMetricCode =
                    "def score(y_valid, y_pred):\n"+
                    "    \"\"\"\n"+
                    "    Custom scoring function.\n" +
                    "    Must return a float quantifying the estimator prediction quality.\n"+
                    "      - y_valid is a pandas Series\n"+
                    "      - y_pred is a numpy ndarray with shape:\n"+
                    "           - (nb_records,) for regression problems and classification problems\n"+
                    "             where 'needs probas' (see below) is false\n"+
                    "             (for classification, the values are the numeric class indexes)\n"+
                    "           - (nb_records, nb_classes) for classification problems where\n"+
                    "             'needs probas' is true\n"+
                    "      - [optional] X_valid is a dataframe with shape (nb_records, nb_input_features)\n"+
                    "      - [optional] sample_weight is a numpy ndarray with shape (nb_records,)\n"+
                    "                   NB: this option requires a variable set as \"Sample weights\"\n"+
                    "    \"\"\"\n"
        }
    });


    $scope.$watch('mlTaskDesign', function(nv){
        if (nv) {
            $scope.uiState.predictionType = nv.predictionType;
            $scope.uiState.targetVariable = nv.targetVariable;
            $scope.uiState.sampleWeightVariable = nv.weight.sampleWeightVariable ? nv.weight.sampleWeightVariable : null;
            $scope.uiState.weightMethod = nv.weight.weightMethod ? nv.weight.weightMethod : null;
            $scope.uiState.splitMethodDesc = nv.splitParams.ssdSplitMode==="SORTED" ? "Based on time variable" : "Randomly";
            if (nv.backendType === "PY_MEMORY") {
                $scope.uiState.hyperparamSearchStrategies =  [["GRID", "Grid search"],
                                                              ["RANDOM", "Random search"],
                                                              ["BAYESIAN", "Bayesian search"]];
            } else {
                $scope.uiState.hyperparamSearchStrategies =  [["GRID", "Grid search"]];
            }
            if (nv.guessPolicy === 'CUSTOM' && nv.backendType === 'PY_MEMORY' && $scope.mlTaskDesign.modeling.custom_python.length > 0) {
                let expectedAlgKey = 'custom_python_' + ($scope.mlTaskDesign.modeling.custom_python.length - 1);
                $scope.uiState.algorithm = expectedAlgKey;
            }

            if (nv.guessPolicy === 'CUSTOM' && nv.backendType === 'MLLIB' && $scope.mlTaskDesign.modeling.custom_mllib.length > 0) {
                let expectedAlgKey = 'custom_mllib_' + ($scope.mlTaskDesign.modeling.custom_mllib.length - 1);
                $scope.uiState.algorithm = expectedAlgKey;
            }

            $scope.retrieveCodeEnvsInfo();
        }
    });

    $scope.getCrossvalModes = function() {
        if($scope.mlTaskDesign.time && $scope.mlTaskDesign.time.enabled) {
            return $scope.crossvalModesWithTime;
        } else {
            return $scope.crossvalModesRandom;
        }
    };

    $scope.$watch('mlTaskDesign.time', function(nv, ov){
        // Propagate changes of `mlTaskDesign.time` object to:
        //   - split params
        //   - per feature
        //   - grid search params
        // Be careful to propagate only if actual change in order not to dirtify the mlTaskDesign object for nothing 
        if(nv && ov && nv !== ov) {
            const splitSingleDataset = $scope.mlTaskDesign.splitParams.ttPolicy === "SPLIT_SINGLE_DATASET";
            if (nv.timeVariable && nv.timeVariable !== ov.timeVariable) {
                let featureData = $scope.mlTaskDesign.preprocessing.per_feature[nv.timeVariable];
                featureData.missing_handling = "DROP_ROW";
                featureData.autoReason = null;
                if (splitSingleDataset) {
                    $scope.mlTaskDesign.splitParams.ssdColumn = nv.timeVariable;
                }
            }

            if (nv.ascending !== ov.ascending && splitSingleDataset) {
                $scope.mlTaskDesign.splitParams.testOnLargerValues = nv.ascending;
            }

            if (nv.enabled !== ov.enabled) {
                if (nv.enabled) {
                    $scope.mlTaskDesign.splitParams.ssdSplitMode = "SORTED";
                    $scope.uiState.splitMethodDesc = "Based on time variable";
                    switch ($scope.mlTaskDesign.modeling.gridSearchParams.mode) {
                        case "KFOLD":
                            $scope.mlTaskDesign.modeling.gridSearchParams.mode = "TIME_SERIES_KFOLD";
                            break;
                        case "SHUFFLE":
                            $scope.mlTaskDesign.modeling.gridSearchParams.mode = "TIME_SERIES_SINGLE_SPLIT";
                            break;
                        default:
                            break;
                    }
                    $scope.mlTaskDesign.splitParams.kfold = false;
                } else {
                    $scope.mlTaskDesign.splitParams.ssdSplitMode = "RANDOM";
                    $scope.uiState.splitMethodDesc = "Randomly";
                    switch ($scope.mlTaskDesign.modeling.gridSearchParams.mode) {
                        case "TIME_SERIES_KFOLD":
                            $scope.mlTaskDesign.modeling.gridSearchParams.mode = "KFOLD";
                            break;
                        case "TIME_SERIES_SINGLE_SPLIT":
                            $scope.mlTaskDesign.modeling.gridSearchParams.mode = "SHUFFLE";
                            break;
                        default:
                            break;
                    }
                    $scope.mlTaskDesign.time.timeVariable = null;
                    if ($scope.mlTaskDesign.splitParams.ssdColumn) {
                        $scope.mlTaskDesign.splitParams.ssdColumn = null;
                    }
                }
            }
        }
    }, true);
});

app.controller("PMLTaskPreTrainBase", function ($scope, $stateParams, $state, $controller, DataikuAPI, WT1, Logger) {
    $controller('_PMLTaskWithK8sContainerInformationController', { $scope });

    $scope._doTrain = function () {
        try {
            const algorithms = {};
            $.each($scope.mlTaskDesign.modeling, function (alg, params) {
                if (params.enabled) {
                    algorithms[alg] = params;
                }
            });

            // Adding custom py algorithms
            $.each($scope.mlTaskDesign.modeling.custom_python, function(algNum, params) {
                if (params.enabled) {
                    algorithms["CUSTOM_PYTHON_" + algNum] = params;
                }
            });

            // Adding custom mllib algorithms
            $.each($scope.mlTaskDesign.modeling.custom_mllib, function(algNum, params) {
                if (params.enabled) {
                    algorithms["CUSTOM_MLLIB_" + algNum] = params;
                }
            });

            // Adding plugin algorithms
            $.each($scope.mlTaskDesign.modeling.plugin_python, function(alg, params) {
                if (params.enabled) {
                    algorithms[alg] = params;
                }
            });

            WT1.event("prediction-train", {
                backendType: $scope.mlTaskDesign.backendType,
                taskType: $scope.mlTaskDesign.taskType,
                predictionType: $scope.mlTaskDesign.predictionType,
                guessPolicy: $scope.mlTaskDesign.guessPolicy,
                feature_generation: JSON.stringify($scope.mlTaskDesign.preprocessing.feature_generation),
                feature_selection_params: JSON.stringify($scope.mlTaskDesign.preprocessing.feature_selection_params),
                algorithms: JSON.stringify(algorithms),
                metrics: JSON.stringify($scope.mlTaskDesign.modeling.metrics),
                weightMethod: $scope.mlTaskDesign.weight.weightMethod,
                hasSessionName: !!$scope.uiState.userSessionName,
                hasSessionDescription: !!$scope.uiState.userSessionDescription,
                calibrationMethod: $scope.mlTaskDesign.calibration.calibrationMethod,
                hasTimeOrdering: $scope.mlTaskDesign.time.enabled,
                gridSearchParams: JSON.stringify($scope.mlTaskDesign.modeling.gridSearchParams),
                runsOnKubernetes: $scope.hasSelectedK8sContainer(),
                assertionsParams: JSON.stringify(aggregateAssertionsParams())
            });
        } catch (e) {
            Logger.error('Failed to report mltask info', e);
        }
        return DataikuAPI.analysis.pml.trainStart($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId,
            $scope.uiState.userSessionName, $scope.uiState.userSessionDescription, $scope.uiState.forceRefresh).error(setErrorInScope.bind($scope));
    };
    function aggregateAssertionsParams() {
        let assertionsConditionsModes = {}
        $scope.mlTaskDesign.assertionsParams.assertions.map(a => a.filter.uiData.mode)
            .forEach(val => assertionsConditionsModes[val] = (assertionsConditionsModes[val] || 0) + 1)
        return {
            "count": $scope.mlTaskDesign.assertionsParams.assertions.length || 0,
            "assertionsConditionsModes": assertionsConditionsModes
        };
    }
});

app.controller("PMLTaskPreTrainBaseKeras", function ($scope, $controller) {
    $controller("PMLTaskPreTrainBase", {$scope:$scope});
    $scope.kerasTrain = function () {
        $scope._doTrain().then(function () {
            $scope.onTrainModalResolution();
        });
    };
});

app.controller("PMLTaskPreTrainModal", function($scope, $stateParams, $state, DataikuAPI,$controller, WT1, Logger) {
    $controller("PMLTaskPreTrainBase", {$scope:$scope});
    $scope.uiState = {
        confirmRun: false
    };

    DataikuAPI.analysis.pml.getPreTrainStatus($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId).success(function(data) {
        $scope.preTrainStatus = data;
        $scope.splitStatus = data.splitStatus;
        $scope.uiState.anyError = data.messages.some(x => x.severity == 'ERROR');
        $scope.uiState.anyWarning = data.messages.some(x => x.severity == 'WARNING');
    }).error(setErrorInScope.bind($scope));

    function trainAndResolveModal() {
        $scope._doTrain().success(function (data) {
            $scope.resolveModal();
        });
    }

    $scope.getModelStr = (pluralize) => {
        let modelStr;
        if ($scope.preTrainStatus && $scope.preTrainStatus.partitionedModelEnabled) {
            modelStr = "partitioned model";
        } else {
            modelStr = "model";
        }

        if (pluralize) {
            modelStr += "s";
        }

        return modelStr;
    }

    $scope.train = function () {
        if ($scope.isMLBackendType("KERAS")) {
            $scope.saveSettings().success(function() {
                if ($scope.recipe.params && $scope.recipe.params.skipPrerunValidate) {
                    trainAndResolveModal();
                } else {
                    $scope.validateRecipe().then(function(validationResult) {
                        if (!validationResult.topLevelMessages || !validationResult.topLevelMessages.maxSeverity || validationResult.topLevelMessages.maxSeverity === 'OK') {
                            trainAndResolveModal();
                        } else {
                            $state.go('projects.project.analyses.analysis.ml.predmltask.list.design',
                                {
                                    "projectKey": $scope.projectSummary.projectKey,
                                    "analysisId": $scope.analysisCoreParams.id,
                                    "mlTaskId": $scope.mlTaskDesign.id
                                }).then(() => {
                                    $scope.valCtx.showPreRunValidationError = true;
                                    $scope.goToKerasArchitecture();
                                    $scope.dismiss();
                            });

                        }
                    });
                }
            });
        } else {
            trainAndResolveModal();
        }
    };

    const selectedAlgorithmsWithWeightIncompatibility = [];
    $scope.base_algorithms[$scope.mlTaskDesign.backendType].forEach(function(x) {
        const unsupportedAlgo = $scope.algosWithoutWeightSupport.has(x.algKey);

        if((x.algKey in $scope.mlTaskDesign.modeling) && $scope.mlTaskDesign.modeling[x.algKey].enabled && unsupportedAlgo) {
            selectedAlgorithmsWithWeightIncompatibility.push(x.name);
        }

        // Looking at plugin algorithms as well
        const algoInPluginsAndEnabled = $scope.mlTaskDesign.modeling["plugin_python"]
                                        && $scope.mlTaskDesign.modeling["plugin_python"][x.algKey]
                                        && $scope.mlTaskDesign.modeling["plugin_python"][x.algKey].enabled;

        if (algoInPluginsAndEnabled && unsupportedAlgo) {
            selectedAlgorithmsWithWeightIncompatibility.push(x.name);
        }
    });
    $scope.uiState["selectedAlgorithmsWithWeightIncompatibility"] = selectedAlgorithmsWithWeightIncompatibility;
    $scope.uiState["displayWeightWarningPreTrain"] = ($scope.isSampleWeightEnabled() && (selectedAlgorithmsWithWeightIncompatibility.length > 0));
});

app.controller("PMLTaskAssertionsController", function($scope, DataikuAPI, StringUtils, $stateParams) {

    DataikuAPI.analysis.getPostScriptSchema($stateParams.projectKey, $stateParams.analysisId).success(function (data) {
        $scope.postScriptFeaturesSchema = data;
        $scope.postScriptFeaturesSchema.columns.splice($scope.postScriptFeaturesSchema.columns.map(column => column.name).indexOf($scope.mlTaskDesign.targetVariable), 1);
    });
    $scope.classes = $scope.mlTaskDesign.preprocessing.target_remapping.map(clss => clss.sourceValue);

    DataikuAPI.flow.recipes.generic.getVariables($stateParams.projectKey).success(function(data) {
        // recipeVariables is needed to fill the variable tab of the assertion filter when using a formula
        $scope.recipeVariables = data;
    }).error(setErrorInScope.bind($scope));
    $scope.addNewMlAssertion = function () {
        function isClassification() {
            return $scope.mlTaskDesign && $scope.mlTaskDesign.predictionType !== "REGRESSION";
        }
        let newAssertion = {
            filter: {"enabled": true},
            name: StringUtils.transmogrify("Assertion " + ($scope.mlTaskDesign.assertionsParams.assertions.length + 1).toString(),
                $scope.mlTaskDesign.assertionsParams.assertions.map(a => a.name),
                function(i){return "Assertion " + (i+1).toString() }),
            assertionCondition: {expectedValidRatio: 0.9}
        };
        if (isClassification()) {
            newAssertion.assertionCondition.expectedClass = $scope.classes[0];
        } else {
            DataikuAPI.shakers.detailedColumnAnalysis(
                $stateParams.projectKey,
                $scope.analysisCoreParams.projectKey,
                $scope.analysisCoreParams.inputDatasetSmartName,
                $scope.analysisCoreParams.script,
                null,
                $scope.mlTaskDesign.targetVariable,
                50
            ).success(function (data) {
                newAssertion.assertionCondition.expectedMinValue = Math.round(data.numericalAnalysis.min);
                newAssertion.assertionCondition.expectedMaxValue = Math.round(data.numericalAnalysis.max);
            });
        }
        $scope.mlTaskDesign.assertionsParams.assertions.push(newAssertion);
    };
    $scope.deleteAssertion = function(index) {
        $scope.mlTaskDesign.assertionsParams.assertions.splice(index, 1);
    }
});

app.controller('_K8sConfigurationCheckerController', ($scope, $stateParams, DataikuAPI) => {
    let k8sContainerNames = [];
    let defaultContainerName = null;

    DataikuAPI.containers.listNamesWithDefault($stateParams.projectKey, 'KUBERNETES')
        .success((data) => {
            k8sContainerNames = data.containerNames;
            defaultContainerName = data.resolvedInheritValue;
        })
        .error(setErrorInScope.bind($scope));

    $scope.isK8sContainer = (backendType, containerSelection) => {
        if (!['PY_MEMORY', 'KERAS'].includes(backendType)) {
            return false;
        }

        switch (containerSelection.containerMode) {
            case 'EXPLICIT_CONTAINER':
                return k8sContainerNames.includes(containerSelection.containerConf);
            case 'INHERIT':
                return k8sContainerNames.includes(defaultContainerName);
            default:
                return false;
        }
    };
});

app.controller("_PMLTaskWithK8sContainerInformationController", ($scope, $controller) => {
    $controller("_K8sConfigurationCheckerController", { $scope });

    $scope.hasSelectedK8sContainer = () => {
        const { backendType, containerSelection } = $scope.mlTaskDesign;
        return $scope.isK8sContainer(backendType, containerSelection);
    };
});

app.controller("PMLTaskHyperparametersController", ($scope, $controller) => {
    $controller("PMLTaskCrossvalController", { $scope });
    $controller("_PMLTaskWithK8sContainerInformationController", { $scope });
});

app.controller("PMLTaskRuntimeController", ($scope, $controller) => {
    $controller("_PMLTaskWithK8sContainerInformationController", { $scope });

    const updateHpSearchDistribution = (newSelection, oldSelection) => {
        if (angular.equals(newSelection, oldSelection)) {
            return;
        }

        const searchParams = $scope.mlTaskDesign.modeling.gridSearchParams;
        searchParams.distributed = searchParams.distributed && $scope.hasSelectedK8sContainer();
    };

    $scope.$watch('mlTaskDesign.containerSelection', updateHpSearchDistribution, true);
});

app.controller("PMLTaskCrossvalController", function($scope, $controller, $timeout, $stateParams, DataikuAPI, DatasetUtils, VisualMlCodeEnvCompatibility, Dialogs, SamplingData){
    var datasetLoc = DatasetUtils.getLocFromSmart($stateParams.projectKey, $scope.analysisCoreParams.inputDatasetSmartName);
    DataikuAPI.datasets.get(datasetLoc.projectKey, datasetLoc.name, $stateParams.projectKey).success(function (data) {
        $scope.analysisDataset = data;
    });
    $scope.getPartitionsList = function () {
        return DataikuAPI.datasets.listPartitionsWithName(datasetLoc.projectKey, datasetLoc.name)
            .error(setErrorInScope.bind($scope))
            .then(function (ret) {
                return ret.data;
            })
    };
    $scope.isSearchNeeded = function() {

        // xgboost is a bit annoying, because we know for sure that when "enable_early_stopping" is checked
        // it needs search (whatever the strategy is), so we handle this special case separatly
        const xgbParams = $scope.mlTaskDesign.modeling.xgboost;
        if (xgbParams && xgbParams.enabled && xgbParams.enable_early_stopping) {
            return true;
        }

        if ($scope.mlTaskDesign.modeling.gridSearchParams.strategy !== "GRID") {
            return $scope.mlTaskDesign.modeling.gridSearchParams.nIterRandom !== 1;
        } else {
            var ret = false;
            angular.forEach($scope.mlTaskDesign.modeling, function(alg, algName) {
                if (!alg.enabled) {
                    return;
                }

                angular.forEach(alg, function(v,k) {
                    // Numerical hyperparameter
                    if (v.gridMode === "EXPLICIT" && v.values && v.values.length > 1) {
                        ret = true;
                    } else if (v.gridMode === "RANGE" && v.range.nbValues > 1) {
                        ret = true;
                    // Categorical hyperparameter
                    } else if (Object.values(v.values || {}).filter(val => val.enabled).length > 1) {
                        ret = true;
                    }
                });
            });

            // For plugin algos, need to have a look at their 'params' field
            angular.forEach($scope.mlTaskDesign.modeling.plugin_python, function(alg, algKey) {
                if (!alg.enabled) {
                    return;
                }

                var algorithmSetting = $scope.getPluginAlgorithm(algKey);
                if (algorithmSetting.customInfo.desc.gridSearchMode === "CUSTOM") {
                    ret = true;
                } else if (algorithmSetting.customInfo.desc.gridSearchMode === "MANAGED"){
                    angular.forEach(alg.params, function(v,k) {
                        if ($.isArray(v) && v.length > 1) {
                            ret = true;
                        }
                    });
                }
            });

            return ret;
        }
    }
    // Prefill
    $scope.$watch("uiSplitParams.policy", function(nv, ov) {
        if (!nv) return;
        if (nv == "EXPLICIT_FILTERING_TWO_DATASETS") {
            if (!$scope.mlTaskDesign.splitParams.eftdTrain) {
                $scope.mlTaskDesign.splitParams.eftdTrain = {
                    datasetSmartName : $scope.analysisCoreParams.inputDatasetSmartName,
                    selection : DatasetUtils.makeHeadSelection(100000)
                }
            }
            if (!$scope.mlTaskDesign.splitParams.eftdTest) {
                $scope.mlTaskDesign.splitParams.eftdTest = {
                    selection : DatasetUtils.makeHeadSelection(100000)
                }
            }
        } else if (nv.indexOf("EXPLICIT_FILTERING_SINGLE_DATASET")==0) {
            if (!$scope.mlTaskDesign.splitParams.efsdTrain) {
                $scope.mlTaskDesign.splitParams.efsdTrain = {
                    selection : DatasetUtils.makeHeadSelection(100000)
                }
            }
            if (!$scope.mlTaskDesign.splitParams.efsdTest) {
                $scope.mlTaskDesign.splitParams.efsdTest = {
                    selection : DatasetUtils.makeHeadSelection(100000)
                }
            }
        } else if (nv == "SPLIT_OTHER_DATASET") {
            if (!$scope.mlTaskDesign.splitParams.ssdDatasetSmartName) {
                $scope.mlTaskDesign.splitParams.ssdDatasetSmartName = $scope.analysisCoreParams.inputDatasetSmartName;
            }
        }
        if (nv != "SPLIT_MAIN_DATASET" && $scope.mlTaskDesign.partitionedModel.enabled) {
            const choices = [
                { revert: false, title: "Disable partitioning & keep this policy",
                    desc: ($scope.trainTestPolicies.find(_ => _[0] === nv) || [,nv])[1] },
                { revert: true, title: "Keep partitioning & revert policy",
                    desc: $scope.trainTestPolicies[0][1] }
            ];
            function act(choice) {
                if (choice.revert) {
                    $scope.uiSplitParams.policy = 'SPLIT_MAIN_DATASET';
                } else {
                    $scope.mlTaskDesign.partitionedModel.enabled = false;
                }
            }
            Dialogs.select($scope, "Change train/test policy",
                "Model partitioning is enabled, but not compatible with this policy.",
                choices, choices[0]
            ).then(act, act.bind(null, choices[1])); // dismiss => revert policy
        }
    });

    $scope.$watch("mlTaskDesign.modeling.gridSearchParams.mode", function(nv, ov){
        if (nv === "CUSTOM" && !$scope.mlTaskDesign.modeling.gridSearchParams.code) {
            $scope.mlTaskDesign.modeling.gridSearchParams.code =
                "# Define an object named cv that follows the scikit-learn splitter protocol\n"+
                "# This example uses the 'repeated K-fold' splitter of scikit-learn\n"+
                "from sklearn.model_selection import RepeatedKFold\n"+
                "\n"+
                "cv = RepeatedKFold(n_splits=3, n_repeats=5)"
        }
    })

    DatasetUtils.listDatasetsUsabilityForAny($stateParams.projectKey).success(function (data) {
        $scope.availableDatasets = data;
        $scope.availableDatasetsExceptForInputDataset = $scope.availableDatasets.filter(function(d) {
            return d.smartName !==  $scope.analysisCoreParams.inputDatasetSmartName
        })
        data.forEach(function (ds) {
            ds.usable = true;
        });
    });

    $scope.potentialTimeFeatures = function() {
        const per_feature = $scope.mlTaskDesign.preprocessing.per_feature;
        if ($scope.analysisDataset) {
            // Sort and split are done before Script is applied so only input columns can be time features
            const inputColumns = $scope.analysisDataset.schema.columns.map(col => col.name);
            return inputColumns.filter(col => (per_feature[col] && per_feature[col].role !== "TARGET"));
        }
    }

    $scope.getSamplingMethodLabel = function() {
        return SamplingData.getSamplingMethodForDocumentation($scope.mlTaskDesign.splitParams.ssdSelection.samplingMethod, $scope.mlTaskDesign);
    }

    $scope.getCrossValidationLabel = function() {
        let crossValidationLabel;
        
        if ($scope.mlTaskDesign.time && $scope.mlTaskDesign.time.enabled) {
            crossValidationLabel = $scope.getCrossvalModesWithTimeForDocumentation($scope.mlTaskDesign.modeling.gridSearchParams.mode, $scope.mlTaskDesign)
        } else {
            crossValidationLabel = $scope.getCrossvalModesRandomForDocumentation($scope.mlTaskDesign.modeling.gridSearchParams.mode, $scope.mlTaskDesign);
        }

        return crossValidationLabel;
    };

    $scope.getHyperparametersBarsMaxWidth = function() {
        return $scope.mlTaskDesign.splitParams.kfold ? 1 : $scope.mlTaskDesign.splitParams.ssdTrainingRatio;
    };

    $scope.isCodeEnvCompatibleWithBayesian = function() {
        if (!$scope.mlTaskDesign || !$scope.mlTaskDesign.envSelection) {
            return false;
        }
        return VisualMlCodeEnvCompatibility.isCompatible($scope.mlTaskDesign.envSelection, $scope.codeEnvsCompat, false, true);
    };
});

app.controller("PMLTaskFeatureSelectionController", function($scope, $controller, $timeout, $stateParams, DataikuAPI, Dialogs){
    $scope.featureSelectionKinds = [
        ["NONE", "No reduction"],
        ["CORRELATION", "Correlation with target"],
        ["RANDOM_FOREST", "Tree-based"],
        ["PCA", "Principal Component Analysis"],
    ]

    if(!$scope.isMulticlass() &&
        $scope.mlTasksContext &&
        $scope.mlTasksContext.activeMLTask &&
        $scope.mlTasksContext.activeMLTask.backendType == "PY_MEMORY") {
        $scope.featureSelectionKinds.push(["LASSO", "LASSO regression"]);
    }
    
    // Signal to Puppeteer that the content of the element has been loaded and is thus available for content extraction
    $scope.puppeteerHook_elementContentLoaded = true;
})

// NB: Also used for clustering
app.controller("PMLTaskFeaturesController", function($scope, $controller) {
    $controller("_MLTaskFeaturesController", {$scope:$scope});

    $scope.selection = {orderQuery: 'datasetColumnId'};

    $scope.isMLBackendType = function(mlBackendType){
        if (!$scope.mlTaskDesign) return false;
        return $scope.mlTaskDesign.backendType == mlBackendType;
    };
});

// NB: Also used for clustering
app.controller("MLTaskFeatureController", function($scope, PMLSettings, DataikuAPI) {
    $scope.onVariableTypeChange = function() {
        let featureData = $scope.selection.selectedObject;
        if (featureData.type === 'NUMERIC') {
            const modes = $scope.numericalMissingHandlingModes.map(function(m){return m[0]});
            if (modes.indexOf(featureData.missing_handling) < 0) {
                featureData.missing_handling = 'IMPUTE';
            }
        } else if (featureData.type === 'CATEGORY') {
            const modes = $scope.categoryMissingHandlingModes.map(function(m){return m[0]});
            if (modes.indexOf(featureData.missing_handling) < 0) {
                featureData.missing_handling = 'IMPUTE';
            }
        } else if (featureData.type === 'VECTOR') {
            const modes = $scope.vectorMissingHandlingModes.map(function(m){return m[0]});
            if (modes.indexOf(featureData.missing_handling) < 0) {
                featureData.missing_handling = 'DROP_ROW';
            }
            // Setting value of Vector Handling manually for first selection of Vector as type
            // because vector type is never guessed by back-end so never set up automatically
            if (featureData.vector_handling === undefined) {
                featureData.vector_handling = "UNFOLD";
                featureData.missing_handling = 'DROP_ROW';
                featureData.missing_impute_with = 'MODE';
            }
        } else if (featureData.type == "IMAGE") {
            const modes = $scope.imageMissingHandlingModes.map(function(m){return m[0]});
            if (modes.indexOf(featureData.missing_handling) < 0) {
                featureData.missing_handling = 'DROP_ROW';
            }

            // Setting value of Image Handling manually for first selection of Image as type
            // because image type is never guessed by back-end so never set up automatically
            if (featureData.image_handling === undefined) {
                featureData.image_handling = "CUSTOM";
                featureData.missing_handling = 'DROP_ROW';
            }

            if (featureData.image_handling === "CUSTOM" && featureData.customHandlingCode === "") {
                featureData.customHandlingCode = getCustomImageHandlingCode();
            }
        }
    };

    $scope.onVariableRoleChange = function() {
        console.debug("onVariableRoleChange", $scope.feature);
    };

    function getCustomImageHandlingCode() {
        const prepImgCode = "from keras.preprocessing.image import img_to_array, load_img\n\n" +
                            "# Custom image preprocessing function.\n" +
                            "# Must return a numpy ndarray representing the image.\n" +
                            "#  - image_file is a file like object\n" +
                            "def preprocess_image(image_file):\n" +
                            "    img = load_img(image_file,target_size=(197, 197, 3))\n" +
                            "    array = img_to_array(img)\n\n" +
                            "    # Define the actual preprocessing here\n\n" +
                            "    return array\n";
        return prepImgCode;
    }
    
    // Signal to Puppeteer that the content of the element has been loaded and is thus available for content extraction
    $scope.puppeteerHook_elementContentLoaded = true;

    $scope.$watch('selection.selectedObject', function(newValue) {
        // Only allow preprocessing of not rejected input features
        if (newValue) {
            $scope.canPreprocess = newValue.role != 'TARGET' && newValue.role != 'REJECT' && newValue.role != 'WEIGHT';
        }
    }, true);
});

app.controller("PMLTargetRemappingController", function($scope, Assert, Fn) {
    Assert.inScope($scope, 'mlTaskDesign');

    $scope.updateGraph = function(){
        $scope.colors  = window.dkuColorPalettes.discrete[0].colors // adjascent colors are too similar
            .filter(function(c, i) { return i % 2 === 0; });        // take only even-ranked ones

        try {
        $scope.totalCount = $scope.mlTaskDesign.preprocessing.target_remapping.map(Fn.prop("sampleFreq")).reduce(Fn.SUM);

        $scope.graphData = $scope.mlTaskDesign.preprocessing.target_remapping.map(function(x){
            return [x.sourceValue, x.sampleFreq / $scope.totalCount];
        });
        } catch (e) {}
    }

    $scope.$watch('mlTaskDesign.preprocessing.target_remapping', $scope.updateGraph, false); // shallow, for the "re-detect settings" case

    $scope.editMapping = {
        active: false,
        value : null
    }
    $scope.startEditMapping = function(){
        $scope.editMapping.active = true;
        $scope.editMapping.value = $scope.mlTaskDesign.preprocessing.target_remapping;
    }
    $scope.$watch("editMapping.value", function(nv, ov) {
        if (!nv) $scope.editMapping.error = true;
        else $scope.editMapping.error = false;
    }, true);
    $scope.okEditMapping = function(){
        $scope.editMapping.active = false;
        $scope.mlTaskDesign.preprocessing.target_remapping = $scope.editMapping.value ;
        $scope.updateGraph();
    }
    $scope.cancelEditMapping = function(){
        $scope.editMapping.active = false;
    }

    $scope.updateGraph();

    $scope.hasManyCategories = function(){
        return $scope.mlTaskDesign.preprocessing.target_remapping.length >= 50;
    }

});

app.controller("PMLSparkConfigController", function($scope, Assert, DataikuAPI, Fn) {
    Assert.inScope($scope, 'mlTaskDesign');

    $scope.sparkConfs = ['default'];
    DataikuAPI.admin.getGeneralSettings().success(function(data){
        $scope.sparkConfs = data.sparkSettings.executionConfigs.map(Fn.prop('name'));
    });
});

app.directive('tensorboardDestroyHandler', function () {
    return {
        link: function ($scope, elem, attr) {
            elem.on('$destroy', function() {
                $scope.sessionTask.tensorboardStatus.isFrontendReady = false;
                $scope.sessionTask.tensorboardStatus.showIfFrontIsNotReady = true;
            });
        }
    }

});


})();

(function(){
'use strict';

var app = angular.module('dataiku.analysis.mlcore');


/**
 * Controllers, services and directives for the views of a single model
 * of a MLTask
 */

/**
 * Injected into all controllers that display a single PMLTask model. Handles:
 *   - the global nav handle to switch between PMLTask models
 *   - setting the top nav item
 */
app.controller("_PMLModelBaseController", function($scope, $controller, $q, DataikuAPI, $stateParams, PMLFilteringService, CreateModalFromTemplate){
    $controller("_ModelUtilsController", {$scope:$scope});
    $controller("_MLModelBaseController", {$scope:$scope});
    $controller("downloadModelController", {$scope:$scope});

    $scope.whenHasModel = function() {
        if ($scope.modelData) return $q.when(null);
        else {
            return DataikuAPI.ml.prediction.getModelDetails($stateParams.fullModelId).success(function(data){
                // replace only if absent or different, else may have been enriched, e.g. in _PredictionModelReportController
                if (!$scope.modelData || $scope.modelData.fullModelId != data.fullModelId) {
                    $scope.modelData = data;
                    // Signal to Puppeteer that the content of the element has been loaded and is thus available for content extraction
                    $scope.puppeteerHook_elementContentLoaded = true;
                }
            });
        }
    }

    $scope.mlTasksContext.delete = function() {
        $scope.deleteTrainedAnalysisModel();
    }

    $scope.whenHasModel().then(function(){
        var algoName = $scope.modelData.modeling.algorithm;
        $scope.mlTasksContext.noPredicted = /^(MLLIB|SPARKLING|VERTICA|PYTHON_ENSEMBLE|SPARK_ENSEMBLE|KERAS)/i.test(algoName);
        $scope.mlTasksContext.noExport = $scope.mlTasksContext.noPredicted || (algoName === "CUSTOM_PLUGIN");
    });

    $scope.mlTasksContext.deploy = function(){
        $scope.whenHasModel().then(function(){
             CreateModalFromTemplate("/templates/analysis/prediction/model/deploy-modal.html",
                $scope,"AnalysisPredictionDeployController");
        });
    }
    $scope.mlTasksContext.exportNotebook = function(){
        $scope.whenHasModel().then(function(){
            CreateModalFromTemplate("/templates/analysis/mlcommon/export-notebook-modal.html",
            $scope,"AnalysisPredictionExportNotebookController");
        });
    }

    DataikuAPI.analysis.pml.getTaskStatus($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId).success(function(data){
        if (!$scope.mlTasksContext.activeMetric) {
            $scope.mlTasksContext.activeMetric = data.headSessionTask.modeling.metrics.evaluationMetric;
        }
    });

    DataikuAPI.analysis.pml.getModelSnippets($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId).success(function(data){
        $scope.mlTasksContext.models = Object.values(data).filter(function(m){
            return m.trainInfo.state == "DONE" && m.fullModelId != $stateParams.fullModelId;
        });
        $scope.mlTasksContext.models.sort(function(a, b) {
            var stardiff = (0+b.userMeta.starred) - (0+a.userMeta.starred)
            if (stardiff != 0) return stardiff;
            return b.sessionDate - a.sessionDate;
        });
        $scope.mlTasksContext.models.forEach(function(m){
            m.mainMetric = PMLFilteringService.getMetricFromSnippet(m, $scope.mlTasksContext.activeMetric);
            m.mainMetricStd = PMLFilteringService.getMetricStdFromSnippet(m, $scope.mlTasksContext.activeMetric);
        });
    }).error(setErrorInScope.bind($scope));
});

app.controller("downloadModelController", function($scope, MLExportService) {
    $scope.mlTasksContext.showDownloadModel = function(type) {
        if (!$scope.modelData) return false;
        return MLExportService.showDownloadModel($scope.appConfig, type);
    };
    $scope.mlTasksContext.mayDownloadModel = function(type) {
        if (!$scope.modelData) return false;
        return MLExportService.mayDownloadModel($scope.appConfig, $scope.modelData, type);
    };
    $scope.mlTasksContext.downloadModel = function(type) {
        $scope.whenHasModel().then(function(){
            MLExportService.downloadModel($scope, $scope.modelData, type, $scope.mlTasksContext.partitionName);
        });
    };

    $scope.mlTasksContext.exportToSnowflakeFunction = function() {
        $scope.whenHasModel().then(function(){
            MLExportService.exportToSnowflakeFunction($scope, $scope.modelData, $scope.mlTasksContext.partitionName);
        });
    }
});


/**
 * Controller for displaying results screen of a prediction model
 * in a PMLTask
 */
 app.controller("PMLModelReportController", function($scope, $controller, TopNav, WebAppsService) {
    TopNav.setLocation(TopNav.TOP_ANALYSES, null, "PREDICTION-ANALYSIS-MODEL", "report");

    $controller("_PMLModelBaseController",{$scope:$scope});
    $controller("_PredictionModelReportController",{$scope:$scope});

    $scope.whenHasModel().then(function() {
        const contentType = `${$scope.modelData.coreParams.taskType}/${$scope.modelData.coreParams.backendType}/${$scope.modelData.modeling.algorithm}`.toLowerCase();
        $scope.modelSkins = WebAppsService.getSkins('ANALYSIS', '', contentType);
    });
});

app.controller("PMLPartModelReportController", function($scope, $controller, DataikuAPI, $state, $stateParams, $location,
    FullModelIdUtils){
    const fullModelId = $stateParams.fullModelId || $scope.fullModelId;

    const setScopeSnippets = (partSnippets) => {
        if (partSnippets.fullModelId === fullModelId) {
            $scope.currentPartitionedModel = partSnippets;
        } else {
            $scope.currentPartitionedModel = Object.values(partSnippets.partitions.summaries)
                .find(m => m.snippet.fullModelId === fullModelId)
                .snippet;
            $scope.currentPartitionName = $scope.currentPartitionedModel.partitionName;
        }

        $scope.partitionedModelSnippets = partSnippets;

        if ($scope.mlTasksContext) {
            $scope.mlTasksContext.noPredicted = !$scope.isOnModelPartition();
            $scope.mlTasksContext.noExport = true;
            $scope.mlTasksContext.partitionName = $scope.currentPartitionName;
        }
        if ($scope.smContext) {
            $scope.smContext.partitionName = $scope.currentPartitionName;
        }
    };

    $scope.goToBaseModel = function() {
        $state.go('.', {fullModelId : $scope.partitionedModelSnippets.fullModelId});
    };

    $scope.goToPartitionedModel = function(partitionName) {
        if (partitionName) {
            // Switch between partitions, stay on the same tab (hashcode)
            const partitionFmi = $scope.partitionedModelSnippets.partitions.summaries[partitionName].snippet.fullModelId;
            $state.go('.', {fullModelId: partitionFmi, '#': $location.hash()})
        } else {
            // Switch from overall model to partitioned, go to the first one done
            const firstPartitionFmi = Object.values($scope.partitionedModelSnippets.partitions.summaries)
                .find(summary => summary.state.endsWith('DONE')).snippet.fullModelId;
            $state.go('.', {fullModelId: firstPartitionFmi});
        }
    };

    $scope.showPartitions = function() {
        return !$scope.insight;
    }

    $scope.isOnModelPartition = function (){
        return $scope.currentPartitionedModel && $scope.currentPartitionedModel.partitionName;
    };

    $scope.isOnPartitionedBaseModel = function () {
        return !$scope.currentPartitionedModel || !$scope.currentPartitionedModel.partitionName;
    };

    /* In analysis */
    $scope.$watch('mlTasksContext.models', function(models) {
        if (!models) {
            return;
        }
        DataikuAPI.analysis.pml.getPartitionedModelSnippets(fullModelId)
            .then((result) => setScopeSnippets(result.data), setErrorInScope.bind($scope));
    });

    /* In saved model */
    $scope.$watch('versionsContext.currentVersion', function(currentVersion) {
        if (!$scope.versionsContext || !$scope.versionsContext.versions) {
            return;
        }

        const baseFullModelId = FullModelIdUtils.getBase(fullModelId);
        const baseVersion = $scope.versionsContext.versions
            .find(m => m.snippet.fullModelId === baseFullModelId);

        if (!$scope.versionsContext.currentVersion || !$scope.versionsContext.currentVersion.snippet) {
            $scope.versionsContext.currentVersion = Object.values(baseVersion.snippet.partitions.summaries)
                .find(m => m.snippet.fullModelId === fullModelId);
        }

        if (baseVersion) {
            setScopeSnippets(baseVersion.snippet);
        } else {
            setScopeSnippets(currentVersion.snippet);
        }
    });
});

app.controller("AnalysisPredictionDeployController", function($scope, $controller, DataikuAPI, $state, $stateParams, Assert, TopNav, DatasetUtils, Dialogs){
    $scope.onSelectTrain = function(){
        $scope.uiState.selectedMode = 'train';
        $scope.formData = {
            optimizationBehaviour: "REDO",
            thresholdBehaviour: "REDO"
        };
        function autoSetModelName() {
            var algo = $scope.getAlgorithm();
            if (!$scope.formData.modelName && $scope.formData.trainDatasetSmartName) {
                const modelPredName = $scope.isPartitionedModel() ?
                    'Partitioned prediction' :
                    'Prediction';
                $scope.formData.modelName = `${modelPredName} (${algo}) on ${$scope.formData.trainDatasetSmartName}`;
            }
        }

        $scope.$watch("trainDatasetSmartName", autoSetModelName);

        var splitParams = $scope.modelData.splitDesc.params;
        if (splitParams.ttPolicy == 'SPLIT_SINGLE_DATASET') {
            $scope.formData.trainDatasetSmartName = $scope.analysisCoreParams.inputDatasetSmartName;
        } else if (splitParams.ttPolicy == 'EXPLICIT_FILTERING_TWO_DATASETS') {
            $scope.formData.trainDatasetSmartName = splitParams.eftdTrain.datasetSmartName;
            $scope.formData.testDatasetSmartName = splitParams.eftdTest.datasetSmartName;
        } else if (splitParams.ttPolicy == 'EXPLICIT_FILTERING_SINGLE_DATASET') {
            $scope.formData.trainDatasetSmartName = $scope.analysisCoreParams.inputDatasetSmartName;
        } else {
            throw "Unhandled split mode";
        }

        $scope.deployTrain = function() {
            var options = {
                redoOptimization: $scope.formData.optimizationBehaviour === "REDO",
                redoThresholdOptimization: $scope.formData.thresholdBehaviour === "REDO",
                fixedThreshold: $scope.modelData.userMeta.activeClassifierThreshold
            };
            DataikuAPI.analysis.pml.deployTrain($stateParams.fullModelId,
                $scope.formData.trainDatasetSmartName, $scope.formData.testDatasetSmartName,
                $scope.formData.modelName,
                options
            ).success(function(data){
                $scope.dismiss();
                $state.go("projects.project.flow");
            }).error(setErrorInScope.bind($scope));
        };
    };
    $scope.onSelectRedeployTrain = function() {
        $scope.uiState.selectedMode = 'redeploy-train';
        $scope.formData = {
            redeployTrainRecipeName: $scope.redeployables.length === 1
                ? $scope.redeployables[0].recipeName : null,
            redeployTrainActivate: true,
            optimizationBehaviour: "REDO",
            thresholdBehaviour: "REDO"
        };
        $scope.redeployTrain = function() {
            var options = {
                redoOptimization: $scope.formData.optimizationBehaviour === "REDO",
                redoThresholdOptimization: $scope.formData.thresholdBehaviour === "REDO",
                fixedThreshold: $scope.modelData.userMeta.activeClassifierThreshold
            };
            DataikuAPI.analysis.pml.redeployTrain($stateParams.fullModelId,
                $scope.formData.redeployTrainRecipeName,
                $scope.formData.redeployTrainActivate,
                options
            ).success(function(data){
                var go = $state.go.bind($state, "projects.project.flow");
                var parentScope = $scope.$parent;
                $scope.dismiss();
                if (data.schemaChanged) {
                    Dialogs.ack(parentScope, "Schema changed",
                        "The preparation script schema of the updated version is different than the previously " +
                        "selected version, this may affect the ouput schema of downstream scoring recipes."
                    ).then(go);
                } else {
                    go();
                }
            }).error(setErrorInScope.bind($scope));
        };
    };
    $scope.suggestRedeployTrain = function(redeployables) {
        $scope.uiState.selectedMode = 'can-redeploy';
        $scope.redeployables = redeployables;
        $scope.canRedeploy = true;
    };

    function main(){
        $scope.uiState = {};
        Assert.inScope($scope, "modelData");
        Assert.inScope($scope, "analysisCoreParams");

        DataikuAPI.analysis.pml.listRedeployableTrain($stateParams.fullModelId).success(function(data) {
            if (data && data.length) {
                $scope.suggestRedeployTrain(data);
            } else {
                $scope.onSelectTrain();
            }
        }).error($scope.onSelectTrain);

        DatasetUtils.listDatasetsUsabilityForAny($stateParams.projectKey).success(function(data){
            $scope.availableDatasets = data;
        });
    }

    main();
});


app.controller("DownloadModelDocumentationController", function($scope, DataikuAPI, WT1, FutureWatcher, ProgressStackMessageBuilder) {

    $scope.radio = { type: "default" };
    $scope.newTemplate = {};
    $scope.renderingInProgress = false;
    $scope.renderingDone = false;
    $scope.downloaded = false;
    $scope.errorOccured = false;
    $scope.hasDesignChangesOccurred = false;
    $scope.data = undefined;

    // The model data is stored in $scope.modelData for analysis and in $scope.smContext.model for savedmodels
    let fullModelId = (($scope.modelData) ? $scope.modelData : $scope.smContext.model).fullModelId;

    // Compute design changes before starting MDG to avoid wasting the user's time on generating documents 
    DataikuAPI.ml.prediction.getPreDocGenInfoMessages(fullModelId).success((data) => {
        $scope.data = data;
    }).error(setErrorInScope.bind($scope));

    $scope.export = (templateType) => {
        if (templateType === "custom") {
            WT1.event("render-model-documentation", {type: "custom"});
            DataikuAPI.ml.prediction.docGenCustom($scope.newTemplate.file, fullModelId, (e) => {
                // You can use here Math.round(e.loaded * 100 / e.total) to compute and display to the user the progress percentage of the template upload
            })
            .then(watchJobId)
            .catch((error) => {
                setErrorInScope2.call($scope, error);
            });
        } else {
            WT1.event("render-model-documentation", {type: "default"});
            DataikuAPI.ml.prediction.docGenDefault(fullModelId)
            .success(watchJobId)
            .error(setErrorInScope.bind($scope));
        }

        function watchJobId(initialResponse) {
            $scope.initialResponse = angular.fromJson(initialResponse);
            $scope.data = undefined;

            FutureWatcher.watchJobId($scope.initialResponse.jobId)
            .success(function(response) {
                let exportId = response.result.exportId;
                $scope.data = response.result.data;
                $scope.text = "The model documentation is ready.";
                if ($scope.data.maxSeverity === 'WARNING') {
                    $scope.text += " Be aware that the placeholders which couldn't be resolved are not shown in the model documentation.";
                } else if ($scope.data.maxSeverity === 'ERROR') {
                    $scope.text = "";
                    $scope.errorOccured = true;
                }
                
                // When an error occured it means the generation failed to produce the documentation, there is nothing to download
                if (!$scope.errorOccured) {
                    $scope.modelDocumentationURL = DataikuAPI.savedmodels.getModelDocumentationExportURL(exportId);
                }
                $scope.renderingInProgress = false;
                $scope.renderingDone = true;
            }).update(function(response) {
                $scope.futureResponse = response;
                $scope.percentage =  ProgressStackMessageBuilder.getPercentage(response.progress);
                $scope.stateLabels = ProgressStackMessageBuilder.build(response.progress, true);
            }).error(function(response, status, headers) {
                setErrorInScope.bind($scope)(response, status, headers);
            });
        }

        $scope.percentage = 100;
        $scope.stateLabels = "Uploading the template";
        $scope.renderingInProgress = true;
    };

    $scope.download = function() {
        downloadURL($scope.modelDocumentationURL);
        WT1.event("download-model-documentation");
        $scope.downloaded = true;
    };

    $scope.abort = function() {
        DataikuAPI.futures.abort($scope.initialResponse.jobId).error(setErrorInScope.bind($scope));
        $scope.dismiss();
        WT1.event("abort-model-documentation-rendering");
    }
});


app.controller("AnalysisPredictionExportNotebookController", function($scope, $controller, DataikuAPI, $state, $stateParams, Assert, TopNav) {
    Assert.inScope($scope, "modelData");
    Assert.inScope($scope, "analysisCoreParams");

    $scope.formData = {};

    var cp = $scope.modelData.coreParams;
    $scope.formData.notebookName = "Predict " + cp.target_variable + " in " +
        $scope.analysisCoreParams.inputDatasetSmartName.replace(/\./g, '_');

    $scope.createNotebook = function() {
        DataikuAPI.analysis.pml.createNotebook($stateParams.fullModelId, $scope.formData.notebookName)
        .success(function(data){
            $scope.dismiss();
            $state.go("projects.project.notebooks.jupyter_notebook", {notebookId : data.id});
        }).error(setErrorInScope.bind($scope));
    }
});


app.controller("PredictionScatterPlotController", function($scope){
    // remove duplicates in the scatter plot data - prevent d3 voronoi issue https://github.com/d3/d3/issues/1908
    $scope.$watch("modelData.perf.scatterPlotData", function(nv){
        if (!nv) { return }
        var hashTbl = {};
        for (var i=nv.x.length-1;i>=0;i--) {
            var key = nv.x[i] + '#' + nv.y[i];
            if (hashTbl[key]) { nv.x.splice(i,1) ; nv.y.splice(i,1) }
            else { hashTbl[key] = true }
        }
        $scope.spd = nv;
    });
});


app.directive("analysisPredictionPredictedTable", function($q, Assert, MonoFuture, WT1, TopNav) {
    return {
        scope: true,
        priority: 1,
        controller: function($scope, $stateParams, $state, DataikuAPI, $controller) {
            $controller("_PMLModelBaseController", {$scope});
            WT1.event("pml-model-prediction-open");
            TopNav.setLocation(TopNav.TOP_ANALYSES, null, "PREDICTION-ANALYSIS-MODEL", "predictedtable");
            Assert.inScope($scope, "loadMLTask");
            $scope.loadMLTask();

            DataikuAPI.ml.prediction.getModelDetails($stateParams.fullModelId)
                .success(function(data) {
                    if ($scope.mlTasksContext) $scope.mlTasksContext.model = data;
                    // Signal to Puppeteer that the content of the element has been loaded and is thus available for content extraction
                    $scope.puppeteerHook_elementContentLoaded = true;
                })
                .error(setErrorInScope.bind($scope));
        }
    }
});


app.directive('analysisPredictionPredictedCharts', function(Logger, DataikuAPI, WT1, TopNav) {
return {
        scope: true,
        controller: function ($scope, $stateParams, $state, $controller) {
            var main = function(){
                WT1.event("analysis-pml-charts-open");
                TopNav.setLocation(TopNav.TOP_ANALYSES, null, "PREDICTION-ANALYSIS-MODEL", "charts");
                $controller("_PMLModelBaseController",{$scope:$scope});

                DataikuAPI.analysis.mlcommon.getCurrentSettings($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId).success(function(data){
                    $scope.mlTaskDesign = data;
                    $scope.shaker = data.predictionDisplayScript;
                    $scope.charts = data.predictionDisplayCharts;
                    $scope.onSettingsLoaded();
                }).error(setErrorInScope.bind($scope));

                DataikuAPI.ml.prediction.getModelDetails($stateParams.fullModelId).success(function(data){
                    if ($scope.mlTasksContext) $scope.mlTasksContext.model = data;
                    // Signal to Puppeteer that the content of the element has been loaded and is thus available for content extraction
                    $scope.puppeteerHook_elementContentLoaded = true;
                });
            }
            main();
        }
    };
});


})();

(function(){
'use strict';

var app = angular.module('dataiku.analysis.mlcore');

/**
 * Controllers and services for the summary views
 * of a MLTask
 */


})();
(function(){
'use strict';

var app = angular.module('dataiku.analysis.mlcore');


app.service('CMLSettings', function(Fn) {
    var cst = {
        task: {
            evaluationMetrics: [
                ["SILHOUETTE", "Silhouette"],
                ["INERTIA", "Inertia"],
                ["NB_CLUSTERS", "Clusters"]
            ],
            outliersMethods: [
                ["NONE", "Do not detect outliers"],
                ["DROP", "Drop outliers"],
                ["CLUSTER", "Create a cluster with all outliers"]
            ]
        }, names: {
            evaluationMetrics: {
                SILHOUETTE: "Silhouette",
                INERTIA: "Inertia",
                NB_CLUSTERS: "Clusters"
            },
            algorithms: {
                a_km: "KMeans",
                b_hc: "Hierarchical",
                c_sc: "Spectral",
                d_db: "Density-based"
            }
        }, filter: {
            algorithms: {
                a_km: ['KMEANS', 'MiniBatchKMeans'],
                b_hc: ['WARD'],
                c_sc: ['SPECTRAL'],
                d_db: ['DBSCAN', 'OPTICS']
            }
        }, sort: {
            lowerBetter: ['INERTIA', 'NB_CLUSTERS'] // Simplification
        }, base_algorithms: {
            PY_MEMORY: [
                {name:'KMeans',algKey:'kmeans_clustering'},
                {name:'Gaussian Mixture',algKey:'gmm_clustering'},
                {name:'Mini-Batch KMeans',algKey:'mini_batch_kmeans_clustering'},
                {name:'Agglomerative clustering',algKey:'ward_clustering'},
                {name:'Spectral clustering',algKey:'spectral_clustering'},
                {name:'DBSCAN',algKey:'db_scan_clustering'},
                {name:'Interactive clustering',algKey:'two_step'},
                {name:'Isolation Forest',algKey:'isolation_forest'},
            ],
            MLLIB: [
                {name:'KMeans',algKey:'mllib_kmeans_clustering'},
                {name:'Gaussian Mixture',algKey:'mllib_gaussian_mixture_clustering'},
                {name:'Interactive clustering',algKey:'two_step'},
                {name:'Isolation Forest',algKey:'isolation_forest'},
            ],
            H2O :[
                {name:'KMeans',algKey:'h2o_kmeans'},
            ],
        }, algorithmCategories: {
            "KMeans": ['KMEANS', 'MiniBatchKMeans'],
            "Hierarchical": ['WARD'],
            "Spectral": ['SPECTRAL'],
            "Density-based": ['DBSCAN', 'OPTICS']
        }, noDollarKey: function(k) {
            return !k.startsWith('$') && k != "_name" && k != "datasetColumnId" && k != "userModified";
        },
    };
    cst.sort.lowerIsBetter = function (e, customEvaluationMetricGIB) {
        if (e === "CUSTOM") {
            if (customEvaluationMetricGIB == undefined) {return false;}
            else {return !customEvaluationMetricGIB;}
        }
        return (cst.sort.lowerBetter.indexOf(e) !== -1);
    };
    return cst;
});


app.controller("CMLTaskBaseController", function($scope, $timeout, $controller, Assert, DataikuAPI, CMLSettings, CMLFilteringService,
            $state, $stateParams, TopNav, Collections, Dialogs, CreateModalFromTemplate, Fn) {
    $scope.MLAPI = DataikuAPI.analysis.cml;
    $scope.FilteringService = CMLFilteringService;
    $scope.SettingsService = CMLSettings;

    $scope.$state = $state;
    $scope.sRefPrefix = 'projects.project.analyses.analysis.ml.clustmltask';
    $scope.algorithmCategories = CMLSettings.algorithmCategories;
    $scope.base_algorithms = CMLSettings.base_algorithms;
    $scope.metricMap = CMLFilteringService.metricMap;
    $scope.outliersMethods = CMLSettings.task.outliersMethods;

    $controller("_MLTaskBaseController",{$scope:$scope});

    $scope.newTrainSessionModalDisplayed = false;
    function newTrainSessionCallback() {
        DataikuAPI.analysis.cml.getUpdatedSettings($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId).success(function(data){
            DataikuAPI.analysis.cml.saveSettings($stateParams.projectKey, $stateParams.analysisId, data).success(function(data){
                if (!$scope.newTrainSessionModalDisplayed) {
                    $scope.newTrainSessionModalDisplayed = true;
                    CreateModalFromTemplate("/templates/analysis/clustering/pre-train-modal.html", $scope, "CMLTaskPreTrainModal").then(function(){
                        $scope.newTrainSessionModalDisplayed = false;
                        $scope.initialRefreshAndAutoRefresh();
                        if ($state.current.name !== $scope.sRefPrefix + '.list.results') {
                            $state.go($scope.sRefPrefix + '.list.results');
                        } else {
                            $scope.uiState.viewMode = "sessions";
                        }
                    }, function(){
                        $scope.newTrainSessionModalDisplayed = false;
                    });
                }
            }).error(setErrorInScope.bind($scope));
        }).error(setErrorInScope.bind($scope));
    }
    $scope.newTrainSession = function() {
        if ($scope.dirtySettings()) { $scope.saveSettings().then(newTrainSessionCallback) }
        else { newTrainSessionCallback() }
    };

    $scope.saveSettings = function() {
        Assert.inScope($scope, "mlTaskDesign");

        return DataikuAPI.analysis.cml.saveSettings($stateParams.projectKey, $stateParams.analysisId, $scope.mlTaskDesign).success(function(data) {
            resetErrorInScope($scope);
            $scope.savedSettings = dkuDeepCopy($scope.mlTaskDesign, CMLSettings.noDollarKey);
        }).error(setErrorInScope.bind($scope));
    };

    // watchers & init

    DataikuAPI.analysis.mlcommon.getLastPreprocessingStatus($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId).success(function(data){
        $scope.lastPreprocessingStatus = data;
    }).error(setErrorInScope.bind($scope));

    // to be run if not guessing
    $scope.initMlTaskDesign = function() {
        $scope.$watch("analysisCoreParams", function(nv, ov) {
            if (!nv) return;
            DataikuAPI.analysis.cml.getUpdatedSettings($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId).success(function(data){
                $scope.setMlTaskDesign(data);
                
                DataikuAPI.analysis.cml.listGuessPolicies().success(data => {
                    $scope.guessPolicies = data.auto.concat(data.expert).filter(policy => policy.id !== 'ALGORITHMS'); // useless (choose from all algos)
                    $scope.guessPolicies = $scope.prepareGuessPolicies($scope.guessPolicies);
                }).error(setErrorInScope.bind($scope));    

                $scope.savedSettings = dkuDeepCopy($scope.mlTaskDesign, CMLSettings.noDollarKey);
                $scope.uiState.algorithm = $scope.base_algorithms[data.backendType]
                    .filter(function(o){ return (!o.condition || o.condition()) })[0].algKey;
                $scope.uiState.userPredictionType = data.predictionType;
           }).error(setErrorInScope.bind($scope));
        });
    }
});


app.controller("CMLTaskResultController", function($scope, $controller) {
    $controller("_MLTaskResultsController", {$scope});

});


app.controller("CMLTaskDesignController", function($scope, $controller, $state, $stateParams,
            DataikuAPI, TopNav, Dialogs, CreateModalFromTemplate, Fn, CMLSettings, PMLSettings, CMLFilteringService,
            WT1) {
    $controller("_MLTaskDesignController",{$scope:$scope});
    
    $scope.addCustomPython = function() {
        var code = "# This sample code uses a standard scikit-learn algorithm, the Birch clustering.\n\n" +
                   "# Your code must create a 'clf' variable. This clf must be a scikit-learn compatible\n" +
                   "# model, ie, it should:\n" +
                   "#  1. have at least fit(X), fit_predict(X) and predict(X) methods\n" +
                   "#  2. inherit sklearn.base.BaseEstimator\n" +
                   "#  3. handle the attributes in the __init__ function\n" +
                   "#     See: https://doc.dataiku.com/dss/latest/machine-learning/custom-models.html\n\n" +
                   "from sklearn.cluster import Birch\n\n"+
                   "clf = Birch(n_clusters=5)\n"

        $scope.mlTaskDesign.modeling.custom_python = $scope.mlTaskDesign.modeling.custom_python || [];
        var expectedAlgKey = 'custom_python_' + $scope.mlTaskDesign.modeling.custom_python.length;
        $scope.uiState.algorithm = expectedAlgKey;
        $scope.mlTaskDesign.modeling.custom_python.push({
            enabled: true,
            k: [5],
            name: "Custom Python model",
            code: code,
        });
    };

    $scope.addCustomMLLib = function() {
        var code = "// This sample code uses a standard MLlib algorithm, the KMeans.\n\n" +
                   "// import the Estimator from spark.ml\n" +
                   "import org.apache.spark.ml.clustering.KMeans\n\n" +
                   "// instantiate the Estimator\n" +
                   "new KMeans()\n" +
                   "  .setFeaturesCol(\"__dku_features\") // Must always be __dku_features\n" +
                   "  .setPredictionCol(\"cluster\") // Must always be cluster\n" +
                   "  .setK(5)\n";

        $scope.mlTaskDesign.modeling.custom_mllib = $scope.mlTaskDesign.modeling.custom_mllib || [];
        var expectedAlgKey = 'custom_mllib_' + $scope.mlTaskDesign.modeling.custom_mllib.length;
        $scope.uiState.algorithm = expectedAlgKey;
        $scope.mlTaskDesign.modeling.custom_mllib.push({
            enabled: true,
            k: [5],
            name: "Custom MLlib model",
            initializationCode: code,
        });
    };

    $scope.getAlgorithmTemplate = function() {
        if (!$scope.uiState||!$scope.uiState.algorithm) {
            return;
        } else if ($scope.uiState.algorithm.startsWith("custom")) {
            return '/templates/analysis/clustering/settings/algorithms/'+$scope.mlTaskDesign.backendType.toLowerCase()+'/custom.html'
        } else {
            return '/templates/analysis/clustering/settings/algorithms/'+$scope.mlTaskDesign.backendType.toLowerCase()+'/'+$scope.uiState.algorithm+'.html'
        }
    };

    $scope.reguessAll = function(){
        Dialogs.confirm($scope, "Reguess", "Are you sure you want to reguess? All settings will be reset").then(function(){
            DataikuAPI.analysis.cml.reguess($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId)
                .success(function(data){
                    $scope.setMlTaskDesign(data);
                    $scope.savedSettings = dkuDeepCopy($scope.mlTaskDesign, CMLSettings.noDollarKey);
                })
        });
    };

    $scope.copyAlgorithmSettings = function(exportSettings) {
        if ($scope.dirtySettings()) {
                $scope.saveSettings();
        }
        DataikuAPI.projects.listHeads(exportSettings ? 'WRITE_CONF' : null).success(function(projectData) {
             CreateModalFromTemplate("/templates/analysis/mlcommon/settings/copy-settings.html", $scope, null, function(newScope) {
                 newScope.projects = projectData;
                 newScope.totem = "icon-" + (exportSettings ? "copy" : "paste");
                 newScope.title = "Copy algorithms " + (exportSettings ? "to" : "from");
                 newScope.selectedProjectKey = $stateParams.projectKey;
                 newScope.analyses = $scope.analyses;
                 newScope.selectedAnalysisId = $stateParams.analysisId;
                 newScope.infoMessages = ["You can only choose a clustering model using a "
                                            + ($scope.backendTypeNames[$scope.mlTaskDesign.backendType] || $scope.mlTaskDesign.backendType)
                                            + " engine"];
                 newScope.selectProject = function() {
                     DataikuAPI.analysis.listHeads(newScope.selectedProjectKey).success(function(analysisData) {
                         newScope.analyses = analysisData;
                         newScope.selectedAnalysisId = undefined;
                         newScope.selectedTask = undefined;
                     }).error(setErrorInScope.bind($scope));
                 };
                 newScope.selectAnalysis = function() {
                     DataikuAPI.analysis.listMLTasks(newScope.selectedProjectKey, newScope.selectedAnalysisId)
                     .success(function(taskData) {
                         newScope.tasks = taskData;
                         newScope.descriptions = [];
                         newScope.tasks.forEach(task => {
                             // task can be selected if it is not the current one + is a clustering + same backend
                             task.isNotSelectable = task.mlTaskId === $stateParams.mlTaskId
                                                && newScope.selectedAnalysisId === $stateParams.analysisId
                                                && newScope.selectedProjectKey === $stateParams.projectKey
                                                || task.backendType !== $scope.mlTaskDesign.backendType
                                                || task.taskType !== "CLUSTERING";
                             newScope.descriptions.push($scope.displayTypes[task.predictionType || task.taskType] + " ("
                             + ($scope.backendTypeNames[task.backendType] || task.backendType) + ")");
                         });
                         newScope.selectedTask = undefined;
                     }).error(setErrorInScope.bind($scope));
                 };
                 if (newScope.projects.some(_ => _.projectKey === $stateParams.projectKey)) {
                     newScope.selectedProjectKey = $stateParams.projectKey;
                     newScope.analyses = $scope.analyses;
                     newScope.selectedAnalysisId = $stateParams.analysisId;
                     newScope.selectAnalysis();
                 }
                 newScope.confirm = function() {
                    if (exportSettings) {
                        DataikuAPI.analysis.cml.copyAlgorithmSettings($stateParams.projectKey, $stateParams.analysisId,
                            $stateParams.mlTaskId, newScope.selectedProjectKey, newScope.selectedAnalysisId,
                            newScope.selectedTask.mlTaskId).error(setErrorInScope.bind($scope));
                    } else {
                        DataikuAPI.analysis.cml.copyAlgorithmSettings(newScope.selectedProjectKey, newScope.selectedAnalysisId,
                            newScope.selectedTask.mlTaskId, $stateParams.projectKey, $stateParams.analysisId,
                            $stateParams.mlTaskId).success(function(data) {
                                $scope.setMlTaskDesign(data);
                        }).error(setErrorInScope.bind($scope));
                    }
                    WT1.event("mltask-copy-algorithms", {
                        export: exportSettings,
                        sameProject: $stateParams.projectKey === newScope.selectedProjectKey,
                        sameAnalysis: $stateParams.analysisId === newScope.selectedAnalysisId,
                        typeDest: "CLUSTERING",
                        typeSrc: "CLUSTERING"
                    });
                    newScope.dismiss();
                 };
                 newScope.cancel = function() {
                     newScope.dismiss();
                 };
             });
        }).error(setErrorInScope.bind($scope));
    };

    $scope.$watch('mlTaskDesign', function(nv){
        if (nv) {
            if (nv.guessPolicy === 'CUSTOM' && nv.backendType === 'PY_MEMORY' && $scope.mlTaskDesign.modeling.custom_python.length > 0) {
                let expectedAlgKey = 'custom_python_' + ($scope.mlTaskDesign.modeling.custom_python.length - 1);
                $scope.uiState.algorithm = expectedAlgKey;
            }

            if (nv.guessPolicy === 'CUSTOM' && nv.backendType === 'MLLIB' && $scope.mlTaskDesign.modeling.custom_mllib.length > 0) {
                let expectedAlgKey = 'custom_mllib_' + ($scope.mlTaskDesign.modeling.custom_mllib.length - 1);
                $scope.uiState.algorithm = expectedAlgKey;
            }
            
            $scope.retrieveCodeEnvsInfo();
        }
    });
});

app.controller("CMLTaskSamplingController", function($scope, $timeout, $stateParams, DataikuAPI, DatasetUtils){
    DatasetUtils.listDatasetsUsabilityForAny($stateParams.projectKey).success(function(data){
        $scope.availableDatasets = data;
    });
});

app.controller("CMLTaskReductionController", function($scope, $controller, $timeout, $stateParams, Assert, DataikuAPI, DatasetUtils){
    Assert.inScope($scope, "mlTaskDesign");
    // This code handles the mapping between how reduce options are presented to the user (radio boxes)
    // & how we handle them internally (two booleans)
    $scope.$watch("mlTaskDesign.preprocessing.reduce", function(nv, ov) {
        if (nv == null) return;
        if (!nv.disable && !nv.enable) {
            if (ov.disable) {
                nv.enable = true;
            } else {
                nv.disable = true;
            }
        }
        if (nv.disable && nv.enable) {
            $scope.modelUI.reduceOption = "both";
        } else if (nv.disable && !nv.enable) {
            $scope.modelUI.reduceOption = "disable";
        } else {
            $scope.modelUI.reduceOption = "enable";
        }
    }, true);
    $scope.modelUI = { reduceOption : 'disable'};

    $scope.$watch('modelUI.reduceOption', function(nv, ov) {
        if(!nv) return;
        if($scope.modelUI.reduceOption=='both') {
            $scope.mlTaskDesign.preprocessing.reduce.disable = true;
            $scope.mlTaskDesign.preprocessing.reduce.enable = true;
        } else if($scope.modelUI.reduceOption=='enable') {
            $scope.mlTaskDesign.preprocessing.reduce.disable = false;
            $scope.mlTaskDesign.preprocessing.reduce.enable = true;
        } else  {
            $scope.mlTaskDesign.preprocessing.reduce.disable = true;
            $scope.mlTaskDesign.preprocessing.reduce.enable = false;
        }
        if ($scope.mlTaskDesign.preprocessing.reduce.enable && !$scope.mlTaskDesign.preprocessing.reduce.kept_variance) {
            $scope.mlTaskDesign.preprocessing.reduce.kept_variance = 0.9;
        }
    });
});


app.controller("CMLTaskPreTrainModal", function($scope, $stateParams, $state, DataikuAPI, WT1, Logger) {
    $scope.uiState = {
        confirmRun: false
    };

    DataikuAPI.analysis.cml.getPreTrainStatus($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId).success(function(data) {
        $scope.preTrainStatus = data;
        $scope.splitStatus = data.splitStatus;
        $scope.uiState.anyError = data.messages.some(x => x.severity == 'FATAL');
        $scope.uiState.anyWarning = data.messages.some(x => x.severity == 'WARNING');
    }).error(setErrorInScope.bind($scope));

    $scope.train = function() {
        try {
            const algorithms = {};
            $.each($scope.mlTaskDesign.modeling, function(alg, params) {
                if (params.enabled){
                    algorithms[alg] = params;
                }
            });
            WT1.event("clustering-train", {
                backendType: $scope.mlTaskDesign.backendType,
                nbModelsPreGS: $scope.preTrainStatus.nbModelsPreGS,
                taskType: $scope.mlTaskDesign.taskType,
                guessPolicy: $scope.mlTaskDesign.guessPolicy,
                feature_generation: JSON.stringify($scope.mlTaskDesign.preprocessing.feature_generation),
                outliers: JSON.stringify($scope.mlTaskDesign.preprocessing.outliers),
                reduce: JSON.stringify($scope.mlTaskDesign.preprocessing.reduce),
                algorithms: JSON.stringify(algorithms),
                metrics: JSON.stringify($scope.mlTaskDesign.modeling.metrics),
                hasSessionName: !!$scope.uiState.userSessionName,
                hasSessionDescription: !!$scope.uiState.userSessionDescription
            });
        } catch (e) {
            Logger.error('Failed to report mltask info', e);
        }
        DataikuAPI.analysis.cml.trainStart($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId,
            $scope.uiState.userSessionName, $scope.uiState.userSessionDescription, $scope.uiState.forceRefresh)
        .success(function(data) {
            $scope.resolveModal();
        }).error(setErrorInScope.bind($scope));
    };
})

})();

(function(){
'use strict';

var app = angular.module('dataiku.analysis.mlcore');


/**
 * Controllers, services and directives for the views of a single model
 * of a MLTask
 */

/**
 * Injected into all controllers that display a single CMLTask model.  Handles:
 *   - the global nav handle to switch between PMLTask models
 *   - setting the top nav item
 */
app.controller("_CMLModelBaseController", function($scope, $controller, DataikuAPI, TopNav, $stateParams, CreateModalFromTemplate, $q, CMLFilteringService){
    $controller("_ModelUtilsController", {$scope:$scope});
    $controller("_MLModelBaseController",{$scope:$scope});
    $controller("downloadModelController", {$scope:$scope});

    $scope.whenHasModel = function(){
        if ($scope.modelData) return $q.when(null);
        else {
            return DataikuAPI.ml.clustering.getModelDetails($stateParams.fullModelId).success(function(data){
                $scope.modelData = data;
                // Signal to Puppeteer that the content of the element has been loaded and is thus available for content extraction
                $scope.puppeteerHook_elementContentLoaded = true;
            });
        }
    }

    $scope.whenHasModel().then(function(){
        var algoName = $scope.modelData.modeling.algorithm;
        $scope.mlTasksContext.noPredicted = /^(MLLIB|SPARKLING|VERTICA|PYTHON_ENSEMBLE|SPARK_ENSEMBLE)/i.test(algoName);
        $scope.mlTasksContext.noExport = $scope.mlTasksContext.noPredicted; //todo: check this is correct for clustering
    });

    $scope.mlTasksContext.delete = function() {
        $scope.deleteTrainedAnalysisModel();
    }

    $scope.mlTasksContext.deploy = function(){
        $scope.whenHasModel().then(function(){
             CreateModalFromTemplate("/templates/analysis/clustering/model/deploy-modal.html",
                $scope,"AnalysisClusteringDeployController");
        });
    }
    $scope.mlTasksContext.exportNotebook = function(){
        $scope.whenHasModel().then(function(){
            CreateModalFromTemplate("/templates/analysis/mlcommon/export-notebook-modal.html",
            $scope,"AnalysisClusteringExportNotebookController");
        });
    }

    DataikuAPI.analysis.cml.getModelSnippets($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId).success(function(data){
        if (!$scope.mlTasksContext.activeMetric) {
            $scope.mlTasksContext.activeMetric = "SILHOUETTE"; // Temporary data.task.modeling.metrics.evaluationMetric;
        }
        $scope.mlTasksContext.models = Object.values(data).filter(function(m){
            return m.trainInfo.state == "DONE" && m.fullModelId != $stateParams.fullModelId;
        });
        $scope.mlTasksContext.models.sort(function(a, b) {
            var stardiff = (0+b.userMeta.starred) - (0+a.userMeta.starred)
            if (stardiff !=0) return stardiff;
            return b.sessionDate - a.sessionDate;
        });
        $scope.mlTasksContext.models.forEach(function(m){
            m.mainMetric = CMLFilteringService.getMetricFromSnippet(m, $scope.mlTasksContext.activeMetric);
        });
    }).error(setErrorInScope.bind($scope));
});


app.controller("CMLModelReportController", function($scope, $controller, TopNav, WebAppsService) {
    TopNav.setLocation(TopNav.TOP_ANALYSES, null, "CLUSTERING-ANALYSIS-MODEL", "report");

    $controller("_CMLModelBaseController",{$scope:$scope});
    $controller("_ClusteringModelReportController", {$scope:$scope});

    $scope.whenHasModel().then(function() {
        const contentType = `${$scope.modelData.coreParams.taskType}/${$scope.modelData.coreParams.backendType}/${$scope.modelData.modeling.algorithm}`.toLowerCase();
        $scope.modelSkins = WebAppsService.getSkins('ANALYSIS', '', contentType);
    });
});


app.controller("AnalysisClusteringDeployClusterRecipeController", function($scope, $stateParams, $controller, $state, Assert, DataikuAPI, DatasetUtils) {
    $scope.recipeType = "clustering_cluster";
    $controller("SingleOutputDatasetRecipeCreationController", {$scope:$scope});

    $scope.scoringRecipe = {};

    $scope.autosetName = function() {
        if ($scope.io.inputDataset) {
            const niceInputName = $scope.io.inputDataset.replace(/\w+\./,"");
            $scope.maybeSetNewDatasetName(niceInputName + "_clustered");
        }
    };
    $scope.deployCluster = function() {
        Assert.inScope($scope, "newOutputDataset");

        // build the 'settings' object, from the bits the template for the new dataset creation puts in place
        $scope.newOutputDataset.settings = {
            connectionId: $scope.newOutputDataset.connectionOption.id,
            specificSettings: {
                formatOptionId: $scope.newOutputDataset.formatOptionId,
                overrideSQLCatalog: $scope.newOutputDataset.overrideSQLCatalog,
                overrideSQLSchema: $scope.newOutputDataset.overrideSQLSchema
            },
            partitioningOptionId: $scope.newOutputDataset.partitioningOption || 'NP'
        };

        DataikuAPI.analysis.cml.deployCluster($stateParams.fullModelId,
            $scope.io.inputDataset,
            $scope.newOutputDataset.name,
            $scope.newOutputDataset.settings
        ).success(function(data) {
            $scope.dismiss();
            $state.go("projects.project.flow");
        }).error(setErrorInScope.bind($scope));
    }

    DatasetUtils.listDatasetsUsabilityInAndOut($stateParams.projectKey, "clustering_cluster").then(function(data){
        $scope.availableInputDatasets = data[0];
    });
});


app.controller("AnalysisClusteringDeployController", function($scope, $controller, DataikuAPI, $state, $stateParams, Assert, TopNav, DatasetUtils, Dialogs){

    $scope.uiState = { selectedMode: null };
    $scope.partitioningOptions = [{id: "NP", label: "Not partitioned"}];

    $scope.canCreateClusterRecipe = function(){
        return ['MLLIB_TWO_STEP', 'PY_TWO_STEP', 'VERTICA_KMEANS'].indexOf($scope.getAlgorithm()) == -1;
    };

    $scope.isCentroidType = function() {
        return ['KMEANS',
                'MiniBatchKMeans',
                'GMM',
                'MLLIB_KMEANS',
                'MLLIB_GAUSSIAN_MIXTURE',
                'VERTICA_KMEANS',
                'SPARKLING_KMEANS',
                'MLLIB_CUSTOM',
                'MLLIB_TWO_STEP',
                'PY_TWO_STEP',
                'PY_ISOLATION_FOREST',
                'MLLIB_ISOLATION_FOREST'].indexOf($scope.getAlgorithm()) >= 0;
    };

    $scope.onSelectTrain = function(){
        $scope.uiState.selectedMode = 'train';
        $scope.formData = {};
        function autoSetModelName() {
            var algo = $scope.getAlgorithm();
            if (!$scope.formData.modelName && $scope.formData.inputDatasetSM) {
                $scope.formData.modelName = "Clustering (" + algo + ") on " + $scope.formData.inputDatasetSM;
            }
        }
        $scope.$watch("inputDatasetSM",autoSetModelName);

        $scope.formData.inputDatasetSM = $scope.analysisCoreParams.inputDatasetSmartName;

        $scope.deployTrain = function() {
            DataikuAPI.analysis.cml.deployTrain($stateParams.fullModelId,
                $scope.formData.inputDatasetSM,
                $scope.formData.modelName
            ).success(function(data){
                $scope.dismiss();
                $state.go("projects.project.flow");
            }).error(setErrorInScope.bind($scope));
        }
    };

    $scope.onSelectRedeployTrain = function() {
        $scope.uiState.selectedMode = 'redeploy-train';
        $scope.formData = {
            redeployTrainRecipeName: $scope.redeployableTrains.length === 1
                ? $scope.redeployableTrains[0].recipeName : null,
            redeployTrainActivate: true
        };
        $scope.redeployTrain = function() {
            DataikuAPI.analysis.cml.redeployTrain($stateParams.fullModelId,
                $scope.formData.redeployTrainRecipeName,
                $scope.formData.redeployTrainActivate
            ).success(function(data){
                var go = $state.go.bind($state, "projects.project.flow");
                var parentScope = $scope.$parent;
                $scope.dismiss();
                if (data.schemaChanged) {
                    Dialogs.ack(parentScope, "Schema changed",
                        "The preparation script schema of the updated version is different than the previously " +
                        "selected version, this may affect the ouput schema of downstream scoring recipes."
                    ).then(go);
                } else {
                    go();
                }
            }).error(setErrorInScope.bind($scope));
        };
    };

    $scope.onWantTrain = function() {
        if ($scope.redeployableTrains && $scope.redeployableTrains.length) {
            $scope.uiState.selectedMode = 'can-redeploy-train';
            $scope.canRedeployTrain = true;
        } else {
            $scope.onSelectTrain();
        }
    };

    $scope.onSelectCluster = function() {
        fetchManagedDatasetConnections($scope, DataikuAPI);
        $scope.uiState.selectedMode = 'cluster';
        $scope.io = {};

        $scope.deployCluster = function() {
            Assert.inScope($scope, "newDataset");

            // build the 'settings' object, from the bits the template for the new dataset creation puts in place
            $scope.newDataset.settings = {
                connectionId:$scope.newDataset.connectionOption.id,
                specificSettings : {
                    formatOptionId:$scope.newDataset.formatOptionId,
                    overrideSQLCatalog : $scope.newDataset.overrideSQLCatalog,
                    overrideSQLSchema : $scope.newDataset.overrideSQLSchema
                },
                partitioningOptionId:$scope.newDataset.partitioningOption || 'NP'
            }

            DataikuAPI.analysis.cml.deployCluster($stateParams.fullModelId,
                $scope.io.mainInputDataset,
                $scope.newDataset.name,
                $scope.newDataset.settings
            ).success(function(data) {
                $scope.dismiss();
                $state.go("projects.project.flow");
            }).error(setErrorInScope.bind($scope));
        };
    };

    $scope.onSelectRedeployCluster = function() {
        $scope.uiState.selectedMode = 'redeploy-cluster';
        $scope.formData = {
            redeployClusterRecipeName: $scope.redeployableClusters.length === 1
                ? $scope.redeployableClusters[0].recipeName : null
        };
        $scope.redeployCluster = function() {
            DataikuAPI.analysis.cml.redeployCluster($stateParams.fullModelId,
                $scope.formData.redeployClusterRecipeName
            ).success(function(data){
                var parentScope = $scope.$parent;
                $scope.dismiss();
                if (data.schemaChanged) {
                    Dialogs.ack(parentScope, "Schema changed",
                        "The preparation script schema of the updated version is different than before, " +
                        "you may want to check the output schema of this clustering recipe."
                    ).then($state.go.bind($state, "projects.project.recipes.recipe", {recipeName: $scope.formData.redeployClusterRecipeName}));
                } else {
                    $state.go("projects.project.flow");
                }
            }).error(setErrorInScope.bind($scope));
        };
    };

    $scope.onWantCluster = function() {
        if ($scope.redeployableClusters && $scope.redeployableClusters.length) {
            $scope.uiState.selectedMode = 'can-redeploy-cluster';
            $scope.canRedeployCluster = true;
        } else {
            $scope.onSelectCluster();
        }
    };

    function main() {
        Assert.inScope($scope, "modelData");
        Assert.inScope($scope, "analysisCoreParams");

        DataikuAPI.analysis.cml.listRedeployableCluster($stateParams.fullModelId).success(function(data) {
            $scope.redeployableClusters = data;
        });
        if ($scope.isCentroidType()) {
            DataikuAPI.analysis.cml.listRedeployableTrain($stateParams.fullModelId).success(function(data) {
                $scope.redeployableTrains = data;
            });
        }

        DatasetUtils.listDatasetsUsabilityForAny($stateParams.projectKey).success(function(data){
            $scope.availableDatasets = data;
        });
    };
    main();
});


app.controller("AnalysisClusteringExportNotebookController", function($scope, $controller, Assert, DataikuAPI, $state, $stateParams, TopNav){
    Assert.inScope($scope, "modelData");
    Assert.inScope($scope, "analysisCoreParams");
    $scope.formData = {};

    $scope.formData.notebookName = "Cluster "+ $scope.analysisCoreParams.inputDatasetSmartName.replace(/\./g, '_');

    $scope.createNotebook = function(){
        DataikuAPI.analysis.cml.createNotebook($stateParams.fullModelId, $scope.formData.notebookName)
            .success(function(data){
                $scope.dismiss();
                $state.go("projects.project.notebooks.jupyter_notebook", {notebookId : data.id});
            }).error(setErrorInScope.bind($scope));
    }
});

app.directive("analysisClusteringPredictedTable", function(MonoFuture, $q, Assert, WT1, TopNav){
    return {
        scope: true,
        priority : 1,
        controller : function($scope, $stateParams, $state, DataikuAPI, $controller) {
            Assert.inScope($scope, "loadMLTask");

            $controller("_CMLModelBaseController",{$scope:$scope});
            WT1.event("analysis-cmltask-model-table-open");
            TopNav.setLocation(TopNav.TOP_ANALYSES, null, "CLUSTERING-ANALYSIS-MODEL", "predictedtable");
            $scope.loadMLTask();

            DataikuAPI.ml.clustering.getModelDetails($stateParams.fullModelId).success(function(data){
                if ($scope.mlTasksContext) $scope.mlTasksContext.model = data;
                // Signal to Puppeteer that the content of the element has been loaded and is thus available for content extraction
                $scope.puppeteerHook_elementContentLoaded = true;
            });
        }
    }
});


app.directive('analysisClusteringPredictedCharts', function(DataikuAPI, WT1, TopNav, DatasetUtils) {
 return {
        scope: true,
        controller: function ($scope, $stateParams, $state, $controller) {
            WT1.event("analysis-cmltask-model-charts-open");
            TopNav.setLocation(TopNav.TOP_ANALYSES, null, "CLUSTERING-ANALYSIS-MODEL", "charts");
            $controller("_CMLModelBaseController",{$scope:$scope});

            DataikuAPI.analysis.mlcommon.getCurrentSettings($stateParams.projectKey, $stateParams.analysisId, $stateParams.mlTaskId).success(function(data){
                $scope.mlTaskDesign = data;
                $scope.shaker = data.predictionDisplayScript;
                $scope.charts = data.predictionDisplayCharts;
                $scope.onSettingsLoaded();
            }).error(setErrorInScope.bind($scope));

            DataikuAPI.ml.clustering.getModelDetails($stateParams.fullModelId).success(function(data){
                if ($scope.mlTasksContext) $scope.mlTasksContext.model = data;
                // Signal to Puppeteer that the content of the element has been loaded and is thus available for content extraction
                $scope.puppeteerHook_elementContentLoaded = true;
            });
        }
    };
});

})();

(function(){
'use strict';

const app = angular.module('dataiku.savedmodels', ['dataiku.ml.report', 'dataiku.lambda']);


app.service("SavedModelsService", function($q, DataikuAPI, $stateParams, CreateModalFromTemplate, SmartId, $rootScope,
    ActiveProjectKey, FullModelIdUtils) {
    var listModels = function(projectKey, type) {
        var deferred = $q.defer();
        DataikuAPI.savedmodels.listWithAccessible(projectKey).success(function(data){
            var savedModels = data.filter(function(sm) { return sm.miniTask.taskType === type; });
            savedModels.forEach(function(sm) {
                if (sm.projectKey !== projectKey) {
                    sm.name = sm.projectKey + "." + sm.name;
                    sm.id = sm.projectKey + "." + sm.id;
                }
            });
            deferred.resolve(savedModels);
        });
        return deferred.promise;
    };

    var svc = {
        listPredictionModels: function(projectKey) {
            return listModels(projectKey, 'PREDICTION');
        },
        listClusteringModels: function(projectKey) {
            return listModels(projectKey, 'CLUSTERING');
        },
        isActiveVersion: function(fullModelId, savedModel) {
            if (!fullModelId || !savedModel) return;
            return FullModelIdUtils.parse(fullModelId).versionId === savedModel.activeVersion;
        },
        isPartition: function(fullModelId) {
            if (!fullModelId) return;
            return !!FullModelIdUtils.parse(fullModelId).partitionName;
        },
        createAndPinInsight: function(model, settingsPane, fullModelId) {
            var insight = {
                projectKey: ActiveProjectKey.get(),
                type: 'saved-model_report',
                params: {savedModelSmartId: SmartId.create(model.id, model.projectKey)},
                name: "Full report of model " + model.name
            };

            if (fullModelId) {
                insight.params.fullModelId = fullModelId;
            }

            if (settingsPane) {
                var params = {displayMode: settingsPane};
            }

            CreateModalFromTemplate("/templates/dashboards/insights/create-and-pin-insight-modal.html", $rootScope, "CreateAndPinInsightModalController", function (newScope) {
                newScope.init(insight, params);
            });
        }
    };

    return svc;
});

/* ************************************ List / Right column  *************************** */

app.controller("SavedModelPageRightColumnActions", function($controller, $scope, $rootScope, DataikuAPI, $stateParams, ActiveProjectKey) {

    $controller('_TaggableObjectPageRightColumnActions', {$scope: $scope});

    $scope.selection = {};

    DataikuAPI.savedmodels.get(ActiveProjectKey.get(), $stateParams.smId).success((data) => {
        data.description = data.shortDesc;
        data.nodeType = 'LOCAL_SAVEDMODEL';
        data.name = data.id;
        data.interest = {};

        $scope.selection = {
            selectedObject : data,
            confirmedItem : data,
        };

        updateUserInterests();

    }).error(setErrorInScope.bind($scope));

    function updateUserInterests() {
        DataikuAPI.interests.getForObject($rootScope.appConfig.login, "SAVED_MODEL", ActiveProjectKey.get(), $stateParams.smId).success(function(data) {

            $scope.selection.selectedObject.interest.watching = data.watching;
            $scope.selection.selectedObject.interest.starred = data.starred;

        }).error(setErrorInScope.bind($scope));
    }

    const interestsListener = $rootScope.$on('userInterestsUpdated', updateUserInterests);
    $scope.$on("$destroy", interestsListener);
});


app.directive('savedModelRightColumnSummary', function($controller, $state, $stateParams, SavedModelCustomFieldsService, $rootScope, FlowGraphSelection,
    DataikuAPI, CreateModalFromTemplate, QuickView, TaggableObjectsUtils, SavedModelsService, LambdaServicesService, ActiveProjectKey, ActivityIndicator, SelectablePluginsService) {

    return {
        templateUrl :'/templates/savedmodels/right-column-summary.html',

        link : function(scope, element, attrs) {
            $controller('_TaggableObjectsMassActions', {$scope: scope});

            scope.$stateParams = $stateParams;
            scope.QuickView = QuickView;
            scope.LambdaServicesService = LambdaServicesService;

            scope.createAndPinInsight = SavedModelsService.createAndPinInsight;

            scope.getSmartName = function (projectKey, name) {
                if (projectKey == ActiveProjectKey.get()) {
                    return name;
                } else {
                    return projectKey + '.' + name;
                }
            }

            scope.refreshData = function() {
                var projectKey = scope.selection.selectedObject.projectKey;
                var name = scope.selection.selectedObject.name;
                DataikuAPI.savedmodels.getFullInfo(ActiveProjectKey.get(), scope.getSmartName(projectKey, name)).success(function(data){
                    if (!scope.selection.selectedObject || scope.selection.selectedObject.projectKey != projectKey || scope.selection.selectedObject.name != name) {
                        return; // too late!
                    }
                    scope.savedModelData = data;
                    scope.savedModel = data.model;
                    scope.savedModel.zone = (scope.selection.selectedObject.usedByZones || [])[0] || scope.selection.selectedObject.ownerZone;
                    scope.isLocalSavedModel = projectKey == ActiveProjectKey.get();
                }).error(setErrorInScope.bind(scope));
            };

            scope.publishEnabled = function() {
                if (!$state.is('projects.project.savedmodels.savedmodel.prediction.report')
                    && !$state.is('projects.project.savedmodels.savedmodel.clustering.report')) {
                    return true;
                }
                if (SavedModelsService.isPartition($stateParams.fullModelId)) {
                    scope.publishDisabledReason = "Only the overall model can be published";
                    return false;
                }
                if (!SavedModelsService.isActiveVersion($stateParams.fullModelId, scope.smContext.savedModel)) {
                    scope.publishDisabledReason = "Only the active version can be published";
                    return false;
                }
                return true;
            }

            scope.$on("objectSummaryEdited", function() {
                DataikuAPI.savedmodels.save(scope.savedModel, {summaryOnly: true})
                .success(function(data) {
                    ActivityIndicator.success("Saved");
                }).error(setErrorInScope.bind(scope));
            });

            scope.$watch("selection.selectedObject",function() {
                if(scope.selection.selectedObject != scope.selection.confirmedItem) {
                    scope.savedModel = null;
                    scope.objectTimeline = null;
                }
            });

            scope.$watch("selection.confirmedItem", function(nv, ov) {
                if (!nv) {
                    return;
                }
                if (!nv.projectKey) {
                    nv.projectKey = ActiveProjectKey.get();
                }
                scope.refreshData();
            });

            scope.zoomToOtherZoneNode = function(zoneId) {
                const otherNodeId = scope.selection.selectedObject.id.replace(/zone__.+?__saved/, "zone__" + zoneId + "__saved");
                if ($stateParams.zoneId) {
                    $state.go('projects.project.flow', Object.assign({}, $stateParams, { zoneId: zoneId, id: graphVizUnescape(otherNodeId) }))
                }
                else {
                    scope.zoomGraph(otherNodeId);
                    FlowGraphSelection.clearSelection();
                    FlowGraphSelection.onItemClick(scope.nodesGraph.nodes[otherNodeId]);
                }
            }

            scope.isSMZoneInput = function() {
                return (scope.selection.selectedObject.usedByZones.length && scope.selection.selectedObject.usedByZones[0] != scope.selection.selectedObject.ownerZone);
            }

            scope.trainModel = function() {
                CreateModalFromTemplate("/templates/savedmodels/build-model-modal.html", scope, "BuildSavedModelController", function(newScope) {
                    newScope.projectKey = scope.selection.selectedObject.projectKey;
                    newScope.modelId = scope.selection.selectedObject.name;
                    newScope.redirectAfterTrain = !!attrs.redirectAfterTrain;
                });
            };

            scope.editCustomFields = function() {
                if (!scope.selection.selectedObject) {
                    return;
                }
                DataikuAPI.savedmodels.getSummary(scope.selection.selectedObject.projectKey, scope.selection.selectedObject.name).success(function(data) {
                    let savedModel = data.object;
                    let modalScope = angular.extend(scope, {objectType: 'SAVED_MODEL', objectName: savedModel.name, objectCustomFields: savedModel.customFields});
                    CreateModalFromTemplate("/templates/taggable-objects/custom-fields-edit-modal.html", modalScope).then(function(customFields) {
                        SavedModelCustomFieldsService.saveCustomFields(savedModel, customFields);
                    });
                }).error(setErrorInScope.bind(scope));
            };

            scope.selectablePlugins = SelectablePluginsService.listSelectablePlugins({'SAVED_MODEL' : 1});

            const customFieldsListener = $rootScope.$on('customFieldsSaved', scope.refreshData);
            scope.$on("$destroy", customFieldsListener);
        }
    }
});

app.service("SavedModelCustomFieldsService", function($rootScope, TopNav, DataikuAPI, ActivityIndicator, WT1){
    let svc = {};

    svc.saveCustomFields = function(savedModel, newCustomFields) {
        WT1.event('custom-fields-save', {objectType: 'SAVED_MODEL'});
        let oldCustomFields = angular.copy(savedModel.customFields);
        savedModel.customFields = newCustomFields;
        return DataikuAPI.savedmodels.save(savedModel, {summaryOnly: true})
            .success(function(data) {
                ActivityIndicator.success("Saved");
                $rootScope.$broadcast('customFieldsSaved', TopNav.getItem(), savedModel.customFields);
                $rootScope.$broadcast('reloadGraph');
            })
            .error(function(a, b, c) {
                savedModel.customFields = oldCustomFields;
                setErrorInScope.bind(scope)(a, b, c);
            });
    };

    return svc;
});


app.controller("SavedModelSummaryController", function($scope, $rootScope, $stateParams, $timeout, DataikuAPI, TopNav, ActivityIndicator, ActiveProjectKey, SavedModelCustomFieldsService) {
    TopNav.setLocation(TopNav.TOP_FLOW, TopNav.ITEM_SAVED_MODEL, TopNav.TABS_SAVED_MODEL, "summary");
    TopNav.setItem(TopNav.ITEM_SAVED_MODEL, $stateParams.smId);

    DataikuAPI.savedmodels.getSummary(ActiveProjectKey.get(), $stateParams.smId).success(function(data) {
        $scope.savedModel = data.object;
        $scope.objectInterest = data.interest;
        $scope.objectTimeline = data.timeline;

        TopNav.setItem(TopNav.ITEM_SAVED_MODEL, $stateParams.smId, {name: $scope.savedModel.name, taskType: ($scope.savedModel.miniTask || {}).taskType});
        TopNav.setPageTitle($scope.savedModel.name + " - Model");
    }).error(setErrorInScope.bind($scope));

    $scope.refreshTimeline = function() {
        DataikuAPI.timelines.getForObject(ActiveProjectKey.get(), "SAVED_MODEL", $scope.savedModel.id)
        .success(function(data){
            $scope.objectTimeline = data;
        })
        .error(setErrorInScope.bind($scope));
    };

    var save = function() {
        DataikuAPI.savedmodels.save($scope.savedModel, {summaryOnly: true})
            .success(function(data) {
                ActivityIndicator.success("Saved");
            })
            .error(setErrorInScope.bind($scope));
    };

    /* Auto save */
    $scope.$watch("savedModel", function(nv, ov) {
        if (nv && ov) {
            save();
        }
    }, true);

    $scope.$on('customFieldsSummaryEdited', function(event, customFields) {
        SavedModelCustomFieldsService.saveCustomFields($scope.savedModel, customFields);
    });
});


app.controller("SavedModelController", function($scope, Assert, DataikuAPI, CreateModalFromTemplate, $state,
    $stateParams, SavedModelsService, MLExportService, ActiveProjectKey, WebAppsService, FullModelIdUtils){
    $scope.versionsContext = {}
    $scope.smContext = {};
    $scope.uiState = {};
    $scope.clearVersionsContext = function(){
        clear($scope.versionsContext);
    };

    $scope.trainModel = function() {
        CreateModalFromTemplate("/templates/savedmodels/build-model-modal.html", $scope, "BuildSavedModelController", function(newScope) {
            newScope.projectKey = $stateParams.projectKey;
            newScope.modelId = $stateParams.smId;
            newScope.redirectAfterTrain = true;
        });
    };

    $scope.goToAnalysisModelFromVersion = function(){
        Assert.trueish($scope.smContext.model, 'no model data');
        Assert.trueish($scope.smContext.model.smOrigin, 'no origin analysis');

        const id = $scope.smContext.model.smOrigin.fullModelId;
        const elements = FullModelIdUtils.parse(id);

        var params =  {
            projectKey: elements.projectKey, // ProjectKey from SavedModels is updated when reading it
            analysisId: elements.analysisId,
            mlTaskId: elements.mlTaskId,
            fullModelId: id
        }

        var state = "projects.project.analyses.analysis.ml.";
        if ($state.includes("projects.project.savedmodels.savedmodel.prediction")) {
            state += "predmltask.model.report";
        } else {
            state += "clustmltask.model.report";
        }

        if ($scope.smContext.model.smOrigin.origin == "EXPORTED_FROM_ANALYSIS") {
             $state.go(state, params);
         } else {
            CreateModalFromTemplate("/templates/savedmodels/go-to-analysis-model-modal.html", $scope, null, function(newScope){
                newScope.go = function(){
                    newScope.dismiss();
                    $state.go(state, params);
                }
            })
        }
    }

    $scope.showDownloadModel = function(type) {
        return $scope.smContext.model && MLExportService.showDownloadModel($scope.appConfig, type);
    };
    $scope.mayDownloadModel = function(type) {
        return MLExportService.mayDownloadModel($scope.appConfig, $scope.smContext.model, type);
    };
    $scope.downloadModel = function(type) {
        MLExportService.downloadModel($scope, $scope.smContext.model, type, $scope.smContext.partitionName);
    };
    $scope.exportToSnowflakeFunction = function(type) {
        MLExportService.exportToSnowflakeFunction($scope, $scope.smContext.model, $scope.smContext.partitionName);
    };

    $scope.createAndPinInsight = SavedModelsService.createAndPinInsight;

    $scope.isActiveVersion = SavedModelsService.isActiveVersion;
    $scope.isPartition = SavedModelsService.isPartition;

    $scope.$on("$destroy", $scope.clearVersionsContext);

    DataikuAPI.savedmodels.get(ActiveProjectKey.get(), $stateParams.smId).success(function(data) {
        $scope.savedModel = data;
    }).error(setErrorInScope.bind($scope));
});


app.filter('savedModelMLTaskHref', function($state, $stateParams, ActiveProjectKey, FullModelIdUtils) {
    return function(sm) {
        if (!sm || !sm.lastExportedFrom) return;

        const elements = FullModelIdUtils.parse(sm.lastExportedFrom);

        const params =  {
            projectKey: elements.projectKey,  // ProjectKey from SavedModels is updated when reading it
            analysisId: elements.analysisId,
            mlTaskId: elements.mlTaskId
        };

        const type = sm.type || sm.miniTask.taskType;
        let state = "projects.project.analyses.analysis.ml.";
        if (type == "PREDICTION") {
            state += "predmltask.list.results";
        } else {
            state += "clustmltask.list.results";
        }
        return $state.href(state, params);
    };
});

/* ************************************ Versions listing *************************** */


app.controller("SavedModelVersionsController", function($scope, Assert, DataikuAPI, $q, Fn, CreateModalFromTemplate, $state, $stateParams, TopNav, $controller, GraphZoomTrackerService, ActiveProjectKey, MLDiagnosticsService){
    TopNav.setLocation(TopNav.TOP_FLOW, TopNav.ITEM_SAVED_MODEL, TopNav.TABS_SAVED_MODEL, "versions");
    TopNav.setItem(TopNav.ITEM_SAVED_MODEL, $stateParams.smId);
    angular.extend($scope, MLDiagnosticsService);

    GraphZoomTrackerService.setFocusItemByName("savedmodel", $stateParams.smId);

    $scope.snippetSource = 'SAVED';

    $scope.isModelDone = function() {
        return true;
    };
    $scope.isModelRunning = function() {
        return false;
    };
    $scope.isSessionRunning = function() {
        return false;
    };
    DataikuAPI.savedmodels.get(ActiveProjectKey.get(), $stateParams.smId).success(function(data) {
        $scope.savedModel = data;
        $scope.smContext.savedModel = data;
        TopNav.setItem(TopNav.ITEM_SAVED_MODEL, $stateParams.smId, {name: data.name, taskType: (data.miniTask || {}).taskType});

        const taskType = $scope.savedModel.miniTask.taskType;
        Assert.trueish(['PREDICTION', 'CLUSTERING'].includes(taskType), 'Unknown task type');
        if (taskType === 'PREDICTION') {
            $scope.sRefPrefix = 'projects.project.savedmodels.savedmodel.prediction';
            $controller("PredictionSavedModelVersionsController" , {$scope});
        } else if (taskType === "CLUSTERING") {
            $scope.sRefPrefix = 'projects.project.savedmodels.savedmodel.clustering';
            $controller("ClusteringSavedModelVersionsController" , {$scope});
        }
    }).error(setErrorInScope.bind($scope));

    $scope.canDeleteSelectedModels = function() {
        if (!$scope.selection || !$scope.selection.selectedObjects) {return false}
        return (!$scope.selection.selectedObjects.every(function(o){return o.active}));
    };
});


app.controller("PredictionSavedModelVersionsController", function($scope, DataikuAPI, $q, Fn, CreateModalFromTemplate, $state, $stateParams, TopNav, MLTasksNavService, PMLFilteringService, $controller, Dialogs, ActivityIndicator, ActiveProjectKey, PartitionedModelsService){
    angular.extend($scope, PartitionedModelsService);
    function filterIntermediatePartitionedModels(status) {
        if (status.task && status.task.partitionedModel && status.task.partitionedModel.enabled) {
            /* Keeping all models exported from analysis (they don't have intermediate versions) */
            const analysisModels = status.versions
                .filter(model => model.smOrigin && model.smOrigin.origin === 'EXPORTED_FROM_ANALYSIS');

            /* Grouping models trained from recipe by their JobId */
            const recipeModelsByJobId = status.versions
                .filter(model => model.smOrigin && model.smOrigin.origin === 'TRAINED_FROM_RECIPE')
                .reduce((map, model) => {
                    map[model.smOrigin.jobId] = (map[model.smOrigin.jobId] || []).concat(model);
                    return map;
                }, {});

            /* Keeping most recent or active models in those groups */
            const recipeMostRecentModels = Object.entries(recipeModelsByJobId)
                .map((jobEntries) =>
                    jobEntries[1].reduce((mostRecentModel, currentModel) => {
                        if (!mostRecentModel || currentModel.active) {
                            return currentModel;
                        }

                        return (currentModel.snippet.trainDate > mostRecentModel.snippet.trainDate) ? currentModel : mostRecentModel;
                    }, null));

            status.versions = analysisModels.concat(recipeMostRecentModels);
        }
    }

    $scope.refreshStatus = function(){
        DataikuAPI.savedmodels.prediction.getStatus(ActiveProjectKey.get(), $stateParams.smId).success(function(data){
            data.versions.map(function(v) { v.snippet.versionRank = +v.versionId || 0; });
            $scope.smStatus = data;
            $scope.setMainMetric();
            $scope.possibleMetrics = PMLFilteringService.getPossibleMetrics($scope.smStatus.task);
            if ($scope.smStatus.task.modeling && !$scope.uiState.currentMetric) {
                $scope.uiState.currentMetric = $scope.smStatus.task.modeling.metrics.evaluationMetric;
            }
        }).error(setErrorInScope.bind($scope));
    }

    $scope.refreshStatus();

    $scope.setMainMetric = function() {
        if(!$scope.smStatus || !$scope.smStatus.versions) { return; }
        PMLFilteringService.setMainMetric($scope.smStatus.versions,
            ["snippet"],
            $scope.uiState.currentMetric,
            $scope.smContext.savedModel.miniTask.modeling.metrics.customEvaluationMetricGIB);

        if ($scope.smStatus.task.partitionedModel.enabled) {
            // Updating main metrics for saved model partition snippets too
            angular.forEach($scope.smStatus.versions, (version) => {
                if (version.snippet && version.snippet.partitions) {
                    const modelSnippets = Object.values(version.snippet.partitions.summaries).map(summary => summary.snippet);
                    PMLFilteringService.setMainMetric(modelSnippets,
                        [],
                        $scope.uiState.currentMetric,
                        $scope.smContext.savedModel.miniTask.modeling.metrics.customEvaluationMetricGIB);
                }
            })
        }
    };
    $scope.$watch('uiState.currentMetric', $scope.setMainMetric);

    $scope.makeActive = function(data) {
        Dialogs.confirmPositive($scope, "Set model as active", "Do you want to set this model version as the active scoring version ?").then(function(){
            DataikuAPI.savedmodels.prediction.setActive(ActiveProjectKey.get(), $stateParams.smId, data.versionId)
                .success(function(data) {
                    $scope.refreshStatus();
                    if (data.schemaChanged) {
                        Dialogs.ack($scope, "Schema changed", "The preparation script schema of the selected version is different than " +
                            "the previously selected version, this may affect the ouput schema of downstream scoring recipes.");
                    }
                })
                .error(setErrorInScope.bind($scope));
        });
    };

    $scope.deleteSelectedModels = function() {
        DataikuAPI.savedmodels.prediction.deleteVersions(ActiveProjectKey.get(), $stateParams.smId,
                $scope.selection.selectedObjects.filter(function(o){return !o.active}).map(Fn.prop('versionId')))
            .success($scope.refreshStatus)
            .error(setErrorInScope.bind($scope));
    };
});


app.controller("ClusteringSavedModelVersionsController", function($scope, DataikuAPI, $q, Fn, CreateModalFromTemplate, $state, $stateParams, CMLFilteringService, $controller, Dialogs, ActivityIndicator, ActiveProjectKey){
    $scope.refreshStatus = function(){
        return DataikuAPI.savedmodels.clustering.getStatus(ActiveProjectKey.get(), $stateParams.smId).success(function(data){
            $scope.smStatus = data;
            $scope.setMainMetric();
            $scope.possibleMetrics = CMLFilteringService.getPossibleMetrics($scope.smStatus.task);
            if (!$scope.uiState.currentMetric) {
                $scope.uiState.currentMetric = "SILHOUETTE"; // Dirty tmp
            }
        }).error(setErrorInScope.bind($scope));
    }

    $scope.setMainMetric = function() {
        if(!$scope.smStatus || !$scope.smStatus.versions) { return; }
        CMLFilteringService.setMainMetric($scope.smStatus.versions,
            ["snippet"],
            $scope.uiState.currentMetric,
            $scope.smContext.savedModel.miniTask.modeling.metrics.customEvaluationMetricGIB);
    };

    $scope.makeActive = function(data) {
        Dialogs.confirmPositive($scope, "Set model as active", "Do you want to set this model version as the active scoring version ?").then(function(){
            DataikuAPI.savedmodels.clustering.setActive(ActiveProjectKey.get(), $stateParams.smId, data.versionId)
                .success(function(data) {
                    $scope.refreshStatus();
                    if (data.schemaChanged) {
                        Dialogs.ack($scope, "Schema changed", "The preparation script schema of the selected version is different than " +
                            "the previously selected version, this may affect the ouput schema of downstream scoring recipes.");
                    }
                })
                .error(setErrorInScope.bind($scope));
        });
    };

    $scope.deleteSelectedModels = function() {
        DataikuAPI.savedmodels.clustering.deleteVersions(ActiveProjectKey.get(), $stateParams.smId,
                $scope.selection.selectedObjects.filter(function(o){return !o.active}).map(Fn.prop('versionId')))
            .success($scope.refreshStatus)
            .error(setErrorInScope.bind($scope));
    };

    // Watchers & init

    $scope.$watch('uiState.currentMetric', $scope.setMainMetric);
    $scope.refreshStatus();
});

/* ************************************ Settings *************************** */

app.controller("SavedModelSettingsController", function($scope, DataikuAPI, $q, CreateModalFromTemplate, $state, $stateParams, TopNav, $controller, ActivityIndicator, ComputableSchemaRecipeSave, WT1, ActiveProjectKey, Logger){
    TopNav.setLocation(TopNav.TOP_FLOW, TopNav.ITEM_SAVED_MODEL, TopNav.TABS_SAVED_MODEL, "settings");
    TopNav.setItem(TopNav.ITEM_SAVED_MODEL, $stateParams.smId);

    var savedSettings;
    DataikuAPI.savedmodels.get(ActiveProjectKey.get(), $stateParams.smId).success(function(data) {
        $scope.savedModel = data;
        $scope.canHaveConditionalOutput = data.miniTask.taskType === 'PREDICTION' && data.miniTask.predictionType === 'BINARY_CLASSIFICATION';
        savedSettings = angular.copy(data);
        TopNav.setItem(TopNav.ITEM_SAVED_MODEL, $stateParams.smId, {name: data.name, taskType: (data.miniTask || {}).taskType});

        if (!$scope.canHaveConditionalOutput) return;
        $scope.targetRemapping = ['0', '1'];
        DataikuAPI.ml.prediction.getModelDetails(['S', data.projectKey, data.id, data.activeVersion].join('-')).success(function(data){
            $scope.targetRemapping = [];
            data.preprocessing.target_remapping.forEach(function(r){ $scope.targetRemapping[r.mappedValue] = r.sourceValue; });
        }).error(setErrorInScope.bind($scope));
    }).error(setErrorInScope.bind($scope));

    var getUpdatePromises = function(datasets){
        var promises = [];
        $.each(datasets, function(idx, val) {
            promises.push(DataikuAPI.flow.recipes.saveOutputSchema(ActiveProjectKey.get(),
                        val.type == "DATASET" ?val.datasetName: val.id,
                        val.newSchema, val.dropAndRecreate, val.synchronizeMetastore));
        });
        return promises;
    }
    let oldNumberChecksOnAssertionsMetrics;
    let oldNumberChecks;
    $scope.save = function() {
        try {
            let numberChecksOnAssertionsMetrics = 0;
            let numberChecks = 0;
            if ($scope.savedModel && $scope.savedModel.metricsChecks && $scope.savedModel.metricsChecks.checks) {
                numberChecksOnAssertionsMetrics = $scope.savedModel.metricsChecks.checks.filter(m => m.metricId).filter(
                    m => m.metricId.startsWith("model_perf:ASSERTION_") ||
                        m.metricId === "model_perf:PASSING_ASSERTIONS_RATIO"
                ).length;
                numberChecks = $scope.savedModel.metricsChecks.checks.length || 0;
            }
            if (numberChecksOnAssertionsMetrics !== oldNumberChecksOnAssertionsMetrics ||
                numberChecks !== oldNumberChecks) {

                WT1.event("checks-save", {
                    numberChecksOnAssertionsMetrics: numberChecksOnAssertionsMetrics,
                    numberChecks: numberChecks
                });
            }
            oldNumberChecksOnAssertionsMetrics = numberChecksOnAssertionsMetrics;
            oldNumberChecks = numberChecks;
        }  catch (e) {
            Logger.error('Failed to report checks info', e);
        }
        DataikuAPI.savedmodels.save($scope.savedModel).success(function(data) {
            savedSettings = angular.copy($scope.savedModel);
            if ($scope.canHaveConditionalOutput && data && 'recipes' in data) {
                if (data.recipes.length) {
                    DataikuAPI.flow.recipes.getComputableSaveImpacts($scope.savedModel.projectKey, data.recipes, data.payloads).success(function(data){
                        if (!data.totalIncompatibilities) return;
                        CreateModalFromTemplate("/templates/recipes/fragments/recipe-incompatible-schema-multi.html", $scope, null,
                            function(newScope) {
                                ComputableSchemaRecipeSave.decorateChangedDatasets(data.computables, false);

                                newScope.schemaChanges = data;
                                newScope.customMessage = "The output datasets of scoring recipes using this model have incompatible schemas.";
                                newScope.noCancel = true;
                                function done(){ newScope.dismiss(); };
                                newScope.ignoreSchemaChangeSuggestion = done;
                                newScope.updateSchemaFromSuggestion = function() {
                                    $q.all(ComputableSchemaRecipeSave.getUpdatePromises(data.computables))
                                        .then(done).catch(setErrorInScope.bind($scope));
                                }
                            }
                        );
                    });
                } else if (data.hiddenRecipes) {    // TODO warn?
                }
            }
        }).error(setErrorInScope.bind($scope));
    };

    $scope.dirtySettings = function() {
        return !angular.equals(savedSettings, $scope.savedModel);
    }
    checkChangesBeforeLeaving($scope, $scope.dirtySettings);
});


/* ************************************ Report *************************** */

app.controller("_SavedModelReportController", function($scope, TopNav, $stateParams, DataikuAPI, ActiveProjectKey, WebAppsService){
    if (!$scope.noSetLoc) {
        TopNav.setItem(TopNav.ITEM_SAVED_MODEL, $stateParams.smId);
    }

    DataikuAPI.savedmodels.get(ActiveProjectKey.get(), $stateParams.smId).success(function(data) {
        $scope.savedModel = data;
        if ($scope.smContext) $scope.smContext.savedModel = data;
        if (!$scope.noSetLoc) {
            TopNav.setItem(TopNav.ITEM_SAVED_MODEL, $stateParams.smId, {name: data.name, taskType: (data.miniTask || {}).taskType});
        }
    });

    $scope.fillVersionSelectorStuff = function(statusData, type){
        if (!$scope.versionsContext.activeMetric) {
            $scope.versionsContext.activeMetric= statusData.task.modeling.metrics.evaluationMetric;
        }
        $scope.versionsContext.versions = statusData.versions.filter(function(m){
            return m.snippet.trainInfo.state == "DONE" && m.snippet.fullModelId != $stateParams.fullModelId;
        });
        $scope.versionsContext.currentVersion = statusData.versions.filter(function(m){
            return m.snippet.fullModelId === $stateParams.fullModelId;
        })[0] || {}; // (partitioned models) ensure watch on versionsContext.currentVersion is fired (see ch45900)
        $scope.versionsContext.versions.sort(function(a, b) {
            var stardiff = (0+b.snippet.userMeta.starred) - (0+a.snippet.userMeta.starred)
            if (stardiff !=0) return stardiff;
            return b.snippet.sessionDate - a.snippet.sessionDate;
        });

        statusData.versions.forEach(function(version) {
            if (version.active) {
                $scope.versionsContext.activeVersion = version;
            }
        });

        if ($scope.versionsContext.currentVersion.snippet) {
            var contentType = $scope.savedModel.contentType;
            if (!contentType.endsWith("/")) {
                contentType = contentType + '/';
            }
            contentType = contentType + $scope.versionsContext.currentVersion.snippet.algorithm.toLowerCase();
            $scope.modelSkins = WebAppsService.getSkins('SAVED_MODEL', $scope.versionsContext.currentVersion.versionId, contentType);
        }
    }
})

app.controller("PredictionSavedModelReportController", function($scope, DataikuAPI, $q, CreateModalFromTemplate, $state, $stateParams, TopNav, $controller, PMLFilteringService, ActiveProjectKey, ModelEvaluationUtils){
    $scope.noMlReportTourHere = true; // the tabs needed for the tour are not present

    $controller("_PredictionModelReportController",{$scope:$scope});
    $controller("_SavedModelReportController", {$scope:$scope})

    if (!$scope.noSetLoc) {
        TopNav.setLocation(TopNav.TOP_FLOW, TopNav.ITEM_SAVED_MODEL, "PREDICTION-SAVED_MODEL-VERSION", "report");
    }

    // Fill the version selector
    DataikuAPI.savedmodels.prediction.getStatus(ActiveProjectKey.get(), $stateParams.smId).success(function(data){
        $scope.fillVersionSelectorStuff(data, "PREDICTION");
        $scope.versionsContext.versions.forEach(function(m){
            m.snippet.mainMetric = PMLFilteringService.getMetricFromSnippet(m.snippet, $scope.versionsContext.activeMetric);
            m.snippet.mainMetricStd = PMLFilteringService.getMetricStdFromSnippet(m.snippet, $scope.versionsContext.activeMetric);
        });
    });
});


app.controller("ClusteringSavedModelReportController", function($scope, $controller, $state, $stateParams, $q, DataikuAPI, CreateModalFromTemplate, TopNav, CMLFilteringService, ActiveProjectKey){
    $controller("_ClusteringModelReportController",{$scope:$scope});
    $controller("_SavedModelReportController", {$scope:$scope})

    if (!$scope.noSetLoc) {
        TopNav.setLocation(TopNav.TOP_FLOW, TopNav.ITEM_SAVED_MODEL, "CLUSTERING-SAVED_MODEL-VERSION", "report");
    }

    // Fill the version selector
    DataikuAPI.savedmodels.clustering.getStatus(ActiveProjectKey.get(), $stateParams.smId).success(function(data){
        $scope.fillVersionSelectorStuff(data, "CLUSTERING");
        $scope.versionsContext.versions.forEach(function(m){
            m.snippet.mainMetric = CMLFilteringService.getMetricFromSnippet(m.snippet, $scope.versionsContext.activeMetric);
        });
    });
});


/* ***************************** Scoring recipe creation ************************** */

app.controller("NewPredictionScoringRecipeModalController", function($scope, $stateParams, $controller, DataikuAPI, Fn, SavedModelsService, ActiveProjectKey) {
    $scope.recipeType = "prediction_scoring";
    $controller("SingleOutputDatasetRecipeCreationController", {$scope:$scope});

    $scope.scoringRecipe = {};

    $scope.autosetName = function() {
        if ($scope.io.inputDataset) {
            var niceInputName = $scope.io.inputDataset.replace(/[A-Z]*\./,"");
            $scope.maybeSetNewDatasetName(niceInputName + "_scored");
        }
    };

    $scope.doCreateRecipe = function() {
        var createOutput = $scope.io.newOutputTypeRadio == 'create';

        var finalRecipe = angular.copy($scope.scoringRecipe);
        finalRecipe.inputDatasetSmartName = $scope.io.inputDataset;
        finalRecipe.savedModelSmartName = $scope.smId;
        finalRecipe.createOutput = createOutput;
        finalRecipe.outputDatasetSmartName = createOutput ? $scope.newOutputDataset.name : $scope.io.existingOutputDataset;
        finalRecipe.outputDatasetCreationSettings = $scope.getDatasetCreationSettings();
        finalRecipe.zone = $scope.zone;

        return DataikuAPI.savedmodels.prediction.deployScoring(ActiveProjectKey.get(), finalRecipe);
    };

    $scope.subFormIsValid = function() {
        return !!$scope.smId;
    };

    $scope.$watch('projectKey', function() {
        SavedModelsService.listPredictionModels($scope.projectKey).then(function(savedModels){
            $scope.savedModels = savedModels;
        }, setErrorInScope.bind($scope));;
    });
});


app.controller("NewClusteringScoringRecipeModalController", function($scope, Fn, $stateParams, $controller, DataikuAPI, SavedModelsService, ActiveProjectKey) {
    $scope.recipeType = "prediction_scoring";
    $controller("SingleOutputDatasetRecipeCreationController", {$scope:$scope});

    $scope.scoringRecipe = {};

    $scope.autosetName = function() {
        if ($scope.io.inputDataset) {
            var niceInputName = $scope.io.inputDataset.replace(/[A-Z]*\./,"");
            $scope.maybeSetNewDatasetName(niceInputName + "_scored");
        }
    };

    $scope.doCreateRecipe = function() {
        var createOutput = $scope.io.newOutputTypeRadio == 'create';
        return DataikuAPI.savedmodels.clustering.deployScoring(
            ActiveProjectKey.get(),
            $scope.smId,
            $scope.io.inputDataset,
            createOutput,
            createOutput ? $scope.newOutputDataset.name : $scope.io.existingOutputDataset,
            $scope.getDatasetCreationSettings());
    };

    $scope.subFormIsValid = function() { return !!$scope.smId; };
    $scope.$watch('projectKey', function() {
        SavedModelsService.listClusteringModels($scope.projectKey).then(function(savedModels){
            $scope.savedModels = savedModels;
        }, setErrorInScope.bind($scope));
    });
});

/* ***************************** Evaluation recipe creation ************************** */

app.controller('NewEvaluationRecipeModalController', function($scope, $controller, $stateParams, $state, DataikuAPI, DatasetsService,
DatasetUtils, RecipeComputablesService, PartitionDeps, ActiveProjectKey, $rootScope){
    $scope.recipeType = "evaluation";
    //$controller("VisualRecipeCreationController", {$scope:$scope});
    $controller("_RecipeCreationControllerBase", {$scope:$scope});

    $scope.autosetName = function() {
        if ($scope.io.inputDataset) {
            var niceInputName = $scope.io.inputDataset.replace(/[A-Z]*\./,"");
            $scope.maybeSetNewDatasetName(niceInputName + "_scored");
        }
    };

    addDatasetUniquenessCheck($scope, DataikuAPI, ActiveProjectKey.get());
    fetchManagedDatasetConnections($scope, DataikuAPI);
    DatasetsService.updateProjectList(ActiveProjectKey.get());

    $scope.recipeParams = {
        inputDs: "",
        smId: "",
    };

    $scope.recipe = {
        projectKey : ActiveProjectKey.get(),
        type: "evaluation",
        inputs : {},
        outputs : {},
        params: {}
    };
    $scope.$on("preselectInputDataset", function(scope, preselectedInputDataset) {
        $scope.recipeParams.inputDs = preselectedInputDataset;
    });

    $scope.$watch("recipeParams.inputDs", function(nv, ov) {
        if (nv) {
            $scope.recipe.name = "evaluate_" + nv;
        }
        if ($scope.recipeParams.inputDs) {
            $scope.recipe.inputs.main = {items:[{ref:$scope.recipeParams.inputDs}]}; // for the managed dataset creation options
        } else {
            $scope.recipe.inputs.main = {items:[]}; // for the managed dataset creation options
        }
    }, true);
    $scope.$watch("recipeParams.smId", function(nv, ov) {
        if ($scope.recipeParams.smId) {
            $scope.recipe.inputs.model = {items:[{ref:$scope.recipeParams.smId}]}; // for the managed dataset creation options
        } else {
            $scope.recipe.inputs.model = {items:[]}; // for the managed dataset creation options
        }
    }, true);

    //fetch saved models list
    $scope.$watch('projectKey', function() {
        DataikuAPI.savedmodels.listWithAccessible($scope.projectKey).success(function(data){
            $scope.savedModels = data.filter(function(sm) { return sm.miniTask.taskType === 'PREDICTION' && sm.miniTask.backendType !== 'VERTICA'; });
            $scope.savedModels.forEach(function(sm) {
                if (sm.projectKey !== $scope.projectKey) {
                    sm.name = sm.projectKey + "." + sm.name;
                    sm.id = sm.projectKey + "." + sm.id;
                }
            });
        }).error(setErrorInScope.bind($scope));
    });

    DatasetUtils.listDatasetsUsabilityInAndOut(ActiveProjectKey.get(), "evaluation").then(function(data){
        $scope.availableInputDatasets = data[0];
    });

    RecipeComputablesService.getComputablesMap($scope.recipe, $scope).then(function(map){
        $scope.setComputablesMap(map);
    });

    $scope.hasMain = function() {
        const outputs = $scope.recipe.outputs;
        return outputs.main && outputs.main.items && outputs.main.items.length > 0 && outputs.main.items[0].ref
    }
    $scope.hasMetrics = function() {
        const outputs = $scope.recipe.outputs;
        return outputs.metrics && outputs.metrics.items && outputs.metrics.items.length > 0 && outputs.metrics.items[0].ref
    }
    $scope.hasEvaluationStore = function() {
        const outputs = $scope.recipe.outputs;
        return outputs.evaluationStore && outputs.evaluationStore.items && outputs.evaluationStore.items.length > 0 && outputs.evaluationStore.items[0].ref
    }

    $scope.canCreate = function(){
        return $scope.recipe.name
            && $scope.recipe.name.length > 0
            && $scope.recipe.outputs
            && ($scope.hasMain() || $scope.hasMetrics() || $scope.hasEvaluationStore())
            && !($scope.newRecipeForm.$invalid)
    }

    $scope.shouldDisplayOutputExplanation = function () {
        return !$scope.hasMain() && !$scope.hasMetrics() && !$scope.hasEvaluationStore();
    };

    $scope.generateOutputExplanation = function () {
        const requiredOutputRoles = [];
        $scope.recipeDesc.outputRoles.forEach((role, outputRoleidx) => {
            if (!$rootScope.featureFlagEnabled('model_evaluation_stores')) {
                let canOtherThanEvaluationStore = role.acceptsDataset || role.acceptsSavedModel || role.acceptsManagedFolder || role.acceptsStreamingEndpoint;
                if (!canOtherThanEvaluationStore && role.acceptsModelEvaluationStore) {
                    // skip roles that are only MES
                    return;
                }
            }

            requiredOutputRoles.push(role.name === "main" ? "main output" : '"' + (role.label || role.name) + '"');
        });
        const message = "This recipe requires at least one output in: "
            + requiredOutputRoles.slice(0, -1).join(', ')
            + (requiredOutputRoles.length === 2 ? ' or ' : ', or ')
            + requiredOutputRoles.slice(-1) + ".";
        return message;
    };

    $scope.createRecipe = function() {
        $scope.creatingRecipe = true;
        var finalRecipe = {};

        finalRecipe.inputDatasetSmartName = $scope.recipeParams.inputDs;
        finalRecipe.savedModelSmartName = $scope.recipeParams.smId;
        finalRecipe.scoredDatasetSmartName = $scope.recipe.outputs.main && $scope.recipe.outputs.main.items ? $scope.recipe.outputs.main.items[0].ref : null;
        finalRecipe.metricsDatasetSmartName = $scope.recipe.outputs.metrics && $scope.recipe.outputs.metrics.items ? $scope.recipe.outputs.metrics.items[0].ref : null;
        finalRecipe.evaluationStoreSmartName = $scope.recipe.outputs.evaluationStore && $scope.recipe.outputs.evaluationStore.items ? $scope.recipe.outputs.evaluationStore.items[0].ref : null;
        finalRecipe.zone = $scope.zone;

        DataikuAPI.savedmodels.prediction.deployEvaluation(ActiveProjectKey.get(), finalRecipe)
            .success(function(data) {
                $scope.creatingRecipe = false;
                $scope.dismiss();
                $scope.$state.go('projects.project.recipes.recipe', {
                    recipeName: data.id
                });
            }).error(function(a, b, c) {
                $scope.creatingRecipe = false;
                setErrorInScope.bind($scope)(a,b,c);
            });;

    };
});

app.controller('NewStandaloneEvaluationRecipeModalController', function($scope, $controller, $stateParams, $state, DataikuAPI, DatasetsService,
DatasetUtils, RecipeComputablesService, PartitionDeps, ActiveProjectKey){
    $scope.recipeType = "standalone_evaluation";
    //$controller("VisualRecipeCreationController", {$scope:$scope});
    $controller("_RecipeCreationControllerBase", {$scope:$scope});

    $scope.autosetName = function() {
        if ($scope.io.inputDataset) {
            var niceInputName = $scope.io.inputDataset.replace(/[A-Z]*\./,"");
            $scope.maybeSetNewDatasetName(niceInputName + "_scored");
        }
    };

    addDatasetUniquenessCheck($scope, DataikuAPI, ActiveProjectKey.get());
    DatasetsService.updateProjectList(ActiveProjectKey.get());

    $scope.recipeParams = {
        inputDs: "",
    };

    $scope.recipe = {
        projectKey : ActiveProjectKey.get(),
        type: "standalone_evaluation",
        inputs : {},
        outputs : {},
        params: {}
    };
    $scope.$on("preselectInputDataset", function(scope, preselectedInputDataset) {
        $scope.recipeParams.inputDs = preselectedInputDataset;
    });

    $scope.$watch("recipeParams.inputDs", function(nv, ov) {
        if (nv) {
            $scope.recipe.name = "standalone_evaluate_" + nv;
        }
        if ($scope.recipeParams.inputDs) {
            $scope.recipe.inputs.main = {items:[{ref:$scope.recipeParams.inputDs}]}; // for the managed dataset creation options
        } else {
            $scope.recipe.inputs.main = {items:[]}; // for the managed dataset creation options
        }
    }, true);

    //fetch saved models list
    DatasetUtils.listDatasetsUsabilityInAndOut(ActiveProjectKey.get(), "standalone_evaluation").then(function(data){
        $scope.availableInputDatasets = data[0];
    });

    RecipeComputablesService.getComputablesMap($scope.recipe, $scope).then(function(map){
        $scope.setComputablesMap(map);
    });

    $scope.hasMain = function() {
        const outputs = $scope.recipe.outputs;
        return outputs.main && outputs.main.items && outputs.main.items.length > 0 && outputs.main.items[0].ref
    }

    $scope.canCreate = function(){
        return $scope.recipe.name
            && $scope.recipe.name.length > 0
            && $scope.recipe.outputs
            && $scope.hasMain()
            && !($scope.newRecipeForm.$invalid)
    }

    $scope.shouldDisplayOutputExplanation = function () { return !$scope.hasMain(); };

    $scope.createRecipe = function() {
        $scope.creatingRecipe = true;
        var finalRecipe = {};

        finalRecipe.inputDatasetSmartName = $scope.recipeParams.inputDs;
        finalRecipe.evaluationStoreSmartName = $scope.recipe.outputs.main.items[0].ref;
        finalRecipe.zone = $scope.zone;

        DataikuAPI.savedmodels.prediction.deployStandaloneEvaluation(ActiveProjectKey.get(), finalRecipe)
            .success(function(data) {
                $scope.creatingRecipe = false;
                $scope.dismiss();
                $scope.$state.go('projects.project.recipes.recipe', {
                    recipeName: data.id
                });
            }).error(function(a, b, c) {
                $scope.creatingRecipe = false;
                setErrorInScope.bind($scope)(a,b,c);
            });;

    };
});

app.controller("SavedModelVersionSkinsController", function($scope, $state, VirtualWebApp, $rootScope, $timeout) {
    function setSkinFromTile() {
        // if insight or dashboard tile, we select the skin defined in the params
        if ($scope.tile.tileParams && $scope.tile.tileParams.advancedOptions && $scope.tile.tileParams.advancedOptions.customViews) {
            const viewId = $scope.tile.tileParams.advancedOptions.customViews.viewId;
            $scope.uiState.skin = $scope.modelSkins.find(s => s.id === viewId);
        }
    }

    let modelId = '';
    let version = '';
    if ($scope.savedModel && $scope.savedModel.id) {
        // when called from sm
        modelId = $scope.savedModel.id;
    } else if ($scope.insight &&  $scope.insight.$savedModel && $scope.insight.$savedModel.id) {
        // when called from insight
        modelId = $scope.insight.$savedModel.id;
    } else {
        Logger.error("Skin missing model's modelId");
    }
    if ($scope.versionsContext && $scope.versionsContext.currentVersion && $scope.versionsContext.currentVersion.versionId) {
        // when called from sm
        version = $scope.versionsContext.currentVersion.versionId
    } else if ($scope.insight && $scope.insight.$savedModel && $scope.insight.$savedModel.activeVersion) {
        // when called from insight
        version = $scope.insight.$savedModel.activeVersion;
    } else {
        Logger.error("Skin missing model's version");
    }
    if ($scope.tile && $scope.tile.insightId) {
        $scope.skinHolderClass = "skin-holder-insight-" + $scope.tile.insightId;
        const deregister = $scope.$watch('modelSkins', function (nv, ov) {
            if (!nv) {return}
            // make sure modelSkins is defined before calling setSkinFromTile
            $scope.$watch('tile.tileParams.advancedOptions.customViews.viewId', function () {
                setSkinFromTile(); // changes uiState.skin accordingly
            });
            deregister();
        });
    } else {
        $scope.skinHolderClass = "skin-holder"
    }

    $scope.$watch('uiState.skin', function() {
        if (!$scope.uiState.skin) {return;}
        if ($scope.tile && $scope.tile.tileParams && $scope.tile.tileParams.displayMode === 'skins'
            && $scope.tile.tileParams.advancedOptions && $scope.tile.tileParams.advancedOptions.customViews) {
            // we are in a dashboard tile and the tile has a custom config
            const tileView = $scope.tile.tileParams.advancedOptions.customViews;
            $scope.webAppCustomConfig = {
                ...tileView.viewParams
            }
        }

        // ng-class="skinHolderClass"  needs to be evaluated before changing skin
        $timeout(() =>
            VirtualWebApp.changeSkin($scope, 'SAVED_MODEL', $scope.uiState.skin, $scope.uiState, $scope.skinHolderClass, modelId,
                version, false)
        );
    }, true);
});


})();

(function(){
'use strict';

const app = angular.module('dataiku.modelevaluationstores', []);



/* ************************************ List / Right column  *************************** */

app.controller("ModelEvaluationStorePageRightColumnActions", function($controller, $scope, $state, $rootScope, DataikuAPI, $stateParams, ActiveProjectKey) {

    $controller('_TaggableObjectPageRightColumnActions', {$scope: $scope});

    $scope.selection = {};

    DataikuAPI.modelevaluationstores.get(ActiveProjectKey.get(), $stateParams.mesId).success((data) => {
        data.description = data.shortDesc;
        data.nodeType = 'LOCAL_MODELEVALUATIONSTORE';
        data.name = data.id;
        data.interest = {};

        $scope.selection = {
            selectedObject : data,
            confirmedItem : data,
        };

        updateUserInterests();

    }).error(setErrorInScope.bind($scope));

    function updateUserInterests() {
        DataikuAPI.interests.getForObject($rootScope.appConfig.login, "MODEL_EVALUATION_STORE", ActiveProjectKey.get(), $stateParams.mesId).success(function(data) {

            $scope.selection.selectedObject.interest.watching = data.watching;
            $scope.selection.selectedObject.interest.starred = data.starred;

        }).error(setErrorInScope.bind($scope));
    }

    $scope.isOnStoreObjectPage = function() {
        return $state.includes('projects.project.modelevaluationstores.modelevaluationstore');
    }

    const interestsListener = $rootScope.$on('userInterestsUpdated', updateUserInterests);
    $scope.$on("$destroy", interestsListener);
});


app.directive('modelEvaluationStoreRightColumnSummary', function($controller, $state, $stateParams, ModelEvaluationStoreCustomFieldsService, $rootScope, FlowGraphSelection,
    DataikuAPI, CreateModalFromTemplate, QuickView, TaggableObjectsUtils, ActiveProjectKey, ActivityIndicator) {

    return {
        templateUrl :'/templates/modelevaluationstores/right-column-summary.html',

        link : function(scope, element, attrs) {
            $controller('_TaggableObjectsMassActions', {$scope: scope});

            scope.$stateParams = $stateParams;
            scope.QuickView = QuickView;

            scope.getSmartName = function (projectKey, name) {
                if (projectKey == ActiveProjectKey.get()) {
                    return name;
                } else {
                    return projectKey + '.' + name;
                }
            }

            scope.refreshData = function() {
                var projectKey = scope.selection.selectedObject.projectKey;
                var name = scope.selection.selectedObject.name;
                DataikuAPI.modelevaluationstores.getFullInfo(ActiveProjectKey.get(), scope.getSmartName(projectKey, name)).success(function(data){
                    if (!scope.selection.selectedObject || scope.selection.selectedObject.projectKey != projectKey || scope.selection.selectedObject.name != name) {
                        return; // too late!
                    }
                    scope.modelEvaluationStoreData = data;
                    scope.modelEvaluationStore = data.evaluationStore;
                    scope.modelEvaluationStore.zone = (scope.selection.selectedObject.usedByZones || [])[0] || scope.selection.selectedObject.ownerZone;
                    scope.isLocalModelEvaluationStore = projectKey == ActiveProjectKey.get();
                }).error(setErrorInScope.bind(scope));
            };

            scope.$on("objectSummaryEdited", function() {
                DataikuAPI.modelevaluationstores.save(scope.modelEvaluationStore, {summaryOnly: true})
                .success(function(data) {
                    ActivityIndicator.success("Saved");
                }).error(setErrorInScope.bind(scope));
            });

            scope.$watch("selection.selectedObject",function() {
                if(scope.selection.selectedObject != scope.selection.confirmedItem) {
                    scope.modelEvaluationStore = null;
                    scope.objectTimeline = null;
                }
            });

            scope.$watch("selection.confirmedItem", function(nv, ov) {
                if (!nv) {
                    return;
                }
                if (!nv.projectKey) {
                    nv.projectKey = ActiveProjectKey.get();
                }
                scope.refreshData();
            });

            scope.zoomToOtherZoneNode = function(zoneId) {
                let otherNodeId = scope.selection.selectedObject.id.replace(/zone__.+?__saved/, "zone__" + zoneId + "__saved");
                if ($stateParams.zoneId) {
                    $state.go('projects.project.flow', Object.assign({}, $stateParams, { zoneId: zoneId }))
                }
                else {
                    scope.zoomGraph(otherNodeId);
                    FlowGraphSelection.clearSelection();
                    FlowGraphSelection.onItemClick(scope.nodesGraph.nodes[otherNodeId], null);
                }
            }

            scope.isMESZoneInput = function() {
                return (scope.selection.selectedObject.usedByZones.length && scope.selection.selectedObject.usedByZones[0] != scope.selection.selectedObject.ownerZone);
            }

            scope.editCustomFields = function() {
                if (!scope.selection.selectedObject) {
                    return;
                }
                DataikuAPI.modelevaluationstores.getSummary(scope.selection.selectedObject.projectKey, scope.selection.selectedObject.name).success(function(data) {
                    let modelEvaluationStore = data.object;
                    let modalScope = angular.extend(scope, {objectType: 'MODEL_EVALUATION_STORE', objectName: modelEvaluationStore.name, objectCustomFields: modelEvaluationStore.customFields});
                    CreateModalFromTemplate("/templates/taggable-objects/custom-fields-edit-modal.html", modalScope).then(function(customFields) {
                        ModelEvaluationStoreCustomFieldsService.saveCustomFields(modelEvaluationStore, customFields);
                    });
                }).error(setErrorInScope.bind(scope));
            };
            
            scope.buildModelEvaluationStore = function() {
                CreateModalFromTemplate("/templates/modelevaluationstores/build-store-modal.html", scope, "BuildModelEvaluationStoreController", function(newScope) {
                    newScope.projectKey = scope.modelEvaluationStore.projectKey;
                    newScope.mesId = scope.modelEvaluationStore.id;
                });
            };
            

            const customFieldsListener = $rootScope.$on('customFieldsSaved', scope.refreshData);
            scope.$on("$destroy", customFieldsListener);
        }
    }
});

app.service("ModelEvaluationStoreCustomFieldsService", function($rootScope, TopNav, DataikuAPI, ActivityIndicator, WT1){
    let svc = {};

    svc.saveCustomFields = function(modelEvaluationStore, newCustomFields) {
        WT1.event('custom-fields-save', {objectType: 'MODEL_EVALUATION_STORE'});
        let oldCustomFields = angular.copy(modelEvaluationStore.customFields);
        modelEvaluationStore.customFields = newCustomFields;
        return DataikuAPI.modelevaluationstores.save(modelEvaluationStore, {summaryOnly: true})
            .success(function(data) {
                ActivityIndicator.success("Saved");
                $rootScope.$broadcast('customFieldsSaved', TopNav.getItem(), modelEvaluationStore.customFields);
                $rootScope.$broadcast('reloadGraph');
            })
            .error(function(a, b, c) {
                modelEvaluationStore.customFields = oldCustomFields;
                setErrorInScope.bind(scope)(a, b, c);
            });
    };

    return svc;
});


app.controller("ModelEvaluationStoreSummaryController", function($scope, $rootScope, $stateParams, $timeout, DataikuAPI, TopNav, ActivityIndicator, ActiveProjectKey, ModelEvaluationStoreCustomFieldsService) {
    TopNav.setLocation(TopNav.TOP_FLOW, TopNav.ITEM_MODEL_EVALUATION_STORE, TopNav.TABS_MODEL_EVALUATION_STORE, "summary");
    TopNav.setItem(TopNav.ITEM_MODEL_EVALUATION_STORE, $stateParams.mesId);

    DataikuAPI.modelevaluationstores.getSummary(ActiveProjectKey.get(), $stateParams.mesId).success(function(data) {
        $scope.objectInterest = data.interest;
        $scope.objectTimeline = data.timeline;

        TopNav.setItem(TopNav.ITEM_MODEL_EVALUATION_STORE, $stateParams.mesId, {name: $scope.modelEvaluationStore.name});
        TopNav.setPageTitle($scope.modelEvaluationStore.name + " - Evaluation store");
    }).error(setErrorInScope.bind($scope));

    $scope.refreshTimeline = function() {
        DataikuAPI.timelines.getForObject(ActiveProjectKey.get(), "MODEL_EVALUATION_STORE", $scope.modelEvaluationStore.id)
        .success(function(data){
            $scope.objectTimeline = data;
        })
        .error(setErrorInScope.bind($scope));
    };

    var save = function() {
        DataikuAPI.modelevaluationstores.save($scope.modelEvaluationStore, {summaryOnly: true})
            .success(function(data) {
                ActivityIndicator.success("Saved");
            })
            .error(setErrorInScope.bind($scope));
    };

    if ($scope.$root.projectSummary.canWriteProjectContent) {
        /* Auto save */
        $scope.$watch("modelEvaluationStore", function(nv, ov) {
            if (nv && ov) {
                save();
            }
        }, true);
    }

    $scope.$on('customFieldsSummaryEdited', function(event, customFields) {
        ModelEvaluationStoreCustomFieldsService.saveCustomFields($scope.modelEvaluationStore, customFields);
    });

    checkChangesBeforeLeaving($scope, $scope.dirtySettings);

});


app.controller("ModelEvaluationStoreController", function($scope, Assert, DataikuAPI, CreateModalFromTemplate, $state, $stateParams, ActiveProjectKey, StateUtils, TopNav) {
    $scope.versionsContext = {}
    $scope.mesContext = {};
    $scope.uiState = {};
    $scope.clearVersionsContext = function(){
        clear($scope.versionsContext);
    };

    $scope.$on("$destroy", $scope.clearVersionsContext);

    $scope.savedSettings = {}
    DataikuAPI.modelevaluationstores.getFullInfo(ActiveProjectKey.get(), $stateParams.mesId).success(function(data){
        $scope.modelEvaluationStoreFullInfo = data;
        $scope.modelEvaluationStore = data.evaluationStore;
        if (!$scope.modelEvaluationStore.displayParams.sortColumn) {
            $scope.modelEvaluationStore.displayParams.sortColumn = "runId";
        }
        if (!$scope.modelEvaluationStore.displayParams.xLabel) {
            $scope.modelEvaluationStore.displayParams.xLabel = DEFAULT_X_LABEL;
            $scope.modelEvaluationStore.displayParams.yLabels = DEFAULT_Y_LABELS;
        }
        $scope.savedSettings = angular.copy($scope.modelEvaluationStore);
        TopNav.setItem(TopNav.ITEM_MODEL_EVALUATION_STORE, $stateParams.mesId, {name: data.name});
    }).error(setErrorInScope.bind($scope));

    $scope.save = function() {
        DataikuAPI.modelevaluationstores.save($scope.modelEvaluationStore).success(function(data) {
            $scope.savedSettings = angular.copy($scope.modelEvaluationStore);
        }).error(setErrorInScope.bind($scope));
    };

    $scope.dirtySettings = function() {
        return !angular.equals($scope.savedSettings, $scope.modelEvaluationStore);
    }

    $scope.goToEvaluatedModel = function() {
        if (!$scope.mesContext.evaluationFullInfo.evaluation) return;
        const modelRef = $scope.mesContext.evaluationFullInfo.evaluation.modelRef;
        StateUtils.go.savedModel(modelRef.smId, modelRef.projectKey);
    };

    $scope.goToEvaluatedModelVersion = function() {
        if (!$scope.mesContext.evaluationFullInfo.evaluation) return;
        const modelRef = $scope.mesContext.evaluationFullInfo.evaluation.modelRef;
        StateUtils.go.savedModelVersion('PREDICTION', modelRef.smId, modelRef.fullId, modelRef.projectKey);
    }

    $scope.goToEvaluatedDataset = function() {
        if (!$scope.mesContext.evaluationFullInfo.evaluation) return;
        StateUtils.go.dssObject('DATASET', $scope.mesContext.evaluationFullInfo.evaluation.dataParams.ref);
    };
});


/* ************************************ Settings *************************** */

app.controller("ModelEvaluationStoreSettingsController", function($scope, DataikuAPI, $q, CreateModalFromTemplate, $state, $stateParams, TopNav, $controller, ActivityIndicator, ComputableSchemaRecipeSave, ActiveProjectKey){
    TopNav.setLocation(TopNav.TOP_FLOW, TopNav.ITEM_MODEL_EVALUATION_STORE, TopNav.TABS_MODEL_EVALUATION_STORE, "settings");
    TopNav.setItem(TopNav.ITEM_MODEL_EVALUATION_STORE, $stateParams.mesId);
});


app.controller("ModelEvaluationsMetricsHandlingCommon", function($scope, PMLFilteringService, PMLSettings) {
    $scope.sortValue = function(sortColumn) {
        const metricsPattern = /^metrics\./;
        const labelsPattern = /^labels\./;
        if(metricsPattern.exec(sortColumn)) {
            return me => me.metrics[sortColumn.replace(metricsPattern, '')];
        }
        if(labelsPattern.exec(sortColumn)) {
            return me => me.labels.get(sortColumn.replace(labelsPattern, ''));
        }
    };

    $scope.refreshMetrics = function(predictionType) {
        $scope.possibleMetrics = [];
        if (!predictionType) {
            return;
        }
    
        let toDropdownElems = function(a) {
            return a.map(function(m) { return [m, PMLSettings.names.evaluationMetrics[m]] });
        };
        if ('BINARY_CLASSIFICATION' === predictionType) {
            $scope.possibleMetrics.push([null, 'Binary classification']);
            $scope.possibleMetrics = $scope.possibleMetrics.concat(toDropdownElems(['ACCURACY', 'PRECISION', 'RECALL', 'F1', 'COST_MATRIX', 'LOG_LOSS', 'ROC_AUC', 'CALIBRATION_LOSS', 'CUMULATIVE_LIFT', 'CUSTOM']));
        }
        if ('MULTICLASS' === predictionType) {
            $scope.possibleMetrics.push([null, 'Multiclass classification']);
            $scope.possibleMetrics = $scope.possibleMetrics.concat(toDropdownElems(['ACCURACY', 'PRECISION', 'RECALL', 'F1', 'LOG_LOSS', 'ROC_AUC', 'CALIBRATION_LOSS', 'CUSTOM']));
        }
        if ('REGRESSION' === predictionType) {
            $scope.possibleMetrics.push([null, 'Regression']);
            $scope.possibleMetrics = $scope.possibleMetrics.concat(toDropdownElems(['EVS', 'MAPE', 'MAE', 'MSE', 'RMSE', 'RMSLE', 'R2', 'PEARSON', 'CUSTOM']));
        }
        if ($scope.uiState.currentMetric && $scope.possibleMetrics.filter(_ => _[0] == $scope.uiState.currentMetric).length == 0) {
            // old selected metric isn't possible anymore
            $scope.uiState.currentMetric = null;
        }
        if ($scope.uiState.currentMetric == null) {
            if ('BINARY_CLASSIFICATION' === predictionType) {
                $scope.uiState.currentMetric = 'ROC_AUC';
            }
            if ('MULTICLASS' === predictionType) {
                $scope.uiState.currentMetric = 'ROC_AUC';
            }
            if ('REGRESSION' === predictionType) {
                $scope.uiState.currentMetric = 'R2';
            }
        }
        if (!$scope.modelEvaluationStore.displayParams.displayedMetrics) {
            $scope.modelEvaluationStore.displayParams.displayedMetrics = $scope.possibleMetrics.map(pm => pm[0]).filter(x => x);
        }
        $scope.refreshCurrentMetricNames();
    }

    $scope.refreshCurrentMetricNames = function() {
        if ($scope.modelEvaluationStore && $scope.modelEvaluationStore.displayParams.displayedMetrics && $scope.possibleMetrics) {
            $scope.uiState.currentFormattedNames = $scope.modelEvaluationStore.displayParams.displayedMetrics.map(cur => {
                return {
                    key: PMLFilteringService.metricMap[cur],
                    label: $scope.possibleMetrics.find(x => x[0] === cur)[1]
                };
            });
        } else {
            $scope.uiState.currentFormattedNames = [];
        }
        $scope.refreshMetricsValues();
    }

    $scope.refreshMetricsValues = function() {
        let refs;
        if ($scope.uiState.refs && $scope.uiState.refs.length) {
            refs = $scope.uiState.refs;
        } else if ($scope.ctrl && $scope.ctrl.refs && $scope.ctrl.refs.length) {
            refs = $scope.ctrl.refs;
        }
        if (refs) {
            for (let item of refs) {
                item.formattedMetrics = {};
                for (let metric of $scope.modelEvaluationStore.displayParams.displayedMetrics) {
                    item.formattedMetrics[PMLFilteringService.metricMap[metric]] = $scope.getMetricValue(item, metric);
                }
            }
        }
    }
});

/* ************************************ Evaluations list and perf drift *************************** */

app.controller("ModelEvaluationStoreListCommon", function($scope, DataikuAPI, $stateParams, TopNav, PMLFilteringService, PMLSettings, ActiveProjectKey, Fn, $filter, ModelEvaluationUtils, $controller) {
    $controller("ModelEvaluationsMetricsHandlingCommon", {$scope, PMLFilteringService, PMLSettings});

    TopNav.setLocation(TopNav.TOP_FLOW, TopNav.ITEM_MODEL_EVALUATION_STORE, TopNav.TABS_MODEL_EVALUATION_STORE, "evaluations");
    TopNav.setItem(TopNav.ITEM_MODEL_EVALUATION_STORE, $stateParams.mesId);

    $scope.uiState = {
        refs: [],
        titleLabels: []
    };

    $scope.refreshStatus = function() {
        DataikuAPI.modelevaluationstores.listEvaluations(ActiveProjectKey.get(), $stateParams.mesId).success(function(data) {
            $scope.evaluations = data.evaluations;
            TopNav.setItem(TopNav.ITEM_MODEL_EVALUATION_STORE, $stateParams.mesId, {name: data.modelEvaluationStore.name});
            $scope.predictionType = $scope.evaluations && $scope.evaluations.length?$scope.evaluations[0].evaluation.predictionType:null;
            $scope.refreshMetrics($scope.predictionType);
        }).error(setErrorInScope.bind($scope));
    };

    $scope.$watch("modelEvaluationStore", (nv) => { if (nv) $scope.refreshStatus(); });

    $scope.selection = $.extend({
        filterQuery: {
            userQuery: ''
        },
        filterParams: {
            userQueryTargets: ["runId", "trainDataSetName", "modelName", "evaluationDatasetName", "value"],
            propertyRules: {}
        },
        orderQuery: "-value",
        orderReversed: false
    }, $scope.selection || {});

    $scope.deleteSelectedEvaluations = function() {
        DataikuAPI.modelevaluationstores.deleteEvaluations(ActiveProjectKey.get(), $stateParams.mesId,
                $scope.selection.selectedObjects.filter(function(o){return !o.active}).map(Fn.prop('ref')).map(Fn.prop('runId')))
            .success($scope.refreshStatus)
            .error(setErrorInScope.bind($scope));
    };

    $scope.computeRefs = function() {
        if ($scope.evaluations) {
            $scope.uiState.refs = $scope.evaluations.map(x => {
                let ret = ModelEvaluationUtils.makeRefDisplayItemFromEvaluation(x.evaluation);
                ret.metrics = x.metrics;
                return ret;
            });
        } else {
            $scope.uiState.refs = [];
        }
        $scope.refreshMetricsValues();
    }

    $scope.getMetricValue = function(item,metric) {
        let ret = $filter('nicePrecision')(item.metrics[PMLFilteringService.metricMap[metric]],2);
        if (!ret) {
            ret = '-';
        }
        return ret;
    }

    DataikuAPI.modelevaluationstores.listWithAccessible($stateParams.projectKey).success(function(data){
        $scope.storeList = data;
    });

    $scope.computeTitleLabels = function() {
        $scope.uiState.titleLabels = ($scope.uiState.shownLabels && $scope.uiState.shownLabels.length)?generateTitleLabelsFromRefs($scope.uiState.shownLabels):[];
    }

    $scope.$watch("uiState.shownLabels", $scope.computeTitleLabels);

    $scope.computeAllLabels = function() {
        $scope.uiState.possibleLabels = _.sortBy(_.uniq(_.flatten($scope.uiState.refs.map(r => Array.from(r.labels.keys())))));
        if ($scope.uiState.possibleLabels && $scope.uiState.possibleLabels.length && !$scope.uiState.shownLabels) {
            $scope.uiState.shownLabels = [DEFAULT_X_LABEL].concat(DEFAULT_Y_LABELS);
        }
        if ($scope.uiState.shownLabels && $scope.uiState.shownLabels.length) {
            $scope.uiState.shownLabels = $scope.uiState.shownLabels.filter(l => $scope.uiState.possibleLabels.includes(l));
        }
    }

    $scope.$watch('evaluations', $scope.computeRefs);
    $scope.$watch('uiState.refs', $scope.computeAllLabels);

    $scope.labelPrefix = function(labelKey) {
        return getDomainLabel(labelKey);
    }

    $scope.labelSuffix = function(labelKey)  {
        return getDomainSubLabel(labelKey);
    }

    $scope.shouldSaveDisplaySettings = function() {
        return $scope.$root && $scope.$root.projectSummary && $scope.$root.projectSummary.canWriteProjectContent
            && $scope.savedSettings && $scope.modelEvaluationStore && !angular.equals($scope.savedSettings.displayParams, $scope.modelEvaluationStore.displayParams);
    }


    $scope.$watch("shouldSaveDisplaySettings()", (dirty) => { if (dirty) { $scope.save(); } });

});

app.controller("ModelEvaluationStoreEvaluationsController", function($scope, DataikuAPI, $stateParams, TopNav, $controller, ActivityIndicator, PMLFilteringService, PMLSettings, ActiveProjectKey, Fn, $filter) {
    $controller("ModelEvaluationStoreListCommon", {$scope});
    TopNav.setLocation(TopNav.TOP_FLOW, TopNav.ITEM_MODEL_EVALUATION_STORE, TopNav.TABS_MODEL_EVALUATION_STORE, "evaluations");
    TopNav.setItem(TopNav.ITEM_MODEL_EVALUATION_STORE, $stateParams.mesId);
    $scope.$watch("modelEvaluationStore.displayParams.displayedMetrics", $scope.refreshCurrentMetricNames)
});

app.controller("ModelEvaluationStorePerfDriftController", function($scope, $filter, $stateParams, TopNav, $controller, ModelEvaluationUtils, PMLFilteringService, DataikuAPI) {
    $controller("ModelEvaluationStoreListCommon", {$scope});
    TopNav.setLocation(TopNav.TOP_FLOW, TopNav.ITEM_MODEL_EVALUATION_STORE, TopNav.TABS_MODEL_EVALUATION_STORE, "perfdrift");
    TopNav.setItem(TopNav.ITEM_MODEL_EVALUATION_STORE, $stateParams.mesId);
});

const DEFAULT_X_LABEL = "evaluation:date";
const DEFAULT_Y_LABELS = ["model:algorithm", "model:date", "evaluationDataset:dataset-name"];
const DEFAULT_SELECTED_LABELS = [DEFAULT_X_LABEL].concat(DEFAULT_Y_LABELS); // in 'driftReferencesSelector'


function generateTitleLabelsFromRefs(refLabels) {
    var titleLabels = [];
    let curDomainTitle = null;
    for (const curLabel of refLabels) {
        const labelParts = curLabel.split(":");
        if (1 == labelParts.length) {
            curDomainTitle = null;
            titleLabels.push({
                domain: "-",
                subLabel: curLabel,
                fullLabel: curLabel
            });
            continue;
        }
        titleLabels.push({
            domain: labelParts[0] !== curDomainTitle?labelParts[0]:null,
            subLabel: labelParts.slice(1).join(":"),
            fullLabel: curLabel
        });
        curDomainTitle = labelParts[0];
    }

    let curDomainCount = 1;
    for (let i = titleLabels.length-1 ; i >=0 ; i--) {
        if (!titleLabels[i].domain) {
            curDomainCount++;
        } else {
            titleLabels[i].span = curDomainCount;
            curDomainCount = 1;
        }
    }
    return titleLabels;
}



function getDomainLabel(labelKey) {
    const labelParts = labelKey.split(":");
    if (1 >= labelParts.length) {
        return "(no domain)";
    }
    return labelParts[0];
}

function getDomainSubLabel(labelKey) {
    const labelParts = labelKey.split(":");
    if (1 >= labelParts.length) {
        return labelKey;
    }
    return labelParts.slice(1).join(":");
}

app.controller('DriftReferencesSelectorModalController', function($scope, CollectionFiltering) {
    $scope.filterQuery = { userQuery: '' };

    $scope.save = function() {
        if($scope.driftModalState.selectedReference) {
            $scope.acceptDeferred.resolve($scope.driftModalState.selectedReference);
        }
        $scope.dismiss();
    }

    $scope.sortValue = sortColumn => me => me.labels.get(sortColumn);

    $scope.$watch('filterQuery.userQuery', ()=> {
        $scope.driftModalState.filteredCompatibleReferences = CollectionFiltering.filter($scope.driftModalState.compatibleReferences, $scope.filterQuery);
    });

    $scope.labelPrefix = function(labelKey) {
        return getDomainLabel(labelKey);
    }

    $scope.labelSuffix = function(labelKey)  {
        return getDomainSubLabel(labelKey);
    }
});

app.component('driftReferencesSelector',{
    bindings: {
        ref: '=',
        cur: '<',
        compatibleReferences: '<',
        action: '<',
        fnLabel: '<',
        refLabels: '=',
        driftParams: '<' // Used to show the configuration popover within this directive
    },
    templateUrl: '/templates/modelevaluationstores/drift-references-selector.html',
    controller: function ctrlModelLikesInfo($scope, ClipboardUtils, openDkuPopin, $q, CreateModalFromTemplate) {
        $scope.$ctrl = this;

        $scope.uiState = {
            titleLabels: [],
            selectedLabels: [], 
            allLabels: []
        };

        $scope.labelPrefix = function(labelKey) {
            return getDomainLabel(labelKey);
        }

        $scope.labelSuffix = function(labelKey)  {
            return getDomainSubLabel(labelKey);
        }

        $scope.changeReference = function() {
            const deferred = $q.defer();
            CreateModalFromTemplate("/templates/modelevaluationstores/drift-references-selector-modal.html", $scope, "DriftReferencesSelectorModalController", function(newScope) {
                newScope.acceptDeferred = deferred;
                newScope.driftModalState = {
                    selectedLabels: angular.copy($scope.uiState.selectedLabels),
                    selectedReference: $scope.$ctrl.ref,
                    currentMe: $scope.$ctrl.cur,
                    compatibleReferences: $scope.$ctrl.compatibleReferences,
                    allLabels: $scope.uiState.allLabels,
                }
                newScope.$on("$destroy",function() {
                    if(newScope.acceptDeferred) {
                        newScope.acceptDeferred.reject();
                    }
                    newScope.acceptDeferred = null;
                });
            });
            deferred.promise.then((newRef)=> {
                $scope.$ctrl.ref = newRef;
                $scope.$applyAsync(() => $scope.$ctrl.action());
            });
        };

        $scope.computeAllLabels = function() {
            $scope.uiState.allLabels = [];
            if ($scope.$ctrl.compatibleReferences) {
                $scope.uiState.allLabels = [...new Set($scope.$ctrl.compatibleReferences.flatMap(me => [...me.labels.keys()]))];
            }
            $scope.uiState.allLabels.sort((v1,v2) => {
                const domainV1 = getDomainLabel(v1);
                const domainV2 = getDomainLabel(v2);
                const cmp = domainV1.localeCompare(domainV2);
                if (domainV1 === domainV2) {
                    const subLabelV1 = getDomainSubLabel(v1);
                    const subLabelV2 = getDomainSubLabel(v2);
                    return subLabelV1.localeCompare(subLabelV2);
                }
                return cmp;
            })

            if($scope.uiState.selectedLabels.length == 0) {
                // No label is selected (likely, initial state) => set defaults if they exist
                $scope.uiState.selectedLabels = DEFAULT_SELECTED_LABELS.filter(label=> $scope.uiState.allLabels.includes(label));
            }
        }

        $scope.computeTitleLabels = function() {
            $scope.uiState.titleLabels = generateTitleLabelsFromRefs($scope.uiState.selectedLabels);
        }

        $scope.$watch("$ctrl.compatibleReferences", $scope.computeAllLabels);
        $scope.$watch("uiState.selectedLabels", $scope.computeTitleLabels);

        $scope.copyDataDriftParamsToClipboard = function() {
            ClipboardUtils.copyToClipboard(JSON.stringify($scope.$ctrl.driftParams, null, 2));
        };

        let dismissComputeParamsPopin = null;
        $scope.toggleComputationParamsPopin = function($event) {
            if (!dismissComputeParamsPopin) {
                function isElsewhere(elt, e) {
                    return $(e.target).parents(".dropdown-menu").length == 0;
                }
                const dkuPopinOptions = {
                    template: `
                        <ul class="dropdown-menu" style="padding: 15px;" listen-keydown="{'enter': 'save()', 'esc': 'dismiss()' }">
                            <form class="dkuform-horizontal">
                                <div class="control-group">
                                    <label for="" class="control-label">Confidence level</label>
                                    <div class="controls">
                                        <input type="number" required ng-model="$ctrl.driftParams.confidenceLevel" min="0.5" max="0.999"
                                            step="0.001" />
                                        <div class="help-inline">
                                            Used to compute confidence interval and determine significance level of statistical tests
                                        </div>
                                    </div>
                                </div>

                                <div class="control-group">
                                    <label for="" class="control-label">PSI threshold</label>
                                    <div class="controls">
                                        <input type="number" required ng-model="$ctrl.driftParams.psiThreshold" min="0" max="1"
                                            step="0.001" />
                                        <div class="help-inline">Using a fixed random seed allows for reproducible result</div>
                                    </div>
                                </div>

                                <button type="button" class="pull-right btn btn--secondary" ng-click="copyDataDriftParamsToClipboard()">
                                    <i class="icon-copy interactive-scoring__edit-icon"></i>
                                    Copy settings to clipboard
                                </button>
                            </form>
                        </ul>
                    `,
                    isElsewhere,
                    popinPosition: 'SMART',
                    onDismiss: () => {
                        dismissComputeParamsPopin = null;
                    }
                };
                dismissComputeParamsPopin = openDkuPopin($scope, $event, dkuPopinOptions);
            } else {
                dismissComputeParamsPopin();
                dismissComputeParamsPopin = null;
            }
        };
    }
});


app.component('perfDrift', {
    bindings: {
        refs: '<',
        predictionType: '<',
        labels: '<',
        storeList: '<',
        refreshStatus: '<',
        excludedLabels: '<',
        hideStore: '<',
        displayParams: '=',
        possibleMetrics: '<'
    },
    templateUrl: '/templates/modelevaluationstores/perfdrift-component.html',
    controller: ['$scope', 'PMLSettings', '$filter', 'PMLFilteringService', '$state', '$stateParams', '$controller', 'ChartIconUtils', '$sanitize',
        function ctrlPerfDrift($scope, PMLSettings, $filter, PMLFilteringService, $state, $stateParams, $controller, ChartIconUtils, $sanitize) {
            $scope.$state = $state;
            $scope.$stateParams = $stateParams;
            let ctrl = this;
            $scope.ctrl = ctrl;

            $scope.uiState = {
                query:  null,
                titleLabels: [],
                focusedLabels: []
            };

            ctrl.$onChanges = function(changes) {
                $scope.labels= ctrl.labels;
                $scope.refreshLabels();
                $scope.refreshTableData();
                $scope.refreshEchartsData();
            }

            $scope.graphData = [];
        
            $scope.selection = $.extend({
                filterQuery: {
                    userQuery: ''
                },
                filterParams: {
                    userQueryTargets: ["runId", "trainDataSetName", "modelName", "evaluationDatasetName", "value"],
                    propertyRules: {}
                },
                orderQuery: "-value",
                orderReversed: false
            }, $scope.selection || {});

            $scope.computeChartIcone = function(type, variant, webAppType) {
                return ChartIconUtils.computeChartIcon(type, variant, $scope.isInAnalysis, webAppType);
            }

            $scope.setGraphTypes = function() {
                $scope.uiState.graphStyle = ($scope.selection.filteredSelectedObjects && $scope.selection.filteredSelectedObjects.length > 2)?'LINE':'BAR';
            }

            $scope.generateTitleLabels = function() {
                var labels = [];
                if (ctrl.displayParams.xLabel) {
                    labels.push(ctrl.displayParams.xLabel);
                }
                if (ctrl.displayParams.yLabels) {
                    labels = labels.concat(ctrl.displayParams.yLabels);
                }
                if (ctrl.displayParams.alsoDisplayedLabels) {
                    labels = labels.concat(ctrl.displayParams.alsoDisplayedLabels);
                }
                labels.sort();
                $scope.uiState.titleLabels = generateTitleLabelsFromRefs(labels);
            }

            $scope.refreshLabels = function() {
                let labelKeys = _.sortBy(_.uniq(_.flatten(ctrl.refs.map(r => Array.from(r.labels.keys())))));
                if ($scope.ctrl.excludedLabels) {
                    labelKeys = labelKeys.filter(l => !$scope.ctrl.excludedLabels.includes(l));
                }
                $scope.possibleXLabels = labelKeys;
                if (ctrl.displayParams.xLabel && !$scope.possibleXLabels.includes(ctrl.displayParams.xLabel)) {
                    ctrl.displayParams.xLabel = undefined;
                }
                if (!ctrl.displayParams.xLabel && !$scope.ctrl.excludedLabels) {
                    ctrl.displayParams.xLabel = (labelKeys && labelKeys.length)?(labelKeys.includes(DEFAULT_X_LABEL)?DEFAULT_X_LABEL:labelKeys[0]):undefined;
                }
                $scope.possibleYLabels = $scope.possibleXLabels.slice().filter(x => x !== ctrl.displayParams.xLabel);
                $scope.possibleOtherLabels = $scope.possibleYLabels.slice().filter(x => ctrl.displayParams.yLabels?!ctrl.displayParams.yLabels.includes(x):true);
            }


            $scope.$watch("ctrl.displayParams.xLabel", function() {
                $scope.setGraphTypes();
                $scope.possibleYLabels = $scope.possibleXLabels.slice().filter(x => x !== ctrl.displayParams.xLabel);
                if (!ctrl.displayParams.yLabels || !ctrl.displayParams.yLabels.length) {
                    ctrl.displayParams.yLabels = DEFAULT_Y_LABELS.filter(l => $scope.possibleYLabels.includes(l));
                }
                if (ctrl.displayParams.yLabels && ctrl.displayParams.yLabels.length) {
                    ctrl.displayParams.yLabels = ctrl.displayParams.yLabels.filter(x => (x !== ctrl.displayParams.xLabel) && $scope.possibleYLabels.includes(x));
                }
                if (ctrl.displayParams.alsoDisplayedLabels && ctrl.displayParams.alsoDisplayedLabels.length) {
                    ctrl.displayParams.alsoDisplayedLabels = ctrl.displayParams.alsoDisplayedLabels.filter(x => x !== ctrl.displayParams.xLabel);
                }
            });

            $scope.$watch("ctrl.displayParams.yLabels", function() {
                $scope.possibleOtherLabels = $scope.possibleYLabels.slice().filter(x => !ctrl.displayParams.yLabels.includes(x));
                if (ctrl.displayParams.alsoDisplayedLabels && ctrl.displayParams.alsoDisplayedLabels.length) {
                    ctrl.displayParams.alsoDisplayedLabels = ctrl.displayParams.alsoDisplayedLabels.filter(x => !ctrl.displayParams.yLabels.includes(x));
                }
            });

            $scope.$watch("uiState.graphStyle", function(nv, ov) {
                if (nv === ov) return;
                if ('BAR' == nv) {
                    $scope.uiState._yLabels = ctrl.displayParams.yLabels;
                    ctrl.displayParams.yLabels = [];
                } else {
                    if (!ctrl.displayParams.yLabels) {
                        ctrl.displayParams.yLabels = $scope.uiState._yLabels || [];
                    }
                }
            });

            $scope.labelPrefix = function(labelKey) {
                return getDomainLabel(labelKey);
            }

            $scope.labelSuffix = function(labelKey)  {
                return getDomainSubLabel(labelKey);
            }

            $scope.computeMergedObject = function() {
                let keyObjects = _.uniqWith(ctrl.refs.map((v) => {
                    let ret = {};
                    const foundXLabel = v.labels.get(ctrl.displayParams.xLabel);
                    ret[ctrl.displayParams.xLabel] = foundXLabel?foundXLabel:null;
                    if (ctrl.displayParams.yLabels) {
                        for (let key of ctrl.displayParams.yLabels) {
                            const foundYLabel = v.labels.get(key);
                            ret[key] = foundYLabel?foundYLabel:null;
                        }
                    }
                    return ret;
                }), _.isEqual);
                $scope.mergedObjects = ctrl.refs.length - keyObjects.length;
            }

            $scope.refreshTableData = function() {
                $scope.mergedObjects = 0;
                if (ctrl.refs && ctrl.labels) {
                    $scope.tableData = ctrl.refs.map((v,i) => { v.id = i+1; v.$selected = true; return v;});
                } else if (ctrl.refs && ctrl.refs.length > 0) {
                    $scope.tableData = ctrl.refs.map((v,i) => { v.id = i+1; v.$selected = true; return v;});
                } else {
                    $scope.tableData = null;
                }
            }

            const ISO8861_RE = /\d{4}-[01]\d(-[0-3]\d(( |T)[0-2]\d(:[0-5]\d(:[0-5]\d(\.\d+([+-][0-2]\d:[0-5]\d|Z)?)?)?)?)?)?/;
            const X_VALUE_CACHE_ATTR = "_xValue";
            const DISPLAY_LABEL_CACHE_ATTR = "_displayLabel";
            const DISPLAY_LABELS_CACHE_ATTR = "_displayLabels";

            $scope.computeChartOptionsLines = function() {
                $scope.chartsOptions = ctrl.displayParams.displayedMetrics.map((currentMetric, idx) => {
                    const xAxisLabel = ctrl.displayParams.xLabel || "";
                    const yLabels = (ctrl.displayParams.yLabels && ctrl.displayParams.yLabels.length)?ctrl.displayParams.yLabels: [];
        
                    const valuesWithTag = _.filter($scope.selection.filteredSelectedObjects, item => item.labels.has(xAxisLabel)).map(item => {
                        let copy = _.cloneDeep(item);
                        copy[X_VALUE_CACHE_ATTR] = copy.labels.get(xAxisLabel);
                        return copy;
                    });
                    let isNumeric = valuesWithTag.reduce((acc,cur) => acc && !isNaN(cur[X_VALUE_CACHE_ATTR]), true);
                    let isTemporal = valuesWithTag.reduce((acc,cur) => acc && ISO8861_RE.test(cur[X_VALUE_CACHE_ATTR]), true);
                    const convertedValuesWithTag = valuesWithTag.map(v => {
                        if (!isTemporal && !isNumeric) return v;
                        let copy = _.cloneDeep(v);
                        if (isTemporal) {
                            copy[X_VALUE_CACHE_ATTR] = moment(copy[X_VALUE_CACHE_ATTR]).valueOf();
                        } else {
                            copy[X_VALUE_CACHE_ATTR] = parseFloat(copy[X_VALUE_CACHE_ATTR]);
                        }
                        return copy;
                    });
        
                    const sortedValuesWithTag = _.orderBy(convertedValuesWithTag, item => item[X_VALUE_CACHE_ATTR], 'asc');

                    sortedValuesWithTag.forEach(item => {
                        let labelValues = [];
                        let curLabels = new Map();
                        for (let curYLabel of yLabels) {
                            const found = item.labels.get(curYLabel);
                            if (found && "" != found) {
                                labelValues.push(found);
                                curLabels.set(curYLabel, found);
                            }
                        }
                        let ret = labelValues.join("-");
                        if ("" === ret) {
                            ret = "(no labels)"
                        }
                        item[DISPLAY_LABEL_CACHE_ATTR] = ret;
                        item[DISPLAY_LABELS_CACHE_ATTR] = curLabels;
                    });
                    // generate unique label list
                    let labels = _.uniq(sortedValuesWithTag.map(item => item[DISPLAY_LABEL_CACHE_ATTR]));
    
                    // assign colors to the labels
                    let labelColors = new Map();
                    labels.forEach((label,index) => {
                        labelColors.set(label, $scope.colors[index%$scope.colors.length]);
                    });

                    // let's generate line segments
                    let currentLabel = null;
                    let series = [];
                    let currentSerie = null;
                    let mapSegments = new Map();
                    let mapSegmentsLabels = new Map();

                    let evaluationColors = new Map();
                    for (const currentItem of sortedValuesWithTag) {
                        if (currentLabel != currentItem[DISPLAY_LABEL_CACHE_ATTR]) {
                            currentLabel = currentItem[DISPLAY_LABEL_CACHE_ATTR];
                            currentSerie = mapSegments.get(currentLabel);
                            if (!currentSerie) {
                                currentSerie = {
                                    data: [],
                                    name: currentLabel,
                                    type: 'line',
                                    symbol: 'roundRect',
                                    symbolSize: 5,
                                    color: labelColors.get(currentLabel)
                                };
                                series.push(currentSerie);
                                mapSegments.set(currentLabel, currentSerie);
                                mapSegmentsLabels.set(currentLabel, currentItem[DISPLAY_LABELS_CACHE_ATTR]);
                            }
                        }
                        currentSerie.data.push([currentItem[X_VALUE_CACHE_ATTR],currentItem.metrics[PMLFilteringService.metricMap[currentMetric]],currentItem["id"]]); // NOSONAR
                        evaluationColors.set(currentItem["id"], currentSerie.color);

                    }

                    $scope.colormap(evaluationColors);
                    $scope.mapSegmentsLabels = mapSegmentsLabels;
    
                    return {
                        animation: false,
                        tooltip: {
                            trigger: 'item',
                            confine: true,
                            axisPointer: { type: 'none' },
                            formatter: (params) => {
                                $scope.uiState.hoverId = (params.data && params.data.length > 2)?params.data[2]:undefined;
                                $scope.$apply();
                                const serieLabels = $scope.mapSegmentsLabels.get(params.seriesName);
                                const X = isTemporal?moment(params.data[0]).format("YYYY-MM-DDTHH:mm:ss.SSSZ"):params.data[0];
                                if (!serieLabels || !serieLabels.size) {
                                    return `${params.seriesName} - ${X}: ${params.data[1].toFixed(2)}`;
                                } else {
                                    let ret = "<table style='background: none;'><tbody>";
                                    for (const labelEntry of serieLabels) {
                                        const labelName = $sanitize(labelEntry[0]);
                                        const labelValue = $sanitize(labelEntry[1]);
                                        ret += `<tr><td>${labelName}</td><td>${labelValue}</td></tr>`;
                                    }
                                    ret += `<tr><td>X</td><td>${X}</td></tr>`;
                                    const value = $sanitize(params.data[1].toFixed(2));
                                    ret += `<tr><td>Value</td><td>${value}</td></tr>`;
                                    ret += '</tbody></table>';
                                    return ret;
                                }
                            }
                        },
                        xAxis: [{
                            type: isTemporal?'time':(isNumeric?'value':'category'),
                            axisLine: { show: true },
                            axisTick: { show: true },
                            axisLabel: ctrl.displayParams.xLabel || "",
                            scale: true
                        }],
                        yAxis: [{
                            type: 'value',
                            axisTick: { show: true },
                            axisLine: { show: true },
                            scale: true
                        }],
                        series,
                        grid: {
                            top: 10,
                            bottom: 20,
                            left: 40,
                            right: 3
                        },
                        metric: ctrl.possibleMetrics.find(x => x[0] === currentMetric)
                    };
                });
            }

            $scope.computeChartOptionsBars = function() {
                let objects;
                if (ctrl.refs && ctrl.labels) {
                    objects = ctrl.refs;
                } else {
                    objects = $scope.selection.filteredSelectedObjects;
                }
                $scope.chartsOptions = ctrl.displayParams.displayedMetrics.map((currentMetric) => {
                    const series = objects.map(
                        (v, idx) => {
                            return {
                                name: $scope.labels?$scope.labels[idx]:v.ref.runId,
                                type: 'bar',
                                data: [v.metrics[PMLFilteringService.metricMap[currentMetric]]]
                            };
                        });
                    return {
                        animation: false,
                        tooltip: {
                            trigger: 'item',
                            confine: true,
                            axisPointer: { type: 'none' },
                            formatter: (params) => {
                                return `${params.seriesName}: ${params.value.toFixed(2)}`;
                            }
                        },
                                    xAxis: [{
                            type: 'category',
                            axisLine: { show: true },
                            axisTick: { show: true }
                        }],
                        yAxis: [{
                            type: 'value',
                            axisTick: { show: true },
                            axisLine: { show: true },
                        }],
                        series,
                        color: $scope.colors,
                        grid: {
                            top: 10,
                            bottom: 20,
                            left: 40,
                            right: 0
                        },
                        metric: ctrl.possibleMetrics.find(x => x[0] === currentMetric)
                   };
                });
                const evaluationColors = new Map();
                objects.forEach((v,i) => {
                    evaluationColors.set(v.id, $scope.colors[i]);
                });
                $scope.colormap(evaluationColors);
            }

            $scope.refreshEchartsData = function() {
                if (ctrl.refs && ctrl.labels) {
                    $scope.computeChartOptionsBars();
                } else if ($scope.selection.filteredSelectedObjects && $scope.selection.filteredSelectedObjects.length) {
                    if ('LINE' === $scope.uiState.graphStyle) {
                        $scope.computeChartOptionsLines();
                    } else {
                        // 'BAR'
                        $scope.computeChartOptionsBars();
                    }
                } else {
                    $scope.chartsOptions = [];
                }
            }

            $scope.refreshCurrentMetricNames = function() {
                if (ctrl.displayParams.displayedMetrics) {
                    $scope.uiState.currentFormattedNames = ctrl.displayParams.displayedMetrics.map(cur => {
                        return {
                            key: PMLFilteringService.metricMap[cur],
                            label: ctrl.possibleMetrics.find(x => x[0] === cur)[1]
                        };
                    });
                } else {
                    $scope.uiState.currentFormattedNames = [];
                }
                $scope.refreshMetricsValues();
            }

            $scope.refreshMetricsValues = function() {
                let refs = $scope.ctrl.refs;
                if (refs) {
                    for (let item of refs) {
                        item.formattedMetrics = {};
                        for (let metric of ctrl.displayParams.displayedMetrics) {
                            item.formattedMetrics[PMLFilteringService.metricMap[metric]] = $scope.getMetricValue(item, metric);
                        }
                    }
                }
            }

            $scope.$watch("ctrl.displayParams.displayedMetrics", $scope.refreshTableData);
            $scope.$watch("ctrl.displayParams.displayedMetrics", $scope.refreshEchartsData);
            $scope.$watch("ctrl.displayParams.displayedMetrics", $scope.refreshCurrentMetricNames);
            $scope.$watch("ctrl.displayParams.xLabel", $scope.computeMergedObject);
            $scope.$watch("ctrl.displayParams.yLabels", $scope.computeMergedObject);
            $scope.$watch("ctrl.displayParams.xLabel", $scope.refreshEchartsData);
            $scope.$watch("ctrl.displayParams.yLabels", $scope.refreshEchartsData);
            $scope.$watch("selection.filteredSelectedObjects", $scope.setGraphTypes);
            $scope.$watch("selection.filteredSelectedObjects", $scope.refreshEchartsData);
            $scope.colors = window.dkuColorPalettes.discrete[0].colors.filter((x,idx) => idx%2 === 0);
            $scope.$watch("ctrl.displayParams.xLabel", $scope.generateTitleLabels);
            $scope.$watch("ctrl.displayParams.yLabels", $scope.generateTitleLabels);
            $scope.$watch("ctrl.displayParams.alsoDisplayedLabels", $scope.generateTitleLabels);


            $scope.uiState.hoverId = null;

            $scope.mouseovergraph = function(val) {
                $scope.uiState.hoverId = val.data.id;
                $scope.$digest();
            }

            $scope.mouseoutgraph = function() {
                $scope.uiState.hoverId = null;
                $scope.$digest();
            }

            $scope.colormap = function(obj) {
                $scope.uiState.colormap = obj;
            }

            $scope.styleKeyColor = function(item) {
                let color = "#FFFFFF";
                if ($scope.uiState.colormap) {
                    color = $scope.uiState.colormap.get(item.id);
                }
                return { "background-color": color };
            }


            $scope.getMetricValue = function(item,metric) {
                let ret = $filter('nicePrecision')(item.metrics[PMLFilteringService.metricMap[metric]],2);
                if (!ret) {
                    ret = '-';
                }
                return ret;
            }

            $scope.getStoreName = function(storeId) {
                if (!storeId) {
                    return null;
                }
                if (ctrl.storeList && ctrl.storeList.length) {
                    let store = ctrl.storeList.find(s => s.id === storeId);
                    if (store) {
                        return store.name;
                    }
                }
                return storeId;
            }

            $scope.addFocusedGraphLabel = function(label) {
                if (ctrl.displayParams.pinnedMetrics.includes(label)) return;
                ctrl.displayParams.pinnedMetrics.push(label);
            }

            $scope.removeFocusedGraphLabel = function(label) {
                ctrl.displayParams.pinnedMetrics = ctrl.displayParams.pinnedMetrics.filter(e => e !== label);
            }

            $scope.showBigGraph = function(label) {
                return ctrl.displayParams.pinnedMetrics.includes(label);
            }

            $scope.firstMetricOfDomain = function(label) {
                const labels = $scope.uiState.currentFormattedNames.map(metric => metric.label);
                return [
                    labels.find(l => $scope.showBigGraph(l)),
                    labels.find(l => !$scope.showBigGraph(l))
                ].includes(label);
            }
        }
    ]
});

app.controller("ModelEvaluationStoreEvaluationController", function($scope, DataikuAPI, $q, CreateModalFromTemplate, $state, $stateParams, TopNav, $controller, PMLFilteringService, PMLSettings, ActiveProjectKey, ModelEvaluationUtils){
    $controller("ModelEvaluationsMetricsHandlingCommon", {$scope, PMLFilteringService, PMLSettings});
    $scope.noMlReportTourHere = true; // the tabs needed for the tour are not present

    TopNav.setLocation(TopNav.TOP_FLOW, TopNav.ITEM_MODEL_EVALUATION_STORE, "MODEL_EVALUATION_STORE-EVALUATION", "report");
    TopNav.setItem(TopNav.ITEM_MODEL_EVALUATION_STORE, $stateParams.mesId, {runId: $stateParams.runId});

    $scope.refreshStatus = function() {
        DataikuAPI.modelevaluationstores.getEvaluation(ActiveProjectKey.get(), $stateParams.mesId, $stateParams.runId).success(function(data) {
            $scope.mesContext.evaluationFullInfo = data.evaluation;

            $scope.versionsContext.activeMetric = data.evaluation.evaluation.metricParams.evaluationMetric;
            $scope.evaluation = data.evaluation;
            $scope.refreshMetrics($scope.evaluation.evaluation.predictionType);
            TopNav.setItem(TopNav.ITEM_MODEL_EVALUATION_STORE, $stateParams.mesId, {name: data.modelEvaluationStore.name, runId: $stateParams.runId});

            $scope.modelData = data.evaluation.details;
            $scope.modelData.modelEvaluation = data.evaluation.evaluation;
            $scope.evaluatedDataStatistics = data.evaluation.evaluatedDataStatistics;
            $controller("_PredictionModelReportController",{$scope:$scope});

            $scope.isPartitionedModel = function() { return false; };

            let fme = makeFullModelEvalutionIdString(ActiveProjectKey.get(), $stateParams.mesId, $stateParams.runId);
            DataikuAPI.modelevaluations.get(fme).success(function(data) {
                $scope.modelEvaluation = data;
                $scope.fullModelEvaluationId = fme;
                $scope.currentMEReference = ModelEvaluationUtils.makeRefDisplayItemFromEvaluation($scope.modelEvaluation, $scope.storeList);
            }).error(setErrorInScope.bind($scope));
            DataikuAPI.modelevaluations.listCompatibleReferencesForDrift(ActiveProjectKey.get(), fme, false).success(function(data) {
                $scope.compatibleReferences = ModelEvaluationUtils.computeReferenceLabels(ModelEvaluationUtils.makeRefDisplayItemFromModelLikeInfo(data.compatibleReferences, $scope.storeList, $scope.modelList));
                $scope.driftState.selectedReference = $scope.driftState.selectedReference || $scope.compatibleReferences.find(me => data.defaultReference && me.ref.fullId == data.defaultReference.fullId);
            }).error(setErrorInScope.bind($scope));
            if ($scope.modelData.classes) {
                $scope.driftState.currentClass = $scope.modelData.classes[0];
            }
        }).error(setErrorInScope.bind($scope));
    };
    $scope.refreshStatus();

    $scope.driftState = {
        selectedReference: null
    };

    $scope.resetDriftResults = function(nv, ov) {
        if (nv != ov) {
            $scope.driftState.dataDriftResult = null;
            $scope.driftState.perfDriftRefs = null;
            $scope.driftState.pdfs = null;
            $scope.driftState.pdd = null;
            $scope.driftState.refDensityData = null;
            $scope.driftState.refPredValueCount = null;
            $scope.driftState.curPredValueCount = null;
            $scope.driftState.univariateCols = [];
            $scope.driftState.predHistogramOptions = null;
            $scope.driftState.classes = null;
        }
    }
    $scope.resetDriftResults();

    $scope.refreshCurrentMEReference = function() {
        $scope.currentMEReference = ModelEvaluationUtils.makeRefDisplayItemFromEvaluation($scope.modelEvaluation, $scope.storeList);
    }

    DataikuAPI.modelevaluationstores.listWithAccessible($stateParams.projectKey).success(function(data){
        $scope.storeList = data;
    });

    DataikuAPI.savedmodels.listWithAccessible($stateParams.projectKey).success(function(data){
        $scope.modelList = data;
    });

    $scope.$watch('driftState.selectedReference', $scope.resetDriftResults);
    $scope.$watch('modelEvaluation', $scope.refreshCurrentMEReference);
    $scope.$watch('storeList', $scope.refreshCurrentMEReference);

    $scope.$watch('storeList', $scope.refreshCompatibleReferences);
    $scope.$watch('modelList', $scope.refreshCompatibleReferences);

    $scope.$on("$destroy", function() {
        $scope.mesContext.evaluationFullInfo = null;
    });
    
});


/************************** creation modal ***************************/

app.controller("NewModelEvaluationStoreController", function($scope, $state, DataikuAPI, WT1, $stateParams) {
    WT1.event("new-model-evaluation-store-modal-open");

    $scope.newMES = {
        name : null,
        settings : {
            zone: $scope.getRelevantZoneId($stateParams.zoneId)
        }
    };

    DataikuAPI.datasets.getModelEvaluationStoreOptionsNoContext($stateParams.projectKey).success(function(data) {
        $scope.managedDatasetOptions = data;
        $scope.partitioningOptions = [
            {"id" : "NP", "label" : "Not partitioned"},
        ].concat(data.projectPartitionings)

        $scope.newMES.settings.partitioningOptionId = "NP";
    }).error(setErrorInScope.bind($scope));

    $scope.create = function(){
        resetErrorInScope($scope);
        WT1.event("new-model-evaluation-store-modal-create");
        DataikuAPI.datasets.newModelEvaluationStore($stateParams.projectKey, $scope.newMES.name, $scope.newMES.settings).success(function(data) {
            $scope.dismiss();
            $state.go("projects.project.modelevaluationstores.modelevaluationstore.evaluations", {mesId: data.id})
        }).error(setErrorInScope.bind($scope));
    }
});

/******************** evaluated data statistics  ********************/
app.directive('evaluatedDataStatistics', function($controller, $state, $stateParams, $rootScope) {
    return {
        scope: false,
        link : function($scope, element, attrs) {
            $scope.uiState = {};
            
            $scope.selection = $.extend({
                    filterQuery: {
                        userQuery: ''
                    },
                    filterParams: {
                        userQueryTargets: ["column", "type", "featureType", "featureRole"],
                        propertyRules: {}
                    },
                    orderQuery: "column",
                    orderReversed: false,
                }, $scope.selection || {});

            $scope.columnList = []; // lighter objects for the list where you select columns, to ease the load on angular watches
            let updateUnivariatesList = function() {
                $scope.univariatesMap = {};
                $scope.columnList.splice(0, $scope.columnList.length);
                if ($scope.evaluatedDataStatistics && $scope.evaluatedDataStatistics.univariate) {
                    Object.keys($scope.evaluatedDataStatistics.univariate).forEach(function(k) {
                        let statistics = $scope.evaluatedDataStatistics.univariate[k];
                        let facet = $scope.evaluation.columns[k] || {};
                        // put a fake "cache" in there, so that the column-analysis directive doesn't do a call to fetch the data
                        let row = {column:k, statistics:statistics, cache:{}};
                        let columnRow = {column:k, type:statistics.type, featureType:statistics.featureType, featureRole:statistics.featureRole};
                        row.isNumeric = statistics.type == 'numeric' || statistics.type == 'date';
                        row.isDate = statistics.type == 'date';
                        row.cache[k] = facet;
                        $scope.univariatesMap[k] = row;
                        $scope.columnList.push(columnRow)
                    });
                }
            };
            $scope.$watch('evaluatedDataStatistics.univariate', updateUnivariatesList, false);
        }
    };
});
})();
