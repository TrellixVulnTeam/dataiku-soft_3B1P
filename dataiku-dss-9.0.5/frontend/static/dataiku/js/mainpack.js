 /* Various controller fragments */
 function addDatasetUniquenessCheck($scope, DataikuAPI, projectKey) {
    DataikuAPI.datasets.listNames(projectKey).success(function(data) {
        $scope.datasets_names = data;
    });
    DataikuAPI.streamingEndpoints.listNames(projectKey).success(function(data) {
        $scope.streamingEndpoints_names = data;
    });

    let unicityCheck = function(value) {
        if ($scope.datasets_names) {
            for(var k in $scope.datasets_names) {
                var ds = $scope.datasets_names[k];
                if((ds||'').toLowerCase()===(value||'').toLowerCase()) {
                    return false;
                }
            }
        }
        if ($scope.streamingEndpoints_names) {
            for(var k in $scope.streamingEndpoints_names) {
                var ds = $scope.streamingEndpoints_names[k];
                if((ds||'').toLowerCase()===(value||'').toLowerCase()) {
                    return false;
                }
            }
        }
        return true;
    };
    $scope.isDatasetNameUnique = unicityCheck;
    $scope.isStreamingEndpointNameUnique = unicityCheck;
}

/* Mapping Code Mirror Editor Option Mode to language name */
function computeCodeMirrorMode(snippetType) {
	switch(snippetType) {
	    case 'jl':
	    case 'julia':
            return 'text/x-julia';
        case 'py':
	    case 'python':
            return 'text/x-python';
	    case 'pig':
	        return 'text/x-dkupig';
	    case 'R':
	        return 'text/x-rsrc';
	    case 'scala':
	    	return 'text/x-scala';
	    case 'shell':
	    	return 'text/x-sh';
	    case 'hive':
	    case 'impala':
	        return 'text/x-hivesql';
	    case 'sql':
	        return 'text/x-sql2';
	    case 'html':
	        return 'application/xml';
	    case 'css':
	        return 'text/css';
	    case 'javascript':
        case 'js':
	        return 'text/javascript';
	    default:
            return 'text/plain'
	}
}

function getDefaultConnection(list, cur, wantSQL, wantHDFS) {
    if (cur) return cur;
    if (list != null && list.length > 0) {
        if (wantSQL) {
            for (var i in list) {
                if (list[i].sql) return list[i].connection;
            }
        } else if (wantHDFS) {
            for (var i in list) {
                if (list[i].type == "HDFS") return list[i].connection;
            }
        } else {
            for (var i in list) {
                if (list[i].connection == "filesystem_managed") {
                    return list[i].connection;
                }
            }
        }
        return list[0].connection;
    } else {
        return null;
    }
}

function fetchManagedDatasetConnections($scope, DataikuAPI) {
    DataikuAPI.datasets.listManagedDatasetConnections().success(function(data) {
        $scope.managedDatasetConnections = [];
        for (var i in data) {
            var c = data[i];
            $scope.managedDatasetConnections.push({"connection" : c.name, "type" : c.type, "sql" : c.sql, "label" : c.name + " (" + c.type + ")"});
        }
    }).error(setErrorInScope.bind($scope));
}


function filterSortLimitTagsAndQ($filter, list, query, sortOptions, max, customFilter) {
    if (list == null) {
        return {formatted : [], filtered : []};
    }
    var filtered = list;
    // Filter on tags
    if (query.tags){
    angular.forEach(query.tags, function(tag){
        filtered = $.grep(filtered, function(item){
            return item.tags && item.tags.indexOf(tag) >= 0;
        })
    })
    }
    // Filter on terms
    filtered = angular.element(document.body).injector().get('ListFilter').filter(filtered, query.q);
    // Custom filters
    if (typeof(customFilter) === "function") {
    	filtered = customFilter(filtered);
    }
    // sort
    var formatted = $filter('orderBy')(filtered, sortOptions.column, sortOptions.reverse);
    // limit
    formatted = formatted.slice(0, max);
    return {formatted : formatted, filtered : filtered};
}


(function() {
'use strict';

const app = angular.module('dataiku', [
    'angular-blocks',
    'dataiku.controllers',
    'dataiku.services',
    'dataiku.logger',
    'dataiku.charts',

    'dataiku.common.func',
    'dataiku.common.nav',
    'dataiku.common.build',
    'dataiku.common.lists',
    'dataiku.common.pictures',
    'dataiku.common.sampling',

    'dataiku.services.help',

    'dataiku.shaker',
    'dataiku.shaker.analyse',
    'dataiku.shaker.table',
    'dataiku.shaker.misc',
    'dataiku.shaker.library',

    'dataiku.export.services',

    'dataiku.directives.bootstrap',
    'dataiku.directives.dip',
    'dataiku.directives.styling',
    'dataiku.directives.widgets',
    'dataiku.directives.forms',
    'dataiku.directives.snippetEditor',
    'dataiku.directives.scope',
    'dataiku.widgets.futures',
    'dataiku.widgets.integrations',
    'dataiku.widgets.drawers',
    'dataiku.widgets.tageditfield',

    'dataiku.filters',

    'dataiku.meanings',

    'dataiku.taggableobjects',

    'dataiku.notebooks.sql',
    'dataiku.rstudioserverembed',

    'dataiku.projects.settings',
    'dataiku.projects.actions',
    'dataiku.projects.directives',

    'dataiku.personal-home.directives',

    'dataiku.connections',

    'dataiku.datasets',
    'dataiku.datasets.status',
    'dataiku.datasets.custom',
    'dataiku.datasets.directives',
    'dataiku.datasets.foreign',
    'dataiku.datasets.partitioning',

    'dataiku.dashboards',
    'dataiku.dashboards.insights',

    'dataiku.webapps',
    'dataiku.report',

    'dataiku.metrics.core',
    'dataiku.metrics.views',
    'dataiku.metrics.savedmodels.views',
    'dataiku.metrics.edit',

    'dataiku.flow.graph',
    'dataiku.flow.tools',
    'dataiku.flow.project',
    'dataiku.flow.runtime',

    'dataiku.recipes',
    'dataiku.recipes.customcode',
    'dataiku.directives.insights',
    'dataiku.directives.simple_report',
    'dataiku.filters',


    'dataiku.admin',
    'dataiku.admin.codeenvs.common',
    'dataiku.admin.codeenvs.automation',
    'dataiku.admin.codeenvs.design',
    'dataiku.admin.security',
    'dataiku.admin.maintenance',
    'dataiku.admin.monitoring',
    'dataiku.admin.clusters',

    'dataiku.plugins',
    'dataiku.plugindev',
    'dataiku.folder_edit',
    'dataiku.catalog',
    'dataiku.deployer',
    'dataiku.apideployer',
    'dataiku.projectdeployer',

    /* ML (shared between analysis, saved model and insight) */
    'dataiku.ml.core',
    'dataiku.ml.predicted',
    'dataiku.ml.report',
    'dataiku.ml.explainability',
    'dataiku.ml.hyperparameters',

    'dataiku.analysis.core',
    'dataiku.analysis.script',
    'dataiku.analysis.mlcore',

    'dataiku.savedmodels',
    'dataiku.modelevaluationstores',

    'dataiku.managedfolder',

    /* Streaming endpoints */
    'dataiku.streaming-endpoints',

    'dataiku.scenarios',
    'dataiku.continuous-activities',
    'dataiku.monitoring',
    'dataiku.runnables',

    'dataiku.lambda',

    'dataiku.collab.timeline',
    'dataiku.collab.discussions',
    'dataiku.collab.wikis',
    'dataiku.git',

    'dataiku.bundles.common',
    'dataiku.bundles.design',
    'dataiku.bundles.automation',

    'dkuSanitize',

    'dataiku.integrations.alation',

    'dataiku.ngXmigration',

    /* 3rd party */
    'ngRoute',
    'ngSanitize',
    'ui.sortable',
    'ui.tree',
    'ui.router',
    'ui.codemirror',
    'ui.keypress',
    'infinite-scroll',
    'platypus.utils',
    'ui-rangeSlider',
    'pasvaz.bindonce',
    'colorContrast',
    'LocalStorageModule',
    'monospaced.elastic',
    'ngDragDrop',
    'checklist-model',
    '$strap'
]);


app.factory('dssInterceptor', function($location, $q, $rootScope) {
    return {
        'requestError': function(response) {
            const status = response.status;
            if (status == 401) {
                /*Don't redirect to login on failed login :D */
                if (response.config.url.indexOf("/api/login") >= 0) {
                    return $q.reject(response);
                }
                // It's not possible to inject $state here because of
                // Uncaught Error: Circular dependency: $templateFactory <- $state <- $http <- $compile
                // So we can't transition and have to refresh ...
                if ($location.path() !== '/login/') {
                    $rootScope.$evalAsync('appConfig.loggedIn = false');
                    $location.url("/login/?redirectTo=" + $location.path());
                } else {
                    return $q.reject(response);
                }
            } else {
                return $q.reject(response);
            }
        }
    };
});


app.config(function($stateProvider, $locationProvider, $urlRouterProvider, $httpProvider, $qProvider, $compileProvider) {

    $compileProvider.preAssignBindingsEnabled(true);
    $locationProvider.html5Mode(true);

    /* ************************* Top level routes ************************ */

    $stateProvider.state('root', {
        url: '/',
        params: {
            showSearchInNav: true
        },
        templateUrl: '/templates/personal-home.html',
        controller: 'PersonalHomeController',
        pageTitle: function(stateParams) {
            return "Home";
        }
    });
    $stateProvider.state('profile.ngx', {
        url: '/ngx-hello',
        template: '<ng2-downgrade-example></ng2-downgrade-example>'
    });
    $stateProvider.state('home', {
        url: '/home/',
        params: {
            showSearchInNav: true
        },
        templateUrl: '/templates/personal-home.html',
        controller: 'PersonalHomeController',
        pageTitle: function(stateParams) {
            return "Home";
        }
    });

    $stateProvider.state('wikis', {
        url: '/wikis/',
        params: {
            filterBy: undefined,
            standalone: true,
            row: 'wikis'
        },
        templateUrl: '/templates/personal-home.html',
        controller: 'PersonalHomeController',
        pageTitle: function(stateParams) {
            return "Wikis";
        }
    });

    $stateProvider.state('wikis.list', {
        url: 'list/',
        params: {
            filterBy: undefined,
            standalone: true,
            row: 'wikis'
        },
        templateUrl: '/templates/personal-home.html',
        controller: 'PersonalHomeController',
        pageTitle: function(stateParams) {
            return "Wikis";
        }
    });

    $stateProvider.state('home.expandedlist', {
        url: ':row/expandedlist',
        params: {
            filterBy: undefined
        },
        templateUrl: '/templates/personal-home.html',
        controller: 'PersonalHomeController',
        pageTitle: function(stateParams) {
            return "Home expanded";
        }
    });

    $stateProvider.state('home.expandedmosaic', {
        url: ':row/expandedmosaic',
        params: {
            filterBy: undefined,
            standalone: undefined
        },
        templateUrl: '/templates/personal-home.html',
        controller: 'PersonalHomeController',
        pageTitle: function(stateParams) {
            return "Home expanded mosaic";
        }
    });

    $stateProvider.state('project-list', {
        url: '/project-list/:folderId',
        controller: 'ProjectsListController',
        templateUrl: '/templates/projects-list/projects-list.html',
        pageTitle: function(stateParams) {
            return "Projects";
        }
    });

    $stateProvider.state('login', {
        url: '/login/?redirectTo',
        templateUrl: '/templates/login.html',
        controller: 'LoginController',
        pageTitle: function(stateParams) {
            return "Login";
        }
    });

    $stateProvider.state('logged-out', {
        url: '/logged-out',
        templateUrl: '/templates/logged-out.html',
        pageTitle: function(stateParams) {
            return "Logged out";
        }
    });

    $stateProvider.state('feedback', {
        url: '/feedback/',
        templateUrl: '/templates/feedback.html'
    });

    $stateProvider.state("blackhole", {
        url: "/blackhole/"
    });

    $stateProvider.state('projects', {
        url: '/projects',
        abstract: true,
        template: '<div ui-view class="h100"></div>'
    });

    $stateProvider.state('jambon', {
        url: '/admin/jambon/',
        templateUrl: '/templates/widgets/image-uploader-dialog.html'
    });


    /* ************************** Project Apps ********************** */

    $stateProvider.state('apps', {
        url: '/apps',
        abstract: true,
        template: "<div ui-view></div>"
    });

    $stateProvider.state('apps.list', {
        url: '/',
        controller: 'AppsListController',
        templateUrl: '/templates/apps/apps-list.html',
        pageTitle: function(stateParams) {
            return "Applications";
        }
    });

    $stateProvider.state('apps.app', {
        url: '/:appId',
        controller: 'AppPageController',
        templateUrl: '/templates/apps/app-page.html',
        pageTitle: function(stateParams) {
            return "App";
        }
    });

    // TODO: Maybe /profile isn't the best place for this?
    $stateProvider.state('oauth2', {
        url: '/profile/oauth2-response/?userState&success&message',
        controller: 'OAuth2ResponseController'
    });

    /* ************************** Project ********************** */

    $stateProvider.state('projects.project', {
        url: '/:projectKey',
        abstract: true,
        controller: 'ProjectBaseController',
        templateUrl: '/templates/projects/project.html'
    });

    $stateProvider.state('projects.project.home', {
        abstract: true,
        url: '',
        templateUrl: '/templates/projects/home/index.html',
        controller: 'ProjectHomeTabController',
    });

    $stateProvider.state('projects.project.home.regular', {
        url: '/?discussionId&testInstance',
        templateUrl: '/templates/projects/home/project-home.html',
        controller: 'ProjectHomeController',
        pageTitle: function(stateParams) {
            return "Summary";
        }
    });

    $stateProvider.state('projects.project.home.activity', {
        url: '/activity/',
        templateUrl: '/templates/projects/home/activity.html',
        controller: 'ProjectHomeController',
        pageTitle: function(stateParams) {
            return "Summary";
        }
    });

    $stateProvider.state('projects.project.home.status', {
        url: '/status',
        abstract: true,
        templateUrl: '/templates/projects/home/status.html',
        controller: 'ProjectMetricsController',
        pageTitle: function(stateParams) {
            return " Summary";
        }
    });

    $stateProvider.state('projects.project.home.status.settings', {
        url: '/settings',
        templateUrl: '/templates/projects/home/status-settings.html'
    });

    $stateProvider.state('projects.project.home.status.metrics', {
        url: '',
        templateUrl: '/templates/projects/home/status-metrics.html'
    });

    $stateProvider.state('projects.project.home.status.checks', {
        url: '/checks',
        templateUrl: '/templates/projects/home/status-checks.html'
    });

    /* Temporary redirect state */

    $stateProvider.state('projects.project.settings.tmp', {
        url: '/',
        controller: 'ProjectSettingsTmpController',
    });

    $stateProvider.state('projects.project.variables', {
        url: '/variables/',
        templateUrl: '/templates/projects/variables/variables.html'
    });

    $stateProvider.state('projects.project.appdesigner', {
        url: '/app-designer/',
        templateUrl: '/templates/apps/app-designer.html',
        controller: "AppDesignerController",
        pageTitle: function(stateParams) {
            return "Application designer";
        }
    });

    $stateProvider.state('projects.project.statisticsWorksheet', {
        url: '/statistics/worksheet/:worksheetId',
        template: '<ng2-eda-worksheet-redirection-page></ng2-eda-worksheet-redirection-page>'
    });

    $stateProvider.state('projects.project.settings', {
        url: '/settings/:selectedTab',
        templateUrl: '/templates/projects/settings/settings.html'
    });

    $stateProvider.state('projects.project.integrations', {
        url: '/settings/integrations',
        templateUrl: '/templates/projects/integrations/messaging-like-selection.html'
    });

    $stateProvider.state('projects.project.security', {
        url: '/security/:selectedTab',
        templateUrl: '/templates/projects/security/security.html'
    });

    $stateProvider.state("projects.project.libedition", {
        url: '/libedition',
        templateUrl: '/templates/plugins/development/lib-edition-project.html',
        controller: 'ProjectFolderEditionController',
        pageTitle: function(stateParams) {
            return "Library Editor";
        }
    });

    $stateProvider.state('projects.project.libedition.libpython', {
        url: '/libpython',
        redirectTo: 'projects.project.libedition'
    });

    $stateProvider.state('projects.project.libedition.localstatic', {
        url: '/localstatic',
        redirectTo: 'projects.project.libedition'
    });

    $stateProvider.state('projects.project.flow', {
        url: '/flow/?id&?zoneId',
        templateUrl: '/templates/flow-editor/flow-editor.html',
        pageTitle: function(stateParams) {
            return "Flow";
        }
    });

    $stateProvider.state('projects.project.version-control', {
        url: '/version-control/',
        templateUrl: '/templates/projects/git/project-git.html',
        controller: "ProjectVersionControlController",
        pageTitle: function(stateParams) {
            return "Version control";
        }
    });


    /* ************************** Dataset ********************** */

    $stateProvider.state('projects.project.datasets', {
        url: '/datasets',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.datasets.list', {
        url: '/',
        templateUrl: '/templates/datasets/list.html',
        controller: 'DatasetsListController',
        pageTitle: function(stateParams) {
            return "Datasets";
        }
    });

    $stateProvider.state('projects.project.datasets.dataset', {
        url: '/:datasetName?discussionId',
        abstract: true,
        controller: 'DatasetCommonController',
        templateUrl: '/templates/datasets/dataset.html'
    });

    $stateProvider.state('projects.project.datasets.dataset.summary', {
        url: '/summary/',
        templateUrl: '/templates/datasets/summary.html',
        controller: 'DatasetSummaryController',
        pageTitle: function(stateParams) {
            return stateParams.datasetName + " - Summary";
        }
    });

    $stateProvider.state('projects.project.datasets.dataset.settings', {
        url: '/settings/',
        templateUrl: '/templates/datasets/settings.html',
        controller: 'DatasetSettingsController',
        pageTitle: function(stateParams) {
            return stateParams.datasetName + " - Settings";
        }
    });

    $stateProvider.state('projects.project.datasets.dataset.history', {
        url: '/history/',
        templateUrl: '/templates/datasets/history.html',
        controller: 'DatasetHistoryController',
        pageTitle: function(stateParams) {
            return stateParams.datasetName + " - History";
        }
    });

    $stateProvider.state('projects.project.datasets.dataset.statistics', {
        url: '/statistics',
        template: `<ng2-eda
            dataset-name="{{$state.params.datasetName}}"
            project-key="{{$state.params.projectKey}}"
            worksheet-id="{{$state.params.worksheetId}}"></ng2-eda>`,
        controller: 'DatasetStatisticsController',
        reloadOnSearch: false,
        pageTitle: function(stateParams) {
            return stateParams.datasetName + " - Statistics";
        }
    });

    $stateProvider.state('projects.project.datasets.dataset.statistics.worksheet', {
        url: '/worksheet/:worksheetId',
        reloadOnSearch: false,
        pageTitle: function(stateParams) {
            return stateParams.datasetName + " - Statistics";
        }
    });

    $stateProvider.state('projects.project.datasets.dataset.edit', {
        url: '/edit/',
        templateUrl: '/templates/datasets/edit-dataset.html',
        controller: 'DatasetEditController',
        pageTitle: function(stateParams) {
            return stateParams.datasetName + " - Edit";
        }
    });

    $stateProvider.state('projects.project.datasets.dataset.explore', {
        url: '/explore/',
        templateUrl: '/templates/datasets/explore.html',
        pageTitle: function(stateParams) {
            return stateParams.datasetName + " - Explore";
        }
    });

    $stateProvider.state('projects.project.datasets.dataset.status', {
        url: '/status',
        abstract: true,
        templateUrl: '/templates/datasets/status.html',
        controller: 'DatasetStatusController',
        pageTitle: function(stateParams) {
            return stateParams.datasetName + " - Status";
        }
    });

    $stateProvider.state('projects.project.datasets.dataset.status.settings', {
        url: '/settings/:selectedTab',
        templateUrl: '/templates/datasets/status-settings.html'
    });

    $stateProvider.state('projects.project.datasets.dataset.status.metrics', {
        url: '',
        templateUrl: '/templates/datasets/status-metrics.html'
    });

    $stateProvider.state('projects.project.datasets.dataset.status.checks', {
        url: '/checks',
        templateUrl: '/templates/datasets/status-checks.html'
    });

    $stateProvider.state('projects.project.datasets.dataset.visualize', {
        url: '/visualize/?chartIdx',
        templateUrl: '/templates/datasets/visualize.html',
        pageTitle: function(stateParams) {
            return stateParams.datasetName + " - Visualize";
        }
    });

    $stateProvider.state('projects.project.datasets.new_with_type', {
        url: '/new/:type?fromOdbSmartId?fromOdbItemPath?fromOdbItemDirectory?zoneId',
        abstract: true,
        templateUrl: '/templates/datasets/dataset.html',
        controller: 'DatasetNewController',
    });

    $stateProvider.state('projects.project.datasets.new_with_type.settings', {
        url: '/?prefillParams',
        templateUrl: '/templates/datasets/new-settings.html',
        controller: 'DatasetSettingsController',
        pageTitle: function(stateParams) {
            return "New " + stateParams.type + " dataset";
        }
    });

    /* ************************** Foreign view of datasets ********************** */

    $stateProvider.state('projects.project.foreigndatasets', {
        url: '/foreigndatasets',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.foreigndatasets.dataset', {
        url: '/:datasetFullName',
        abstract: true,
        controller: 'ForeignDatasetCommonController',
        templateUrl: '/templates/foreigndatasets/dataset.html'
    });

    $stateProvider.state('projects.project.foreigndatasets.dataset.explore', {
        url: '/explore/',
        templateUrl: '/templates/foreigndatasets/explore.html',
        pageTitle: function(stateParams) {
            return stateParams.datasetFullName + " - Explore";
        }
    });

    $stateProvider.state('projects.project.foreigndatasets.dataset.visualize', {
        url: '/visualize/?insightId',
        templateUrl: '/templates/foreigndatasets/visualize.html',
        pageTitle: function(stateParams) {
            return stateParams.datasetFullName + " - Visualize";
        }
    });

    $stateProvider.state('projects.project.foreigndatasets.dataset.statistics', {
        url: '/statistics',
        template: `<ng2-eda
            dataset-name="{{$state.params.datasetFullName}}"
            project-key="{{$state.params.projectKey}}"
            worksheet-id="{{$state.params.worksheetId}}"></ng2-eda>`,
        controller: 'DatasetStatisticsController',
        reloadOnSearch: false,
        pageTitle: function(stateParams) {
            return stateParams.datasetName + " - Statistics";
        }
    });

    $stateProvider.state('projects.project.foreigndatasets.dataset.statistics.worksheet', {
        url: '/worksheet/:worksheetId',
        reloadOnSearch: false,
        pageTitle: function(stateParams) {
            return stateParams.datasetName + " - Statistics";
        }
    });

    $stateProvider.state('projects.project.foreigndatasets.dataset.edit', {
        url: '/edit/',
        templateUrl: '/templates/datasets/edit-dataset.html',
        controller: 'DatasetEditController',
        pageTitle: function(stateParams) {
            return stateParams.datasetName + " - Edit";
        }
    });

    /* ************************** Streaming enpdoints ********************** */

    $stateProvider.state('projects.project.streaming-endpoints', {
        url: '/streaming-endpoints',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.streaming-endpoints.list', {
        url: '/',
        templateUrl: '/templates/streaming-endpoints/list.html',
        controller: 'StreamingEndpointsListController',
        pageTitle: function(stateParams) {
            return "Streaming endpoints";
        }
    });

    $stateProvider.state('projects.project.streaming-endpoints.streaming-endpoint', {
        url: '/:streamingEndpointId?discussionId',
        abstract: true,
        controller: 'StreamingEndpointPageController',
        templateUrl: '/templates/streaming-endpoints/streaming-endpoint.html'
    });

    $stateProvider.state('projects.project.streaming-endpoints.streaming-endpoint.settings', {
        url: '/settings/',
        templateUrl: '/templates/streaming-endpoints/settings.html',
        controller: 'StreamingEndpointSettingsController',
        pageTitle: function(stateParams) {
            return stateParams.streamingEndpointId + " - Settings";
        }
    });
    
    $stateProvider.state('projects.project.streaming-endpoints.streaming-endpoint.history', {
        url: '/history/',
        templateUrl: '/templates/streaming-endpoints/history.html',
        controller: 'StreamingEndpointHistoryController',
        pageTitle: function(stateParams) {
            return stateParams.streamingEndpointId + " - History";
        }
    });

    $stateProvider.state('projects.project.streaming-endpoints.streaming-endpoint.explore', {
        url: '/explore/',
        templateUrl: '/templates/streaming-endpoints/explore.html',
        controller: 'StreamingEndpointExploreController',
        pageTitle: function(stateParams) {
            return stateParams.streamingEndpointId + " - Explore";
        }
    });

    /* ************************** Analysis ********************** */

    $stateProvider.state('projects.project.analyses', {
        url: '/analysis',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.analyses.list', {
        url: '/?datasetId',
        templateUrl: '/templates/analysis/list.html',
        controller: "AnalysesListController",
        pageTitle: function(stateParams) {
            return " Analyses";
        }
    });

    $stateProvider.state('projects.project.analyses.analysis', {
        url: '/:analysisId?discussionId',
        abstract: true,
        templateUrl: '/templates/analysis/analysis.html',
        controller: "AnalysisCoreController",
        pageTitle: function(stateParams) {
            return " Analysis";
        }
    });

    $stateProvider.state('projects.project.analyses.analysis.summary', {
        url: '/',
        templateUrl: '/templates/analysis/summary.html',
        controller: "AnalysisSummaryController"
    });

    $stateProvider.state('projects.project.analyses.analysis.script', {
        url: '/script/',
        templateUrl: '/templates/analysis/script.html',
    });

    $stateProvider.state('projects.project.analyses.analysis.charts', {
        url: '/charts/?chartIdx',
        templateUrl: '/templates/analysis/charts.html',
    });

    $stateProvider.state('projects.project.analyses.analysis.ml', {
        url: '/ml',
        abstract: true,
        template: '<div ui-view></div>'
    });
    // You never stay on this state except if no mltask
    $stateProvider.state('projects.project.analyses.analysis.ml.list', {
        url: '/',
        templateUrl: '/templates/analysis/mltasks.html',
        controller: "AnalysisMLTasksController"
    });

    /* ******************** Analysis/ML/Prediction **************** */

    $stateProvider.state('projects.project.analyses.analysis.ml.predmltask', {
        url: '/p/:mlTaskId',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.analyses.analysis.ml.predmltask.list', {
        url: '/list',
        abstract: true,
        templateUrl: '/templates/analysis/models.html',
        controller: 'PMLTaskBaseController'
    });

    $stateProvider.state('projects.project.analyses.analysis.ml.predmltask.list.design', {
        url: '/design',
        templateUrl: '/templates/analysis/prediction/models-design.html',
        controller: 'PMLTaskDesignController'
    });

    $stateProvider.state('projects.project.analyses.analysis.ml.predmltask.list.results', {
        url: '/results',
        templateUrl: '/templates/analysis/mlcommon/models-results.html',
        controller: 'PMLTaskResultController'
    });

    $stateProvider.state('projects.project.analyses.analysis.ml.predmltask.model', {
        url: '/:fullModelId',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.analyses.analysis.ml.predmltask.model.predictedtable', {
        url: '/table/',
        templateUrl: '/templates/analysis/prediction/model/model-predicted-table.html'
    });

    $stateProvider.state('projects.project.analyses.analysis.ml.predmltask.model.predictedcharts', {
        url: '/charts/',
        templateUrl: '/templates/analysis/prediction/model/model-predicted-charts.html'
    });

    $stateProvider.state('projects.project.analyses.analysis.ml.predmltask.model.report', {
        url: '/report/?exportMode',
        templateUrl: '/templates/analysis/prediction/model/model-report.html'
    });

    /* ******************** Analysis/ML/Clustering **************** */

    $stateProvider.state('projects.project.analyses.analysis.ml.clustmltask', {
        url: '/c/:mlTaskId',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.analyses.analysis.ml.clustmltask.list', {
        url: '/list',
        abstract: true,
        templateUrl: '/templates/analysis/models.html',
        controller: 'CMLTaskBaseController'
    });

    $stateProvider.state('projects.project.analyses.analysis.ml.clustmltask.list.design', {
        url: '/design',
        templateUrl: '/templates/analysis/clustering/models-design.html',
        controller: 'CMLTaskDesignController'
    });

    $stateProvider.state('projects.project.analyses.analysis.ml.clustmltask.list.results', {
        url: '/results',
        templateUrl: '/templates/analysis/mlcommon/models-results.html',
        controller: 'CMLTaskResultController'
    });

    $stateProvider.state('projects.project.analyses.analysis.ml.clustmltask.model', {
        url: '/:fullModelId',
        abstract: true,
        template: '<div ui-view></div>'
    });
    $stateProvider.state('projects.project.analyses.analysis.ml.clustmltask.model.predictedtable', {
        url: '/table/',
        templateUrl: '/templates/analysis/clustering/model/c-model-predicted-table.html'
    });

    $stateProvider.state('projects.project.analyses.analysis.ml.clustmltask.model.predictedcharts', {
        url: '/charts/',
        templateUrl: '/templates/analysis/clustering/model/c-model-predicted-charts.html'
    });

    $stateProvider.state('projects.project.analyses.analysis.ml.clustmltask.model.report', {
        url: '/report/',
        templateUrl: '/templates/analysis/clustering/model/c-model-report.html'
    });

    /* ************************** Saved Model (Flow) ********************** */

    $stateProvider.state('projects.project.savedmodels', {
        url: '/savedmodels',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.savedmodels.savedmodel', {
        url: '/:smId?discussionId',
        abstract: true,
        controller: "SavedModelController",
        templateUrl: '/templates/savedmodels/savedmodel.html'
    });

    $stateProvider.state('projects.project.savedmodels.savedmodel.summary', {
        url: '/summary/',
        controller: "SavedModelSummaryController",
        templateUrl: '/templates/savedmodels/summary.html'
    });

    $stateProvider.state('projects.project.savedmodels.savedmodel.settings', {
        url: '/settings/',
        controller: "SavedModelSettingsController",
        templateUrl: '/templates/savedmodels/settings.html'
    });

    $stateProvider.state('projects.project.savedmodels.savedmodel.status', {
        url: '/status',
        templateUrl: '/templates/savedmodels/status.html'
    });

    $stateProvider.state('projects.project.savedmodels.savedmodel.status.metrics', {
        url: '/metrics/',
        templateUrl: '/templates/savedmodels/status-metrics.html'
    });

    $stateProvider.state('projects.project.savedmodels.savedmodel.status.checks', {
        url: '/checks/',
        templateUrl: '/templates/savedmodels/status-checks.html'
    });

    $stateProvider.state('projects.project.savedmodels.savedmodel.versions', {
        url: '/versions/',
        controller: "SavedModelVersionsController",
        templateUrl: '/templates/savedmodels/versions.html'
    });

    $stateProvider.state('projects.project.savedmodels.savedmodel.prediction', {
        url: '/p',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.savedmodels.savedmodel.prediction.report', {
        url: '/:fullModelId/?exportMode',
        templateUrl: '/templates/savedmodels/prediction-report.html'
    });

    $stateProvider.state('projects.project.savedmodels.savedmodel.clustering', {
        url: '/c',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.savedmodels.savedmodel.clustering.report', {
        url: '/:fullModelId/',
        templateUrl: '/templates/savedmodels/clustering-report.html'
    });

    /* **************************  Model Evaluation Store (Flow) ********************** */

    $stateProvider.state('projects.project.modelevaluationstores', {
        url: '/modelevaluationstores',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.modelevaluationstores.modelevaluationstore', {
        url: '/:mesId?discussionId',
        abstract: true,
        controller: "ModelEvaluationStoreController",
        templateUrl: '/templates/modelevaluationstores/modelevaluationstore.html'
    });

    $stateProvider.state('projects.project.modelevaluationstores.modelevaluationstore.evaluations', {
        url: '/evaluations',
        controller: "ModelEvaluationStoreEvaluationsController",
        templateUrl: '/templates/modelevaluationstores/evaluations.html'
    });

    $stateProvider.state('projects.project.modelevaluationstores.modelevaluationstore.perfdrift', {
        url: '/perfdrift',
        controller: "ModelEvaluationStorePerfDriftController",
        templateUrl: '/templates/modelevaluationstores/perfdrift.html'
    });

    $stateProvider.state('projects.project.modelevaluationstores.modelevaluationstore.evaluation', {
        url: '/evaluations/:runId',
        abstract: true,
        controller: "ModelEvaluationStoreEvaluationController",
        templateUrl: '/templates/modelevaluationstores/evaluation.html'
    });

    $stateProvider.state('projects.project.modelevaluationstores.modelevaluationstore.evaluation.report', {
        url: '/report',
        templateUrl: '/templates/modelevaluationstores/evaluation-report.html'
    });

    $stateProvider.state('projects.project.modelevaluationstores.modelevaluationstore.evaluation.statistics', {
        url: '/statistics',
        templateUrl: '/templates/modelevaluationstores/evaluation-statistics.html'
    });

    $stateProvider.state('projects.project.modelevaluationstores.modelevaluationstore.summary', {
        url: '/summary/',
        controller: "ModelEvaluationStoreSummaryController",
        templateUrl: '/templates/modelevaluationstores/summary.html'
    });

    $stateProvider.state('projects.project.modelevaluationstores.modelevaluationstore.settings', {
        url: '/settings/',
        controller: "ModelEvaluationStoreSettingsController",
        templateUrl: '/templates/modelevaluationstores/settings.html'
    });

    /* ************************** Managed folder (Flow) ********************** */

    $stateProvider.state('projects.project.managedfolders', {
        url: '/managedfolder',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.managedfolders.managedfolder', {
        url: '/:odbId?discussionId',
        abstract: true,
        controller: "ManagedFolderBaseController",
        templateUrl: '/templates/managedfolder/managedfolder.html'
    });

    $stateProvider.state('projects.project.managedfolders.managedfolder.summary', {
        url: '/summary/',
        controller: "ManagedFolderSummaryController",
        templateUrl: '/templates/managedfolder/summary.html',
        pageTitle: function(stateParams) {
            return " Folder";
        }
    });

    $stateProvider.state('projects.project.managedfolders.managedfolder.view', {
        url: '/view/',
        controller: "ManagedFolderViewController",
        templateUrl: '/templates/managedfolder/view.html',
        pageTitle: function(stateParams) {
            return " Folder";
        }
    });

    $stateProvider.state('projects.project.managedfolders.managedfolder.settings', {
        url: '/settings/',
        controller: "ManagedFolderSettingsController",
        templateUrl: '/templates/managedfolder/settings.html',
        pageTitle: function(stateParams) {
            return " Folder";
        }
    });

    $stateProvider.state('projects.project.managedfolders.managedfolder.status', {
        url: '/status',
        abstract: true,
        templateUrl: '/templates/managedfolder/status.html',
        controller: 'ManagedFolderStatusController',
        pageTitle: function(stateParams) {
            return " Folder";
        }
    });

    $stateProvider.state('projects.project.managedfolders.managedfolder.status.settings', {
        url: '/settings',
        templateUrl: '/templates/managedfolder/status-settings.html'
    });

    $stateProvider.state('projects.project.managedfolders.managedfolder.status.metrics', {
        url: '',
        templateUrl: '/templates/managedfolder/status-metrics.html'
    });

    $stateProvider.state('projects.project.managedfolders.managedfolder.status.checks', {
        url: '/checks',
        templateUrl: '/templates/managedfolder/status-checks.html'
    });

    /* ************************** Foreign view of managed folders ********************** */

    $stateProvider.state('projects.project.foreignmanagedfolders', {
        url: '/foreignmanagedfolder',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.foreignmanagedfolders.managedfolder', {
            url: '/:odbId?discussionId?sourceProjectKey',
            abstract: true,
            controller: "ManagedFolderBaseController",
            templateUrl: '/templates/foreignmanagedfolder/managedfolder.html'
        });

    $stateProvider.state('projects.project.foreignmanagedfolders.managedfolder.view', {
            url: '/view/',
            controller: "ManagedFolderViewController",
            templateUrl: '/templates/managedfolder/view.html',
            pageTitle: function(stateParams) {
                return " Folder";
            }
        });

    /* ************************** Recipes ********************** */

    $stateProvider.state('projects.project.recipes', {
        url: '/recipes',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.recipes.list', {
        url: '/',
        templateUrl: '/templates/recipes/list.html',
        controller: 'RecipesListController',
        pageTitle: function(stateParams) {
            return "Recipes";
        }
    });

    $stateProvider.state('projects.project.recipes.new', {
        url: '/new/:type/?prefill&input&output',
        templateUrl: '/templates/recipes/recipe-editor.html',
        controller: 'RecipeEditorController',
        pageTitle: function(stateParams) {
            return "New " + stateParams.type + " recipe";
        }
    });

    $stateProvider.state('projects.project.recipes.recipe', {
        url: '/:recipeName/?newlyCreated?discussionId',
        templateUrl: '/templates/recipes/recipe-editor.html',
        controller: 'RecipeEditorController',
        pageTitle: function(stateParams) {
            return stateParams.recipeName + " - Recipe";
        }
    });

    $stateProvider.state('projects.project.recipes.recipesummary', {
        url: '/:recipeName/summary?newlyCreated',
        templateUrl: '/templates/recipes/recipe-editor.html',
        controller: 'RecipeEditorController',
        pageTitle: function(stateParams) {
            return stateParams.recipeName + " - Recipe";
        },
        data : {
            tab: 'summary'
        }
    });

    /* ************************** Flow jobs / monitoring  ********************** */

    $stateProvider.state('projects.project.jobs', {
        url: '/jobs',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.jobs.list', {
        url: '/',
        templateUrl: '/templates/jobs/list.html',
        controller: 'FlowJobsBrowserController',
        pageTitle: function(stateParams) {
            return "Jobs";
        }
    });

    $stateProvider.state('projects.project.jobs.job', {
        url: '/:jobId/?hideFlow',
        templateUrl: '/templates/jobs/job-status.html',
        pageTitle: function(stateParams) {
            return "Job " + stateParams.jobId + "";
        }
    });

    $stateProvider.state('projects.project.datasets.new', {
        url: '/new/?zoneId',
        templateUrl: '/templates/datasets/new-dataset.html',
        controller: function($scope, CreateModalFromTemplate, TopNav, GlobalProjectActions) {
            TopNav.setItem(null);
            TopNav.setLocation(TopNav.TOP_FLOW, "new-dataset", TopNav.TABS_NONE, null);
            $scope.newManagedDataset = function() {
                CreateModalFromTemplate("/templates/flow-editor/new-managed-dataset.html",
                    $scope, "NewManagedDatasetController");
            };

            GlobalProjectActions.getAllDatasetsByTiles($scope).then(val => $scope.datasetTiles = val);

            // similar to what's done for the new dataset menu. Instead of a submenu, we show a tile
            const pluginSections = {};
            // get connectors, grouped by ownerPluginId
            $scope.appConfig.customDatasets.forEach(function(x) {
                let pluginSection = pluginSections[x.ownerPluginId];
                if (pluginSection == null) {
                    pluginSection = {
                        pluginId: x.ownerPluginId,
                        items: []
                    };
                    pluginSections[x.ownerPluginId] = pluginSection;
                }

                pluginSection.items.push({
                    type: x.datasetType,
                    label: x.desc.meta != null && x.desc.meta.label != null ? x.desc.meta.label : x.ownerPluginId,
                    icon: x.desc.meta != null ? x.desc.meta.icon : null
                });
            });
            // get fs providers, grouped by ownerPluginId
            $scope.appConfig.customFSProviders.forEach(function(x) {
                let pluginSection = pluginSections[x.ownerPluginId];
                if (pluginSection == null) {
                    pluginSection = {
                        pluginId: x.ownerPluginId,
                        items: []
                    };
                    pluginSections[x.ownerPluginId] = pluginSection;
                }

                pluginSection.items.push({
                    type: x.fsProviderType,
                    label: x.desc.meta != null && x.desc.meta.label != null ? x.desc.meta.label : x.ownerPluginId,
                    icon: x.desc.meta != null ? x.desc.meta.icon : null
                });
            });
            // fetch plugin label for each ownerPluginId
            $scope.customConnectorPlugins = [];
            $.each(pluginSections, function(pluginId, pluginData) {
                const plugin = Array.dkuFindFn($scope.appConfig.loadedPlugins, function(n) {
                    return n.id == pluginData.pluginId
                });
                if (plugin == null) {
                    return;
                }
                pluginData.items.forEach(function(dtype) {
                    if (!dtype.icon) dtype.icon = plugin.icon;
                });
                $scope.customConnectorPlugins.push({
                    isSection: true,
                    id: "plugin_" + plugin.id,
                    icon: plugin.icon,
                    label: plugin.label || plugin.id,
                    connectors: pluginData.items,
                    plugin: plugin
                });
            });
        },
        pageTitle: function(stateParams) {
            return "New dataset";
        }
    });

    /* ************************** Notebooks (SQL and jupyter) ********************** */

    $stateProvider.state('projects.project.notebooks', {
        url: '/notebooks',
        abstract: true,
        template: '<div ui-view class="h100"></div>'
    });

    $stateProvider.state('projects.project.notebooks.list', {
        url: '/?datasetId',
        templateUrl: '/templates/notebooks/list.html',
        controller: 'NotebooksController',
        pageTitle: function(stateParams) {
            return "Notebooks";
        }
    });

    $stateProvider.state('projects.project.notebooks.jupyter_notebook', {
        url: '/jupyter/:notebookId/?discussionId&kernel_name',
        templateUrl: '/templates/notebooks/jupyter_notebook.html',
        controller: 'IPythonController',
        pageTitle: function(stateParams) {
            return stateParams.notebookId + " | Jupyter notebook";
        }
    });

    $stateProvider.state('projects.project.notebooks.jupyter_notebook_copied', {
        url: '/jupyter/:notebookId/copy/',
        templateUrl: '/templates/notebooks/jupyter_notebook.html',
        controller: function($scope, $stateParams, $sce) {
            $scope.$stateParams = $stateParams;
            $scope.notebookURL = $sce.getTrustedResourceUrl("/jupyter/notebooks/" + $stateParams.projectKey + "/" + $stateParams.notebookId + '/copy');
        },
        pageTitle: function(stateParams) {
            return "Jupyter notebook";
        }
    });

    $stateProvider.state('projects.project.notebooks.sql_notebook', {
        url: '/sql/:notebookId/?discussionId',
        templateUrl: '/templates/notebooks/sql_notebook.html',
        controller: 'SQLNotebookController',
        // The user-friendly name is not in the stateParams, so the controller overrides the title
        pageTitle: function(stateParams) {
            return "SQL notebook";
        }
    });

    /* ************************** RStudio Server ********************** */

    $stateProvider.state('projects.project.rstudioserver', {
        url: '/rstudio-server',
        abstract: true,
        template: "<div ui-view></div>"
    });

    $stateProvider.state('projects.project.rstudioserver.embed', {
        url: '/',
        templateUrl: '/templates/rstudio-server/embed.html',
        controller: "RStudioServerEmbedController",
        pageTitle : function(stateParams) {
            return "RStudio Server"
        }
    });

    /* ***************** Webapps ********************** */

    $stateProvider.state('projects.project.webapps', {
        url : "/webapps",
        abstract : true,
        template : "<div ui-view></div>"
    });

    $stateProvider.state('projects.project.webapps.list', {
        url : "/",
        templateUrl: '/templates/webapps/list.html',
        controller: 'WebAppsListController',
        pageTitle : function(stateParams) {
            return "Webapps";
        }
    });

    $stateProvider.state('projects.project.webapps.webapp', {
        url : "/{webAppId}_{webAppName}?discussionId",
        templateUrl: '/templates/webapps/webapp.html',
        controller: 'WebAppCoreController',
        abstract: true
    });

    $stateProvider.state('projects.project.webapps.webapp.edit', {
        url : "/edit?{safe-mode}",
        templateUrl: '/templates/webapps/edit.html',
        pageTitle : function(stateParams) {
            return "Webapp";
        }
    });

    $stateProvider.state('projects.project.webapps.webapp.view', {
        url : "/view",
        templateUrl: '/templates/webapps/view.html',
        pageTitle : function(stateParams) {
            return "Webapp";
        }
    });

    $stateProvider.state('projects.project.webapps.webapp.summary', {
        url : "/summary",
        templateUrl: '/templates/webapps/summary.html',
        controller : "WebAppSummaryController",
        pageTitle : function(stateParams) {
            return "Webapp";
        }
    });

    $stateProvider.state('projects.project.webapps.webapp.history', {
        url : "/history",
        templateUrl: '/templates/webapps/history.html',
        controller : "WebAppHistoryController",
        pageTitle : function(stateParams) {
            return "Webapp";
        }
    });

    $stateProvider.state('projects.project.webapps.webapp.logs', {
        url : "/logs",
        templateUrl: '/templates/webapps/logs.html',
        pageTitle : function(stateParams) {
            return "Webapp";
        }
    });

    /* ***************** Reports ********************** */

    $stateProvider.state('projects.project.reports', {
        url : "/report",
        abstract : true,
        template : "<div ui-view></div>"
    });

    $stateProvider.state('projects.project.reports.list', {
        url : "/",
        templateUrl: '/templates/code-reports/list.html',
        controller: 'ReportsListController',
        pageTitle : function(stateParams) {
            return "Report";
        }
    });

    $stateProvider.state('projects.project.reports.report', {
        url : "/{reportId}?discussionId",
        templateUrl: '/templates/code-reports/report.html',
        controller: 'ReportCoreController',
        abstract: true
    });

    $stateProvider.state('projects.project.reports.report.edit', {
        url : "/edit",
        templateUrl: '/templates/code-reports/edit.html',
        controller: 'ReportEditController',
        pageTitle : function(stateParams) {
            return "Report";
        }
    });

    $stateProvider.state('projects.project.reports.report.view', {
        url : "/view",
        templateUrl: '/templates/code-reports/view.html',
        controller: 'ReportViewController',
        pageTitle : function(stateParams) {
            return "Report";
        }
    });

    $stateProvider.state('projects.project.reports.report.summary', {
        url : "/summary",
        templateUrl: '/templates/code-reports/summary.html',
        controller : "ReportSummaryController",
        pageTitle : function(stateParams) {
            return "Report";
        }
    });

    $stateProvider.state('projects.project.reports.report.history', {
        url : "/history",
        templateUrl: '/templates/code-reports/history.html',
        controller : "ReportHistoryController",
        pageTitle : function(stateParams) {
            return "Report";
        }
    });

    /* ***************** Dashboards ********************** */

    $stateProvider.state('projects.project.dashboards', {
        url: "/dashboards",
        abstract: true,
        template: "<div ui-view></div>"
    });

    $stateProvider.state('projects.project.dashboards.list', {
        url: "/",
        templateUrl: '/templates/dashboards/list.html',
        controller: 'DashboardsListController',
        pageTitle: function(stateParams) {
            return "Dashboards";
        }
    });

    $stateProvider.state('projects.project.dashboards.dashboard', {
        url: "/{dashboardId:[0-9a-zA-Z]*}{separator:\_{0,1}}{dashboardName}?discussionId",
        templateUrl: '/templates/dashboards/dashboard.html',
        controller: 'DashboardCoreController',
        abstract: true
    });

    $stateProvider.state('projects.project.dashboards.dashboard.edit', {
        url: "/edit/:pageId",
        templateUrl: '/templates/dashboards/edit.html',
        controller: "DashboardEditController",
        pageTitle: function(stateParams) {
            return "Dashboard";
        }
    });

    $stateProvider.state('projects.project.dashboards.dashboard.view', {
        url: "/view/:pageId?fullScreen",
        templateUrl: '/templates/dashboards/view.html',
        controller: "DashboardViewController",
        pageTitle: function(stateParams) {
            return "Dashboard";
        }
    });

    $stateProvider.state('projects.project.dashboards.dashboard.summary', {
        url : "/summary",
        templateUrl: '/templates/dashboards/summary.html',
        controller : "DashboardSummaryController",
        pageTitle : function(stateParams) {
            return "Dashboard";
        }
    });

    $stateProvider.state('projects.project.dashboards.insights', {
        url: "/insights",
        abstract: true,
        template: "<div ui-view></div>"
    });

    $stateProvider.state('projects.project.dashboards.insights.list', {
        url: "/",
        templateUrl: '/templates/dashboards/insights/list.html',
        controller: 'InsightsListController',
        pageTitle: function(stateParams) {
            return "Insights";
        }
    });

    $stateProvider.state('projects.project.dashboards.insights.insight', {
        url: "/{insightId:[0-9a-zA-Z_-]*}_{insightName}?discussionId",
        templateUrl: '/templates/dashboards/insights/insight.html',
        controller: 'InsightCoreController',
        abstract: true
    });

    $stateProvider.state('projects.project.dashboards.insights.insight.edit', {
        url: "/edit",
        templateUrl: '/templates/dashboards/insights/edit.html',
        controller: "InsightEditController",
        pageTitle: function(stateParams) {
            return "Insight";
        }
    });

    $stateProvider.state('projects.project.dashboards.insights.insight.view', {
        url: "/view?fullScreen",
        templateUrl: '/templates/dashboards/insights/view.html',
        controller: "InsightViewController",
        pageTitle: function(stateParams) {
            return "Insight";
        }
    });

    $stateProvider.state('projects.project.dashboards.insights.insight.summary', {
        url: "/summary",
        templateUrl: '/templates/dashboards/insights/summary.html',
        controller: "InsightSummaryController",
        pageTitle: function(stateParams) {
            return "Insight";
        }
    });

    /* ************************** Bundles ********************** */

    // DSS Design node

    $stateProvider.state('projects.project.bundlesdesign', {
        url: '/bundles-design',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.bundlesdesign.list', {
        url: '/?showProgressModalFor',
        templateUrl: '/templates/bundles/design/list.html',
        controller: "DesignBundlesListController",
        pageTitle: function(stateParams) {
            return "Bundles export";
        }
    });

    $stateProvider.state('projects.project.bundlesdesign.new', {
        url: '/new/',
        templateUrl: '/templates/bundles/design/new.html',
        controller: "DesignBundlesNewController",
        pageTitle: function(stateParams) {
            return "Create bundle";
        }
    });

    // DSS Automation node

    $stateProvider.state('projects.project.bundlesautomation', {
        url: '/bundles-automation',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.bundlesautomation.list', {
        url: '/',
        templateUrl: '/templates/bundles/automation/list.html',
        controller: "AutomationBundlesListController",
        pageTitle: function(stateParams) {
            return "Bundles management";
        }
    });

    $stateProvider.state('projects.project.bundlesautomation.settings', {
        url: '/settings/',
        templateUrl: '/templates/bundles/automation/activation-settings.html',
        controller: "AutomationBundlesSettingsController",
        pageTitle: function(stateParams) {
            return "Bundles settings";
        }
    });

    /* ************************** Mass import           ********************** */
    $stateProvider.state('projects.project.tablesimport', {
        url: '/import-tables?zoneId',
        templateUrl: '/templates/datasets/project-tables-import.html',
        controller: 'ProjectMassTableToDatasetController',
        params: {
            importData: null
        },
        pageTitle: function(stateParams) {
            return "Import tables";
        }
    });

    $stateProvider.state('alationOpen', {
        url: '/alation-open/:alationOpenId',
        templateUrl: '/templates/datasets/alation-open.html',
        controller: "AlationOpenController",
        pageTitle: function(stateParams) {
            return "Mass import";
        }
    });

    /* ************************** API Services (Lambda) ********************** */

    $stateProvider.state('projects.project.lambdaservices', {
        url: '/api-designer',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.lambdaservices.list', {
        url: '/',
        templateUrl: '/templates/lambda/list.html',
        controller: "LambdaServicesListController",
        pageTitle: function(stateParams) {
            return "API Services";
        }
    });

    $stateProvider.state('projects.project.lambdaservices.service', {
        url: '/:serviceId?discussionId',
        abstract: true,
        controller: "LambdaServiceBaseController",
        templateUrl: '/templates/lambda/lambda-service.html'
    });

    $stateProvider.state('projects.project.lambdaservices.service.summary', {
        url: '/summary/',
        controller: "LambdaServiceSummaryController",
        templateUrl: '/templates/lambda/summary.html'
    });

    $stateProvider.state('projects.project.lambdaservices.service.endpoints', {
        url: '/endpoints/',
        controller: "LambdaServiceEndpointsController",
        templateUrl: '/templates/lambda/endpoints.html'
    });

    $stateProvider.state('projects.project.lambdaservices.service.config', {
        url: '/config/',
        controller: "LambdaServiceConfigController",
        templateUrl: '/templates/lambda/lambda-service-config.html'
    });

    $stateProvider.state('projects.project.lambdaservices.service.packages', {
        url: '/packages/',
        controller: "LambdaServicePackagesController",
        templateUrl: '/templates/lambda/packages.html'
    });

    /* ************************** Wiki ********************** */

    $stateProvider.state('projects.project.wiki', {
        url: '/wiki',
        controller: "WikiController",
        templateUrl: '/templates/wikis/wiki.html'
    });

    $stateProvider.state('projects.project.wiki.article', {
        url: '/:articleId/:articleName?fullScreen',
        abstract: true,
        controller: "ArticleController",
        params: {
            // When no articleName is given through the URL, the router will act as if it didn't exist
            // (aka having url:'/:articleId')
            articleName: {squash: true, value: null}
        },
        templateUrl: '/templates/wikis/article.html'
    });

    // templates for the 3 sub-routes for wiki are handled through ng-show and ng-if instead of ui-view because we need to keep the editor state when switching tabs
    // note that history template is kept at the top in order to trigger infinite-scroll directive when switching tabs
    $stateProvider.state('projects.project.wiki.article.view', {
        url: '?discussionId'
    });

    $stateProvider.state('projects.project.wiki.article.edit', {
        url: '/edit'
    });

    $stateProvider.state('projects.project.wiki.article.history', {
        url: '/history'
    });

    $stateProvider.state('projects.wikis', { //mjt placeholder for the page PC is writing
        url: '/wikis',
        templateUrl: '/templates/wikis/article-history.html'
    });

    /* ************************** Scenarios ********************** */

    $stateProvider.state('projects.project.scenarios', {
        url: '/scenarios',
        abstract: true,
        controller: "ScenarioCoreController",
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.scenarios.list', {
        url: '/',
        templateUrl: '/templates/scenarios/list.html',
        controller: "ScenariosListController",
        pageTitle: function(stateParams) {
            return "Scenarios";
        }
    });

    $stateProvider.state('projects.project.scenarios.scenario', {
        url: '/:scenarioId?discussionId',
        templateUrl: '/templates/scenarios/scenario.html',
        controller: "ScenarioController",
        pageTitle: function(stateParams) {
            return "Scenario";
        }
    });

    $stateProvider.state('projects.project.scenarios.scenario.settings', {
        url: '/settings',
        templateUrl: '/templates/scenarios/fragments/scenario-settings.html'
    });

    $stateProvider.state('projects.project.scenarios.scenario.summary', {
        url: '/summary',
        templateUrl: '/templates/scenarios/fragments/scenario-summary.html'
    });

    $stateProvider.state('projects.project.scenarios.scenario.runs', {
        url: '/runs',
        abstract: true,
        templateUrl: '/templates/scenarios/fragments/scenario-runs-timeline.html'
    });

    $stateProvider.state('projects.project.scenarios.scenario.runs.list', {
        url: '/list',
        templateUrl: '/templates/scenarios/fragments/scenario-runs.html'
    });
    // same as above, but go directly to a run
    $stateProvider.state('projects.project.scenarios.scenario.runs.list.run', {
        url: '/:runId',
        templateUrl: '/templates/scenarios/scenario.html',
        controller: "ScenarioRunController",
        pageTitle: function(stateParams) {
            return "Scenario";
        }
    });

    $stateProvider.state('projects.project.scenarios.scenario.runs.timeline', {
        url: '/timeline',
        templateUrl: '/templates/scenarios/fragments/scenario-timeline.html'
    });

    $stateProvider.state('projects.project.scenarios.scenario.history', {
        url: '/history',
        controller: "ScenarioHistoryController",
        templateUrl: '/templates/scenarios/fragments/scenario-git-log.html'
    });

    $stateProvider.state('projects.project.scenarios.scenario.steps', {
        url: '/steps',
        templateUrl: '/templates/scenarios/fragments/scenario-steps.html'
    });

    $stateProvider.state('projects.project.scenarios.scenario.script', {
        url: '/script',
        templateUrl: '/templates/scenarios/fragments/scenario-script.html'
    });

    $stateProvider.state('projects.project.monitoring', {
        url: '/monitoring',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.monitoring.scenarios', {
        url: '/',
        templateUrl: '/templates/scenarios/scenarios-monitoring.html',
        controller: "ScenariosMonitoringController",
        pageTitle: function(stateParams) {
            return "Monitoring";
        }
    });

    $stateProvider.state('projects.project.monitoring.scenarios.scoped', {
        url: ':scopeToDay',
        templateUrl: '/templates/scenarios/scenarios-monitoring.html',
        controller: "ScenariosMonitoringController",
        pageTitle: function(stateParams) {
            return "Monitoring";
        },
        params: {
            scenarioQuery: null
        }
    });

     /* ************************** Continuous Activities ********************** */

    $stateProvider.state('projects.project.continuous-activities', {
        url: '/continuous-activities',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.continuous-activities.list', {
        url: '/',
        templateUrl: '/templates/continuous-activities/list.html',
        controller: "ContinuousActivitiesListController",
        pageTitle: function(stateParams) {
            return "Continuous Activities";
        }
    });

    $stateProvider.state('projects.project.continuous-activities.continuous-activity', {
        url: '/:continuousActivityId',
        templateUrl: '/templates/continuous-activities/continuous-activity.html',
        controller: "ContinuousActivityController",
        pageTitle: function(stateParams) {
            return "Continuous Activity";
        }
    });

    $stateProvider.state('projects.project.continuous-activities.continuous-activity.runs', {
        url: '/runs?runId&attemptId',
        templateUrl: '/templates/continuous-activities/runs.html'
    });

    /* ************************** Macros ********************** */

    $stateProvider.state('projects.project.runnables', {
        url: '/macros',
        abstract: true,
        controller: "RunnableCoreController",
        template: '<div ui-view></div>'
    });

    $stateProvider.state('projects.project.runnables.list', {
        url: '/',
        templateUrl: '/templates/macros/runnables.html',
        controller: "RunnablesListController",
        pageTitle: function(stateParams) {
            return "Macros";
        }
    });

    /* ************************** User profile pages ********************** */

    $stateProvider.state('profile', {
        abstract: true,
        url: '/profile',
        template: '<div ui-view></div>'
    });

    $stateProvider.state('profile.my', {
        url: '/',
        abstract: true,
        templateUrl: '/templates/profile/index.html',
        controller: 'ProfileController'
    });

    /* Default */
    $stateProvider.state('profile.my.settings', {
        url: '',
        templateUrl: '/templates/profile/settings.html',
        pageTitle: function(stateParams) {
            return "Profile settings";
        },
        controller: 'MyProfileAccountController',
        data: {selectedTab: 'settings'}
    });

    $stateProvider.state('profile.my.achievements', {
        url: 'achievements/',
        templateUrl: '/templates/profile/achievements.html',
        pageTitle: function(stateParams) {
            return "My profile";
        },
        controller: 'MyProfileAchievementsController',
        data: {selectedTab: 'achievements'}
    });

    $stateProvider.state('profile.my.exports', {
        url: 'exports/',
        templateUrl: '/templates/profile/exports.html',
        pageTitle: function(stateParams) {
            return "My exports";
        },
        controller: 'MyProfileExportController',
        data: {selectedTab: 'exports'}
    });

    $stateProvider.state('profile.my.stars', {
        url: 'stars/',
        templateUrl: '/templates/profile/stars.html',
        pageTitle: function(stateParams) {
            return "My stars";
        },
        controller: 'MyProfileStarsController',
        data: {selectedTab: 'stars'}
    });

    $stateProvider.state('profile.my.credentials', {
        url: 'credentials/',
        templateUrl: '/templates/profile/credentials.html',
        pageTitle: function(stateParams) {
            return "Connection credentials";
        },
        controller: 'MyProfileConnectionCredentialsController',
        data: {selectedTab: 'credentials'}
    });

    $stateProvider.state('profile.my.apikeys', {
        url: 'apikeys/',
        templateUrl: '/templates/profile/personal-api-keys.html',
        pageTitle: function(stateParams) {
            return "Personal API Keys";
        },
        controller: 'MyProfilePersonalAPIKeysController',
        data: {selectedTab: 'apikeys'}
    });

    $stateProvider.state('profile.my.account', {
        url: 'account/',
        templateUrl: '/templates/profile/account.html',
        pageTitle: function(stateParams) {
            return "Account";
        },
        controller: 'MyProfileEditController',
        data: {selectedTab: 'account'}
    });

    $stateProvider.state('profile.my.notifications', {
        url: 'notifications/',
        templateUrl: '/templates/profile/notifications.html',
        pageTitle: function(stateParams) {
            return "My notifications";
        },
        data: {selectedTab: 'notifications'}
    });

    $stateProvider.state('profile.user', {
        url: '/:userLogin/',
        abstract: true,
        templateUrl: '/templates/profile/index.html',
        controller: 'ProfileController'
    });

    $stateProvider.state('profile.user.view', {
        url: '',
        templateUrl: '/templates/profile/achievements.html',
        controller: 'MyProfileAchievementsController',
        pageTitle: function(stateParams) {
            return "Profile";
        }
    });

    /* ************************** Plugins ********************** */

    $stateProvider.state('plugins', {
        url: '/plugins-explore',
        controller: 'PluginsExploreController',
        templateUrl: '/templates/plugins/index.html',
        pageTitle: function() {
            return 'Plugins';
        }
    });

    $stateProvider.state('plugins.store', {
        url: '/store/:pluginid',
        templateUrl: '/templates/plugins/store-list.html',
        controller: 'PluginsStoreController',
        pageTitle: function() {
            return 'Plugins store';
        }
    });

    $stateProvider.state('plugins.installed', {
        url: '/installed/',
        templateUrl: '/templates/plugins/installed-list.html',
        pageTitle: function() {
            return 'Installed plugins';
        }
    });

    $stateProvider.state('plugins.development', {
        url: '/development/',
        templateUrl: '/templates/plugins/development-list.html',
        pageTitle: function() {
            return 'Plugins Development';
        }
    });

    /* ************************** Plugin page ********************** */

    $stateProvider.state('plugin', {
        url: '/plugins/:pluginId',
        controller: 'PluginController',
        abstract: true,
        templateUrl: '/templates/plugins/plugin-details/index.html'
    });

    $stateProvider.state('plugin.installation', {
        url: '/installation/',
        controller: 'PluginInstallationController',
        templateUrl: '/templates/plugins/plugin-details/installation.html',
        pageTitle: function($stateParams) {
            return 'Installing ' + $stateParams.pluginId;
        }
    });

    $stateProvider.state('plugin.update', {
        url: '/update/',
        controller: 'PluginInstallationController',
        templateUrl: '/templates/plugins/plugin-details/installation.html',
        pageTitle: function($stateParams) {
            return 'Updating ' + $stateParams.pluginId;
        }
    });

    $stateProvider.state('plugin.upload', {
        url: '/upload',
        controller: 'PluginInstallationController',
        templateUrl: '/templates/plugins/plugin-details/installation.html',
        params: { uploadedPluginFile: null },
        pageTitle: function($stateParams) {
            return 'Uploading ' + $stateParams.pluginId;
        }
    });

    $stateProvider.state('plugin.upload.update', {
        url: '/update/',
        controller: 'PluginInstallationController',
        templateUrl: '/templates/plugins/plugin-details/installation.html',
        params: { uploadedPluginFile: null },
        pageTitle: function($stateParams) {
            return 'Updating ' + $stateParams.pluginId;
        }
    });

    $stateProvider.state('plugin.installationfromgit', {
        url: '/install-from-git/?uri&checkout&path',
        controller: 'PluginInstallationController',
        templateUrl: '/templates/plugins/plugin-details/installation.html',
        pageTitle: function($stateParams) {
            return 'Installing from Git'
        }
    });

    $stateProvider.state('plugin.updatefromgit', {
        url: '/update-from-git/?uri&checkout&path',
        controller: 'PluginInstallationController',
        templateUrl: '/templates/plugins/plugin-details/installation.html',
        pageTitle: function($stateParams) {
            return 'Updating from Git'
        }
    });


    $stateProvider.state('plugin.summary', {
        url: '/summary/',
        templateUrl: '/templates/plugins/plugin-details/summary.html',
        controller: 'PluginSummaryController',
        pageTitle: function($stateParams) {
            return 'Plugin - ' + $stateParams.pluginId ;
        }
    });

    $stateProvider.state('plugin.settings', {
        url: '/settings/:selectedTab',
        templateUrl: '/templates/plugins/plugin-details/settings.html',
        controller: 'PluginSettingsController',
        pageTitle: function($stateParams) {
            return 'Plugin settings - ' + $stateParams.pluginId ;
        }
    });

    $stateProvider.state('plugin.usages', {
        url: '/usages/',
        templateUrl: '/templates/plugins/plugin-details/usages.html',
        controller: 'PluginUsagesController',
        pageTitle: function($stateParams) {
            return 'Plugin usages - ' + $stateParams.pluginId ;
        }
    });

    $stateProvider.state('plugindev', {
        url: '/plugins/development/:pluginId',
        abstract: true,
        templateUrl: '/templates/plugins/development/plugin-details/index.html',
        controller: 'PlugindevEditionController'
    });

    $stateProvider.state('plugindev.definition', {
        url: '/definition/',
        templateUrl: '/templates/plugins/development/plugin-details/definition.html',
        controller: 'PlugindevDefinitionController',
        pageTitle: function($stateParams) {
            return 'Plugin - ' + $stateParams.pluginId;
        }
    });

    $stateProvider.state('plugindev.settings', {
        url: '/settings/:selectedTab',
        templateUrl: '/templates/plugins/development/plugin-details/settings.html',
        controller: 'PluginSettingsController',
        pageTitle: function($stateParams) {
            return 'Plugin settings - ' + $stateParams.pluginId;
        }
    });

    $stateProvider.state('plugindev.usages', {
        url: '/usages/',
        templateUrl: '/templates/plugins/plugin-details/usages.html',
        controller: 'PluginUsagesController',
        pageTitle: function($stateParams) {
            return 'Plugin usages - ' + $stateParams.pluginId ;
        }
    });

    $stateProvider.state('plugindev.editor', {
        url: '/editor/',
        templateUrl: '/templates/plugins/development/plugin-details/editor.html',
        controller: 'PlugindevEditorController',
        // to pass a param without putting it into the url
        resolve: {
            filePath: function($stateParams){
                return $stateParams.filePath;
            }
        },
        params: {
            filePath: null
        },
        pageTitle: function($stateParams) {
            return 'Plugin Editor - ' + $stateParams.pluginId ;
        }
    });

    $stateProvider.state('plugindev.history', {
        url: '/development/history/',
        templateUrl: '/templates/plugins/development/plugin-details/history.html',
        controller: 'PlugindevHistoryController',
        pageTitle: function($stateParams) {
            return 'Plugin History - ' + $stateParams.pluginId ;
        }
    });

    $stateProvider.state("libedition", {
        url: '/libedition',
        abstract: true,
        templateUrl: '/templates/plugins/development/lib-edition.html',
        controller: 'TopLevelFolderEditionController'
    });

    $stateProvider.state('libedition.libpython', {
        url: '/libpython',
        templateUrl: '/templates/plugins/development/lib-python-editor.html'
    });

    $stateProvider.state('libedition.libr', {
        url: '/libr',
        templateUrl: '/templates/plugins/development/lib-r-editor.html'
    });

    $stateProvider.state('libedition.localstatic', {
        url: '/localstatic',
        templateUrl: '/templates/plugins/development/local-static-editor.html',
        controller: 'TopLevelLocalStaticEditorController'
    });

    /* ************************** Catalog ********************** */

    $stateProvider.state("catalog", {
        url: '/catalog',
        abstract: true,
        templateUrl: '/templates/catalog/index.html',
        controller: function(TopNav) {
            TopNav.setLocation("DSS_HOME", "catalog", "items", null);
        }
    });

    const catalogItems = {
        url: '/search/:hash',
        templateUrl: '/templates/catalog/search.html',
        controller: "CatalogItemsController",
        params: {
            scope: null
        },
        pageTitle: function(stateParams) {
            return "DSS Data Catalog";
        }
    };

    const catalogMeanings = {
        url: '/meanings/:hash',
        templateUrl: '/templates/catalog/search.html',
        controller: "CatalogMeaningsController",
        pageTitle: function(stateParams) {
            return "Meanings";
        }
    };

    $stateProvider.state('meanings', {
        url: '/meanings',
        templateUrl: '/templates/meanings/index.html',
        controller: "CatalogMeaningsController",
        pageTitle: function(stateParams) {
            return "Meanings";
        }
    });

    $stateProvider.state('projects.project.catalog', {
        url: '/catalog',
        abstract: true,
        templateUrl: '/templates/catalog/index.html',
        controller: function(TopNav) {
            TopNav.setLocation(TopNav.TOP_FLOW, "datasets", TopNav.TABS_NONE, null);
            TopNav.setNoItem();
        }
    });

    $stateProvider.state("catalog.items", $.extend({}, catalogItems));
    $stateProvider.state("projects.project.catalog.items", $.extend({}, catalogItems, {params: {scope: ['external'], _type: null}, url:catalogItems.url+'?zoneId'}));
    $stateProvider.state("projects.project.catalog.meanings", $.extend({}, catalogMeanings));

    $stateProvider.state("external-table", {
        url: '/external-table/:connection/:catalog/:schema/:table',
        abstract: true,
        templateUrl: '/templates/catalog/external-table/index.html',
        controller: "ExternalTableController"
    });

    $stateProvider.state("external-table.summary", {
        url: '',
        template: '<external-table-summary class="h100"></external-table-summary>'
    });

    $stateProvider.state("external-table.schema", {
        url: '/schema/',
        templateUrl: '/templates/catalog/external-table/schema.html'
    });
    $stateProvider.state("external-table.sample", {
        url: '/sample/',
        templateUrl: '/templates/catalog/external-table/sample.html'
    });
    $stateProvider.state("external-table.items", {
        url: '/items/',
        templateUrl: '/templates/catalog/external-table/items.html'
    });

    /* ************************** INBOX ********************** */

    $stateProvider.state("inbox", {
        url: '/inbox',
        templateUrl: '/templates/catalog/inbox.html',
        controller: 'DiscussionsInboxController',
        pageTitle: function() {
            return "Inbox";
        }
    });

    /* ************************** Deployer ********************** */

    $stateProvider.state('deployer', {
        url: '/deployer/',
        controller: 'DeployerHomeController',
        templateUrl: '/templates/deployer/index.html',
        pageTitle: () => "Deployer"
    });


    /* ************************** API Deployer ********************** */

    $stateProvider.state('apideployer', {
        url: '/api-deployer/',
        controller: 'APIDeployerController',
        abstract: true,
        templateUrl: '/templates/api-deployer/index.html'
    });


    $stateProvider.state('apideployer.deployments', {
        url: 'deployments',
        abstract: true,
        template: '<div ui-view class="h100"></div>'
    });
    $stateProvider.state('apideployer.deployments.dashboard', {
        url: '/',
        controller: 'APIDeployerDeploymentsDashboardController',
        templateUrl: '/templates/api-deployer/deployment-dashboard.html',
        pageTitle: function(stateParams) {
            return 'Deployments';
        }
    });
    $stateProvider.state('apideployer.deployments.deployment', {
        url: '/:deploymentId',
        abstract: true,
        controller: 'APIDeployerDeploymentController',
        templateUrl: '/templates/api-deployer/deployment.html'
    });
    $stateProvider.state('apideployer.deployments.deployment.status', {
        url: '/',
        controller: 'APIDeployerDeploymentStatusController',
        templateUrl: '/templates/api-deployer/deployment-status.html',
        pageTitle: function(stateParams) {
            return stateParams.deploymentId + ' - Deployments'
        }
    });
    $stateProvider.state('apideployer.deployments.deployment.history', {
        url: '/history/',
        controller: 'APIDeployerDeploymentHistoryController',
        templateUrl: '/templates/api-deployer/deployment-history.html',
        pageTitle: function(stateParams) {
            return stateParams.deploymentId + ' - Deployments'
        }
    });
    $stateProvider.state('apideployer.deployments.deployment.settings', {
        url: '/settings/',
        controller: 'APIDeployerDeploymentSettingsController',
        templateUrl: '/templates/api-deployer/deployment-settings.html',
        pageTitle: function(stateParams) {
            return stateParams.deploymentId + ' - Deployments'
        }
    });


    $stateProvider.state('apideployer.services', {
        url: 'services',
        abstract: true,
        template: '<div ui-view class="h100"></div>'
    });
    $stateProvider.state('apideployer.services.list', {
        url: '/',
        controller: 'APIDeployerServicesListController',
        templateUrl: '/templates/api-deployer/published-services-list.html',
        pageTitle: function(stateParams) {
            return 'Published API services';
        }
    });
    $stateProvider.state('apideployer.services.service', {
        url: '/:serviceId',
        abstract: true,
        controller: 'APIDeployerServiceController',
        templateUrl: '/templates/api-deployer/published-service.html'
    });
    $stateProvider.state('apideployer.services.service.status', {
        url: '/?versions',
        controller: 'APIDeployerServiceStatusController',
        params: {
            versions: { array: true }
        },
        templateUrl: '/templates/api-deployer/published-service-status.html',
        pageTitle: function(stateParams) {
            return stateParams.serviceId + ' - Published API services';
        }
    });
    $stateProvider.state('apideployer.services.service.history', {
        url: '/history/',
        controller: 'APIDeployerServiceHistoryController',
        templateUrl: '/templates/api-deployer/published-service-history.html',
        pageTitle: function(stateParams) {
            return stateParams.serviceId + ' - Published API services';
        }
    });
    $stateProvider.state('apideployer.services.service.settings', {
        url: '/settings/',
        controller: 'APIDeployerServiceSettingsController',
        templateUrl: '/templates/api-deployer/published-service-settings.html',
        pageTitle: function(stateParams) {
            return stateParams.serviceId + ' - Published API services';
        }
    });


    $stateProvider.state('apideployer.infras', {
        url: 'infras',
        abstract: true,
        template: '<div ui-view class="h100"></div>'
    });
    $stateProvider.state('apideployer.infras.list', {
        url: '/',
        controller: 'APIDeployerInfrasListController',
        templateUrl: '/templates/api-deployer/infras-list.html',
        pageTitle: function(stateParams) {
            return 'API Infrastructures';
        }
    });
    $stateProvider.state('apideployer.infras.infra', {
        url: '/:infraId',
        controller: 'APIDeployerInfraController',
        abstract: true,
        templateUrl: '/templates/api-deployer/infra.html'
    });
    $stateProvider.state('apideployer.infras.infra.status', {
        url: '/',
        controller: 'APIDeployerInfraStatusController',
        templateUrl: '/templates/api-deployer/infra-status.html',
        pageTitle: function(stateParams) {
            return stateParams.infraId + ' - API Infrastructures';
        }
    });
    $stateProvider.state('apideployer.infras.infra.history', {
        url: '/history/',
        controller: 'APIDeployerInfraHistoryController',
        templateUrl: '/templates/api-deployer/infra-history.html',
        pageTitle: function(stateParams) {
            return stateParams.infraId + ' - API Infrastructures';
        }
    });
    $stateProvider.state('apideployer.infras.infra.settings', {
        url: '/settings/',
        controller: 'APIDeployerInfraSettingsController',
        templateUrl: '/templates/api-deployer/infra-settings.html',
        pageTitle: function(stateParams) {
            return stateParams.infraId + ' - API Infrastructures';
        }
    });

    /* ************************** Project Deployer ********************** */
    $stateProvider.state('projectdeployer', {
        url: '/project-deployer/',
        controller: 'ProjectDeployerController',
        abstract: true,
        template: '<div ui-view class="h100"></div>'
    });
    
    $stateProvider.state('projectdeployer.deployments', {
        url: 'deployments',
        abstract: true,
        controller: 'ProjectDeployerDeploymentsController',
        template: '<div ui-view class="h100"></div>'
    });
    $stateProvider.state('projectdeployer.deployments.dashboard', {
        url: '/',
        controller: 'ProjectDeployerDeploymentDashboardController',
        templateUrl: '/templates/project-deployer/deployment-dashboard.html',
        pageTitle: function(stateParams) {
            return 'Deployments';
        }
    });
    $stateProvider.state('projectdeployer.deployments.deployment', {
        url: '/:deploymentId',
        abstract: true,
        controller: 'ProjectDeployerDeploymentController',
        templateUrl: '/templates/project-deployer/deployment.html'
    });
    $stateProvider.state('projectdeployer.deployments.deployment.status', {
        url: '/',
        controller: 'ProjectDeployerDeploymentStatusController',
        templateUrl: '/templates/project-deployer/deployment-status.html',
        pageTitle: function(stateParams) {
            return stateParams.deploymentId + ' - Deployments'
        }
    });
    $stateProvider.state('projectdeployer.deployments.deployment.settings', {
        url: '/settings/',
        controller: 'ProjectDeployerDeploymentSettingsController',
        templateUrl: '/templates/project-deployer/deployment-settings.html',
        pageTitle: function(stateParams) {
            return stateParams.deploymentId + ' - Deployments'
        }
    });
    $stateProvider.state('projectdeployer.deployments.deployment.history', {
        url: '/history/',
        controller: 'ProjectDeployerDeploymentHistoryController',
        templateUrl: '/templates/project-deployer/deployment-history.html',
        pageTitle: function(stateParams) {
            return stateParams.deploymentId + ' - Deployments'
        }
    });

    $stateProvider.state('projectdeployer.projects', {
        url: 'projects',
        abstract: true,
        controller: 'ProjectDeployerProjectsController',
        template: '<div ui-view class="h100"></div>'
    });
    $stateProvider.state('projectdeployer.projects.list', {
        url: '/',
        controller: 'ProjectDeployerProjectListController',
        templateUrl: '/templates/project-deployer/published-projects-list.html',
        pageTitle: function(stateParams) {
            return 'Projects';
        },
        params: {
            selectedProjectKey: null // open specified project accordion table on load
        }
    });
    $stateProvider.state('projectdeployer.projects.project', {
        url: '/:publishedProjectKey',
        abstract: true,
        controller: 'ProjectDeployerProjectController',
        template: '<div ui-view class="h100"></div>'
    });
    $stateProvider.state('projectdeployer.projects.project.home', {
        url: '',
        abstract: true,
        templateUrl: '/templates/project-deployer/published-project.html'
    });
    $stateProvider.state('projectdeployer.projects.project.home.status', {
        url: '/',
        controller: 'ProjectDeployerProjectStatusController',
        templateUrl: '/templates/project-deployer/published-project-status.html',
        pageTitle: function(stateParams) {
            return stateParams.publishedProjectKey + ' - Published Projects';
        }
    });
    $stateProvider.state('projectdeployer.projects.project.home.settings', {
        url: '/settings/',
        controller: 'ProjectDeployerProjectSettingsController',
        templateUrl: '/templates/project-deployer/published-project-settings.html',
        pageTitle: function(stateParams) {
            return stateParams.publishedProjectKey + ' - Published Projects';
        }
    });
    $stateProvider.state('projectdeployer.projects.project.home.history', {
        url: '/history/',
        controller: 'ProjectDeployerProjectHistoryController',
        templateUrl: '/templates/project-deployer/published-project-history.html',
        pageTitle: function(stateParams) {
            return stateParams.publishedProjectKey + ' - Published Projects';
        }
    });
    $stateProvider.state('projectdeployer.projects.project.bundle', {
        url: '/bundle/:bundleId',
        controller: 'ProjectDeployerBundleController',
        abstract: true,
        templateUrl: '/templates/project-deployer/published-bundle.html'
    });
    $stateProvider.state('projectdeployer.projects.project.bundle.status', {
        url: '/',
        controller: 'ProjectDeployerBundleStatusController',
        templateUrl: '/templates/project-deployer/published-bundle-status.html',
        pageTitle: function(stateParams) {
            return stateParams.bundleId + ' - Published Bundles';
        }
    });

    $stateProvider.state('projectdeployer.infras', {
        url: 'infras',
        abstract: true,
        template: '<div ui-view class="h100"></div>'
    });
    $stateProvider.state('projectdeployer.infras.list', {
        url: '/',
        controller: 'ProjectDeployerInfrasListController',
        templateUrl: '/templates/project-deployer/infras-list.html',
        pageTitle: function(stateParams) {
            return 'Infrastructures';
        }
    });
    $stateProvider.state('projectdeployer.infras.infra', {
        url: '/:infraId',
        controller: 'ProjectDeployerInfraController',
        abstract: true,
        templateUrl: '/templates/project-deployer/infra.html'
    });
    $stateProvider.state('projectdeployer.infras.infra.status', {
        url: '/',
        controller: 'ProjectDeployerInfraStatusController',
        templateUrl: '/templates/project-deployer/infra-status.html',
        pageTitle: function(stateParams) {
            return stateParams.infraId + ' - Automation Node Infrastructures';
        }
    });
    $stateProvider.state('projectdeployer.infras.infra.settings', {
        url: '/settings/',
        controller: 'ProjectDeployerInfraSettingsController',
        templateUrl: '/templates/project-deployer/infra-settings.html',
        pageTitle: function(stateParams) {
            return stateParams.infraId + ' - Automation Node Infrastructures';
        }
    });
    $stateProvider.state('projectdeployer.infras.infra.history', {
        url: '/history/',
        controller: 'ProjectDeployerInfraHistoryController',
        templateUrl: '/templates/project-deployer/infra-history.html',
        pageTitle: function(stateParams) {
            return stateParams.infraId + ' - Automation Node Infrastructures';
        }
    });

    /* ************************** Connection explorer           ********************** */
    const connectionExplorer = {
        url: '/connection-explorer?connectionName?schemaName?catalogName?zoneId',
        templateUrl: '/templates/datasets/connection-explorer.html',
        controller: "ConnectionsExplorerController",
        pageTitle: function(stateParams) {
            return "Connection explorer";
        }
    };

    $stateProvider.state('projects.project.catalog.connectionexplorer', $.extend({}, connectionExplorer));
    $stateProvider.state('catalog.connectionexplorer', $.extend({}, connectionExplorer));


    /* ************************** Automation  ********************** */

    $stateProvider.state("automation", {
        url: '/automation',
        abstract: true,
        templateUrl: '/templates/scenarios/instance-monitoring.html',
        pageTitle: stateParams => "Automation",
    });

    $stateProvider.state("automation.outcomes", {
        url: '/',
        templateUrl: '/templates/scenarios/outcomes-instance-view.html',
    });

    $stateProvider.state("automation.timeline", {
        url: '/timeline',
        templateUrl: '/templates/scenarios/timeline.html',
    });

    $stateProvider.state("automation.triggers", {
        url: '/triggers',
        templateUrl: '/templates/scenarios/triggers-instance-view.html',
    });

    $stateProvider.state("automation.reporters", {
        url: '/reporters',
        templateUrl: '/templates/scenarios/reporters-instance-view.html',
    });

    /* ************************** Administration ********************** */

    $stateProvider.state('admin', {
        url: '/admin/',
        abstract: true,
        templateUrl: '/templates/admin/index.html',
        controller: function(Breadcrumb) {
            Breadcrumb.set([{type: "admin"}]);
        }
    });

    $stateProvider.state('admin.home', {
        url: '',
        templateUrl: '/templates/admin/home.html',
        controller: "AdminLicensingController",
        pageTitle: function(stateParams) {
            return "Administration";
        }
    });

    $stateProvider.state('admin.general', {
        url: 'general/',
        templateUrl: '/templates/admin/general/index.html',
        controller: "AdminGeneralSettingsController",
    });

    $stateProvider.state('admin.general.themes', {
        url: 'themes/',
        controller: "AdminThemeController" ,
        templateUrl: '/templates/admin/general/themes.html',
        pageTitle: function(stateParams) {
            return "Themes";
        },
    });

    $stateProvider.state('admin.general.globaltags', {
        url: 'global-tags/',
        templateUrl: '/templates/admin/general/global-tags.html',
        pageTitle: function(stateParams) {
            return "Global tag categories";
        },
    });

    $stateProvider.state('admin.general.notifications', {
        url: 'notifications/',
        templateUrl: '/templates/admin/general/notifications.html',
        pageTitle: function(stateParams) {
            return "Notifications";
        },
    });

    $stateProvider.state('admin.general.engines', {
        url: 'engines/',
        templateUrl: '/templates/admin/general/engines.html',
        pageTitle: function(stateParams) {
            return "Engines";
        },
    });

    $stateProvider.state('admin.general.flowbuild', {
        url: 'flow-build/',
        templateUrl: '/templates/admin/general/flow-build.html',
        pageTitle: function(stateParams) {
            return "Flow build";
        },
    });

    $stateProvider.state('admin.general.variables', {
        url: 'variables/',
        controller: 'AdminVariablesController',
        templateUrl: '/templates/admin/general/variables.html',
        pageTitle: function(stateParams) {
            return "Variables";
        },
    });

    $stateProvider.state('admin.general.hadoop', {
        url: 'hadoop/',
        templateUrl: '/templates/admin/general/hadoop.html',
        pageTitle: function(stateParams) {
            return "Hadoop";
        },
    });

    $stateProvider.state('admin.general.hive', {
        url: 'hive/',
        templateUrl: '/templates/admin/general/hive.html',
        pageTitle: function(stateParams) {
            return "Hive";
        },
    });

    $stateProvider.state('admin.general.impala', {
        url: 'impala/',
        templateUrl: '/templates/admin/general/impala.html',
        pageTitle: function(stateParams) {
            return "Impala";
        },
    });

    $stateProvider.state('admin.general.spark', {
        url: 'spark/',
        templateUrl: '/templates/admin/general/spark.html',
        pageTitle: function(stateParams) {
            return "Spark";
        },
    });

    $stateProvider.state('admin.general.metastores', {
        url: 'metastores/',
        templateUrl: '/templates/admin/general/metastores.html',
        pageTitle: function(stateParams) {
            return "Hadoop";
        },
    });


    $stateProvider.state('admin.general.containers', {
        url: 'containers/',
        templateUrl: '/templates/admin/general/containers.html',
        pageTitle: function(stateParams) {
            return "Containers";
        },
    });

    $stateProvider.state('admin.general.security', {
        url: 'security/',
        templateUrl: '/templates/admin/general/security.html',
        pageTitle: function(stateParams) {
            return "Security";
        },
    });

    $stateProvider.state('admin.general.limits', {
        url: 'limits/',
        templateUrl: '/templates/admin/general/limits.html',
        pageTitle: function(stateParams) {
            return "Resources control";
        },
    });

    $stateProvider.state('admin.general.git', {
        url: 'git/',
        templateUrl: '/templates/admin/general/git.html',
        pageTitle: function(stateParams) {
            return "Git";
        },
    });

    $stateProvider.state('admin.general.deployer', {
        url: 'deployer/',
        templateUrl: '/templates/admin/general/deployer.html',
        pageTitle: function(stateParams) {
            return "Deployer";
        },
    });

    $stateProvider.state('admin.general.audit', {
        url: 'audit/',
        templateUrl: '/templates/admin/general/audit.html',
        pageTitle: function(stateParams) {
            return "Audit";
        },
    });

    $stateProvider.state('admin.general.eventserver', {
        url: 'eventserver/',
        templateUrl: '/templates/admin/general/eventserver.html',
        pageTitle: function(stateParams) {
            return "Event Server";
        },
    });

    $stateProvider.state('admin.general.misc', {
        url: 'misc/',
        templateUrl: '/templates/admin/general/misc.html',
        pageTitle: function(stateParams) {
            return "Misc";
        },
    });

    /********************
     * Admin / Code envs
     ********************/

    $stateProvider.state('admin.codeenvs-design', {
        url: 'code-envs/design',
        abstract: true,
        template:'<div ui-view></div>'
    });

    $stateProvider.state('admin.codeenvs-design.list', {
        url: '/',
        controller: "AdminCodeEnvsDesignListController",
        templateUrl: '/templates/admin/code-envs/design/list.html'
    });

    $stateProvider.state('admin.codeenvs-design.python-edit', {
        url: '/python/:envName/',
        controller: "AdminCodeEnvsDesignPythonEditController",
        templateUrl: '/templates/admin/code-envs/design/python-edit.html'
    });

    $stateProvider.state('admin.codeenvs-design.r-edit', {
        url: '/r/:envName/',
        controller: "AdminCodeEnvsDesignREditController",
        templateUrl: '/templates/admin/code-envs/design/R-edit.html'
    });

    $stateProvider.state('admin.codeenvs-automation', {
        url: 'code-envs/automation',
        abstract: true,
        template:'<div ui-view></div>'
    });

    $stateProvider.state('admin.codeenvs-automation.list', {
        url: '/',
        controller: "AdminCodeEnvsAutomationListController",
        templateUrl: '/templates/admin/code-envs/automation/list.html'
    });

    $stateProvider.state('admin.codeenvs-automation.python-edit', {
        url: '/python/:envName/',
        controller: "AdminCodeEnvsAutomationPythonEditController",
        templateUrl: '/templates/admin/code-envs/automation/python-edit.html'
    });

    $stateProvider.state('admin.codeenvs-automation.r-edit', {
        url: '/r/:envName/',
        controller: "AdminCodeEnvsAutomationREditController",
        templateUrl: '/templates/admin/code-envs/automation/R-edit.html'
    });

    /********************
     * Admin / Maintenance
     ********************/

    $stateProvider.state('admin.maintenance', {
        url: 'maintenance/',
        templateUrl: '/templates/admin/maintenance/index.html'
    });

    $stateProvider.state('admin.maintenance.info', {
        url: 'info/',
        templateUrl: '/templates/admin/maintenance/info.html',
        pageTitle: function(stateParams) {
            return "System info";
        },
        controller: "AdminMaintenanceInfoController"
    });

    $stateProvider.state('admin.maintenance.logs', {
        url: 'logs/',
        templateUrl: '/templates/admin/maintenance/logs.html',
        pageTitle: function(stateParams) {
            return "Logs";
        },
        controller: "AdminLogsController"
    });

    $stateProvider.state('admin.maintenance.diagnosis', {
        url: 'diagnosis/',
        templateUrl: '/templates/admin/maintenance/diagnosis.html',
        pageTitle: function(stateParams) {
            return "Diagnosis";
        },
        controller: "AdminDiagnosticsController"
    });

    $stateProvider.state('admin.maintenance.scheduledtasks', {
        url: 'scheduled/',
        templateUrl: '/templates/admin/maintenance/scheduled-tasks.html',
        pageTitle: function(stateParams) {
            return "Scheduled Tasks";
        },
        controller: "AdminScheduledTasksController" // Ugly ....
    });

    /********************
     * Admin / Monitoring
     ********************/

    $stateProvider.state('admin.monitoring', {
        url: 'monitoring',
        abstract: true,
        templateUrl: '/templates/admin/monitoring/index.html',
    });

    $stateProvider.state('admin.monitoring.summary', {
        url: '/',
        controller: "AdminMonitoringSummaryController",
        templateUrl: '/templates/admin/monitoring/global-summary.html',
    });

    $stateProvider.state('admin.monitoring.clustertasks', {
        url: '/cluster-tasks/',
        controller: "AdminMonitoringClusterTasksController",
        templateUrl: '/templates/admin/monitoring/cluster-tasks.html',
    });

    $stateProvider.state('admin.monitoring.connectiondata', {
        url: '/connection-data/',
        controller: "AdminMonitoringConnectionDataController",
        templateUrl: '/templates/admin/monitoring/connection-data.html',
    });

    $stateProvider.state('admin.monitoring.bgtasks', {
        url: '/background-tasks/',
        controller: "AdminMonitoringBackgroundTasksController",
        templateUrl: '/templates/admin/monitoring/background-tasks.html',
    });

    $stateProvider.state('admin.monitoring.webapps', {
        url: '/webapp-backends/',
        controller: "AdminMonitoringWebAppBackendsController",
        templateUrl: '/templates/admin/monitoring/webapp-backends.html',
        pageTitle : function() { return "Webapp backends"; }
    });

    $stateProvider.state('admin.monitoring.integrations', {
        url: '/integrations/',
        controller: "AdminMonitoringIntegrationsController",
        templateUrl: '/templates/admin/monitoring/integrations.html',
        pageTitle : function() { return "Integrations"; }
    });

    /********************
     * Admin / Security
     ********************/

    $stateProvider.state('admin.security', {
        url: 'security/',
        abstract: true,
        templateUrl: '/templates/admin/security/index.html',
        controller: "AdminSecurityController"
    });

    $stateProvider.state('admin.security.users', {
        url: 'users/',
        abstract: true,
        template: '<div ui-view class="h100"></div>',
    });

    $stateProvider.state('admin.security.users.list', {
        url:'',
        templateUrl: '/templates/admin/security/users.html',
        controller: 'UsersController',
        pageTitle: function(stateParams) {
            return "Users";
        }
    });

    $stateProvider.state('admin.security.users.new', {
        url: 'new/',
        templateUrl: '/templates/admin/security/user.html',
        controller: 'UserController',
        pageTitle: function(stateParams) {
            return "New user";
        }
    });

    $stateProvider.state('admin.security.users.edit', {
        url: 'edit/:login/',
        templateUrl: '/templates/admin/security/user.html',
        controller: 'UserController',
        pageTitle: function(stateParams) {
            return "Edit "+stateParams.login+"";
        }
    });

    $stateProvider.state('admin.security.groups', {
        url: 'groups/',
        abstract: true,
        template: '<div ui-view class="h100"></div>',
    });

    $stateProvider.state('admin.security.groups.list', {
        url: '',
        templateUrl: '/templates/admin/security/groups.html',
        pageTitle: function(stateParams) {
            return "Groups";
        },
        controller: "GroupsController"
    });

    $stateProvider.state('admin.security.groups.new', {
        url: 'new/',
        templateUrl: '/templates/admin/security/group.html',
        controller: 'GroupController',
        pageTitle: function(stateParams) {
            return "New group";
        }
    });

    $stateProvider.state('admin.security.groups.edit', {
        url: 'edit/:name/',
        templateUrl: '/templates/admin/security/group.html',
        controller: 'GroupController',
        pageTitle: function(stateParams) {
            return "Edit "+stateParams.name+"";
        }
    });

    $stateProvider.state('admin.security.globalapi', {
        url: 'apikeys/',
        abstract: true,
        template: '<div ui-view class="h100"></div>'
    });

    $stateProvider.state('admin.security.globalapi.list', {
        url: '',
        templateUrl: '/templates/admin/security/global-api-keys.html',
        pageTitle: function(stateParams) {
            return "API";
        },
        controller: "GlobalPublicAPIKeysController"
    });

    $stateProvider.state('admin.security.globalapi.new', {
        url: 'new/',
        templateUrl: '/templates/admin/security/global-api-key.html',
        pageTitle: function(stateParams) {
            return "API";
        },
        controller: "EditGlobalPublicAPIKeyController"
    });

    $stateProvider.state('admin.security.globalapi.edit', {
        url: 'edit/:id/',
        templateUrl: '/templates/admin/security/global-api-key.html',
        controller: 'EditGlobalPublicAPIKeyController',
        pageTitle: function(stateParams) {
            return "API";
        }
    });

    $stateProvider.state('admin.security.personalapi', {
        url: 'personalapikeys/',
        templateUrl: '/templates/admin/security/personal-api-keys.html',
        pageTitle: function(stateParams) {
            return "API";
        },
        controller: "AdminPersonalPublicAPIKeysController"
    });

    $stateProvider.state('admin.security.authorizationmatrix', {
        url: 'authorization-matrix/',
        templateUrl: '/templates/admin/security/authorization-matrix.html',
        controller: "AdminSecurityAuthorizationMatrixController"
    });

    $stateProvider.state('admin.security.auditbuffer', {
        url: 'audit-buffer/',
        templateUrl: '/templates/admin/security/audit-buffer.html',
        controller: "AdminSecurityAuditBufferController"
    });

    // Connections management

    $stateProvider.state('admin.connections', {
        url: 'connections/',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('admin.connections.list', {
        url: 'list/',
        templateUrl: '/templates/admin/connections.html',
        controller: 'ConnectionsController',
        pageTitle: function(stateParams) {
             return "Overview";
        }
    });

    $stateProvider.state('admin.connections.hiveindexing', {
        url: 'hive-indexing/',
        templateUrl: '/templates/admin/connections.html', // Reuses the same template
        controller: 'ConnectionsHiveIndexingController',
        pageTitle: function(stateParams) {
             return "Hive indexing";
        }
    });

    $stateProvider.state('admin.connections.new', {
        url: 'new/:type/',
        templateUrl: '/templates/admin/connection.html',
        controller: 'ConnectionController',
        pageTitle: function(stateParams) {
            return "New " + stateParams.type + " connection";
        }
    });

    $stateProvider.state('admin.connections.edit', {
        url: ':connectionName/',
        templateUrl: '/templates/admin/connection.html',
        controller: 'ConnectionController',
        pageTitle: function(stateParams) {
            return stateParams.connectionName + " - Connection";
        }
    });

    // Clusters admin
    $stateProvider.state('admin.clusters', {
        url: 'clusters',
        abstract: true,
        template: '<div ui-view></div>'
    });

    $stateProvider.state('admin.clusters.list', {
        url: '/',
        templateUrl: '/templates/admin/clusters/clusters.html',
        controller: "ClustersController",
        pageTitle: function(stateParams) {
            return "Clusters";
        }
    });

    $stateProvider.state('admin.clusters.cluster', {
        url: '/:clusterId',
        templateUrl: '/templates/admin/clusters/cluster.html',
        controller: "ClusterController",
        pageTitle: function(stateParams) {
            return "Cluster";
        }
    });

    //last but not the least : a route to cach everything that could not be routed

    $stateProvider.state("otherwise", {
        url: "*path",
        templateUrl: "/templates/404.html",
        controller: function($scope, $stateParams) {
            $scope.$stateParams = $stateParams;
        }
    });

    $httpProvider.interceptors.push('dssInterceptor');
});


})();

(function() {
'use strict';

const app = angular.module('dataiku.controllers', ['dataiku.services', 'dataiku.filters', 'dataiku.markdown']);



app.controller('DataikuController', function($cacheFactory, $filter, $http, $injector, $state, $location, $modal, $q, $rootScope,
       $route, $scope, $controller, $stateParams, $templateCache, $timeout, $exceptionHandler,
       Assert, Dialogs, ActivityIndicator, FlowToolsLoader, Discussions,
       BackendReportsService, Breadcrumb, Throttle, CachedAPICalls, CreateExportModal,
       CreateModalFromTemplate, DataikuAPI, localStorageService, ContextualMenu,
       LoggerProvider, Notification, TopNav, WebSocketService, TrackingService, WT1,
       Markdown, GrelMode, RMarkdownMode, //Not used but included here to force load
       TaggingService, ProjectFolderContext,
       ExportUtils, ErrorReporting, StateUtils, SmartId, IntercomSupport, RecipeDescService, MessengerUtils,
       AlationCatalogChooserService, CodeMirrorSettingService, UserImageUrl, ProjectStatusService, HomePageContextService,
       HomeBehavior, CatalogItemService, Debounce, FeatureFlagsService, DetectUtils, FullScreenService) {
           
    RecipeDescService.load($scope);
    $rootScope.DataikuAPI = DataikuAPI;
    $rootScope.$state = $state;
    $scope.isFullScreen = FullScreenService.isFullScreen;

    TopNav.setLocation(TopNav.DSS_HOME);

    // Since the controller is not properly declared, it's not possible to use "Logger" directly (see angular-instantiable.js)
    const Logger = LoggerProvider.getLogger('DataikuController');
    Logger.info("Starting DSS load");

    window.APIErrorLogger = LoggerProvider.getLogger("api.errors");

    $rootScope.wl = {
        productShortName: "DSS",
        productLongName: "Dataiku DSS"
    }
    $rootScope.dssMinorVersion = "9.0";
    $rootScope.versionDocRoot = "https://doc.dataiku.com/dss/9.0/";
    $rootScope.apiDocRoot = "https://doc.dataiku.com/dss/api/9.0/";
    $rootScope.academyRootUrl = "https://academy.dataiku.com/";
    $rootScope.learnRootUrl = "https://www.dataiku.com/learn/";


    $controller("DatasetsCommon", {$scope: $scope});

    function userAvatar(userLogin, size) {
        if (!userLogin)  return "";
        return '<img class="user-avatar" src="' + UserImageUrl(userLogin, size) + '" /> ';
    }

    function dssObjectLink(objectType, projectKey, objectId, innerHTML) {
        var link = StateUtils.href.dssObject(objectType, objectId, projectKey);
        return '<a href="'+link+'" class="link-std">'+innerHTML+'</a>';
    }

    function userLink(userLogin, innerHTML) {
        return '<a href="/profile/'+escape(userLogin)+'/" class="link-std">'+ innerHTML + '</a>';
    }

    $scope.$on("$stateChangeStart", function(event, toState, toParams, fromState, fromParams) {
        Logger.debug('State: '+((fromState && fromState.name)?fromState.name:'Unknown') + ' -> '+ ((toState && toState.name)?toState.name:'Unknown'), toParams);
    });

    // Check for unsaved changes in the page before leaving:
    window.addEventListener("beforeunload", function (event) {
        try {
            if (typeof window.dssHasDirtyThings == "function" && window.dssHasDirtyThings()) {
                var msg = 'Unsaved changes will be lost';
                event.returnValue = msg; //this string will not be displayed anyway
                return msg;
            }
        } catch (e){
            Logger.error("Failed to compute dirtiness. Let it go.", e);
        }
    });

    $scope.reflow = {};
    $scope.$on('reflow',function() {
        $scope.reflow = {};
    });

    Notification.registerEvent('websocket-status-changed',function(evt,data) {
        $scope.wsFail = false;
        $("body").removeClass("ws-disconnected");
        if(data.code == WebSocketService.ERROR_CODE.CONNECTION_FAILED) {
            $scope.wsFail = true;
        } else if(data.code == WebSocketService.ERROR_CODE.CONNECTION_LOST) {
            $("body").addClass("ws-disconnected");
        }
    });

    $scope.closeContextualMenus = function(){
        ContextualMenu.prototype.closeAny();
    };

    $scope.reconnectWebSocket = function() {
        WebSocketService.connect();
    };

    $scope.sendOfflineQueues = function() {
        DataikuAPI.internal.sendOfflineQueues();
    };
    $scope.failAllBackendCalls = function(fail) {
        DataikuAPI.internal.fail(fail);
    };
    $scope.sendDigests = function() {
        DataikuAPI.internal.sendDigests();
    };
    $scope.buildUsageSummaryReports = function () {
        DataikuAPI.internal.buildUsageSummaryReports();
    };

    /* Put some stuff in the global scopes */
    $rootScope.$stateParams = $stateParams;
    $rootScope.StateUtils = StateUtils;
    $rootScope.SmartId = SmartId;
    $scope.$state = $state;
    $scope.sanitize = sanitize;
    $scope.JSON = JSON;
    $scope.$route = $route;
    $scope.Object = Object;
    $scope.pendingRequests = $http.pendingRequests;
    $rootScope.spinnerPosition = undefined;
    $scope.isTouchDevice = isTouchDevice();

    Breadcrumb.set([])

    $timeout(function() {
        $('.selectpicker').selectpicker();
        $('[data-toggle=dropdown]').dropdown();
     },10);

    /* Some global state management */

    // Preserve Hash in URL (that ui-router discard otherwise)
    // We only do it for predmltask.report and clustmltask.report and mltask.list.design to go to the design page from the train information
    // It's absolutely ugly. But the problem is that keeping the hash seriously
    // breaks history

     var hash;
     $scope.$on('$stateChangeStart', function(e){
         hash = $location.hash();
     })
    $scope.$on('$stateChangeSuccess', function(e, toState){
        if (hash && (toState.name.includes("mltask.report") || toState.name.includes("mltask.list.design"))){
             $location.hash(hash, true).replace(true);
        }
        WT1.setSessionParam("currentState", toState.name);
        WT1.event("state-changed");
        $rootScope.$broadcast("dismissModals");
        $rootScope.$broadcast("dismissPopovers");
    });

    /* *************** Global login / config management ***************** */

    $scope.isSAASAuth = function() {
        return $rootScope.appConfig && $rootScope.appConfig.saasAuth;
    };

    $scope.onConfigurationLoaded = function() {
        IntercomSupport.activate();
        Assert.inScope($rootScope, 'appConfig');

        $rootScope.wl = $rootScope.appConfig.whiteLabeling;

        if ($rootScope.wl.referenceDocRootUrl) {
            $rootScope.versionDocRoot = $rootScope.wl.referenceDocRootUrl;
        }
        if ($rootScope.wl.apiDocRootUrl) {
            $rootScope.apiDocRoot = $rootScope.wl.apiDocRootUrl;
        }
        if ($rootScope.wl.academyRootUrl) {
            $rootScope.academyRootUrl = $rootScope.wl.academyRootUrl;
        }
        if ($rootScope.wl.learnRootUrl) {
            $rootScope.learnRootUrl = $rootScope.wl.learnRootUrl;
        }

        if ($rootScope.appConfig.loggedIn) {
            WebSocketService.connect();
            $scope.countNotifications();
            // Temporary stuff ... Just in case it remained here...
            WT1.delVisitorParam("tutorial-project");
            WT1.delVisitorParam("tutorial-id");
            WT1.configure();
            ErrorReporting.configure();
            TrackingService.configurePingTracking();
            if ($rootScope.appConfig.customJS) {
                function evalCustomJS() {
                    try {
                        eval($rootScope.appConfig.customJS); //NOSONAR
                    } catch (e){
                        $exceptionHandler(e);
                    }
                }
                evalCustomJS();
            }

            if ($rootScope.appConfig.loadedPlugins) {
                $rootScope.appConfig.loadedPlugins.forEach(function(pluginDesc) {
                    if (!pluginDesc.customJSSnippets) {
                        return;
                    }
                    function evalCustomJSSnippet(snippet) { //Keep a named function to easily spot custom js in stacks
                        try {
                            eval(snippet); //NOSONAR
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    }
                    pluginDesc.customJSSnippets.forEach(evalCustomJSSnippet);
                });
            }

            if ($rootScope.appConfig.theme) {
            	$scope.setTheme($rootScope.appConfig.theme);
            }

            /** Additional license info */
            $rootScope.addLicInfo = {};
            $rootScope.addLicInfo.sparkLicensed = $rootScope.appConfig.licensedFeatures && $rootScope.appConfig.licensedFeatures.sparkAllowed || $rootScope.appConfig.ceEntrepriseTrial;
            $rootScope.addLicInfo.hiveLicensed = !$rootScope.appConfig.community;
            $rootScope.addLicInfo.pigLicensed = !$rootScope.appConfig.community;
            $rootScope.addLicInfo.impalaLicensed = !$rootScope.appConfig.community;
            $rootScope.addLicInfo.containersLicensed = !$rootScope.appConfig.community;

            if ($rootScope.appConfig.alationSettings.enabled) {
                AlationCatalogChooserService.install();
            }
        } else {
            /* Still configure WT1 for push login state event */
            WT1.configure();
        }
        if (window.devInstance) {
            Mousetrap.bind("@ r r", function(){
                $templateCache.removeAll();
                $cacheFactory.get("$http").removeAll();
                $state.go($state.current, $stateParams, {reload:true, inherit: false, notify: true});
            })
            Mousetrap.bind("@ c c", function(){
                $templateCache.removeAll();
                $cacheFactory.get("$http").removeAll();
            })
        }
    };

    DataikuAPI.getConfiguration().success(function(data) {
        $rootScope.appConfig = data;
        $scope.appConfig = data;
        window.dkuAppConfig = data;

        var ac = data;
        WT1.event("studio-open", {
            loggedIn : ac.loggedIn,
            installId: ac.installId,
            version: ac.version,
            hadoopVersion: ac.hadoopVersion,
            hasNodeName: !!ac.nodeName,
            hasExternalURL: !!ac.dssExternalURL,
            themeId: ac.theme && ac.theme.id,

            hadoopEnabled: ac.hadoopEnabled,
            hiveEnabled: ac.hiveEnabled,
            impalaEnabled: ac.impalaEnabled,
            pigEnabled: ac.pigEnabled,
            twitterEnabled: ac.twitterEnabled,
            rEnabled: ac.rEnabled,
            legacyH2OEnabled: ac.h2oEnabled,
            impersonationEnabled: ac.impersonationEnabled,
            sparkEnabled: ac.sparkEnabled,
            pluginDevExplicitCommit: ac.pluginDevExplicitCommit,
            pluginDevGitMode: ac.pluginDevGitMode,
            alationEnabled: !!ac.alationSettings && ac.alationSettings.enabled,
            anonRegistrationAllowed: ac.anonRegistrationAllowed,
            gitMode : ac.gitMode,

            nbProjectStatus: ac.projectStatusList && ac.projectStatusList.length || 0,

            plugins: ac.loadedPlugins.map(x => x.id).join(","),
            customCodeRecipes: ac.customCodeRecipes && ac.customCodeRecipes.length || 0,
            customDatasets: ac.customDatasets && ac.customDatasets.length || 0,
            customDialects: ac.customDialects && ac.customDialects.length || 0,
            customExporters: ac.customExporters && ac.customExporters.length || 0,
            customFSProviders: ac.customFSProviders && ac.customFSProviders.length || 0,
            customJavaFormats: ac.customJavaFormats && ac.customJavaFormats.length || 0,
            customJythonProcessors: ac.customJythonProcessors && ac.customJythonProcessors.length || 0,
            customPythonChecks: ac.customPythonChecks && ac.customPythonChecks.length || 0,
            customPythonFormats: ac.customPythonFormats && ac.customPythonFormats.length || 0,
            customPythonPluginSteps: ac.customPythonPluginSteps && ac.customPythonPluginSteps.length || 0,
            customPythonPluginTriggers: ac.customPythonPluginTriggers && ac.customPythonPluginTriggers.length || 0,
            customPythonProbes: ac.customPythonProbes && ac.customPythonProbes.length || 0,
            customRunnables: ac.customRunnables && ac.customRunnables.length || 0,
            customWebApps: ac.customWebApps && ac.customWebApps.length || 0,
            customSQLProbes: ac.customSQLProbes && ac.customSQLProbes.length || 0,
            nbHomeMessages: ac.homeMessages && ac.homeMessages.length || 0
        });

        if (ac && ac.version && ac.version.product_version && ac.version.product_version.includes('dev') && !window.localStorage.forceRollbar) {
            // Disable WT1 and Rollbar reporting for dev kits
            window.devInstance = true;
        }

        if (!$scope.appConfig.loggedIn) {
            /* Don't redirect to login access to the login or logout page */
            if ($location.path().indexOf("/login/") === 0 || $location.path().indexOf("/logged-out") === 0) {
                return;
            } else if ($scope.appConfig.licensingMode == 'NONE'){
                Logger.info("Not logged in, but registration flow active, not redirecting");
            } else if ($scope.isSAASAuth() && !$scope.appConfig.saasAccess.loggedIn) {
                Logger.info("You are not logged in, redirecting you ...");
                window.location = $scope.appConfig.saasUserURL + "/login/?redirectTo=" + window.location;
            } else if ($scope.isSAASAuth() && $scope.appConfig.saasAccess.loggedIn) {
                Logger.info("logged in but no SAAS access");
            } else if ($scope.appConfig.noLoginMode) {
                Logger.info("Not logged in, but no-login-mode enabled, getting an access token");
                DataikuAPI.noLoginLogin().success(function(data){
                    location.reload();
                });
            } else if ($scope.appConfig.ssoLoginEnabled) {
                if ($scope.appConfig.ssoProtocol == "SAML") {
                    if ($location.path()) {
                        Logger.info("Setting a post-SSO redirect to", $location.path());
                        localStorageService.set("postSSOLoginRedirect", $location.path());
                    }
                    DataikuAPI.getSAMLRedirectURL().success(function(data){
                        window.location = data.url;
                    });
                } else if ($scope.appConfig.ssoProtocol == "SPNEGO") {
                    Logger.info("SPNEGO mode, redirecting to login URL");
                    window.location = "/dip/api/spnego-login";
                }
            } else {
                Logger.info("You are not logged in, redirecting you ...");
                // Redirect to login
                $state.transitionTo("login", {redirectTo : $location.path()});
            }
        } else if (!$scope.appConfig.unattendedMode &&  // When launched by puppeteer and automated tools, do not display the licence warning
                    $scope.appConfig.licensing.expired) {
            var last = localStorageService.get("licenseExpired");
            if (!last || last <= Date.now() - 24 * 3600000) {
                Dialogs.ack($scope,
                    "License expired!",
                    "Your DSS license expired on " + (new Date($scope.appConfig.licensing.expiresOn)).toLocaleString()
                );
                localStorageService.set("licenseExpired", Date.now());
            }
        } else if (!$scope.appConfig.unattendedMode && // When launched by puppeteer and automated tools, do not display the licence warning
                $scope.appConfig.licensing.expiresOn &&  // 0 on Free Edition
                $scope.appConfig.licensing.expiresOn <= Date.now() + 7 * 24 * 3600000) {
            var last = localStorageService.get("licenseExpiring");
            if (!last || last <= Date.now() - 24 * 3600000) {
                Dialogs.ack($scope,
                    "License expires soon!",
                    "Your DSS license expires on " + (new Date($scope.appConfig.licensing.expiresOn)).toLocaleString()
                );
                localStorageService.set("licenseExpiring", Date.now());
            }
        } else {
            const redirectTo = localStorageService.get("postSSOLoginRedirect");
            if (redirectTo) {
                Logger.info("There is a post-SSO login redirect, following it", redirectTo);
                localStorageService.remove("postSSOLoginRedirect");
                window.location.pathname = redirectTo;  // Only follow redirects to a local path, not to another site
                return;
            }
        }
        $scope.onConfigurationLoaded();
    }).error(setErrorInScope.bind($scope));

    $scope.isDSSAdmin = function(permission) {
        return $scope.appConfig && $scope.appConfig.loggedIn && $scope.appConfig.admin;
    };
    $rootScope.isDSSAdmin = $scope.isDSSAdmin;


    $scope.canWriteInProjectFolder = function() {
        let currentFolder = ProjectFolderContext.getCurrentProjectFolder();
        return ProjectFolderContext.getCurrentProjectFolderId() && (currentFolder || {}).id == ProjectFolderContext.getCurrentProjectFolderId() ? (currentFolder && currentFolder.canWriteContents) : $rootScope.appConfig.globalPermissions.mayWriteInRootProjectFolder;
    };
    $rootScope.canWriteInProjectFolder = $scope.canWriteInProjectFolder;

    $scope.isPluginDeveloper = function() {
        return $scope.appConfig && $scope.appConfig.loggedIn && ($scope.appConfig.admin || $scope.appConfig.globalPermissions.mayDevelopPlugins);
    };

    $scope.isLibFolderEditor = function() {
        return $scope.appConfig && $scope.appConfig.loggedIn && ($scope.appConfig.admin || $scope.appConfig.globalPermissions.mayEditLibFolders);
    };

    $scope.mayWriteSafeCode = function() {
        return $scope.appConfig && $scope.appConfig.loggedIn &&
        ($scope.appConfig.admin || $scope.appConfig.globalPermissions.mayWriteUnsafeCode || ($scope.appConfig.impersonationEnabled && $scope.appConfig.globalPermissions.mayWriteSafeCode));
    };

    $scope.mayWriteUnsafeCode = function() {
        return $scope.appConfig && $scope.appConfig.loggedIn &&
        ($scope.appConfig.admin || $scope.appConfig.globalPermissions.mayWriteUnsafeCode);
    };

    $scope.mayCreateActiveWebContent = function() {
        return $scope.appConfig && $scope.appConfig.loggedIn &&
        ($scope.appConfig.admin || $scope.appConfig.globalPermissions.mayCreateActiveWebContent);
    };

    $scope.canSeeAdminMenu = function() {
        if (!$scope.appConfig || !$scope.appConfig.loggedIn) {
            return false;
        }
        /* Because of code envs, anybody must be allowed to access the administration screen 
         * (almost anybody will have at least "use") */
        return true;
    };

    $scope.openRequestTrialModal = function(){
        CreateModalFromTemplate("/templates/request-trial-modal.html", $scope);
    };

    $scope.logout = function(){
        if ($scope.isSAASAuth()) {
            window.location = $scope.appConfig.saasUserURL + "/logout/";
        } else {
            DataikuAPI.logout().success(function(data) {
                // Violent redirect to avoid keeping a cached appConfig
                if ($scope.appConfig && $scope.appConfig.postLogoutBehavior == "CUSTOM_URL") {
                    window.location = $scope.appConfig.postLogoutCustomURL;
                } else {
                    window.location = "/logged-out";
                }
            });
        }
    };

    /* ********************* Keyboard shortcuts handling ******************* */
    $scope.keyboardsModal = { shown : false };
    $scope.showKeyboardShortcuts = function() {
        if (!$scope.keyboardsModal.shown) {
        	$scope.closeContextualMenus();
            $scope.keyboardsModal.shown = true;
            CreateModalFromTemplate("/templates/shortcuts.html", $scope, null, function(newScope) {
                newScope.$on("$destroy", function(){ $scope.keyboardsModal.shown = false});
            });
        }
    }

    $rootScope.showAdminContactInfo = function(){
        CreateModalFromTemplate("/templates/dialogs/admin-contact.html", $scope);
    }

    Mousetrap.bind("?", function() {
        $scope.showKeyboardShortcuts();
        $scope.$apply();
    });

    Mousetrap.bind(": q", function() {
        window.location = "about:blank"
    })

    var goToView = function(viewRoute) {
        return function() {
            if ($stateParams.projectKey) {
                let zoneId = $scope.getDestZone();
                $state.go(viewRoute, {projectKey : $stateParams.projectKey, zoneId : zoneId}, {reload: true});
            }
        }
    };

    $scope.reloadPluginConfiguration = function() {
    	// reload config & descriptors for smoother plugin development
    	if ($rootScope.appConfig && $rootScope.appConfig.loggedIn) {
    		// no point if you're not already logged in
    		DataikuAPI.plugindev.reloadAll().success(function(data) {
        		DataikuAPI.getConfiguration().success(function(data) {
        			$rootScope.appConfig = data;
        			$scope.appConfig = data;
        			window.dkuAppConfig = data;
        			if ( CachedAPICalls != null ) {
        				// for custom datasets, so that the parameter list from the descriptors is refreshed
        				CachedAPICalls.datasetTypes = DataikuAPI.datasets.get_types();
        				// reload recipe types
        				RecipeDescService.load($scope);
        			}
        		});
    		});
    	}
    };

    Mousetrap.bind("@ r c d", $scope.reloadPluginConfiguration);
    Mousetrap.bind("g c", function() { $state.go("catalog.items", {}, {reload: true});  });
    Mousetrap.bind("g f", goToView("projects.project.flow"));
    Mousetrap.bind("g n", goToView("projects.project.notebooks.list"));
    Mousetrap.bind("g d", goToView("projects.project.datasets.list"));
    Mousetrap.bind("g r", goToView("projects.project.recipes.list"));
    Mousetrap.bind("g a", goToView("projects.project.analyses.list"));
    Mousetrap.bind("g p", goToView("projects.project.dashboards.list"));
    Mousetrap.bind("g i", goToView("projects.project.dashboards.insights.list"));
    Mousetrap.bind("g j", goToView("projects.project.jobs.list"));
    Mousetrap.bind("g w", goToView("projects.project.wiki"));
    Mousetrap.bind("g l", goToView("projects.project.libedition"));

    Mousetrap.bind("c h a m p i o n s", function() {
        $(".master-nav").addClass("master-nav-champions");
        $(".icon-dkubird").replaceWith("<img class='champions'>");
        $(".champions").attr("src","/static/dataiku/images/coq.png");
    });

    Mousetrap.bind("@ r b", function(){
        if ($state.current.name.startsWith("projects.project.webapps.webapp")){
            DataikuAPI.webapps.restartBackend({"projectKey":$stateParams.projectKey, "id":$stateParams.webAppId})
        }
    })

    Mousetrap.bind("s e u m", function() {
        $(".master-nav").addClass("master-nav-seum");
    });

    Mousetrap.bind("k i t t y", function() {
        CreateModalFromTemplate("/templates/kitty.html", $scope, null, function(newScope) {
            $timeout(function(){
                $rootScope.$broadcast("reflow")
            }, 0);
        });
    });

    Mousetrap.bind("r o c k e t", function() {
        if ($state.current.name.startsWith('projectdeployer')) {
            const sentences = [
                {msg: "I'm stepping through the door"},
                {error: true, msg: "Your circuit's dead, there's something wrong"},
                {error: true, msg:"Can you hear me, Major Tom?"},
                {msg: "Now it's time to leave the capsule if you dare"}
            ];

            CreateModalFromTemplate("/templates/rocket.html", $scope, null, function(newScope) {
                $scope.leaveMessage = sentences[Math.floor(Math.random()*sentences.length)];
                $timeout(function(){
                    $rootScope.$broadcast("reflow")
                }, 0);
            });
        }
    });

    Mousetrap.bind("p u p p y", function() {
        CreateModalFromTemplate("/templates/puppy.html", $scope, null, function(newScope) {
            $timeout(function(){
                $rootScope.$broadcast("reflow")
            }, 0);
        });
    });

    Mousetrap.bind("c o m i c", function() {
        var rnd = Math.floor(Math.random()*3);
        var font = ["'Comic Neue'", "cursive", "fantasy"][rnd];

        $("head").append($("<link rel='stylesheet' type='text/css' href='https://dku-assets.s3.amazonaws.com/comicneue/comicneue.css'>"));
        $("head").append($("<style>div, button, p, span, a, input, textarea { font-family: " + font + " !important;}</style>"));
    });

    function setColor(x) {
        $("body").css("background-color", x);
        $("#flow-graph").css("background-color", x);
    }

    Mousetrap.bind("s a r c e l l e", function() {
        if (Math.random() > 0.75) {
           setColor("#045067");
        } else {
            setColor("#2AB1AC");
        }
    });

    Mousetrap.bind("p i n k", function() {
            $("body").css("background-color", "pink");
    });

    Mousetrap.bind("p u r p l e", function() {
            $("body").css("background-color", "purple");
    });

    Mousetrap.bind("& @ &", function(){
        CreateModalFromTemplate("/templates/debugging-tools.html", $scope, "DebuggingToolsController");
    });

    function trollMe() {
        $("i").addClass("icon-spin");
        $(".avatar20").addClass("icon-spin");
        $(".avatar32").addClass("icon-spin");
        $(".avatar").addClass("icon-spin");
    }

    function untrollMe() {
        $("i").removeClass("icon-spin");
        $(".avatar20").removeClass("icon-spin");
        $(".avatar32").removeClass("icon-spin");
        $(".avatar").removeClass("icon-spin");
    }

    window.showNativeNotification = function(txt, tag, onclick, user) {
        if ("document.hasFocus", document.hasFocus()) return; // Only display notification when the user is not on the page
        if (window.Notification.permission === "default") {
            // User did not choose the notifications type yet, ask (but don't wait for the answer to display in-window notification)
            window.Notification.requestPermission(function (permission) {
                WT1.event("allow-browser-notification", {permission : permission});
            });
        } else if (window.Notification.permission === "granted") {
            // User native browser Notifications
            var options = {
                icon: UserImageUrl(user || $rootScope.appConfig.login, 200),
                dir: "ltr",
                tag: tag,
                renotify: false,
                silent: true
            };
            var notification = new window.Notification(txt, options);

            notification.onclick = (function(onclick) {return function () {
                window.focus();
                if (onclick) onclick();
                this.close();
            };})(onclick);

            var timeout = setTimeout((function(n){return function(){ n.close()}; }(notification)), 5000);// native notifications have no custom timeout
        }
    }

    Notification.registerEvent('spinnee-troll',function() {
        trollMe();
    });

    Notification.registerEvent('spinnee-untroll',function() {
        untrollMe();
    });

    Mousetrap.bind("w h e e e", function() {
        // Troll others
        Notification.broadcastToOtherSessions('spinnee-troll',{lol:"salut"});

        // Untroll me
        untrollMe();
    });

    Mousetrap.bind("w h o o o", function() {
        // Untroll everyone
        Notification.broadcastToFrontends('spinnee-untroll',{lol:"salut"});
    })

    function fallingBird() {
        $(".icon-dkubird").css("visibility", "hidden");
        var falling = $("<i class='icon-dkubird falling-bird' />");
        $("body").append(falling);
        $("body").append($("<audio src='/static/dataiku/css/rifle.mp3' autoplay/>"));
        window.setTimeout(function(){falling.css("top", "105%")}, 10);
    }

    Mousetrap.bind("p a n", fallingBird);
    Mousetrap.bind("b a n g", fallingBird);

    Mousetrap.bind("s o n i a", function fallingBird() {
        $("body").append($("<audio src='/static/dataiku/css/sonia.mp3' autoplay/>"));
    });

    Mousetrap.bind("f u r y r o a d", function() {
        if ($state.current.name.startsWith('apideployer')) {
            $('head').append($('<style>@keyframes furyroad{from{left:0%;}to{left:100%;}}</style>'));
            $('body').append($('<div style="position: fixed; height: 400px; width: 600px; bottom: 0; animation-name: furyroad; animation-duration: 4s; animation-timing-function: ease-in-out; animation-iteration-count: infinite;"><svg viewBox="0 0 600 400"><circle cx="145" cy="295" r="30" fill="#6b6c69" stroke="#000"/><circle cx="145" cy="295" r="20" fill="#907354" stroke="#000"/><circle cx="145" cy="295" r="5" fill="#6b6c69" stroke="#000"/><circle cx="395" cy="295" r="30" fill="#6b6c69" stroke="#000"/><circle cx="395" cy="295" r="20" fill="#907354" stroke="#000"/><circle cx="395" cy="295" r="5" fill="#6b6c69" stroke="#000"/><path d="m100 300v-100q0-20 20-20h100q30 0 50 20l10 10q20 20 50 20l100-10q10 0 10 10v70h-10v-10q-7-13-20-20h-30q-13 7-20 20v10h-180v-10q-7-13-20-20h-30q-13 7-20 20v10h-10z" fill="#907354" stroke="#000"/><path d="m110 260q35-20 70 0l40 20q20 10 40 10" fill="transparent" stroke="#000"/><path d="m110 230v-30q0-10 10-10h50v40h-60z" fill="#ba9e9a" stroke="#000"/><path d="m180 230v-40h50q20 5 40 25v15h-90z" fill="#ba9e9a" stroke="#000"/><path d="m422 240l20-10q5-5 10 0v30q-5 5-10 0l-20-10q-5-5 0-10z" fill="#7d4842" stroke="#000"/><path d="m100 290l-80-40v-15l80 50v5z" fill="#6b6c69" stroke="#000"/><path d="m100 280l-80-60v-20l80 75v5z" fill="#6b6c69" stroke="#000"/><path d="m418 220l4-200h-2v-10h6v10h-2l-4 200h-2z" fill="#444" stroke="#000"/><path d="m422 220l10-200h-2v-10h6v10h-2l-10 200h-2z" fill="#444" stroke="#000"/><path d="m120 180l-30-50 40 50z" fill="#7d4842" stroke="#000"/><path d="m140 180l10-40v40z" fill="#7d4842" stroke="#000"/><path d="m170 180l-10-80 20 80z" fill="#7d4842" stroke="#000"/><path d="m190 180l-20-50 30 50z" fill="#7d4842" stroke="#000"/><path d="m210 180l40-50-30 50z" fill="#7d4842" stroke="#000"/><path d="m220 180l10-90v90z" fill="#7d4842" stroke="#000"/><path d="m130 180l-30-100 40 100z" fill="#7d4842" stroke="#000"/><path d="m155 180l-10-90 20 90z" fill="#7d4842" stroke="#000"/><path d="m180 180l20-80-10 80z" fill="#7d4842" stroke="#000"/><path d="m195 180v-120l10 120z" fill="#7d4842" stroke="#000"/><path d="m205 180l10-50v50z" fill="#7d4842" stroke="#000"/><path d="m330 230l-20-50 30 49z" fill="#7d4842" stroke="#000"/><path d="m352 228l10-40v38z" fill="#7d4842" stroke="#000"/><path d="m370 226l-10-80 20 79z" fill="#7d4842" stroke="#000"/><path d="m388 224l25-50-15 49z" fill="#7d4842" stroke="#000"/><path d="m410 222l-20-120 30 118z" fill="#7d4842" stroke="#000"/><path d="m420 220l30-90-20 90z" fill="#7d4842" stroke="#000"/><path d="m340 229l10-90v89z" fill="#7d4842" stroke="#000"/><path d="m358 227l50-120-40 119z" fill="#7d4842" stroke="#000"/></svg></div>'));
        }
    });

    Mousetrap.bind("n e y m a r", function() {
        $('head').append($('<style>@keyframes neymar{from{left:0%;transform:rotate(0deg);}to{left:100%;transform:rotate(4000deg);}}</style>'));
        const el = $('.icon-dkubird');
        el.css('position', 'absolute').css('color', 'yellow').css('background', '#184bad').css('top', '12px').css('animation-name', 'neymar').css('animation-duration', '10s').css('animation-timing-function', 'linear').css('animation-iteration-count', 'infinite');
    });

    Mousetrap.bind("b i g b r o t h e r", function() {
        $('body').append($('<div style="position: absolute;z-index: 2147483647000;bottom: 0;left: 0;right: 0;width: 100%;height: 415px;background: white;box-shadow: #121212 2px 2px 14px 2px;"><div style="margin: 20px auto;width: 450px;"><h4>This website uses quotes <i class="icon-eye-open"/></h4><p style=" line-height: 1.6em; font-size: 1.2em;">“He thought of the telescreen with its never-sleeping ear. They could spy upon you night and day, but if you kept your head you could still outwit them. With all their cleverness they had never mastered the secret of finding out what another human being was thinking. . . . Facts, at any rate, could not be kept hidden. They could be tracked down by inquiry, they could be squeezed out of you by torture. But if the object was not to stay alive but to stay human, what difference did it ultimately make? They could not alter your feelings; for that matter you could not alter them yourself, even if you wanted to. They could lay bare in the utmost detail everything that you had done or said or thought; but the inner heart, whose workings were mysterious even to yourself, remained impregnable.”</p><p class="" style="text-align: right;font-weight: bold;">― George Orwell, 1984</p><div><button class="btn btn--primary pull-right">2 + 2 = 5</button></div></div></div>'));
        $('body').append($('<div style="position: absolute;z-index: 2147483647000;top: 0;left: 0;right: 0;width: 100%;height: 150px;background: white;box-shadow: #121212 2px 2px 14px 2px;"><div style="margin: 20px auto;width: 450px;"><div class="alert alert-danger">Warning angry cookies</div><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAYWSURBVGhD7VntU1RVGHf6UP0FNVOyb6z7cu/de++CgiE0vGqZExIKgiAi6iTCIqCiIqDZjFZDGjiZTpqAmIqShhNmmk5NHypzaqaZBLIPOdVk04uwCAVyOr/b2W2XvazLyq5+2N/Mb/ZwznOfl3vOec5zD9MiiCCCCCKI4EGBwSA+pjVwxTZBPinyUp9phjigN/CjOgM/ptVz+UzMB0aj8ZH0uNiugrS4XvzibzYUXkTprUkiJ102m8WhlVnpzvb6ZeTqAQe52bmZDHfXk1lyzC2tlrcycR/MluXNrWvT7nTXPENaStPuPGW317Ch8CDKyEfbaACiYB9qqS0cc56tI6PnG3wYbeRHtFrto+wxH8BxBOAKJEGyb2RDoYfeKCylMzD4uiNn9FZXrWoALibFxfXrdNan2aM+cC+tjPiesC4ti0ncIfLy8Jf7ylUdH8/j24rGOIv0g8HAaZiK+w+LRW5ImhU/eOP4RlWnJ2Jj+eJ/jDOEv5ia+wujUSiw0Zm4cWJyQYDnG1cTOotXmCo3BEGwPJ8Y+/WChJnfmM02M+sOHTQamwF74qv9gS2n8XxrQx4xzxD3MnVuJNrl3e9VzyOnq+cStFl36IDs1OhYNKrmpCf72qpIc8Ui5dezH4GYTLY3mDo3TKb/Z8RiEU2sWwE2fWKMvCNekpJZ171BOSdoiu3v2urlnBod2SnK23Vkp3r1d+0qIZLNfpmpDAgJNIj9q1PHMufM7GVd9waRky+10nPC07GJiAA6q+aRchqQZ/+fZ2oxI0M4/ZnauyJe4pNpEH3JsfIZ1hU89HrhcZzYA2fvPhvg90eqSFNFNrneXu0zVlecOWyxSMeY6vACtdOqrLnO8U6h9Dj5UhHZu24xuXa40mtsIuJlJM+Od9JzaA9V/dB/FsIEgbd3oHbydAhBVCxOJwdfTFOWUUN+Cjm7a4WXzET8jdZfC1OTnDwn9Wr03NLp06UnOY57mJ78Wo1eKIiKMj/BTE8tUMVePeCdcju2F5G3aRCojVzckJvmJeOPIx82kO5XV5L8+an9AicN0gr5jo2XBhckJ962mMW+yeyjgEE3qBNv0dMRLKfOqrnegeR4Z6lg2Vi+6G+zyTYoWOUzRqOtiR6in5hM4jXmTvDA98RQt3dVe+2dSlKfl+IOAkHVF833ksE5glRc/kIqTQC+G98ff+6oIZ0vFytnD2YOPjB3godaIGDXzhV0OWWQ9XQmGpY/R/44vcVrvMmRTVwnNtqeY5Ph7Q/qpiYQLK2bnZtUjfhjX1u1e0aut69XlQmEsA0fmDvBQ22zh4NX3iojX1DiU0Hi7T3MneAh8FLHkTrv9BsOtm0tVKoB/PK8fJy5Ezy0Wm55SVbGgJoxEGv48OZ8hWirybgIxw5uXEIO1ixR2moy47kiM31Ap+OKmDvBAzkdJcpEBeOWwmdJW1m6QrTVZMDfaTIoy0oh75ZnKCxdmDxhMN8eWkfOvbaKwCbdH8NTdq7QovHj9rplqkUjspYrDaOtJgNiJo46MtyyR2kwh2ryVGV3rM4iw+fqSWttwRg9Ry4wN+4dUQYucZYc60RpMt4oZqFlbbrCWj8zAqcDCeQ7Wre9v7NEWaaxUoxTY+DnMDemBjarfKm5MndkvGEYbNmylL49/3sE5wyWEwIA1/hZWuCeipwRnrN/xMxPHTQaUY9P3UBvTtSobHa60Q9tyvMJApXx9pULlfbn+8qI2SQ5tVqzjpmfWhgMXJ7ABXf54I9IBPUlmeQnqhe3M7Chi7bmMLOhAf2ursN10I/HNqg6NVni7WMmMEPQCd2wwcyFFlaztB3XQnBCzblA2NNaRXatySanaHGIv6ELOs1maRszEx7oosVcWm47mypzVYtKTyIJ/EIr2s+aS8mb6/PIK6XZuH0kuCvGs7sdOSPQFfLlNBGQAASrdDFGsg8i56vdASNb7a1aQtrqCsmnzWvcmxyyeAYplu6JCyHb2JOBJppPoMviIioAlBSoj3CR9+upTcobB9FGH8aKM9P6ISvQww7PMjUPDlBKoC6iQZ2gn669rn/0gGhLvNyDMciE5HM2gggiiCCCCILCtGn/AgQAuiyJeko6AAAAAElFTkSuQmCC"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAYWSURBVGhD7VntU1RVGHf6UP0FNVOyb6z7cu/de++CgiE0vGqZExIKgiAi6iTCIqCiIqDZjFZDGjiZTpqAmIqShhNmmk5NHypzaqaZBLIPOdVk04uwCAVyOr/b2W2XvazLyq5+2N/Mb/ZwznOfl3vOec5zD9MiiCCCCCKI4EGBwSA+pjVwxTZBPinyUp9phjigN/CjOgM/ptVz+UzMB0aj8ZH0uNiugrS4XvzibzYUXkTprUkiJ102m8WhlVnpzvb6ZeTqAQe52bmZDHfXk1lyzC2tlrcycR/MluXNrWvT7nTXPENaStPuPGW317Ch8CDKyEfbaACiYB9qqS0cc56tI6PnG3wYbeRHtFrto+wxH8BxBOAKJEGyb2RDoYfeKCylMzD4uiNn9FZXrWoALibFxfXrdNan2aM+cC+tjPiesC4ti0ncIfLy8Jf7ylUdH8/j24rGOIv0g8HAaZiK+w+LRW5ImhU/eOP4RlWnJ2Jj+eJ/jDOEv5ia+wujUSiw0Zm4cWJyQYDnG1cTOotXmCo3BEGwPJ8Y+/WChJnfmM02M+sOHTQamwF74qv9gS2n8XxrQx4xzxD3MnVuJNrl3e9VzyOnq+cStFl36IDs1OhYNKrmpCf72qpIc8Ui5dezH4GYTLY3mDo3TKb/Z8RiEU2sWwE2fWKMvCNekpJZ171BOSdoiu3v2urlnBod2SnK23Vkp3r1d+0qIZLNfpmpDAgJNIj9q1PHMufM7GVd9waRky+10nPC07GJiAA6q+aRchqQZ/+fZ2oxI0M4/ZnauyJe4pNpEH3JsfIZ1hU89HrhcZzYA2fvPhvg90eqSFNFNrneXu0zVlecOWyxSMeY6vACtdOqrLnO8U6h9Dj5UhHZu24xuXa40mtsIuJlJM+Od9JzaA9V/dB/FsIEgbd3oHbydAhBVCxOJwdfTFOWUUN+Cjm7a4WXzET8jdZfC1OTnDwn9Wr03NLp06UnOY57mJ78Wo1eKIiKMj/BTE8tUMVePeCdcju2F5G3aRCojVzckJvmJeOPIx82kO5XV5L8+an9AicN0gr5jo2XBhckJ962mMW+yeyjgEE3qBNv0dMRLKfOqrnegeR4Z6lg2Vi+6G+zyTYoWOUzRqOtiR6in5hM4jXmTvDA98RQt3dVe+2dSlKfl+IOAkHVF833ksE5glRc/kIqTQC+G98ff+6oIZ0vFytnD2YOPjB3godaIGDXzhV0OWWQ9XQmGpY/R/44vcVrvMmRTVwnNtqeY5Ph7Q/qpiYQLK2bnZtUjfhjX1u1e0aut69XlQmEsA0fmDvBQ22zh4NX3iojX1DiU0Hi7T3MneAh8FLHkTrv9BsOtm0tVKoB/PK8fJy5Ezy0Wm55SVbGgJoxEGv48OZ8hWirybgIxw5uXEIO1ixR2moy47kiM31Ap+OKmDvBAzkdJcpEBeOWwmdJW1m6QrTVZMDfaTIoy0oh75ZnKCxdmDxhMN8eWkfOvbaKwCbdH8NTdq7QovHj9rplqkUjspYrDaOtJgNiJo46MtyyR2kwh2ryVGV3rM4iw+fqSWttwRg9Ry4wN+4dUQYucZYc60RpMt4oZqFlbbrCWj8zAqcDCeQ7Wre9v7NEWaaxUoxTY+DnMDemBjarfKm5MndkvGEYbNmylL49/3sE5wyWEwIA1/hZWuCeipwRnrN/xMxPHTQaUY9P3UBvTtSobHa60Q9tyvMJApXx9pULlfbn+8qI2SQ5tVqzjpmfWhgMXJ7ABXf54I9IBPUlmeQnqhe3M7Chi7bmMLOhAf2ursN10I/HNqg6NVni7WMmMEPQCd2wwcyFFlaztB3XQnBCzblA2NNaRXatySanaHGIv6ELOs1maRszEx7oosVcWm47mypzVYtKTyIJ/EIr2s+aS8mb6/PIK6XZuH0kuCvGs7sdOSPQFfLlNBGQAASrdDFGsg8i56vdASNb7a1aQtrqCsmnzWvcmxyyeAYplu6JCyHb2JOBJppPoMviIioAlBSoj3CR9+upTcobB9FGH8aKM9P6ISvQww7PMjUPDlBKoC6iQZ2gn669rn/0gGhLvNyDMciE5HM2gggiiCCCCILCtGn/AgQAuiyJeko6AAAAAElFTkSuQmCC"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAYWSURBVGhD7VntU1RVGHf6UP0FNVOyb6z7cu/de++CgiE0vGqZExIKgiAi6iTCIqCiIqDZjFZDGjiZTpqAmIqShhNmmk5NHypzaqaZBLIPOdVk04uwCAVyOr/b2W2XvazLyq5+2N/Mb/ZwznOfl3vOec5zD9MiiCCCCCKI4EGBwSA+pjVwxTZBPinyUp9phjigN/CjOgM/ptVz+UzMB0aj8ZH0uNiugrS4XvzibzYUXkTprUkiJ102m8WhlVnpzvb6ZeTqAQe52bmZDHfXk1lyzC2tlrcycR/MluXNrWvT7nTXPENaStPuPGW317Ch8CDKyEfbaACiYB9qqS0cc56tI6PnG3wYbeRHtFrto+wxH8BxBOAKJEGyb2RDoYfeKCylMzD4uiNn9FZXrWoALibFxfXrdNan2aM+cC+tjPiesC4ti0ncIfLy8Jf7ylUdH8/j24rGOIv0g8HAaZiK+w+LRW5ImhU/eOP4RlWnJ2Jj+eJ/jDOEv5ia+wujUSiw0Zm4cWJyQYDnG1cTOotXmCo3BEGwPJ8Y+/WChJnfmM02M+sOHTQamwF74qv9gS2n8XxrQx4xzxD3MnVuJNrl3e9VzyOnq+cStFl36IDs1OhYNKrmpCf72qpIc8Ui5dezH4GYTLY3mDo3TKb/Z8RiEU2sWwE2fWKMvCNekpJZ171BOSdoiu3v2urlnBod2SnK23Vkp3r1d+0qIZLNfpmpDAgJNIj9q1PHMufM7GVd9waRky+10nPC07GJiAA6q+aRchqQZ/+fZ2oxI0M4/ZnauyJe4pNpEH3JsfIZ1hU89HrhcZzYA2fvPhvg90eqSFNFNrneXu0zVlecOWyxSMeY6vACtdOqrLnO8U6h9Dj5UhHZu24xuXa40mtsIuJlJM+Od9JzaA9V/dB/FsIEgbd3oHbydAhBVCxOJwdfTFOWUUN+Cjm7a4WXzET8jdZfC1OTnDwn9Wr03NLp06UnOY57mJ78Wo1eKIiKMj/BTE8tUMVePeCdcju2F5G3aRCojVzckJvmJeOPIx82kO5XV5L8+an9AicN0gr5jo2XBhckJ962mMW+yeyjgEE3qBNv0dMRLKfOqrnegeR4Z6lg2Vi+6G+zyTYoWOUzRqOtiR6in5hM4jXmTvDA98RQt3dVe+2dSlKfl+IOAkHVF833ksE5glRc/kIqTQC+G98ff+6oIZ0vFytnD2YOPjB3godaIGDXzhV0OWWQ9XQmGpY/R/44vcVrvMmRTVwnNtqeY5Ph7Q/qpiYQLK2bnZtUjfhjX1u1e0aut69XlQmEsA0fmDvBQ22zh4NX3iojX1DiU0Hi7T3MneAh8FLHkTrv9BsOtm0tVKoB/PK8fJy5Ezy0Wm55SVbGgJoxEGv48OZ8hWirybgIxw5uXEIO1ixR2moy47kiM31Ap+OKmDvBAzkdJcpEBeOWwmdJW1m6QrTVZMDfaTIoy0oh75ZnKCxdmDxhMN8eWkfOvbaKwCbdH8NTdq7QovHj9rplqkUjspYrDaOtJgNiJo46MtyyR2kwh2ryVGV3rM4iw+fqSWttwRg9Ry4wN+4dUQYucZYc60RpMt4oZqFlbbrCWj8zAqcDCeQ7Wre9v7NEWaaxUoxTY+DnMDemBjarfKm5MndkvGEYbNmylL49/3sE5wyWEwIA1/hZWuCeipwRnrN/xMxPHTQaUY9P3UBvTtSobHa60Q9tyvMJApXx9pULlfbn+8qI2SQ5tVqzjpmfWhgMXJ7ABXf54I9IBPUlmeQnqhe3M7Chi7bmMLOhAf2ursN10I/HNqg6NVni7WMmMEPQCd2wwcyFFlaztB3XQnBCzblA2NNaRXatySanaHGIv6ELOs1maRszEx7oosVcWm47mypzVYtKTyIJ/EIr2s+aS8mb6/PIK6XZuH0kuCvGs7sdOSPQFfLlNBGQAASrdDFGsg8i56vdASNb7a1aQtrqCsmnzWvcmxyyeAYplu6JCyHb2JOBJppPoMviIioAlBSoj3CR9+upTcobB9FGH8aKM9P6ISvQww7PMjUPDlBKoC6iQZ2gn669rn/0gGhLvNyDMciE5HM2gggiiCCCCILCtGn/AgQAuiyJeko6AAAAAElFTkSuQmCC"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAYWSURBVGhD7VntU1RVGHf6UP0FNVOyb6z7cu/de++CgiE0vGqZExIKgiAi6iTCIqCiIqDZjFZDGjiZTpqAmIqShhNmmk5NHypzaqaZBLIPOdVk04uwCAVyOr/b2W2XvazLyq5+2N/Mb/ZwznOfl3vOec5zD9MiiCCCCCKI4EGBwSA+pjVwxTZBPinyUp9phjigN/CjOgM/ptVz+UzMB0aj8ZH0uNiugrS4XvzibzYUXkTprUkiJ102m8WhlVnpzvb6ZeTqAQe52bmZDHfXk1lyzC2tlrcycR/MluXNrWvT7nTXPENaStPuPGW317Ch8CDKyEfbaACiYB9qqS0cc56tI6PnG3wYbeRHtFrto+wxH8BxBOAKJEGyb2RDoYfeKCylMzD4uiNn9FZXrWoALibFxfXrdNan2aM+cC+tjPiesC4ti0ncIfLy8Jf7ylUdH8/j24rGOIv0g8HAaZiK+w+LRW5ImhU/eOP4RlWnJ2Jj+eJ/jDOEv5ia+wujUSiw0Zm4cWJyQYDnG1cTOotXmCo3BEGwPJ8Y+/WChJnfmM02M+sOHTQamwF74qv9gS2n8XxrQx4xzxD3MnVuJNrl3e9VzyOnq+cStFl36IDs1OhYNKrmpCf72qpIc8Ui5dezH4GYTLY3mDo3TKb/Z8RiEU2sWwE2fWKMvCNekpJZ171BOSdoiu3v2urlnBod2SnK23Vkp3r1d+0qIZLNfpmpDAgJNIj9q1PHMufM7GVd9waRky+10nPC07GJiAA6q+aRchqQZ/+fZ2oxI0M4/ZnauyJe4pNpEH3JsfIZ1hU89HrhcZzYA2fvPhvg90eqSFNFNrneXu0zVlecOWyxSMeY6vACtdOqrLnO8U6h9Dj5UhHZu24xuXa40mtsIuJlJM+Od9JzaA9V/dB/FsIEgbd3oHbydAhBVCxOJwdfTFOWUUN+Cjm7a4WXzET8jdZfC1OTnDwn9Wr03NLp06UnOY57mJ78Wo1eKIiKMj/BTE8tUMVePeCdcju2F5G3aRCojVzckJvmJeOPIx82kO5XV5L8+an9AicN0gr5jo2XBhckJ962mMW+yeyjgEE3qBNv0dMRLKfOqrnegeR4Z6lg2Vi+6G+zyTYoWOUzRqOtiR6in5hM4jXmTvDA98RQt3dVe+2dSlKfl+IOAkHVF833ksE5glRc/kIqTQC+G98ff+6oIZ0vFytnD2YOPjB3godaIGDXzhV0OWWQ9XQmGpY/R/44vcVrvMmRTVwnNtqeY5Ph7Q/qpiYQLK2bnZtUjfhjX1u1e0aut69XlQmEsA0fmDvBQ22zh4NX3iojX1DiU0Hi7T3MneAh8FLHkTrv9BsOtm0tVKoB/PK8fJy5Ezy0Wm55SVbGgJoxEGv48OZ8hWirybgIxw5uXEIO1ixR2moy47kiM31Ap+OKmDvBAzkdJcpEBeOWwmdJW1m6QrTVZMDfaTIoy0oh75ZnKCxdmDxhMN8eWkfOvbaKwCbdH8NTdq7QovHj9rplqkUjspYrDaOtJgNiJo46MtyyR2kwh2ryVGV3rM4iw+fqSWttwRg9Ry4wN+4dUQYucZYc60RpMt4oZqFlbbrCWj8zAqcDCeQ7Wre9v7NEWaaxUoxTY+DnMDemBjarfKm5MndkvGEYbNmylL49/3sE5wyWEwIA1/hZWuCeipwRnrN/xMxPHTQaUY9P3UBvTtSobHa60Q9tyvMJApXx9pULlfbn+8qI2SQ5tVqzjpmfWhgMXJ7ABXf54I9IBPUlmeQnqhe3M7Chi7bmMLOhAf2ursN10I/HNqg6NVni7WMmMEPQCd2wwcyFFlaztB3XQnBCzblA2NNaRXatySanaHGIv6ELOs1maRszEx7oosVcWm47mypzVYtKTyIJ/EIr2s+aS8mb6/PIK6XZuH0kuCvGs7sdOSPQFfLlNBGQAASrdDFGsg8i56vdASNb7a1aQtrqCsmnzWvcmxyyeAYplu6JCyHb2JOBJppPoMviIioAlBSoj3CR9+upTcobB9FGH8aKM9P6ISvQww7PMjUPDlBKoC6iQZ2gn669rn/0gGhLvNyDMciE5HM2gggiiCCCCILCtGn/AgQAuiyJeko6AAAAAElFTkSuQmCC"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAYWSURBVGhD7VntU1RVGHf6UP0FNVOyb6z7cu/de++CgiE0vGqZExIKgiAi6iTCIqCiIqDZjFZDGjiZTpqAmIqShhNmmk5NHypzaqaZBLIPOdVk04uwCAVyOr/b2W2XvazLyq5+2N/Mb/ZwznOfl3vOec5zD9MiiCCCCCKI4EGBwSA+pjVwxTZBPinyUp9phjigN/CjOgM/ptVz+UzMB0aj8ZH0uNiugrS4XvzibzYUXkTprUkiJ102m8WhlVnpzvb6ZeTqAQe52bmZDHfXk1lyzC2tlrcycR/MluXNrWvT7nTXPENaStPuPGW317Ch8CDKyEfbaACiYB9qqS0cc56tI6PnG3wYbeRHtFrto+wxH8BxBOAKJEGyb2RDoYfeKCylMzD4uiNn9FZXrWoALibFxfXrdNan2aM+cC+tjPiesC4ti0ncIfLy8Jf7ylUdH8/j24rGOIv0g8HAaZiK+w+LRW5ImhU/eOP4RlWnJ2Jj+eJ/jDOEv5ia+wujUSiw0Zm4cWJyQYDnG1cTOotXmCo3BEGwPJ8Y+/WChJnfmM02M+sOHTQamwF74qv9gS2n8XxrQx4xzxD3MnVuJNrl3e9VzyOnq+cStFl36IDs1OhYNKrmpCf72qpIc8Ui5dezH4GYTLY3mDo3TKb/Z8RiEU2sWwE2fWKMvCNekpJZ171BOSdoiu3v2urlnBod2SnK23Vkp3r1d+0qIZLNfpmpDAgJNIj9q1PHMufM7GVd9waRky+10nPC07GJiAA6q+aRchqQZ/+fZ2oxI0M4/ZnauyJe4pNpEH3JsfIZ1hU89HrhcZzYA2fvPhvg90eqSFNFNrneXu0zVlecOWyxSMeY6vACtdOqrLnO8U6h9Dj5UhHZu24xuXa40mtsIuJlJM+Od9JzaA9V/dB/FsIEgbd3oHbydAhBVCxOJwdfTFOWUUN+Cjm7a4WXzET8jdZfC1OTnDwn9Wr03NLp06UnOY57mJ78Wo1eKIiKMj/BTE8tUMVePeCdcju2F5G3aRCojVzckJvmJeOPIx82kO5XV5L8+an9AicN0gr5jo2XBhckJ962mMW+yeyjgEE3qBNv0dMRLKfOqrnegeR4Z6lg2Vi+6G+zyTYoWOUzRqOtiR6in5hM4jXmTvDA98RQt3dVe+2dSlKfl+IOAkHVF833ksE5glRc/kIqTQC+G98ff+6oIZ0vFytnD2YOPjB3godaIGDXzhV0OWWQ9XQmGpY/R/44vcVrvMmRTVwnNtqeY5Ph7Q/qpiYQLK2bnZtUjfhjX1u1e0aut69XlQmEsA0fmDvBQ22zh4NX3iojX1DiU0Hi7T3MneAh8FLHkTrv9BsOtm0tVKoB/PK8fJy5Ezy0Wm55SVbGgJoxEGv48OZ8hWirybgIxw5uXEIO1ixR2moy47kiM31Ap+OKmDvBAzkdJcpEBeOWwmdJW1m6QrTVZMDfaTIoy0oh75ZnKCxdmDxhMN8eWkfOvbaKwCbdH8NTdq7QovHj9rplqkUjspYrDaOtJgNiJo46MtyyR2kwh2ryVGV3rM4iw+fqSWttwRg9Ry4wN+4dUQYucZYc60RpMt4oZqFlbbrCWj8zAqcDCeQ7Wre9v7NEWaaxUoxTY+DnMDemBjarfKm5MndkvGEYbNmylL49/3sE5wyWEwIA1/hZWuCeipwRnrN/xMxPHTQaUY9P3UBvTtSobHa60Q9tyvMJApXx9pULlfbn+8qI2SQ5tVqzjpmfWhgMXJ7ABXf54I9IBPUlmeQnqhe3M7Chi7bmMLOhAf2ursN10I/HNqg6NVni7WMmMEPQCd2wwcyFFlaztB3XQnBCzblA2NNaRXatySanaHGIv6ELOs1maRszEx7oosVcWm47mypzVYtKTyIJ/EIr2s+aS8mb6/PIK6XZuH0kuCvGs7sdOSPQFfLlNBGQAASrdDFGsg8i56vdASNb7a1aQtrqCsmnzWvcmxyyeAYplu6JCyHb2JOBJppPoMviIioAlBSoj3CR9+upTcobB9FGH8aKM9P6ISvQww7PMjUPDlBKoC6iQZ2gn669rn/0gGhLvNyDMciE5HM2gggiiCCCCILCtGn/AgQAuiyJeko6AAAAAElFTkSuQmCC"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAYWSURBVGhD7VntU1RVGHf6UP0FNVOyb6z7cu/de++CgiE0vGqZExIKgiAi6iTCIqCiIqDZjFZDGjiZTpqAmIqShhNmmk5NHypzaqaZBLIPOdVk04uwCAVyOr/b2W2XvazLyq5+2N/Mb/ZwznOfl3vOec5zD9MiiCCCCCKI4EGBwSA+pjVwxTZBPinyUp9phjigN/CjOgM/ptVz+UzMB0aj8ZH0uNiugrS4XvzibzYUXkTprUkiJ102m8WhlVnpzvb6ZeTqAQe52bmZDHfXk1lyzC2tlrcycR/MluXNrWvT7nTXPENaStPuPGW317Ch8CDKyEfbaACiYB9qqS0cc56tI6PnG3wYbeRHtFrto+wxH8BxBOAKJEGyb2RDoYfeKCylMzD4uiNn9FZXrWoALibFxfXrdNan2aM+cC+tjPiesC4ti0ncIfLy8Jf7ylUdH8/j24rGOIv0g8HAaZiK+w+LRW5ImhU/eOP4RlWnJ2Jj+eJ/jDOEv5ia+wujUSiw0Zm4cWJyQYDnG1cTOotXmCo3BEGwPJ8Y+/WChJnfmM02M+sOHTQamwF74qv9gS2n8XxrQx4xzxD3MnVuJNrl3e9VzyOnq+cStFl36IDs1OhYNKrmpCf72qpIc8Ui5dezH4GYTLY3mDo3TKb/Z8RiEU2sWwE2fWKMvCNekpJZ171BOSdoiu3v2urlnBod2SnK23Vkp3r1d+0qIZLNfpmpDAgJNIj9q1PHMufM7GVd9waRky+10nPC07GJiAA6q+aRchqQZ/+fZ2oxI0M4/ZnauyJe4pNpEH3JsfIZ1hU89HrhcZzYA2fvPhvg90eqSFNFNrneXu0zVlecOWyxSMeY6vACtdOqrLnO8U6h9Dj5UhHZu24xuXa40mtsIuJlJM+Od9JzaA9V/dB/FsIEgbd3oHbydAhBVCxOJwdfTFOWUUN+Cjm7a4WXzET8jdZfC1OTnDwn9Wr03NLp06UnOY57mJ78Wo1eKIiKMj/BTE8tUMVePeCdcju2F5G3aRCojVzckJvmJeOPIx82kO5XV5L8+an9AicN0gr5jo2XBhckJ962mMW+yeyjgEE3qBNv0dMRLKfOqrnegeR4Z6lg2Vi+6G+zyTYoWOUzRqOtiR6in5hM4jXmTvDA98RQt3dVe+2dSlKfl+IOAkHVF833ksE5glRc/kIqTQC+G98ff+6oIZ0vFytnD2YOPjB3godaIGDXzhV0OWWQ9XQmGpY/R/44vcVrvMmRTVwnNtqeY5Ph7Q/qpiYQLK2bnZtUjfhjX1u1e0aut69XlQmEsA0fmDvBQ22zh4NX3iojX1DiU0Hi7T3MneAh8FLHkTrv9BsOtm0tVKoB/PK8fJy5Ezy0Wm55SVbGgJoxEGv48OZ8hWirybgIxw5uXEIO1ixR2moy47kiM31Ap+OKmDvBAzkdJcpEBeOWwmdJW1m6QrTVZMDfaTIoy0oh75ZnKCxdmDxhMN8eWkfOvbaKwCbdH8NTdq7QovHj9rplqkUjspYrDaOtJgNiJo46MtyyR2kwh2ryVGV3rM4iw+fqSWttwRg9Ry4wN+4dUQYucZYc60RpMt4oZqFlbbrCWj8zAqcDCeQ7Wre9v7NEWaaxUoxTY+DnMDemBjarfKm5MndkvGEYbNmylL49/3sE5wyWEwIA1/hZWuCeipwRnrN/xMxPHTQaUY9P3UBvTtSobHa60Q9tyvMJApXx9pULlfbn+8qI2SQ5tVqzjpmfWhgMXJ7ABXf54I9IBPUlmeQnqhe3M7Chi7bmMLOhAf2ursN10I/HNqg6NVni7WMmMEPQCd2wwcyFFlaztB3XQnBCzblA2NNaRXatySanaHGIv6ELOs1maRszEx7oosVcWm47mypzVYtKTyIJ/EIr2s+aS8mb6/PIK6XZuH0kuCvGs7sdOSPQFfLlNBGQAASrdDFGsg8i56vdASNb7a1aQtrqCsmnzWvcmxyyeAYplu6JCyHb2JOBJppPoMviIioAlBSoj3CR9+upTcobB9FGH8aKM9P6ISvQww7PMjUPDlBKoC6iQZ2gn669rn/0gGhLvNyDMciE5HM2gggiiCCCCILCtGn/AgQAuiyJeko6AAAAAElFTkSuQmCC"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAYWSURBVGhD7VntU1RVGHf6UP0FNVOyb6z7cu/de++CgiE0vGqZExIKgiAi6iTCIqCiIqDZjFZDGjiZTpqAmIqShhNmmk5NHypzaqaZBLIPOdVk04uwCAVyOr/b2W2XvazLyq5+2N/Mb/ZwznOfl3vOec5zD9MiiCCCCCKI4EGBwSA+pjVwxTZBPinyUp9phjigN/CjOgM/ptVz+UzMB0aj8ZH0uNiugrS4XvzibzYUXkTprUkiJ102m8WhlVnpzvb6ZeTqAQe52bmZDHfXk1lyzC2tlrcycR/MluXNrWvT7nTXPENaStPuPGW317Ch8CDKyEfbaACiYB9qqS0cc56tI6PnG3wYbeRHtFrto+wxH8BxBOAKJEGyb2RDoYfeKCylMzD4uiNn9FZXrWoALibFxfXrdNan2aM+cC+tjPiesC4ti0ncIfLy8Jf7ylUdH8/j24rGOIv0g8HAaZiK+w+LRW5ImhU/eOP4RlWnJ2Jj+eJ/jDOEv5ia+wujUSiw0Zm4cWJyQYDnG1cTOotXmCo3BEGwPJ8Y+/WChJnfmM02M+sOHTQamwF74qv9gS2n8XxrQx4xzxD3MnVuJNrl3e9VzyOnq+cStFl36IDs1OhYNKrmpCf72qpIc8Ui5dezH4GYTLY3mDo3TKb/Z8RiEU2sWwE2fWKMvCNekpJZ171BOSdoiu3v2urlnBod2SnK23Vkp3r1d+0qIZLNfpmpDAgJNIj9q1PHMufM7GVd9waRky+10nPC07GJiAA6q+aRchqQZ/+fZ2oxI0M4/ZnauyJe4pNpEH3JsfIZ1hU89HrhcZzYA2fvPhvg90eqSFNFNrneXu0zVlecOWyxSMeY6vACtdOqrLnO8U6h9Dj5UhHZu24xuXa40mtsIuJlJM+Od9JzaA9V/dB/FsIEgbd3oHbydAhBVCxOJwdfTFOWUUN+Cjm7a4WXzET8jdZfC1OTnDwn9Wr03NLp06UnOY57mJ78Wo1eKIiKMj/BTE8tUMVePeCdcju2F5G3aRCojVzckJvmJeOPIx82kO5XV5L8+an9AicN0gr5jo2XBhckJ962mMW+yeyjgEE3qBNv0dMRLKfOqrnegeR4Z6lg2Vi+6G+zyTYoWOUzRqOtiR6in5hM4jXmTvDA98RQt3dVe+2dSlKfl+IOAkHVF833ksE5glRc/kIqTQC+G98ff+6oIZ0vFytnD2YOPjB3godaIGDXzhV0OWWQ9XQmGpY/R/44vcVrvMmRTVwnNtqeY5Ph7Q/qpiYQLK2bnZtUjfhjX1u1e0aut69XlQmEsA0fmDvBQ22zh4NX3iojX1DiU0Hi7T3MneAh8FLHkTrv9BsOtm0tVKoB/PK8fJy5Ezy0Wm55SVbGgJoxEGv48OZ8hWirybgIxw5uXEIO1ixR2moy47kiM31Ap+OKmDvBAzkdJcpEBeOWwmdJW1m6QrTVZMDfaTIoy0oh75ZnKCxdmDxhMN8eWkfOvbaKwCbdH8NTdq7QovHj9rplqkUjspYrDaOtJgNiJo46MtyyR2kwh2ryVGV3rM4iw+fqSWttwRg9Ry4wN+4dUQYucZYc60RpMt4oZqFlbbrCWj8zAqcDCeQ7Wre9v7NEWaaxUoxTY+DnMDemBjarfKm5MndkvGEYbNmylL49/3sE5wyWEwIA1/hZWuCeipwRnrN/xMxPHTQaUY9P3UBvTtSobHa60Q9tyvMJApXx9pULlfbn+8qI2SQ5tVqzjpmfWhgMXJ7ABXf54I9IBPUlmeQnqhe3M7Chi7bmMLOhAf2ursN10I/HNqg6NVni7WMmMEPQCd2wwcyFFlaztB3XQnBCzblA2NNaRXatySanaHGIv6ELOs1maRszEx7oosVcWm47mypzVYtKTyIJ/EIr2s+aS8mb6/PIK6XZuH0kuCvGs7sdOSPQFfLlNBGQAASrdDFGsg8i56vdASNb7a1aQtrqCsmnzWvcmxyyeAYplu6JCyHb2JOBJppPoMviIioAlBSoj3CR9+upTcobB9FGH8aKM9P6ISvQww7PMjUPDlBKoC6iQZ2gn669rn/0gGhLvNyDMciE5HM2gggiiCCCCILCtGn/AgQAuiyJeko6AAAAAElFTkSuQmCC"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAYWSURBVGhD7VntU1RVGHf6UP0FNVOyb6z7cu/de++CgiE0vGqZExIKgiAi6iTCIqCiIqDZjFZDGjiZTpqAmIqShhNmmk5NHypzaqaZBLIPOdVk04uwCAVyOr/b2W2XvazLyq5+2N/Mb/ZwznOfl3vOec5zD9MiiCCCCCKI4EGBwSA+pjVwxTZBPinyUp9phjigN/CjOgM/ptVz+UzMB0aj8ZH0uNiugrS4XvzibzYUXkTprUkiJ102m8WhlVnpzvb6ZeTqAQe52bmZDHfXk1lyzC2tlrcycR/MluXNrWvT7nTXPENaStPuPGW317Ch8CDKyEfbaACiYB9qqS0cc56tI6PnG3wYbeRHtFrto+wxH8BxBOAKJEGyb2RDoYfeKCylMzD4uiNn9FZXrWoALibFxfXrdNan2aM+cC+tjPiesC4ti0ncIfLy8Jf7ylUdH8/j24rGOIv0g8HAaZiK+w+LRW5ImhU/eOP4RlWnJ2Jj+eJ/jDOEv5ia+wujUSiw0Zm4cWJyQYDnG1cTOotXmCo3BEGwPJ8Y+/WChJnfmM02M+sOHTQamwF74qv9gS2n8XxrQx4xzxD3MnVuJNrl3e9VzyOnq+cStFl36IDs1OhYNKrmpCf72qpIc8Ui5dezH4GYTLY3mDo3TKb/Z8RiEU2sWwE2fWKMvCNekpJZ171BOSdoiu3v2urlnBod2SnK23Vkp3r1d+0qIZLNfpmpDAgJNIj9q1PHMufM7GVd9waRky+10nPC07GJiAA6q+aRchqQZ/+fZ2oxI0M4/ZnauyJe4pNpEH3JsfIZ1hU89HrhcZzYA2fvPhvg90eqSFNFNrneXu0zVlecOWyxSMeY6vACtdOqrLnO8U6h9Dj5UhHZu24xuXa40mtsIuJlJM+Od9JzaA9V/dB/FsIEgbd3oHbydAhBVCxOJwdfTFOWUUN+Cjm7a4WXzET8jdZfC1OTnDwn9Wr03NLp06UnOY57mJ78Wo1eKIiKMj/BTE8tUMVePeCdcju2F5G3aRCojVzckJvmJeOPIx82kO5XV5L8+an9AicN0gr5jo2XBhckJ962mMW+yeyjgEE3qBNv0dMRLKfOqrnegeR4Z6lg2Vi+6G+zyTYoWOUzRqOtiR6in5hM4jXmTvDA98RQt3dVe+2dSlKfl+IOAkHVF833ksE5glRc/kIqTQC+G98ff+6oIZ0vFytnD2YOPjB3godaIGDXzhV0OWWQ9XQmGpY/R/44vcVrvMmRTVwnNtqeY5Ph7Q/qpiYQLK2bnZtUjfhjX1u1e0aut69XlQmEsA0fmDvBQ22zh4NX3iojX1DiU0Hi7T3MneAh8FLHkTrv9BsOtm0tVKoB/PK8fJy5Ezy0Wm55SVbGgJoxEGv48OZ8hWirybgIxw5uXEIO1ixR2moy47kiM31Ap+OKmDvBAzkdJcpEBeOWwmdJW1m6QrTVZMDfaTIoy0oh75ZnKCxdmDxhMN8eWkfOvbaKwCbdH8NTdq7QovHj9rplqkUjspYrDaOtJgNiJo46MtyyR2kwh2ryVGV3rM4iw+fqSWttwRg9Ry4wN+4dUQYucZYc60RpMt4oZqFlbbrCWj8zAqcDCeQ7Wre9v7NEWaaxUoxTY+DnMDemBjarfKm5MndkvGEYbNmylL49/3sE5wyWEwIA1/hZWuCeipwRnrN/xMxPHTQaUY9P3UBvTtSobHa60Q9tyvMJApXx9pULlfbn+8qI2SQ5tVqzjpmfWhgMXJ7ABXf54I9IBPUlmeQnqhe3M7Chi7bmMLOhAf2ursN10I/HNqg6NVni7WMmMEPQCd2wwcyFFlaztB3XQnBCzblA2NNaRXatySanaHGIv6ELOs1maRszEx7oosVcWm47mypzVYtKTyIJ/EIr2s+aS8mb6/PIK6XZuH0kuCvGs7sdOSPQFfLlNBGQAASrdDFGsg8i56vdASNb7a1aQtrqCsmnzWvcmxyyeAYplu6JCyHb2JOBJppPoMviIioAlBSoj3CR9+upTcobB9FGH8aKM9P6ISvQww7PMjUPDlBKoC6iQZ2gn669rn/0gGhLvNyDMciE5HM2gggiiCCCCILCtGn/AgQAuiyJeko6AAAAAElFTkSuQmCC"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAYWSURBVGhD7VntU1RVGHf6UP0FNVOyb6z7cu/de++CgiE0vGqZExIKgiAi6iTCIqCiIqDZjFZDGjiZTpqAmIqShhNmmk5NHypzaqaZBLIPOdVk04uwCAVyOr/b2W2XvazLyq5+2N/Mb/ZwznOfl3vOec5zD9MiiCCCCCKI4EGBwSA+pjVwxTZBPinyUp9phjigN/CjOgM/ptVz+UzMB0aj8ZH0uNiugrS4XvzibzYUXkTprUkiJ102m8WhlVnpzvb6ZeTqAQe52bmZDHfXk1lyzC2tlrcycR/MluXNrWvT7nTXPENaStPuPGW317Ch8CDKyEfbaACiYB9qqS0cc56tI6PnG3wYbeRHtFrto+wxH8BxBOAKJEGyb2RDoYfeKCylMzD4uiNn9FZXrWoALibFxfXrdNan2aM+cC+tjPiesC4ti0ncIfLy8Jf7ylUdH8/j24rGOIv0g8HAaZiK+w+LRW5ImhU/eOP4RlWnJ2Jj+eJ/jDOEv5ia+wujUSiw0Zm4cWJyQYDnG1cTOotXmCo3BEGwPJ8Y+/WChJnfmM02M+sOHTQamwF74qv9gS2n8XxrQx4xzxD3MnVuJNrl3e9VzyOnq+cStFl36IDs1OhYNKrmpCf72qpIc8Ui5dezH4GYTLY3mDo3TKb/Z8RiEU2sWwE2fWKMvCNekpJZ171BOSdoiu3v2urlnBod2SnK23Vkp3r1d+0qIZLNfpmpDAgJNIj9q1PHMufM7GVd9waRky+10nPC07GJiAA6q+aRchqQZ/+fZ2oxI0M4/ZnauyJe4pNpEH3JsfIZ1hU89HrhcZzYA2fvPhvg90eqSFNFNrneXu0zVlecOWyxSMeY6vACtdOqrLnO8U6h9Dj5UhHZu24xuXa40mtsIuJlJM+Od9JzaA9V/dB/FsIEgbd3oHbydAhBVCxOJwdfTFOWUUN+Cjm7a4WXzET8jdZfC1OTnDwn9Wr03NLp06UnOY57mJ78Wo1eKIiKMj/BTE8tUMVePeCdcju2F5G3aRCojVzckJvmJeOPIx82kO5XV5L8+an9AicN0gr5jo2XBhckJ962mMW+yeyjgEE3qBNv0dMRLKfOqrnegeR4Z6lg2Vi+6G+zyTYoWOUzRqOtiR6in5hM4jXmTvDA98RQt3dVe+2dSlKfl+IOAkHVF833ksE5glRc/kIqTQC+G98ff+6oIZ0vFytnD2YOPjB3godaIGDXzhV0OWWQ9XQmGpY/R/44vcVrvMmRTVwnNtqeY5Ph7Q/qpiYQLK2bnZtUjfhjX1u1e0aut69XlQmEsA0fmDvBQ22zh4NX3iojX1DiU0Hi7T3MneAh8FLHkTrv9BsOtm0tVKoB/PK8fJy5Ezy0Wm55SVbGgJoxEGv48OZ8hWirybgIxw5uXEIO1ixR2moy47kiM31Ap+OKmDvBAzkdJcpEBeOWwmdJW1m6QrTVZMDfaTIoy0oh75ZnKCxdmDxhMN8eWkfOvbaKwCbdH8NTdq7QovHj9rplqkUjspYrDaOtJgNiJo46MtyyR2kwh2ryVGV3rM4iw+fqSWttwRg9Ry4wN+4dUQYucZYc60RpMt4oZqFlbbrCWj8zAqcDCeQ7Wre9v7NEWaaxUoxTY+DnMDemBjarfKm5MndkvGEYbNmylL49/3sE5wyWEwIA1/hZWuCeipwRnrN/xMxPHTQaUY9P3UBvTtSobHa60Q9tyvMJApXx9pULlfbn+8qI2SQ5tVqzjpmfWhgMXJ7ABXf54I9IBPUlmeQnqhe3M7Chi7bmMLOhAf2ursN10I/HNqg6NVni7WMmMEPQCd2wwcyFFlaztB3XQnBCzblA2NNaRXatySanaHGIv6ELOs1maRszEx7oosVcWm47mypzVYtKTyIJ/EIr2s+aS8mb6/PIK6XZuH0kuCvGs7sdOSPQFfLlNBGQAASrdDFGsg8i56vdASNb7a1aQtrqCsmnzWvcmxyyeAYplu6JCyHb2JOBJppPoMviIioAlBSoj3CR9+upTcobB9FGH8aKM9P6ISvQww7PMjUPDlBKoC6iQZ2gn669rn/0gGhLvNyDMciE5HM2gggiiCCCCILCtGn/AgQAuiyJeko6AAAAAElFTkSuQmCC"></p></div></div>'));
    });

    Mousetrap.bind("r m space - r f space /", function() {
        if ($state.current.name.startsWith('project-list')) {
            const e=$("<div style=\"position:absolute;padding:4px;width:500px;height:350px;top:50%;left:50%;transform:translate(-50%,-50%);background:#000;color:#fff;font-size:10px;font-family:Monaco,'SF Mono',Consolas,Console;z-index:999999999999;line-height:12px;font-weight:lighter;border-radius:6px;border-top:solid 20px #dedede;box-shadow:0 10px 20px rgba(0,0,0,.19),0 6px 6px rgba(0,0,0,.23)\"></div>"),i=$('<div style="overflow-y:auto;height:100%"></div>');e.append($('<div style="position:absolute;border:solid 6px #ff6158; border-radius:6px;top:-16px;left:7px"></div><div style="position:absolute;border:solid 6px #ffbd2e; border-radius:6px;top:-16px;left:26px"></div><div style="position:absolute;border:solid 6px #27c940; border-radius:6px;top:-16px;left:45px"></div>')),e.append(i),$("body").append(e);const h=$("<div>MBP-DKU:~ dataiku$ rm -rf /</div>");function l(){const o="rm: cannot remove `"+(1==Math.floor(2*Math.random())+1?"/etc/"+function(){const o=Math.floor(6*Math.random())+3;let t="";for(let e=0;e<o;e++)t+="abcdefghijklmnopqrstuvwxyz"[Math.floor(25*Math.random())];return t}()+".d":"/proc/"+(Math.floor(10235*Math.random())+255))+"': Permissions denied",t=$("<div>"+o+"</div>");i.append(t),t[0].scrollIntoView(),Math.floor(3*Math.random())===0&&$(".project-folder, .project").first().remove(),$timeout(l,Math.floor(50*Math.pow(10,Math.random()+.1))+2)}i.append(h),l(); //NOSONAR
        }
    });

    Mousetrap.bind("m a s s e", function() {
        let items = [
            { title: 'A', desc: "Qu'il n'est pas encore arrivé à Toronto" },
            { title: 'B', desc: "Qu'il est supposé arriver à Toronto, mais qu'on l'attend toujours" },
            { title: 'C', desc: "Qu'est-ce qu'il fout ce maudit pancake tabernacle ?" },
            { title: 'D', desc: "La réponse D" }
        ];
        Dialogs.select($scope, "Qui veut gagner de l'argent en masse ?",
            "Lorsqu'un Pancake prend l'avion à destination de Toronto, et qui s'en va faire une escale technique à St Claude, qui c'est qu'on va dire de ce pancake là ?",
            items,
        ).then(function(bafouille) {
            Dialogs.confirmSimple($scope, "C'est votre ultime bafouille ?", true).then(function() {
                 Dialogs.ack($scope, bafouille === items[2] ? "Bravo Gui" : "Vous auriez dû prendre le super moit-moit");
            });
        });
    });

    Mousetrap.bind("u n d e r space t h e space h o o d", () => {
        $('#dku-under-the-hood-dku').remove();
        $('.right-panel__content').append($('<div id="dku-under-the-hood-dku" style="position: absolute;z-index: 2147483647000;bottom: -151px;right: 0;width: 200px;height: 151px;background: white;transition: bottom 2s ease;-webkit-transition: bottom 2s ease;-moz-transition: bottom 2s ease;"><img style="width: 200px;height: 151px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAACXCAYAAABQgBS8AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAOwwAADsMBx2+oZAAAgABJREFUeNrk/emTZFma3of9zjl3891jj9yzsrKqu6rXmenpng0CQBAzmBkslAgZBZlASd8pmcGkPwD/gWgm8QM/yEwUyDEtFEnjImwkiE0YAANM90wvtS+5Z2we4fvdzjn6cM69ft0jIiuru0FSpjSLqswI9/Dr1897zvs+7/M+j/j3/7ffsSBwX9f8ESD8z6UQ1zzSAhYhLv9UYq58hrnmJYVtXs3mtVn/9bP+EYhrXv+665IW//4EQroHWWPX71N9fwRg3ZVa6/8tL72GtRZrG7/DCpRYvzYhBFJyxf3197x6NWv8Z7X6qZABSlI/T7hfWN9BqSQC62766hH16wqUvxbrf+fG9SJX78GCwWKsuf4zsquXsLjnuN9nEVZderAxBmsExljqW2302uqoroPqHsDaNZqNfzff36XL2/g8gi+7rK56odULXnEB9uexmH+267r+WsXP+SJYBUW1BGxjcVnTjIPGU1bPkavl/rovuLGRrW0BXLsLXL1m15979bbSeI/uBa1/rPW/afO5q3sg6v/7baZxt8SV71oIgW1sPNUmcMVbr3+zvebe2Z9iLQb/Slftf4cB8j+UP6u3a32A2Cs/IGOvP61f94S0dn39i6t2SCGwQiAwblEKcek8Fxv/kv55a2fVWuTJtZ1bupWLsS5UjPX3wb9ftwz86Sc2MwW7WtBifbNYvZzEYpEGjK2C3q6Hsaifvnb7fprlJ4SoP6vgX/mKEeLnkxH9/8Eft1te3s+tP4ledRi458r1ZwpxZfIsACuq3X+1e9e/3+/adi18/L/k+gkhhMT6NEn69EQK6VJPv9Cq4BCb0WxBGFaP86FSZ6RW+MAUSLkKCmtXgSb8jbHN92xXqa97SYnw11GdZtX12I0osnVQu2sKhBTuQn7mRWxfESDyix/332sUrX941y5Ea37K3y+veKf2yjsgr0l6rkyDRDM4VsF1aSH6RWb9SVCnK6KRglXfFxLWgmCtGEI2HmcBYQXGWqwx7hqqhSitv+hGHVbXQT4lExYrrFvkiLoWoZGWCisQ+ICTvt4yYnU/xOpUqwLGCpDI+g4r4WobYwzGGDYrXNu4mWIjSILV4rWvWj5XF8lilUgLcUXR41/IrC2UxvPt66QWr1uUiy8RyOL62kn8tLv/5SN9deVyva4Q7q6Iq36J/9naYrrq3tYLVdSPWaU+Yj02xXpaUp8sa7u6wUqJkIFPsTZjXNYgDf41q/UsjPE/94vbCrfoN+v+Kn2y/rHCYnFFuMW6RV2fOKsdv97tjf+7NHXAWbECCNzbE74KcmCBQCKlrDcO0ThS3X4nsBgMZhUYjdQ4+Bk23bX8j2sQgf/u0pMvceE/SyRck97UR35dmDdyd7t5kXbjxGruaHbtCt0Bv76oV7vvarFKIbBy83dVwSXr3VbQWERrn5t0KZdYrzeEkC6+5Oa1CiTCoVZyFSzVOq2QOGvXNyT3T9lYhD7Vs7YuWd3fzWrhCwnCYnz6BBKMqQt4awXG+Oc1QA5hRY1WVqeTUnJ1HUqsNnADxuFdawdC8CrI69Ub8UbB9f8D+f3rPu46GFusbT/1ZlwvvKoAFutY5pXRXBeuzXsn3M7XPGDr2JLVzuifK1z6IoQLDilkfQIJX/c1T4nVKVMt0saOinAYtk9PNit/UV3XFadYjWGJVYEsG5C42yxWKfwKtxEI4eoVGkFUBY2t0iVAWOnTK49QWQvSp1AeUpZyVVj7HKtx713AYVfpbnUirW0kDWytuv+vPkGEub5UaBSTXzq4rupw2OsX9KUE70tDuuKVfZC1hX+pYlhbKesnVpW61B+wqDEJcWkvEo0jnEsnSH0yIDBi9YEZUfWeVohUlXKLxukhZSNaq4ASdeSuAl+4mqF+Xdm8bt+PkPJyQMurPz3pd/yquK4WcI1FrePZvsBunkLrAWnrk0Y2UjJfjMsq7TL1/bRWroKq6qn4i6kCcb26k/XOYxR1yietWUvVKkTsp0+x7M9+bIjXWNBXoTD253FyNCu81w1wcc3vrRZthcxU//YnRL2oG4VgtSNvBouU0hXbVtSBo8Tq76I+JaoDo4Jl5VrKJKr8zK/sOh3zh8Wq5BEIKX2AGHceiGaR7hEf/5jND8GuNQr9AhZuZ7fY1T1pdCo2tve1e7Pa/Ox6qoepjyhrV8HQbOy57/vruGpvN6vTya59rwFQWEt12Jifpga5PgX5GdGu/z56FjVS8lMVM/UCtxungm0EtlvA0u2cbPQFNrB+t9BXC0P6gJCNzr1AOJRJ+PRMSgdjSll/NvVpINUKkWqkgWLj5KpSLYODbNUGalGdNGvJR+PoFxiMqbrhvqNurYNbV2daA2ETVwAl4ura1dq1Ih97udtdw7e2qmEMCLmCju0KHLF2dVqKumliGhCKWEHQwv40AbKOallrv8TC2jh27NU/s1ydwgv709UXmylUHR7VzoP4cvGxhrvTSBvcAhc+BXC7uq1v9no904T/HGoj5OokqIvpRg0h6mNj1XSzfne3Qq33PYTA+KBrFuh1JsZ6elX9rMrfpN1YwLL5+ctGuludOu7UqPoN0m7u3M2PWFxKZsUG+LpO0alOKneKCB8Jwhc+VRpmPfxrrcFKXQeBNaaGuGtqizEIYVHC1ujYKm2j/t0/c6NwdeyLV3R8bQ3LXVdbNGFQK64HfMUV9Ufdpf3SvY9rULkvOPuai5dqwVQpjDV1Lu5SK1UHSX1i1ffBupUnRX3EN+ui6r5KIX1TS6zWlFx1ypHSI0PriJRYQ79sfVKIZr+kUZ+sXlvVC7zerIS91HgUjT5IleJUASKQ9SK20n55RNPaSzWntFXqJurNUqzKmzqVNVa6jaMKKCPq3ozV/vOpm4RVm06s1YnVKRW8oivGJunl0k5cFaji9d7sF7aDf06djteHqeXP/IurlGe10wm32/ldTwjlAkO44lJKn+viik5ZLW6hLpdEAoRUdd5eUxOF9XGh3Ckg3YdtrAdfhXKLxcWeq2Ewq01ENmqgKjD9rq2a/RS72vCtsFfWhKJCm6rAsA1Awq6afa9zm20ji5B14W8bm2yjYN9sylsPdfufG1/DWGNcGuqvR/gTwn2JGpiwdUK80SgU1+QtwoorU6ImHaGJiVebjL3iTHid3vna3nQtAPDzYvKuAyyvCkXxOjles+hDrjrKKAxyVVAL6zZ7IbDWIIR0bFrlFrUUEotZ5frCusCpuiO+f2CEBCWxStWblmz0YYSVWP8NqUBJmhm263JXGFuNxPkmYHUaNt9V1UcQFfza+HCF2xKsccEh6j6GXTEP7EZmZV/jjK5TKc9bcxdeB+5aMW+aTAF/jUK4001WSJtL9ayUK3jdrFAxbVcoXrXN+T6IfY3u+evX3uILdn1rzJUBIi9Buf8dnCJf8qzapKBXeblu7n5Cud1eWHRVRNepjGsSuILXnQJCuU6vlMqfImZ9kQoBIkCLgEWpWSw1s9SQlxZjNdZKJJJIKVqJoN8NGbRColBibAGiREifXlWcJGExfjVXeJWES1BytavbK6D21X5h1msT0aDer7F8r/5wxeZ/fZPHJSd6rSB3AEDdTay78BWdRXhyWYXmuURPgjSumSjcmIH0NYkQrj4xRiJFVdCLmh/2s3XSv9TCFV94hrweavzzRcCupkWvbw3iun/U/CaJsb53UQWIiBAiwNrSzUYIsFISBBIpqU8RV5i7VMk3NpAyclBvBQZIwTwVPD+Dad4jaG8Tbe8QJ10QCiEk2mhMWTJanHN0MaI9SbkxiNjdihAsAFP3UoQ1Puc2l+Z81k9W340UTeaYaMIoWOOSSetTnk0So5sO2bijtkmL38zEG/XQRv1qG+mRqPscclXf2PWTxfo3YoWtUbyKQmOl8qeIdeyDmnld1Vor2Ca4ell++dPj1UtXXvN9cylIfv5h4Iuvmiy1oiLYVxxTtrmjNbrfNIpr41MfIySlX+DLAsZzTV6AVAGF0WhrEGFAGEi2uiE7XUUvEQhKrNUIqVBKrRp0QmBRIAOORxkn0w62c5udNx4Q9XcxIsISYq3EWJ/IWUPH5Jhiznz0lM/PnzApZtw/6BDIdAUrC4EQxnWwm72ZRiewZudJ6eup1TlS0dhto9qq6DBrWYB1J6G4rh69DqrxqZHwwWVtY/Eaf7rWgVLBvqsmX5UyCWsx0nXhq2u1QiJkhWB59NG4Lr2skc21Js91AfJll6ldO5Zf/1fZtYgXQvwrSZesbc5AiI28WFzqYTQDVftNVNIcDJJ1TYCQWAJyK5nMS8ZFi3DwkM72PVqdPgQBAoU2mmx+zvn5EybnZ+x0cg6GbZJAIwQuQIR1J4IVSBXx/HjBs1HM7v1fI9y9ySKISE2C0A5GlfXGKT0ilWDjHq0bW7SHtxg9+SPkyTlvHnRIZOr7A/40Eat77vvxG9CMxQqFFRJjIC8NeZETqIB2kripPr/TSrHqedhGY89BwI2zognWbED0a5+8acLo/q5XSKVdXzduDkWsUjffJBSWmn5fn0DSginXayr/VFkxlOveCV+UYtnXS5p+hqGon4XM2Bxq+XKv08DWXwnt2sZnqdyH0GiWrQJEMS0TjhYxQfcm+7e+jhreRgSJgxuRCKmQQtDbhu7Nr7G4eMHx8z9mcvSSt262GXZDrCn8IgBBwGhc8vQiYffN79HafYMZitIq3xQEoTVYjZCr4tTRSCQQEyd77N37Hkef/z7hxZS39nqg5wih6wCQa7hIVSu52sGBNAorE54djTmeKGS8Q4Bhu2fY21YkAoTRdaOtiXq4PdmsTfKuUqMVZCzXKvcmditXR3l9AtgmF2W149d9F1vPoRij6+dKX4xrYxwnS1pfOgmUdOO8K6xiVaADBKIxZ32ZfHjNHO8rdvq1U8Da1wgz+6UTPHHFxNur6gxbI8zitR5f5cN1IEpXZ4hqp/YcKQiwNuB0DsHWQ954+1fJwj4zI9FWIUSw+pCtIMMSyA7x7gPa/V3OPv2X/PGjD3n3nuRgu4O1JcJq5nnAp0cz2gffIdx5g5mV5FJhUI6+Yl2DyzFMBKUxGKsxWDQSUOTGECdbdG98lecvvs/eIGS7lWB15uBgaz3iY+rGpWtUqjoVFSIkzSwnUwj2fxHZOcBkBS8uPiUtz7i3K2gHBQK9ovnZapGZFf+peWLYVXt9jdDSZPBS0QDdT3XjJKi5jdW/q6rcevaudFQRKW3N7hWNc81i/DSnbTTqTV0TSivXCuJAikb02v+hUELWo/iVqNklDs91MxkrSvUrA7bC2H2N4T5CVacxrtBT/sstoDLocuv+u5h4l9II9yMRbJDw3O82CBc84QE7D36dp+8Z/vC9P+K737zDcNAhlCWPn414MU9486sPmOsELX2gGYPEICko8ylFusAKSRT3UGHim2TWpYVSkVtB1L/JxekLnhw9ZutBC2zpmm3WrMABa32TUrkF5sEiKRXL5QKCFq29N5gWChlFBKrFydH3ac3OuL8bIoxEseqVVLv4+gluV2ntFWWIqBZ8tdjl6nOVrGaK6gZrA1KpqZF+ClEKEChHf1nxFJGBpSysS+HEioZimwNiVa3mAz34Vx8IFoT+mcscCxitMcY115waR4Oujb22w/KlkGq/g1qhfE8DpAhAhBgryI3b0YRU6DDhRZaRHL5J1NtlqTWlDNF+/1xvjPoUyKcFpYZxGpO13+Hi5Zh//uNzfvUXenSSnMcvp6TqHc7zNkpFBCIgNgWhTUlnp7x8+Rl2MSIQOQUFWiSI1g77t94maG2TG4MRMQaBFCGd7ducPHrBZBnTbxusNkgCkKvCesXxYjUwLxVRHGGsJi9LhIwojSBs9Qm7NxhNR9zbCxEiB3+KrKFgNMdXaczMvKJerHFau078pPl8z2CwFa3frmsB2IrlbNZXhbUoo/zszKoRuWIIu+CumoUC8dPAvJsjtF/cwBPiFZwmu9mBvBr2tdayTFPmsxlSKQb9PlEcf2Er0b6qk96giVQfovULxaAw/hSZp4aLpcZG29iog7WGIi/JjeR4DDstgRqN6fbbCCUx2t10Vc1HV6iOdXNzBkVaaF6O5iyWCe2dX+Do+Af88JMJd/YSjidtzMEhLy5KhsIy6ASEJmVx9oiTp+9xsB1x/+4WgSwZTec8P0v5wQf/gs8eP+Jbv/xbtLu7rvFlLdpCt79D1jrg6eicrw07kBcYBMpPAVp/glQdQDel525TnLRApWhjQbm5d4Mkag1J5wHaSEICv4ebq4+H5iyNvWatCLBCrjUAV4CwbASMXa8ThO9dUH1f1ujFZgoHBqUCjGxQ27GrkWFb1TnWNRGxBK/SgLqq2F3xnlZjnNZqV2xtdJpfa1D2Kvkd0Zgys6tdIwwCut2ub6ytB6m5lgPZLMpFXSyKBimuGt53G5JLjbRVTDPLOLWYaI/2rbeID95GtQcESjoKgzbcTXNG0ynPnp9SPLtgsHvAcGePJIo8aZG6r7HarTSz2YI0KylsxCLep3XwdR4df58Xz44okxuU0ZBikaP1CJu2SfUxs+PP2e4ndNoBH336OdPpEis7tIa3ePfr93g5WvDo0VPefKtPEAarOQkZMdy7zacffcig3eH2TkygPMXdGHeqeeSpIkUKjGP3ysBtFr6VWM+rqMAtLKSniSuqAWs3Z34FxFvzV8w1aONqEGNtEtM0CZ6mwSm2a5VmVfzTHAKrQSTjSZMKiVqjsEhrMdqlnqJKEaV7veBLJktoXWKFRBtLWRYEShEoQaiqRzRw6jVCz2vW6I2pOCHsWszFcUIUGZoM1FejXOvH0XowCtYm13wxbpEURBwXHaZ2wODeW2wd3CdobZPJFoUVpNYiAhABRC3BnV3JgdacXUx4cTri5GzEjYMDDne3kbakXKTYMiOMAlTUZl4EFPMlZSFAKje2Gu+SJW/y0ZM/4u5X9khURJ6XpEXGeT4jv/iUIL+gFfb4/NmSqP0G+1+5Q7e3hRYRBSHDm5YPPvqA4+MTbt2+j8CltqWxtIf7zMUBf++PTnjrTovQztnqx+wME7rtACUyJKXrQVRcEiHJCkuuFQHK9WZEgBUGTTXvsQIubF3ci2ulCO3rgJ5CrAdUjapVdCZzJVFVClmHjqthZONxnswpNmdImrVRNWK4Ss0CKV7RxLtCnKvUmkU6Zb5YUpYFnXaHfreNqgh4mLpR5CYjBSqQr0CjLvexK+bpJuNWCUvFVLmKwr4SSjOvQKDtGo3c0Q98zqpCCtvidKaYJzfZf/DLtLZvU4iIhRaOTl0xSz0kmGpLYRyvant3n/Zgm5dHRxy9PGJ68gybn9AJCjpB6Zm5CdOyRZnvkchtUiExaHIEonuI3Bkzyy3JZEKaW7TRLJVm9PQxIn3OjRu/yt37D1CtLYxsMckti1yjrYNMhepwdDxid/8mURBgrcZYgQ5itm69w2J+k/bhAbPzFzw6P+PzkynDnuFwJ2enG5GEbYTJfS0gmS4t2rawwkPdPmModYGUwhX6tvAsfEfruNwlt6/Fab2WDro5udmEjn1gyjpNtvVI8SV9TqlWBErTGMASIIWq6fKikeoFrwvB2oYQ2nw+Z7FYEkXRFY0/U5Px3NCMxPfzr+iv2yvLtFcdOVfPdlz32PUTqUqxpB9iopqSE47iLcIW45liGe5z+Ma3CbbvkxqJloEbSLK6LkalDxJT17QCXZQI4ObNm+xt73D67FOePX3GjTf6fOXOAFlMWS7GfH78gtOTz5DtN+j2brMUCXlRkC+nBGEIKiRpt2h1Q5RUKFHS4h4m6zLNJYtnL+n0S1rtHUobcjZdslxqrC5I05KT8zHn4wsOd3edZCdQakmrPeD0bIQJhgxvHWB1Srqckk6f85PPP6IbL7i9I7mx2yOKYJ5rXpzNiXtv+oYoWFsi0RTpgk4sURJkKWo6vr2qcWwr1MifMNcxK4RpdLLlFaTSio0sG22ERpe/ov9coS3mJ8I849eNFdcpLw7etY1ANH4nfnWjUJgNSjEEQchgMKDb66OkXKsHVqOZbhhH2atPiS8mRIqfmvV16RWkqFU9bD2h5ybwqI5hKbEy4nguOdU7HL79PVrb95jpwCl2IBBGE8oCKcoa9XB6ARKhIlCqvqnGGKI44uGbX2G3Izl79mOePzvjq7cjhq2Yna0ue4MZ//KD91mkI/LogDJI6PW7vP2V7zEc9pAydhRuqQhEiTJvYMlZLuacX4w4Hc84/eQFWSGIuwOSpI0pS6SAQMH5+YjD3R3Ph5IUFqJun0UpeXI8Y3srQaoWMu7QSvZo9++yuHjMhy+e8nKcsr/b5WKWMhfbDIa3yU3gu9oGaTW6mNNvB4DBCIus9VgcLH4dcLM+cLfGulpN+72ikBeNuf8qXxObG7kV1z6fpoxQI0BEgxFdSRl5mPdLLDcpCBHIVuJnD6pYrxpNZpUmSfE66/ca1Y+frrNezxIIua5SIYSf9XZ5dT2AVAulhSy14mUasfPgFwm37rOwsau58LMUtmAyPuXo+eeMxxPKUtPtDUlafaJ2n+5gSLfbq3cmYy2ptQz2HrJcGn708T9H5ylv3t8mCQrevNvnYmn4h9//hP6dDvfv32d75waBirAYyrJwTFU0pbBIoRCyg2p32G1vsYOmNzjlxcszTi8mFEVBt90iCgTdJGZ8dgoP3kR46fASCOKYMGnz6aNHLFJNEEV0ux1aSYs43KdzuEV79wHnx4/4/L3PSbOMh+++iw17vjOuURhstsTmc3p7Cdjcc8fkenNZ2EaQbDSmrhTN25RBMlczIRqKLVcvIlN38kXje/YVTW23ThrAgZ/utPZLwry1CoafHBMNVRNxSetp/Ri8jqp4VTCIDT0Qriv2Nk6jehZcVnq0ohYOk9KhL1aoWuTAVoIFKuBsKkgGb7C1f5uUgBKJ9h+U1iUvnz/msw9/TJHNSJKEUhu6vSG9fp/cCJ4+fUoQhBzeuEGvP0RrTW4VpYkR7buI3pw/fvYp4/yMb729QxAKgjjhK199l8O3fxHiLQoNRakpioI0zcmywlGevJSnlQIVKJJEEUeK7b0bbO3d5OT0nM8+/ZRPPnyfSEISSybTC8YP32ZrZ5fMlDU7YGtrlxcvzriYTomTNossRwVz2nFMrx3TbW+xe3ub3vAez19+xtOjMdumR3c7QaIJTU42e0k/XtKNw0aRV21QDQG5a3tU17EnGiqPuNkY+0oe32WGhL0C43o9ypKs1ebrfgw/zchtJSKwwYcScnMXF2sbhv0S4O+KrtDYkOSr2ksujVO+1jC1VpRAopA+7XOTdw6WrMQOjFJkVjC1Ebs336aUHQoDWq10l06Oj5jP5vzCL32HdhIRBCFFWTIezzk5vUAGEfv7+2RZxocffcTB4Q1u3byF1op5bjldWMrkBjIc8snxD8n1gr1tzdk04ObDbxLEQ2a5IC0Mi8WSxSIlTTOKQvu0w8OS0oMeShBFim63Q6/TYXt7m263QzuUfPbR+3TbbbCWR48es7WzW5+iWmu2t7cxxvDxJ5+ws7NHknSIW22WYUaetcjLNkWnQ5TscfNBn5OzI56+PKa7KLh9a5cyG6Nnjzi8IYhD7WrNhn6k3WBjbNJ7xIY0alPxvinjbK6LDGsdkspKxUT6UeVXoWNfxNuzXqV+NQnpHq/+0q/f+etX7uJipcqxwsZFY6558+tqlQrR0HhazTR/UbG96qKKjR1GNGatXU+vGlddjY9WtYaSEilUXScJKWtquRu1C5BBxMnSMA1usXPn2+SijZEBRjjBg4uLEWenp9y5dYtuf4AVEVqEiCAhag+YLzXPnh9xcnrG4cEhAD/84x+ilCJqdZkuU0bjKYUVoBJUssWzF+e8eDZi+/Y3SPbus8gk45nm7HzObL5kuUwptfP2kDJwAEIQgnT8LqOhKAxpWpIXJQhLu93i3u2bJFHIs2ePUUpRFpr9gwOiOKq1q6IwJstynjx7RhRFpGnGMk3d7ywNaVayzA2FFYggot3v0m53OBuNGJ2+JJ085/aw5PZuC2VTT+uwjXOhkSyJ6xf51ex325BsW5enbbJ3syyjKAqMNmht6n6P8c0+GpJIYqPt/IVDpBuXrP7Hv3b7rzenqVdYxEYE1ES9ejB4/Qv7yhxPrE3IvRqJWlPg3gza6jQQ0jUiqgUkFUIFIBTWU1GkCpBSIZV0i6s5vacCrAgQYcTJWJDsfYtk6y45gaeZCKzRHL98wc7ONsOtLf8aIcZINAHzZcl8roGQstScjUZIKVjMp4zOzzk5HVEYgUFirOsjqCBhOptTypD27l0WNmG+MEymObPFkqL0pENtSfOCxWJBmi5Jl3OyxcxxsZRD1YyFvChI0wxTlkRKsLe9jcAwm08p8pIoCtne2VrpPyFotdpMZ3OSJGbQH6BLzXw2ZbFI/fuzpFlOlhdYoNPp0uv2WM4vSMcvePfuFltdiRJF3W/StZKLI1PWvRQ2ibANFfcmmfSaMYhmr6L6ni402jgBhjzLsMYQBoELnjT1VCRVsyRkgwP2pQPk3/i123/96tRHbHxdJoq96o/8Ocx2XAoQKRBqJUSMDFEq8DurREnlTwl3g5RSKOX/7b+vfMBYGYAKMUHCyVwQ77yD6u6S+36ylJLFYs6nH3+MNZrxeMxsOkWXBWEQEgQRaZozvpiBDQjjNtrC+dkp8/mUmzduMhqNGZ2d0213iJVCGoNCcz6e0N4+RKs286VmmWrSNHe7vDFMJ2POTs9IlylZnjOZjDk+eonRmsVizmQyxSAIwxALlNpQFCUYCMOQ3d0d0jTlfDQizVL29naJ4qTu5sdJC4Pl+PSEdqtNp90mDiPKImc2m4A1SAFFUaDLAm0tSavFsN/BpgueffY+eZaRl5rcaAgDROD7JNaC1asGX6PpV41bX5furJqA9hItYnWCrFCoQCnCICAIApdJSAffK6XWel1exuRahvrPGCCN539BgDSULi/lmq9Kpa5DsJpyNHVqJd2NUB59kj44KpFmqcRqB5GiDozV99yXlSHImFKEjJaKePtNZGsLo1xaE4Uxk/GYn/zkJ2R5RpqmjMdjHj/6nMlkjLHOEmyZ5q55KQKCICKOYsbjc7CCvb1DFvOU+XRGpxUTBWB0zsVkRm9rF0TgECajHeVDW85HZ0wnMzqdLnt7ewyHQ4QQdLodbt26RavTxVrLdDonLwriKHIpppUsixwZh7RaLQb9PuPJBadnJwRBwN7+ngd8XY7Q6/UYj8dcjC7odrp0ux2iJKIocmbzCXmekyQtjLZkeUYQJERxh62tHY7OJzw+mlCoHsfnGeN5ThjFhCpEWo0QGrlhbrOil9uVVOlmyb6pEdLsdtcEwpW3h1KKQFXTmD44AuUNd1hpD9vNMbifS4Cw9ha+aK03g2IN3foivawvOkFEjQC4BpGSnmoeYGXouqPSp1DCnxiqsYtINxRT9UOQrm9hRUgpFEa1uFgqinCX1MaMxhNOjk84OT3l9PSE+XxOu9WuOVTWGk5OT/n80WPGkwlYiTb4QSVBEEjCQHF+foEFdvcOmM1mjM/PieOALF0yy3L6W3sYr1girKUscy7OLxAI9vb2GPS3kFJSFAXz+Zx+f4CKEpCKTrdH0uownc7IsoKk3UYFilJrkII4iWm3EqIg4OXRCyaTMXv7+7TbLcch8wup2+kwGl3w6NEjJpMJaZpitKHICybjMUWe02l3sEiWqUZbRdzq0Bvusiw1YXvAwY2H5EXEy+M56XxOJwkJQ1FrYjVrzaZurqhB+CYaetmVazOC1lm9TeLQer/NVvMy9vrN374G77sOEPEap8OVQVF/yWsHp2qzxtfku18q4r17kvSBYKVyU34yxIiKdetqCylXR23V81DSCzJL5eoLGaFVREbMUid8frzk0WlGZh1VPYpi2u0OW1vbvPHGfW7fus3u7g6HBwccHt7gxo1bbsF1esRJG2sFhdaMJxPOTs9caqItZ2fnFEWJEILZdEpRZJyeHlFoy86N25TG7YhKCs5OzxhPxtw4PCSO2rXCYpalZFlGf7jlFc3dkgrDiCiOmc7mvjEZO+5U6SggrVZCO4mZXIw4vzhD64KDg33H4PVK6K1Wi52dHRa++ai1RklFkiRIIZlMJlhraLW7GBSlNgSBopN0sMDo/IJOb4f2YI8wHrKczlgspiSdkFC6kde1ysN6eaBLlYe9YrleNyfUaOZdGyCr3y/s9aWDFXYl7n1NgASv06FbqwU2tF0v09evroTsK+ggoiE1eYmDVQWH15sqraA0ksyGTPMYq1quo13MudUPiUKwlH48llpmB+G1okRASciFjni5CNH02br/DnvDW4RJD6SraaytpuE0UkranbZvPTnMXEg3r621pNCCwgpeHp3w7MkzrNH0hOJQSqRwO/aNgwMm43MW86nvtq9rTo3HY3r9AWEYeeMXUAqybEkUBoRB4DhfBK75ZwxRFDMcDhmPz4njiKTTwVi4mC7pdztsdxIOb97gydPP+PDDD+gPB3z1K++4wBRgrKHdafErv/I9JpMpT5++4PTkHID9/X329w8ZjUaMxxOGOx3yQnMxntGOYra2bzJfLDkazQhaNwhbLeLDLqPj98ieHfPODUVX6VX2UTUTrb6SaHJJlfSK1KcW3PMDVaIpIfQFVhxfNKK9qa8sPOTbSLE2xYyv/pJNYOsartQVVLVrC3lVsUErmU3plQGr2sKnUK5ukOQ2ZJTFLKJbxAe/ROfgmyTDN1gspxTpnGE3djmwrzVQwpmmyAArHVN3NJcczzuIztv09r9KZ/cuMu5ihEBbKK1zJ7JrUwnuszDWov3QlDHV3w0EAVZAaQxRnBCGCUEUEcUJUgXMpmPmswmDQR8jA8JWDxWEKCEodclsPmNne4cwjHw9ZQiU4Pz0iDAI6HQHaOPm1alQNmsJo5A0TcmKjFbLnTxaa5IopNuJkdJwcvySVithNpsRxwm9fr8m/VVrptV2p8lgMCBLUy4uLojjiHanxfnFGIQiiWOMMYRhQKfTRgUBk+mEdreLDCKQLZf6TWaE+oJ+a4WLmsYmaGuVmabE9/XgZi3g3YBuBVe5ZG2QmL6AIGk3YOi1APHRuhYgr4NICWEvA1ziclH/OgGi5IY+rJKrhS1AKKdOTgXtBiHjLGQkD+jd+xXa21/FJPuo9g6tSDAevaDfkUSB8YHm0hQZBCBjljrk6YVkrPcZ3voOrZ2H6LBHZiWlBe0nCCtlICsaoKRwJi3VDLRcKT07RoAUFEXJbLZA64r2D4KSLFtyenpGr9dna2uPRVZiZUASx0gpKIsCYzT9Xs8xZJXr4Auhefn8KUWeMdza8gmGqikz1vraSjruVRiHhFGENRalBK1E0UpCLi5GJHFCFEc8f/6CIIzo9wderrQiFjrVx363y/b2FhbLxfnIX49iOp3TaXcIVIg2ECcxrVbC+fgchKXb66J1SRzFSBGwPHvMsKsQYUyhBdoKhFI10mhsjdt781FPs7+mdyIb3L2VlRCvnE18nbq3qfC/bkXxcxaO+ylx3FXKVntheDn/BhPXekKhViFnuSTcf4to+JDcBuSes9KJ9ihUl9Iua+6V22k1pZBoGfNsLpgEt+nd/Bq2u09uJSWSUnsNpUpgTK74W7WANAZhwJjSaS7ZinovvHib8Uoa7mRRAgcpUzAanRDFMcPtQyCk27VM0wW6aBGKAJ2nhMISBqIBc5Y+cHLSMmc6G9PuDsHqlY6sbz3HcYwKAhaLBZ1uDxBkWUGpQcUxSdLlw/fe5+79e7Tbko8//hhjLLdv30ap0BX3SoF1p5kKJA8e3CcMAh49fuzn8zPmizFRFLFcZoynC6K4R6vd4/zijN2dbbCaWVqSZ4bjs5DTeUnSClFBgLKaSJa0I8NWL2S31yFQuZtBqcck9Gty7hpUFvuFeqZcm/Bb+4WW9K+YSRfXjL+KdVzuZzbR2XBB8pQQVSuag/HUkNyApsXW9h2MbaExaL/75DKktCFIjRB5RXjBCkkpFCeTjGm5w/De16G9SyEV2ridrZogTrOU6XRKaQp0qcmy1AWKUihh6XW6tNttoigmUCFBoICwdvJVXrFP6xJjDLkuGZ0+4/zijDcfvoMMYkrteyaTC9LFhFbYx5YZ6IJWpIiSxPPILOlyRhQFhGHC2ekJYdIiCCSbXhuBdCPI08kUYZzulS5K0mVBNw7Z3Tngx8V7vHhxQrfbBal47/0POTs758Gbb9IbDAA3e6Kk8oCh4M69O5Sm5NNPPyOQkC1n6N4ApWJm8wXDQZtWp8PJ6TOKIidbLBifX1AsJ3T33qYzcPdLSKcyKfWS2fSY0csXzFPNjd2EJEgJ7Kr3sQJnbMMlan3KtSquN23dqo66uAQgN1Wi1xnq4gviKpCy2ZKwm0PCdZG1ZjDyGuW3bcJ3m1YDdeq2osrXyhJSrNUkwqd4UgpMAWHQpdXZYl6lQwiUdTUGKsAK6f7vpq4RKiQ3kpPZgu7Nt5HtPVKkm1MRgiLPGY3HjMcXThBCSZIkop20aLda9YLP0iXjiwlHL19iLURRQhDGyCBBI7BSsVhkPH9+zHKRE8gQrOb4xTN2drdotVsUOsdiaCUBB7sDXr58TEiKNJphN+ZwZ0Dc7vjr1+iyx9Hzp0gZcj5ecPTiJfuHN1GhWDerBDqtNhejc7LFgk6ngzEwnS4YtBP6/W1uHN5CBorlckmhS4yFp0+POD455f4b93jjwX2CIHZKj2LFTbpz9xZpOufzR0+dGIXOUUFIWWQsszn9fgeADz/8iCQMGPYH3Lp1k1YcOxat9UOywiDkgHZ7h97wJscvPkAz5f5BgHKjeG4dGNE0T76yPbEmDiFsoyPfaEusWUy9vmbnZjkQNDudmEvke5qMli91WDRVLKRc5XeiUUSJlXWAaNoa19OS3j+jIhh6lQ5UiKgFmKXXGlBYKTDSYIRAVZI2QcjpiUbH9wgHd0m1wCiJ1ZqLiwtOTkcYoD/os7W1TZIkaGMI/E5qsY4P5W+8LkvyvGA2m/Ps2UvOzl9SGDBCYa2bSuv2uiRRi3aSEMiSwaBLu52grSArDKIs6LYDpiePGX3+E4Y7Q77zy7/O7rBHqg1WCYyFqBXT6bQxRrJ/0OPp8yOOj4/Y37tBklTzJxZrNIGSRIEkXc7odTsYoMhLilLTilvErTZBGDIY7jCdTkmzjDRdMJ8v+KM//iEX4wu+/e1fJArUSvwASxAo7t69w+nJCefnY/JsQBQFKBlgyoLFQpMXBZGEm/fuOcq/kOSeIbty3pEIY8mIUXGb5GaX8/NPaJ8+586OO+nXqEaNrd2Kq3d6cSnT2WQW2y9I1a6oS+wrYN41xqz9+RkQyjUUbDVdaMRlYqNcM7dvnCSimgZzk4pWarcz1Y6pAYaIUrTQSjvOkoTMKs7mBcnNm5iohc4ti3TB8+fPKfOcnf0Dhh49MtZxoIyVfg7EejhW+2LY86mimO6wxZ4OUFHPp2qeb2UbU3SmQErJzcN9tnaGIAPSvGA5uWA+OmE5esbs7Jhs3Cb53i8SKU1hjNP59elCnESML+YMtre4ceMmx8enPH/6lJ2dbXq9nptqNJpASpIoIE8XDko1ljIvyAsXoJ3BgPOLc5J2l15/m46VLBYLsnzOZHrOT37yAUEQ8c2vf40wDOodzlhLp93hxo1Dnj17QqkXWFos0yXPnk0wlOzt7nH31k2iKKLUlX2DYIVkVyohDqotrEVFA4LBPY7OTuinGbtteZkVv+Hwajcz/I31Jleqwg1HXD/+YO2XVLj6KUQbrryqawKpVg2XjlVrZbMYp6Yoiw1n2IpOYqv+iKgMZgRJHGInKWUxR4YdrAl870UgVQ/V2uNo9Am9w5C45YiKi7kgtSGD7pC8FJyMzhmdu77BvTu3iZKOSx2Mdf+31Y323tzen0L6mW+EcOS++ZL5LKUonCiyRXrVG5c3KwlZntHvdTg82PNsXEkQSvrxgE/PPiJdnBCrlHI+J1+OCIISoSu400nQtLttzkYX7mRq94lvtZiMJ5yfnjKbXNDrdkjikDiO6LVCThcX6GKOklGdGmrdpT/scX5xSmk0iDZWRCSdFu3eFts7h2xt7fD06XN63Q5fefshpvL68/2HGzcOsVZzdPSCUjvu2Pb2Dnfv32F7awhSkZVgbZUyOdaBq2mcRpXWJZCDhNRIgs4WdrbHIn8CnfXdW7JB6N2oO/7V/jHXNQp/ngBVw+q3thdrGNt7TaY1i+Imru11kmS1+IQgCiMCVZLNT4lbOwjrHZYEWBQ7hw85fjTnveeP2O0JklbA5y8mpOyAiHj85Cmplty6dZtutw3WOIp0IxC1sRRl6dEoTVG6gtvR5t2HbYxhOnXUdKOdx4do7DouLZMUecrOsE2chBTaOR0F1pDEIZ0kQusMSU6pcxaLCYiy5rtVFvdbWwNePD+i1BkqkERhwO7uNr1um8lkwmw2ZTLOiUIBVrOYnrGYthgMdrCUWJtizJLhoMUTpcmKJWHUcbMUIvS1Gmzt3CIKQ549fcG9O3dIWgllZbeMpd1pcXB4QBDFvPngTdrtLt1ezxE/EZTGz+YbZ5wTSAP5gnQxQWcZcRgRdTqESav2/wjKHGEypHRXIddkQjezEXHtNOIrkaqfMf0Jfqa5b9F0jLBrcqB12tTsY3g17dXsvVyzL6tOnFrIDbGyE0MgA0m/BRfnz0iG91Ay8gW+a9aFvT323vpl0ovbTMopWRRSdEaki4LT8ylFYTm4cYder48uNcILw5XaYnAuQ8vlknSRUhYOZtU+QExj6swaNz9dlhYpQ0Lft1kN/zgRaG1yklafIFRoa5DeNLIVSQIlMKUr2o02nJ+dYXWJJHSvIpyO07A/YNDvMZvN6HRdnSOEJElikniXskjJsyllkVEUGQjD8fFzJ9IsJNosETInSSLAMDo7Zf9wgPS0dmPdOK8uDUnSYzw+5+TkjNv37jhGgjciCMOQu3fuMNze5ebNO2ht0dpQGiezKixYXVDmGVm2IB89Z3H6GcpcEIaWOYJWt0d36watzg1iCfnsiLY9pdMJ0DavDUdfV5R83e9SbBj1rJf3l37+ih5J3dC0luCySuL6gze7lM1RVyHWVVIRlwNE+k646zPIBgFxNeC04sOImhaywghk4/+G7W7A0ekZ6WREuD1AW+0WAmBQyKjP4HCApEApS6pOefTHf0R7y3D7zj1U0qHU7tSQ1sG8aVawzHImswXzyYw8K3ygLGr+UFEUzufD00SUDFwiIBXtduK69YBUEiUlWhum0xGDd99YDZlhkMIQApPTl+g8RUYKheHF48/IFxNEsI0VpRfMcLn0wf4e5+efMp9ZWq0eUoTe4syCLTFWo01BFAXcODwAYRkOByRJCysteV5grabT7nAxPmM+PScIMlTYck07aQmwvtAPGJ2dc+vObUfv8VN/UoYEYcjxyTFxq+N8N6ykNAJdWqzW6DJjOj5ncvac5Ys/5he+MuSb79xkkFgwBbOs5Hz6lHT2BISgK3N2tyKioHFq2pWmWd0Ks6zLmdkN1MlWBpxVemTXFmo1C7MSPtzQb/b/MHZFx7emCpAvYNe+2kFWrBXYa8U2XAqAJne9LsgrWNdblck111xRF4pCSrSAVizYbqWcP/tjbnT6hPE2uXH6Vs5UJaQsjVv8pWU61/S3DtnevUEYxZ5GItBaoHXJbL7kYjLlfDzh9OyCMstpRS2EEIRhTBInBEGI8l1+U880gMWlYKUuMNppRZnSUmJZLhds7wzZ2hpQlgVSOtHRQBhEmXP+8imBLlDGoXxnz59w/uxz9u5vkZvCacd69fWdnS0evnmfp0+fMZ+NEEJhtHbXJCTdTkzvcIt2u0WrldBqtYii2DkwCeNPAs2tW3d4+6slo7MLLkZj5osJxgpHmVfO/SqJFIv53DkEiPVVGUcRj588RwVtnFy1RFuJ1QbKksV8RLY4Z6tluX0r5JsPumy3c5SeE0pDuxuy3RYYbQDj61Pt9NPs5am5xXKJsU4hJorCS6TETUfaVcDY2ljUWFMLwlU8Qafc35AfFas2hzUrP5HXrkGuChJxBTK1FiB2JfJgq8XvKeeViILwWkbS09mFbDQLG66x1GOUglBqbu9oyuNnjD7/5xze/QWCZJe5VRjjOD9OulJS5Dnz5ZKbt+8Rt/uUSHLt7leWlZyPLnj58iXj6ZS8dHKge9u77GzvIIWjrSvZmLsXq3uhvHSnEZXwsZe3tJrFckaWhXzl7YfIQGKMdh541iAwLBcTTl8+c+5MxlFYltMLPvnRH3Hj3lcJvNSntRVAITk43GEw6DCbTcmLAikcrT0KIlqtDnEUuJSndP2EPM8xlYurMLU5Txwl3LhxwP7eDqenZ7x4/pzFbEacxEgREsUheZG7lLLSaWsY9ZQlFDlOAFs6aojOM4rFFEHKVx4csj+QJOfn7LUEolwiKDySpQltg9eBcEY8XqKhQa6lNIbFYuHTW7cZ1Ly9L+xeePNPP4K76qvYtTqmOYS13r+jTvWCTU1bQdO5aCNIpKh3edk8Caoao5bRZ3UaVCaWcuX3vaJw+D1BrhMiawddiyPoCbFSW5KWmILbh20enbzgyacp7Z03CYf3nc6TD1ap4Gw0RqrQEf20oBCu3lgsUkajMS9eHDOdTml3OvSHLVRwgQoCAqXqlDHNM5bpAlM6zXbjh/qld4QqTel5TAIpIS9cvn/37m36/T5GOycmawy6zGlFimfPHnH08jmhknWRLIThRz/6AQ+//Svs3n+LsigQOOdb7bVu2+2ETre96gsbZydmjHUBYRpWZHhbm8awkpQQBO46ZRhweOOAQb/LRx9+xAcfvE+n3SKQkk630/DqWKkMZmXm0EUZUJaWfJmRLmdMLk7YH7b5xjfeYrevGB9/QqcV0opDSpO600KY2uTzKgkP0Ujf3QhQwPb2LsYYtCnAWKyyl2wv1jHTV2uZCD97c/U8/HotYzcbhc1TojkrvJk6rU4MscZZkmJdAlI0TxXZ8OOufi5X/Y6VIc5qQEp6arPxjkiVjbLyb6CjSt48jJkuJ5xe/Avm42ck3V2sipwHh4DT52fs3P4KMozIC0OhYbHIOT465fhkxGKZ0en2GQwGKKXIspLxxQW9dkSSJMzmc7IspdNts3u4T6fTRghBnhfkeUaW5xjrAkAKQRgFxHHE9vYOYRiuW44ZjUJT5hk//uH3SZczkkDUImlKKU5Pj/kHf+9v8dt/eZswSSht1S8PvL2zawqu0gqPMZUarbXjh2lDWWqyrCAvbC1t5JRQYuJEEMVBTQxst9u8++67pOmSyfiCssiIonBtPqhaNJPplNH5CGNilssSyoJ2KDH5lP3tXfa2BkxOPkQUZxzeSlAy85vKSiq8og9dDweJegNSUtYutNbqK5xeRWOYr0FTxxE4V30RL89tuBIJ2/SYaQZfcC0K0KgHhG/w1AMWXrrT7ZpVgMiG6LRYnSSe6bpOm6+E29bnSOyaHpZo6EaIWsxa+YI3xNCSmp2h5LAnWBRnZPk5pZGgYqY6IDEZe8MeBRKhFKYomI1nHL04Yr7M2NrZJ0kSlAyxBrrdIVm65OXRC7q9Nr1uh3fefZv9/T3HybGgtfugVC1E5+dPam874wu8qhbzzSpTEgXwyU9+zAc//gFRUI2Dmno2JAwkH/z4+7T6Pf7kn/2ztNo9NJkjQRrlXW09TO7lMZUQYEuy5cwpxqcpeaHJc02mARRBEBBFIYFqowJNmEha3YB2JwEJSavF177+dT7+6APG5+ccHB6sK8lICcYymUyIoogwCEiGXVpRSDdSTM4yOhGkk5fo5RH3byh6rRxj85WAuSd1XjlH1Mhf6k22add2zdRes15fLfLNR5i6Fqmccq/tol8a9W3WIM1Xa9YCgpXEffMkkbIu7GQlltD4mRTrA/vNE6IKEOP9OFb1+Go2YKUeKde66oGS3nrZdbitNoQypJ8ALcfHklHIeRowmllCKcitZZllzKZLxucXvHj2jKTTc/pRTqnXpZZKsLuzw5PPz+h3d3j3a+/S6XTQpiT3Soel1s7pSYBSgbc2KB3pvZbn9+qN1rgvDGFgOHn2GX/wj/4bstmYUBpvZL8uVCCt4Qe///cx2YRv/dJ3Obj9gEF3FynjNT1xrQ26tCxnE54++pSnTx5xcnLMYjGjKAtKYzEigKBFO+mxtbXD9vYt2r09ZCpZZBGLZZtBv42xhla7Tavd5nx0yu7Ozip3txolA2aTCdky4/btu8TRFrqUBEIgbYYwOWV2gpmecHNryY1+SGAKr0jZEE64PEN7fYNhpbVQW2I3Cbib6ZSw/pSwFaO6aTdRaWiZNRh5bda9KUXauNbgqqNGypWws6i5UOuplpINgYRKZqfqV8jGKVE3vcRlOaBGUNlGE7FWv/AkxmaASOGkNL17nZP8QfvveY8HXSILSYCTginygvF4xsX5jNHoHCEkURBSFjlh2Ko/L2NKsuWcO7dv8PWvfY2k3aYsS7TR6KLElNoxdbVL+6IoJIoiZzMg3AyGEMaZa6IQpkRREijD8bNP+Yd/97/k8Sc/JpEKYWxzotj3GwxKAGXJD//gn/Lx+z9h//A2t++/xeHhHZLYoWtFUZBlGZPJmMeff8rzZ49YLGYYXaKkrb0hSwvWRkxFwLGU9AZ7HN56g5sP3kHYfaZZibDQ7rdotyK2d3dZLma0WkljCs+NOj198gxBRKC66FIhRYLF9XqsyQlJub3XZq8nSOwS5XXFsA5Ob8rlrvR3qdfIVTFj6wlWueYF4gpwvV4f13bQpqYfXYm4bs6DWLsmNbUKqBrmbYyRikYFX3/vcv1QpVQuQNy/K4mdqyDgVw+6i9pAspILrWama2sGwYYHhZ9hroPYOiti6Y1XsCiK+mXy3DCbZRSlZjoZs7e7QxAmnJ+P2N+/6QNNkKdLijLj4RtvEMcRWmu0gdk0YzadoPMUo3MXhAKUECRJQqfjvoIgRFiNRRMIULKkzGZ8+OP3+P1/+Pc4ef6IWAl/qjRkcayoEwwByEAhEBTzKU8++hGPP/oRQgZOiKKB72lflEshCYUbtFKVULffUa1wO6q2lnQ04vHkc+azcx5849fpbN1gMp6RmRIl+/S6fYbDIWma0gmjGn5P04wnT54RJ32UiNE2qEdo87Kg3Q759tcPubM1gzxDevMc0ZBkqFL42j6twS8SDd96u2Ir1mn36mfOoPMqWBezbqVWeS+unQh+SnTTSroy8qwp8w3llUB4zlF94c3Z8kaRtpJakTUKpVQVHLI+Nb78H6/q3WT/NgJL+o66lKtmkK267BtKiw4T0n7XMljj3GmL3JAXFmMkZZ7T2toianU4PhsxnozpdTuEgSDP5uzsbLG7v4/WmmWWM5+nTCcLsnRGQMl0fMz4/AJdFijhXK8GvTb37t/hxsEuUGBNxjKdc/L8CZ9+8GM++uB9JuNzIi/KgjH1PRY4VnL1/g2rHUwJSxh6zScM1pa1dD9SEkqJNTgRNWP8Z6gbyJBDbaxP3YS0YAueffYTjEz4+nf+NUw0IF1qlsuCzrZTURxPZ7S7PYccSsXHjz9mNLrgra/cqUdoNRopDHmeIrOM8WSE7jujnU0xaNFk2Aqzmg8Xl2fFRb3wzco1ytcRdQA0XG/rFW+q7xlqWQi78hus1VSkrde2aRAYm4FBIzULmrUGDfyXDbpIlUoptUqhlKr6AeK1LJavpIXZFQqxTt5cf33hdyw3atpgdlpRjwQ7DcNKWE65iT8ryHOD0d6Xwjh/8G6vx2y55Hx0jlLQTiCONDdvHCKFZJlmjMdzLs6nmCJHlHOePvmIx5+8x2wyxprM6z9ZAmV5r+8o7QJNWRaU+ZJ8uSBPUzevEUUIXYDVGG91ZsXKxbWiGinR1KVdmbxU3KyqI0/lpyisU0LyJ6mtvS1EA3gRNQomsASkHD39kMPbb7B771uUhSVNC3RpieKYi/M52iuYjMcX/PhHPyYKI8IgprQGIQtUGBAFgnRSsr2zx8uTM3ZaETeHCYKCQGiuMmG6tD1W3oDWE3nq1oRp7P6mtn2msp7wBTfeS9A9xKwhfLY542Sc2qPW/vRunBLCrvzWa/WVqlEoGr18sTJQqNMoJRUyCFaSnV4afoViyVWe+CX4YWuMgdoUvuH9sELEG81OiSXACj8HLizKiobx0GrvVEFAaQpKXaK1UymRQmJs6akTksFwG2PHjEYjjrJz3n54n+3tLfJcs8w080WB0YJQwNMn7/PRD/4+ZFNiBRINRrudXgtmx6fMhKvfKsqCxJ2M2mg0ltinSKsCc20SrfZgEZ7gaWrqRWN6zm8WxlrK0r8X5braRVF4Goz0HoXULrDC13zWWkIF83zCydHn7N59F2MClsuU5TIlimKyLMNaQ5Zr3n//A8rScHC4h1CKOAhodWKCMCCJQ8pFzMH+bRK5xdOjR2x3BZ0gqGkya59KZRlvV3USDY8O05Tkbfp91o/3J0S1gKuutzGXO+rGfw5Wu23C13ymkkat5vGr+mXjWlZcLClWjqBS1B8satXUq/RtlZQOZpUVI3fVOKxNGK8KhiuU2e0aJNfg0dimVKVPp/zN1EjmWlE6vixJ2ELKEknm+iPWUxg8O9cYKIxBC7ztgUFrTZZlXjwtYWc3YTaVPH38kl6/74Z9ipzpPGexyIlRpLMLHn/8Y8jPiVUFr7pw1b5YjILAKahbQxhIut0Ot2/fYTjYQmvN6OyMly+eMb648CBH4OV9xJqSE6wLh9dGnD4N1sZQlJrh1hb379/n4cO32NvbRwjJbDblk48/4f333+f07NR9Xsrl4tKfMNpWPrsli+kZuswgapNnmjwvaQ9anq084+XLI0ajC+KkjQxi4jihP+zT7sZI4WbIg9AQdXr0ki3GT14wnpe0t2KsKVbyTcKu7P8QGKtrftRa/6GJKnmKiIPMPV3EmjqNcrGyHjBrqo3WuMDxMqjVxmN9A7QZIHXG0gjaqiEcOGsxjz03Zzb8yaB8w0ZJh6dLtQqkWn5FCqyxa8jCF7GD7Wpm0tlzGbtCNNanYCitQ51GE8NR3iJpbyOsIs6n6LikEwuE8akKbo6iLDXGuOAunMmGI98ZQ17kDi3zkHa/P+Dg4ICtrS3K0pAuXXA4j8WCF88+YXpxRNvZwrokzn9QAs8T0xoVKN559x1+/dd/nXfffYdbt27TaXcRUpJlKU8ef84/+kf/mH/8j/8xL549qzlrpsqHKyaDqOwEfKrr/2+sJYoSfvlXfoHf/HN/jnfffYfBYEir1fGjwZo8z/nk44/523/7b/P3/95/w3I+d57y1vhrdimaokDnC0yZISK3aHQJSgbEccyPf/xjZrMl/X6fUT4lCGNa7YROp0UQuk0xyzKQljBOEFGMioccnT3jYKu97vl0qai+ks9UN0ErV1pRMwP8KdEMkopJ0AyMOl2rUjLTWE9yVYz7gDGNQt2RL1dnewUNB0qpRoD4UyJQfhJLEqhKHd0hVbIy52sGiBCUpkRrvW57UJ0U2r4GVdnlnU1drcqpqbCS0UTz6KJLcvhtgq0baAOTyVPOR3/Eg31Jy5ZeutIhGPN0iRUDVJig9bJBSIPlcuFl8x11vG7UhSFaaxZpRmEsQiqyfMrJ8XOMzkBqTw1p+O0J5xHeHw743d/98/z27/w2ewcHSCkpPVVeKUm33+fr3/o273z96/yJP/Wn+L3/6D/kn/2T32/g+ram6jSpq7K2xIZup8uf++0/x1/+t/4tdvZ2Xa2jDfN0WRerQRTy9W99i4dvv8W3vvEN/sb/9f/Cs2fPHK1F61riRmGhzBBGgwRTOoNWhESpkNPTETdu3CIMIoSY0+916fXbhKFDOwMlmRU5URQTxgmZgWRwh9GLY+ZLQxLL1Ya5xlky9WawosW4icNKEaaaKa8WuzYGa7Tf4X0gVJuUWT89jLGrtMo2k+5V8V6dEE3LhmbBb+0q7Q+EUp4C4IttpZBKuZk6Vcl5+u/LdTkescmLqec4mkMuZtUtv4ZiJhoMgCprrX6PRpCViidnJdHu27S27rEwgQur1iGz8n3SUpME0nVDrKO+TeYpYfse2io/LeiRHCExesVXEv6mGuNSmFIb0tzBu9Ln9fPFfLXDbfgxWCztdoe/8lf+5/z5v/gXCEJnhYDQtdaXBQrtmL9CCN5592v8tf/d/57/c/ff57/+W3/L1XNWrPhujdtXIXRBqPjdv/gX+Ct/5a/Q7nbJy9JrEauaElQtumW6RCnFn/2t3yJOIv69/9O/x+nJMYFwjV1jBVJYymyOzlMiISn9eLEFp7/b36Lb7pMuM6IwZGtnSJRECOkgdSUl2XxOFCpQTjqp3d3DhlucXEwY7guEto1OesPCoIEW1dq51skmmfr7ZjV7Y9xgm6hTriaKtVrcri4xdRbBGtu3uqH2EpQrGjMgK7q9CyepAl+I1ydEZR8gUZ6A5wb6KhFrcVkupYpGX1hWf7cuX6gdTtd6qI2OumgQICuelvFOUUKF5HmAFrv0hvcobYCWCiMUQnVARl5ZSXqT+5BlBuNpSbd/SJZZtHY+2cY6xCcKA9Yt1EW9cxtjKUvr/QGrXUBX1D83617ZVEv3fv/13/pNfvt3f9eppJRO9rRqbFpPSTHCNT21gLTI2d3b43/5v/5f8dV330UbvTL4qZqwPq1VgbvWX/u1X+N/8pf/TZJOh7zUWFlpEq/E35zonQtKbQ3zLOU3/tSf5i//W/8zZBjWnoxCOmYsWlPmS5fSCYER7nmVGqQThCgZ9Lvs7AwJAuF0jv0pmi0XtKLI3TcBVkWE7W2eHs0oraIaMNTGYLTGmtItYGMbsqHa9Y58kw+rvXW1xhqN8UCIaw769KmqLYz7e12LeJX8KvWq+iP1l69Lqi82v2wTBbSrAT6pNpi2NGqS5qnwioafuI4e2Ri2d/ZhlbnNyiG3siZQgdsRpQpcsyyQqCAky0ta/QNobaGRTiIU6xafDF0QKoWRYJXi6VnGnH3C3iHzpaYs3QeSp0ukoJbzqVI5FQRorZlOpy5dLI2nwLhZierxa7NhQqC14dbt2/z27/wOcSt2p5CX3l8b1xdNYMItxkW6ZP/GIX/x3/g3nDp7tUE12MyB7yv1+j3+/J//8+zu7vlaJ2iMJeNF7MyapnGV+mpj+DP/+p/hnXfeodS6zgSUVFitKYulC3pcemWMIGklxHFEWWSURcpg0KOdRCi/DUm/w+uyIA6jGnLWBuLuDtM8YpEar/9ra6u0RjuiUVtYv3arBW0QRjsf87ru0DRFTJsGoVU6ZDyr2dXCpj51qi9ttLtHdqUbsAnpNpGwKquQVTEuPPGQWnbTNhgeYp1b1ZwJ8c8TXlXdjdiucSj8SbFyl13vvYjG68i1Yarq30WhkVELrSKMCCit09A1wqJJyEyCCtsI1SbTihczQWvnLUzcZVGUFHmJMAXz+YSyLAmj0BdprpEoVIgKIk5HowY06hZZFMVsb+/4cVDr5Rw8DGs03/uV7/HGG284FXfV8KWQ8hIprkmvcKe24rvf+x4PHjxwkKJSDXKoQCpJWRTcvXuXhw/fpiy0V1bZRANXvt6roSJR01K2trf57ne/69IU/3NHcnTsYiWsF5V2TdYkajHs91gspmiT02pFjnJSMS2EPxm0JnKmJ7WylWz1MGGHeVbUIt31rm2Nn/9wEHkVAMKnT6t0ydRFd3XiVAilbfRBqoafrfsnq867aXTWN7lX9XqrPdtlTaaUG4irrDmCyj9OVrKywh/bjfpCrvLcZvRZs1pVl3VtVz2TdbZvRVsRDR3dKjBo0Omtp1OoekqskgwyMkC1dnh+JjibSUaLmM+PLbL9gO7uQ5aFJC8M2BJ0xmI2YbFYIFDUp7B3wo3DkKPnT5lPxyg/8CWtRmHptVuEQtVx7/obhk4r5rvf+Q5J0kYIrwrvtWarlK/itinlUMAmdSfPS7a3d/jqV99x/RSp1iSSlOelvf2Vr7C1ve2aqn40tA42BHle+lKvQc8QKx1BYwxf+9rXGAwGaGMa462G6cUZtlgSoJGmRGIIpWB/Z9udIGVGqxX5Tr5ZCbMBF+fnLBbLau4Tg4EgxsiY8WyJQdQpkrUWq0uMLkAXYAqEKZC6QJocaUoXKGty16ZO54RtKG3bjRO5mckIsTGf20RSG0ZLVCavov579bmsWOoCGQQBQRjUaJUUq7THWvyUmiYvS7Ki8Li/XeHYdtX5lbUIsQ+Kxu9q0tZXAg2yhpOFuEJh3idBKpBoXSK1O369sjXaBnR370HnTT4cb/PJbJ958jXa+18nE12mM02W5oS2pFxOyLIlnd6AOOnVurrWOog6VAFRKJiNT4gD6ZySTIm0BWWeurqDVWdfG02/3+fg4ICiyOue0PqpAUopzs7O+L3f+z3+8A//0NmmeRSlLEuCMOKNN95oaM56hMULRSipuHnzpteqarB5jQEpOD494f/w7/67/L/+0/+0RmZqcNNfi9aam7duuZPQyzBVcPL47IhyOSGUGkyBtAWmTNnZ7rO11WM8GRGG0qc1psF1gulsxvn5BdJLrlqrnV1bZ8BskaONrTWLjXHiFMbXI1obz3UzdW0hfD2CdaiWsBXX2vr07nLzYI0IXnMAN0WoG/xf/1rGXka/6oGzRhoYBGG4Pl7V1H1s0EFM6XYPGXpXp0tHliAImsVvM7fbVE+UjSGXRorFOkTsbpST6jybnZFkY2TQRRJSWlegynBA//DrIDwCQkxhJNN5zsV4Tpbl6CLj/PwMay2DrV2Sdt/p/fpFqXWBsYYHDx6QTsecjUa021t0Isni4gUvH3+C8lTpev7JWFQQMBwMalLl+sBZdYMDPvzwQ/6D/+A/4Ld/53f49rd/YcVDku71e/2eM7axdl0kszFMVf0+6wUNKgQmy3I++fRTwihEGyeWZxFrH6WxligMaSUxylOEjHaLbjZ6QTo+ZpjECJNhbeGasEnI/v4uH374HmLdvKm+xrwoOTsbOShbugK/MJYwbrOYFmgdukIb7WFclyZV6ZRl1dVeM2Sz62wLuaHZbhoMcet7U7biEkrryZ+2MWto/Rz6qlcnbFMDW1zryR6sjEvWc6/Lo7hNL9zVhYtL7NxVsFULxqzBoqLBvarJLY1h/KYTikGYgmE75unZYy5etujc+Z6bzDPagRNSUYoQbZw/hzaCZaY5v1iwTDPKPGM2HZNlqcfsuxAmzsbNOnSuLEoEgt2dXcZmwX/7N/8Teq2Ifivi4uSU5eiYUJQethQIA1Io8qxkNpuxtb13SeiyKtTLsuTevXv8zu/+Lt/8xjfWqN7gfn4+Gq2NjgqapFGYz+fOG9xL+Qjraf+l5dbNW/y1v/bX6HY7KOVFJXywGasx3hk4S1PyLHOoD2WdCRT5jEef/ojWoIsJLWdngjzPybMFuizp9fvrC8ef7NYI2p0eyyzj0ePHdLo92u0OURwSxi2yUpMXJaqmc+gavhW+MSrqZt4VJCS7KsJrxNY/R9pVsNSJfDVkJdaFcmuLwkrp0TanSexqCt1ebacQGGuu7HTLq5jpiA2pn+vkf1/lzdCYtlsTZ1j5yRk/KFPNfESB4c5uyKenH3MhW3RvfQNkG2XcdF+poTBQGsiLjMkk5eJiSr5ISRcz8ix1KUoQ0e4NnY4uyt/5grLM6HY6hFFIFEcUyxEvj044tW5iL1CBT+1WH4xSisViwYvnL7h770G9G9kNEEPrkps3b/K/+Xf+HSov73o4x1iyLOfR48fe/kx6yJa1Zunp6alb0BsuM1UQfeMbX6/RmianiFrmRvDs2XNGo5FLL7welpEAJc+ef0qytcvw8C6Fdh4hWwcHDAcDwihozFg0W1uWe/fusz3sI6Th/Pycs7Mz+sMhw0RgbEip8UNVNDhTzcVvrx+7bdDSzVqXfBMfbdRUV0mrVylT1aZoyJPWyiZrk/GbJ4h5hWWaP17k9ZZSVzEGrrzAS1LdYqVnby912FdB5FoRJTu9FoE0fHryI46nJyS7DyE5RKge2kChDWlRMplMmYxnTCZzimxZd26tkHQ6PaJWx5m5CM/iNAXWFAyHOwSBk/BMkhBmAUqUK7p1o76oCup0ueT9997jV37tN9Zg402ad+kbhGtOr8YQCMlsMuHTTz5pyPc3JGisC6b333ufi/NzOr0eRQXn2tVmWJbasdP8YrSNaK08af7oB99nOp3VFm9VotJqJRzcf4O3336b3dtv0uoM3EcjnSB4p91rTOc1NBeEGxiTUrG1vU233WE8nXA6GnH+8pytWYGgA5T1Asc46FfS5EDZy+lpdbo0qvGqRl+feWp2vWks/SbRxfGvsHYtE7p63dpXpFivUG60G3rZq/Eeu0K57CskH6+SV7EWa1Vjs7B+EVYUcNtAmQySlGFX8Y12wrPRS548+pyzfAvULkYEaOtI5LNlyfiiwKo2KmpRaIMVsL29Q9Tqo1FgXANUWE2WLZHCsLU9cIaVrYRut8f8+AVKioYU8oo4Kb0saSAlv/9Pfp/f/O3fYfdg38nxKPFKwf0altWGMIn4/k9+wrMnT5FKrkG1AEYbpJJ88MEH/LPf/2f81u/8NmWaOpi14Z+mhFxL34Vd1R6tKOL05IQ//MPv+53U1X9lnpP0h3z31/4MX/2FXyXqH5KTkBZuWk9rjZBOjE8Xxp0a1q7U2oEgcPZvuuwihWJ3e49ut8fJc0N2Ljgfp+wPnWax1a4IN9bLvFpRDynJtRW1vl7qjjl2YyltQrfrEK61V+rM1YNa9spP5ooT5LIR57qSnXhFquTwYHtJitS+xgtfLntedUJpPwxVEgrLvd2QG8OIRQ7z7JRpqimNQYUR8zTik1IzNYqZVgiVMOgPaHeGGBmijcezbQk6JVtOODzYpttJ0DqlnSTs37jJk08+QhI4fhIKaSFAEErjKPNaEwQBn3z8MX/n7/xt/uq//W+7cVk/0LVJp6lZudb4mRTBbDbjH/z9v8/F+IJASNdtbtBytHWDVWm65G/+rb/Jt37x22xt71BqvQrWRs5t1zzGjafeW/7u3/47fPTRR4RRjBGSXAs6e/f4lf/Rv8a73/oeNuixKEJyDXmhKYqcssiREiaT+aoxWYs4uIXWarcZn49qmo7ri0Q8ePAWul3y2Yt/yWw542AgiZVdiXtLg2ykUaYenmqO1W5SSqp5jwaF3m761lzOSKqRb3udOMkGH/BSgFxJIBSbjp/XKFFUZ15ThlSIDfRZvnLtr0f4eoHTHLB3p4hyu5vJiYA4lgwTCYMIayVaCj56dE6earp7txn0blMQU2qBJgQROgE341KM5XKCknD79k2UAqMtZWnoDHaItw7pdQf0OkOSpIdCcHH0jIvjTxB2BrZEGo3Rhv/3f/lfcf/+fX7jN36DXJeOUl5PzfneRTVFaAyhCtBFyd/+m3+Tf/EHf+CLUFuLFIiN0yaKYn70xz/k//F/+7/zv/irf5Vuf0BaFLUCiPUwiCueTQ2hh0HAP/6H/4i/+V/+F46GoRSZsezcvM+v/pnf5c7Dd8lkiyxXjGc5yzQnzTLyNEPrEmFLlsuF0xbWZR2IlSRTu9Xh+OiI07Nz9raHjr6vhTMyPXwXG/d4/PifUDLh9naIJKcyljAethVX7KPG2EbNx9qEX9UXa1Aa1qS2bAOhqhbyCqBtOExtnjDX2Imov/rbX/3rVXPG9fLsapL4igBZdwLdgGkvib+t6Nvrnuo06CuWlYvVOmOrJoz5N137PWBqdMI4ZTlKHXI0ynhxntG7/Q3uvvvLbN+4B0Gb2Tx3RbmVYJwwQpHNOT97ye7uDrdv3QBhGI1OePHiKUmrzbvf/CXuv/VNDu+8zc7BfQ5u3Wd/74Dx+IzJ+MwLoRmkVEwmYz75+CN6vQ7377/hhrWKAmO8wIM/NUKlaLdaTMcX/Gf/2X/Gf/If/z9ZeHqLbbBLHXfNNpSe3O758YcfMjo75d79N9jZ2akXWEXTcJ7rijgMmU7G/N3/+u/wH/6Nv8Hp0RFSBpTWcvvBW/zp3/nL3HzwDksTcj4rOR1nnJ0vmC9zytI4dNBYiiJnsZwznUw42N8j8mIOePcpIUXd51FKEsdRvRgLHDU/EjGL2YxOFBAoT2Ov07QVjtksc41Z9VuqEQg/UrWRvK4zFSpttrUOyJoHul3pWm+0New1Nh7qr/7Ou399TbFk7TS5OijWTxO7zvlvzPva5ujo2uJvYtXrz19jaTZoEzV+ZI0vUAO0UJQyZFnAo1PNyBzQufVLtG+8QyFaZKViMnfyo8azcYXR5OmcoxdPENKwv7eLtZqz0Qmj81OGgyH3H7zFcPcmRnaYLCzzzJCVgk6ckESKF88fYbWjaGCd/cH5+Ygf/fCHZHlOvz9ka3uLKAoJw4AgcM3S4+Mj/sW/+Of8h3/jP+Lv/p2/S57m9eBP9QE1nXXtujMkWud89uknfP+P/ggpFdvbOyRJQjtpEYUJxljOz0b86Ec/5vd+7/f4z//z/8Iv3pCs0Owe3uTP/PZf5Nab32CcSi7mmvNJymTmROZ0aSjylOnEWdIdHx1zcX5OWea0koidvd3VyKvfmludDlmece4HtKIoQqnAz68IWmEbnS2Zz0d02oIoFIjAMcYrrzfR2Eyr9LAaanJrzbBuAGivQbwuI0WC5rrcqKmt+MIUX/yt/+O/ebVhT2MuQTRSp0qq54ucGZqvLRpNtnV04YuRsWaAVEMyGoUWEXkQMF5anr6cQvcrdG/8Ajo5ZFEE5BrG85yT0ZQ8d8JuaM1iOuHifERZLml3Ygb9HrpM2d7tc+fuTXqdHqBYpJrz8ZLpJCPNNMJClwUiO+Yf/Tf/Men5IxJlsdr4fN+feEHA4e07fPWdr3L71k26vQ5FUfL06VPee+8nPH/+gnSREgaxo9cXBdiG1bYwnslq1qWWrHYnvJQs8oKk3ePu3Xvcf+M+21vbYGE8HvPJJ5/w8uURi8Uc3eAcBVHIb/2Fv8TXvvMbTIou54uIF6dTFmlJUVpMqR0VZz7G6JJOu8V0MnZp7KDLcj7mm7/0bXZ3tt1ct1BeZMIV9eOzE05PTghUwHA4JG659xebkra94OTxH7AdTTjYVmiT0VaGdhISSokyJcp30YWnvVM19MAzfD0jd62PVPU27LqfrF2vMqoOufVjHdbTbGgghxVSdxnFsuaKZSk3BKSrYR6xVne8UvyrWUtYew3SfQ3kJq4u8Z3jrXDUdREwKzTPTixh7x0G93+JhdxmUSoyI5gvM87HE4o8RwmJLnOm4wuy5YKtYY842eb07CUnJ0e8+eYb3Lt/mzBQpDmUpeFimjKZpl6+U7n3LQ3aLDE29Tu88gmCrpm8uix59uhznj763D0iCD1psCQInHSPUCGZdmOnQrquNlrXHWnp/RVFo3UvvRgz2hCFEWWp+eijj/nxT36ClBHtdpdWu02SJGzt3qCvSzKdkRc56TLj9t373HvrmxjZISsVF9PUT01KdFEyOj2hyBf0eh3a7TZxGLBczOh1ewwGA5bLjKdPX7K9NWykw64poqRke3efdrvLZDJmtlhyPpk6sqewtGTG0u6SFz2ymUDpOcosaauUwx1FP7AIYdbmi4SU68qK12E9r6GDIBpIaz3r0bi/1Qmjrw4QuyYpv0bs2riKNYORa4ZqN1O1V4TBJarK5glziT3sr9MIRW4lzy8W2M7bDG79CnPRcwrvwvkAXnifD6td8XlyfMRyPuP+vbv0uh1KkxNFku3tPd588CZBFJDnJWlmGI0nLJY5ebnC621RUJQnTI8+JZ+fe3s26Ul6Dd1cz78SgXKnpHRTiyp0pPJOd8itO3c5uHGTTneLpNWmyJakywUXoxFPnzzh5YsjsuUMyP24LGBVvYBKLUBBqzPgwa373Lz7gBs379Dp9YiTxOkCC4FQlqzIOTk5YzHPeXa6IF5ekNk2k2nqC3rFbDLCmozd3W2SpAVYjo5fMpvNuHHjAG0svcEWZ6fnvHh+xO3bN9xEpgdoK3ePVqdLt+cEu6vhK2UNodAo8RChFAGG0GaYdMLoyR+iRp/T22/VKdXVC78irb6ukNQVa7MBHsmr1pxoEDGFqPsiwQoKEw3tkHWo126gKlddqfwppH9qeaEvIxMkBFoITsaaXNxj69a3yMM+pRVIqUhzzWQ8JU8LiixjNDolW7o5kCgKawHl2XzG1tYWX3v3a0RRTF5alpllNBqzSHMKYymKkvl8RpbOOD95xuzx95GLI3SZoXyfoaY9yGbHxO32GklZFiBDDm/d4evf/EUevv11tnYPkVEbQ4AKQpdWlSXKGrLFhBcvnvHej37IRx/8iNHJU6zNvX2bJ1YmLW4/eIdvfPt73Lj7FgRtFplllhaMlyUsBTJISFodkiRm/02J1jmT6ZjjszEX43NQISqIuTg/pchTdve2CcOQPMuYzeacj0aEgXIjt1YQRwm9/pDPPn+MlIIbN2+gjV1HkGw1lShqyR8LGCndJmJAW0lhY8J4h8Gtd8gevUDrklCJaxe6EI1elG0gpvbVJ8alDb2xeW8+1dHc5SpF88yRtT6IaJjWrKVJTVcprk6XxKXUqTnMaF9LyOGK86gxACQdxd0aFjlcLGM6e29j1ZDcQGGh1IbJeEy6mLOYLjg6PsYI2BoO6XY6TCdjJpMJxjjtqptv3iNKIifzUxhG4ynTRebm1hdLFvMFeZHSbscc7O8w/qwgXSyIQukFG5qCaKstRgqBBrJCM9je5Xu//id56+u/wNbuTQwJy1KwnENaaKTy2rzWEmJJoj4HD7c5fPAO33jxq/zoB/+UH/zhP2F+cUFoYW93h+/8iT/Fw29+l6C1zek45eR4ziw1lKZCDyWWAns+QSpJHEsG/Q7DwSG3+wfExye8ePmMs+MjytKwu7NPFEq0LphMJkil6HS7zo8ljom9SehgOOD45XO+//0fIAQcHN50TUutV0oyjWG7SgvXVL7e1n1+yhjXhLSKXDcAmFqf+KogaTQTrWiMZtt1Z4JNHqCx16rtrFPlJZ6Du3YIBPxUad26EHGlcijZlJNsTp1sPN8KXn12yA2mr8JgKLCcjjUqvkXUuUNKQoljki4WC5aTMYvxhLPjM0IVMtzdJ45bSKDb6XGeZ7x4+ZwHD99gb2+P0hgKYxhdTJgtM4QMyOZzLs5GxHHM/t4ucRwQ0mF8cMjz8fN68MsYZ1JmrED5wslY7Yx6SsP+rXv8a3/uL/DmO9+iFDGTUlCWgrQQTJeaRVaQF3PfaJOE0hIFliC0JFHA9u4dfuM3D7h5/w3+/n/9d8mnU37lT/8Z3v72L5PS4sVFytHZjKyUFCbCisBrHHvhf+vUXUptyPI5RSHZ3e5z4+Zt2t0W//Sf/j5GGzrthOViyWS2wFrB9vYOeZ4SxwGD7T6tVkwSRnQ6beazDnle8P4HH3AxmXLzxgG9Ttd5txhHyZEVcilMPUBWU2esccTFvGB09JSuyQlU6ICODcUTscY2sZc6Z7U+Qi38tiLGChrGP4Iv5+nZ4M9/aZdbey1B8frmubhCSBjPvrSvfCWxzve3gmWRMM679LbvYMOIUihKP9Kp84zl5JSL509oR232b90lEzFGRBgLKnISP4vFjFu3bhOEIXlRkqYZyzR1vKmi5OL8nCSMGAwG3vpLo5Ria3uPZyomM46dqoQzIhNWEHjdpRLJvDAc3HnAb/75v8y9h19jqRWZjplnlvkyZ74oyIqctNT1EJRDsrzUDwYlSkYXJdvDNjff+lX+dLLLs48/4I2vfodSbXM2KTid5izLGK0twkgiCVKULp0Rru/hROgUVkvOLxZordnZ6jEcbvGdX/ol3n/vfebzKYvFkrK0DLccMzlQgvv3bzMYdtzAlxBoWzBfzOj1+uzt7qNLzeNHj2knCbtbfbZ6A9cLMVXXQjtCpBQY41QjYykR5YLZyfsk80+4uRvWk4rXreTryK9VoW3NemCsDqPX2OorSHlz+rOmmmxg7Q2WFT+dmOj1M+lrUBy2Fhi+FuCt7Req5FMxXQqM7BN1dlkgvM2YG01djCcUk1P6wTlRCBGaEoVVEdoYlLVoCzu7Owy3hn5GWbBc5pS5ASTz2QxtDAf7+wRRRGkKrIHCGjKtUJ09+oMuh/t77G4NOX/5ks/e+wPQC4QQZKVl+9Y9fusv/U+5++DrzHLBsgiYZYbzacpsmWNLgzUlUmgnjNEASbR2gztaCLKiZLqcMFlk3Lr5EKsFT07OCZcRo4VgnoEwilgYJCX5dEReTCkpCZIhYTJAiNA7BSuMtkwnSyesLdrs7u7x8KHmB3/4h1gEOzv7JHFEqUuiOODg4IAoCvCMF5AwWywIopjBcJftnSFWl1ycHXP0/Aln9jH9TkC/F5O0uoggJheCEuH6LFlBMXpBmD5jrzPj/r6g1xIIm3+hAfqaqN4alYfVqeUtJ6ytpi5fLzjW0y3RkCwVTjjuquzfNsZSfqqgqISDN+TtpX2dGmSFX9fpmXczmS4WBHEHEbXRfmhKWCizktnZS7pqyv23hzx+fIGdjwnbLazRaOtSNl1qtoZ94jgmL3KsFV6LSVDmBScnx2AMp6enTqrHG3QGogDV5hd/7c8y3Nqj1+4QSM3uwZjJ9Jjjx+8jpCIZbvEn/vRvc/fNr7MsJKmRjKYpo4sFhXbaKMJKQiGRNkdnJUVZ1LZvwlriIMBaSwFoLTmfzGknMTs37vHpxx+xGD1GJUMkIYHVlNmczz/9gBef/5gsPSPVGVF3n69/60/S6u8jI4uKRI3OTKdLklgShAmHh4dEYUiaZnQ6HYQSmEI7a4c4cM5OFb/C4sTihCJOWrSTDlIaBp2IIB/y+OMfcvzofbItwdNnE/YO38F2tiiRIAKiIGZ+9Jjb7TPuHQ5JzBRlte9zmHpVmLq+8O2rxkpXm8HRZJXYjUnDJpFWXO6PXN3aYG1oK5BSrvNdvqizKK5iUYnrG4av7Jtsyk/WpZe7YUKsjfZaa9FFSbS95QQctHT0ESuZZ1Py2SO+eiPnrf0IJjM+Pf8Ioi5Ktdw4JxZdFLRbW764q3YbZyEwnU6QUrC1vYsSkpZSyEChAkmkJJFSRGGCNjAtHXbfanU4fPMbvDh+gi7hT/2J3+Tdb/06yzxkvCg4G8+ZLTRFVhBIi7AFi8kZz599wvTsJfPFnDxLHS1dBLS6fW546DYK22REWBNyMc6J4y1u3XubH/3wB0RmRDfpcPb8ER/+5F8yOXmENHOkNAhtIFB85c1Dwu4e7336HJsv6PYGYAOMgdk0JU5C2oMWd+7e4dNPP2e5XFKUc6azGcNhh0BJT9VXK31cT0wMVIiwgkKXtIUhtpo+Zzx8a8juYYd/NJuxe3OX3o23yLRABRHtpM1sqLBn/5xIFQTG+s/FrPXA3HSg9MNd9nVab1ekZBUD2zY2ffHKjGW9Me6LdLkxJipeo5G3gst8Dsj1xcSmMbxdO97kZqdlvf7wuaFpbA/aGMK4ja4UULy6u16cE+oRNwZtIj3i4a2IuZnyfPkMEfZARChpELYkVDiRAF9gWz9AlOc529s77O/t1xyvFfotwAakJqjn0q0DcmkNb6FaO9y/c49v//KfQMsWi0XBZFYynpYYLVBGs7g45sln73P09H2y8TMoMzdSWzWtrGB+Kjh9/iFnp+/w8Ou/hurtY61gkWmm85KbBzsMBn3OXzwjWFzw6Y//KeOXnxHLgkC4uZPCaG7u7fHG3VuI7g7jtORH732MFDDsb6OtYJHldHPnUnWwf8iPfvgTpDpHBSHpconc7q2p/tf6zdZ4O2sLpqSUBlPOOXr6Hl014d52m0QuuL3XIbXaNUq9FVxRardedIGwXoe/MVFYe6Q0nI+rVHx9sOnVElTNFXWJpSsadghCNhjEYkW4F6tDI1gjJK7Nplc+qRsOQA1p0Gqmmg330FdV9isfRXPFeFF1JJqaZFbVGGCcMqK1XjGkIX0K6MWU7VbAdidClDM6LcPDOxHTjx8zmUa0th46EQCjiaS3HfZ7ja6m8ayl1UrQxqCN332EcFmeLyCFNKsxYuvGYJeZYbB9i1//k79Ja7DLeGk4nS2ZzJcYUyKs4ezlZ3z0w3/GZPQEqefEokAEoq7LpIdsQiS5SXny2UfocJs3vtYjaTuZomVWkhWaG4cHfP7ev+Sjzz9mMnpOGHjpzgYEevfuHcIwZDJfkCQJvW6Po+fPiVVI0h1QaChKizbCG+ds0e0PaHe6xMnYI3JmfdjaWgIpKK1GCYM0Ja1izuL0PcLiE+7cSIjDkkAYWq2QhSm9Yr9C4Bun3rtFuckc8JR8UfmGWesdBCTWWDdfY+WVnugbNHIv9sea56UbGmsoJVwLacmNEV3fKGymac0RWDYoKCsm7eZ0ob16Lr3Bidk8QZq2Bw1Eu7FViYZsJBg/EaZM5XK7kt+RUoAWlPmSrdASiYISjdCW3UTyziH85NH7LMuUoL+NsufEahdJ4dnLor6ovCiqEUrv2e0BbCv9UV9gbe7LIosxBVmqeXl0yptvfY0bdx6QGcV0WTCaLimLAmkKTp9+ykd//M+Yjx4TqwwVWKSV9RhqNU/t0kqX8nU7HaIo4uWLF9y+mxAnEUVZkGY5Ozs7BAG8PH5EP1ZI7Rtdwi22VqfDw7feRqqALDWkWcHu7i7zizHTiwva3QG5gdJ7JEaRQ+wMrtkahhFlmaFL7RZo3WS2dJKY5XgE+ZJ5PmP0+R9wezjnrXs9OmGJNbn3cano5U7SqUpltTaE1glRCC0a/P6VE1VTcrXSJ26uI9FsANYUKEFltFJJGtV8aGOvmUHa5DddtoMLaudR32FGrFQgNmeGnTRkk11rGhfecJ3fIIxdFSBi82fCXhISrrhX2FXrX/ljuVb4834lQaBcA0oU9ekUmYI7O5J2HPH+5+/x4kXAcgrK3vGy+Koe8RZCoMsS40WS8dYEopa/cI5KQjjf7vlsxnw2JU+XlNrw8CtfQwYJ2dJyMVmSpiUBhsVszOeffMD0YkQoNLpIKa1FemWPys8jCgJAOjhaBrzxxkNufuWrfPD4hMV8TivpUeqSNE0Jh23eevst3vv+/4cyX0JRINFYSgyCN99+wO7Nu2TakpaCtLAoFTAcDrgYXThWs/+oSm2IAkGrnTCbLcEYoiBwelcWlFDOMsDREkmShKOXL/gokuhsQTD7kF9++IBeYrE6R0jt48nUohNNzyhtCjqBrOVVral6aF7QTq7yf+Gdha9TOTC+JnLqKKIu0q1HPG2NnK70oTf91Tcnk6zdCJD6YRVL16cTFc/G4oQF0jQlSWLCIKyHWezG7MalJjobZilXIGWNd7vRL3G/xBlAinoMN1CKLMsIjfbPLhEypN1OIHMjos5G2OWygTLsb1m2Ol0+u4j4B98fs5guHSFQg5KCwOvhBlKgtTtZqn3AenZpkWfkeUqazlks52AN7VZMqxVzY/dNdg5ukpaWs4sp0/kSIRRFumR8fsbO9hbFtIcoS/b3DhkMBsRBSCAV09mUs5MzTk+OKbQGGXBw8x633niLVmfI3p5kPB6zvXMAVlCWmqI03L13n729Q8rFlNs3DtndGRIEis+ev+Cdb3+XVn+PWSbIS02p3b3L85TpdOz7LAppXbdCKEUcKUbpAtHpEAhAFyxmU4ZbA7cAfVq6u7tDHMeURU6kBAf7Q7b7LYSdumE0BMgQiyEMosYol7eOEJokDl2K6/WNpZVIYX0D1s99VCxdKWpel6DBeobaHNQ2ZopspWxSuetiHI6zxlJvyP14P0V3gFxmnQei4YW+6ln4SXDfodS6dEJm2mClaewKZn00q3k82S9u9LySo1XdwIYTkzVuIChfTpzdga9NwNAfDClODbY0BCoGU7hFbgSltWTWoIuCwGqyLPfOWGZlQCodWvX0yWOKLPfzF5Y0LyhLg5LOxzyKA3a2t2knIYESnJ6dcnDzEBknzOYp82XhLQg109k5eb7g1u2bvHnvgLt3dzk42CGKEpQMkFKgi5LZdMYnH37Mf/sP/yGFDXj47T9JsnWXQiR0uobTsxFl6Xom1jpx7SBq8/Ddb/LNd7/K7Vs3vDJ9wfZHH7N7cJtMC3KjSPPCQ9kFi8Xcnbje/MdnZd7222LKDExBtpgzm5wzOj1iZ6uHttozBzT9fo+bt25i0gntGA52usSBQZSlCxARoq0iywVRv133s6y1SGPI0yVxHK5czYR7beF3JOtTbGss0+mU5XJOFMe02+013bUG3OSXiKjXrvN3VavRkLX+m6QRESunZa4WLwk2d39rWTclsZY4TkjiZH2Avh4KXleeeBXs9to9erHivIuGEy7WEgeSMh0hdO6bYC5wBv0txkmPRaHptSJ3CliLFRGLIuHHj0+ZzrdJ2vtkWe5QKr8jxXHMfFnQ7XYZnZ06QYUw9NKTISoI6SSxo5yECueKWzCfTUlaMXsHhyxyzdlkwTwtCCQUecrR0TN2um3eePCAGzf3COOQUmtSa8BKhBEIBZ29HW6rPm+MCmS8Rf/GmxQ2QGMJo5ZDgIqMIPTFqlQIFbN18zbd/RukMkKXhpcnp5RBQtLbJjeSTBvSZQbGIXRpltJqt91iVdBqJ/UCsdbw6NHnHL08otPuEARw8vI5b9y7XdPvrReivnvnDu//8F8i8wU7bw2QUvvAc/2O2TxnllmGUdvB8EI5ZXetKZYTkn6AoHCAhxdtWPVKVxOE0msdjycTpJT0ej2Paq42Yq21n8dRDc0xsXKJAqxVtUJMpWPsLGvcew8ChVTe/vxygJg1mZ9ailHbNWxpZVflFbcrAM18cRNGvAbDq+nUUNdCwm7IwZS0k5Di/AKdjwnijhsPBVTYwXRv83T6hLc7gVcBF8zzmJ88Sjlb3kF27hDHgnk+IS8LhAgxQKfTYrZY0O7EdDpttrYGtNptjMbfSG+CKQxlUTCfX5DnM2azC77xzV+k3e1zcj5hMtNo72l4fnZGt9Phl7/3y+zvblEaS5aDtsI7dnnPRyTPnh/xwfsf0hrepDM4ILWhg7GxqDAmjmN0kSOJvQuTQIUxQkWMZwvCqMU8zZjMM3b3b0PQwZSSxdIpS0pguVg4veNAYWxJEkbEUeCVRVxx3ul2iMOk9kc/OnrB+dkp+4c3vC6XQFvN/uEBi8k9Xnz6A5KWQsoc0G7hqpCz8QVWbhHFfdKG3I41GcLMaUcrlXZRCUPbNRM6rBC0u13ana7zO5FO71h45WwhIMszJpOpU+DvtLEIsjTl9PSc/mBIq9WuXdO0H7gy2mUQ2gqMxomOC8Fgq0echCtmul+HQXM2o/lVUZllA+aqa441i+iNLOtnoaM0J++bkhUV995qOnFIxJJyfkyS7FES+GJeMTh8wPHjE9TRhFvbEZ12wqOnc46mCbJ3j0z20WHOfH7OYpkSdWKwEMcx7XbMYhkRBAEXF+ckSeL0e4XTnS2KjOViSpYu0XpJmk2JI8nu3i5pXjCZZ2Q5BEjS5Zw8W/LL3/0ue4cHpFmGJUAbS1GCLgusNiwWS06OTxmPp7TbW/T62+Q2RIvQ6esag1KCuKUo8zkhbYR2aZBQEhXFZKUlN5anL16StLp0etuUVpGXlvkycyelFb6GdDPlQgm6vTYqkI060HLz5k32dg45P7/g6Ogpk8mMzz77jL39Q48UuXnyIJC8+fABYTliPjtFDCOHoGEpjGA0N7T6h6ASv7OVhEJSpgt6QUE3YgXrrvUqVgEiveEoQtL1ltS6csiq9MC0g+bDKKprCyElgZ+H0cagvD50oAIHUAYRSdLxcI+iKDTL5RJjJEKEvrVha8e1wGJ9urExvXXFkJRtIAXX0oZfNdH1Oo8RDTPFzWEpDLGSHLQDzkZPibfuolSINQojIOrt07v9ixy9+DEXz84I5Zj3Plsgu29ijCAvFmiTMZ0tmEzn7Pe2oLQoBd1OwnyeMBz2GZ2eM+j3abV75HnJeDIhTedYkzPodYjjFqNzzYM379JqJZxPMxbzFHDmL/PphNu3bnF44waLLKMsLVm2ZLFMWS4ztNFMx1OeP3tJGETs7OwStzredCZw6Jr1fK3AIoVhsVwSqH0nWOFNVONWwvPnL5hNpiAVO3v7WCEptWC2WJIunRdjli7RRUEYBGhd0k5iklaElCvxzuVyiUVhVEJ3eEAYt3nxVPHZZ4/pD7d4++23PIqqKcuSOBDcvnWTi+NPKG8comSAxXA+zZgXLbZu3aE0AVZKsJpYCLLxGYPIEEk3RisaPQwpxbqClFi5QgnvTFunQD6tbrdatJLEaRf7J3e7PdrtHmmao412au1Krew1PCJaFpr5fM5suiBNM0Qg6PU6DLc6KClZZhlplhJUM9VXDUBtCgkLy8/1zxrkK1YIQ+Un0sTSHbHR/XzYCzk5G7O4OKa928cKhRaSnIjW8CatTo/56DnHJ8+ItzTEW2QqpBt1aHf2yPWCl8fHHNy44YdmJa04ZGvQp8xT5uMJZ6dHbG0VzOYL8kLT73XodraIk5DR6IRut8O9e/coi4J0nmJLNzxV5hnWGO7cvoXVlqI0XFzMmM0WFHnBMk2ZzxccH53Q7w3Y3d8nDGNHJrSyFsc01rFfi3TJ8dExZbZkf2eL4bCHMYb5fMbkYsrFeMLu7h7bu/sEUQtjBdoI0rSgLDRZVjA6OaEVxxRFSRgEdDsxrSioFWysMSyWGUHURtuIEksY99g/uMvzpwU/+uFPKPOcr7z9kHa3Vau1WG2IghhjXZpUmIKXJ1Pi1n3CuM/Cz4cEWEy2YDl5xv0DgZSFnxWRLr2qm86mOX21kkOqjF4rxR0/LSmkrK2jK3sNl/04lfm8LJFBQGl03fCVSLK84PTsnJcvT5hNF0RxQqvTYrqYIoJ9lJIsFgt38pjN4LDXnwhCaK5ilVwel+VSxX7VKWJpav42i3IfIN76TVQBAqAtvaRkp2V5/uw9eu0tgtY+cwJnSWZjUCG9vT5bB28jLCwKyEzsinoEi/mUZy+fcXFxztbQCbEpCe1OQj9zdmOPHz/m9Owlw+EWhwc3abdiELBcTsmyJQ8fvkkYBMwXGdlyCVojjWUym9Drd+l2+2RZwXQ853w0ZT5bkKdLFoslRycnhGHM3t4hQRj5xpryGEvpNcAsi8WU45dPUVISdzvMpmPKMiPNFqjY0mq3+c53vkuvP/AuSoCRFGlOvszQRcnkfESeZ+zu7HN8csFw2KPdigmVQAqnUWW9f2Kr1XMOXp6YGCYDdvfuML445vmTZ2TTCXv7fdqxpJ9YxPyEW8O2s5iTEScXMy6WITu37lKKBIPyXuOGdHJMoqYM+pW/d0MRX2xy/BoKiJWoQiV07XN60WgirjhcbiZFBgFBaEiz1LEk/IpVKiCQEisgimMHt8dtut0ug60BuS5AarQ17OztEoZRpc0rLjfuLs2Pc21wNNMwURMfN5sedsOzoanD3JAUqpG7xjint4JzOwWEYsatbUWWfsbFZxG7b/8piDpY7WUtRUBpQwpjXUqgXL5basN8XmBEG2sljx89YmvQc9KdCOIQtrcGmNKpnz958piiyD2j1SF2k8k5u7s7HB7eIE1zJuMpRa5RCNIspUgX3H37HaSQnF+M3QjvfMl0MkOXJd3ugGVaMBgOaLVbzh7OQ5LCGldU2pLZbMLZyRGddszdu19la9DncH/bqacIN1SlAtdic6Y4jpqhtaEsnP/GeDJmsViytTVESMjzjP2DB3Q6LUcjsRIhHdXGpfueoiEURoQIKen0JfN5ynYPYpvz5I/+Gb/07i5vHwxo7aXEUQsVhlxMl3x63CbcfYjt3qHwqaK0GvSS9Px9HuxCEpjaSqNmbNT9E9vQNHCdcWFXmYz1wMVqYEqu+cy7klFhjSWOYtRA1dCxsbb2nInjmCTpsL93UAND2lq0NeTFkrIsnMFRkROIDXxWbHCjrLez0mXpxblc32BNiHnNB3vV5VwjPIqVqkQdWA2bt1WQOIurymbZNps3lcOTMLQCuHMQ89nzRxx/9vvEd75LEHUwBGgUpSdSmopyLwRFqRlP5pRlwHCwx8X5MednJ+zu7roBOKWQYcDWsI8UgihSPH/+gqfPnjLs99C2pNfr8JWvvk0YKmazjMVigdECXcJ8dsGtmwfsbA+Zz2csZnPm0zknJ2e0kha7BwfEcYvZbE6Wpm4nVA58kAikEuTZgsnknOlsSq/XYX9vz42pKokKQ6S0fn7aqToKUckmCC/2ZkjTlPPzc85H5/R6PYbDPov5Bb1ei5s3DpBKYErrAz+gLJ2NQxB26UTWSytJpBCoMEEGMdOLY/o78PabPX7xW7fZ6rhTxxgYLTLefz5Bdd+it/0GWnQcTItBypzZy08J9An9JIGyXFlr1NQRD+1q35eSzqXr/9vZmzQ5dmV5fr87vIcZcMCn8JgjyCCZWd2VpVJrsDLJTHt9B32MNi200AeSaaGdTCtZS1Zd1uoaMotZOZCMOcJnOBzumN6792hx7xsAh0cyK8xoDIbTwwG8O5zzP/+hflgSI8LXyEobvlbl8asV2AjblqlnqgxrVYUpiVQ2phowSrCNEFtnYrCTBVmz9lnbHHEm4pwLSIwIqbVrClr/heZCNsiVRahOoUsQJTV2SnjhrhayUwY0ii/9YEv5vii6TcvLx/D69Aeu3iuGBy9ptnfxtk+uI+FQApqxWGRcj29ZzDLEW1pJi0yE17//nlHvv8ImLXz0p+q2GjFsVGi3W5ydjbm6vODq+pJnz59ycnJCtloxHl+itKbVaONcRrer+OrlYzTCdDLhenLF5cU548tLGg8eROdBT7/f493bd7x2PzAa7YAKQzvnck6OP7NYznn8+An7+yMUDnE52oAxlPEFhYY7fIbhULHWMp1e8+btOz58OKbd6bK7O8RawypbMtod0u12yPI8uLfH2n2xWHB+ccls4XmkO6TNfngWgMbQG+zw+Q/fM2o5/ua/OKDdnLPKMzKn+Xg84cMVrFrP2d37BtGd0JOIIlUrltPP+Pkx3z3bpd/O0DH/ysd8klKNLuByjzYEcuOdPExTozRJjZS4hThSsOWVlDSiEE6rNhwUtvDWlSlltkoprI9WNSX7sU54j3+e53nNs0lHDyi15vh+R1H7BQluaeS8aR+JQBGJbCIZRRT4EFpjDKCDi3uhae80Ld88STi+PuFmPOH6vIvuHEFrBOkI0U2mtzM+H5/iFg4rimwxpWNynndm3M5O+fAH2P/qV7Qaw6Ai09HUzA4ZDAYMh3tMJ/ssV+H6Pf58jNYqGpzlXN5OuBqPef78BVo7bm+XLBdLptNrGo2UR4+OuLgY00hT9vf2GXS7vHj+jOvrMW4VJsvtVot2Z8CzZw85PT3h8nLMxcUJrVaLdrtNp9MM/sFlBEFMVtKC0YpV5jk5OeP773/HzXTB3v4Bg50BqdFkqyUX56ccHr7CGhtLsui3pQ3z+ZzRaAiqyfHJMY8eN9G6GZICBVqdLu1WyvPHKV8/HKHzJbOV4e2HCZ+uGjR2v6IzfEKmAtgQyiLHYjZmcf4Tzw4Mu0NP6hxaWTzgnIq2rJFz54IFkXcKFyf9ZWZ8WVqpDXW6upd8KF5iAGf9dlFr+SrbjK6UNiGcSEJUgy0MsyUGQNZ7BakNCI3WGGsjZFYlsZYEmC+oWhRVn6PqJqzK1F6sLjeJUjoqEXUtG7DKANTx+kMH/ymD5ulBk5VLuV46zq8/8Pf/329YmKdkps31YsFildHSBjU74cn+gr/+7iG7/RaoB/zw/oTxu/9EcvRLmr1DPIoVCpPaMIRqtDkYDXB5jtKKtJGGYBk8Ls9ZrRaMr85Zzlf88MMP3FzPmE5vWGQ5R0ePaLe7IJ7Tk8800oSdnSGDQZfhsMPRwz12dvoVemgNT54+5tPHz7x7/5aLizPGVwajBe+GJImN7IEwQV5lwXDi8vKay8sp1qQcPTwiSdtJ9lkpAAA1P0lEQVQYpVktl1ycf+JmOmE4GCAxUrnM4VCK5XyBQnFwsM+bt8fc3kzY2WmAD3IDrzStdp9up43RHY4vb/hwekumB+w+eQadQxbSwUVUysgKvZowO/+BvY7naNhCu0t09J5SijJuvFi6TvkYB+1imJBCU0X1iVpnfasNY487a85s9zgQbe7FVFXN6LCwLLVKm9IxUUSvDWyKSKskSVBJshZvrLZ5DG0JslMl6rDp66tKdKpQnhADG8MbCWVDAQRK0bSpkPMd+gpdWl8o8SR2QbvZoNdt8NN7y9gfoNMmo25AaxIRZsdj/s1XDb566HDLGdpo/t3XHT4cj3nz4f8h6z+nvfeURmsHT4BMjdGgDSSRuq0F71ZBL2AMtt2m030ceoCFZ3Yz5+TkhDfv3zO5HqOUcPRgH63g+PgTgmPQH2CtJbHROyt+VpkPBhFPnz7h4GCf6+k1N9Mp89mUT58+4rxDiwCO29kN55dTOt0B1jY42D+g0WzjvCLPwXnHeHzO7WzKcDigP+hVKU+1Qe/NdMr0+pqjB4qdfpfrqzE7/VFw01eCSEKz+4Tf/vg7lJoyXwrN3iP6+y8Q02RJA49GCyhZovMbVhf/Qt9c8NWDHRJuK8NxKlNqbWLZI1Ul4fIANNT5VF7d5fQJVVm+vcKXtfVWVC1hfKDv2FkVK7Au8gsbpO7GXn6hSjI1cSvWB3mbDopbB4FqfWeqje+r8kvjvKMUrIQcPops9YIxU8CBMSrZK4WU0dKhoZQivShf4vIZra5F2Q45QfecqJxGs0GnnaIlRB5rURijePV0yIM9x4fzz3x4+x6x+/SGT2m0ethmD21beDE4gRwfcXmiKjHUz4owle+0uuzt7fPo6VOOT0748OEjF5fnjEb7aKP49PE9i8WMowf7KE2ZzV36komQ5xlaK0bDIft7e2jl8W4Z/hyY3U55/+E9jx6/YP/gITe3C87OJmSZBHGSOE5OTpB8wf7eHsvsBmvsuptlRK2yLKPVbHI1uaLT7XI1uWa1mpE2O+EWwdMc9Dn91KA5GfDNN99hky5zleC9CnZDztMQYHXN5PwPHCSXfP2oS2LniFuE57LN3K0gomiwWLQ2mOizpYq1F/uWbetMqftdQlQtuhxRpWpT1aBhNli+61omuRugU8wh6uZE699c0XV1ubGq2LStE/I1ob1av1lq7zIa+Nc2SMG2DJuhZL3UchSUjoIaVbFBU2OxeJZugbeD4FulDCbRJGmDxXKBFoNRQSEoovAup9+xfNsdcHSYc3o5YXLzGybnmkwSdHNAq7NPZ+chjVYXp8ArW/VqvgIUsjxDK0W/36M/6HN0dMiPP/7E6ek5Ozs7wIiLi3OybM6Dhwd0u90ypk3XotqCPa0LOpW4ybVSZKslJ8fH9Pp9Hj56iqgEbVpkmeHycsoyy7k4O2U1n/Po4QGoFavstlosNYqHc448y9gd7XJzM6fT7mK1YrVc0Gy1Q4krCp00aPYPuVkKGU0QG8KZ4yK2soLZmNvxj3STK54/7tBuZKxWMxCH18ERs4zXKGUV8UAv0rKiaEvJJrIpd5KhCsTzHp03FYRVpShLYV5dmMohZcleJ48XcXPmf/off/m/1hezus9+Z812RUr3PK0CPFnmgeiNf2KvUPuDWqOkai7ycVimDcoYlA7/aFP9N1qDiZtFm3DCaIPWFoypMtptgzcfJyzcLtLoh8Fhr83uzoBew3E7fsODkaXViE9Hhwm29+FGaKaGvVHKwciyN2yw09c00wXjyxN+/Ztfc3o+5fpmweTmhjzP0dqQNgIztryBdYwy8znNVoPDg0O893z+/Jlut8OgP2A8HnM9mbAz3KEbnQypxSVrfNBJBClV+KyV4uTkGO8cjx8/xtgU7zXea1wmLOYLzs9OuLo85+jggH6vS5YFGsyL509rRNB42Hnh3Zs3tJst5rM5aWIx2rBcLEPCbYRr08TS6ba4no7xPmc03EFLWNC4BfPJW7LrH9gbrHj6IKVlM5SPLvVGo62Nm17HwkijlK0yZagOOa3rpZAqq42wVsJz1ypwqVDm7qIrLaOK7zNoTOxtI7tYKZzzBA6mRhtb/cxYvSj0RsIUNV693Gcxqu5khdSdsrfa99zZ5VJSCApMrsi5Njos2OoGUTG7UJd8F62qzVW8BtEFHKBpWMXusMHFyZTUQG80YHenT9NAq/+Sk9cf+Of3n/jLrw8ZdJrgPbnLY05HmNaH8EtHN/H0Gpaj/R6Zv+F8qth//Axnm0znS05OTpi/e0e73WFvf5/RcEiSpjjvSgeQPA890KtXrxCBd+/e0e8PGI1GfPjwlrOzU169esXzZ8842NsP0dT5Au/zmqQ0DPOup9NoKv0Aa1NyJ3gf0rFWyxXTqwnXlxcc7u/R7/fIsozJ1QRjXURnZE14LSJ4yUkSgzWG1XzBsL/D55NzstWcNG2gtNDtNdgd7vPgwQ7v3v6R4+OPPNzfZXEzYT75TOrHPD4y7A8a+GzF+dQxnc65Gk+wBp4cjtjbaaJZorYZ4mwczoVLp9ypcO4aEG4ru0TUnbK+3Iixvw4Rda7sfu8yQqTaIGrLRll3YiyMGjaSpLaYBW+aMOjNDPbi+quVSlppSsBAxx1cktOqPqmYqqty8BNuE4lloBdFkhiO9rv8cLag3Tb0Bm3SRKPEIbbF7pNfcvx6yt/99oInBwNGvSZWC4mGRiMhTYKYKWQRrlCyYjnPODk+4eWLv6G3+4S5KEZxmDC9nXM5vuL48zFnp2cMh0P29vYiic7HWj/cKM+fP+fy8oLf/+Ff6Hb6PDh8hLEJZ2dXnJ9dcLA75MmjBwxHPdqtNMqcPUoUy8xzfnrKoL9Dt9PHOR0Ihk7IVjnz+ZyT02Mmk2v6vT6fPn5ilS2YzyYMd7tr86miNNYm0O/n8wnz2Zg0adJs7qE1TKdjdnd36fd77I56NFJLq7XDs+fP+fTuRz69+T0dNeOvvn3I04NDjJkxnUy5unZMVm10+oB0t8n89obfvv7AL57mPNlPEb8oy/L76UhFbyo158FN2YTabsZYBvKoO4meSukYwCRYpQOqVbYVurRJRXxg8/4cBm699FKo2nhf16gi67Ysa4Zeiq3WoygLOtTxypgStVBao4yusT0LMpuqrr8ah6swNpYislo8+6Mu7caEZjKjZfNyWpuLJmns8+Lb/56b8WfenR3z7niKlmXwaPIr2g0VDZ+b7I069HoNyEOF3ExaZCvIyfE6QM7dTodev8+jx4+YXF3x4cNHxldjHj9+TLvVqiLnvCdNLS9ePOPi8pzDg4ekaQujU7ROyZbXTMfH/MPntzSsMBr26fW79Dtd0iTlYjrHOcfe/n5ojNFRLehZzGdcXJwxmUxIrGWxWGCt5eDgAMUO8+U06O21rsE3IUJtZ2eHNz/9M82mJU1ShJx2u8V4csHOTjC9bqQWpQK9vN8f0H31DZ/fQnZ1wqfjC07PF6TWYFSLtHlIc/chOu2iSWjtGCa2ydvP/8TDvQOSIpUXiYIq2e6hsDah2O6zIF/SWagqnXjN4TNKbYuBYnFIl72tEOY593nzbt4Q615Ym0O/ynlF9PakcNnwmguNt479gyn7lIIGoIwGo6vZSTli0fi122Pdhqh4md7n9NtNng7henVBVz0hE4/ToQRzWKBHZ79Db/8F4rMYuulxyxmS3bJcXPPm4pI/vL9g0FccPRyhtGU+u6LbOkR7hVJJsA0qwm+MYbS7S6fT5fPxZ969fcfTZ0/odjth5qBD1PPBwT6H+3tkyzntRg/nIjnQ9nmwl6BWLa4vXnPz8bdwLpwuF/T2nnA6zfjlX/8N1iY4p+J0OXzCk8klZ6efOTzYZXd3P8SgRY/dbHXDbD5huVrSardQXqKhU/jeFy9esJqfsVpOmU7nXF9PaHd7nF585vpqTKv5CqNcyZnyAmna4atvfgXZgtVyymo1w9oGzUYHmzTJlSbDgDN4ZWj39rgaCyvnaFhVqv1+lkRi84SVewbSW9bqtg20trbr1cnmxhLB1khSG9+4gTGre1i7kZpdQJSFi4sIG4GeqvTYKjgxogzaWHQcDBL5N8rEhlyV05Lam9Hb4T7qJm+exGS8etLinz6cItkE2xiUjsNOKcSbsDCVRdGMXCiN7gwxStHTQl9WTMefOfv8B979/TvaDUOWv8U0+zR6D1l5weliIq1CL+Md1mqePX3CTz/+wPnZCb3uV+FnR/uZVmoYDnq8ef2O0c4RuY+pR+JYza9IVxc8HqX86r/7K57spbz/9Ik/fl5gkyZ7o34gF6owqAxMhyVX43OcW9Lf2QuRCuIRr8l9KBVy8dxMJ/Q7rVB3RzWjd0Kn2+Uvf/VXXJ6fMp2uaHX3ULbFfHHLxdkpk8szDg93w3QZiyhDJorMBQGVbrdJ26GmdwJ5IbjTCUrA5Sv8/IrRqIe1NQn1pmG0l6pa+JKdovryxlJrGyUoU6s5iCpncPVZidR5XLXFbbXV6xCsqs+/18use/d8nMT7mpGb0qGnCDz9GKmlYpBPqf2w4bZQJaMs9hl6bTZDbbfrbadJbRgZIAGN8gv2h5qD6YzPx7+mM3xFe2cPdEqOQlRe6plVnNoHL2tNLpqV0mg06c5DXgyGnL7vMz15jayWvPvtf+bh157O/jNWSiMuQLC4aH4gHo3lwcEe7z+8D5SU2CPpYA9Jr9WgoQlTZ2eZr24gHzM0H3h+ZHn14ojdgUHLipfPH7Lkhrmbk9joZh915Ep5bqdXnH96T9c06CUJWmsyp3BKkyiFFY1ZzrkZn6IPd4ulEblMGjwkSY8nT3cQDLlYrq5v2ds7wC/n/PM//T3pX//bEBfhcjzhVghES4uL9p4ikWYqChWne0bnZNMzVDbm6ZMDUjtFOVVzNyyoIR7nXAj39FUfUZEa1UZiADW6UrUhCpKssJZiUKKldV83fU+TX79+7J9S+yn1JTOGwh5HlaqwouQxBVwbYdRyCKarnVygWyrKIpE42ImbZPN23cqiqc8vSzKjLxmaLx+1sCdXnJz/LePLA1qdB9hGB9EB+TJJk8Q20NrgI4zovSZXOSsB8oQcxe7jX6Jtwofv/5HZ63cs3n9k9PIbei++od0/RNsmwQctlGpGlhhZkVqzbhcWX2aTHG5P4CpHr3L2OprDo5RXj4c82m9iJMNl87BYtKbThIbxwZJTVHQxz1FuwfzkjzROfsdBo4txlziToFUKkoADv7qhN35LtjqDoxG2NwwUkshnE9E4NMuVC8/UGDIXzA4eHOzz/oe/44d/OCP9xV+wd/SE3LbJvIWogPRFZSBR+SdCAhg3Z3nzCX/7nge7nk6aoLyvJSBLWbLPZnMAmjFqejOOYFtfLDGu2ktwxqwfmMVMaa2f5W4ptW7QqO6sLVvPY7uvDty6h2LiqpQaYhNp8KoMmFERjfJrLMr1uLe1n1W7OfizzIrXX6SvGGC0rebrR20eDDOuJhNuZxP8zOB0KBNWuWWeWxwpmBaN1pDWzj40EhZeaIjG0WLmDL2jbxmeX5K+P+bhzZjZr/+Wz7/7NWbnkN7hIwZHD2jvjNBpC6U1xxentJqd8BlEny4tghFFw11x0Jny1X6T3VHC/n6bnV4T7ZbIchrmDz7MVXwe3OWVrDAIWoKlp0Zwswnup3/iF2rKoZuzOPtElrvSH8oaS2o0icm5OLnk5vU+o7/8b8l9tFOLpgmhKS7sQXMkzzBek91e8eLA8mRfmI//mQ+TN3T3n9Hbe0KSDlg5wwqLlyC1SpQgkrO6OcVN3rO8/czuYEZHW64nirlfYX0R1FlYD6lI6TeBwFjetjp+TWqK1mpteAnwfJ5lZHmAxK1NMFaHTBRd80xQW1izm+X5lvVvC6bTPdGH95vzKIXWFlMM5+IGiQmHZWahisNBUfU4tSJAx99FEL6wOX6OedA6hhagXS2OQSth2LVxMYSN7QSWK2G+9MyjS8n55RvOLhu0D17S232GRIM6pw25bvHw5Xe8++k1zfFnnrYaLJcrJsevuf78A+PvE07bXW6SFpPM0Dx6zrN/9zc4H8ZtmpCwJJnDuCv+h795xaMHXfArvCzIl2O0eHR07dDoUHpknlaiaSU5q+kpzc4hSqesVnMu3v0Bc/yWl+0mhwa82HJCLcohrFAxB6Uj8Oaf/5HO/hM6R18zzfOKqRDHd0okmEos56jFFW1/xX/zq8c8P4RV7jk+v+Xtu99xdfGBtLOHbe6imv3oq7Xgej4lW8xp2zH7I8/o6ZC2bWPkFrxHS4r2Ls51fMjxyKNJuRNW4kp6u9KBwh9mGro0gzNaxVi32E0YQ1o4xRgTqxFdVRVqk+Z+R80XPHvryJlsJEzJFonsneSditZSLnylil5DR9zfVMOd8v9RJT1+DSkQVXs9au19bOJhZXOv1Zccte6wiA2hLPEUHj4uwtMeg9BKNO1UYbXFPuiwcprPpzP+8Q+/YX56xsHzvyBPuniVsnQhWbb/6CmTy888EMeO9fQtOG2Ze8dkcc3Z9YxV2uP5i6ekzSYr77E6mDYnynMzPiFbXrHT2cPNJ2EgZcNpahCUjqzqGPDiRWhZzaO9hNeffkOjc4pN2lxdneMvfs9eOqOvPE1nyXSt/o6ewro4ga1hcjvm9O//jqP/uklneEBmTBg0ikT1h2K1XDK//IRZvOa754aHOw61nNPS8PKwyaOdBvMbz3h6znT2gewmTP2NgUHDMjjoMdxRtBpCIqtArlQNlAreyqq0jopJVNE4vOgvg7w2GP5lWRYm2lZV7JFC8qQN1ipsnMhTxDtrXS5W2dRVbVIaCxmUklrfo+q+WLLVtKEoW+ROE1CVT6EkClCtNgasRkng00sNTtP39DG63vjX0K47WHKt+f9CP7X1Q9A1l/pgaBz+TMRHz9lAF9XOonNo5NC4ndKenPPx8jPNpEX/2S9YSmQeqyatw8cc/+Y/I7kgOvC5Ei9YD6ky5CIMfvGK9uMjZk4wiuhoLig353b8E092Dd1EEJcj2qN80KIrH2DBIuUo+HY7wHM0TCBb8un9r7Fpj28GbWYdxyKBBnncDAW8ogkBcb60+G8p4WUK707f8uE//J8MvvmO/lffkHRGZJlDfIrzhvdvf8/N8U9898Ty6gGY5TnORBAkm5OiaPQT9kYNFA3ybBmiIFQRU7FAeY9aAqxideBjVoeOC7lyAdGxvC4o8HXhUmJDngkUB3aN/qRUkEuvjSB+fm0uUmwQueOoUuTUW39ftIeoGq+lhiBpVe7ScA3Gf0wgrhUDPRUhs3KIJxU5UWq+q2prw6RqtvY/767QfEGLElrvYMgd7L4DPzS6+qXK4peOy/NLTt9+hgl8l+7y6KDL2/E16okLlC0Bpwyd3T3SVot8OaWtXYRofUmG8xa6jx+wtAbjQmmlndBUOeMPvyO5fs+3Lx/RlIy5zxHJ8D6vzMHrkGd0Mwwoz4xRL2Hvu32aLuHs/QdOXv/A0AspHoPCljQrv2bpryJREK15JEI6OWPy9xM+//RH2ruHJI0mSjXJVjnZu39hlC55kjxmkKfYVJPJMvQH2FAaZTMWSqNNEg5E8eQFh0xV3GzqVQfg1mhKVUMd0HlXieiUhGg1E9JnxW8IwlV1YH8JC64jWVKyODbWU0wZKC11VTiQBLDlTbGZuaAoFVk6Ns+VUEmXMK5SwddWRUJiKKUqC/t6rFWRXVHYuazzW9bgqHsapz+VirudCUahONGhrAsLWmGxNEyDm/Mpn15/YHYxY5QO2OsP0KbNp1mGiX1SyMaQYM1jG6gkgXnFMlNRgaYxaO8wLqchwi05VmkabsH8w2vG3/8nHrXm3L4RWs92Mcbj8iVQPBRVEh6LaAbvQxmiXI6SBZaE+eWcD7/7PfZ2ST9phxssbgKjinfsa5+aLxtfrR0N5RiJ5/r8E9nlOf3hXsgHaTT4i8dH3CwuuP7+t7z+YHn81WPau00cHudzAq1A4qDSI9oGnYkEYmMIF5K16kDVSnOpoY4l0gSlR0G1Bk0Fyep6H/HngTh/0tgwjh9KnWtExmKJpTZa4OKmCAu+fAPFTVFw7EtDLh00I9FOpTwNWA9nKibfukYnLtEJVYVwKbWFkPazzK//VAtfyGg0iqBCVCvP5fuPHP94Qss1eNk8opP2woBNNLNsiTRD+IsOFhtVblEUbQXEJRqUiZBpSJTn9rffM0jb5P0d1O2C69c/MP/jb3ne0HzV2eXmwyk38yuOvnqA1Z5c8kALr7l0FGeI9xJOVx8Mu5UTjt8d09Vdut0OdrHEaoUN4SL1e2ONzaDjs7DKo7zDIvSbTRrdHqPdHYxtoE0aHNXblvmqzfj6go//+I7Ggyb7Tx6QtC1OVrGXc/gcvNJV1goa0cGItHQSqZXaBULl42sxxsQNLesTctGlYUfdmGLbjXF3VPGv8PiM1aEnCM3ybBUm6UV6E8qUjFnRGqNN3CTF9NqUgz9V8Oe1qlGI66phVTbem69V1voRdRd7jmGb64jCPbeDqivj6mCCbK3IRDTehynq/GbO5z++YzWes9fcZdgY0KCBduHn5QTTt8FwCDqUEeCiiUUe3cht4DfhQ457NF8YpYrx8XvO/+8xvt3GZTnq9pZHWvNiuMdes8OteH774TXdfoPBQTeo6OK5L0UDK5XkWSJ13BjLxekpi+mCVw+/xU6XTD9/DLqR0FDVTu5K0iz1OAovaGVoJU26w10anT5a28hjc4gHozQd06U9bLPjRpyMT3h9/hP9oy77j4boxJDnqxg5HZ+8DpJWJQpfBHOWGoiwkepr2auQ0ovTFZEwzsWCGUV0eo/s3PA+akzviJgKqiznuYeJ/rPOWSXgK5fR3DmsRPKaMXETRHKXMrqcY+goYlIq6DGKF4iuNfGlSqvytqojDpsevKJqm2MtBk5VjijlCajv6nlL10XZ+kaLa7xAyryEB4S2XJ5PmJyOsVnKTm/AQHdpZglGbOwjIMtzVnlOu9djXk6SPAaPWszoJE12+rvY/BbvVjiXl8E/DQV7CtzNFD+doFtNOt0uO90dBp0u2kMv7dDVLcbHZ+zstQIUi4t9a9HXxGl5nDSLD4DAzfiaTtql2+phfQu765lNp6zmM4QsSnJVuajqG0QpQ5I2SZttOt0ejXYXbZJws2pTJsyGTznA9r2kT2e3x9nNCZ/evmd2OWH4cJf+qEsmq5CHrjz4IJVes+cphWw1pJKKIeG9K/l1OqpFheJ2jgRWLThdh2mkVlIHRnURxFOuHKXu6UruIz6ue05rY0i0Dim3qhSp2LIu1Ka6IYI4RVc9iKoad9nIF6mr1u6oFe9YONZkpqpS5CESS7rC/qcMQ4una03yte1wWFOFhSFd4IsljC/njC8dLx/+FWkjY3l+RSNXJHVqaBye5t7RSCwojyNHkZOSI5cXPB2MeNpJYTElWy2Z3U5ZLhegFGmcYSTWYqwmaaakjQ5J2saaGL0mim7S5mo+Do7tPuQdVg59UsVNxM2iw4tCspy9wT4qV1jbZGf3Af3uiOnkksXyFvF5tOTUa2VIkiY0my2araBhN0ZXQ9W1Bagi+hUOOAcYLzzqHLKX9Pl8fcr5Hy5YPcwYHu4gNkdUmKmIK6K74zYrYhNqdk5riGiMuytcEb0ywZdXKfSasFWVFYmKMoMqOEetLe5t5XbwP1BsZ8cXDF7inEWXkLNVOqmxigMKo7WuqbrUGuOxLJvqG0OkujnuSqMqcc49O7tueSoCPneslsGuv93uom0DcRLLz+p0Cq6QFZ24+FmyxicLFi4ozfX1kovzOV+//LcMpMfl6zckkmIjClV9r2CsRnlhdn5Ou3cQFmbiWJ0fw/u37LdbWKswjTadVptep0vu8tiEqtIsObzmiCjFya4r+UpEyDnHSxZTtCo9dJnOVfjPogiZDI5EWUx0Flba0Gi1aaQNnMtKP2OPrpKaCpAlYnoo7pSm1YFfo5iLr7LtxdCwHR7uPaO16PL2/Wtmkxv2nw9Iu5rchaGq8lLrHWrJZUpFaL1ovMOtQw3YCedUdIrUHjEOJaa6mUomrFTl2tp44L56SjYsgDYqsaKH0iF+WlUbxFSNcW1TFANAWXtztd/XPtDtm1a+EEldDXU2N1HB58J7Fssl2dJhbCNslMTG1+ZL/Nq7nPligXeOZrNJkiShTpXaBtWW25sVZ6e3fP3Vr3j84Cve/MO/oJY5SZy2F1aXxFsqNZqjXp+3f/wd5I7uaJfZ9YTF2zd8k6aM0gbeL4LhmwdlEhKTVIqZUkTmywXiVRVa50RYrJY0h01wOeLyWulZc9r38bOJKIZRBls8RFMGJ+NElYYWurRI0psXdijd6gzXQrMtmwO1Sg9upJpZOBG0h1F7j86TLq9P/8CnHz/x6Js9SJOYI5IHuFlV1jxKbWGI+3hz+ehQo6WyIoxcvWBAUVPRRzO4wg0HFVAzCp2LuscrS/mqj/kCu6+gPEkEkGwdYaCm5qss12u7q1ZPbpMhhigFqUU4u5osdtvEPli83M5uaTWbJElaYS9a43LH+cUJxycXPH/2kpdfvWCZrfCSs1rOQQk2EtGsteUJWT8/PJ7caT6fjHl09EuePvkl49MrZlczBqIRcZFgWL0qoxQNUTxud+jolE/vX5N/eENXKZ40Ug67Laz3pS3S5oFVIwhEW3/FWgKK0cyXt6z8ioPREJdlCEH66XUleS4a6uL+Fy8oo0mTlNvbW4bD/VC/F91bdKgsaIA61vKbDrAqBluKkkgYVRt+B1L3GykNNoqzzYjC59AxHZ4dfMXvPv+a9z++59HXL4Ouh2A0KHFUUPR1NVZgCeqIL8p0Hxd5aflYQThe0D48J11MymOmoBRUJpF7PBXqwqWfl3ZWr3Is2pRTTVXTglOjm9c1Hfenjfq1CaX3nmy1wlhLq9lctyEtX29wbZzPZqRpSoKQ547p9TUXFxesVhm3t3MuLi5YLFYYa+gNenjJmVxdkmVBADQYDOj3+wED8hvx1cpzeXVLu73P46ffkuWK6e2cVe4QpXGFFUy0Pw7puWFBN7TmsNVip9Uhi4lIVguJz9BUKUSKjUUolftKYdtf4Et5HKhd3V7Q6BqabUvuFxWA52sLtEjbLW5LERaLOcoYJtMr9rtLmqa5vrxFUY4IldpC2Slep8FH50q5w1XytddMmSgc/MeI03qFctA2bZ7vv+Kn0++5+DRh79Eo+quFK8uX7jVRgVEEpErFvq5Ud1ILafIB6jW+ZFgrpfHKI0YHEzoliDYhkFTbaiKut+nc67JwuWP1ozYcF9dKrHCk+JqLxJYJw7Z7K74xESFbrfAipGlS/uDlaombh/istJHWN3L5e60Vw9Go9GzKsozb+Tx8sEbT6rR5+fIlzsNqtYqJQYbJZBwN1yTaoia0e93SWaT4TPLcMp06vv3mrzF2JxhYz2Y4YzBpguQrckf0jC1o+B4lIYPIiyMVIY2lj/YS5g1lTRu2ild187ECr/dhAcZPMRdhpYTr2ZTrxSW7RwPEuAo1KjDwWnlYLEgfod/VakmuciarGz5dfuDRwVOsJGhlIgoZ6Ca6HP5WGVKq9iyLNI5ch8CFOmDiawB8uG1czVuhUtuFGY1hkIx4PPyWH09+T7PToDdsBlFXbZNo6mF/hWGH1KbXpcdiqQ/y3oPX5drUWpd0f1E2oMfiw9cdpWRhQ2qycSv4e2Cj7beKDdWU1FvqMsRlbcQmcm+DvdY8xUVmjcHljtvZjHa7RZqmNUOuwgtYM53ecHF5we5oxHA4xFrL3t4eNk2CpQ6WxDZiREBxzuc8f/mCZTTUVkpxM7tFFLRarZq5nSbLhU53xM7ogMyFhnb34AC7s8tANNl0yuTkhNvLK1IvkTZRSPhBq/hQanMeXZ6uqqbnkbUTWpc+X4IvJckwnV3z/vINo0cpjR1LzmotT168rI9+6zlGAmmaYPdS2u0Ol+8vURPLw+EzjItER2VjAI+Pcm/BbW6QuLid1jilMJ0uzdEQaaSgDTdXE6aXFzSyFU3WPA/WaB5FP2MkYbd1wJk95uLzmE73YRykFly3uLKKLMvaZ1WvSEqUtDA4L9JxYzKviOB1uOF9JD4Wibg+KvGU0T97tPxzfllVY85K6RKi7wjPRd21mi8wba1V7B9UaTnvvafZbIXd7GO5UHM/8fF009bQarWDvYxSGGuwaYK2hkarhXcS8laoanGNYjgc4kVifoewWGQ450IunTElgLBcLOn3jkiTJgvJUWLY2d0LXsNAI9+ldTDi+F9+T3ZyRlro3ancwDX1RVo03Rqt7p9GeRUKFa8CicSJ53o25uPlO9Ih9A47OF3dHgiVY3ttbqU21P3GBGg02WmiSTh9dwLK8vjgGflKIS7cWlYHZq4oWTMmLx6DVpCJgn6PvV98gxntkCdh7tBdZYzff+TmDz/go2+v1DR8awQfARNjMQ53DvjxYoJbOpKWqmSuxTKKRm2B16Fq1p9SmlqUJauqZii+aI8lctO0wisf/bGiTW0Ua0kRznNPP7IputpWVtV7ZatqfHlNTXlVQ6G8eLTyOBRamcpUuN7MWFMtj3gCFEmjWb680zyrmGTU6+8w2t0LV3Geo7UgOl6TsawIMKCUIqBgzelLnpgIdLtpSfCrb2Pn8gi/hiM8nEqK3Am5hswoOsMBgwf7nJ5dxIWqS2vR+pWsfN2/VSq6PutqtHDLhcm2MgEVu7w+58PVG3qHHXYfD/B2HrlSUgmBRLarJssdFOYnXhxOVjT6CbuPW1yevqOVd3l09Aq3gNn4Gp07ElVQZFRZ7iikBGRy8Qz292gd7HOjIYvQtmk12Hn2iHw8Zvn2E40CWYus6KoIk3LhO+Vpt9okJtiQ6oIFUPOoc5shsHWirN645eqD42L4W26CwkvN4/HoSJ8XUWhRqDXvnZ97m8h9JZba6AukUvvGN+lxOB+s8m1i1rxk1Rb2ZKAhh6Fho9nAOlMrw6qmP7jdBYe7SoEod3y2FFJjYeo1p4o1CyCtNlA10MayWgY6dihxXbS512VIpMdXMx+Rez84hWytWaWIOo4ghsMHxoKBhVvy6fQDN/mEwaM2wwc7se/w5cQc9M8KOq1j9yIOj6fVSzhIB5xevmWhPb/45r9k+PiQm4trri8mrGZzgq+gwdbQSlGC9yr0YTao73Q05nYCOknojoasPp6A86WBtKrdbFLrKDyQuTxEK0h165dDQKoEdNSWJXkvuCRrUmVf3uJRvuCDramJ1P4i8/DPVNjdX2JJnCB7QrmilcZYszZ4CdyaDa+VshClZr+zyf6qakvxwd6+uE4DBFkJqoriVupnsdw/RvnSOy8lxOLpNFM+n1wyv7lGfMLlx1P6rQ47o12ssSitcLMZk9PzqLyjpo+R+19ErTB35XwjXPFeOXLJGE8v+XhzjDOO3Sd9+nsNnFqsIxVbRGr3ejzJhht5PGhabcthM+X84hP/8R/GfP31X/Lq279iN3vO6fEp0/E1y5sZWebBB1q8IQAG4+mUjnc4a+OJrkpYXiUpSttIQy9OHV+VlkrhRMiUkGvh8voaZUNKl/eruB1kTWdR136v9wqyFrpU0WQiP80HZEyUlJKKcn4WIfH1gIRtHI5tlo4/Y4MoYHp9w/HxZ1qdDg8fHoUa3RhU7Bc0BLv6DQPkOgXX36fIUJrMuRKJMSb+3Wr9FpLa4rufpuLvuSBd7f3HheoNrUaTfDnhw7sfeXr0NWev3zDJPNO9Pfo7I8AzH1+yOL+gFc0QqjNx4whSa1H35YJ1NZ2BI2e2mDKeXjBxE9KDlNHBHiYRclnWdDJ1x8CifLnn9FTrL0VRQ91MUEtqoxjttrm5yfj+t/+RP759zfPn/4avvvqOx9++5Ob6ltl0xmI253Z8jc+zEHCK52axRKdpDR4OGeQ3s3kY1mlVxoBLLPOIkG2OIum0mc6vOL+5YOeoj7GRvVDLQi8rgjsWoxuD7vL51z8Ch9IexFR9lPcVSVGK2ziwgKlJucunJXqLoOpnoFjFF9JGg729fUwSTlUVNR+6tli1VmuNzaYo6r6TPtSMCvUz8AUpaRHxZpMa3+ZP8JWLCbRElwsRj1aWg90exx//SMdoeqnD3S6YffzI/Pg4CP2d0BQwsSzwNeLaGvs0OFGVD1NFekuuPJnOmK1uuJhekMmSZj/lcH+fpGdxkgUHEi3rA8P68xLZ+Mq2h6bupALXR6JaOTo9S7NtGU/P+adf/1+8efcbnj35mhcvv2P09AAvlsV8FSj0KsDT0kgiLBtPZSdMzi84OT/H4si0wvgwOfHxthAFvX6P4W6feXbDxQ9/JN3RdAbBmVG2nOXb7AaK27qMAC/BBFlfLRIgXYn0GR8beoMpEbUaZ+mOZE5JZXX0xbW3+Yn/h//t34tWOi7IiupgCiNpqhDEutSRyLLRG2zeO2WBCvFaLuqOCxKciu7ca2lVCFmebUDKgjEm0s3vSeGNXWCxKYrwE+cEJEEk4fR8wvXJhM4qZWj6NEkwTmG9xlJ5JhXxYYqC71NRqF0cgBY/0ihwOK6zay7mZyyY0egn9Pf6pC2LU1nFMRJXExrdbxB+F6evKCuCx3tVlh0FFSX8X4F564p+SBsyp7maZFxdrTCmR2/0kK++/RUPn7zCNts4IJfgcO59pGtIjs9z5pMpq+spfj6HLMNkGYnP0YlCN23oLa3i4uITP/70PYvlOcOdlDR1YYNI5TlWlI96CwJR3yCbbp5rpXRBnNU6jucVylisseg0QZng8G+sQasETFLTnuhycCpa36MjuSea7f/93/9nWc+qLgx8fc0ZUW/cGBXhWN/1dVzLWSjWQSHML3DGetJUPRNjla2YXk9DDJcx3Nzc0O/3GY5GcfHf18j56meU03xAAgVF6SbTsynvf/MTZqHY6+zSTzpho1A3MA6oTFEv1z9DJ57M58HWZrVkkS2YrmbkZkln1KC1k9Dop+Q4nFsFImLx3tR69HHFt5KKDPglNU95O9ZImbWTtUwHljrfSyMqBUmZLRdcTmYsXUrSfMT+0TP2HzygN9yl0xnRbHZQxuCzHJdlpBL8JhNAE8Rai/kNs9trLi6OOTv5yNX4FJffkqY5jaYjsR4IgEjYIFLbHFsMN6TqUVQtYu8uFEsF4mhdcq90jAVUia1tEBscHVVa2lJJwUSXYI9b/d26VuJuH5Jb1ujuqoRKpQDLa1yfTcWfqssZtSo7rLs5icGxwm+Zytd5PgDW2JBLETfTcrVcc76o3y5r1+pGbxL4Wboiy+E4OBoxbLc5fXvMxcdzLibHtHSLTrNLq9kitUmAsG2FmikFee5YZYuwIZZTlm6BNYHG3j7q0h52aXQUORm5hOGlNpS30Ca0JkqVGXg/S+ymNs0FVS0ftrDur4EKNfQPWQI5nRb0Oi2cGK6uP3L69ic+vRacapI0BuztP2R394huu0diUowXlMtxqxWL+ZzpdMJ4fMrs5oo8n6FkRbdj6fYt1ubBnKFMEnJ3AQ51F/lbb9GllAHoGhuiDBVai0uu09urlGbxPqKUBqVcqS3JnQPvsImtyRkkrvkvN+zqb/+P/yVo+LSqSHGx1i4TpAoWpqL8S6Vu5qW2RaxtcY8oTni1PRbhvsOzuIEQWeN0eV/n1cgauFTS9WscJS0RPcs8i+tbLo/PmE1mzG4X+Cz4M/kYIFlYFumaI2TSMDT7DRrtlGa7RZIYlAZHBuRh2ltEXceKvjLN8xtlhb/bnN45XWuHiLCeR198FrIOalR59YVjR9XSFyelqAQRi/NC7jyz+ZKb2YIsL4RLNjqrOJIYe2etxViwWmhYTWJBkYNk1aFZ8kbcetRbPRRno7Sqp0aVjIX4Xgu5ty6o+vH2CMK90BaEGyQBHSnxWqO0RakUYxLQlsVyxezmBmtTuv1BYKnH7PmCPb5muytb5iBSa5SkGAYp1nIWVM1mtDixCr25IHemrOsPTdZNgrfF8W6RyuoovyypyiL3qCp1bWPUNmGEbQvkJXM5eZ6DzRk96LH3oI/LPG4lZJkjy7Mo2InzHB2u7UaShBtVBxBgla/IySPhJAxSlaqVTz93IPUFh3Il6zOdkoJRbggpzS+kRk8p04prULWunbTea2IIFonW9DoNet1mHMb5Mi9eAeLCJk9McE8UlwfjN5+DCr1qvXwUKqWn3EFU5Q7kGiKgJUZTOJwLiV3aGtCRNqPq9B3uUvk3Pt/VaoU2GmMTECFNUnSnx2RyzSobs1ytSFLLcDii2WyW8gSp0wPif9nqOlO18BAp49XWDUfUvUMtFZNmN8go6xulBiPe8aVfR+XWr17AGF3SvzcD5bWuYrfCaSVrdBZVwrbE2jgaJEiOi+/VNDS2ldLWjXAreB9SooqseAmUFnHxvUY2aZG3p+JxXiili4WrhDX1258z290sU+ubQ2o112apJhsnoVIVnuTr3CbASV5RNIqYZtG1RRP5BG5V46G5OHiVwFCPh0JYuLLl9Utl+1RD4UIxEVSki8WC29mM2XxOv9djMNxBFLhiY8QoEV0jvMk9SNTtzS1pAxppE60FlzlmtzPGF5ecXY4RgWa7yXh8xf7+Pvv7+2s0qAo1lbhBvJRlkkhRQrmtbhF394bcAyvfDfas13uVsYJii23wfbO02snJmqfwur3QpqYxslq9RLWYBMcM5cvT2cdNo0SC4bP4NepK8HlVtVPZ12OE1hszX2sctvgIbA4E5Qu2NLLR693ZP5uRFKUgKlgVbZC5Sv+n4pTXKkKgSkC5cNMW4ZYUQaLx/UpRNvoSjayfbEUJXci42er5rO58DloH+9BWu0Wj2aDRaNTUj2uU2VKt+XMYB3mek+crTj6f8unTMbPZDJSm1+tjlOLs5JTT0zO+++47HhwdhQ3pHMvlguvpNS7PIxdL16jMSpWTzGoBVsyYemzDZqO1rveo1dx+Q7FTmjPUXBSV3Gngts5WqGDmQnbrVJjuFuKk8sFJtWLD5iia1wCZFmZIivWyTGLZtBlGv3ZSy+aUvc7ClXJGwlo2l9wrNf45LKFt//7i99YRm7Xc+mj9qapXJUS/3IoQEsmB1CbiBfRdIXyeal5RuK3XkvNgrdCT0kK2vv2NsbTbNtzzG5tKbfql1TwRJBJBzQb1aGdnBycGL8JsNmN6e0uj1aTT69LrDwCY3kxZrpbM5gvOzk45eHAYaE8+jCTa7RbL5Wo9/mD992bjcagtnlU/95f6U5ywrafF1u2h1IbZQ0Av8ugOHpi8lQZDNudGxaOKhKIq3F5qtEO/dghUz2zbpmALh0vusZm5u0mk3pDXZi7lQqpPngsLIFkfKRbaD9m4neTemXHg85caeBVhGakYAToaWZffqyt+nujq5pf67bgZhbH5yMsNqUoKUxlPR5gzVaruqkEvg5RKd09dTR21inqTmmSbEGOB0vQGfb7pD0iTNP6dFuccV5MJabON1prDw4PydVtjkDQFPJOrCTYMaGQDddDRTYStvr134McvImV//o76MicpOk9EaNM5Qpyv94Hv5X2E94Lm3eiq9pXaLEFt6FjWIeO7PVA9Gbao60W2Ed3/tb+ktt/U9sFoqbqr9Dn/mgOryBpU6yyayhY0yndVARSUozB95zYtzP8KH4EwQ9qM76vBtWUlImsInorU/HLWFqUThQCudBspUpALLwWta2YMag3cUcaGeUl05gnE2yCx6A/6tDtdkjSlkTZKG1Flws/N3Yp2pxN6kOqkrb+5YuOYGquWNbO2Ottf3ac63Ljq7//lvzjyv/OQtUKX3Jy8LMucc+QFiqN1pFjnQW0ngnce7/Jgxf+n+Ih/4lZU6r7TYvPuvefv9xIYBhsy4eVqxXKxwCYJ7VYrOlhW5Zh3rjR6/lJS2X14SHUDSzXRr8fdxY2hNhrBrQO8NdZDzTqzTkCMMzVdDJ0LhWTh1BIZHKaYmGtd3SLFYVkbFKLDQq7fy6XjZ/n7WvMmLt7IhTEEGGswxlafbXFTRVhc65T9/b0i/kDd4R1tnuhK1Wv1gmPlSmqH2tKAwZrc+M++Rb60XIuvG63B2vUrveba7fMV3vtgDu18cA+RvCRFK7l/GKFqtW8UhPxZm/hL10rx7fPZjNvZDKUUvW6XLM84PTml1W4h8znT6ZSdwYB2u11uRC+Cy7JwqhqDsrbGN9rMBd/S9AulfqJ4jyUtpFT0xRKosEIqbUNlPXBJ1T0LpBLH1TDsku1dmoEEY4xCe1MekTXfq7UNQmXkUVBNfHxmmlqmjKrWqqhKYFfA4LpWTRQeXcUFURIr1yLb4P8HawhyF+u6NdoAAABcdEVYdGNvbW1lbnQARmlsZSBzb3VyY2U6IGh0dHA6Ly93d3cucG9rZXBlZGlhLmZyL2luZGV4LnBocC9GaWNoaWVyOlNhcXVlZGVuZXVfZCUyNyVDMyU4OXJpa2EucG5nAwh41AAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNC0wNC0wOFQxMToyNTozNSswMjowMDTB9NsAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTQtMDQtMDhUMTE6MjU6MzUrMDI6MDBFnExnAAAAR3RFWHRzb2Z0d2FyZQBJbWFnZU1hZ2ljayA2LjcuNy0xMCAyMDEyLTExLTA2IFExNiBodHRwOi8vd3d3LmltYWdlbWFnaWNrLm9yZyVyXygAAAAYdEVYdFRodW1iOjpEb2N1bWVudDo6UGFnZXMAMaf/uy8AAAAYdEVYdFRodW1iOjpJbWFnZTo6aGVpZ2h0ADQ2OG6GRb8AAAAXdEVYdFRodW1iOjpJbWFnZTo6V2lkdGgANjIw2xmPagAAABl0RVh0VGh1bWI6Ok1pbWV0eXBlAGltYWdlL3BuZz+yVk4AAAAXdEVYdFRodW1iOjpNVGltZQAxMzk2OTQ5MTM1wQVhxAAAABJ0RVh0VGh1bWI6OlNpemUAMzk3S0JCVIG1PwAAAFp0RVh0VGh1bWI6OlVSSQBmaWxlOi8vL3Nydi9wb2tlcGVkaWEvcG9rZXBlZGlhL3B1YmxpY19odG1sL2ltYWdlcy9jL2M2L1NhcXVlZGVuZXVfZCfDiXJpa2EucG5n88L/uQAAAABJRU5ErkJggg=="></div>'));
        setTimeout(() => $('#dku-under-the-hood-dku').css('bottom', '0px'), 200);
    });

    // Begining Clippy.js
    var clippyjs_agent;
    function create_clippyjs_agent(name_agent, callback) {
        name_agent = typeof name_agent !== 'undefined' ? name_agent : 'Clippy';
        clippy.load(name_agent, function(agent) {
            clippyjs_agent = agent;
            clippyjs_agent.show();
            //clippyjs_agent.moveTo(window.innerWidth-200,window.innerHeight-200);
            if (callback && typeof(callback) === "function") {
                callback();
            }
        });
    }

    Mousetrap.bind("c l i p p y", function() {
        if (typeof clippyjs_agent == 'undefined') {
            // First call : initializing
            clippyjs_agent = null;
            $("head").append($("<link rel='stylesheet' type='text/css' href='https://dku-assets.s3.amazonaws.com/clippy-js/clippy.css'>"));
            $("head").append($("<style>#loader-clippy{position:fixed;top:0px;left:0px;width:100%}#loader-clippy>div{margin:10em auto;"
                             +"font-size:10px;position:relative;text-indent:-9999em;border-top:1.1em solid rgba(255,255,255,.2);"
                             +"border-right:1.1em solid rgba(255,255,255,.2);border-bottom:1.1em solid rgba(255,255,255,.2);"
                             +"border-left:1.1em solid #ffc324;-webkit-transform:translateZ(0);transform:translateZ(0);"
                             +"-webkit-animation:load8 1.1s infinite linear;animation:load8 1.1s infinite linear;border-radius:50%;"
                             +"width:10em;height:10em}@-webkit-keyframes load8{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}"
                             +"@keyframes load8{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}"
                             +".clippy,.clippy-balloon{z-index:4000 !important}</style>"));
            $("body").append($("<div id='loader-clippy'><div></div></div>"));
            $("body").append($("<script type='text/javascript' src='https://dku-assets.s3.amazonaws.com/clippy-js/clippy.min.js'>"));
            setTimeout(function(){
                create_clippyjs_agent('Clippy', function(){
                    $("#loader-clippy").remove();
                });
            }, 1500);
        }
        else if (clippyjs_agent !== null) {
            // After first call : switching agent
            clippyjs_agent.hide(true, function() {
                $('.clippy').remove();
                $('.clippy-balloon').remove();
                if (clippyjs_agent.path.indexOf('Clippy') > -1) {
                    create_clippyjs_agent('Links', function() {
                        clippyjs_agent.play('GetWizardy');
                    });
                } else if (clippyjs_agent.path.indexOf('Links') > -1) {
                    create_clippyjs_agent('Merlin');
                } else {
                    create_clippyjs_agent('Clippy');
                }
            });
        }
    });

    Notification.registerEvent("job-state-change", function(evt, message) {
        if (message.state == "RUNNING" && typeof clippyjs_agent != 'undefined') {
            clippyjs_agent.play('Writing');
        } else if (message.state == "DONE" && typeof clippyjs_agent != 'undefined') {
            clippyjs_agent.play('Congratulate');
        } else if (message.state == "FAILED" && typeof clippyjs_agent != 'undefined') {
            clippyjs_agent.play('Alert');
        }
    });
    // End Clippy.js

    Mousetrap.bind("m s g a l l", function() {
        if ($rootScope.appConfig.admin === true) {
            var msg = window.prompt("What message do you want to send to all users?");
            Notification.broadcastToFrontends('msg-all', {msg:msg, user:$rootScope.appConfig.user});
        }
        else {
            alert("You must be admin to send a message."); // NOSONAR: OK to use alert for this message
        }
    });
    Notification.registerEvent('msg-all',function(evt, data) {
        MessengerUtils.post({
          message: "<div><b>Message from " + userLink(data.user.login, sanitize(data.user.displayName)) + ":</b><br>"+sanitize(data.msg)+"</div>",
          icon: userAvatar(data.user.login),
          hideAfter: 120,
          showCloseButton: true,
          id: 'msg-all-'+data.msg,
          type: 'no-severity'
        });
    });

    Mousetrap.bind("h a d o o p", function() {
        $("body").append($("<audio src='/static/dataiku/css/hadoop.mp3' autoplay/>"));
    });

    Mousetrap.bind("p i g", function() {
        $("body").append($("<audio src='/static/dataiku/css/pig.mp3' autoplay/>"));
    });

    Mousetrap.bind("h i v e", function() {
        $("body").append($("<audio src='/static/dataiku/css/hive.mp3' autoplay/>"));
    });

    Mousetrap.bind("p y t h o n", function() {
        $("body").append($("<audio src='/static/dataiku/css/python.mp3' autoplay/>"));
    });

    Mousetrap.bind("ctrl+e", function() {
        $rootScope.appConfig.easterEggs = true;
    });

    Mousetrap.bind("m i n i n g", function() {
        var elt = $("<div class='modal-container'><div id='minesweeper' class='modal modal3 dku-modal'><div class='modal-header'>"+
            "<h4><button type='button' class='close' data-dismiss='modal' aria-hidden='true'>&times;</button>"+
            "This is not data mining</h4></div><iframe  style='height: 500px;width: 98%' "+
            "src='http://www.chezpoor.com/minesweeper/minecore.html' /></div></div>");
        elt.modal("show");
    });

     Mousetrap.bind("k a t t a r s h i a n s", function() {
        var elt = $("<div class='modal-container'><div id='kattarshians' class='modal modal3 dku-modal relative-modal-90-90'>"+
            "  <iframe  style='width: 100%; height: 100%' "+
            "src='http://nutiminn.is/kattarshians/' /></div></div>");
        elt.modal("show");
    });

    Mousetrap.bind('up up down down left right left right b a enter', function() {
        CreateModalFromTemplate("/templates/infinity.html", $scope);
    });

    Mousetrap.bind("g e l l y", function(){
        window.setInterval(function(){
            d3.selectAll("g.node,g.edge").transition().duration(600).ease("elastic").attr("transform", function(d, i) {
                var x = 70 * Math.random() - 35;
                var y = 70 * Math.random() - 35;
                return "translate(" + x + " , " + y + ")";
            });
        }, 600)
    });

    Notification.registerEvent('discussions-wizz',function() {
        var elt = $('.discussions-widget-popover, .right-panel--opened .right-panel__content');
        elt.effect('shake');
    });

    Mousetrap.bind("w i z z", function() {
        Notification.broadcastToOtherSessions('discussions-wizz',{lol:"kikoo"});
    });

    Mousetrap.bind("l e a k s", function() {
        if ($state.current.name.startsWith('projects.project.wiki')) {
            $('.wiki-article-content.wiki-article-body-main').append($('<div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0;"><div class="water"><div class="drop"></div><div class="drop"></div><div class="drop"></div><div class="drop"></div></div><svg version="1.1" xmlns="http://www.w3.org/2000/svg"><defs><filter id="goo"><feGaussianBlur in="SourceGraphic" result="blur" stdDeviation="12"/><feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 18 -7" result="goo"/></filter></defs></svg><style>.water{background:#083a44;width:200%;height:19%;position:absolute;bottom:-11%;left:-50%;-webkit-filter:url(#goo);filter:url(#goo)}.drop,.water::before{background:inherit;position:absolute;bottom:598%}.water::before{content:"";width:100%;height:100%}.drop{width:64px;height:64px;left:50%;border-radius:0 50% 50%;-webkit-transform:translateX(-50%) rotate(45deg);transform:translateX(-50%) rotate(45deg);-webkit-animation:drop 2s ease-in infinite;animation:drop 2s ease-in infinite}.drop:nth-child(1){width:64px;height:64px;-webkit-animation-delay:.1875s;animation-delay:.1875s}.drop:nth-child(2){width:51.2px;height:51.2px;-webkit-animation-delay:375ms;animation-delay:375ms}.drop:nth-child(3){width:38.4px;height:38.4px;-webkit-animation-delay:.5625s;animation-delay:.5625s}.drop:nth-child(4){width:25.6px;height:25.6px;-webkit-animation-delay:.75s;animation-delay:.75s}@-webkit-keyframes drop{0%{bottom:598%}100%,50%{bottom:0}}@keyframes drop{0%{bottom:598%}100%,50%{bottom:0}}</style></div>'));
        }
    });

    $scope.win = function() {
         Notification.publishToFrontend("achievement-unlocked", {achievementId : 'LOL'});
    };

    /* ********************* Various notification stuff ******************* */

    Notification.registerEvent("login", function(evt, message) {
        MessengerUtils.post({
          message: '<span>' + userLink(message.user, sanitize(message.userDisplayName)) + " just connected</span>",
          icon: userAvatar(message.user),
          hideAfter: 5,
          showCloseButton: true,
          id: message.user+'connected',
          type: 'no-severity'
        });
    });

    Notification.registerEvent("logout", function(evt, message) {
        MessengerUtils.post({
          message: '<span>' + userLink(message.user, sanitize(message.userDisplayName)) + " just disconnected</span>",
          icon: userAvatar(message.user),
          hideAfter: 5,
          showCloseButton: true,
          id: message.user+'disconnected',
          type: 'no-severity'
        });
    });

    Notification.registerEvent("job-state-change", function(evt, message) {
        if (!displayUserTaskNotification(message)) return;

        // If we are on the recipe page and the result panel is open, the info is already displayed
        try {
            var resultPanel = angular.element(".recipe-editor-job-result, .recipe-settings-floating-result");
            if (resultPanel.length && resultPanel.scope().isJobRunning()) {
                if (resultPanel.scope().startedJob.jobId == message.jobId) {
                    return;
                }
            }
        } catch (e) {
            Logger.error("Failed to check if user is on running recipe page.", e);
        }


        var initiatedByCurrentUser = $rootScope.appConfig.login == message.initiator;

        function jobLink(innerHTML) {
            var link = StateUtils.href.job(message.projectKey, message.jobId);
            return '<a href="'+link+'" class="link-std">'+innerHTML+'</a>';
        }

        function goToLogs() {
            return StateUtils.go.job(message.projectKey, message.jobId);
        }

        function goToFirstOutput() {
            var output = message.outputs[0];
            if (!output) {
                return;
            }
            if (!output.type) {
                throw new Error("Job output type not specified: "+ angular.toJson(output));
            }
            return StateUtils.go.dssObject(output.type, output.targetDataset, output.targetDatasetProjectKey);
        }

        var gotoJob = (function(message){ return function() {
            StateUtils.go.job(message.projectKey, message.jobId);
        }})(message);

        var triggerLabel = '<i class="icon-play"/> ';
        if (message.triggeredFrom == 'SCHEDULER') {
            triggerLabel = '<i class="icon-calendar" title="Scheduled in a scenario"/> ';
        } else if (message.triggeredFrom == 'API') {
            triggerLabel = '<i class="icon-code" title="Triggered from API"/> ';
        }

        var userLabel = initiatedByCurrentUser ? '' :
            userLink(message.initiator,
                        userAvatar(message.initiator, 20)
                        + '<span class="messenger-initiator">'
                        + sanitize(message.initiatorDisplayName || message.initiator)
                        + '</span>'
                    ) + '<br />';
        var jobLabel = jobLink(sanitize(message.humanReadableJobDesc));

        if (message.state == "DONE") {
            var warnLevel = message.warningsCount ? 'warning' : 'success';
            window.showNativeNotification("Job completed", message.jobId, gotoJob, message.initiator);
            if (!message.warningsCount) {
                MessengerUtils.post({
                    message: '<div>' + userLabel + 'Job completed<br/>' + jobLabel + '</div>',
                    icon: triggerLabel,
                    type: warnLevel + ' current-user',
                    id: message.jobId,
                    hideAfter: 5,
                    actions: {
                        target: {
                            label: "View",
                            action: goToFirstOutput
                        },
                        logs: {
                            label: "Logs",
                            action: goToLogs
                        }
                    }
                });
            }
        } else if (message.state == "RUNNING") {
            MessengerUtils.post({
                message: '<div>' + userLabel + 'Job started<br/>' + jobLabel + '</div>',
                icon: triggerLabel,
                type: 'current-user',
                hideAfter: 5,
                id: message.jobId,
                showCloseButton: true,
                actions: {
                    logs: {
                        label: "Logs",
                        action: goToLogs
                    }
                }
            });
        } else if(message.state == "FAILED" || message.state == "ABORTED") {
            window.showNativeNotification("Job " + message.state.toLowerCase(), message.jobId, gotoJob, message.initiator);
            MessengerUtils.post({
                message: '<div>' + userLabel + 'Job ' + message.state.toLowerCase() + '<br/>' + jobLabel + '</div>',
                icon: triggerLabel,
                type: 'error current-user',
                showCloseButton: true,
                id: message.jobId,
                hideAfter: 5,
                actions: {
                    logs: {
                        label: "Logs",
                        action: goToLogs
                    }
                }
            });
        }
    });


    function mlTaskLink(mlTaskType, projectKey, analysisId, mlTaskId, innerHTML) {
        var href = StateUtils.href.mlTask(mlTaskType, projectKey, analysisId, mlTaskId);
        return '<a href="'+href+'" class="link-std">'+innerHTML+'</a>';
    }

    function displayUserTaskNotification(evt) {
        var initiatedByCurrentUser = $rootScope.appConfig.login == evt.initiator;
        var otherUsersTasks = $rootScope.appConfig.userSettings.frontendNotifications.otherUsersTasks;
        return initiatedByCurrentUser || otherUsersTasks;
    }

    Notification.registerEvent("mltask-state-change", function(evt, message) {
        if (!displayUserTaskNotification(message)) return;

        // If we are on the mltask page, the info is already displayed
        try {
            var x = 'projects.project.analyses.analysis.ml.';
            if (
                ($state.current.name == x+'predmltask.list.results' || $state.current.name == x+'clustmltask.list.results')
                && message.projectKey == $stateParams.projectKey
                && message.taskId == $stateParams.mlTaskId
                ) {
                return;
            }
        } catch (e) {
            Logger.error("Failed to check if user is on running mlTask page.", e);
        }

        MessengerUtils.post({
            message: mlTaskLink(message.taskType, message.projectKey, message.analysisId, message.taskId, sanitize(message.name + ": training done")),
            icon: '<i class="icon-dku-nav_analysis" />',
            type: 'success',
            showCloseButton: true
        });
    });

    Notification.registerEvent("timeline-item", function(evt, message) {
        if (message.item.action == "COMMENT") {
            MessengerUtils.post({
                message: userLink(message.item.user, sanitize(message.item.details.userDisplayName))
                    + " commented on "
                    + dssObjectLink(message.item.objectType, message.item.projectKey, message.item.objectId, sanitize(message.item.details.objectDisplayName))
                    + ":"
                    + '<span class="messenger-comment">'
                    + sanitize(message.item.details.text.substr(0,400))
                    + (message.item.details.text.length > 400 ? '[...]' : '')
                    + '</span>'
                    ,
                icon: userAvatar(message.item.user),
                type: 'no-severity',
                hideAfter: 5,
                showCloseButton: true
            });
        } else if (message.item.action == "EDIT_COLLABORATIVE_METADATA") {
            Assert.trueish(message.item.details.doneTasks != null, 'no done tasks');
            var tasks = "";
            for (var i = 0; i < message.item.details.doneTasks.length; ++i) {
                tasks += '<i class="icon-ok" /> ' + sanitize(message.item.details.doneTasks[i]);
            }

            MessengerUtils.post({
                message: userLink(message.item.user, sanitize(message.item.details.userDisplayName))
                    + " completed a task on "
                    + dssObjectLink(message.item.objectType, message.item.projectKey, message.item.objectId, sanitize(message.item.details.objectDisplayName))
                    + ":"
                    + '<span class="messenger-comment">'
                    + tasks
                    + '</span>'
                    ,
                icon: userAvatar(message.item.user),
                type: 'no-severity',
                hideAfter: 5,
                showCloseButton: true
            });
        }
    });

    Notification.registerEvent("commit-mention", function(evt, message) {
        MessengerUtils.post({
            message: userLink(message.author, sanitize(message.details.authorDisplayName || message.author))
                + " mentioned you in commit: "
                + '<span class="messenger-comment">'
                + sanitize(message.message.substr(0,400))
                + (message.message.length > 400 ? '[...]' : '')
                + '</span>'
                ,
            icon: userAvatar(message.author),
            type: 'no-severity',
            showCloseButton: true
        });
    });

    Notification.registerEvent("interest-added", function(evt, message) {
        MessengerUtils.post({
            message: '<i class="icon-star interests-star active"></i>'
                + userLink(message.user, sanitize(message.details.userDisplayName))
                + ' starred '
                + dssObjectLink(message.objectType, message.projectKey, message.objectId, sanitize(message.details.objectDisplayName)),
            icon: userAvatar(message.user),
            id: message.user+'starred'+message.details.objectDisplayName,
            type: 'no-severity',
            showCloseButton: true
        });
    });

    Notification.registerEvent("scenario-run-failed-check-logs", function(evt, message) {
        if (!displayUserTaskNotification(message)) return;
        MessengerUtils.post({
          message: "Failed to run scenario " + message.projectKey+"."+message.scenarioId + ": " + message.message + ".\nPlease check logs",
          icon: '<i class="icon-calendar"/>',
          type: "error",
          id: "ScenarioState"+ message.scenarioId,
          showCloseButton: true
        });
    });

    Notification.registerEvent("scenario-state-change", function(evt, message) {
        function goToLogs() {
            return StateUtils.go.scenario(message.scenarioId, message.projectKey);
        }
        if (!displayUserTaskNotification(message)) return;
        var msg = {
                DONE: 'finished',
                RUNNING: 'started',
                FAILED: 'failed',
                ABORTED: 'aborted'
            };
        var isSuccess = ['DONE'].indexOf(message.state) >= 0;
        var isError = ['FAILED', 'ABORTED'].indexOf(message.state) >= 0;
        var triggerLabel = '<i class="icon-calendar" /> ';
        var actions = {};
        if (isSuccess || isError) {
            actions.logs = {label: "Logs",action: goToLogs};
        }
        MessengerUtils.post({
          message: "Scenario " + msg[message.state] + "<br/>" + dssObjectLink('SCENARIO', message.projectKey, message.scenarioId, message.scenarioName),
          icon: triggerLabel,
          id: "ScenarioState"+ message.scenarioId,
          type: isSuccess ? 'success' : (isError ? 'error' : ''),
          showCloseButton: true,
          actions : actions
        });
    });

    $scope.showAbout = function() {
    	$scope.closeContextualMenus();
        CreateModalFromTemplate("/templates/about-dss.html", $scope, null, function(modalScope){
            modalScope.currentYear = new Date().getFullYear();
        });
    };

    $scope.showAboutPartitioning = function() {
    	$scope.closeContextualMenus();
         CreateModalFromTemplate("/templates/about-partitioning.html", $scope);
    };

    $scope.showFeedbackModal = function() {
        $scope.closeContextualMenus();
        CreateModalFromTemplate("/templates/widgets/topbar_drawers/feedback-modal.html", $scope, 'FeedbackController');
    };

    this.getStateWithParam = (scope, state) => {
        let stateName = scope.appConfig.userSettings.home.behavior;
        let params = {};
        if (stateName === HomeBehavior.LAST) {
            const lastVisitedState = HomePageContextService.getLastVisitedState();
            if (lastVisitedState === undefined || lastVisitedState === null) {
                stateName = HomeBehavior.DEFAULT;
            } else {
                stateName = lastVisitedState.name;
                params = lastVisitedState.params;
            }
        }
        else if (stateName !== HomeBehavior.DEFAULT && stateName !== HomeBehavior.PROJECTS) {
            stateName = HomeBehavior.DEFAULT;
        }
        else if (stateName === HomeBehavior.PROJECTS) {
            params = {folderId: ''};
        }
        // In case the state is unknown (edited by the user, etc)
        stateName = state.href(stateName, params) != null ? stateName : HomeBehavior.DEFAULT;
        return { state: stateName, params };
    };

    $scope.getHomeHref = () => {
        const stateWithParam = this.getStateWithParam($scope, $state);
        return $state.href(stateWithParam.state, stateWithParam.params);
    };

    $scope.redirectHome = () => {
        const stateWithParam = this.getStateWithParam($scope, $state);
        $state.go(stateWithParam.state, stateWithParam.params, { reload: true });
    };

    $scope.onClickHref = (event) => {
        event.preventDefault();
        $scope.redirectHome();
    };

    $scope.freshWidgetInitDone = false;

    $rootScope.showHelpModal = function(){
        function showSupportWidget() {
            if (window.dkuAppConfig && window.dkuAppConfig.offlineFrontend){
                ActivityIndicator.error("Offline mode - Support widget not available");
                return;
            }
            if (!$scope.freshWidgetInitDone) {
                var version = nv.version && nv.version.product_version;
                var instanceId = nv.dipInstanceId;
                if (!window.devInstance) {
                    FreshWidget.init("", {
                        "queryString": "&widgetType=popup&helpdesk_ticket[custom_field][dss_version_112979]=" + version
                            + "&helpdesk_ticket[custom_field][dss_instance_112979]=" + instanceId,
                        "widgetType": "popup", "buttonType": "text", "buttonText": "Support",
                        "buttonColor": "white", "buttonBg": "#006063", "alignment": "4",
                        "submitThanks" : "Thanks for your message. We'll get in touch very soon",
                        "offset": "-1500px", "formHeight": "500px",
                        "url": "https://dataiku.freshdesk.com",
                        "loadOnEvent" : "immediate"
                    } );
                } else {
                    ActivityIndicator.error("Support widget not available on a dev instance");
                    return;
                }
                $scope.freshWidgetInitDone = true;
            }
            FreshWidget.show();
        }
        CreateModalFromTemplate("/templates/widgets/topbar_drawers/get-help-modal.html", $scope, null, function(newScope) {
            newScope.openSupport = function() {
                newScope.dismiss();
                showSupportWidget();
            };
            newScope.openIntercom = function() {
                newScope.dismiss();
                $scope.forceShowIntercom()
            }
        });
    };

    const getZoomedZoneCtxKey = () => {
        return `dku.flow.zoneId.${$stateParams.projectKey}`;
    }

    $scope.getDestZone = function() {
        if ($stateParams.zoneId || $state.current.name.includes('projects.project.home.regular')) {
            localStorageService.remove(getZoomedZoneCtxKey());
            return null;
        }
        return localStorageService.get(getZoomedZoneCtxKey());
    }

    $scope.$on("$stateChangeSuccess", function() {
        if ($state.$current.pageTitle) {
            TopNav.setPageTitle($state.$current.pageTitle($stateParams));
        }
        if ($state.current.name.includes('projects.project.flow')) {
            localStorageService.set(getZoomedZoneCtxKey(), $stateParams.zoneId);
        }
    });


    /* ******************* Persistent notifications handling ****************** */

    $scope.pnotifications = {};
    $scope.countNotifications = function() {
        DataikuAPI.notifications.count().success(function(data) {
            $scope.pnotifications.totalUnread = data.totalUnread;
            $rootScope.totalUnreadNotifications = data.totalUnread;
            TopNav.refreshPageTitle();
        });
    };

    Notification.registerEvent("export-state-change", function(evt, message) {
        if (message.status.state == "RUNNING") return;
        $scope.countNotifications()
    });
    Notification.registerEvent("job-state-change", function(evt, message) {
        if (message.state == "RUNNING") return;
        $scope.countNotifications()
    });
    Notification.registerEvent("update-notifications-count", function(evt, message) {
        // Sometimes the sent event contains the totalUnread value, no need to fetch it again
        if (message.totalUnread == -1) {
            $scope.countNotifications();
        } else {
            $scope.pnotifications.totalUnread = message.totalUnread;
            $rootScope.totalUnreadNotifications = message.totalUnread;
            TopNav.refreshPageTitle();
        }
    });

    $rootScope.discussionsUnreadStatus = $rootScope.discussionsUnreadStatus || {};
    Notification.registerEvent("discussions-unread-full-ids-changed", function(evt, message) {
        let newFIDs = angular.copy(message.unreadFullIds || []);
        $rootScope.discussionsUnreadStatus.unreadFullIds = newFIDs;
    });

    $scope.hasUnreadThings = function() {
        return $scope.pnotifications.totalUnread || ($rootScope.discussionsUnreadStatus.unreadFullIds || []).length;
    };


    /* ******************* Exports handling ****************** */

    Notification.registerEvent("export-state-change", function(evt, message) {
        if (!displayUserTaskNotification(message)) {
            return;
        }
        var txt = null;
        var type = null;
        if (message.status.state == 'DONE') {
            var lowerDescription = message.status.inputDescription.description ? message.status.inputDescription.description.toLowerCase() : '';
            if (lowerDescription.startsWith("dataset")) {
                var datasetName = sanitize(message.status.inputDescription.name);
                var datasetProjectKey = sanitize(message.status.inputDescription.projectKey);
                txt = 'Export done : dataset <a href="/projects/'+datasetProjectKey+'/datasets/'+datasetName+'/explore/" class="link-std">'+ datasetName + '</a>';
            } else if (lowerDescription.startsWith("apply shaker")) {
                var datasetName = sanitize(message.status.inputDescription.name);
                var datasetProjectKey = sanitize(message.status.inputDescription.projectKey);
                txt = 'Export done : apply shaker on <a href="/projects/'+datasetProjectKey+'/datasets/'+datasetName+'/explore/" class="link-std">'+ datasetName + '</a>';
            } else {
                txt = sanitize("Export done : "+ message.status.inputDescription.name);
            }
            type = 'success';
        } else if (message.status.state == 'FAILED'){
            txt = sanitize("Export failed : "+ message.status.inputDescription.name);
            type = 'error';
        }
        if (txt) {
            MessengerUtils.post({
                 message: txt,
                 icon: '<i class="icon-download-alt"></i>',
                 type: type,
                 hideAfter: 5,
                 showCloseButton: true
             });
        }
    });

    /* ********* Global actions we want in every scope ********************* */

    /* Open the modal for exporting a dataset */
    $scope.exportDataset = function(projectKey, datasetName, overrideFeatures) {
        DataikuAPI.datasets.getForExport(projectKey, datasetName, $stateParams.projectKey).success(function(datasetDetails) {
            var partitionLoader = (datasetDetails.partitioning.dimensions.length == 0) ? null : (function() {
                var deferred = $q.defer();
                DataikuAPI.datasets.listPartitions(datasetDetails).success(function(partitionData) {
                    deferred.resolve(partitionData);
                }).error(function() {
                    deferred.reject();
                });
                return deferred.promise;
            });
            var dialog = {
                title : 'Export "'+datasetName+'"',
                warn : null
            };
            var features = {
                partitionListLoader:partitionLoader,
                datasetDefinition: datasetDetails,
                downloadMethod: false
            };
            rextend(features,overrideFeatures);
            CreateExportModal($scope, dialog, features).then(function(params) {
                // Create export
                DataikuAPI.datasets.exportDS($stateParams.projectKey, projectKey, datasetName, params).success(function(data) {
                    ExportUtils.defaultHandleExportResult($scope, params, data);
                }).error(setErrorInScope.bind($scope));
            });
        }).error(setErrorInScope.bind($scope));
    };

    $scope.datasetSmartHRef = function(smartName, subState) {
        if (!smartName) return;
        if(!subState) {
            subState = 'explore';
        }
        if (smartName.indexOf(".") > 0) {
            var chunks = smartName.split(".");
            return $state.href("projects.project.datasets.dataset."+subState, {projectKey :chunks[0], datasetName : chunks[1]})
        } else {
            return $state.href("projects.project.datasets.dataset."+subState, {projectKey :$stateParams.projectKey, datasetName :smartName})
        }
    };

    /* Shortcut : put the service in the scope so we can use it directly in templates */
    $scope.WT1Event = function(type, params) {
        WT1.event(type, params);
    };

    $scope.setSpinnerPosition = function(position){
    	$rootScope.spinnerPosition = position;
    };

    $scope.setTheme = function(theme) {
    	if (theme) {
    		var uri = $scope.getThemeUri(theme);
        	var cssUri = uri + "theme.css";
        	$("#theme-stylesheet").remove();
        	$("head").append('<link id="theme-stylesheet" rel="stylesheet" type="text/css" href="'+cssUri+'">');
        	if (!theme.isUnitedColorBg) {
                if (theme.background.startsWith("http")) {
                    var imgUri = theme.background;
                } else {
                    var imgUri = uri + theme.background;
                }
                $("#root-dom-element").css("background-image","url("+imgUri+")");
            } else {
                $("#root-dom-element").css("background-image","none");
            }
    	} else {
    		$("#theme-stylesheet").remove();
    		$("#root-dom-element").css("background-image","none");
    	}
        /* Update or revert favicon */
        var faviconLink = $("head").find("link[rel='shortcut icon']");
        if (theme && theme.favicon) {
            var faviconUri = uri + theme.favicon + '?t=' + new Date().getTime();
            faviconLink.attr("href", faviconUri);
        } else {
            faviconLink.attr("href", "/favicon.ico?v=3");
        }
    };

    $scope.getThemeUri = function(theme) {
    	var uri;
    	switch (theme.origin) {
    		case "BUILTIN":
    			uri = "/themes/builtin/" + theme.id + "/";
    			break;
    		case "PLUGIN":
    			uri = "/plugins/" + theme.pluginId + "/resource/themes/" + theme.id + "/";
    			break;
    		case "USER":
    			uri = "/themes/user/"  + theme.id + "/";
    			break;
    	}
    	return uri;
    };

    // refactor status color handling out into a service for easier usage in separated scopes
    $scope.getProjectStatusColor = function(status) {
        return ProjectStatusService.getProjectStatusColor(status);
    };


        $scope.codeMirrorSettingService = CodeMirrorSettingService;

    /* ******************* Top nav override ****************** */
    $scope.onEnterSecondNav = function(type){
        TopNav.setOverrideLeftType(type);
    };

    $scope.onLeaveSecondNav = function(){
        TopNav.setOverrideLeftType(null);
    };

    $scope.isShowNavSearch = function() {
        return TopNav.isShowHomePageNavSearch();
    };

    Logger.info("DSS loaded");

    $scope.closeNavMenu = function (triggerId) {
        let trigger = document.querySelector('#' + triggerId);
        trigger.classList.add('js-blurred');
        let blurListener = trigger.addEventListener('mouseout', function() {
            trigger.classList.remove('js-blurred');
            trigger.removeEventListener('mouseout', blurListener);
        })
    };

    /* ******************* Global Finder ****************** */
    Mousetrap(document.body).bind("mod+shift+f", e => {
        const inCodeMirror = $(e.target).closest('.CodeMirror').length > 0;
        if (inCodeMirror === false || DetectUtils.getOS() === "macos") {
            e.preventDefault();
            $scope.openGlobalFinder();
        }
    });

    $scope.modKey = DetectUtils.getOS() === "macos" ? "⌘" : "Ctrl"; //also used in shortcuts.html
    $scope.globalFinderShortcut = DetectUtils.getOS() === "macos" ? `${$scope.modKey}⇧F` : `${$scope.modKey}+Shift+F`;
    $scope.globalFinderLocalStorageKey = "global-search__last-searches";
    $scope.globalFinderTabStorageKey = "global-search__last-tabId";


    $scope.initQuery = (filter = '', advancedSearch = false) => {
        $scope.globalfinder = Object.assign({}, $scope.globalfinder, { q: filter, results: [], hits: [], searchResultsAnswers: {hits: []}, searchResultsDoc: {hits: []}, searchResultsLearn: {hits: []}, advancedSearch });
        $scope.initLastSearches();
    };

    $scope.initLastSearches = () => {
        let searches = localStorageService.get($scope.globalFinderLocalStorageKey);
        if (searches === null || Array.isArray(searches) === false) {
            searches = [];
        }
        let data = searches.map((q, index) => ({$idx: index, _type: 'search', _category: 'recent', _source: {name: q.query, query: q.query, time: q.time, tabId: q.tabId }, icon: 'global-finder-modal__search-type-icon--smaller--nomargin icon-time'}));
        $scope.initial.index = 1;
        data.unshift({_type: 'search-separator', selectable: false, _source: {name: 'Recent searches', query: '' }});
        $scope.globalfinder.results = data;
        $scope.globalfinder.allData = [...data];
    };

    $scope.globalFinderModal = null;

    $scope.openGlobalFinder = (filter = '', advancedSearch = false, tabId = undefined) => {
        if ($scope.globalFinderModal !== null) { // Forbid two modal at the same time
            return;
        }
        const filterPattern = '(\\w+:(".+"|[^ ]+))';
        $scope.initial = { index: 0 };
        $scope.initQuery(filter, advancedSearch);

        $scope.globalFinderModal = CreateModalFromTemplate("/templates/global-finder-modal.html", $scope, null, newScope => {

            const projectNames = {};
            DataikuAPI.projects.list()
                .success(function (response) {
                    angular.forEach(response, function (project) {
                        projectNames[project.projectKey] = project.name;
                    })
                })
                .error(setErrorInScope.bind($scope));

            const users = {};
            DataikuAPI.security.listUsers()
                .success(function (response) {
                    angular.forEach(response, function (user) {
                        users[user.login] = user.displayName;
                    })
                })
                .error(setErrorInScope.bind($scope));

            newScope.inProject = !!newScope.$stateParams.projectKey;

            newScope.getHelp = function () {
                newScope.dismiss();
                $scope.showHelpModal();
            };

            newScope.shouldTriggerBackendSearch = () => !newScope.globalfinder.advancedSearch || newScope.tabs.current.id !== "help";
            newScope.helpIntegrationEnabled = () => newScope.wl.contextualHelpSearchEnabled && newScope.appConfig.helpIntegrationEnabled;
            newScope.shouldTriggerHelpSearch = () => newScope.helpIntegrationEnabled() && (!newScope.globalfinder.advancedSearch || newScope.tabs.current.id === "all" || newScope.tabs.current.id === "help");

            newScope.updateLastSearches = (newSearch, tabId) => {
                if (newSearch === '') {
                    return;
                }

                let searches = localStorageService.get($scope.globalFinderLocalStorageKey);
                if (searches === null || Array.isArray(searches) === false) {
                    searches = [];
                }
                let index = searches.map(s => s.query.toLowerCase()).indexOf(newSearch.toLowerCase());
                if (index !== -1) {
                    searches.splice(index, 1);
                }
                let savedSearch = {
                    query: newSearch,
                    tabId: tabId,
                    time: Date.now()
                };
                searches.unshift(savedSearch);

                if (searches.length > 5) {
                    searches.splice(5);
                }
                localStorageService.set($scope.globalFinderLocalStorageKey, searches)
            };

            newScope.onSmartInputChange = () => {
                newScope.initial.index = 0;
                const tabSelected = newScope.tabs.current && newScope.tabs.current.id !== 'all';
                if (!tabSelected) {
                    disableAdvancedSearch();
                }
                newScope.triggerSearch(!tabSelected);
            };

            newScope.triggerSearch = function (shouldSelectTab = true, shouldHandleLoading = true) {
                if (shouldHandleLoading) {
                    newScope.globalfinder.searching = true;
                    newScope.globalfinder.results = [];
                    newScope.globalfinder.allData = [];
                }
                newScope.globalfinder.trimmedQuery = newScope.trimQuery(newScope.globalfinder.q);
                if (newScope.globalfinder.trimmedQuery === '') {
                    newScope.globalfinder.searching = false;
                }
                newScope.debouncedTriggerSearch(shouldSelectTab);
            };

            newScope.debouncedTriggerSearch = Debounce().withDelay(200, 200).wrap(function (shouldSelectTab = true) {
                let query = newScope.globalfinder.q;
                if (!newScope.globalfinder.advancedSearch && query === "") {
                    setCurrentTab();
                    $scope.initQuery('', newScope.globalfinder.advancedSearch);
                    return;
                }

                if (newScope.globalfinder.advancedSearch) {
                    newScope.initial.index = -1;
                }
                if (shouldSelectTab) {
                    newScope.selectTabBasedOnFilter();
                }
                if (newScope.shouldTriggerHelpSearch()) {
                    newScope.globalfinder.search(query);
                }
                if (newScope.shouldTriggerBackendSearch()) {
                    if (newScope.globalfinder.advancedSearch && newScope.tabs.current.filtersPrefix) {
                        for (var i = 0; i < newScope.tabs.current.filtersPrefix.length; i++) {
                            const filter = newScope.tabs.current.filtersPrefix[i];
                            if (!query.toLowerCase().includes(`${filter}:`)) {
                                query += ` ${filter}:all`;
                            }
                        }
                    }

                    if (newScope.inProject && newScope.tabs.current.id === 'project' && !query.toLowerCase().includes('project:')) {
                        query += ` project:${newScope.$stateParams.projectKey}`;
                    }

                    DataikuAPI.globalfinder.search(query, newScope.globalfinder.advancedSearch === true ? 100 : 10, newScope.$stateParams.projectKey)
                        .success(data => {
                            newScope.globalfinder.hits = data.hits.map(hit => Object.assign({url: newScope.getLink(hit)}, hit));
                            newScope.globalfinder.aggregations = data.aggregations;
                            newScope.buildResult();
                        })
                        .error(() => {
                            newScope.globalfinder.hits = [];
                            newScope.buildResult();
                        });
                } else {
                    newScope.globalfinder.hits = [];
                }
                newScope.focusSearchInput();
            });

            newScope.trimQuery = query => {
                return query.replace(new RegExp(filterPattern, 'g'), '').trim().replace(/\s{2,}/g, ' ').trim();
            };

            newScope.emptySearch = () => {
                newScope.globalfinder.q = "";
                disableAdvancedSearch();
                newScope.triggerSearch();
                newScope.focusSearchInput();
            };

            newScope.focusSearchInput = () => {
                const searchInputs = document.getElementsByClassName("global-finder-modal__search-input");
                if (searchInputs && searchInputs.length > 0) {
                    searchInputs[0].focus();
                }
            };

            newScope.enableTab = tab => {
                newScope.removeAllFilters();
                newScope.tabs.current = tab;
                newScope.globalfinder.aggregations = {};
                newScope.updateLastSearches(newScope.globalfinder.q, newScope.tabs.current.id);
                newScope.triggerSearch(false);
            };

            // We first select the tab based on filter in the query, then based on the last tab.
            newScope.selectTabBasedOnFilter = () => {
                const potentialTab = newScope.tabs.availables.find(t => t.filtersPrefix.some(f => newScope.hasFilter(`${f}:`)));
                if (potentialTab !== undefined) {
                    newScope.tabs.current = potentialTab;
                    return;
                }
                if (newScope.tabs.current === undefined) {
                    newScope.tabs.current = newScope.tabs.availables[0];
                }
            };

            newScope.removeFilter = filter => {
                newScope.globalfinder.q = newScope.globalfinder.q.replace(new RegExp(`${filter}(?=\\s|\$)`, 'g'), '').trim().replace(/\s{2,}/g, ' ');
            };

            newScope.addFilter = filter => {
                newScope.globalfinder.q = `${newScope.globalfinder.q} ${filter}`;
            };

            newScope.hasFilter = filter => newScope.globalfinder.q.includes(filter);

            newScope.hasFilterWithValue = filter => {
                return new RegExp(`${filter}(?=\\s|\$)`, 'g').test(newScope.globalfinder.q);
            };

            newScope.hasAnyFilter = () => new RegExp(filterPattern).test(newScope.globalfinder.q);

            newScope.buildFilterValue = (value) => value.includes(' ') ? `"${value}"` : value;

            newScope.removeAllFilters = prefix => {
                if (prefix === undefined) {
                    newScope.globalfinder.q = newScope.trimQuery(newScope.globalfinder.q);
                } else {
                    newScope.globalfinder.q = newScope.globalfinder.q.replace(new RegExp(`(${prefix}:(".+"|[^ ]+))`, 'g'), '').trim().replace(/\s{2,}/g, ' ').trim();
                }
            };

            newScope.toggleFilter = (facet, value, isAllFilter = false) => {
                const filter = `${facet}:${value}`;
                const hasFilter = newScope.hasFilterWithValue(filter);
                if (newScope.isHelpTabSelected()) {
                    newScope.removeAllFilters(facet);
                }
                if (hasFilter) {
                    newScope.removeFilter(filter);
                } else {
                    newScope.addFilter(filter);
                }
                const allFilter = `${facet}:all`;
                if (isAllFilter) {
                    newScope.removeAllFilters(facet);
                } else if (newScope.hasFilterWithValue(filter)) {
                    newScope.removeFilter(allFilter)
                }
                newScope.triggerSearch(false, false);
            };

            newScope.getAggregationTitle = key => {
                switch (key) {
                    case '_type':
                    case 'help':
                        return "Type";
                    case 'tag.raw':
                        return "Tags";
                    case 'projectKey.raw':
                        return 'Projects';
                    default:
                        return typeof key === 'string' ? key.charAt(0).toUpperCase() + key.slice(1) : key;
                }
            };

            newScope.getAggregationText = (key, aggKey, aggItem) => {
                if (aggKey === 'help') {
                    return aggItem.label ? aggItem.label : key;
                } else if (aggKey === 'projectKey.raw') {
                    return projectNames[key] || key;
                } else if (aggKey === 'user') {
                    return users[key] || key;
                }
                return typeof key === 'string' ? $filter('capitalize')(key.replace(/_/g, " ")) : key;
            };

            newScope.getLastModifiedDate = (item) => {
                let lastModifiedOn = '';
                let createdOn = '';
                let lastReplyTime = '';

                if (!item) {
                    return ''
                }

                if (item._type === "discussion") {
                    lastReplyTime = item._source.lastReplyTime;
                } else if (item._source) { // DSS items
                    lastModifiedOn = item._source.lastModifiedOn;
                    createdOn = item._source.createdOn;
                } else if (item.created_parsed) { // Questions & Answers items
                    lastModifiedOn = item.created_parsed;
                }

                let lastModifiedDate = lastModifiedOn || createdOn || lastReplyTime || '';
                if (!lastModifiedDate) {
                    return lastModifiedDate;
                }

                let currentYear = new Date().getFullYear();
                let itemYear = new Date(lastModifiedDate).getFullYear();

                if (itemYear === currentYear) {
                    return $filter("friendlyDate")(lastModifiedDate, "d MMM");
                } else {
                    return $filter("friendlyDate")(lastModifiedDate, "dd/MM/yyyy");
                }
            };

            newScope.getFilter = key => {
                if (key === '_type') {
                    return 'type';
                }
                if (key === 'tag.raw') {
                    return "tag";
                }
                if (key === 'projectKey.raw') {
                    return 'project';
                }
                return key;
            };

            newScope.formatItemName = item => {
                if (!item) {
                    return '';
                }
                if (item._type === 'discussion') {
                    return item._source.discussions && item._source.discussions.length && item._source.discussions[0].topic ? item._source.discussions[0].topic : "Unnamed discussion";
                }
                return item._source.name;
            };

            newScope.formatItemPath = item => {
                if (!item) {
                    return '';
                }
                if (newScope.isNavigation(item)) {
                    return item._source.path.replace(` > ${item._source.name}`, "");
                }
                if (item._type === 'discussion') {
                    return item._source.projectName + " > " + item._source.objectName;
                }
                if (item._type === 'project') {
                    return item._source.shortDesc;
                }
                return item._source.projectName;
            };

            newScope.formatItemHelpType = item => {
                if (item && item._type) {
                    return $filter('capitalize')(item._type.replace(/_/g, " "));
                }
                return "Help";
            };


            newScope.chunkSize = () => newScope.isHelpTabSelected() ? 10 : 3;
            if (newScope.globalfinder === undefined){
                newScope.globalfinder = {};
            }
            newScope.globalfinder.searchResults = {hits: []};

            newScope.globalfinder.search = (query = newScope.globalfinder.q) => {
                const trimmedQuery = newScope.trimQuery(query);
                // Google search does not accept empty query
                if (!trimmedQuery) {
                    return;
                }
                return newScope.getRowChunk(0)
                .success(newScope.onResult("searchResults"))
                .error(onError(newScope.globalfinder, "searchResults", {hits: []}));
            }

            const onError = (object, fieldName, defaultValue = []) => content => {
                object[fieldName] = defaultValue;
                newScope.buildResult();
            };

            newScope.onResult = fieldName => content => {
                newScope.globalfinder.searchInformation = content.searchInformation;
                newScope.globalfinder[fieldName] = Object.assign({nbHits: parseInt(content.searchInformation.totalResults, 10)}, content, {hits: (content.items ? content.items : []).map(item => Object.assign({url: item.link, isHelp: true, _type: newScope.getItemType(item), _id:item.cacheId}, item))});
                newScope.buildResult();
            };

            newScope.getRowChunk = pageNumber => {
                return DataikuAPI.help.search(newScope.globalfinder.q.replace('help:', 'more:'), {"num": newScope.chunkSize(), "start": (pageNumber * newScope.chunkSize()) + 1});
            }

            newScope.getListRowNumber = () => {
                // According to https://developers.google.com/custom-search/v1/reference/rest/v1/cse/list
                // The JSON API will never return more than 100 results, even if more than 100 documents match
                // So we limit to 100 in case we have more results
                return Math.min(100, newScope.globalfinder.searchInformation ? parseInt(newScope.globalfinder.searchInformation.totalResults, 10) : 100);
            };

            newScope.getItemType = item => {
                const type = item && item.pagemap && item.pagemap.metatags ? item.pagemap.metatags.map(metatag => metatag["og:site_name"]).find(site => site) : undefined;
                if (type === undefined && item.displayLink) {
                    return item.displayLink.match("^[^\.]*")[0];
                }
                return type;
            };

            newScope.transformPage = (pageNumber, response) => {
                const data = (response.items ? response.items : []).map((item, index) => Object.assign({url: item.link, isHelp: true, _type: newScope.getItemType(item), _id: item.cacheId, $idx: index + (newScope.chunkSize() * pageNumber)}, item))
                if (pageNumber == 0) {
                    newScope.globalfinder.allData = [];
                }
                if (data.length > 0) {
                    newScope.globalfinder.allData.splice(data[0].$idx, 0, ...data);
                }
                if (response.searchInformation) {
                    newScope.globalfinder.searchInformation = response.searchInformation;
                }
                return function(i, j) {
                    return data[i % newScope.chunkSize()];
                };
            };

            newScope.buildSearchAggregations = () => {
                // In case the search is not configured to have facets, display them in full
                if (!newScope.globalfinder.searchResults || !newScope.globalfinder.searchResults.context) {
                    return;
                }
                newScope.globalfinder.aggregations = {
                    'help': {
                        doc_count: parseInt(newScope.globalfinder.searchInformation.totalResults, 10),
                        agg: {
                            buckets: (newScope.globalfinder.searchResults.context || {facets: []}).facets.map(facet => ({key: facet[0].label, doc_count: 0, label: facet[0].anchor}))
                        }
                    }
                };
            };

            newScope.isHelpTabSelected = _ => newScope.tabs.current.id === 'help';

            const nameMatch = (hit, query) => {
                if (!hit) {
                    return false;
                }
                if (hit._source.name) {
                    return hit._source.name.toLowerCase() === query.toLowerCase();
                }
                else if (hit._source.objectName) {
                    return hit._source.objectName.toLowerCase() === query.toLowerCase();
                }
                return false;
            };

            newScope.mergeResult = () => {
                const helpData = newScope.shouldTriggerHelpSearch() ? newScope.globalfinder.searchResults.hits : [];
                if (newScope.globalfinder.advancedSearch === true && newScope.isHelpTabSelected()) {
                    newScope.buildSearchAggregations();
                }
                const initialData = newScope.globalfinder.advancedSearch === true ? [] : [{_type: 'search', _source: {name: `Search ${newScope.globalfinder.q}`, query:newScope.globalfinder.q  }, icon: "global-finder-modal__search-type-icon icon-dku-search"}];
                const hits = newScope.hasFilter('help:') ? [] : newScope.globalfinder.hits.map(hit => {
                    if (hit.url && newScope.$stateParams.projectKey) {
                        hit.url = hit.url.replace(':projectKey:', newScope.$stateParams.projectKey);
                    }
                    return hit;
                });

                if (hits.length > 0 && nameMatch(hits[0], newScope.globalfinder.trimmedQuery)) {
                    newScope.globalfinder.results = hits.slice(0, 1).concat(initialData.concat(hits.slice(1).concat(helpData))).filter(el => el);
                } else {
                    newScope.globalfinder.results = initialData.concat(hits.concat(helpData)).filter(el => el);
                }
                newScope.globalfinder.results.forEach((val, index) => val.$idx = index);
                newScope.globalfinder.allData = [...newScope.globalfinder.results];
                newScope.globalfinder.searching = false;
            };

            newScope.buildResult = Debounce().withDelay(100, 100).wrap(newScope.mergeResult);

            newScope.clickItem = item => {
                if (item === null || item === undefined) {
                    return;
                }
                WT1.event("global-finder-item-open", {
                    type: item._type,
                    id: item._id || item.objectID,
                    currentTab: newScope.globalfinder.advancedSearch ? newScope.tabs.current.id : "",
                    filters: newScope.globalfinder.advancedSearch && newScope.hasAnyFilter() ? Array.from(newScope.globalfinder.q.matchAll(new RegExp(filterPattern, 'g')), x => x[0]) : []
                });
                if (item._type === 'search') {
                    newScope.globalfinder.advancedSearch = true;
                    newScope.globalfinder.q = item._source.query;

                    let isOldSearch = !!item._source.tabId;
                    if (isOldSearch) {
                        setCurrentTab(item._source.tabId);
                    }
                    newScope.triggerSearch(!isOldSearch);
                    newScope.updateLastSearches(newScope.globalfinder.q, newScope.tabs.current.id);
                    return;
                }
                if (newScope.simulateClick(item)) {
                    newScope.focusSearchInput(); // reset activeElement after a click
                }
            };

            newScope.openItem = item => {
                if (item && item.url) {
                    const aElem = document.querySelector(`.global-finder-modal__line a[href="${item.url}"]`);
                    if (aElem) {
                        $timeout(() => {
                            aElem.focus();
                            aElem.click();
                        });
                    }
                } else {
                    newScope.clickItem(item);
                }
            };

            newScope.simulateClick = item => {
                const itemURL = new URL(item.isHelp ? item.url : `${window.location.protocol}//${window.location.host}${item.url}`);
                // The redirect behavior is different if the user is already on the desired page
                if (window.location.pathname === itemURL.pathname) {
                    newScope.dismiss();
                    if (itemURL.hash) {
                        window.location.hash = itemURL.hash;
                        document.getElementById(itemURL.hash.substr(1)).scrollIntoView();
                    }
                    return false;
                }
                return true;
            };

            function disableAdvancedSearch() {
                newScope.globalfinder.advancedSearch = false;
            }

            newScope.tabs = {
                availables: [
                    {id: 'all', value: 'All', filtersPrefix: []},
                    {id: 'instance', value: `${newScope.wl.productShortName} Items`, filtersPrefix: ['type', 'user', 'tag', 'project']},
                    {id: 'navigation', value: 'Navigation', filtersPrefix: ['navigation']},
                    {id: 'help', value: 'Help topics', filtersPrefix: ['help']}
                ]
            };
            if (!newScope.helpIntegrationEnabled()) {
                newScope.tabs.availables.pop(); // Assuming help is the last tab
            }
            if (newScope.inProject && newScope.projectSummary) {
                newScope.tabs.availables.splice(1, 0, {id: 'project', value: newScope.projectSummary.name, filtersPrefix: ['type', 'user', 'tag']});
            }

            function setCurrentTab(currentTabId = undefined) {
                if (currentTabId !== undefined) {
                    const wantedTab = newScope.tabs.availables.find(t => t.id === currentTabId);
                    if (wantedTab !== undefined) {
                        newScope.enableTab(wantedTab);
                        return;
                    }
                }

                newScope.tabs.current = newScope.tabs.availables[0];
            }

            setCurrentTab(tabId);

            function shortcutTabAction(incr) {
                return e => {
                    if (!newScope.globalfinder.advancedSearch) {
                        return;
                    }
                    e.preventDefault();

                    // We want a positive result for a negative number
                    // Unfortunately, -1 % 4 = -1 in JS
                    function mod(n, m) {
                        return ((n % m) + m) % m;
                    }

                    const nextTab = newScope.tabs.availables[mod(newScope.tabs.availables.findIndex(tab => tab.id === newScope.tabs.current.id) + incr, newScope.tabs.availables.length)];
                    if (nextTab !== undefined) {
                        newScope.enableTab(nextTab);
                    }
                };
            }

            newScope.$on('selectedIndex', (event, index) => {
                if (!newScope.globalfinder.advancedSearch || index === -1) {
                    return;
                }
                newScope.$broadcast('scrollToLine', index);
            });

            newScope.selectItem = item => {
                if (item.selectable === false || item.$idx === newScope.selected.index) {
                    return;
                }
                newScope.selectIndex(item.$idx);
            };

            Mousetrap(document.querySelector(".global-finder-modal__search-input")).bind('tab', shortcutTabAction(1));
            Mousetrap(document.querySelector(".global-finder-modal__search-input")).bind('shift+tab', shortcutTabAction(-1));

            newScope.aggsCollapsing = {};

            const initialAggCollapsing = 7;
            const subsequentAggCollapsing = 50;
            newScope.getAggCollapsing = agg => {
                const aggId = agg._key;
                if (newScope.aggsCollapsing[aggId] === undefined) {
                    let result = initialAggCollapsing;
                    // If we are just 1 item away from the max, include it rather than displaying "+ 1 more".
                    if (result === agg.agg.buckets.length - 1) {
                        result++;
                    }
                    return result;
                } else {
                    return newScope.aggsCollapsing[aggId];
                }
            };
            // When user clicks on "+ X more", we first display up to 50 results, then each subsequent click doubles the number.
            newScope.setAggCollapsing = agg => {
                let result = newScope.getAggCollapsing(agg);
                result = result < subsequentAggCollapsing ? subsequentAggCollapsing : 2 * result;
                // If we are just 1 item away from the max, include it rather than displaying "+ 1 more".
                if (result === agg.agg.buckets.length - 1) {
                    result++;
                }
                newScope.aggsCollapsing[agg._key] = result;
            };
        });

        $scope.globalFinderModal.catch(() => {
            $scope.globalFinderModal = null
        });
    };

    $scope.isItemSelectable = item => item.selectable === undefined || item.selectable === true;
    $scope.isNavigation = item => item && item._type === 'page';

    $scope.itemToIcon = (item, inList) => {
        if (!item) {
            return;
        }
        if (item.isHelp) {
            return 'icon-dku-help';
        }
        if (item._type === 'page') {
            return 'icon-list'
        }
        return CatalogItemService.itemToIcon(item._type, item._source, inList);
    };

    $scope.itemToColor = item => {
        if (!item) {
            return;
        }
        if (item._type === 'page') {
            return 'navigation';
        }
        if (item.isHelp) {
            return 'home';
        }
        return CatalogItemService.itemToColor(item._type, item._source);
    };

    $scope.disableItemIcon = item => {
        if (item && item._source && item._source.closed) {
            return 'global-finder-modal__search-type-icon--disabled';
        }
    };

    $scope.getLink = (item, discussionId) => {
        if (!item || item.isHelp) {
            return;
        }
        if (item._type === 'page') {
            return item._source.url;
        }
        return CatalogItemService.getLink(item._type, item._source, discussionId);
    };
});


app.controller('RequestEETrialController', function ($scope, $state, Assert, DataikuAPI, DataikuCloudAPI, $rootScope) {
    Assert.inScope($scope, 'appConfig');
    Assert.trueish($scope.appConfig.licensing.community, 'not a free edition');
    $scope.request = {
        state : "initial"
    };

    $scope.request.updatedEmailAddress = $scope.appConfig.licensing.ceRegistrationEmail;

    $scope.sendRequest = function() {
        DataikuCloudAPI.community.requestEETrial(
                $scope.appConfig.licensing.ceInstanceId,
                $scope.request.updatedEmailAddress).success(function(data){

            $scope.trialRequestResponse = data;
            if (data.granted) {
                $scope.request.state = "granted";
            } else {
                $scope.request.state = "denied";
            }
        }).error(setErrorInScope.bind($scope));
    };
});


app.controller('RegisterController', function ($scope, $state, Assert, DataikuAPI, DataikuCloudAPI, $rootScope) {
    Assert.inScope($scope, 'appConfig');

    $scope.register = {
        state: 'welcome',
        wantEETrial: false,
        step: '1'
    };
    $scope.newAccount = {
        newsletter: true
    };
    $scope.existingAccount = {};
    $scope.existingKey = {};

    function fetchWebConfig() {
        DataikuCloudAPI.getWebConfig().then(function(id) {
            $scope.webVisitorId = id;
        });
         DataikuCloudAPI.getNewWebConfig().then(function(data) {
            $scope.webVisitorLocalId = data.visitor_id;
            $scope.webVisitorHSId = data.hs_id;
        });
    }
    fetchWebConfig();

    $scope.logMeIn = function() {
        window.location = '/';
    };

    $scope.switchStep = function(state, step) {
        $scope.register.state = state;
        $scope.register.step = step;
    }

    $scope.$watch("register.mode", function(nv, ov) {
        $scope.fatalAPIError = null;
    });

    function setCEThanks(data) {
        if (!data.trialRequestResponse) {
            $scope.register.state = "thanks-ce";
        } else if (data.trialRequestResponse.granted) {
            $scope.register.state = "thanks-ee-trial-granted";
        } else if (!data.trialRequestResponse.granted) {
            $scope.register.state = "thanks-ee-trial-denied";
        }
    }

    $scope.registerNewAccount = function() {
        Assert.trueish($rootScope.appConfig.saasManagerURL, 'Not a saas instance');

        DataikuCloudAPI.community.register(
            $scope.newAccount.firstName, $scope.newAccount.lastName,
            $scope.newAccount.company, $scope.newAccount.persona,
            $scope.newAccount.userEmail,
            $scope.newAccount.newsletter,
            $scope.register.wantEETrial,
            $rootScope.appConfig.version.product_version,
            $scope.webVisitorId, $scope.webVisitorLocalId, $scope.webVisitorHSId,
            $rootScope.appConfig.registrationChannel
        ).success(function(data) {
            /* Write the received license */
            DataikuAPI.registration.initialRegisterCommunity(
                $scope.newAccount.firstName, $scope.newAccount.lastName,
                $scope.newAccount.userEmail,
                data.instanceId, data.license).success(function(data2) {

                $scope.register.registrationResult = data;
                $scope.register.loginInfo = data2;
                if (data.trialRequestResponse && data.trialRequestResponse.granted) {
                    $scope.switchStep('enter-trial-license', 3);
                } else {
                    setCEThanks($scope.register.registrationResult);
                }
            }).error(setErrorInScope.bind($scope));
        }).error(setErrorInScope.bind($scope));
    };

    $scope.registerNoAccount = function () {
        Assert.trueish($rootScope.appConfig.saasManagerURL, 'not a saas instance');

        var firstName = "Unknown";
        var lastName = "Unknown";
        var company = "Unknown";
        var ts = new Date().getTime();
        var userEmail = $scope.webVisitorId + "-" + ts +  "@unknownvisitor.no";
        var password = "Unknown";

        DataikuCloudAPI.community.registerNewAccount(
            firstName, lastName,
            company, userEmail,
            password, 0,
            false,
            $rootScope.appConfig.version.product_version,
            $scope.webVisitorId, $scope.webVisitorLocalId, $scope.webVisitorHSId,
            $rootScope.appConfig.registrationChannel
        ).success(function(data) {
                /* Write the received license */
                DataikuAPI.registration.initialRegisterCommunity(
                    $scope.newAccount.firstName, $scope.newAccount.lastName,
                    $scope.newAccount.userEmail,
                    data.instanceId, data.license).success(function(data2) {

                        $scope.register.registrationResult = data;
                        $scope.register.loginInfo = data2;
                        setCEThanks(data);

                    }).error(setErrorInScope.bind($scope));
            }).error(setErrorInScope.bind($scope));
    };

    $scope.registerExistingAccount = function() {
        Assert.trueish($rootScope.appConfig.saasManagerURL, 'not a saas instance');

        DataikuCloudAPI.community.registerExistingAccount(
            $scope.existingAccount.userEmail,
            $scope.existingAccount.password,
            $scope.register.wantEETrial,
            $rootScope.appConfig.version.product_version,
            $scope.webVisitorId, $scope.webVisitorLocalId, $scope.webVisitorHSId,
            $rootScope.appConfig.registrationChannel
        ).success(function(data) {
            DataikuAPI.registration.initialRegisterCommunity(
                data.firstName, data.lastName,
                $scope.existingAccount.userEmail,
                data.instanceId, data.license).success(function(data2) {

                $scope.register.registrationResult = data;
                $scope.register.loginInfo = data2;
                setCEThanks(data);

            }).error(setErrorInScope.bind($scope));
        }).error(setErrorInScope.bind($scope));
    };

    $scope.setLicense = function() {
        DataikuAPI.registration.initialRegisterLicensed($scope.existingKey.license).success(function(data) {
            $scope.register.loginInfo = data;
            $scope.register.state = "thanks-license";
        }).error(setErrorInScope.bind($scope));
    };
});


app.controller('RenewLicenseController', function($scope, $state, Assert, DataikuAPI, DataikuCloudAPI, $rootScope) {
    Assert.inScope($scope, 'appConfig');
    $scope.existingKey = {}

    $scope.logMeIn = function(){
        window.location = '/';
    };

    $scope.setLicense = function() {
        DataikuAPI.registration.renewExpiredLicense($scope.existingKey.license).success(function(data) {
            $scope.registrationSuccessful = {}
        }).error(setErrorInScope.bind($scope));
    };
});

app.constant("HomeBehavior", { LAST: 'last', DEFAULT: 'home', PROJECTS: 'project-list' });

app.controller("FeedbackController", function($scope, WT1){
    $scope.feedbackContent = {
        comment: '',
        email: $scope.appConfig.user && $scope.appConfig.user.email ? $scope.appConfig.user.email : ''
    }
    $scope.finished = false;

    $scope.sendFeedback = function() {
        $scope.finished = true;
        WT1.event("dss-feedback", $scope.feedbackContent);
    }
});

app.controller('LoginController', function($scope, $state, $location, DataikuAPI, TopNav, LoggerProvider) {

    const Logger = LoggerProvider.getLogger('LoginController');

    TopNav.setLocation(TopNav.LOGIN, "login");

    var lic = $scope.appConfig.licensing;
    $scope.communityLook = lic.community && !lic.ceEntrepriseTrial;
    if (lic.ceEntrepriseTrialUntil > Date.now()) {
        $scope.daysLeft = Math.floor((lic.ceEntrepriseTrialUntil - Date.now()) / (24 * 3600 * 1000));
    }

    $scope.submit = function() {
        var formLogin = $("input[name=login]").val(),
            formPassword = $("input[name=password]").val();

        $scope.loginFailed = false;
        $scope.loginErrorMessage = '';
        DataikuAPI.login(formLogin, formPassword).success(function(data) {
            const redirectTo = $state.params.redirectTo;
            if (redirectTo) {
                Logger.info("GO " + redirectTo);
                // ui-router does not seem to manage changes of $location.url ... It just does not do anything
                // And since I have a URL, I can't use transitionTo
                // SO I have to reload. It sucks
                const url = new URL(window.location.href);
                url.search = '';            // Remove ?redirectTo
                url.pathname = redirectTo;  // Only follow redirects to a local path, not to another site
                window.location = url.href;
            } else {
                // I also do it here to ensure that we reload appConfig
                window.location = "/";
            }
        }).error(function(data, status, headers) {
            $scope.loginFailed = true;
            if (data.errorType) {
                $scope.loginError = getErrorDetails(data, status, headers)
            } else {
                $scope.loginErrorMessage = data;
            }
        });
    };


    if ($scope.appConfig.loggedIn && !$scope.appConfig.noLoginMode) {
        // it's confusing to leave people on a blank login screen when they are actually logged in
        $scope.redirectHome();
    }

});


app.controller('OAuth2ResponseController', function($scope, $state, $location, ActivityIndicator) {
    const userState = $state.params.userState;
    const success = $state.params.success;

    if (success === "true") {
        ActivityIndicator.success("OAuth2 credential obtained", 5000);
    } else {
        const message = $state.params.message;
        ActivityIndicator.error("Could not obtain OAuth2 credential: " + message, 10000);
    }

    if (userState) {
        $state.transitionTo(userState);
    } else {
        // Should only happen if the response comes back from the auth server and we don't recognize it
        $state.transitionTo("home")
    }
});


app.controller('NewTutorialProjectController', function($scope, Assert, DataikuAPI, $state, WT1, CreateModalFromTemplate) {
    function updateDisplay(){
        if (!$scope.tutorialsList) return;

        $scope.availableSections =[];
        $scope.availableTutorials ={};
        $scope.tutorialsList.items.forEach(function(x){
            if ( x.archiveType != 'FETCH' ) {
                // get the image from the backend for builtin tutorials. Remote tutorials have
                // to provide the image themselves, so we can use their imageURL directly
                x.imageURL = '/dip/api/image/get-tutorial-thumbnail?tutorialId=' + x.id;
            }
            if (x.type == $scope.uiState.currentType) {
                if ($scope.availableSections.indexOf(x.sectionName) < 0) {
                    $scope.availableSections.push(x.sectionName);
                    $scope.availableTutorials[x.sectionName] = [];
                }
                $scope.availableTutorials[x.sectionName].push(x);
            }
        });
        $scope.uiState.currentSection = $scope.availableSections[0]
    }

    DataikuAPI.projects.listTutorials().success(function(data){
        $scope.tutorialsList = data;
        updateDisplay();
    }).error(setErrorInScope.bind($scope));

    $scope.$watch("uiState.currentType", updateDisplay);

    $scope.start = function(id) {
        Assert.trueish(id, 'No tutorial id');

        // note to self: pass the parent scope of this modal's scope as the download modal's scope's parent, since
        // we're going to dismiss this modal right now (and if the download modal was using this scope, then it would be
        // created non functional...)
        CreateModalFromTemplate("/templates/projects/tutorial-download.html", $scope.attachDownloadTo, null, function(newScope) {
            newScope.tutorialIdToInstall = id;
            newScope.tutorialType = $scope.uiState.currentType;
        });

        $scope.dismiss();
    };
});


app.controller('TutorialDownloadController', function($scope, DataikuAPI, MonoFuture, Fn, WT1, $state, ProjectFolderContext) {
    $scope.state = "NOT_STARTED";

    function go(){
        MonoFuture($scope).wrap(DataikuAPI.projects.createTutorial)($scope.tutorialIdToInstall, $scope.tutorialType, ProjectFolderContext.getCurrentProjectFolderId()).success(function(data) {
            $scope.state = data.result.success ? "DONE" : "FAILED";
            $scope.stateShown = null;
            if (!data.result.success) {
                $scope.failure = {
                    message : data.result.installationError.detailedMessage
                }
                WT1.event("tutorial-project-creation-failed", {tutorialId : $scope.tutorialIdToInstall});
            } else {
                $scope.needsGoingToTutorial = true;
                $scope.projectKey = data.result.projectKey;
                WT1.event("tutorial-project-created", {tutorialId : $scope.tutorialIdToInstall});
            }

            $scope.installingFuture = null;
        }).update(function(data) {
            $scope.stateShown = data.progress != null && data.progress.states != null && data.progress.states.length > 0 ?
                                                                    data.progress.states[data.progress.states.length - 1] : null;
            $scope.state = "RUNNING";
            $scope.installingFuture = data;
        }).error(function (data, status, headers) {
            $scope.state = "FAILED";
            if ( data.aborted) {
                $scope.failure = {
                        message : "Aborted"
                }
            } else if (data.hasResult) {
                $scope.failure = {
                        message : data.result.errorMessage
                }
            } else {
                $scope.failure = {
                        message : "Unexpected error"
                }
            }
            $scope.installingFuture = null;
        });
    }

    $scope.abort = function() {
        $scope.state = "FAILED";
        $scope.failure = {
            message : "Aborted"
        }
        DataikuAPI.futures.abort($scope.installingFuture.jobId);
    };

    $scope.closeAndGo = function(){
        $scope.dismiss();
        $state.go("projects.project.home.regular", {projectKey : $scope.projectKey})
    }

    $scope.$on("$destroy", function(){
        if ($scope.state == "RUNNING") {
            $scope.abort();
        }
    });

    /* Wait for the plugin id to start */
    $scope.$watch("tutorialIdToInstall", Fn.doIfNv(go));
});


app.controller('NewProjectController', function($scope, DataikuAPI, $state, $stateParams, WT1, ProjectFolderContext) {
    $scope.modalTabState = { active: "create" };
    $scope.newProject = {};
    $scope.uniq = true;

    DataikuAPI.projects.listAllKeys()
        .success(function(data) { $scope.allProjectKeys = data; })
        .error(setErrorInScope.bind($scope));

    function isProjectKeyUnique(value) {
        return !$scope.allProjectKeys || $scope.allProjectKeys.indexOf(value) < 0;
    };

    $scope.$watch("newProject.projectKey", function(nv, ov) {
        $scope.uniq = !nv || isProjectKeyUnique(nv);
    });

    $scope.$watch("newProject.name", function(nv, ov) {
        if (!nv) return;
        var slug = nv.toUpperCase().replace(/\W+/g, ""),
            cur = slug,
            i = 0;
        while (!isProjectKeyUnique(cur)) {
            cur = slug + "_" + (++i);
        }
        $scope.newProject.projectKey = cur;
    });

    $scope.create = function() {
        DataikuAPI.projects.create($scope.newProject.projectKey, $scope.newProject.name, ProjectFolderContext.getCurrentProjectFolderId())
            .success(function(data) {
                $scope.dismiss();
                $state.transitionTo("projects.project.home.regular", {projectKey : $scope.newProject.projectKey});
            }).error(setErrorInScope.bind($scope));
        WT1.event("project-create");
    };
});


// Re-render dku-bs-select every time the source connection to update connection sorting
app.directive("importProjectRemappingForm", function() {
    return {
        scope: false,
        link: function($scope, $elt) {
            $scope.$watch("conn.source", function(nv) {
                if (!nv) return;
                $elt.find('select[dku-bs-select]').selectpicker('refresh');
            })
            $scope.$watch("codeEnv.source", function(nv) {
                if (!nv) return;
                $elt.find('select[dku-bs-select]').selectpicker('refresh');
            })
        }
    }
});


app.controller('ImportProjectController', function($scope, Assert, DataikuAPI, $state,
               FutureWatcher, ProgressStackMessageBuilder, CreateModalFromTemplate, Dialogs, $timeout, Fn, WT1, ProjectFolderContext) {
    // get the list, don't get it from the home (in case the call to populate the home is too slow)
    DataikuAPI.projects.listAllKeys()
    .success(function(data) { $scope.allProjectKeys = data; })
    .error(setErrorInScope.bind($scope));

    $scope.importData = {}
    $scope.importSettings = {
        remapping : {
            connections : []
        },
        targetProjectFolderId: ProjectFolderContext.getCurrentProjectFolderId()
    };

    $scope.phase = "READY_TO_UPLOAD";
    $scope.prepare = {enabled: false};

    $scope.selectFilter = function(selected) {
        return function(connection) {
            return !connection.mapped || connection.name == selected;
        }
    };

    $scope.updateSelect = function(e) {
        // Nothing to do
    };

    $scope.connComparator = function(sourceCon) {
        var
            source = $scope.findConnection(
            $scope.prepareResponse.usedConnections, sourceCon);
        var sourceType = source && source.type;
        return function(connection) {
            if (connection.type == sourceType) {
                return "AAAAA" + connection.type + "." + connection.name;
            } else {
                return "ZZZZZ" + connection.type + "." + connection.name;
            }
        };
    };

    $scope.codeEnvComparator = function(sourceCodeEnv) {
        var
            source = $scope.findCodeEnv(
            $scope.prepareResponse.usedCodeEnvs, sourceCodeEnv);
        var sourceEnvLang = source && source.envLang;
        return function(codeEnv) {
            if (codeEnv.envLang == sourceEnvLang) {
                return "AAAAA" + codeEnv.envLang + "." + codeEnv.name;
            } else {
                return "ZZZZZ" + codeEnv.envLang + "." + codeEnv.name;
            }
        };
    };

    $scope.findConnection = function(connections, connection) {
        return Array.dkuFindFn(connections, function(c) { return c.name == connection });
    };

    $scope.findCodeEnv = function(codeEnvs, codeEnvName) {
        return Array.dkuFindFn(codeEnvs, function(c) { return c.envName == codeEnvName });
    };

    var abortHook = null;
    $scope.attemptImport = function(){
        Assert.trueish($scope.phase == "READY_TO_IMPORT", 'not ready to import');
        Assert.trueish($scope.uploadResult.id, 'no upload id');

        $scope.phase = "IMPORTING";

        resetErrorInScope($scope);
        DataikuAPI.projects.startImport($scope.uploadResult.id, $scope.importSettings).success(function(initialResponse){
            abortHook = function() {
                DataikuAPI.futures.abort(initialResponse.jobId).error(setErrorInScope.bind($scope));
            };
            FutureWatcher.watchJobId(initialResponse.jobId)
                .success(function(data) {
                    abortHook = null;
                    $scope.futureResponse = null;
                    $scope.importResponse = data.result;
                    if ($scope.importResponse && $scope.importResponse.success){
                        var p2 = $scope.$parent.$parent;
                        $scope.dismiss();
                        Dialogs.infoMessagesDisplayOnly(p2, "Import report", $scope.importResponse).then(function(){
                            $state.transitionTo("projects.project.home.regular", {projectKey : $scope.importResponse.usedProjectKey});
                        });
                    } else {
                        $scope.phase = "READY_TO_IMPORT";

                        // fetch the new manifest in case the migration added some stuff
                        $scope.prepare.enabled = true;
                        prepareImport();
                    }

                }).update(function(data){
                    $scope.percentage =  ProgressStackMessageBuilder.getPercentage(data.progress);
                    $scope.futureResponse = data;
                    $scope.stateLabels = ProgressStackMessageBuilder.build($scope.futureResponse.progress, true);
                }).error(function(data, status, headers) {
                    abortHook = null;
                    $scope.futureResponse = null;
                    $scope.importResponse = null;
                    $scope.phase = "READY_TO_IMPORT";
                    setErrorInScope.bind($scope)(data, status, headers);
                    $timeout(checkProjectKey);
                });
        }).error(function(a,b,c){
            $scope.phase = 'READY_TO_IMPORT';
            setErrorInScope.bind($scope)(a,b,c);
            $scope.importResponse = null;
            $timeout(checkProjectKey);
        });
        WT1.event("project-import",{
            displayAdvancedOptions : $scope.prepare.enabled,
            nbRemappings : $scope.importSettings.remapping ? $scope.importSettings.remapping.connections ? $scope.importSettings.remapping.connections.length : 0 : 0
        });
    }

    $scope.$on("$destroy", function() {
        // cancel import if modal dismissed
        if (abortHook) abortHook();
    });

    $scope.startImport = function(){

        $scope.phase = "UPLOADING";

        DataikuAPI.projects.uploadForImport($scope.importData.file, function(e){
            if (e.lengthComputable) {
                $scope.$apply(function () {
                    $scope.uploadProgress = Math.round(e.loaded * 100 / e.total);
                });
            }
        }).then(function (data) {
            $scope.uploadResult = JSON.parse(data);
            prepareImport();

        }).catch((error) => {
            $scope.phase = '';
            setErrorInScope2.call($scope, error);
        });
    };

    function prepareImport() {
        DataikuAPI.projects.prepareImport($scope.uploadResult.id, $scope.importSettings)
            .success(function(data) {
                $scope.prepareResponse = data;

                $scope.usedConnections = data.usedConnections.map(Fn.prop('name'));
                $scope.usedCodeEnvs = data.usedCodeEnvs.map(Fn.prop('envName'));
                $scope.availableCodeEnvs = [{envLang:'PYTHON', envName:'Builtin', builtin:true}, {envLang:'R', envName:'Builtin', builtin:true}].concat($scope.prepareResponse.availableCodeEnvs);
                $scope.$watch("importSettings.targetProjectKey", checkProjectKey);

                $scope.phase = "READY_TO_IMPORT";
                if (!$scope.prepare.enabled) $scope.attemptImport();
            }).error(setErrorInScope.bind($scope));
    }

    $scope.refreshConnections = function() {
        $scope.prepare.enabled = true;
        prepareImport();
    };

    $scope.refreshCodeEnvs = function() {
        $scope.prepare.enabled = true;
        prepareImport();
    };

    function checkProjectKey(nv) {
        if ($scope.phase != "READY_TO_IMPORT") return;

        var unique;
        if(!$scope.importSettings.targetProjectKey) {
            unique = $scope.allProjectKeys.indexOf($scope.prepareResponse.originalProjectKey) == -1;
        } else {
            unique = $scope.allProjectKeys.indexOf($scope.importSettings.targetProjectKey.toUpperCase().replace(/\W+/g, "")) == -1;
        }
        $scope.importProjectForm.projectKey.$dirty = true;
        $scope.importProjectForm.projectKey.$setValidity("unique", unique);
    }
});

app.controller('DuplicateProjectController', function($scope, DataikuAPI, FutureWatcher, ProgressStackMessageBuilder, WT1, $state, ProjectFolderContext, PromiseService, $q, $window) {
    $scope.hasPartitionedDataset = false;
    $scope.uniq = true;
    $scope.dupProject = {
        projectKey: "COPY_OF_" + $scope.projectSummary.projectKey,
        name: "Copy of " + $scope.projectSummary.name
    };
    $scope.dupOptions = {
        exportAnalysisModels: true,
        exportSavedModels: true,
        exportGitRepository: true,
        exportInsightsData: true,
        duplicationMode: 'UPLOADS_ONLY',
        exportUploads: true,
        exportAllInputDatasets: true,
        exportAllInputManagedFolders: true,
        exportAllDatasets: false,
        exportManagedFolders: false,
        targetProjectFolderId: ProjectFolderContext.getCurrentProjectFolderId(),
    };
    $scope.phase = 'READY_TO_DUPLICATE';

    DataikuAPI.projects.listAllKeys()
        .success(function(data) {
            $scope.allProjectKeys = data;
            $scope.$watch("dupProject.name", function(nv, ov) {
                if (!nv) return;
                var slug = nv.toUpperCase().replace(/\W+/g, ""),
                    cur = slug,
                    i = 0;
                while (!isProjectKeyUnique(cur)) {
                    cur = slug + "_" + (++i);
                }
                $scope.dupProject.projectKey = cur;
            });
        })
        .error(setErrorInScope.bind($scope));

    DataikuAPI.projectFolders.listContents($scope.dupOptions.targetProjectFolderId === null ? '' : $scope.dupOptions.targetProjectFolderId, true, 1, true).success(data => {
        const pathElts = treeToList(data.folder, item => item.parent);
        $scope.dupFolder = angular.extend({}, data.folder, { pathElts: pathElts.map(f => f.name).join('/') });
    }).error(setErrorInScope.bind($scope));

    function isProjectKeyUnique(value) {
        return !$scope.allProjectKeys || $scope.allProjectKeys.indexOf(value) < 0;
    }

    $scope.uniq = isProjectKeyUnique($scope.dupProject.projectKey);

    $scope.$watch("dupProject.projectKey", function(nv, ov) {
        $scope.uniq = !nv || isProjectKeyUnique(nv);
    });

    $scope.connComparator = function(sourceCon) {
        var
            source = $scope.findConnection(
            $scope.prepareResponse.usedConnections, sourceCon);
        var sourceType = source && source.type;
        return function(connection) {
            /**
             * Returns the order in which the available connections will be displayed in the selector
             * - high up in the list if the connection types are compatible (so starting with "AAAAA")
             * - last in the list if they are not (starting with "ZZZZZ")
             */
            if (connection.type == sourceType) {
                return "AAAAA" + connection.type + "." + connection.name;
            } else {
                return "ZZZZZ" + connection.type + "." + connection.name;
            }
        };
    };

    $scope.findConnection = function(connections, connection) {
        return Array.dkuFindFn(connections, function(c) { return c.name == connection });
    };

    $scope.refreshConnections = function(projectKey) {
        DataikuAPI.projects.getProjectDatasets(
            projectKey
        ).then(function(initialResponse){
            $scope.prepareResponse = $scope.prepareResponse ? $scope.prepareResponse : {};
            $scope.prepareResponse.usedConnections = [];
            $scope.usedConnections = [];
            for (let requiredConnection in initialResponse.data.requiredConnections) {
                $scope.prepareResponse.usedConnections.push(initialResponse.data.requiredConnections[requiredConnection]);
                $scope.usedConnections.push(initialResponse.data.requiredConnections[requiredConnection].name);
            }
            $scope.hasPartitionedDataset = initialResponse.data.hasPartitionedDataset;
        });

        DataikuAPI.projects.prepareImport('', '')
            .then(function(response) {
                $scope.prepareResponse = $scope.prepareResponse ? $scope.prepareResponse : {};
                $scope.prepareResponse.availableConnections = [];
                response.data.availableConnections.forEach(function(availableConnection){
                    $scope.prepareResponse.availableConnections.push(availableConnection);
                });
            })
    };

    $scope.setDuplicationMode = function(mode) {
        $scope.dupOptions.duplicationMode = mode;
    };

    var abortHook = null;

    $scope.gotoResult = function() {
        $scope.dismiss();
        $window.location.assign($state.$current.url.sourcePath.replace(":projectKey",$scope.dupProject.projectKey));
    };

    $scope.duplicate = function() {
        $scope.phase = 'DUPLICATING';
        $scope.dupOptions.targetProjectKey = $scope.dupProject.projectKey;
        $scope.dupOptions.targetProjectName = $scope.dupProject.name;
        DataikuAPI.projects.startProjectDuplication(
            $scope.projectSummary.projectKey,
            $scope.dupOptions
        ).success(function(initialResponse){
            abortHook = function() {
                DataikuAPI.futures.abort(initialResponse.jobId).error(setErrorInScope.bind($scope));
            };
            FutureWatcher.watchJobId(initialResponse.jobId).success(function(data){
                abortHook = null;
                $scope.futureResponse = null;
                $scope.duplicateResponse = data.result;
                if (!data.aborted && (data.result.success || data.result.messages == null || data.result.messages.length == 0)) {
                	$scope.gotoResult();
                } else if ((data.result.warning || data.result.error) && !data.result.fatal) {
                	$scope.phase = "SHOW_WARNINGS";
                } else {
                    $scope.phase = "READY_TO_DUPLICATE";
                }
            }).update(function(data){
                $scope.percentage = ProgressStackMessageBuilder.getPercentage(data.progress);
                $scope.futureResponse = data;
                $scope.stateLabels = ProgressStackMessageBuilder.build($scope.futureResponse.progress, true);
            }).error(function(data, status, headers) {
                abortHook = null;
                $scope.futureResponse = null;
                $scope.duplicateResponse = null;
                $scope.phase = "READY_TO_DUPLICATE";
                setErrorInScope.bind($scope)(data, status, headers);
            })
        }).error(function(a,b,c){
            $scope.phase = 'READY_TO_DUPLICATE';
            setErrorInScope.bind($scope)(a,b,c);
            $scope.duplicateResponse = null;
        });
        WT1.event("project-duplicate", {
            duplicationMode: $scope.dupOptions.duplicationMode,
            exportAnalysisModels: $scope.dupOptions.exportAnalysisModels,
            exportSavedModels: $scope.dupOptions.exportSavedModels,
            exportModelEvaluationStores: $scope.dupOptions.exportModelEvaluationStores,
            exportGitRepository: $scope.dupOptions.exportGitRepository,
            exportInsightsData: $scope.dupOptions.exportInsightsData,
            nbRemappings: $scope.dupOptions.remapping ? $scope.dupOptions.remapping.connections ? $scope.dupOptions.remapping.connections.length : 0 : 0
        });
    };

    $scope.$on("$destroy", function() {
        // cancel import if modal dismissed
        if (abortHook) abortHook();
    });

    $scope.refreshConnections($scope.projectSummary.projectKey);
    $scope.$watch("conn.source", function(nv) {
        if (!nv) return;
        $elt.find('select[dku-bs-select]').selectpicker('refresh');
    });

    $scope.browse = folderIds =>  {
        return PromiseService.qToHttp($q(resolve => {
            const ids = folderIds.split('/');
            $scope.destination = ids[ids.length - 1];
            DataikuAPI.projectFolders.listContents($scope.destination, true, 1, true).success(data => {
                const folders = data.folder.children.map(f => angular.extend({}, f, { directory: true, fullPath: f.id }))
                const pathElts = treeToList(data.folder, item => item.parent);

                resolve({
                    children: folders,
                    pathElts: pathElts.map(f => angular.extend({}, f, { toString: () => f.id })),
                    exists: true,
                    directory: true,
                });
            }).error(setErrorInScope.bind($scope));
        }));
    };

    $scope.canSelect = item => item.canWriteContents;

    $scope.getProjectFolderName = item => item.name;
});

app.controller('DebuggingToolsController', function($scope, DataikuAPI, $state, $stateParams) {
    $scope.$state = $state;
    $scope.uiState = {};
    $scope.fakeFutureTypes = [];
    $scope.fakeFutureTypes.push({"name":"export from dataset", "payloadClassName":"com.dataiku.dip.export.LocalExportFutureThread", "payloadMethodName":"buildFuturePayload"});
    $scope.fakeFutureTypes.push({"name":"sql query in notebook", "payloadClassName":"com.dataiku.dip.server.services.SQLNotebooksService", "payloadMethodName":"buildFuturePayload"});
    $scope.fakeFutureTypes.push({"name":"sample building", "payloadClassName":"com.dataiku.dip.shaker.SampleBuilder", "payloadMethodName":"buildFuturePayload"});
    $scope.killBackend = function(){
        DataikuAPI.internal.debugKillBackend();
    }
    $scope.getBackendStacks = function(){
        DataikuAPI.internal.debugGetBackendStacks().success(function(data){
            $scope.retdata = data;
        })
    }
    $scope.restartAllHTMLBackends = function(){
        DataikuAPI.internal.restartAllHTMLBackends().success(function(data){
            $scope.retdata = data;
        })
    }
    $scope.runScenarioTriggers = function(){
        DataikuAPI.internal.runScenarioTriggers().success(function(data){
            $scope.retdata = data;
        })
    }
    $scope.insertFakeFuture = function(){
        var f = $scope.uiState.fakeFutureType;
        DataikuAPI.internal.fakeFuture($stateParams.projectKey, f.payloadClassName, f.payloadMethodName, false).success(function(data){
            $scope.retdata = data;
            $scope.uiState.fakeFutureType = null;
        })
    }
    $scope.getTriggerQueueingInfo = function(){
        DataikuAPI.internal.getTriggerQueueingInfo().success(function(data){
            $scope.retdata = data;
        })
    }
    $scope.resyncProjectFolders = () => {
        DataikuAPI.internal.resyncProjectFolders();
    };
    $scope.clearScenarioReportsCaches = function () {
        DataikuAPI.internal.clearScenarioReportsCaches();
    }
});

app.controller("NameFolderCommonController", $scope => {
    $scope.isNameValid = (nameFormInput, isPristineOk) => {
        if (!nameFormInput) {
            return false;
        }
        const name = nameFormInput.$viewValue;
        const isPristine = nameFormInput.$pristine;
        const hasName = name && name.length > 0;
        return (isPristineOk && isPristine) || hasName;
    };
});

app.directive("dkuShow", function($timeout) {
    return {
        scope: false,
        link: function(scope, elem, attrs) {
            let showTimer;
            let delay = parseInt(attrs.delay);
            delay = angular.isNumber(delay) ? delay : 200;

            scope.$watch(attrs.dkuShow, newVal => {
              newVal ? showSpinner() : hideSpinner();
            });

            const showSpinner = () => {
              if (showTimer) {
                  return;
              }
              showTimer = $timeout(showElement.bind(this, true), delay);
            }

            const hideSpinner = () =>  {
              if (showTimer) {
                $timeout.cancel(showTimer);
              }
              showTimer = null;
              showElement(false);
            }

            const showElement = (show) => {
              show ? elem.css({display:''}) : elem.css({display:'none'});
            }
        }
    }
});

}());

(function() {
'use strict';

const app = angular.module('dataiku.services', []);

// Mapping DOMRect to Object for better usability
function getBoundingClientRect(element) {
    const rect = element.getBoundingClientRect();
    return {
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        left: rect.left,
        width: rect.width,
        height: rect.height,
        x: rect.x,
        y: rect.y
    };
}

app.factory("DKUConstants", function($rootScope) {
    const cst = {
        ARCHIVED_PROJECT_STATUS: "Archived",
        design: {
            alertClasses: {
                SUCCESS: 'alert-success',
                FATAL: 'alert-danger',
                ERROR: 'alert-danger',
                WARNING: 'alert-warning',
                INFO: 'alert-info'
            }
        }
    };
    $rootScope.DKUConstants = cst;

    return cst;
});


app.service('AppConfig', function() {
    let config;
    this.set = function(cfg) {
        logger.info('Set appConfig')
        config = cfg;
    };
    this.get = function() {
        return config;
    }
});

app.service('FeatureFlagsService', function($rootScope) {
    this.featureFlagEnabled = function(flagName) {
        return $rootScope.appConfig && $rootScope.appConfig.featureFlags.includes(flagName);
    };

    // put in rootScope for easy use in templates
    $rootScope.featureFlagEnabled = this.featureFlagEnabled;
});

app.service('uiCustomizationService', ['$rootScope', 'DataikuAPI', '$q', function($rootScope, DataikuAPI, $q) {
    const datasetTypeStatus = { HIDE: 'HIDE', SHOW: 'SHOW', NO_CONNECTION: 'NO_CONNECTION'};
    const computeDatasetTypeStatusCache = {}; // this is project-dependant, we cache for each project

    this.datasetTypeStatus = datasetTypeStatus;

    // returns a promise resolving into a function (type) => datasetTypeStatus
    this.getComputeDatasetTypesStatus = (scope, projectKey) => {
        if(! computeDatasetTypeStatusCache[projectKey]) {
            const deferred = $q.defer();
            DataikuAPI.datasets.listCreatableDatasetTypes(projectKey).success((datasetTypes) => {
                const uiCustomization = $rootScope.appConfig.uiCustomization; // just a shortcut

                deferred.resolve((type) => {
                    const typeIsIn = (array) => array.indexOf(type) !== -1;

                    // Hive is always hidden if showTraditionalHadoop is unchecked
                    if(!uiCustomization.showTraditionalHadoop && type === 'hiveserver2') {
                        return datasetTypeStatus.HIDE;
                    }

                    if(uiCustomization.hideDatasetTypes && uiCustomization.hideDatasetTypes.length !== 0) {
                        // we hide datasets that are blackListed except if they are allowed by personal connections
                        const isBlackListed = typeIsIn(uiCustomization.hideDatasetTypes);
                        const fromPersonalConnections = typeIsIn(datasetTypes.fromPersonalConnections);
                        if(isBlackListed && !fromPersonalConnections) {
                            return datasetTypeStatus.HIDE;
                        }
                    }

                    if(! uiCustomization.showDatasetTypesForWhichThereIsNoConnection) {
                        // we hide / disable dataset that have no adequate connection available
                        let hasConnection = typeIsIn(datasetTypes.fromAllConnections) || typeIsIn(datasetTypes.outsideOfConnections);

                        // if user is admin we consider all connections are available since he could create them
                        if($rootScope.isDSSAdmin()) {
                            hasConnection = true;
                        }
                        // if user can create personal connections, we consider all connections except Filesystem and hiveserver2 are available since he could create them
                        if($rootScope.appConfig.globalPermissions.mayCreateAuthenticatedConnections && type !== 'Filesystem' && type !== 'hiveserver2') {
                            hasConnection = true;
                        }

                        if(!hasConnection) {
                            return datasetTypeStatus.NO_CONNECTION;
                        }

                    }

                    return datasetTypeStatus.SHOW;
                });
            }).error(setErrorInScope.bind(scope))
            .catch(() => {
                // In case of API error, we resolve the promise with a filter that will show every dataset type
                // not ideal, but better than showing nothing
                deferred.resolve(() => datasetTypeStatus.SHOW);
            });
            computeDatasetTypeStatusCache[projectKey] = deferred.promise;
        }
        return computeDatasetTypeStatusCache[projectKey];
    }
}]);

    /**
     * ActiveProjectKey is intended to replace explicit references to $stateParams.projectKey references
     * that litter the current code base.  These references make it impossible to use many directives outside
     * of an opened project.
     * The service get() method will return $stateParams.projectKey whenever possible, but when this is not
     * defined it will return a value previously saved via the set() method.
     */
    app.service('ActiveProjectKey', function($stateParams) {
    let explicitProjectKey;
    this.set = function(projectKey) {
        explicitProjectKey = projectKey;
    };
    this.get = function() {
        let key = $stateParams.projectKey;
        if (typeof(key) === 'undefined') key = explicitProjectKey;
        return key;
    }
});

app.factory("TableChangePropagator", function() {
    var svc = {seqId: 0};
    svc.update = function() {
        svc.seqId++;
    };
    return svc;
});

app.factory("executeWithInstantDigest", function($timeout) {
    return function executeWithInstantDigest(fn, scope) {
        $timeout(function(){
            scope.$apply(fn);
        });
    }
});




app.factory("textSize", function() {
    // if text is a string returns its length
    // if text is a list of texts returns the maximum width.
    // if container is not undefined, append it to container
    // element will be added and then remove before any repaint.
    return function(texts, tagName, className, container) {
        if (texts.length === undefined) {
            texts = [texts];
        }
        if (className === undefined) {
            className = "";
        }
        className += " text-sizer";
        if (container === undefined) {
            container = $("body");
        }
        else {
            container = $(container);
        }
        var maxWidth = 0;
        var elements = [];
        for (var i = 0; i < texts.length; i++) {
            var text = texts[i];
            var el = document.createElement(tagName);
            el.className = className;
            var $el = $(el);
            $el.text(text);
            container.append($el);
            elements.push($el);
        }
        ;
        for (var i = 0; i < elements.length; i++) {
            var $el = elements[i];
            maxWidth = Math.max(maxWidth, $el.width());
            $el.remove();
        }
        ;
        return maxWidth;
    }
});


app.factory("CollectionFiltering", function(Fn) {
    // service to filter collection with complex filters
    // i.e. magic around $filter('filter')

    // usage : CollectionFiltering.filter([obj,obj,obj], filterQuery, params)

    // filterQuery is an object that's matched against objects from the list
    // JS objects : {} means a logical AND
    // JS arrays : [] means a logical OR
    // string/Regex properties are then matched against each others with a substr logic

    // ** Parameters **
    // * filterQuery.userQuery : special str property that's matched against all properties of the object
    //    with an OR behaviour.
    // * property:value strings are extracted from filterQuery.userQuery and added to the filterQuery object
    // * params.userQueryTargets : single (or list of) dotted property paths to restrict the match of userQuery
    // * params.propertyRules : if you want to give the user shortcuts for properties (replace dict)

    // params are enriched with :
    // * params.userQueryResult : a list of Regex+str that where used in the matching (for highlight in list)
    // * params.userQueryErrors : a dict : {str:errMessage} that occurred during parsing

    var matchString = function(query, obj, exactMatch) {
        if (query instanceof RegExp) {
            return query.test(obj);
        } else {
            return !exactMatch ? ('' + obj).toLowerCase().indexOf(query) > -1 : ('' + obj).toLowerCase() === query;
        }
    }

    var filterFilterAllProperties = function(qQuery, obj) {
        if ($.isArray(obj)) {
            for (var i in obj) {
                if (filterFilterAllProperties(qQuery, obj[i])) {
                    return true;
                }
            }
            return false;
        } else if ($.isPlainObject(obj)) {
            for (var objKey in obj) {
                if (objKey.charAt(0) !== '$' && hasOwnProperty.call(obj, objKey) && filterFilterAllProperties(qQuery, obj[objKey])) {
                    return true;
                }
            }
            return false;
        } else if (qQuery instanceof RegExp || ((typeof(qQuery) === "string" || typeof(query) === "number") && qQuery !== "")) {
            return matchString(qQuery, obj);
        } else {
            return true;
        }
    };
    var filterFilter = function(query, params, obj, queryArrayIsAND, exactMatch) {
        if ($.isArray(query)) {
            if (query.length == 0) {
                return true
            }
            if (!queryArrayIsAND) {
                for (var i in query) {
                    if (filterFilter(query[i], params, obj, undefined, exactMatch)) {
                        return true
                    }
                }
                return false;
            } else {
                for (var i in query) {
                    if (!filterFilter(query[i], params, obj, undefined, exactMatch)) {
                        return false
                    }
                }
                return true;
            }
        } else if ($.isArray(obj)) {
            if (obj.length == 0 && query != "") {
                return false;
            }
            for (var i in obj) {
                if (filterFilter(query, params, obj[i], undefined, exactMatch)) {
                    return true
                }
            }
            return false;
        } else if ($.isPlainObject(obj) || $.isPlainObject(query)) {
            if (!$.isPlainObject(obj)) {
                return false
            }
            if (!$.isPlainObject(query)) {
                return true
            }
            if (query.userQuery && !filterFilterAllProperties(query.userQuery, obj)) {
                return false
            }
            for (var objKey in query) {
                const requiresExactMatch = params.exactMatch && params.exactMatch.includes(objKey);
                if (objKey.charAt(0) !== '$' && objKey !== 'userQuery') {
                    if (!objKey.endsWith("__not") && !objKey.endsWith("__and") 
                        && !filterFilter(query[objKey], params, Fn.propStr(objKey)(obj), undefined, requiresExactMatch)) {
                        return false;
                    }
                    if (!objKey.endsWith("__not") && objKey.endsWith("__and") 
                        && !filterFilter(query[objKey], params, Fn.propStr(objKey.substr(0,objKey.length-5))(obj), true, requiresExactMatch)) {
                        return false;
                    }
                    if (objKey.endsWith("__not") && !objKey.endsWith("__and") 
                        && filterFilter(query[ objKey ], params, Fn.propStr(objKey.substr(0,objKey.length-5))(obj), undefined, requiresExactMatch)) { 
                        return false;
                    }
                }
            }
            return true;
        } else if (query instanceof RegExp || ((typeof(query) === "string" || typeof(query) === "number") && query !== "")) {
            return matchString(query, obj, exactMatch);
        } else {
            return true;
        }
    };

    var prepareStringKey = function(params, a) {
        if (a.endsWith("/") && a.startsWith("/") && a.length > 2) {
            try {
                return new RegExp(a.substr(1, a.length - 2));
            } catch (err) {
                if (params) {
                    params.userQueryErrors = params.userQueryErrors || {};
                    params.userQueryErrors[a] = err;
                }
                return a;
            }
        } else {
            return a.toLowerCase();
        }
    };

    var cleanFilterQuery = function(obj, params) {
        if ($.isPlainObject(obj)) {
            for (var k in obj) {
                obj[k] = cleanFilterQuery(obj[k], params);
                if (($.isEmptyObject(obj[k]) && !(obj[k] instanceof RegExp) && (typeof obj[k] !== 'boolean')) || obj[k] === "") {
                    delete obj[k]
                }
            }
        } else if ($.isArray(obj)) {
            for (var k = obj.length - 1; k >= 0; k--) {
                obj[k] = cleanFilterQuery(obj[k], params);
                if (($.isEmptyObject(obj[k]) && !(obj[k] instanceof RegExp) && (typeof obj[k] !== 'boolean')) || obj[k] === "") {
                    obj.splice(k, 1)
                }
            }
        } else if (typeof(obj) === "string" || typeof(obj) === "number" || typeof(obj) === "boolean") {
            obj = prepareStringKey(params, ''+obj);
        }
        return obj;
    };


    var translatePropertyName = function(params, propName) {
        if (propName === 'not') {
            return propName
        }
        propName = (params.propertyRules || {})[propName] || propName;
        if (propName.charAt(0) === '-') {
            propName = ((params.propertyRules || {})[propName.substr(1)] || propName.substr(1)) + "__not"
        } else {
            propName = propName + "__and"
        }
        return propName;
    }

    var safePushProp = function(obj, propStr, value) {
        if (!obj || !propStr) {
            return
        }
        var initialValue = Fn.propStrSafe(propStr)(obj);
        if (!$.isArray(initialValue)) {
            if (initialValue) {
                Fn.setPropStr([initialValue], propStr)(obj)
            }
            else {
                Fn.setPropStr([], propStr)(obj)
            }
            initialValue = Fn.propStr(propStr)(obj);
        }
        if ($.isArray(value)) {
            value.forEach(function(o) {
                initialValue.push(o)
            })
        }
        else {
            initialValue.push(value)
        }
    }

    var handleUserQuery = function(filterQuery, params) {
        if (!filterQuery.userQuery) {
            return filterQuery
        }
        var remainingUserQuery = [];
        filterQuery.userQuery.split(" ").filter(function(o) {
            return o !== ""
        }).forEach(function(dottedProp) {
            if (dottedProp.indexOf(':') > -1 && !( dottedProp.startsWith("/") && dottedProp.endsWith("/") )) {
                var fqelem = dottedProp.split(":");
                var propName = translatePropertyName(params, fqelem.shift());
                safePushProp(filterQuery, propName, fqelem.join(":"));
            } else {
                remainingUserQuery.push(dottedProp);
            }
        });
        filterQuery.userQuery = remainingUserQuery.join(" ").trim();
        return filterQuery;
    };

    var handleUserQueryTargets = function(filterQuery, params) {
        if (!params.userQueryTargets || !filterQuery) {
            return filterQuery
        }
        var userQueryTargets = $.isArray(params.userQueryTargets) ? params.userQueryTargets : [params.userQueryTargets];
        // TODO : there should be a proper "summary of the query after the whole processing"
        params.userQueryResult = ('' + filterQuery.userQuery).split(" ").filter(function(a) {
            return a != ""
        }).map(prepareStringKey.bind(null, null));

        // Add appropriate filters if user imputed not:something
        if (filterQuery.not) {
            userQueryTargets.forEach(function(userQueryTarget) {
                safePushProp(filterQuery, userQueryTarget + "__not", filterQuery.not)
            });
            delete filterQuery.not;
        }

        // dispatch the userQuery remains
        var userQuery = filterQuery.userQuery;
        if (!userQuery) {
            return filterQuery
        }
        delete filterQuery.userQuery;
        var result = [];
        var userQueryValues = userQuery.split(" ").filter(function(o) {
            return o !== ''
        });
        Fn.pow(userQueryTargets, userQueryValues.length).forEach(function(userQueryTargetCombination) {
            var filterQueryOption = angular.copy(filterQuery);
            userQueryTargetCombination.forEach(function(userQueryTarget, i) {
                safePushProp(filterQueryOption, userQueryTarget + "__and", userQueryValues[i]);
            });
            result.push(filterQueryOption);

        });

        return result;
    };

    var filterWrapper = function(collection, query, params) {
        var filterQuery = angular.copy(query || {});
        if (!params) {
            params = {}
        } else {
            delete params.userQueryErrors;
            delete params.userQueryResult;
        }
        filterQuery = handleUserQuery(filterQuery, params);
        // console.info('HANDLE',JSON.stringify(filterQuery));
        filterQuery = handleUserQueryTargets(filterQuery, params);
        // console.info('TARGETS',JSON.stringify(filterQuery));
        filterQuery = cleanFilterQuery(filterQuery, params);
        // console.info('CLEANED',JSON.stringify(filterQuery));
        return collection.filter(function(o) {
            return filterFilter(filterQuery, params, o);
        });
    };

    return {
        filter: filterWrapper,
    }
});


app.factory("algorithmsPalette", function() {
    var COLORS =  [
        "#f07c48", // poppy red (no, it's actually orange)
        "#fdc766", // chicky yellow
        "#7bc9a6", // turquoisy green
        "#4ec5da", // sky blue
        "#548ecb", // sea blue
        "#d848c0", // lilas
        "#41bb15" // some no name green
        //"#97668f", // lilas
        //"#5e2974", // dark purple
    ];
    return function(i) {
        return COLORS[i % COLORS.length];
    }
});


app.factory("categoricalPalette", function() {  // Keep in sync with PaletteFactory/categorical
    var COLORS = [
        "#f06548", // poppy red
        "#fdc766", // chicky yellow
        "#7bc9a6", // turquoisy green
        "#4ec5da", // sky blue
        "#548ecb", // sea blue
        "#97668f", // lilas
        "#5e2974", // dark purple
    ];
    return function(i) {
        return COLORS[i % COLORS.length];
    }
});


app.factory("divergingPalette", function() {
    /* given a value going from -1 to 1
     returns the color associated by a diverging palette
     going form blue to red. */
    var rgbToHsl = function(s) {
        return d3.rgb(s).hsl();
    };
    var RED_SCALE = ["#fbefef", "#FBDAC8", "#F3A583", "#D75D4D", "#B11F2C"].map(rgbToHsl);
    var BLUE_SCALE = ["#f0f1f1", "#CFE6F1", "#94C5DE", "#4793C3", "#2966AB"].map(rgbToHsl);

    var divergingPalette = function(r) {
        var SCALE = (r > 0) ? RED_SCALE : BLUE_SCALE;
        if (r < 0) {
            r = -r;
        }
        if (r >= 1.) r = 0.99;
        var N = SCALE.length - 1;
        var bucket = r * N | 0;
        var low_color = SCALE[bucket];
        var high_color = SCALE[bucket + 1];
        r = r * N - bucket;
        var h = high_color.h;
        var l = low_color.l * (1 - r) + high_color.l * r;
        var s = low_color.s * (1 - r) + high_color.s * r;
        return d3.hsl(h, s, l);
    };
    return divergingPalette;
});


app.factory("AnyLoc", function(Assert) {
    return {
        makeLoc : function(projectKey, localId) {
            return {
                    projectKey: projectKey,
                    localId: localId,
                    fullId: projectKey + "." + localId
            }
        },
        getLocFromSmart: function(contextProjectKey, name) {
            if (name.indexOf(".") >= 0) {
                return {
                    projectKey: name.split("\.")[0],
                    localId: name.split("\.")[1],
                    fullId: name
                }
            } else {
                return {
                    projectKey: contextProjectKey,
                    localId: name,
                    fullId: contextProjectKey + "." + name
                }
            }
        },
        getLocFromFull: function(fullName) {
            Assert.trueish(fullName.includes('.'), 'no dot in fullname');
            return {
                projectKey: fullName.split("\.")[0],
                localId: fullName.split("\.")[1],
                fullId: fullName
            };
        },
    }
});

app.factory("AutomationUtils", function() {
    const svc = {
        pythonEnvImportTimeModes: [
            ["INSTALL_IF_MISS", "Create new if not present"],
            ["FAIL_IF_MISS", "Fail if not present"],
            ["DO_NOTHING", "Ignore"]
         ],
         pythonEnvImportTimeModeDescs: [
             "When the bundle declares a dependency on a code env that does not exist on this instance, create a new code env with that name",
             "When the bundle declares a dependency on a code env that does not exist on this instance, stop the preloading",
             "Do not take action if a code env is missing"
         ],
         envImportSpecificationModes: [
             ["SPECIFIED", "User-specified list of packages"],
             ["ACTUAL", "Actual list of packages"]
         ],
         envImportSpecificationModeDescs: [
             "Use the list of packages that the user specified, and the default list of required packages",
             "Use the list of packages built by inspecting the environment"
         ]
    }

    return svc;
});

app.factory("ConnectionUtils", function() {
    const connectionSqlTypes =
        ["hiveserver2", "MySQL", "PostgreSQL", "Vertica", "Greenplum", "Redshift", "Teradata", "Oracle", "SQLServer", "Synapse", "Netezza", "BigQuery", "SAPHANA", "Snowflake", "JDBC", "Athena"]; //TODO @datasets remove
    return {
        isIndexable: function(connection) {
            return connection && connection.type && connectionSqlTypes.includes(connection.type);
        }
    }
});
app.factory("DatasetUtils", function(Assert, DataikuAPI, $q, Logger, $rootScope, SmartId, RecipesUtils) {
    var sqlTypes = ["MySQL", "PostgreSQL", "Vertica", "Greenplum", "Redshift", "Teradata", "Oracle", "SQLServer", "Synapse", "Netezza", "BigQuery", "SAPHANA", "Snowflake", "JDBC", "Athena"]; //TODO @datasets remove
    const sqlAbleTypes = ["S3"];
    var svc = {
        canUseSQL: function(dataset) {
            if (sqlTypes.indexOf(dataset.type) >= 0 &&
                dataset.params.mode == "table") {
                return true;
            }
            if (sqlAbleTypes.indexOf(dataset.type) >= 0) {
                return true;
            }
            if (dataset.type == "HDFS" || dataset.type == "hiveserver2") {// && $scope.appConfig.impalaEnabled) {
                return true;
            }
            Logger.info("Dataset is not SQL-capable: " + dataset.type);
            return false;
        },
        canUseSparkSQL: function(dataset) {
            if ($rootScope.appConfig.interactiveSparkEngine == "DATABRICKS") {
                return dataset.type == "HDFS";
            } else {
                if (sqlTypes.indexOf(dataset.type) >= 0 && dataset.params.mode == "table") {
                    return false;
                }
                return true;
            }
        },

        hasSizeStatus: function(dataset) {
            return svc.getKindForConsistency(dataset) == "files";
        },

        isSQL: function(dataset) {
            return sqlTypes.indexOf(dataset.type) >= 0;
        },
        isSQLTable: function(dataset) {
            return sqlAbleTypes.indexOf(dataset.type) >= 0 ||
                sqlTypes.indexOf(dataset.type) >= 0 && (!dataset.params || dataset.params.mode == "table"); // A bit hackish, when we don't have the params, let's not block functionality
        },

        supportsReadOrdering : function(dataset) {
            return svc.isSQLTable(dataset);
        },

        getKindForConsistency : function(dataset) {
            if (sqlTypes.indexOf(dataset.type) >= 0) {
                return "sql";
            } else if (dataset.type == "MongoDB") {
                return "mongodb";
            } else if (dataset.type == "DynamoDB") {
                return "dynamodb";
            } else if (dataset.type == "Cassandra") {
                return "cassandra";
            } else if (dataset.type == "Twitter") {
                return "generic";
            } else if (dataset.type == "ElasticSearch") {
                return "generic";
            } else if (dataset.type == "Kafka") {
                return "generic";
            } else if (dataset.type == "SQS") {
                return "generic";
            } else {
                return "files";
            }
        },

        getLocFromSmart: function(contextProjectKey, name) {
            if (name.indexOf(".") >= 0) {
                return {
                    projectKey: name.split("\.")[0],
                    name: name.split("\.")[1],
                    fullName: name
                };
            } else {
                return {
                    projectKey: contextProjectKey,
                    name: name,
                    fullName: contextProjectKey + "." + name
                };
            }
        },
        getLocFromFull: function(fullName) {
            Assert.trueish(fullName.includes('.'), 'no dot in fullname');
            return {
                projectKey: fullName.split("\.")[0],
                name: fullName.split("\.")[1],
                fullName: fullName
            };
        },
        makeLoc: function(datasetProjectKey, datasetName) {
            return {
                projectKey: datasetProjectKey,
                name: datasetName,
                fullName: datasetProjectKey + "." + datasetName
            };
        },
        makeSmart: function(loc, contextProjectKey) {
            if (loc.projectKey == contextProjectKey) {
                return loc.name;
            } else {
                return loc.fullName;
            }
        },

        makeHeadSelection: function(lines) {
            return {
                partitionSelectionMethod: "ALL",
                samplingMethod: "HEAD_SEQUENTIAL",
                maxRecords: lines
            };
        },

        getSchema: function(scope, datasetName) {
            if (!scope.computablesMap || !scope.computablesMap[datasetName]) {
                return;
            }
            var it = scope.computablesMap[datasetName];
            if (!it || !it.dataset) {
                throw Error('dataset is not in computablesMap');
            }
            return it.dataset.schema;
        },

        updateRecipeComputables: function(scope, recipe, projectKey, contextProjectKey) {
            if (!scope.computablesMap) return Promise.resolve();
            let references = new Set(RecipesUtils.getFlatIOList(recipe).map(role => role.ref));
            references = [...references].filter(ref => (ref in scope.computablesMap) && ((scope.computablesMap[ref].dataset && !scope.computablesMap[ref].dataset.schema) || (scope.computablesMap[ref].streamingEndpoint && !scope.computablesMap[ref].streamingEndpoint.schema)));
            return $q.all(references
                .map(name => {
                    let resolvedSmartId = SmartId.resolve(name, contextProjectKey);
                    if (scope.computablesMap[name].dataset) {
                        return DataikuAPI.datasets.get(resolvedSmartId.projectKey, resolvedSmartId.id, contextProjectKey).success(function(data){
                            scope.computablesMap[name].dataset = data;
                        }).error(setErrorInScope.bind(scope));
                    } else if (scope.computablesMap[name].streamingEndpoint) {
                        return DataikuAPI.streamingEndpoints.get(resolvedSmartId.projectKey, resolvedSmartId.id, contextProjectKey).success(function(data){
                            scope.computablesMap[name].streamingEndpoint = data;
                        }).error(setErrorInScope.bind(scope));
                    }
                })
            );
        },

        updateDatasetInComputablesMap: function(scope, dsName, projectKey, contextProjectKey) {
            let resolvedSmartId = SmartId.resolve(dsName, contextProjectKey);
            return DataikuAPI.datasets.get(resolvedSmartId.projectKey, resolvedSmartId.id, contextProjectKey).success(function(data){
                scope.computablesMap[dsName].dataset = data;
            }).error(setErrorInScope.bind(scope));
        },

        listDatasetsUsabilityForAny: function(contextProjectKey) {
            return DataikuAPI.flow.listUsableComputables(contextProjectKey, {
                datasetsOnly: true
            });
        },

        listFoldersUsabilityForOutput : function(contextProjectKey, recipeType) {
            var d = $q.defer();
            DataikuAPI.flow.listUsableComputables(contextProjectKey, {
                datasetsOnly : false,
                forRecipeType : recipeType,
            }).success(function(data) {
                data.forEach(function(x) {
                    x.usable = x.usableAsInput;
                    x.usableReason = x.inputReason;
                });
                d.resolve(data);
            });
            return d.promise;
        },

        listDatasetsUsabilityForInput: function(contextProjectKey, recipeType) {
            var d = $q.defer();
            DataikuAPI.flow.listUsableComputables(contextProjectKey, {
                datasetsOnly: true,
                forRecipeType: recipeType,
            }).success(function(data) {
                data.forEach(function(x) {
                    x.usable = x.usableAsInput;
                    x.usableReason = x.inputReason;
                });
                d.resolve(data);
            });
            return d.promise;
        },

        /**
         * Returns a promise on an arry of two array, "availableInputDatasets" and "availableOutputDataset"
         * On each, the "usable" and "usableReason" are set
         */
        listDatasetsUsabilityInAndOut: function(contextProjectKey, recipeType, datasetsOnly) {
            var d = $q.defer();
            DataikuAPI.flow.listUsableComputables(contextProjectKey, {
                datasetsOnly: datasetsOnly == null ? true : datasetsOnly,
                forRecipeType: recipeType,
            }).success(function(data) {
                var avlIn = angular.copy(data);
                var avlOut = angular.copy(data);
                avlIn.forEach(function(x) {
                    x.usable = x.usableAsInput;
                    x.usableReason = x.inputReason;
                });
                avlOut.forEach(function(x) {
                    x.usable = x.usableAsOutput;
                    x.usableReason = x.outputReason;
                });
                d.resolve([avlIn, avlOut]);
            });
            return d.promise;
        },

        /**
         * Returns a promise on an arry of two array, "availableInputDatasets" and "availableOutputDataset"
         * On each, the "usable" and "usableReason" are set
         */
        listUsabilityInAndOut: function(contextProjectKey, recipeType) {
            var d = $q.defer();
            DataikuAPI.flow.listUsableComputables(contextProjectKey, {
                forRecipeType: recipeType
            }).success(function(data) {
                var avlIn = angular.copy(data);
                var avlOut = angular.copy(data);
                avlIn.forEach(function(x) {
                    x.usable = x.usableAsInput;
                    x.usableReason = x.inputReason;
                });
                avlOut.forEach(function(x) {
                    x.usable = x.usableAsOutput;
                    x.usableReason = x.outputReason;
                });
                d.resolve([avlIn, avlOut]);
            });
            return d.promise;
        }
    }
    return svc;
});


app.factory("Breadcrumb", function($stateParams, $rootScope) {
    var ret = {}
    $rootScope.masterBreadcrumbData = {}

    ret.setProjectSummary = function(projectSummary) {
        $rootScope.currentProjectSummary = projectSummary;
    }

    ret.setData = function(k, v) {
        $rootScope.masterBreadcrumbData[k] = v;
    }

    ret.projectBreadcrumb = function() {
        return [
            //{ "type" : "home" },
            {"type": "project", "projectKey": $stateParams.projectKey}
        ]
    }
    ret.datasetBreadcrumb = function() {
        return ret.projectBreadcrumb().concat([
            //{"type" : "datasets", projectKey : $stateParams.projectKey},
            {
                "type": "dataset", projectKey: $stateParams.projectKey, id: $stateParams.datasetName,
                displayName: $stateParams.datasetName
            }
        ]);
    }
    ret.recipeBreadcrumb = function() {
        return ret.projectBreadcrumb().concat([
            {"type": "recipes", projectKey: $stateParams.projectKey},
            {
                "type": "recipe", projectKey: $stateParams.projectKey, id: $stateParams.recipeName,
                displayName: $stateParams.recipeName
            }
        ]);
    }
    ret.insightBreadcrumb = function(insightName) {
        return ret.projectBreadcrumb().concat([
            {"type": "insights", "projectKey": $stateParams.projectKey},
            {
                "type": "insight",
                "projectKey": $stateParams.projectKey,
                "id": $stateParams.insightId,
                displayName: insightName
            }
        ]);
    }

    ret.set = function(array) {
        $rootScope.masterBreadcrumb = array;
    }

    ret.setWithProject = function(array) {
        ret.set(ret.projectBreadcrumb().concat(array));
    }
    ret.setWithDataset = function(array) {
        ret.set(ret.datasetBreadcrumb().concat(array));
    }
    ret.setWithInsight = function(insightName, array) {
        ret.set(ret.insightBreadcrumb(insightName).concat(array));
    }
    ret.setWithRecipe = function(array) {
        ret.set(ret.recipeBreadcrumb().concat(array));
    }
    ret.setWith
    return ret;
});


app.service('LocalStorage', ['$window', function($window) {
    return {
        set: function(key, value) {
            if (value !== undefined) {
                $window.localStorage[key] = JSON.stringify(value);
            }
        },
        get: function(key) {
            var ret = $window.localStorage[key];
            if (ret !== undefined) {
                ret = JSON.parse(ret);
            }
            return ret;
        }
    }
}]);


app.factory("ContextualMenu", function($compile, $rootScope, $templateCache, $window, $http) {
        // Class describing a menu.
        // Can be used for both contextual menu and
        // regular menues.
        //
        function Menu(params) {
            /*
             Contextual or not, only one menu can be visible at the same time
             on the screen.
             The contextual menu content does not live in the DOM until it is displayed
             to the user.

             Parameters contains the following options
             - template (required) : template path for the content of the menu.
             - controller (optional) : name of the controller
             - scope  (optional) : if not added, a new scope will be created.
             - contextual (option, true|false, default:true
             in contextual menu mode, all clicks outside of the
             popup is captured.
             - onOpen (optional): called on menu open
             - onClose (optional): called on menu close
             - cssClass: CSS class on the ul
             */
            this.template = params.template;
            if (typeof this.template != "string") {
                throw "Template parameter is required";
            }
            this.cssClass = params.cssClass;
            this.controller = params.controller;
            this.contextual = params.contextual;
            if (this.contextual === undefined) {
                this.contextual = true;
            }
            this.enableClick = params.enableClick;
            if (this.enableClick === undefined) {
                this.enableClick = false;
            }
            this.handleKeyboard = params.handleKeyboard;
            if (this.handleKeyboard === undefined) {
                this.handleKeyboard = true;
            }
            this.scope = params.scope;
            this.tmplPromise = $http.get(this.template, {cache: $templateCache});
            this.onClose = params.onClose || function() {
                };
            this.onOpen = params.onOpen || function() {
                };
        }

        Menu.prototype.newScope = function() {
            if (this.scope) {
                return this.scope.$new();
            }
            else {
                return $rootScope.$new(true);
            }
        };

        Menu.prototype.globalOnClose = function() {
        };
        Menu.prototype.globalOnOpen = function() {
        };

        // close any popup currently visible on the screen.
        Menu.prototype.closeAny = function(e) {
            // remove and unbind any overlays
            Menu.prototype.$overlay.unbind("click");
            Menu.prototype.$overlay.unbind("contextmenu");
            Menu.prototype.$overlay.remove();

            // remove the document click
            $(document).off(".closeMenu");

            Menu.prototype.$menu.remove();
            Menu.prototype.globalOnClose();
            Menu.prototype.globalOnClose = function() {
            };
            Menu.prototype.globalOnOpen = function() {
            };
            Menu.prototype.$menu.removeClass();
            Menu.prototype.$menu.addClass('dropdown-menu');
            if (e) e.preventDefault();
            return false;
        };

        Menu.prototype.setup = function($menu) {
            var me = this;

            Menu.prototype.globalOnClose = this.onClose;
            Menu.prototype.globalOnOpen = this.onOpen;
            var index = -1;
            var currentMenu = Menu.prototype.$menu;

            if (me.contextual) {
                $menu.before(Menu.prototype.$overlay);
                $(Menu.prototype.$overlay).bind("contextmenu", me.closeAny.bind(me));
                Menu.prototype.$overlay.click(me.closeAny.bind(me));
            } else {
                window.setTimeout(function() {
                    // handle click when menu is open
                    $(document)
                        .on('click.closeMenu', function(evt) {
                            if ($(evt.target).parents().index(Menu.prototype.$menu) === -1) {
                                Menu.prototype.closeAny();
                            }
                        });
                }, 0);
            }
            if (!me.enableClick) {
                $menu.on('click.ctxmenu', function(e) {
                    me.closeAny();
                });
            }

            window.setTimeout(function() {
                // makes the links focusable
                Menu.prototype.$menu.find('a').attr('tabindex', -1);

                var handleKey = function(evt) {
                    if (Menu.prototype.$menu.height()) {
                        if (evt.which === 27) {
                            // esc
                            Menu.prototype.closeAny();
                        }
                        if (evt.which === 40) {
                            // down
                            const items = currentMenu.find('>li>a');
                            if (items.length) {
                                index = Math.min(items.length - 1, index + 1);
                                items[index].focus();
                            }
                            evt.preventDefault();
                            evt.stopPropagation();
                        }
                        if (evt.which === 38) {
                            // up
                            index = Math.max(0, index - 1);
                            const items = currentMenu.find('>li>a, >*>li>a');
                            if (items.length) {
                                items[index].focus();
                            }
                            evt.preventDefault();
                            evt.stopPropagation();
                        }

                        if (evt.which === 37) {
                            // left
                            // Go up one menu
                            if (currentMenu != Menu.prototype.$menu) {
                                index = currentMenu.parents('ul').eq(0).find('>li>a').index(currentMenu.parent('li.hover').removeClass('hover').find('>a'));
                                currentMenu = currentMenu.parents('ul').eq(0);
                                const items = currentMenu.find('>li>a');
                                if (items.length) {
                                    items[index].focus();
                                }
                            }
                            evt.preventDefault();
                            evt.stopPropagation();
                        }
                        if (evt.which === 39) {
                            // right
                            // go into submenu
                            const items = currentMenu.find('>li>a');
                            const submenus = items.eq(index).siblings('ul');
                            if (submenus.length) {
                                items.eq(index).parent().addClass('hover');
                                currentMenu = submenus.eq(0);
                                index = 0;
                                items[index].focus();
                            }
                            evt.preventDefault();
                            evt.stopPropagation();
                        }
                        if (evt.which === 13) {
                            // enter
                            currentMenu.find('>li>a').eq(index).trigger('click');
                            Menu.prototype.closeAny();
                        }
                    }
                };
                if (me.handleKeyboard) {
                    $(document).on('keydown.closeMenu', handleKey); // handle keypress while the menu doesn't have the focus
                    Menu.prototype.$menu.on('keydown', handleKey);
                }
                Menu.prototype.$menu.on('mouseenter', 'a', function(e) {
                    Menu.prototype.$menu.find('.hover').removeClass('hover');
                    currentMenu = $(this).parents('ul').eq(0);
                    index = currentMenu.find('>li>a').index($(this));
                });

            });
        };

        // Fill the shared menu element with menu instance
        // content.
        //
        // Template is compiled against the scope
        // at each call.
        //
        Menu.prototype.fill = function(cb) {
            var me = this;
            this.tmplPromise.success(function(tmplData) {
                if (me.controller !== undefined) {
                    me.$menu.attr("ng-controller", me.controller);
                }
                else {
                    me.$menu.removeAttr("ng-controller");
                }
                me.$menu.html(tmplData);
                Menu.prototype.destroyCurrentScope();
                var newScope = me.newScope();
                $compile(me.$menu)(newScope);
                Menu.prototype.currentScope = newScope;
                if (cb !== undefined) {
                    cb(me.$menu);
                }
                if (me.cssClass) {
                    me.$menu.addClass(me.cssClass);
                }
            });
        };

        Menu.prototype.destroyCurrentScope = function() {
            if (Menu.prototype.currentScope != undefined) {
                Menu.prototype.currentScope.$destroy();
            }
            Menu.prototype.currentScope = undefined;
        };

        Menu.prototype.openAlignedWithElement = function(alignElement, callback, followScroll, exactAlignment) {
            var me = this;
            me.closeAny();
            me.fill(function($menu) {
                // place the element.
                var $body = $("body");
                var $alignElement = $(alignElement);
                var alignElementOffset = $alignElement.offset();
                var scrollOffsetLeft = alignElementOffset.left;
                var scrollOffsetTop = alignElementOffset.top;

                var box = $alignElement.offset();
                box.width = $alignElement.width();
                box.height = $alignElement.outerHeight();
                $body.append($menu);
                var left = Math.max(0, box.left - (exactAlignment ? 0 : 10));

                // we also want to move the dropdown menu to the left
                // to stay on the screen.
                var menuWidth = $menu.width();
                var bodyWidth = $body.width();

                $menu.detach();

                left = Math.min(left, bodyWidth - menuWidth - 10);

                if (bodyWidth - left - menuWidth < 180) {
                    // let's step into bizarro land
                    // where submenues open to the left.
                    $menu.addClass("bizarro");
                }
                else {
                    $menu.removeClass("bizarro");
                }

                var position = {
                    left: left,
                    top: box.top + box.height,
                    bottom: "auto",
                    right: "auto"
                };

                var containerElement = $body;

                if (followScroll) {
                    var containerElement = $(alignElement).offsetParent();
                    var alignElementPosition = $alignElement.position();
                    var scrollOffsetLeft = alignElementPosition.left - box.left;
                    var scrollOffsetTop = alignElementPosition.top - box.top;
                    position.left += scrollOffsetLeft;
                    position.top += scrollOffsetTop;
                }

                $menu.appendTo(containerElement);
                $menu.css(position);

                me.setup($menu);
                if (callback !== undefined) {
                    callback($menu);
                }
                Menu.prototype.globalOnOpen();
            });
        };

        Menu.prototype.openAtXY = function(left, top, callback, dummyLateralPosition, dummyVerticalPosition) {
            var me = this;
            me.closeAny();
            me.fill(function($menu) {
                $("body").append($menu);
                var offset = {};
                if (left < $($window).width() / 2 || dummyLateralPosition) {
                    offset.left = left;
                    offset.right = 'auto';
                } else {
                    offset.left = 'auto';
                    offset.right = $($window).width() - left;
                }
                if (top < $($window).height() / 2 || dummyVerticalPosition) {
                    offset.top = top;
                    offset.bottom = 'auto';
                } else {
                    offset.top = 'auto';
                    offset.bottom = $($window).height() - top;
                }
                $menu.css(offset);
                me.setup($menu);
                if (callback !== undefined) {
                    callback($menu);
                }
                Menu.prototype.globalOnOpen();
            });
        };

        Menu.prototype.openAtEventLoc = function (evt) {
            if (!evt) return;
            this.openAtXY(evt.pageX, evt.pageY);
        }

        // TODO get rid of the id
        Menu.prototype.$menu = $('<ul id="dku-contextual-menu" class="dropdown-menu" style="position:absolute" role="menu">');
        // overlay element that helps capturing any click
        // outside of the menu.
        // Used in ContextualMenu mode.
        Menu.prototype.$overlay = $('<div class="contextualMenuOverlay"></div>');
        // Menu.prototype.$overlay

        return Menu;
    });


app.factory("ActivityIndicatorManager", ["$timeout", function($timeout) {
    function hide(activityIndicator) {
        activityIndicator.hidden = true;
    }

    function getActivityIndicatorType(type) {
        switch (type) {
            case 'waiting':
            case 'info':
                return 'progress';
            case 'success':
                return 'success';
            case 'warning':
                return 'warning';
            case 'error':
                return 'error';
            default:
                throw new Error('Unknown type: ' + type);
        }
    }

    return {
        hide,
        configureActivityIndicator: function (activityIndicator, type, text, time, faded = true) {
            activityIndicator.hidden = false;
            activityIndicator.text = text;
            activityIndicator.type = getActivityIndicatorType(type);
            activityIndicator.faded = faded;

            if (type === 'waiting') {
                activityIndicator.spinner = true;
            } else {
                activityIndicator.spinner = false;
                if (!time) {
                    time = 2000;
                }
                $timeout(function () {
                    hide(activityIndicator);
                }, time);
            }
        },
        buildDefaultActivityIndicator: function (inChartPanel) {
            return {
                inChart: inChartPanel,
                hidden: true,
                text: '',
                type: 'progress',
                spinner: false,
                faded: true
            };
        }
    };
}]);

app.factory("ActivityIndicator", ["$rootScope", "ActivityIndicatorManager", function($rootScope, ActivityIndicatorManager) {
    $rootScope.activityIndicator = ActivityIndicatorManager.buildDefaultActivityIndicator(false);
    return {
        waiting: function(text) {
            ActivityIndicatorManager.configureActivityIndicator($rootScope.activityIndicator, 'waiting', text);
        },
        hide: function() {
            ActivityIndicatorManager.hide($rootScope.activityIndicator);
        },
        success: function(text, time) {
            ActivityIndicatorManager.configureActivityIndicator($rootScope.activityIndicator,'success', text, time);
        },
        warning: function(text, time) {
            ActivityIndicatorManager.configureActivityIndicator($rootScope.activityIndicator,'warning', text, time);
        },
        info: function(text, time) {
            ActivityIndicatorManager.configureActivityIndicator($rootScope.activityIndicator,'info', text, time);
        },
        error: function(text, time) {
            ActivityIndicatorManager.configureActivityIndicator($rootScope.activityIndicator,'error', text, time);
        }
    };
}]);

app.factory("ChartActivityIndicator", ["ActivityIndicatorManager", function(ActivityIndicatorManager) {
    return {
        buildDefaultActivityIndicator: function () {
            return ActivityIndicatorManager.buildDefaultActivityIndicator(true)
        },
        displayBackendError: function (chartActivityIndicator, errorMessage) {
            ActivityIndicatorManager.configureActivityIndicator(chartActivityIndicator, 'error', errorMessage, 5000, false);
        }
    };
}]);

app.factory("APIXHRService", ["$rootScope", "$http", "$q", "Logger", "HistoryService", function($rootScope, $http, $q, Logger, HistoryService) {
    $rootScope.httpRequests = [];

    var unloadingState = false;

    $(window).bind("beforeunload", function() {
        unloadingState = true;
    });

    // Return a proxified promise that can be disabled
    function disableOnExit(promise) {

        function isEnabled() {
            return !unloadingState;
        }

        var deferred = $q.defer();

        // $q promises
        promise.then(function(data) {

                if (isEnabled()) {
                    deferred.resolve(data);
                }
            },
            function(data) {
                if (isEnabled()) {
                    deferred.reject(data);
                }
            },
            function(data) {
                if (isEnabled()) {
                    deferred.notify(data);
                }
            });

        // $http specific
        if (promise.success) {
            deferred.promise.success = function(callback) {
                promise.success(function(data, status, headers, config, statusText, xhrStatus) {
                    if (isEnabled()) {
                        callback(data === 'null' ? null : data, status, headers, config, statusText, xhrStatus);
                    }
                });
                return deferred.promise;
            };
        }

        if (promise.error) {
            promise.error(function(data, status, headers) {
                var apiError = getErrorDetails(data, status, headers);
                Logger.error("API error: ", apiError.errorType + ": " + apiError.message);
            })
            deferred.promise.error = function(callback) {
                promise.error(function(data, status, headers, config, statusText, xhrStatus) {
                    if (isEnabled()) {
                        callback(data, status, headers, config, statusText, xhrStatus);
                    }
                });
                return deferred.promise;
            };
        }

        if (promise.noSpinner) {
            deferred.promise.noSpinner = promise.noSpinner;
        }

        return deferred.promise;
    }

    return function(method, url, data, spinnerMode) {
        var headers = {
            'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8'
        };

        var start = new Date().getTime();
        Logger.debug("[S] " + method + ' ' + url);

        var params = {
            method: method,
            url: url,
            headers: headers,
            transformRequest: function(data) {
                return angular.isObject(data) && String(data) !== '[object File]' ? jQuery.param(data) : data;
            },
        };
        if ($rootScope.appConfig) {
            params.xsrfCookieName = $rootScope.appConfig.xsrfCookieName;
        }
        if (method == 'GET') {
            params.params = data;
        } else {
            params.data = data;
        }

        var promise = $http(params);
        var disableSpinner = spinnerMode && spinnerMode == "nospinner";

        var logDone = function(result) {
            var end = new Date().getTime();
            Logger.debug("[D] " + method + ' ' + url + " (" + (end - start) + "ms)");
        }
        promise.then(logDone, logDone);

        if (!disableSpinner) {
            promise.spinnerMode = spinnerMode;
            $rootScope.httpRequests.push(promise);

            var removeRequest = function(result) {
                var idx = $rootScope.httpRequests.indexOf(promise);
                if (idx == -1) Logger.info("Unable to remove request"); /*@console*/
                if (idx != -1) $rootScope.httpRequests.splice(idx, 1);
            };

            promise.noSpinner = function() {
                removeRequest();
                safeApply($rootScope);
                return promise;
            };

            promise.then(removeRequest, removeRequest);
        }

        if (method=="POST") HistoryService.recordItemPost(url, data);

        return app.addSuccessErrorToPromise(promise);
    };
}]);


app.factory("CreateModalFromDOMElement", function(CreateModalFromHTML) {
    return function(selector, scope, controller, afterCompileCallback) {
        return CreateModalFromHTML($(selector).html(), scope, controller, afterCompileCallback, false);
    };
});

app.factory("CreateModalFromTemplate", function(CreateModalFromHTML, $http, $templateCache, $q) {
    return function(location, scope, controller, afterCompileCallback, noFocus, backdrop, keyboard) {
        var deferred = $q.defer();
        $q.when($templateCache.get(location) || $http.get(location, {cache: true})).then(function(template) {
            if (angular.isArray(template)) {
                template = template[1];
            } else if (angular.isObject(template)) {
                template = template.data;
            }
            deferred.resolve(CreateModalFromHTML(template, scope, controller, afterCompileCallback, noFocus, backdrop, keyboard));
        });
        return deferred.promise;
    }
});

app.factory("CreateModalFromHTML", function($timeout, $compile, $q, $rootScope) {
    let activeModals = [];

    $rootScope.$on('dismissModals', function() {
        activeModals.forEach((modalScope)=> unregisterModal(modalScope));
    });

    function registerModal(modalScope) {
        activeModals.unshift(modalScope);
    }

    function unregisterModal(modalScope) {
        activeModals = activeModals.filter((activeModalScope)=> {
            if(modalScope == activeModalScope) {
                modalScope.dismiss();
                return false;
            }
            return true;
        });
    }

    return function(template, scope, controller, afterCompileCallback, noFocus, backdrop, keyboard) {
        var deferred = $q.defer();
        var newDOMElt = $(template);
        if (controller != null) {
            newDOMElt.attr("ng-controller", controller);
        }
        newDOMElt.addClass("ng-cloak");

        const $existingModal = $('div.modal-container');
        let stackedClass = "";
        let waitForTransition = 0;
        if ($existingModal.length>0) {
            $existingModal.addClass('aside').removeClass('restored'); //move aside any existing modal in case of stacking
            waitForTransition = 250;
            stackedClass = "new-stacked"
        }

        var wrapper = $("<div>").addClass("modal-container " + stackedClass).append(newDOMElt);
        $("body").append(wrapper);

        /* Now, compile the modal, set its scope, call the callback and show it */
        $timeout(function() {
            var newScope = scope.$new();
            $compile(newDOMElt)(newScope);

            var modalScope = angular.element(newDOMElt).scope();

            if (afterCompileCallback) {
                modalScope.$apply(afterCompileCallback(modalScope, newDOMElt));
            }
            newDOMElt.on('hidden', function(e) {
                if (e.target == newDOMElt.get(0)) {
                    unregisterModal(modalScope);
                    wrapper.remove();
                    modalScope.$destroy();
                    if (deferred != null) {
                        deferred.reject("modal hidden");
                        deferred = null;
                    }
                }
            });

            var prepareForModalStack = function () {
                $('div.modal-backdrop').addClass('modal-rollup').removeClass('non-see-through'); //mjt in the event of stacking a modal
                $("div.modal-container.new-stacked").addClass("modal-stacked-on-top").removeClass("new-stacked");
            }
            prepareForModalStack();

            if (backdrop) {
                newDOMElt.attr('data-backdrop', backdrop);
            }

            if (keyboard) {
                newDOMElt.attr('data-keyboard', keyboard);
            }

            newDOMElt.modal("show");
            $rootScope.$broadcast("dismissPopovers");

            modalScope.unwindModalStack = function (newDOMElt) {
                $('div.modal-backdrop.modal-rollup').removeClass('modal-rollup').click(modalScope.dismiss);
                $('div.modal-container.aside').removeClass('aside').addClass('restored'); //move aside any existing modal in case of stacking
            };
            modalScope.dismiss = function() {
                newDOMElt.modal("hide");
                if (deferred != null) {
                    deferred.reject("dismissed modal");
                    deferred = null;
                }
            };

            registerModal(modalScope);

            modalScope.resolveModal = function(value) {
                if (deferred != null) {
                    deferred.resolve(value);
                    deferred = null;
                }
                newDOMElt.modal("hide");
            };
            modalScope.$modalScope = modalScope;

            $(newDOMElt).on('hide.bs.modal', function (e) {
                if (modalScope && modalScope.canCloseModal && typeof modalScope.canCloseModal === 'function') {
                    if (!modalScope.canCloseModal()) {
                        e.preventDefault();
                        e.stopImmediatePropagation();
                        return false;
                    }
                }
                modalScope.unwindModalStack(newDOMElt);
            });

            modalScope.$on("dismissModal", modalScope.dismiss);

            if (!noFocus) {
                // the first form of the modal, should contain the modal-body in 99% of cases
                var firstForm = newDOMElt.find('form').first();
                // list of focusable elements we want to try, in order of preference
                var focusCandidateFinders = [];
                focusCandidateFinders.push(function() {
                    return firstForm.find('input[type="text"]').first();
                });
                focusCandidateFinders.push(function() {
                    return firstForm.find('button:submit').first();
                });
                focusCandidateFinders.push(function() {
                    return firstForm.find('button:button').first();
                });
                // if the modal has no form, or footer buttons are not in the form, look in the full modal
                focusCandidateFinders.push(function() {
                    return newDOMElt.find('input[type="text"]').first();
                });
                focusCandidateFinders.push(function() {
                    return newDOMElt.find('button:submit').first();
                });
                focusCandidateFinders.push(function() {
                    return newDOMElt.find('button:button').first();
                });
                focusCandidateFinders.push(function() {
                    return newDOMElt.find('.close').first();
                });

                var focusCandidate;
                for (var i = 0; i < focusCandidateFinders.length; i++) {
                    var focusCandidateFinder = focusCandidateFinders[i];
                    focusCandidate = focusCandidateFinder();
                    if (focusCandidate.length > 0) {
                        focusCandidate.focus();
                        // in some cases the element is disabled by a ng-disabled, and the focus behavior becomes a bit erratic
                        // so for safety we focus once more
                        $timeout(function() {
                            focusCandidate.focus();
                        });
                        break;
                    }
                }

                // in case the submit button is dangerous, prevent submit-on-enter
                if (firstForm.length > 0 && focusCandidate.hasClass('btn--danger')) { //NOSONAR: focusCandidate always initialized thanks to jquery first() specs
                    focusCandidate.bind("keydown keypress", function(event) {
                        if (event.which === 13) {
                            event.preventDefault();
                        }
                    });
                }
            }
        }, waitForTransition);

        return deferred.promise;
    };
});


/**
 * Create a custom body-attached DOM element within a new scope.
 * The new scope is fitted with a "dismiss" function, which destroys the DOM
 * element and the scope.
 */
app.factory("CreateCustomElementFromTemplate", ["$http", "$timeout", "$compile", "$templateCache", "$q", "$window",
    function($http, $timeout, $compile, $templateCache, $q, $window) {
        return function(location, scope, controller, afterCompileCallback, domInsertionCallback) {
            $q.when($templateCache.get(location) || $http.get(location, {cache: true})).then(function onSuccess(template) {
                if (angular.isArray(template)) {
                    template = template[1];
                } else if (angular.isObject(template)) {
                    template = template.data;
                }
                var newDOMElt = $(template);
                if (controller != null) {
                    newDOMElt.attr("ng-controller", controller);
                }

                if (domInsertionCallback != null) {
                    domInsertionCallback(newDOMElt);
                } else {
                    $("body").append(newDOMElt);
                }

                /* Now, compile the element, set its scope, call the callback */
                $timeout(function() {
                    var newScope = scope.$new();
                    $compile(newDOMElt)(newScope);
                    var newScope2 = angular.element(newDOMElt).scope();

                    if (afterCompileCallback) {
                        newScope2.$apply(afterCompileCallback(newScope2));
                    }
                    newScope2.$on("dismissModalInternal_", function() {
                        $timeout(function() {
                            newScope2.dismiss();
                        }, 0);
                    });
                    newScope2.dismiss = function() {
                        newDOMElt.remove();
                        newScope2.$destroy();
                    };
                    scope.$on("$destroy", newScope2.dismiss);
                });
            });
        };
    }
]);


/** Keeps a map of promises for static API calls */
app.factory("CachedAPICalls", function(DataikuAPI, Assert, $http, $rootScope) {
    return {
        processorsLibrary: DataikuAPI.shakers.getProcessorsLibrary().success(function(processors) {
            // Inject the doc link at this point so it is only done once.
            processors.processors.forEach(function(p) {
                if (p.docPage) {
                    p.help = p.help + "\n\nFor more info, <a target=\"_blank\" href=\""+
                    $rootScope.versionDocRoot + "preparation/processors/" + p.docPage + ".html"+
                    "\">please see the processor's reference</a>\n"
                }
            });
            return processors
        }),
        customFormulasFunctions: DataikuAPI.shakers.listCustomFormulasFunctions(),
        customFormulasReference: DataikuAPI.shakers.getCustomFormulasReference(),
        datasetTypes: DataikuAPI.datasets.get_types(),
        datasetCommonCharsets: DataikuAPI.datasets.get_common_charsets(),
        datasetFormatTypes: DataikuAPI.datasets.get_format_types(),
        flowIcons: $http.get("/static/dataiku/flow-iconset.json"),
        emojisTable: $http.get("/static/third/emoji.json").then(function(response) {
            Assert.trueish(response.data, 'No emoji returned');
            Assert.trueish(angular.isArray(response.data), 'Emojis were not returned as an array');
            const emojisTable = {};
            response.data.forEach(function(x) {
                emojisTable[x['sn']] = x['code'].split('-').map(x => '&#x' + x + ';').join('');
            });
            return emojisTable;
        })
    };
});


app.service('ComputablesService', function(CreateModalFromTemplate, DataikuAPI, TaggableObjectsUtils, Dialogs) {
    this.clear = function(scope, taggableItems) {
        return CreateModalFromTemplate("/templates/taggable-objects/clear-data-modal.html", scope, null, function(modalScope) {
            modalScope.taggableItems = taggableItems;
            modalScope.itemsType = TaggableObjectsUtils.getCommonType(taggableItems, it => it.type);

            modalScope.confirm = function() {
                DataikuAPI.taggableObjects.clear(taggableItems).success(function(data) {
                    if (data.anyMessage && !data.success) {
                        modalScope.dismiss();
                        Dialogs.infoMessagesDisplayOnly(scope, "Clear result", data);
                    } else {
                        modalScope.resolveModal(data);
                    }
                }).error(setErrorInScope.bind(scope));
            }
        });
    };
});


app.service('DatasetsService', function($rootScope, $q, DataikuAPI, Logger, Notification, ComputablesService, FutureProgressModal, CreateModalFromTemplate) {
    const svc = this;

    svc.listPerProject = {};
    function ensureListPerProject(projectKey) {
        if (svc.listPerProject[projectKey] == null) {
            svc.updateProjectList(projectKey);
            svc.listPerProject[projectKey] = []; // this prevents multiple calls to updateProjectList()
        }
    }

    svc.listPromise = function(projectKey) {
        return DataikuAPI.datasets.list(projectKey);
    };

    svc.updateProjectList = function(projectKey) {
        return DataikuAPI.datasets.listNames(projectKey).success(function(data) {
            svc.listPerProject[projectKey] = data;
        });
    }

    svc.isRenamingValid = function(projectKey, oldName, newName) {
        if (!newName) return false;
        if (oldName == newName) return true;
        if (!newName.match(/^[\w_]+$/)) return false;

        ensureListPerProject(projectKey);
        for (let k in svc.listPerProject[projectKey]) {
            if (svc.listPerProject[projectKey][k].toLowerCase() == newName.toLowerCase()) {
                return false;
            }
        }
        return true;
    };

    svc.cleanupAndTransmogrify = function(projectKey, name) {
        name = name.replace(/[^A-z0-9_]/, "_");
        ensureListPerProject(projectKey);

        let cur = name;
        let i = 0;
        while (true) {
            if (!(cur in Object.keys(svc.listPerProject[projectKey]))) {
                return cur
            }
            cur = name + "_" + (++i)
        }
    };

    svc.clear = function(scope, projectKey, datasetName) {
        return ComputablesService.clear(scope, [{
            type: 'DATASET',
            projectKey: projectKey,
            id: datasetName,
            displayName: datasetName
        }]);
    };

    svc.refreshSummaries = function(scope, selectedItems, computeRecords = true, forceRecompute = false) {
        const deferred = $q.defer();
        DataikuAPI.datasets.refreshSummaries(selectedItems, computeRecords, forceRecompute).success(function(data) {
            FutureProgressModal.show(scope, data, "Refresh datasets status")
                .then(data => deferred.resolve(data), data => deferred.reject(data));
        }).error(setErrorInScope.bind(scope));
        return deferred.promise;
    };

    svc.setVirtualizable = function(scope, selectedItems, virtualizable) {
        const datasets = selectedItems.filter(it => it.type == 'DATASET');
        return DataikuAPI.datasets.setVirtualizable(datasets, !!virtualizable)
            .error(setErrorInScope.bind(scope));
    };

    svc.startSetAutoCountOfRecords = function(selectedItems) {
        return CreateModalFromTemplate("/templates/datasets/set-auto-count-of-records-modal.html", $rootScope, null, function(modalScope) {
            modalScope.autoCountOfRecords = false;

            modalScope.ok = function(vitualizable) {
                svc.setAutoCountOfRecords(selectedItems, modalScope.autoCountOfRecords)
                    .then(modalScope.resolveModal, setErrorInScope.bind(modalScope));
            };
        });
    };

    svc.setAutoCountOfRecords = function(selectedItems, autoCountOfRecords) {
        return DataikuAPI.datasets.setAutoCountOfRecords(selectedItems, autoCountOfRecords);
    };

    Notification.registerEvent("datasets-list-changed", function(evt, message) {
        Logger.info("Datasets list changed, updating");
        //svc.updateProjectList(message.projectKey);
        delete svc.listPerProject[message.projectKey]; // just invalidate
    });
});

/** Cached access to datasets information */
app.factory("DatasetInfoCache", function($stateParams, DataikuAPI, $q, Notification, Logger) {
    // Cache for results of datasets/get
    var simpleCache = {}
    Notification.registerEvent("websocket-status-changed", function() {
        Logger.info("Websocket status change, dropping dataset cache");
        simpleCache = {};
    });
    Notification.registerEvent("datasets-list-changed", function(evt, message) {
        Logger.info("Datasets list changed, dropping cache for ", message.projectKey);
        delete simpleCache[message.projectKey];
    });
    var svc = {
        getSimple: function(projectKey, name) {
            var projectCache = simpleCache[projectKey];
            if (projectCache != null) {
                var data = projectCache[name];
                if (data != null) {
                    Logger.info("Cache hit: " + projectKey + "." + name);
                    return $q.when(data);
                }
            } else {
                simpleCache[projectKey] = {};
            }
            Logger.info("Cache miss: " + projectKey + "." + name);
            return DataikuAPI.datasets.get(projectKey, name, $stateParams.projectKey).then(function(data) {
                simpleCache[projectKey][name] = data.data;
                return data.data;
            });
        }
    }
    return svc;
});


/** This service maintains a cache of recipe names per project */
app.factory("RecipesService", ["DataikuAPI", "$q", "Notification", "Logger", function(DataikuAPI, $q, Notification, Logger) {
    var ret = {}
    ret.listPerProject = {}

    Notification.registerEvent("recipes-list-changed", function(evt, message) {
        Logger.info("Recipes list changed, updating");
        ret.updateProjectList(message.projectKey);
    });

    ret.listPromise = function(projectKey) {
        return DataikuAPI.flow.recipes.list(projectKey);
    };

    ret.updateProjectList = function(projectKey) {
        var deferred = $q.defer();
        ret.listPromise(projectKey).success(function(data) {
            ret.listPerProject[projectKey] = $.map(data, function(recipe) {
                return recipe.name;
            });
            deferred.resolve();
        });
        return deferred.promise;
    };

    ret.isRenamingValid = function(projectKey, oldName, newName) {
        if (!newName) return false;
        if (oldName == newName) return true;

        if (!ret.listPerProject[projectKey]) return true;
        for (var k in ret.listPerProject[projectKey]) {
            if (ret.listPerProject[projectKey][k].toLowerCase() == newName.toLowerCase()) {
                return false;
            }
        }
        return true;
    };

    return ret;
}]);


app.service("extractInsightChart", function() {
    return function(chartScope) {
        var retainedFields = [
            "genericMeasures",
            "dimensions",
            "type",
            "includeZero",
            "yAxisMode",
            "xAxisMode",
            "computeMode",
            "filters",
            "colorMeasures",
            "sizeMeasures",
            "measures",
            "typedMeasures",
            "hexbin",
            "hexbinRadius",
            "chartOptions",
            "includeZero",
            "smoothing"
        ];
        var chart = {};
        for (var i = 0; i < retainedFields.length; i++) {
            var fieldKey = retainedFields[i];
            chart[fieldKey] = chartScope.data[fieldKey];
        }
        //return chart;
        return angular.copy(chartScope.data);
    }
});


// Queue
//
// var lockable = Queue();
// lockable.exec(function() { alert('A'); }); // Executed right now
// var unlock = lockable.lock(); // Lock the object
// lockable.exec(function() { alert('B'); }); // Not executed
// lockable.exec(function() { alert('C'); }); // Not executed
// unlock(); // Execute alert('A') & alert('B');
//
// The queue can be tied to a promise
// lockable.lockOnPromise(DataikuAPI.xxx(yyy,zzz).success(function() {
//     ...
// }));
//
app.factory("Queue", function() {

    return function() {

        var semaphore = 0;
        var queue = [];
        var destroyed = false;
        var scopeUnregisterer = undefined;
        var inside = false;

        var processQueue = function() {
            while (!destroyed && semaphore == 0 && queue.length > 0) {
                if (!inside) {
                    try {
                        inside = true;
                        queue.splice(0, 1)[0]();
                    } finally {
                        inside = false;
                    }
                } else {
                    break;
                }
            }
        };

        var exec = function(fn) {
            if (fn && !destroyed) {
                queue.push(fn);
                processQueue();
            }
        };

        var destroy = function() {
            destroyed = true;
            queue = [];
        };

        var wrap = function(func) {
            return function() {
                var args = arguments;
                exec(function() {
                    if (func) {
                        func.apply(null, args);
                    }
                });
            };
        };

        var lock = function() {
            if (destroyed) {
                return;
            }
            semaphore++;
            var unlocked = false;
            return function() {
                if (!unlocked) {
                    semaphore--;
                    unlocked = true;
                    processQueue();
                }
            };
        };

        var ret = {

            withScope: function(scope) {
                if (scopeUnregisterer) {
                    scopeUnregisterer();
                }
                if (scope) {
                    scopeUnregisterer = scope.$on('$destroy', destroy);
                }
                return ret;
            },
            locked: function() {
                return destroyed || semaphore > 0;
            },
            exec: function(fn) {
                exec(fn);
            },
            wrap: function(fn) {
                return wrap(fn);
            },
            lockOnPromise: function(promise) {
                if (promise && promise['finally']) {
                    var unlocker = lock();
                    promise['finally'](function() {
                        unlocker();
                    });
                }
                return promise;
            },
            lock: function() {
                return lock();
            }
        };
        return ret;
    };

});

// MonoFuture
//
// - Wait for future result
// - Abort the previous future as soon as a new one is started
//
// Usage :
//
// var monoFuture = MonoFuture(scope); // If a scope is passed, life time of monofuture = life time of the scope
// monoFuture.exec(DataikuAPI.xxx.getYYYFuture(zzz)).success(function(data) {
// ...
// }).update(function(data) {
// ...
// }).error(...);
//
//  OR by wrapping the DataikuAPI function directly
//
//  var apiCall = MonoFuture().wrap(DataikuAPI.xxx.getYYYFuture);
//  apiCall(zzz).success(...);
//
//
//
app.factory("MonoFuture", ["$q", "DataikuAPI", "Throttle", function($q, DataikuAPI, Throttle) {

    return function(scope) {

        var promises = [];
        var destroyed = false;

        // Refresh the state of the last promise
        var refreshFutureState = Throttle().withDelay(1000).wrap(function() {

            updateInternalState();

            if (promises.length > 0) {
                var last = promises[promises.length - 1];
                if (!last.hasResult && !last.waiting) {
                    last.waiting = true;
                    DataikuAPI.futures.getUpdate(last.id).success(function(data, status, headers) {

                        last.waiting = false;
                        last.result = {data: data, status: status, headers: headers};
                        if (data.hasResult) {
                            last.hasResult = true;
                        } else {
                            if (!last.aborted) {
                                last.deferred.notify(last.result);
                            }
                            refreshFutureState();
                        }

                        updateInternalState();

                    }).error(function(data, status, headers) {

                        last.failed = true;
                        last.result = {data: data, status: status, headers: headers};
                        last.hasResult = true;
                        last.waiting = false;

                        updateInternalState();
                    });
                }
            }
        });

        // Update current state
        var updateInternalState = function() {
            // Abort all abortable futures & remove them
            var loop = false;
            do {
                loop = false;
                for (var i = 0; i < promises.length; i++) {
                    var isLast = i == (promises.length - 1);
                    var promise = promises[i];
                    promise.aborted |= !isLast;
                    if (promise.aborted && !promise.waiting) {

                        // We have the future id, and not the result meaning that the future is running
                        if (promise.id && !promise.hasResult) {
                            // Abort me
                            DataikuAPI.futures.abort(promise.id);
                        }

                        promises.splice(i, 1);
                        loop = true;
                        break;
                    }
                }
            } while (loop);

            // Check last one : finished?
            if (promises.length > 0) {
                var last = promises[promises.length - 1];
                if (last.hasResult && !last.aborted) {
                    promises.splice(promises.length - 1, 1);
                    if (last.failed) {
                        last.deferred.reject(last.result);
                    } else if (last.result && last.result.data && last.result.data.aborted) {
                        // The future has been aborted by someone
                        last.deferred.reject(last.result);
                    } else {
                        last.deferred.resolve(last.result);
                    }
                }
            }
        };

        var fakePromise = function() {
            var promise = $q.defer().promise;
            promise.success = function() {
                return promise;
            };
            promise.error = function() {
                return promise;
            };
            promise.update = function() {
                return promise;
            };
            return promise;
        };

        var exec = function(apiPromise) {
            if (destroyed || !apiPromise || !apiPromise.success) {
                return fakePromise();
            }
            var deferred = $q.defer();
            var promise = {
                id: null,
                hasResult: false,
                result: undefined,
                deferred: deferred,
                aborted: false,
                failed: false,
                waiting: true,
                noSpinner: apiPromise.noSpinner
            };
            promises.push(promise);
            updateInternalState();
            apiPromise.success(function(data, status, headers) {
                promise.waiting = false;
                promise.result = {data, status, headers};
                if (data) {
                    promise.id = data.jobId;
                }
                if (data.hasResult) {
                    promise.hasResult = true;
                } else {
                    refreshFutureState();
                }
                updateInternalState();
            }).error(function(data, status, headers) {
                promise.failed = true;
                promise.result = {data, status, headers};
                if (data) {
                    promise.id = data.jobId;
                }
                promise.hasResult = true;
                promise.waiting = false;
                updateInternalState();
            });

            deferred.promise.success = function(fn) {
                deferred.promise.then(function(data) {
                    fn(data.data, data.status, data.headers);
                });
                return deferred.promise;
            };

            deferred.promise.error = function(fn) {
                deferred.promise.then(null, function(data) {
                    fn(data.data, data.status, data.headers);
                });
                return deferred.promise;
            };

            deferred.promise.update = function(fn) {
                deferred.promise.then(null, null, function(data) {
                    fn(data.data, data.status, data.headers);
                });
                return deferred.promise;
            };

            deferred.promise.noSpinner = function() {
                promises.forEach(function(p) {
                    if (p.noSpinner) p.noSpinner();
                });
                return deferred.promise;
            };

            return deferred.promise;
        };

        var abort = function() {
            if (promises.length > 0) {
                promises[promises.length - 1].aborted = true;
                updateInternalState();
            }
        };

        var destroy = function() {
            abort();
            destroyed = true;
        };

        const active = function() {
            return promises.length > 0;
        };

        if (scope && scope.$on) {
            scope.$on('$destroy', destroy);
        }

        return {

            exec: exec,
            wrap: function(func) {
                return function() {
                    return exec(func.apply(func, arguments));
                };
            },
            abort: abort,
            destroy: destroy,
            active: active
        };
    };
}]);

// Provide a way to take/release the spinner
//
// Usage:
//
//  var spinner = SpinnerService();   // The spinner is permanently released automatically when scope is destroyed
//  spinner.acquire();
//  /* spinning... */
//  spinner.release(); // It's safe to release it multiple time
//
//
//  The spinner can be tied to a promise like that:
//  SpinnerService.lockOnPromise(promise);
app.factory("SpinnerService", ["$rootScope", function($rootScope) {
    let fakeReq = {}; // Doesn't matter what this object is, it's never used anyway...
    let actives = 0; // Number of active spinners
    let scopeUnregisterer = null;

    // TODO : implement this properly
    // (currently it's  is a little hack around $rootScope.httpRequests)
    function update() {
        // Reset
        let idx = $rootScope.httpRequests.indexOf(fakeReq);
        if (idx != -1) {
            $rootScope.httpRequests.splice(idx, 1);
        }
        // Activate
        if (actives > 0) {
            $rootScope.httpRequests.push(fakeReq);
        }
    }

    function fnr() {
        let acquired = false;
        let destroyed = false;
        function acquire() {
            if (destroyed) {
                return;
            }
            if (!acquired) {
                acquired = true;
                actives++;
                update();
            }
        }
        function release() {
            if (acquired) {
                acquired = false;
                actives--;
                update();
            }
        }
        function destroy() {
            destroyed = true;
            release();
        }

        const ret = {
            acquire: acquire,
            release: release,
            destroy: destroy,
            withScope: function(scope) {
                if (scopeUnregisterer) {
                    scopeUnregisterer();
                }
                if (scope) {
                    scopeUnregisterer = scope.$on('$destroy', destroy);
                }
                return ret;
            }
        };
        return ret;
    };

    fnr.lockOnPromise = function(promise) {
        if (promise && promise['finally']) {
            var lock = fnr();
            lock.acquire();
            promise['finally'](function() {
                lock.release();
            });
        }
    }
    return fnr;
}]);


// Ability to merge watch calls into one (old value is kept, new value is updated)
function wrapWatchHelper(ctrl, fn) {
    var isSet = false;
    var oldVal = undefined;
    var newVal = undefined;

    var trueExec = ctrl.wrap(function() {
        if (!angular.equals(newVal, oldVal)) {
            isSet = false;
            fn(newVal, oldVal);
        }
    });

    return function(nv, ov) {
        if (isSet) {
            newVal = angular.copy(nv);
        } else {
            isSet = true;
            oldVal = angular.copy(ov);
            newVal = angular.copy(nv);
        }
        trueExec();
    };
};

// Debounce
// API is similar to Throttle but it implements a behavior similar to the "onSmartChange" directive as a service
//
// var fn = Debounce
//    .withDelay(500,1000)   // initial delay = 500ms, then delay = 1000ms
//    .withSpinner(true)
//    .wrap(function() {
//        console.log('hello');
//     });
//
// Example 1:
//
// fn(); // Will be executed in 500ms
//
// Example 2 :
// fn();  // Will be dropped
// [sleep less than 100ms]
// fn();  // Will be executed in 1000s
//
//
app.factory("Debounce", ["SpinnerService", "$rootScope", function(SpinnerService, $rootScope) {

    return function(scope) {

        var initialDelay = 0;
        var delay = 0;
        var destroyed = false;
        var spinner = SpinnerService();
        var enableSpinner = false;
        var stdTimer = null;
        var initTimer = null;
        var scopeUnregisterer = null;

        var exec = function(func) {

            if (destroyed) {
                return;
            }

            var wrapped = function debounceExecWrapped() {
                var toBeExec;
                if (func) {
                    spinner.release();
                    toBeExec = func;
                    func = null;
                }
                if (toBeExec) {
                    $rootScope.$apply(function debounceExec() {
                        toBeExec();
                    });
                } else {
                    // Important because the activity state may have changed!
                    $rootScope.$digest();
                }
            };

            var isFirst = true;
            if (stdTimer) {
                clearTimeout(stdTimer.key);
                stdTimer = null;
                isFirst = false;
            }

            if (initTimer) {
                clearTimeout(initTimer.key);
                initTimer = null;
                isFirst = false;
            }

            if (enableSpinner) {
                spinner.acquire();
            }

            if (isFirst) {

                initTimer = {
                    key: setTimeout(function() {
                        initTimer = null;
                        wrapped();
                    }, initialDelay)
                };

                stdTimer = {
                    key: setTimeout(function() {
                        stdTimer = null;
                        wrapped();
                    }, delay)
                };

            } else {

                stdTimer = {
                    key: setTimeout(function() {
                        stdTimer = null;
                        wrapped();
                    }, delay)
                };
            }
        }

        var abort = function() {
            spinner.release();
            if (initTimer) {
                clearTimeout(initTimer.key);
                initTimer = null;
            }
            if (stdTimer) {
                clearTimeout(stdTimer.key);
                stdTimer = null;
            }
        };

        var wrap = function debounceWrap(func) {
            return function debounceWrapped() {
                var args = arguments;
                exec(function debounceWrappedCB() {
                    func.apply(null, args);
                });
            };
        };

        var destroy = function() {
            console.info("Destroy debounce on scope", scope); // NOSONAR
            destroyed = true;
            abort();
        };

        var ret = {
            exec: function(func) {
                exec(func);
            },
            wrap: function(func) {
                return wrap(func);
            },
            wrapWatch: function(fn) {
                return wrapWatchHelper(ret, fn);
            },
            active: function() {
                return !!(initTimer || stdTimer);
            },
            abort: function() {
                abort();
            },
            destroy: function() {
                destroy();
            },
            withDelay: function(newInitialDelay, newDelay) {
                delay = newDelay;
                initialDelay = newInitialDelay;
                return ret;
            },
            withSpinner: function(enabled) {
                enableSpinner = enabled;
                return ret;
            },
            withScope: function(scope) {
                if (scopeUnregisterer) {
                    scopeUnregisterer();
                }
                if (scope) {
                    scopeUnregisterer = scope.$on('$destroy', destroy);
                }
                spinner.withScope(scope);
                return ret;
            }
        };
        return ret;

    };
}]);


// Limit the maximum update frequency to 1/delay
// Some calls will be dropped in order to limit update frequency
//
// Usage:
//
// var throttle = Throttle().withScope(scope).withDelay(1000);  // If a scope is passed, life time of monofuture = life time of the scope
//
// throttle.exec(func1); // Executed now (= after the current event loop)
// throttle.exec(func2); // Dropped (because of func3)
// throttle.exec(func3); // Dropped (because of func4)
// throttle.exec(func4); // Executed 1 second later
//
// It's also possible to permanently wrap a function :
// myFunc = Throttle().wrap(function() {
//    ...
// });
// myFunc(); // executed (= after the current event loop)
// myFunc(); // dropped
// myFunc(); // delayed
//
app.factory("Throttle", ["$timeout", function($timeout) {

    return function() {

        var delay = 0;
        var currentlyWaitingOn = null;
        var storedFunc = null;
        var destroyed = false;
        var scopeUnregisterer = null;

        var waitCallback = function() {
            var toBeExec;
            if (storedFunc) {
                toBeExec = storedFunc;
                storedFunc = null;
                currentlyWaitingOn = $timeout(waitCallback, delay);
            } else {
                currentlyWaitingOn = null;
            }
            // Re-entrant safe
            if (toBeExec) {
                toBeExec();
            }
        }
        var exec = function(func) {
            if (destroyed) {
                return;
            }
            if (!func) {
                func = function() {
                };
            }
            if (currentlyWaitingOn) {
                storedFunc = func;
                // It will be called later :)
            } else {
                // Execute now
                // ... and setup a timeout to drop further calls for 'delay' ms
                $timeout(func);
                storedFunc = null;
                currentlyWaitingOn = $timeout(waitCallback, delay);
            }
        };

        var wrap = function(func) {
            return function() {
                var args = arguments;
                exec(function() {
                    func.apply(null, args);
                });
            };
        };

        var abort = function() {
            if (currentlyWaitingOn) {
                $timeout.cancel(currentlyWaitingOn);
                currentlyWaitingOn = null;
            }
            storedFunc = null;
        };

        var destroy = function() {
            abort();
            destroyed = true;
        };


        var ret = {
            exec: function(func) {
                exec(func);
            },
            wrap: function(func) {
                return wrap(func);
            },
            wrapWatch: function(fn) {
                return wrapWatchHelper(ret, fn);
            },
            active: function() {
                return !!storedFunc;
            },
            abort: function() {
                abort();
            },
            destroy: function() {
                destroy();
            },
            withDelay: function(newDelay) {
                delay = newDelay;
                return ret;
            },
            withScope: function(scope) {
                if (scopeUnregisterer) {
                    scopeUnregisterer();
                }
                if (scope) {
                    scopeUnregisterer = scope.$on('$destroy', destroy);
                }
                return ret;
            }
        };
        return ret;
    };

}]);


app.factory("DKUtils", function($rootScope, $state, $stateParams, $timeout, Logger) {
    return {
        /* Reflows at current digest */
        reflowNow: function() {
            $rootScope.$broadcast("reflow");
        },

        /* Reflows at next digest */
        reflowNext: function() {
            $timeout(function() {
                $rootScope.$broadcast("reflow")
            }, 0);
        },
        /* It's probably bad if you need this */
        reflowLater: function() {
            $timeout(function() {
                Logger.info("delayed reflow");
                $rootScope.$broadcast("reflow")
            }, 400);
        },
        /* Reload current state. Works around broken $state.reload() */
        reloadState: function() {
            $state.transitionTo($state.current,
                angular.copy($stateParams),
                {reload: true, inherit: true, notify: true});
        }
    }
});


app.factory("PluginsService", function($rootScope, DataikuAPI, WT1, StateUtils) {
    const namingConvention = '^[a-z][a-z0-9-]*$';
    const isValidComponentId = function(newComponentId, pluginId, pluginComponentsOfSameType) {
        if (!newComponentId) return false;
        if (newComponentId.startsWith(pluginId)) return false;
        return !pluginComponentsOfSameType.some(_ => _.id ==  newComponentId
                                              || (pluginId + "_" + _.id) === newComponentId
                                              || _.id === (pluginId + "_" + newComponentId)
                                              || (pluginId + "_" + _.id) === (pluginId + "_" + newComponentId));
    };
    var svc = {
        namingConvention: namingConvention,
        transformToDevPlugin: function(modalScope, convertAPIFunc, getAPICallParams, eventWT1Name, componentType, originalType) {
            DataikuAPI.plugindev.list().success(function(data) {
                modalScope.devPlugins = data;
            }).error(setErrorInScope.bind(modalScope));

            modalScope.convert = {
                mode: 'NEW',
                pattern: namingConvention
            };

            modalScope.isIdValid = function() {
                if (modalScope.convert.mode === 'EXISTING') {
                    if (!modalScope.convert.targetPluginId) return false;
                    const plugin = modalScope.devPlugins.find(_ => _.desc.id === modalScope.convert.targetPluginId);
                    return isValidComponentId(modalScope.convert.targetFolder,
                                                            modalScope.convert.targetPluginId,
                                                            plugin.content[componentType]);
                }
                if (!modalScope.convert.newPluginId) return false;
                return isValidComponentId(modalScope.convert.targetFolder,
                                                        modalScope.convert.newPluginId,
                                                        []);
            };

            modalScope.go = function() {
                resetErrorInScope(modalScope);
                convertAPIFunc(...getAPICallParams(modalScope)).success(function(data) {
                    WT1.event(eventWT1Name, {original: originalType});
                    modalScope.reloadPluginConfiguration();
                    StateUtils.go.pluginEditor(data.pluginId, data.relativePathToOpen);
                }).error(setErrorInScope.bind(modalScope));
            };
        },
        isValidComponentId: isValidComponentId,
        getPluginDesc(pluginId) {
            return $rootScope.appConfig.loadedPlugins.find(x => x.id == pluginId);
        },
        isPluginLoaded: function(pluginId) {
            var i, plugin;
            for (i = 0; i < $rootScope.appConfig.loadedPlugins.length; i++) {
                plugin = $rootScope.appConfig.loadedPlugins[i];
                if (plugin.id == pluginId) return true;
            }
            return false;
        },
        getDatasetLoadedDesc : function(datasetType) {
            return $rootScope.appConfig.customDatasets.find(x => x.datasetType == datasetType);
        },
        getFSProviderLoadedDesc : function(fsProviderType) {
            return $rootScope.appConfig.customFSProviders.find(x => x.fsProviderType == fsProviderType);
        },
        getRecipeLoadedDesc : function(recipeType) {
            return $rootScope.appConfig.customCodeRecipes.find(x => x.recipeType == recipeType);
        },
        getOwnerPluginDesc: function(loadedDesc) {
            if (loadedDesc != null) {
                return $rootScope.appConfig.loadedPlugins.find(x => x.id == loadedDesc.ownerPluginId);
            } else {
                return null; // plugin most likely removed
            }
        },
        getRecipeIcon: function(recipeType) {
            var loadedDesc = svc.getRecipeLoadedDesc(recipeType);
            if (loadedDesc && loadedDesc.desc && loadedDesc.desc.meta && loadedDesc.desc.meta.icon) {
                return loadedDesc.desc.meta.icon;
            } else {
                var pluginDesc = svc.getOwnerPluginDesc(loadedDesc);
                if (pluginDesc) {
                    return pluginDesc.icon || "icon-visual_prep_sync_recipe";
                } else {
                    return "icon-visual_prep_sync_recipe"; // plugin has been removed
                }
            }
        },
        getDatasetIcon: function(datasetType) {
            var loadedDesc = svc.getDatasetLoadedDesc(datasetType);
            if (loadedDesc == null) {
                loadedDesc = svc.getFSProviderLoadedDesc(datasetType);
            }
            if (loadedDesc == null ) {
                return "icon-question-sign";
            }
            if (loadedDesc && loadedDesc.desc && loadedDesc.desc.meta && loadedDesc.desc.meta.icon) {
                return loadedDesc.desc.meta.icon;
            } else {
                var pluginDesc = svc.getOwnerPluginDesc(loadedDesc);
                if (pluginDesc) {
                    return pluginDesc.icon || "icon-puzzle-piece";
                } else {
                    return "icon-puzzle-piece"; // plugin has been removed
                }
           }
        },
        getDatasetLabel : function(datasetType) {
            var loadedDesc = svc.getDatasetLoadedDesc(datasetType);
            if (loadedDesc == null) {
                loadedDesc = svc.getFSProviderLoadedDesc(datasetType);
            }
            if (loadedDesc == null ) return null;

            if (loadedDesc.desc && loadedDesc.desc.meta && loadedDesc.desc.meta.label) {
                return loadedDesc.desc.meta.label;
            } else {
               return datasetType;
            }
        }
    };
    return svc;
});


app.factory("PluginConfigUtils", function() {
    return {
        setDefaultValues: function(params, customConfig) {
            if (!customConfig) {
                return;
            }
            params.forEach(function(param) {
                if (customConfig[param.name] === undefined) {
                    if (param.defaultValue) {
                        // the type is not checked, so if the default is not of the right type, strange things can happen
                        customConfig[param.name] = param.defaultValue;
                    } else if (param.type == 'BOOLEAN') {
                        customConfig[param.name] = false;
                    } else if (param.type == 'INT' || param.type == 'DOUBLE') {
                        customConfig[param.name] = 0;
                    } else if (param.type == 'MAP') {
                        customConfig[param.name] = {};
                    } else if (param.type == 'KEY_VALUE_LIST') {
                        customConfig[param.name] = [];
                    } else if (param.type == 'ARRAY') {
                        customConfig[param.name] = [];
                    } else if (param.type == 'OBJECT_LIST') {
                        customConfig[param.name] = [];
                    }
                }
            });
        }
    }
});


app.factory("FutureProgressUtils", function() {
    var svc = {
        getTotalProgressPercentage: function(progress) {
            var percentage = 0;
            var fractionOf = 100;
            if (progress && progress.states) {
                angular.forEach(progress.states, function(state) {
                    if (state.target > 0) {
                        fractionOf = fractionOf / (state.target + 1);
                        percentage += fractionOf * state.cur;
                    }
                });
            }
            return percentage;
        }
    }
    return svc;
})

// Store large things, and give them a unique ID. It's backed by a very small LRU cache, and its purpose is
// to overcome the limitations of $stateParams when trying to pass big data in the URL
app.factory("BigDataService", ['$cacheFactory', function($cacheFactory) {
    var cache = $cacheFactory('BigDataServiceCache', {
        number: 20
    });
    return {
        store: function(bigdata) {
            var id = generateRandomId(10);
            cache.put(id, {data: bigdata});
            return id;
        },
        fetch: function(id) {
            var val = cache.get(id);
            if (!val) {
                return undefined;
            }
            return val.data;
        }
    };
}]);


app.factory("SQLExplorationService", ['$rootScope', '$cacheFactory', '$q', '$stateParams', 'Logger', 'DataikuAPI',
            function($rootScope, $cacheFactory, $q, $stateParams, Logger, DataikuAPI) {

    var cache = $cacheFactory('SQLExplorationServiceCache', {
        number: 50
    });

    var sep = '^~\n$* \\#';

    function connectionKey(connectionName) {
        return 'CNX' + sep + connectionName + sep;
    }

    function tableKey(projectKey, connection, schema, table) {
        if (!schema) {
            schema = '';
        }
        return 'TBL' + sep + schema + sep + table + sep + connection + sep + projectKey;
    }

    function listFieldsForTable(connection, table, projectKey) {
        var deferred = $q.defer();

        var key = tableKey(projectKey, connection, table.schema, table.table);
        var cached = cache.get(key);
        if (cached) {
            deferred.resolve(cached);
            Logger.info("Loaded fields of table " + table.table + " from cache");
        } else {
            DataikuAPI.connections.listSQLFields(connection, [table], projectKey).success(function(data) {
                cache.put(key, data);
                deferred.resolve(data);
                Logger.info("Loaded fields of table " + table.table + " from backend");
            }).error(setErrorInScope.bind($rootScope));
        }

        return deferred.promise;

    }

    return {
        listTables: function(connectionName, projectKey) {
            var deferred = $q.defer();
            var id = connectionKey(connectionName) + '__all__' + projectKey;
            var cached = cache.get(id);

            if (cached) {
                deferred.resolve(cached);
                Logger.info("Loaded tables list for connection " + connectionName + " from cache");
            } else {
                DataikuAPI.connections.listSQLTables(connectionName, projectKey).success(function(data) {
                    cache.put(id, data);
                    deferred.resolve(angular.copy(data));
                    Logger.info("Loaded tables list for connection " + connectionName + " from backend");
                }).error(setErrorInScope.bind($rootScope));
            }
            return deferred.promise;
        },
        listTablesFromProject: function(connectionName, projectKey) {
            var deferred = $q.defer();
            var id = connectionKey(connectionName) + '__fromProject__' + projectKey;
            var cached = cache.get(id);

            if (cached) {
                deferred.resolve(cached);
                Logger.info("Loaded tables list for connection " + connectionName + " and projectKey " + projectKey + " using cache");
            } else {
                DataikuAPI.connections.listSQLTablesFromProject(connectionName, projectKey).success(function(data) {
                    cache.put(id, data);
                    deferred.resolve(angular.copy(data));
                    Logger.info("Loaded tables list for connection " + connectionName + " and projectKey " + projectKey + " from backend");
                }).error(setErrorInScope.bind($rootScope));
            }
            return deferred.promise;
        },
        clearCache: function() {
            cache.removeAll();
        },
        listFields: function(connectionName, tables) {
            var promises = [];
            for (var i = 0; i < tables.length; i++) {
                promises.push(listFieldsForTable(connectionName, tables[i], $stateParams.projectKey));
            }
            var deferred = $q.defer();
            $q.all(promises).then(function(results) {
                var out = [];
                for (var i in results) {
                    out = out.concat(results[i]);
                }
                deferred.resolve(angular.copy(out));
            });
            return deferred.promise;
        }
    };
}]);


app.factory("SmartId", function($stateParams) {
    return {
        create: function(id, contextProjectKey) {
            if (contextProjectKey == $stateParams.projectKey) {
                return id;
            } else {
                return contextProjectKey + "." + id;
            }
        },

        resolve: function(smartId, contextProject) {
            if (contextProject === undefined) {
                contextProject = $stateParams.projectKey
            }
            if (smartId && smartId.indexOf(".") > 0) {
                var chunks = smartId.split(".");
                return {projectKey: chunks[0], id: chunks[1]}
            } else {
                return {projectKey: contextProject, id: smartId};
            }
        },

        fromRef: function(smartObjectRef, contextProject) {
            if (contextProject === undefined) {
                contextProject = $stateParams.projectKey
            }
            if (smartObjectRef.objectType == 'PROJECT') {
                return smartObjectRef.objectId;
            }
            if (!smartObjectRef.projectKey || !smartObjectRef.projectKey.length || smartObjectRef.projectKey == contextProject) {
                return smartObjectRef.objectId;
            } else {
                return smartObjectRef.projectKey + "." + smartObjectRef.objectId;
            }
        },

        fromTor: function(tor, contextProject) {
            if (contextProject === undefined) {
                contextProject = $stateParams.projectKey
            }
            if (tor.taggableType == 'PROJECT') {
                return tor.id;
            }
            if (!tor.projectKey || !tor.projectKey.length || tor.projectKey == contextProject) {
                return tor.id;
            } else {
                return tor.projectKey + "." + tor.id;
            }
        }
    }
});


app.service("FeatureNameUtils", function($filter, Fn) {

    /*
     Returns an object with :
     .elements, an array of strings representing
     consecutive elements of processed the feature name.
     .isCode, an array of booleans with same length indicating whether the corresponding
     element should be treated as "code"
     .value, an optional value for the feature. Defaults to null.
     .operator, the operator describing the operation when there is a value. Defaults to null.
     .no_operator, the inverse operator. Defaults to null.
     */
    var getAsElements = function(input, asHtml) {
        if (asHtml === undefined) {
            asHtml = false;
        }
        if (input == null) {
            input = "";
        }
        // Formatting
        var esc = asHtml ? $filter('escapeHtml') : Fn.SELF;
        var code = [];
        var els = [];
        var value = null, rawValue = null;
        var operator = null;
        var no_operator = null;
        var type = null;

        var addCode = function(c) {
            code.push(true);
            els.push(esc(c));
        };

        var addText = function(c) {
            code.push(false);
            els.push(esc(c));
        };

        var match;
        if (match = input.match(/^dummy:([^:]+):(.*)/)) {
            addCode(match[1]);
            switch (match[2].trim()) {
                case '':
                    value = "empty";
                    operator = "is";
                    no_operator = "is not";
                    break;
                case '__Others__':
                    value = "other";
                    operator = "is";
                    no_operator = "is not";
                    break;
                default:
                    value = esc(match[2]);
                    operator = "is";
                    no_operator = "is not";
            }
        } else if (match = input.match(/^(?:thsvd|hashvect):(.+):(\d+)$/)) {
            addCode(match[1]);
            addText('[text #' + match[2] + ']');
        } else if (match = input.match(/^unfold:([^:]+):(.*)$/)) {
            addCode(match[1]);
            addText('[element #' + match[2] + ']');
        } else if (input.startsWith("impact:")) {
            var elts = input.split(":");
            /*reg: impact:ft:impact*/
            /*multi: impact:ft:impact:i*/
            if (elts.length == 4) {
                addCode(elts[1]);
                addText('[impact #' + elts[3] + ']');
            } else {
                addCode(elts[1]);
                addText("(impact on target)");
            }
        } else if (match = input.match(/^poly_int:(.*)$/)) {
            addCode(match[1]);
            addText("(computed)");
        } else if (match = input.match(/^pw_linear:(.*)$/)) {
            addCode(match[1]);
            addText("(computed)");
        } else if (match = input.match(/countvec:(.+):(.+)$/)) {
            addCode(match[1]);
            operator = 'contains';
            no_operator = "does not contain";
            value = match[2];
            type = "countvec";
        } else if (match = input.match(/tfidfvec:(.+):(.+):(.+)$/)) {
            addCode(match[1]);
            operator = 'contains';
            no_operator = "does not contain";
            value = match[3] + "(idf=" + match[2] + ")";
            rawValue = match[3];
            type = "tfidfvec";
        } else if(input.startsWith("hashing:")) {
            elts = input.split(":");
            addCode(elts[1]);
            value = elts[2];
            operator = "hashes to";
            no_operator = "does not hash to";
            type = "hashing";
        } else if (input.startsWith("interaction")) {
            elts = input.split(":");
            if (elts.length == 3) {
                addCode(elts[1]);
                addText("x");
                addCode(elts[2]);
            } else if (elts.length == 4) {
                addCode(elts[1]);
                addText("x");
                addCode(elts[2] + " = " + elts[3]);
            } else {
                addCode(elts[1] + " = " + elts[3]);
                addText("and");
                addCode(elts[2] + " = " + elts[4]);
            }
        } else {
            addCode(input);
        }

        return {
            elements: els,
            isCode: code,
            value: value,
            operator: operator,
            no_operator: no_operator,
            type : type,
            rawValue : rawValue
        };
    }

    var getAsHtmlString = function(feature) {
        var els = getAsElements(feature, true);
        var htmlArray = [];
        for (var i = 0; i < els.elements.length; i++) {
            if (els.isCode[i]) {
                htmlArray.push("<code>" + els.elements[i] + "</code>")
            } else {
                htmlArray.push(els.elements[i]);
            }
        }
        if (els.value != null) {
            htmlArray.push(els.operator, "<code>" + els.value + "</code>");
        }
        return htmlArray.join(" ");
    };

    var getAsTextElements = function(feature) {
        var els = getAsElements(feature);
        return {
            feature: els.elements.join(" "),
            operator: els.operator,
            no_operator: els.no_operator,
            value: els.value,
            type : els.type,
            rawValue : els.rawValue
        };
    };

    var getAsText = function(feature, negate) {
        if (negate === undefined) {
            negate = false;
        }
        var els = getAsElements(feature);
        if (els.value == null) {
            return els.elements.join(" ");
        } else {
            return els.elements.concat([negate ? els.no_operator : els.operator, els.value]).join(" ");
        }
    }

    return {
        getAsElements: getAsElements,
        getAsHtmlString: getAsHtmlString,
        getAsTextElements: getAsTextElements,
        getAsText: getAsText
    };

})

app.filter("getNameValueFromMLFeature", function(FeatureNameUtils) {
    return function(feature) {
        var els = FeatureNameUtils.getAsTextElements(feature);
        return {
            name: els.feature,
            value: els.value
        };
    }
});


app.factory("InfoMessagesUtils", function() {
    var svc = {
        /* Returns the first of the info messages with a given line, or null if there is none */
        getMessageAtLine: function(im, line) {
            if (!im || !im.messages) return null;
            for (var i = 0; i < im.messages.length; i++) {
                if (im.messages[i].line == line) return im.messages[i];
            }
            return null;
        },
        /* Filter the messages of all categories by line */
        filterForLine : function(im, line) {
            if (!im || !im.messages) return null;
            var fim = {};
            fim.messages = im.messages.filter(function(m) {return m.line == line;});
            fim.anyMessage = fim.messages.length > 0;
            fim.error = fim.messages.filter(function(m) {return m.severity == 'ERROR'}).length > 0;
            fim.warning = fim.messages.filter(function(m) {return m.severity == 'WARNING'}).length > 0;
            fim.maxSeverity = fim.error ? 'ERROR' : (fim.warning ? 'WARNING' : (fim.anyMessage ? 'INFO' : null));
            return fim;
        },
        getMessageAtColumn : function(im, column) {
            if (!im || !im.messages) return null;
            for (var i = 0; i < im.messages.length; i++) {
                if (im.messages[i].column == column) return im.messages[i];
            }
            return null;
        }
    }
    return svc;
});


app.factory("MessengerUtils", function($sanitize) {
    Messenger.options = {
        extraClasses: 'messenger-fixed messenger-on-bottom messenger-on-right',
        theme: 'dss'
    };

    const svc = {
        post: function(options) {
            let msg = null;
            options.actions = options.actions || {};
            if (options.showCloseButton) {
                options.actions.close = {
                    label: "Close",
                    action: function() {
                        msg.hide();
                    }
                };
                delete options.showCloseButton;
            }
            if (options.icon) {
                options.message = '<div style="width: 100%;"><div class="messenger-icon">' + $sanitize(options.icon) + '</div>' + $sanitize(options.message) + '</div>'
                delete options.icon;
            } else {
                options.message = '<div style="width: 100%;">' + $sanitize(options.message) + '</div>'
            }
            msg = Messenger().post(options);
        }
    }
    return svc;
});


// Front-end equivalent of StringNormalizationMode.java
app.factory("StringNormalizer", function() {

    var inCombiningDiatricalMarks = /[\u0300-\u036F]/g;
    var punct = /!"#\$%&'\(\)\*\+,-\.\/:;<=>\?@\[\]\^_`\{\|\}~/g;

    var svc = {
        get: function(stringNormalizationMode) {
            switch(stringNormalizationMode) {
                case 'EXACT':
                    return function(str) {
                        return str;
                    };

                case 'LOWERCASE':
                    return function(str) {
                        return str.toLowerCase();
                    };

                case 'NORMALIZED':
                default:
                    return function(str) {
                        return svc.normalize(str);
                    };
            }
        },

        normalize: function(str) {
            return str.normalize('NFD').replace(inCombiningDiatricalMarks, '');
        },

        removePunct: function(str) {
            return str.replace(punct, '');
        }
    };

    return svc;
});


app.service('HiveService', function($rootScope, Dialogs, ActivityIndicator, DataikuAPI, CreateModalFromTemplate, $q) {
    this.convertToImpala = function(selectedRecipes) {
        var deferred = $q.defer();
        //TODO @flow need a dedicated modal or rather a generic confirm modal that can have errors in scope
        Dialogs.confirm($rootScope, "Convert recipes to Impala", `Are you sure you want to convert ${selectedRecipes.length} Hive recipes to Impala?`).then(function() {
            DataikuAPI.flow.recipes.massActions.convertToImpala(selectedRecipes, true)
                .success(function() {
                    deferred.resolve("converted");
                }).error(function(a,b,c) {
                    deferred.reject("conversion failed");
                    setErrorInScope.bind($rootScope)(a,b,c);
                });
        }, function() {deferred.reject("user cancelled");});
        return deferred.promise;
    };

    this.resynchronizeMetastore = function(selectedDatasets) {
        Dialogs.confirmPositive($rootScope,
            'Hive metastore resynchronization',
            'Are you sure you want to resynchronize datasets to the Hive metastore?')
        .then(function() {
            ActivityIndicator.waiting('Synchronizing Hive metastore...');
            DataikuAPI.datasets.synchronizeHiveMetastore(selectedDatasets).success(function(data) {
                if (data.anyMessage && (data.warning || data.error)) {
                    ActivityIndicator.hide();
                    Dialogs.infoMessagesDisplayOnly($rootScope, "Metastore synchronization", data);
                } else {
                    // nothing to show
                    ActivityIndicator.success('Hive metastore successfully synchronized');
                }
            }).error(function(data, status, headers) {
                ActivityIndicator.hide();
                setErrorInScope.call($rootScope, data, status, headers);
            });
        });
    };

    this.startChangeHiveEngine = function(selectedRecipes) {
        return CreateModalFromTemplate('/templates/recipes/fragments/hive-engine-modal.html', $rootScope, null, function(modalScope) {
            modalScope.options = {executionEngine: 'HIVESERVER2'};

            DataikuAPI.flow.recipes.massActions.startSetHiveEngine(selectedRecipes).success(function(data) {
                modalScope.messages = data;
            }).error(function(...args) {
                modalScope.fatalError = true;
                setErrorInScope.apply(modalScope, args);
            });

            modalScope.ok = function() {
                DataikuAPI.flow.recipes.massActions.setHiveEngine(selectedRecipes, modalScope.options.executionEngine)
                    .success(function() {
                        $rootScope.$emit('recipesHiveEngineUpdated');
                        modalScope.resolveModal();
                    })
                    .error(setErrorInScope.bind(modalScope));
            };
        });
    };

    this.startChangeSparkEngine = function(selectedRecipes) {
        return CreateModalFromTemplate('/templates/recipes/fragments/spark-engine-modal.html', $rootScope, null, function(modalScope) {
            modalScope.options = {executionEngine: 'SPARK_SUBMIT'};

            DataikuAPI.flow.recipes.massActions.startSetSparkEngine(selectedRecipes).success(function(data) {
                modalScope.messages = data;
            }).error(function(...args) {
                modalScope.fatalError = true;
                setErrorInScope.apply(modalScope, args);
            });

            modalScope.ok = function() {
                DataikuAPI.flow.recipes.massActions.setSparkEngine(selectedRecipes, modalScope.options.executionEngine)
                    .success(function() {
                        $rootScope.$emit('recipesSparkEngineUpdated');
                        modalScope.resolveModal();
                    })
                    .error(setErrorInScope.bind(modalScope));
            };
        });
    };
});


app.service('ImpalaService', function($rootScope, Dialogs, CreateModalFromTemplate, DataikuAPI, $q) {

    this.convertToHive = function(selectedRecipes) {
        var deferred = $q.defer();
        //TODO @flow need a dedicated modal or rather a generic confirm modal that can have errors in scope
        Dialogs.confirm($rootScope, "Convert recipes to Hive", `Are you sure you want to convert ${selectedRecipes.length} Impala recipes to Hive?`).then(function() {
            DataikuAPI.flow.recipes.massActions.convertToHive(selectedRecipes, true)
                .success(function() {
                    deferred.resolve("converted");
                }).error(function(a,b,c) {
                    deferred.reject("conversion failed");
                    setErrorInScope.bind($rootScope)(a,b,c);
                });
        }, function() {deferred.reject("user cancelled");});
        return deferred.promise;
    };

    this.startChangeWriteMode = function(selectedRecipes) {
        return CreateModalFromTemplate('/templates/recipes/fragments/impala-write-flag-modal.html', $rootScope, null, function(modalScope) {
            modalScope.options = {runInStreamMode: true};

            DataikuAPI.flow.recipes.massActions.startSetImpalaWriteMode(selectedRecipes).success(function(data) {
                modalScope.messages = data;
            }).error(function(...args) {
                modalScope.fatalError = true;
                setErrorInScope.apply(modalScope, args);
            });

            modalScope.ok = function() {
                DataikuAPI.flow.recipes.massActions.setImpalaWriteMode(selectedRecipes, modalScope.options.runInStreamMode)
                    .success(function() {
                        $rootScope.$emit('recipesImpalaWriteModeUpdated');
                        modalScope.resolveModal();
                    })
                    .error(setErrorInScope.bind(modalScope));
            };
        });
    };
});


app.service('SparkService', function($rootScope, CreateModalFromTemplate, DataikuAPI) {
    this.startChangeSparkConfig = function(selectedItems) {

        return CreateModalFromTemplate('/templates/recipes/fragments/spark-config-modal.html', $rootScope, null, function(modalScope) {
            modalScope.selectedRecipes = selectedItems.filter(it => it.type == 'RECIPE');
            modalScope.options = {};

            DataikuAPI.flow.recipes.massActions.startSetSparkConfig(modalScope.selectedRecipes).success(function(data) {
                modalScope.messages = data;
            }).error(function(...args) {
                modalScope.fatalError = true;
                setErrorInScope.apply(modalScope, args);
            });

            modalScope.ok = function() {
                DataikuAPI.flow.recipes.massActions.setSparkConfig(modalScope.selectedRecipes, modalScope.options.sparkConfig)
                    .success(function() {
                        $rootScope.$emit('recipesSparkConfigUpdated');
                        modalScope.resolveModal();
                    })
                    .error(setErrorInScope.bind(modalScope));
            };
        });
    };
});


app.service('PipelineService', function($rootScope, CreateModalFromTemplate, DataikuAPI) {
    this.startChangePipelineability = function(selectedItems, pipelineType) {
        return CreateModalFromTemplate('/templates/recipes/fragments/pipelineability-modal.html', $rootScope, null, function(modalScope) {
            modalScope.selectedRecipes = selectedItems.filter(it => it.type === 'RECIPE');

            modalScope.pipelineTypeText = (pipelineType === 'SPARK' ? 'Spark' : 'SQL');

            modalScope.options = {
                allowStart: true,
                allowMerge: true
            };

            DataikuAPI.flow.recipes.massActions.startSetPipelineability(modalScope.selectedRecipes, pipelineType).success(function(data) {
                modalScope.messages = data;
            }).error(function(...args) {
                modalScope.fatalError = true;
                setErrorInScope.apply(modalScope, args);
            });

            modalScope.ok = function() {
                DataikuAPI.flow.recipes.massActions.setPipelineability(modalScope.selectedRecipes, pipelineType, modalScope.options.allowStart, modalScope.options.allowMerge)
                    .success(function() {
                        modalScope.resolveModal();
                    })
                    .error(setErrorInScope.bind(modalScope));
            };
        });
    };
});


app.service('ColorPalettesService', function() {

    const svc = this;

    const DEFAULT_COLORS = [
        "#1ac2ab",
        "#0f6d82",
        "#FFD83D",
        "#de1ea5",
        "#9dd82b",
        "#28aadd",
        "#00a55a",
        "#d66b9b",
        "#77bec2",
        "#94be8e",
        "#123883",
        "#a088bd",
        "#c28e1a"
    ];

    svc.fixedColorsPalette = function(name, colors=DEFAULT_COLORS) {
        const colorMap = {};
        return function(key) {
            key = key + ''; //force conversion
            if (colorMap[key]) {
                return colorMap[key];
            }
            colorMap[key] = colors[Object.keys(colorMap).length % colors.length];
        };
    };

});


/*
 * TODO: finally this service is a bit of a duplicate of what CodeBasedEditorUtils was supposed to be. Would be good to merge both at some point...
 */
app.service('CodeMirrorSettingService', function($rootScope) {

    const INDENT_MORE_SHORTCUT = "Tab";
    const INDENT_LESS_SHORTCUT = "Shift-Tab";
    const FIND_SHORTCUT = "Ctrl-F";
    const REPLACE_SHORTCUT = "Ctrl-Alt-F";
    const JUMP_TO_LINE_SHORTCUT = "Ctrl-L";
    const TOGGLE_COMMENT_SHORTCUT_QWERTY = "Cmd-/";
    const TOGGLE_COMMENT_SHORTCUT_AZERTY = "Shift-Cmd-/";
    const TOGGLE_COMMENT_SHORTCUT_RSTUDIO = "Shift-Ctrl-C";
    const AUTOCOMPLETE_SHORTCUT = "Ctrl-Space";
    const FULL_SCREEN_SHORTCUT = "F11";

    this.getShortcuts = function() {
        return {
            "INDENT_MORE_SHORTCUT": INDENT_MORE_SHORTCUT,
            "INDENT_LESS_SHORTCUT": INDENT_LESS_SHORTCUT,
            "FIND_SHORTCUT": FIND_SHORTCUT,
            "REPLACE_SHORTCUT": REPLACE_SHORTCUT,
            "JUMP_TO_LINE_SHORTCUT": JUMP_TO_LINE_SHORTCUT,
            "TOGGLE_COMMENT_SHORTCUT": TOGGLE_COMMENT_SHORTCUT_QWERTY,
            "AUTOCOMPLETE_SHORTCUT": AUTOCOMPLETE_SHORTCUT,
            "FULL_SCREEN_SHORTCUT": FULL_SCREEN_SHORTCUT}
    }

    this.get = function(mimeType, options) {
        var extraKeys = {};

        if (!$rootScope.appConfig.userSettings.codeEditor || !$rootScope.appConfig.userSettings.codeEditor.keyMap || $rootScope.appConfig.userSettings.codeEditor.keyMap == "default") {
            extraKeys[INDENT_MORE_SHORTCUT] = "indentMore";
            extraKeys[INDENT_LESS_SHORTCUT] = "indentLess";
            extraKeys[FIND_SHORTCUT] = "find";
            extraKeys[REPLACE_SHORTCUT] = "replace";
            extraKeys[JUMP_TO_LINE_SHORTCUT] = "jumpToLine";
            extraKeys[TOGGLE_COMMENT_SHORTCUT_QWERTY] = "toggleComment";
            extraKeys[TOGGLE_COMMENT_SHORTCUT_AZERTY] = "toggleComment";
            extraKeys[TOGGLE_COMMENT_SHORTCUT_RSTUDIO] = "toggleComment";
            extraKeys[AUTOCOMPLETE_SHORTCUT] = this.showHint(mimeType, options && options.words ? options.words : []);
        }
        if (!options || !options.noFullScreen) {
            extraKeys[FULL_SCREEN_SHORTCUT] = function(cm) {
                if (cm.getOption("fullScreen")) {
                    cm.setOption("fullScreen", false);
                } else {
                    cm.setOption("fullScreen", !cm.getOption("fullScreen"));
                }
            };
        }


        var settings =  {
            mode: mimeType,
            theme: $rootScope.appConfig.userSettings.codeEditor && $rootScope.appConfig.userSettings.codeEditor.theme ? $rootScope.appConfig.userSettings.codeEditor.theme : 'default',

            //left column
            lineNumbers : true,
            foldGutter: true,
            gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],

            //indentation
            indentUnit: $rootScope.appConfig.userSettings.codeEditor && $rootScope.appConfig.userSettings.codeEditor.indentUnit ? $rootScope.appConfig.userSettings.codeEditor.indentUnit : 4,
            tabSize: $rootScope.appConfig.userSettings.codeEditor && $rootScope.appConfig.userSettings.codeEditor.tabSize ? $rootScope.appConfig.userSettings.codeEditor.tabSize : 4,
            indentWithTabs: $rootScope.appConfig.userSettings.codeEditor ? $rootScope.appConfig.userSettings.codeEditor.indentWithTabs : false,

            //edition
            autoCloseBrackets: $rootScope.appConfig.userSettings.codeEditor ? $rootScope.appConfig.userSettings.codeEditor.autoCloseBrackets : true,
            autoCloseTags: $rootScope.appConfig.userSettings.codeEditor ? $rootScope.appConfig.userSettings.codeEditor.autoCloseTags : true,

            //code reading
            matchBrackets: true,
            matchTags: true,
            highlightSelectionMatches: true,
            styleSelectedText: true,
            styleActiveLine: true,

            keyMap: $rootScope.appConfig.userSettings.codeEditor && $rootScope.appConfig.userSettings.codeEditor.keyMap ? $rootScope.appConfig.userSettings.codeEditor.keyMap : 'default',
            extraKeys: extraKeys,
            onLoad: function(cm) {
                if ($rootScope.appConfig.userSettings.codeEditor && $rootScope.appConfig.userSettings.codeEditor.fontSize) {
                    $($(cm.getTextArea()).siblings('.CodeMirror')[0]).css('font-size', $rootScope.appConfig.userSettings.codeEditor.fontSize + 'px');
                }
                if (options && options.onLoad && typeof(options.onLoad) == "function") {
                    options.onLoad(cm);
                }
            }
        };

        return settings;
    }

    this.showHint = function(mode, words) {
        return function(cm) {
            const modes = {
                'text/x-python': CodeMirror.hintWords.python,
                'text/css': CodeMirror.hintWords.css
            };

            CodeMirror.showHint(cm, function(editor) {
                const anyWordHint = CodeMirror.hint.anyword(cm);
                const recipeWords = words || [];
                const codeKeywords = CodeMirror.hintWords[mode] || modes[mode] || [];

                let combinedWords = [recipeWords, [' '], codeKeywords, [' '], anyWordHint && anyWordHint.list ? anyWordHint.list : []]
                    .reduce((a, b) => a.concat(b.filter(_ => _ === ' ' || !a.includes(_)))); // deduplicates

                /*
                    Filter functionality based off of https://github.com/amarnus/ng-codemirror-dictionary-hint/blob/master/lib/ng-codemirror-dictionary-hint.js
                */
                var cur = editor.getCursor();
                var curLine = editor.getLine(cur.line);
                var start = cur.ch;
                var end = start;
                while (end < curLine.length && /[\w$]/.test(curLine.charAt(end))) ++end;
                while (start && /[\w$]/.test(curLine.charAt(start - 1))) --start;
                var curWord = start !== end && curLine.slice(start, end);
                return {
                    list: (!curWord ? combinedWords : combinedWords.filter(_ => _.startsWith(curWord) && _ !== curWord)),
                    from: CodeMirror.Pos(cur.line, start),
                    to: CodeMirror.Pos(cur.line, end)
                }
            }, { completeSingle: false });
        };
    }
});


app.service('TimingService', function($rootScope) {
    return {
        wrapInTimePrinter: function(prefix, fn) {
            return function() {
                const before = performance.now();
                const retval = fn.apply(this, arguments);
                const after = performance.now();
                console.info("Timing: " + prefix + ": " + (after - before) + "ms");
                return retval;
            }
        }
    };
});

app.service('PromiseService', function() {
    const svc = this;

    /**
     * Wrap a $q promise in a $http promise (in order to keep the .success and .error methods)
     */
    svc.qToHttp = function(p) {
        return {
            then: p.then,
            success: function (fn) {
                return svc.qToHttp(p.then(fn));
            },
            error: function (fn) {
                return svc.qToHttp(p.then(null, fn));
            }
        }
    }

})

app.service('ProjectStatusService', function(TaggingService, $rootScope)  {
    const svc = this;
    let projectStatusMap = {};

    svc.getProjectStatusColor = function(status) {
        if(projectStatusMap && projectStatusMap[status]) {
            return projectStatusMap[status];
        } else {
            return TaggingService.getDefaultColor(status);
        }
    }

    function computeProjectStatusMap() {
        projectStatusMap = {};
        if ($rootScope.appConfig && $rootScope.appConfig.projectStatusList) {
            $rootScope.appConfig.projectStatusList.forEach(function(projectStatus) {
                projectStatusMap[projectStatus.name] = projectStatus.color;
            });
        }
    }
    $rootScope.$watch('appConfig.projectStatusList', computeProjectStatusMap, true);
});

/**
 * Enhance fattable elements with dragging capabilities.
 * Mandatory class fat-draggable should be added for parent draggable zone.
 * Mandatory class fat-draggable__item should be added for each items that can be dragged.
 * Mandatory class fat-draggable__handler should be added to trigger drag. It should be a child of an item or the item itself.
 * Mandatory data-column-name attribute should be added at fat-draggable__item level to keep a reference to the column when DOM is being recycled.
 *
 * To enable drag on an element, call the setDraggable() method with the following options :
 *
 * @param {Object}              options                         - The available options
 * @param {HTMLElement}         options.element                 - (Mandatory) element containing the draggable items.
 * @param {String}              [options.axis="x"]              - Define the dragging axis. Default to horizontal dragging.
 * @param {Function}            [options.onDrop]                - Drop callback
 * @param {Function}            [options.onPlaceholderUpdate]   - Placeholder dimensions update. Use it to reshape / position the placeholder. Called with the placeholder dimensions
 * @param {ScrollBarProxy}      [options.scrollBar]             - Fattable scrollbar to be updated if necessary
 *
 * @example
 *
 * <div class="fat-draggable">
 *  <div class="fat-draggable__item" data-column-name="{{column.name}}">
 *       <i class="fat-draggable__handler"></i>
 *       ...
 *  </div>
 * </div>
 */
app.factory('FatDraggableService', function() {
    const MAIN_CLASSNAME = 'fat-draggable';
    const HANDLER_CLASSNAME = MAIN_CLASSNAME + '__handler';
    const ITEM_CLASSNAME = MAIN_CLASSNAME + '__item';
    const PLACEHOLDER_CLASSNAME = MAIN_CLASSNAME + '__placeholder';
    const BAR_CLASSNAME = MAIN_CLASSNAME + '__bar';
    const DRAGGING_CLASSNAME = MAIN_CLASSNAME + '--dragging';
    const DRAGGED_CLASSNAME = ITEM_CLASSNAME + '--dragged';
    const COLUMN_NAME_ATTRIBUTE = 'data-column-name';
    const BAR_THICKNESS = 2;
    const MINIMAL_MOVE_TO_DRAG = 10;
    let classNamesToIgnore;
    let scrollBar;
    let element;
    let axis = 'x';
    let axisClassname;
    let placeholderDOM = document.createElement('div');
    let barDOM = document.createElement('div');
    let draggedItem;
    let draggedColumnName;
    let disabledTarget;
    let draggedItemDimensions = {};
    let placeholderDimensions = {};
    let barDimensions = {};
    let elementDimensions = {};
    let hoveredItem;
    let hoveredColumnName;
    let hoveredItemDimensions = {};
    let dragging = false;
    let downing = false;
    let onDrop;
    let onPlaceholderUpdate;
    let cursorInitialPosition = -1;
    let cursorPosition = -1;
    let gap = -1;

    // Ensures requestAnimationFrame cross-browsers support
    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;

    /* HELPERS */

    // Gets the draggable item matching the mouse target
    function getDraggableItem(target) {
        return target.closest('.' + ITEM_CLASSNAME);
    }

    function getColumnName(columnDOM) {
        if (columnDOM) {
            return columnDOM.getAttribute(COLUMN_NAME_ATTRIBUTE) || (columnDOM.firstElementChild && columnDOM.firstElementChild.getAttribute(COLUMN_NAME_ATTRIBUTE));
        }
    }

    function getColumnDOM(columnName) {
        if (columnName) {
            return element.querySelector('[' + COLUMN_NAME_ATTRIBUTE + '="' + columnName + '"]');
        }
    }

    // Returns true if we are dragging before (on top in y axis or on left on x axis) the item being dragged
    function isDraggingBefore() {
        return cursorPosition && draggedItemDimensions && (cursorPosition <= draggedItemDimensions[axis === 'y' ? 'top' : 'left']);
    }

    // Retrieves the item around the cursor position
    function getHoveredItem() {
        let items = element.querySelectorAll('.' + ITEM_CLASSNAME);
        let vertical = (axis === 'y');
        for (let i = 0; i < items.length; i++) {
            let currentItem = items[i];
            let itemDimensions = getBoundingClientRect(currentItem);
            if (vertical) {
                if (itemDimensions.top <= cursorPosition && cursorPosition < itemDimensions.top + itemDimensions.height) {
                    return currentItem;
                }
            } else {
                if (itemDimensions.left <= cursorPosition && cursorPosition < itemDimensions.left + itemDimensions.width) {
                    return currentItem;
                }
            }
        }
        return null;
    }

    // Sets hover style for the draggable item matching the mouse target
    function updateHoveredItem() {
        let draggingBefore = isDraggingBefore();
        let target = getHoveredItem();

        if (!target) {
            return;
        }
        if (hoveredItem && hoveredItem === target) {
            return;
        }

        hoveredItem = target;
        hoveredColumnName = getColumnName(hoveredItem);

        if (hoveredItem !== draggedItem) {
            hoveredItemDimensions = getBoundingClientRect(hoveredItem);
            elementDimensions = getBoundingClientRect(element);

            if (axis === 'y') {
                barDimensions.top = draggingBefore ? hoveredItemDimensions.top : hoveredItemDimensions.top + hoveredItemDimensions.height;
                barDimensions.height = BAR_THICKNESS;
                barDimensions.width = placeholderDimensions.width;
                barDimensions.left = elementDimensions.left;
            } else {
                barDimensions.left = draggingBefore ? hoveredItemDimensions.left : hoveredItemDimensions.left + hoveredItemDimensions.width;
                barDimensions.height = placeholderDimensions.height;
                barDimensions.width = BAR_THICKNESS;
                barDimensions.top = elementDimensions.top;
            }
        } else {
            barDimensions.width = 0;
            barDimensions.height = 0;
        }

        updateBarBoundingBox(barDimensions);
    }

    // Redraw the placeholder according the mouse position
    function updatePlaceholderBoundingBox(dimensions) {

        if (typeof onPlaceholderUpdate === 'function') {
            onPlaceholderUpdate(dimensions);
        }

        if (dimensions.top >= 0) {
            if (dimensions.top <= elementDimensions.top - placeholderDimensions.height / 2) {
                // If overflowing on top
                // Putting at top of parent element - half of the placeholder (for better auto scroll)
                dimensions.top = elementDimensions.top - placeholderDimensions.height / 2;
            } else if (dimensions.top + placeholderDimensions.height - placeholderDimensions.height / 2 >= elementDimensions.top + elementDimensions.height) {
                // If overflowing on bottom
                // Putting at bottom of parent element + half of the placeholder (for better auto scroll)
                dimensions.top = elementDimensions.top + elementDimensions.height - placeholderDimensions.height / 2;
            }
            placeholderDOM.style.top = dimensions.top + 'px';
        }
        if (dimensions.left >= 0) {
            if (dimensions.left <= elementDimensions.left - placeholderDimensions.width / 2) {
                // If overflowing on the left
                // Putting at left of parent element - half of the placeholder (for better auto scroll)
                dimensions.left = elementDimensions.left - placeholderDimensions.width / 2;
            } else if (dimensions.left + placeholderDimensions.width - placeholderDimensions.width / 2 >= elementDimensions.left + elementDimensions.width) {
                // If overflowing on the right
                // Putting at right of parent element + half of the placeholder (for better auto scroll)
                dimensions.left = elementDimensions.left + elementDimensions.width - placeholderDimensions.width / 2;
            }
            placeholderDOM.style.left = dimensions.left + 'px';
        }

        if (dimensions.height >= 0) {
            placeholderDOM.style.height = dimensions.height + 'px';
        }
        if (dimensions.width >= 0) {
            placeholderDOM.style.width = dimensions.width + 'px';
        }
    }

    // Wrap the placeholder position update in a callback for requestAnimationFrame()
    function placeholderDOMRedraw() {
        updatePlaceholderBoundingBox(axis === 'y' ? {top: (cursorPosition - gap)} : {left: (cursorPosition - gap)});
    }

    // Redraw the bar according the given dimensions
    function updateBarBoundingBox(dimensions) {
        if (dimensions.top >= 0) {
            if (dimensions.top <= elementDimensions.top) {
                dimensions.top = elementDimensions.top;
            } else if (dimensions.top >= elementDimensions.top + elementDimensions.height) {
                dimensions.top = elementDimensions.top + elementDimensions.height;
            }
            barDOM.style.top = dimensions.top + 'px';
        }
        if (dimensions.left >= 0) {
            if (dimensions.left <= elementDimensions.left) {
                dimensions.left = elementDimensions.left;
            } else if (dimensions.left >= elementDimensions.left + elementDimensions.width) {
                dimensions.left = elementDimensions.left + elementDimensions.width;
            }
            barDOM.style.left = dimensions.left + 'px';
        }
        if (dimensions.height >= 0) {
            barDOM.style.height = dimensions.height + 'px';
        }
        if (dimensions.width >= 0) {
            barDOM.style.width = dimensions.width + 'px';
        }
    }

    // Generic fatTable scroll update
    function updateScroll () {
        if (!scrollBar) {
            return;
        }
        if (axis === 'y') {
            let elementTop = getBoundingClientRect(element).top;
            let elementBottom = elementTop + element.offsetHeight;
            let placeholderTop= placeholderDOM.offsetTop;
            let placeholderBottom = placeholderTop + placeholderDOM.offsetHeight;

            if (placeholderBottom > elementBottom) {
                scrollBar.setScrollXY(element.scrollLeft, scrollBar.scrollTop + placeholderBottom - elementBottom);
            } else if (placeholderTop < elementTop) {
                scrollBar.setScrollXY(element.scrollLeft, scrollBar.scrollTop + placeholderTop - elementTop);
            }
        } else {
            let elementLeft = getBoundingClientRect(element).left;
            let elementRight = elementLeft + element.offsetWidth;
            let placeholderLeft = placeholderDOM.offsetLeft;
            let placeholderRight = placeholderLeft + placeholderDOM.offsetWidth;

            if (placeholderRight > elementRight) {
                scrollBar.setScrollXY(scrollBar.scrollLeft + placeholderRight - elementRight, element.scrollTop);
            } else if (placeholderLeft < elementLeft) {
                scrollBar.setScrollXY(scrollBar.scrollLeft + placeholderLeft - elementLeft, element.scrollTop);
            }
        }
    }

    // Clean every dragging-related things
    function reset() {
        document.body.contains(placeholderDOM) && document.body.removeChild(placeholderDOM);
        barDOM.style.top = '';
        barDOM.style.left = '';
        barDOM.style.height = '';
        barDOM.style.width = '';
        document.body.removeChild(barDOM);
        draggedItem && draggedItem.classList.remove(DRAGGED_CLASSNAME);
        document.body.classList.remove(DRAGGING_CLASSNAME);

        window.removeEventListener('mousemove', onMouseMove);
        window.removeEventListener('mouseup', onMouseUp);
        disabledTarget.removeEventListener('mouseup', disableClick);
        Mousetrap.unbind("esc", onEscape);

        dragging = false;
        downing = false;
        draggedItem = null;
        draggedColumnName = null;
        hoveredItem = null;
        hoveredColumnName = null;
        disabledTarget = null;
        draggedItemDimensions = {};
        placeholderDimensions = {};
        barDimensions = {};
        hoveredItemDimensions = {};
        elementDimensions = {};
        cursorPosition = -1;
        cursorInitialPosition = -1;
        gap = -1;
    }

    // Prevent the beginning of the drag
    function cancel() {
        if (dragging) {
            reset();
        } else {
            cursorInitialPosition = -1;
            downing = false;
            draggedItem = null;
            draggedColumnName = null;
            window.removeEventListener('mousemove', onMouseMove);
        }
    }

    /* EVENTS LISTENERS */
    function onMouseUp() {

        if (!dragging) {
            cancel();
            return;
        }
        if (typeof onDrop === 'function' && draggedColumnName && hoveredColumnName && draggedColumnName !== hoveredColumnName) {
            onDrop(draggedItem, hoveredItem, draggedColumnName, hoveredColumnName);
        }
        reset();
    }

    // When the dragging has started we do not want any click to be triggered on the element
    function disableClick(event) {
        event.stopImmediatePropagation();
        event.preventDefault();
        onMouseUp();
    }

    // If moving the placeholder, update its position according the given axis
    function onMouseMove(event) {

        // If not yet dragging, initiate drag, else update the placeholder position
        if (!dragging && downing) {
            if (axis === 'y') {
                cursorPosition = event.clientY;
                gap = cursorInitialPosition - draggedItemDimensions.y;
            } else {
                cursorPosition = event.clientX;
                gap = cursorInitialPosition - draggedItemDimensions.x;
            }

            // Do not start drag if the mouse has not moved enough
            if (Math.abs(cursorPosition - cursorInitialPosition) < MINIMAL_MOVE_TO_DRAG) {
                return;
            }

            dragging = true;
            // Bind mouseup for dragging end and click on target to prevent other listeners to be triggered
            window.addEventListener('mouseup', onMouseUp);
            disabledTarget = event.target;
            disabledTarget.addEventListener('click', disableClick);

            // Inject placeholder and bar in DOM and add the drag-related class names
            document.body.appendChild(placeholderDOM);
            document.body.appendChild(barDOM);
            document.body.classList.add(DRAGGING_CLASSNAME);
            draggedItem.classList.add(DRAGGED_CLASSNAME);

            placeholderDimensions = angular.copy(draggedItemDimensions);
            updatePlaceholderBoundingBox(placeholderDimensions);

            Mousetrap.bind("esc", onEscape);
        } else {
            cursorPosition = axis === 'y' ? event.clientY : event.clientX;
            requestAnimationFrame(placeholderDOMRedraw);
            updateScroll();
            // If the dragged column DOM from fattable has been removed try to re-fetch it
            if (!document.body.contains(draggedItem)) {
                let newDraggedItem = getColumnDOM(draggedColumnName);
                if (newDraggedItem) {
                    draggedItem = newDraggedItem;
                    draggedItem.classList.add(DRAGGED_CLASSNAME);
                }
            // If the dragged column DOM and column name are inconsistent, invalidate it and try to refetch it
            } else if (!draggedItem.getAttribute(COLUMN_NAME_ATTRIBUTE) || draggedItem.getAttribute(COLUMN_NAME_ATTRIBUTE) !== draggedColumnName) {
                draggedItem.classList.remove(DRAGGED_CLASSNAME);
                draggedItem = null;
                let newDraggedItem = getColumnDOM(draggedColumnName);
                if (newDraggedItem) {
                    draggedItem = newDraggedItem;
                    draggedItem.classList.add(DRAGGED_CLASSNAME);
                }
            }
        }

        updateHoveredItem();
    }

    // Press escape to stop the current drag
    function onEscape() {
        if (!dragging) {
            return;
        }
        reset();
    }

    function onMouseDown(event) {

        // Do not drag if the selected element has at least one class marking it as not-draggable
        try {
            classNamesToIgnore.forEach(className => {
                if (event.target.closest('.' + className)) {
                    throw PreventDragException;
                }
            });
        } catch (e) {
            return;
        }

        if (!event.target.closest('.' + HANDLER_CLASSNAME)) {
            return;
        }

        // Do not consider right click
        if (event.which === 3) {
            return;
        }

        downing = true;
        draggedItem = getDraggableItem(event.target);
        draggedColumnName = getColumnName(draggedItem);

        window.addEventListener('mousemove', onMouseMove);

        // If a click occurred, prevent dragging
        element.addEventListener('click', cancel);

        // Prevent native drag
        event.preventDefault();

        // Ensure mandatory class name are here
        element.classList.add(MAIN_CLASSNAME);
        element.classList.add(axisClassname);

        draggedItemDimensions = getBoundingClientRect(draggedItem);

        if (axis === 'y') {
            cursorInitialPosition = event.clientY;
        } else {
            cursorInitialPosition = event.clientX;
        }
    }

    return {

        setDraggable: function(options) {
            if (!options || !options.element) { return }
            element = options.element;
            onDrop = options.onDrop;
            onPlaceholderUpdate = options.onPlaceholderUpdate;
            scrollBar = options.scrollBar;
            classNamesToIgnore = options.classNamesToIgnore;

            element.classList.add(MAIN_CLASSNAME);

            axis = options.axis && options.axis === 'y' ? 'y' : 'x';
            axisClassname = axis === 'y' ? 'fat-draggable-y-axis' : 'fat-draggable-x-axis';
            element.classList.add(axisClassname);

            placeholderDOM.className = PLACEHOLDER_CLASSNAME;
            barDOM.className = BAR_CLASSNAME;

            // If clicking on a drag handler, retrieve dragged item data and attach mouse move
            element.addEventListener('mousedown', onMouseDown);
        }
    }
});

/**
 * Enhance fattable elements with resize capabilities.
 * Mandatory class fat-resizable__item should be added for each items that can be dragged.
 * Mandatory class fat-resizable__handler should be added to trigger resize. It should be a child of an item or the item itself.
 * Mandatory data-column-name and data-column-index attributes should be added at fat-resizable__item level to keep a reference to the column when DOM is being recycled.
 *
 * To enable resize on an element, call the setResizable() method with the following options :
 *
 * @param {Object}              options                         - The available options
 * @param {HTMLElement}         options.element                 - (Mandatory) element containing the resizable items.
 * @param {Function}            options.onDrop               - Drop callback. Returns an object containing resized column data: index, name and width.
 *
 * @example
 *
 * <div fat-resizable>
 * ...
 *  <div class="fat-resizable__item" data-column-name="{{column.name}}" data-column-index="{{columnIndex}}">
 *      ...
 *      <span class="fat-resizable__handler"></span>
 *      ... 
 *  </div>
 * ...
 * </div>
 */
app.factory('FatResizableService', function () {
    const MAIN_CLASSNAME = 'fat-resizable';
    const ITEM_CLASSNAME = MAIN_CLASSNAME + '__item';
    const HANDLER_CLASSNAME = MAIN_CLASSNAME + '__handler';
    const BAR_CLASSNAME = MAIN_CLASSNAME + '__bar';
    const COLUMN_INDEX_ATTRIBUTE_NAME = 'data-column-index';
    const COLUMN_NAME_ATTRIBUTE_NAME = 'data-column-name';
    const BAR_THICKNESS = 4;
    const ITEM_MIN_WIDTH = 60;

    let element, 
        onDrop, 
        resizing = false,
        downing = false,
        cursorPosition = -1,
        barDimensions = {},
        elementDimensions,
        resizableItem = null,
        resizedItemDimensions = {},
        draggingLowerBound,
        disabledTarget,
        barDOM = document.createElement('div');

    /* HELPERS */

    // Gets the resizable item matching the mouse target
    function getResizableItem(target) {
        return target.closest('.' + ITEM_CLASSNAME);
    } 

    function updateBar() {
        elementDimensions = elementDimensions || getBoundingClientRect(element);
        barDimensions.left = cursorPosition;
        barDimensions.top = elementDimensions.top;
        barDOM.style.top = barDimensions.top + 'px';
        barDOM.style.left = barDimensions.left + 'px';
        barDOM.style.height = barDimensions.height + 'px';
        barDOM.style.width = barDimensions.width + 'px';
    }

    // Clean every resizing-related things
    function reset() {
        barDOM.style.top = '';
        barDOM.style.left = '';
        barDOM.style.height = '';
        barDOM.style.width = '';
        document.body.removeChild(barDOM);

        window.removeEventListener('mousemove', onMouseMove);
        window.removeEventListener('mouseup', onMouseUp);
        disabledTarget.removeEventListener('mouseup', disableClick);
        Mousetrap.unbind("esc", onEscape);

        resizing = false;
        downing = false;
        barDimensions.left = 0;
        barDimensions.right = 0;
        cursorPosition = -1;
        draggingLowerBound = null;
        resizableItem = null;
        resizedItemDimensions = {};
    }

    // Prevent the beginning of the drag
    function cancel() {
        if (resizing) {
            reset();
        } else {
            downing = false;
            resizableItem = null;
            resizedItemDimensions = {};
            window.removeEventListener('mousemove', onMouseMove);
        }
    }

    /* EVENTS LISTENERS */

    function onMouseUp() {

        if (!resizing) {
            cancel();
            return;
        }

        if (typeof onDrop === 'function') {
            let resizedWidth = cursorPosition - resizedItemDimensions.x;
            resizedWidth = resizedWidth > ITEM_MIN_WIDTH ? resizedWidth : ITEM_MIN_WIDTH;
            onDrop({ 
                index: resizableItem.getAttribute(COLUMN_INDEX_ATTRIBUTE_NAME), 
                name: resizableItem.getAttribute(COLUMN_NAME_ATTRIBUTE_NAME), 
                width: resizedWidth 
            });
        }
        reset();
    }

    // When the dragging has started we do not want any click to be triggered on the element
    function disableClick(event) {
        event.stopImmediatePropagation();
        event.preventDefault();
        onMouseUp();
    }

    function onMouseMove(event) {

        // If not yet dragging, initiate drag, else update the placeholder position
        if (!resizing && downing) {

            resizing = true;
            // Bind mouseup for dragging end and click on target to prevent other listeners to be triggered
            window.addEventListener('mouseup', onMouseUp);
            disabledTarget = event.target;
            disabledTarget.addEventListener('click', disableClick);

            // Inject bar in DOM
            document.body.appendChild(barDOM);

            Mousetrap.bind("esc", onEscape);
        } else {
            cursorPosition = event.clientX;
        }

        if (!draggingLowerBound) {
            draggingLowerBound = getBoundingClientRect(resizableItem).x
        }

        // Prevent resizing beyond the previous column
        if (cursorPosition <= draggingLowerBound + ITEM_MIN_WIDTH) { return }

        updateBar();
    }

    function onMouseDown(event) {

        if (!event.target.closest('.' + HANDLER_CLASSNAME)) {
            return;
        }

        // Do not consider right click
        if (event.which === 3) {
            return;
        }

        downing = true;
        resizableItem = getResizableItem(event.target);

        window.addEventListener('mousemove', onMouseMove);

        // If a click occurred, prevent dragging
        element.addEventListener('click', cancel);

        // Prevent native drag
        event.preventDefault();

        resizedItemDimensions = getBoundingClientRect(resizableItem);
    }

    // Press escape to stop the current drag
    function onEscape() {
        if (!resizing) {
            return;
        }
        reset();
    }

    return {

        setResizable: function(options) {
            if (!options || !options.element) { return }

            onDrop = options.onDrop;
            element = options.element;

            // Prepare vertical bar used as feedback while resizing
            barDimensions.height = options.barHeight;
            barDimensions.width = BAR_THICKNESS;
            barDOM.className = BAR_CLASSNAME;

            // If clicking on a drag handler, retrieve dragged item data and attach mouse move
            element.addEventListener('mousedown', onMouseDown);
        }
    }
})

app.service('FatTouchableService', function($timeout) {
    /**
     * Make a fattable/fatrepeat scrollable through touch interaction
     * @param scope: scope of the fattable/fatrepeat directive
     * @param element: DOM element of the fattable/fatrepeat directive
     * @param fattable: fattable object of the fattable/fatrepeat directive
     * @returns function to remove event listeners added by this function
     */
    this.setTouchable = function(scope, element, fattable) {
        /**
         * Return an object wrapping callbacks. This function will be called each time a touchstart is emmited in order
         * to give callbacks to the added the touchmove and touchend event listeners.
         */
        let getOnTouchCallbacks = (function() {
            /*
             * Callbacks
             */

            /**
             * Turns the touchMoveEvent passed in parameter into a scrollOrder to the fattable
             * @param event
             */
            let startScroll;
            let lastScroll;
            let startTouch;
            let lastTouch;
            function scrollFattable(touchMoveEvent) {
                fattable.scroll.dragging = true; //otherwise fattable behaves as user had scrolled using scrollbars, which triggers multiple reflows, which is bad for performances
                touchMoveEvent.preventDefault();
                touchMoveEvent.stopPropagation();
                let newTouch = touchMoveEvent.originalEvent.changedTouches[0];

                // Tracking for direction change
                function getTouchedDistance(t) {
                    return {
                        x: startTouch.screenX - t.screenX,
                        y: startTouch.screenY - t.screenY
                    }
                }
                let touchedDistance = getTouchedDistance(newTouch);
                let lastTouchedDistance = getTouchedDistance(lastTouch);
                if (Math.abs(lastTouchedDistance) - Math.abs(touchedDistance) > 0) {
                    startTouch = lastTouch;
                    startScroll = lastScroll;
                    touchedDistance = getTouchedDistance(newTouch);
                }
                // Scrolling
                requestAnimationFrame(_ => fattable.scroll.setScrollXY(startScroll.x + touchedDistance.x, startScroll.y + touchedDistance.y));
                // Updating memory
                lastTouch = touchMoveEvent.originalEvent.changedTouches[0];
                lastScroll = {
                    x: fattable.scroll.scrollLeft,
                    y: fattable.scroll.scrollTop
                }
            }

            /**
             * Keeps track of touch velocity in order to generate momentum when touchmove will stop.
             * (Tracking will stop at touchEnd)
             * @type {number}
             */
            const SPEED_FILTER = 0.8; // Arbitrary chosen constant
            let prevScroll;
            let velocity;
            let lastTimestamp;
            let keepTrackingVelocity;
            function trackVelocity() {
                // current scroll position
                let scroll = {
                    x: fattable.scroll.scrollLeft,
                    y: fattable.scroll.scrollTop
                };
                // scrolled distance since last track
                let delta = {
                    x: scroll.x - prevScroll.x,
                    y: scroll.y - prevScroll.y
                };
                // if scroll changed direction then we do not take previous velocity into account
                let prevVelocityCoeff = {
                    x: delta.x * velocity.x > 0 ? 0.2 : 0,
                    y: delta.y * velocity.y > 0 ? 0.2 : 0,
                };
                // computing velocity
                let timeStamp = Date.now();
                velocity.x = SPEED_FILTER * delta.x * 1000 / (1 + timeStamp - lastTimestamp) + prevVelocityCoeff.x * velocity.x;
                velocity.y = SPEED_FILTER * delta.y * 1000 / (1 + timeStamp - lastTimestamp) + prevVelocityCoeff.y * velocity.y;
                // updating memory
                lastTimestamp = timeStamp;
                prevScroll = scroll;
                if (keepTrackingVelocity) {
                    $timeout(trackVelocity, 10);
                }
            }

            /**
             * Generates a momentum animation when touch stops
             * @param event
             */
            function animateMomentum() {
                keepTrackingVelocity = false;
                let endTime = Date.now();
                // Momentum appears only if velocity was greater than 10px/s
                if (Math.abs(velocity.x) > 10 || Math.abs(velocity.y) > 10) {
                    // Detach event listeners when momentum ends
                    let onMomentumEnd = function () {
                        element.off('touchstart', stopMomentumAnimation);
                        element.off('touchmove', stopMomentumAnimation);
                        fattable.scroll.dragging = false;
                    }

                    // Stop momentum on new touchevent
                    let interruptedMomentum = false;
                    let stopMomentumAnimation = function () {
                        interruptedMomentum = true;
                        onMomentumEnd();
                    }
                    element.on('touchstart', stopMomentumAnimation);
                    element.on('touchmove', stopMomentumAnimation);

                    // Compute if scroll can go further with inertia
                    let canScroll = function (delta) {
                        let canScrollH = (delta.x < 0 && fattable.scroll.scrollLeft > 0) || (delta.x > 0 && fattable.scroll.scrollLeft < fattable.scroll.maxScrollHorizontal);
                        let canScrollV = (delta.y < 0 && fattable.scroll.scrollTop > 0) || (delta.y > 0 && fattable.scroll.scrollTop < fattable.scroll.maxScrollVertical);
                        return canScrollH || canScrollV;
                    }

                    /*
                     * MOMENTUM (all formulas come from this article: https://ariya.io/2013/11/javascript-kinetic-scrolling-part-2)
                     */

                    // additional distance to scroll while momentum
                    let amplitude = {
                        x: SPEED_FILTER * velocity.x,
                        y: SPEED_FILTER * velocity.y
                    }
                    let previousScroll = {x: 0, y: 0};
                    let autoScroll = function () {
                        const TIME_CONSTANT = 325; // arbitrary constant chosen experimentally
                        let elapsedSinceStop = Date.now() - endTime; // elapsed time since touchend
                        let exponentialDecay = Math.exp(-elapsedSinceStop / TIME_CONSTANT);
                        // where scroll should be at this time (due to inertia)
                        let scroll = {
                            x: amplitude.x * (1 - exponentialDecay),
                            y: amplitude.y * (1 - exponentialDecay)
                        }
                        // missing scroll distance (where scroll should be minus where scroll is now)
                        let delta = {
                            x: scroll.x - previousScroll.x,
                            y: scroll.y - previousScroll.y
                        }
                        // scrolling of missing scrolled distance
                        fattable.scroll.setScrollXY(fattable.scroll.scrollLeft + delta.x, fattable.scroll.scrollTop + delta.y);
                        previousScroll = scroll;
                        // momentum keeps going on until amplitude is almost reached or animation got interrupted by a new touchevent
                        if ((Math.abs(amplitude.x - scroll.x) > 0.5 || Math.abs(amplitude.y - scroll.y) > 0.5) && !interruptedMomentum && canScroll(delta)) {
                            requestAnimationFrame(autoScroll);
                        } else {
                            onMomentumEnd()
                        }
                    }
                    requestAnimationFrame(autoScroll);
                }
            }

            /*
             * Actual getOnTouchCallbacks function
             */
            return function (touchStartEvent) {
                // Initialization of scrollFattable variables
                startScroll = {
                    x: fattable.scroll.scrollLeft,
                    y: fattable.scroll.scrollTop
                };
                lastScroll = {
                    x: fattable.scroll.scrollLeft,
                    y: fattable.scroll.scrollTop
                };
                startTouch = touchStartEvent.originalEvent.changedTouches[0];
                lastTouch = touchStartEvent.originalEvent.changedTouches[0];

                // Initialization of trackVelocity variables
                prevScroll = {
                    x: fattable.scroll.scrollLeft,
                    y: fattable.scroll.scrollTop
                };
                velocity = {x: 0, y: 0};
                lastTimestamp = Date.now();
                keepTrackingVelocity = true;

                return {
                    onTouchStart: function (e) {
                        trackVelocity(e);
                    },
                    onTouchMove: function (e) {
                        scrollFattable(e);
                    },
                    onTouchEnd: function (e) {
                        animateMomentum(e);
                    }
                };
            }
        })();

        function onTouchStart(event) {
            let currentOnTouchCallbacks = getOnTouchCallbacks(event, element);
            currentOnTouchCallbacks.onTouchStart();
            element.on("touchmove", currentOnTouchCallbacks.onTouchMove);
            let onTouchEnd = function(event) {
                currentOnTouchCallbacks.onTouchEnd(event);
                element.off("touchmove", currentOnTouchCallbacks.onTouchMove);
                element.off("touchend", onTouchEnd);
            }
            element.on("touchend", onTouchEnd);
        }

        element.on("touchstart", onTouchStart);

        let removeOnDestroy = scope.$on('$destroy', function() {
            element.off("touchstart", onTouchStart);
        });

        return function() {
            removeOnDestroy();
            element.off("touchstart", onTouchStart)
        }
    }
});

app.service('ClipboardUtils', function(ActivityIndicator) {
    const svc = this;
    svc.copyToClipboard = function(text, successMessage='Successfully copied to the clipboard!', errorMessage='Failed to copy to the clipboard!') {
        if (!text) {
            return;
        }
        var tempInput = document.createElement("textarea");
        tempInput.style = "position: absolute; left: -1000px; top: -1000px";
        tempInput.value = text;
        document.body.appendChild(tempInput);
        tempInput.select();
        try {
            document.execCommand("copy");
            ActivityIndicator.success(successMessage, 5000);
        } catch (err) {
            ActivityIndicator.error(errorMessage, 5000);
        }
        document.body.removeChild(tempInput);
    };
    // for pasting into non-editable element
    // called after capturing ctrl + v keydown event
    svc.pasteFromClipboard = function(event, callback) {
        let tempInput = document.createElement("textarea");
        tempInput.style = 'position: absolute; left: -1000px; top: -1000px';
        document.body.appendChild(tempInput);
        tempInput.select();
        // delay to capture imput value
        window.setTimeout(function() {
            let data = tempInput.value;

            callback(data);

            document.body.removeChild(tempInput);

            if (event) {
                event.currentTarget.focus();
            }
        }, 100);
    }
});

app.factory('DetectUtils', function() {
    const svc = {
        getOS: function() {
            let browser = '';

            if (navigator.appVersion.indexOf("Win") !== -1){
                browser = 'windows';
            }

            if (navigator.appVersion.indexOf("Mac")!=-1){
                browser = 'macos';
            }

            if (navigator.appVersion.indexOf("X11")!=-1){
                browser = 'unix';
            }

            if (navigator.appVersion.indexOf("Linux")!=-1){
                browser = 'linux';
            }

            return browser;
        }
    };

    return svc;
});

app.constant("GRAPHIC_EXPORT_OPTIONS", {
    fileTypes: ['PDF','JPEG','PNG'],
    orientationMap: {
        'LANDSCAPE': 'Landscape',
        'PORTRAIT': 'Portrait'
    },
    paperSizeMap: {
        'A4': 'A4',
        'A3': 'A3',
        'US_LETTER': 'US Letter',
        'LEDGER': 'Ledger (ANSI B)',
        'SCREEN_16_9': '16:9 (Computer screen)',
        'CUSTOM': 'Custom'
    },
    paperSizeMapPage: {
        'A4': 'A4',
        'A3': 'A3',
        'US_LETTER': 'US Letter',
        'LEDGER': 'Ledger (ANSI B)'
    },
    paperInchesMap: {
        'A4': 11.6929,
        'A3': 16.5354,
        'US_LETTER': 11,
        'LEDGER': 17,
        'SCREEN_16_9': 11
    },
    ratioMap: {
        'A4': Math.sqrt(2),
        'A3': Math.sqrt(2),
        'US_LETTER': 11 / 8.5,
        'LEDGER': 17 / 11,
        'SCREEN_16_9': 16 / 9,
        'CUSTOM': 16 / 9
    }
});

app.service('GraphicImportService', function(GRAPHIC_EXPORT_OPTIONS) {
    const svc = this;
    svc.computeHeight = function (width, paperSize, orientation) {
        if (orientation == "PORTRAIT") {
            return Math.round(width * GRAPHIC_EXPORT_OPTIONS.ratioMap[paperSize]);
        } else {
            return Math.round(width / GRAPHIC_EXPORT_OPTIONS.ratioMap[paperSize]);
        }
    };
});

app.service('StringUtils',  function() {
    return {
        transmogrify: function(name, usedNames, makeName) {
            if (! (usedNames instanceof Set)) {
                usedNames = new Set(usedNames);
            }
            if (! usedNames.has(name)) {
                return name;
            }
            if (! makeName) {
                makeName = i => `${name} ${i}`;
            }

            let i = 2;
            while (usedNames.has(makeName(i, name))) {
                i++;
            }
        return makeName(i, name);
        }
    };
});

app.service('PermissionsService', function(Dialogs, Logger) {
    return {
        buildUnassignedGroups: function(item, allGroups) {
            if (!item || !allGroups) return;

            return allGroups.filter(function(groupName) {
                return item.permissions.every(perm => perm.group !== groupName);
            });
        },
        buildUnassignedUsers: function(item, allUsers) {
            return allUsers.filter(user =>
                item.owner !== user.login && item.permissions.every(perm => perm.user !== user.login));
        },
        transferOwnership: function(scope, item, itemName, ownerUiField="ownerLogin") {
            const ownerUi = scope.ui && scope.ui[ownerUiField];
            if (!ownerUi || !item || ownerUi === item.owner) return;
            const newOwnerDisplayName = scope.allUsers.find(user => user.login === ownerUi).displayName || ownerUi;

            Dialogs.confirm(scope, 'Ownership transfer',
                `Are you sure you want to transfer ${itemName} ownership to '${newOwnerDisplayName}' ?`).then(function() {
                Logger.info(`Transferring ${itemName} ownership to ${ownerUi}`);
                item.owner = ownerUi;
            },function() {
                scope.ui[ownerUiField] = item.owner;
            });
        }
    }
});

app.service('FullScreenService', ['$location', '$state', function ($location, $state) {
    return {
        isFullScreen: () => $location.search().fullScreen && $location.search().fullScreen !== "false"
    }
}]);

})();

(function() {
'use strict';

var app = angular.module('dataiku.controllers');

 // TODO : move those controllers !!


 app.controller('ConfirmDialogController', function($scope) {
    // Focus should already have been stolen in the
    // template, but sometimes it does not work ...
    window.setTimeout(function(){
        $(":focus").blur()
    }, 0);
    $scope.confirm = function() {
       if($scope.acceptDeferred) {
           $scope.acceptDeferred.resolve("Accepted");
       }
       $scope.acceptDeferred = null;
       $scope.dismiss();
   };
   $scope.cancel = function() {
       if($scope.acceptDeferred) {
           $scope.acceptDeferred.reject("Cancelled");
       }
       $scope.acceptDeferred = null;
       $scope.dismiss();
   };
});


app.controller('PromptDialogController', function($scope) {
    $scope.confirm = function() {
        if($scope.acceptDeferred) {
            $scope.acceptDeferred.resolve($scope.value);
        }
        $scope.acceptDeferred = null;
        $scope.dismiss();
    };
    $scope.cancel = function() {
        if($scope.acceptDeferred) {
            $scope.acceptDeferred.reject();
        }
        $scope.acceptDeferred = null;
        $scope.dismiss();
    };
});


app.controller('SelectDialogController', function($scope) {
    $scope.confirm = function() {
        if($scope.acceptDeferred) {
            $scope.acceptDeferred.resolve($scope.selectedItem);
        }
        $scope.acceptDeferred = null;
        $scope.dismiss();
    };
    $scope.cancel = function() {
        if($scope.acceptDeferred) {
            $scope.acceptDeferred.reject();
        }
        $scope.acceptDeferred = null;
        $scope.dismiss();
    };
    $scope.selectItem = function(item) {
        $scope.selectedItem = item;
    };
});


app.controller('ConflictDialogController', function($scope) {
    $scope.erase = function() {
        if($scope.acceptDeferred) {
            $scope.acceptDeferred.resolve("erase");
        }
        $scope.acceptDeferred = null;
        $scope.dismiss();
    };

    $scope.cancel = function() {
        if($scope.acceptDeferred) {
            $scope.acceptDeferred.reject();
        }
        $scope.acceptDeferred = null;
        $scope.dismiss();
    };

    $scope.forget = function() {
        if($scope.acceptDeferred) {
            $scope.acceptDeferred.resolve("ignore");
        }
        $scope.acceptDeferred = null;
        $scope.dismiss();
    };
});

app.controller('PasteModalController', function($scope, DetectUtils, WT1) {
    $scope.os = DetectUtils.getOS();
    
    $scope.uiState = {
        editMode: true,
        hasError: false,
        items: [],
        type: ''
    };

    $scope.validateData = $scope.validateData || (() => true);

    $scope.onPasteText = function(event) {
        let data = {};

        try {
            data = JSON.parse(event.originalEvent.clipboardData.getData('text/plain'));
        } catch(e) {}
        if (typeof $scope.applyGenericFormat === 'function') {
            data = $scope.applyGenericFormat(data);
        }
        if (data[$scope.itemKey] 
            && data[$scope.itemKey].length 
            && $scope.copyType === data.type
            && $scope.validateData(data[$scope.itemKey])) {
            let items = data[$scope.itemKey];

            if (typeof $scope.formatData === 'function') {
                items = $scope.formatData(data[$scope.itemKey]);
            }

            $scope.uiState.editMode = false;
            $scope.uiState.hasError = false;
            $scope.uiState.items = items;
            $scope.uiState.type = data.type;
        } else {
            $scope.uiState.hasError = true;
        }

        event.preventDefault();
    };

    $scope.confirm = function() {
        $scope.pasteItems($scope.uiState.items);
        WT1.event('paste-modal-submit', { dataType: $scope.uiState.type });
        $scope.dismiss();
    };
});

}());


(function() {
'use strict';

var app = angular.module('dataiku.services');

app.factory("Dialogs", ["CreateModalFromTemplate", "$q", "$state", "$timeout","DKUConstants", function(CreateModalFromTemplate, $q, $state, $timeout,DKUConstants) {
    return {
        ack : function($scope, title, text) {
            var deferred = $q.defer();
            CreateModalFromTemplate("/templates/dialogs/ack-dialog.html", $scope, "ConfirmDialogController", function(newScope) {
                newScope.acceptDeferred = deferred;
                newScope.title = title;
                newScope.text = text;
                newScope.$on("$destroy",function() {
                    if(newScope.acceptDeferred) {
                        newScope.acceptDeferred.reject();
                    }
                    newScope.acceptDeferred = null;
                });
            });
            return deferred.promise;
        },
        ackMarkdown : function($scope, title, text) {
            var deferred = $q.defer();
            CreateModalFromTemplate("/templates/dialogs/ack-dialog-markdown.html", $scope, "ConfirmDialogController", function(newScope) {
                newScope.acceptDeferred = deferred;
                newScope.title = title;
                newScope.text = text;
                newScope.$on("$destroy",function() {
                    if(newScope.acceptDeferred) {
                        newScope.acceptDeferred.reject();
                    }
                    newScope.acceptDeferred = null;
                });
            });
            return deferred.promise;
        },
        error : function($scope, title, text) {
            var deferred = $q.defer();
            CreateModalFromTemplate("/templates/dialogs/error-dialog.html", $scope, "ConfirmDialogController", function(newScope) {
                newScope.acceptDeferred = deferred;
                newScope.title = title;
                newScope.text = text;
                newScope.$on("$destroy",function() {
                    if(newScope.acceptDeferred) {
                        newScope.acceptDeferred.reject();
                    }
                    newScope.acceptDeferred = null;
                });
            });
            return deferred.promise;
        },
        confirm : function($scope, title, text) {
            var deferred = $q.defer();
            CreateModalFromTemplate("/templates/dialogs/confirm-dialog.html", $scope, "ConfirmDialogController", function(newScope) {
                newScope.acceptDeferred = deferred;
                newScope.positive = false;
                newScope.title = title;
                newScope.text = text;
                newScope.$on("$destroy",function() {
                    if(newScope.acceptDeferred) {
                        newScope.acceptDeferred.reject();
                    }
                    newScope.acceptDeferred = null;
                });
            });
            return deferred.promise;
        },
        confirmUnsafeHTML : function($scope, title, text) {
            var deferred = $q.defer();
            CreateModalFromTemplate("/templates/dialogs/confirm-dialog-unsafe-html.html", $scope, "ConfirmDialogController", function(newScope) {
                newScope.acceptDeferred = deferred;
                newScope.positive = false;
                newScope.title = title;
                newScope.text = text;
                newScope.$on("$destroy",function() {
                    if(newScope.acceptDeferred) {
                        newScope.acceptDeferred.reject();
                    }
                    newScope.acceptDeferred = null;
                });
            });
            return deferred.promise;
        },
        confirmPositive : function($scope, title, text) {
            var deferred = $q.defer();
            CreateModalFromTemplate("/templates/dialogs/confirm-dialog.html", $scope, "ConfirmDialogController", function(newScope) {
                newScope.acceptDeferred = deferred;
                newScope.positive = true;
                newScope.title = title;
                newScope.text = text;
                newScope.$on("$destroy",function() {
                    if(newScope.acceptDeferred) {
                        newScope.acceptDeferred.reject();
                    }
                    newScope.acceptDeferred = null;
                });
            });
            return deferred.promise;
        },
        confirmSimple : function($scope, text, positive = false) {
            var deferred = $q.defer();
            CreateModalFromTemplate("/templates/dialogs/confirm-dialog-simple.html", $scope, "ConfirmDialogController", function(newScope) {
                newScope.acceptDeferred = deferred;
                newScope.positive = positive;
                newScope.text = text;
                newScope.$on("$destroy",function() {
                    if(newScope.acceptDeferred) {
                        newScope.acceptDeferred.reject();
                    }
                    newScope.acceptDeferred = null;
                });
            });
            return deferred.promise;
        },
        confirmDisclaimer : function($scope, title, text, disclaimer) {
            var deferred = $q.defer();
            CreateModalFromTemplate("/templates/dialogs/confirm-dialog-disclaimer.html", $scope, "ConfirmDialogController", function(newScope) {
                newScope.acceptDeferred = deferred;
                newScope.positive = false;
                newScope.title = title;
                newScope.disclaimer = disclaimer;
                newScope.text = text;
                newScope.$on("$destroy",function() {
                    if(newScope.acceptDeferred) {
                        newScope.acceptDeferred.reject();
                    }
                    newScope.acceptDeferred = null;
                });
            });
            return deferred.promise;
        },

        confirmAlert : function($scope, title, text, alertText, severity) {
            var deferred = $q.defer();
            CreateModalFromTemplate("/templates/dialogs/confirm-dialog-alert.html", $scope, "ConfirmDialogController", function(newScope) {
                newScope.acceptDeferred = deferred;
                newScope.positive = false;
                newScope.title = title;
                newScope.alertText = alertText;
                newScope.severity = severity;
                newScope.text = text;
                newScope.$on("$destroy",function() {
                    if(newScope.acceptDeferred) {
                        newScope.acceptDeferred.reject();
                    }
                    newScope.acceptDeferred = null;
                });
            });
            return deferred.promise;
        },

        confirmInfoMessages : function($scope, title, data, text, skipIfNoMessages) {
            if (skipIfNoMessages && (data == null || data.messages.length == 0)) return $q.when(null);
            var deferred = $q.defer();

            CreateModalFromTemplate("/templates/dialogs/confirm-dialog-info-messages.html", $scope, "ConfirmDialogController", function(newScope) {
                newScope.modalTitle = title;
                newScope.data = data;
                newScope.acceptDeferred = deferred;
                newScope.positive = false;
                newScope.title = title;
                newScope.text = text;
                newScope.$on("$destroy",function() {
                    if(newScope.acceptDeferred) {
                        newScope.acceptDeferred.reject();
                    }
                    newScope.acceptDeferred = null;
                });
            });
            return deferred.promise;
        },

        infoMessagesDisplayOnly : function($scope, title, data, log, hideAlertHeader, backdrop, keyboard) {
            if (data.messages.length == 0) return $q.when(null);
            var deferred = $q.defer();
            CreateModalFromTemplate("/templates/dialogs/info-messages-dialog.html", $scope, null, function(newScope) {
                newScope.DKUConstants = DKUConstants;
                newScope.modalTitle = title;
                newScope.data = data;
                newScope.log = log;
                newScope.hideAlertHeader = hideAlertHeader;
                newScope.$on("$destroy",function() {
                    deferred.resolve();
                });
            }, backdrop, keyboard);
            return deferred.promise;
        },

        prompt : function($scope, title, text, defaultValue, options) {
            var deferred = $q.defer();
            CreateModalFromTemplate("/templates/dialogs/prompt-dialog.html", $scope, "PromptDialogController", function(newScope, newDOMElt) {
                newScope.acceptDeferred = deferred;
                newScope.title = title;
                newScope.text = text;
                newScope.value = defaultValue;
                newScope.options = options;
                newScope.$on("$destroy",function() {
                    if(newScope.acceptDeferred) {
                        newScope.acceptDeferred.reject();
                    }
                    newScope.acceptDeferred = null;
                });
                newDOMElt.on('keydown', 'input', function(e) {
                    if (e.which === 13 && newScope.renameForm.$valid === false) {
                        e.stopPropagation();
                    }
                })

                if (options && options.type === 'textarea') {
                    newDOMElt.on('keydown', 'textarea', function(evt) {
                        if (evt.which === 13) {
                            // prevent ENTER key from validating the popup from inside the textarea
                            evt.stopPropagation();
                        }
                    })
                }
            });
            return deferred.promise;
        },

        select : function($scope, title, text, items, selectedItem) {
            var deferred = $q.defer();
            CreateModalFromTemplate("/templates/dialogs/select-dialog.html", $scope, "SelectDialogController", function(newScope) {
                newScope.acceptDeferred = deferred;
                newScope.title = title;
                newScope.text = text;
                newScope.items = items;
                newScope.selectedItem = selectedItem;
                newScope.$on("$destroy",function() {
                    if(newScope.acceptDeferred) {
                        newScope.acceptDeferred.reject();
                    }
                    newScope.acceptDeferred = null;
                });
            });
            return deferred.promise;
        },

        eeUnavailableFeature : function($scope, lockedMessage, learnMoreURL){
           CreateModalFromTemplate("/templates/dialogs/ee-unavailable-feature-modal.html", $scope, null, function(newScope) {
            newScope.lockedMessage = lockedMessage;
            newScope.learnMoreURL = learnMoreURL;
        });
       },

       displaySerializedError: function($scope, e) {
            CreateModalFromTemplate("/templates/dialogs/serialized-error-modal.html", $scope, null, function(newScope) {
                newScope.error = e;
            });
        },


       openEditInNotebookConflictDialog: function($scope) {
        var deferred = $q.defer();
        CreateModalFromTemplate("/templates/dialogs/edit-in-notebook-conflict-dialog.html", $scope, "ConflictDialogController", function(newScope) {
            newScope.acceptDeferred = deferred;
            newScope.$on("$destroy", function() {
                if (newScope.acceptDeferred) {
                    newScope.acceptDeferred.reject();
                }
                newScope.acceptDeferred = null;
            });
        });
        return deferred.promise;
       },

       openConflictDialog : function($scope,conflictResult) {

        var deferred = $q.defer();
        CreateModalFromTemplate("/templates/dialogs/save-conflict-dialog.html", $scope, "ConflictDialogController", function(newScope) {
            newScope.acceptDeferred = deferred;
            newScope.conflictResult = conflictResult;
            newScope.$on("$destroy",function() {
                if(newScope.acceptDeferred) {
                    newScope.acceptDeferred.reject();
                }
                newScope.acceptDeferred = null;
            });
        });
        return deferred.promise;
    },

    saveChangesBeforeLeaving: function(scope, dirty, save, revert, msg) {
        if (typeof dirty != 'function') {
            console.error("Dirtyness detection is not valid. typeof dirty = ", typeof dirty, dirty); /*@console*/ // NOSONAR: OK to use console.
        }
        if (typeof save != 'function') {
            console.error("Saving function is not valid. typeof save = ", typeof save, save); /*@console*/ // NOSONAR: OK to use console.
        }
        if (revert && typeof revert != 'function') {
            console.error("Revert function is not valid. typeof revert = ", typeof revert, revert); /*@console*/ // NOSONAR: OK to use console.
        }

        scope.$on('$stateChangeStart', function (event, toState, toParams, fromState, fromParams) {
            var isDirty = false;
                try { // Don't keep the reference to the scope in dssHasDirtyThings, so never fail this check!
                isDirty = dirty(toState, toParams, fromState, fromParams);
            } catch (e) {
                console.error("Failed to check dirtiness"); /*@console*/ // NOSONAR: OK to use console.
            }
            if (isDirty) {
                event.preventDefault();

                CreateModalFromTemplate("/templates/dialogs/unsaved-changes-warning.html", scope, null, function(modalScope) {
                    modalScope.msg = msg;

                    var goToState = function() {
                        $timeout(function() {
                            $state.go(toState, toParams);
                            modalScope.resolveModal();
                        });
                    };

                    modalScope.saveAndContinue = function() {
                        var saveResult = save();
                        if (saveResult && saveResult.success)  {
                            saveResult.success(goToState);
                        } else {
                            goToState();
                        }

                        if (saveResult && saveResult.error) {
                            saveResult.error(setErrorInScope.bind(modalScope));
                        }
                    };

                    modalScope.continueWithoutSaving = function() {
                        if (revert) {
                            revert();
                        }

                        goToState();
                    };
                });

                return false;
            } else {
            }
        });
    },

    checkChangesBeforeLeaving: checkChangesBeforeLeaving
};

}]);


})();
(function() {
'use strict';

const app = angular.module('dataiku.services');


app.factory("WebSocketService", function($q, $rootScope, Notification, WT1, Logger, $$cookieReader) {

    const ERROR_CODE = Object.freeze({
        CONNECTION_LOST: 2,
        CONNECTION_FAILED: 3,
        CONNECTION_ESTABLISHED: 4
    });

    const PING_INTERVAL = 15000;
    const RECONNECT_TIMEOUT = 50000;
    const DEV_RECONNECT_TIMEOUT = 5000;

    // This ID identifies this browser session
    const sessionId = generateRandomId(10);
    // At a single point in time, only one websocket can be active
    const webSocketProtocol = window.location.protocol.indexOf("https") == 0 ? "wss" : "ws";
    const webSocketUrl = webSocketProtocol + "://" + window.location.host + "/dip/websocket?sessionId=" + sessionId;

    let webSocket = null;
    let reallyConnected = false;
    let everConnected = false;
    let hasFailed = false;

    // Store the event we want to send
    let eventQueue = [];

    function flushEventQueue() {
        if(reallyConnected && webSocket != null) {
             for(const k in eventQueue) {
                webSocket.send(JSON.stringify(eventQueue[k]));
             }
             eventQueue = [];
        }
    }

    function connect() {
        Logger.info("Attempting WS connection");

        if(webSocket != null) {
            return;
        }

        try {
            // Websockets can't have custom headers so we pass the XSRF token through the sub-protocols
            // Plus "dummy" that will get chosen by the server (mandated by WS protocol)
            const xsrfToken = $$cookieReader()[$rootScope.appConfig.xsrfCookieName];
            webSocket = new WebSocket(webSocketUrl, ["dummy", "xsrf-" + xsrfToken]);
        } catch (e) {
            console.error("WS error: " + e.message, e); /*@console*/  // NOSONAR: OK to use console.
            hasFailed = true;
            if(everConnected) {
                emitToFrontend("websocket-status-changed", {
                    code: ERROR_CODE.CONNECTION_LOST,
                    reason : "Unable to re-create a Websocket connection ("+e.message+")"
                });
            } else {
                emitToFrontend("websocket-status-changed", {
                    code: ERROR_CODE.CONNECTION_FAILED,
                    reason : "Could not create a Websocket connection ("+e.message+")"
                });
                WT1.event("websocket-failed", {reason:e.message});
            }
            return;
        }

        const thisWebSocket = webSocket;

        webSocket.onopen = function() {
            const pingMessage = {
                type: "ping",
                event: {
                    webSocketSessionId: sessionId
                }
            };
            if(thisWebSocket == webSocket) {
                thisWebSocket.send(JSON.stringify(pingMessage));
                const intervalId = setInterval(function() {
                    if(thisWebSocket == webSocket) {
                        thisWebSocket.send(JSON.stringify(pingMessage));
                    } else {
                        clearInterval(intervalId);
                    }
                }, PING_INTERVAL);
            }
        };

        webSocket.onmessage = function (evt) {
            $rootScope.$applyAsync(function() {
                if(!reallyConnected) {
                    emitToFrontend("websocket-status-changed", {
                        code: ERROR_CODE.CONNECTION_ESTABLISHED,
                        reason : "Connection established !"
                    });
                    reallyConnected = true;
                    everConnected = true;
                    flushEventQueue();
                }
                const notification = JSON.parse(evt.data);
                if (notification.type != "pong" && notification.type != "watch-triggered") {
                    Logger.debug("Message from WS: " + notification.type);
                }
                emitToFrontend(notification.type, notification.event);
            });
        };

        webSocket.onerror = function(evt) {
            hasFailed = true;
            console.warn("Websocket error", evt); /*@console*/ // NOSONAR: OK to use console.
        };

        webSocket.onclose = function(evt) {
            Logger.info("WS closed:" , evt);
            if ((evt instanceof CloseEvent) && (1001 === evt.code || 1011 === evt.code)) {
                // Unlike Chrome, Firefox calls onclose when it is closing a WS because
                // its tab is closing or the user is navigating away, which would cause the
                // "disconnected" overlay to appear before the new page is loaded.
                // See https://developer.mozilla.org/fr/docs/Web/API/CloseEvent
                Logger.info("Closing tab or navigating away. Not executing WS onclose [firefox].");
                return;
            }
            $rootScope.$apply(function() {
                webSocket = null;
                hasFailed = true;
                if(reallyConnected) {
                    emitToFrontend("websocket-status-changed", {
                        code: ERROR_CODE.CONNECTION_LOST,
                        reason : "You lost connection to the server",
                    });
                } else {
                    emitToFrontend("websocket-status-changed", {
                        code: everConnected?ERROR_CODE.CONNECTION_LOST:ERROR_CODE.CONNECTION_FAILED,
                        reason : "Websocket connection failed"
                    });
                    if(!everConnected) {
                        WT1.event("websocket-failed", {reason:'Connection closed'});
                    }
                }
                // after losing connection, the first re-connect attempt we try is instant
                const timeoutDelay = reallyConnected ? 0 : (window.devInstance ? DEV_RECONNECT_TIMEOUT : RECONNECT_TIMEOUT);
                reallyConnected = false;
                setTimeout(function() {
                    connect();
                }, timeoutDelay);
            });
        };
    }

    function broadcastToBackend(type,event) {
        const copied = angular.copy(event ? event : {});
        copied.webSocketSessionId = sessionId;
        eventQueue.push({
            type: type,
            event: copied
        });
        flushEventQueue();
    }

    function emitToFrontend(type,event) {
        Notification.publishToFrontend(type, event);
    }

    Notification._setBackendEventHandler(broadcastToBackend);

    return {
        // Connect the websocket, or force reconnect.
        connect : connect,
        // Returns true if the websocket is connected
        isConnected : function() {
            return reallyConnected;
        },
        // Returns true if the websocket is or has been connected in the past.
        hasEverConnected : function() {
            return everConnected;
        },
        // Returns true if the websocket has been available in the past,
        // or if it didn't fail yet.
        isAvailable : function() {
            return !hasFailed || everConnected;
        },
        getSessionId : function() {
            return sessionId;
        },
        // List of error codes
        ERROR_CODE : ERROR_CODE
    };

});


})();

(function(){
'use strict';

const app = angular.module('dataiku.services');


    app.factory("Notification", [function() {

            var dispatcherTable = {};

            var backendEventHandler = null;

            var registerEvent = function(type,eventListener) {
                if(!type) return angular.noop;
                var listeners = dispatcherTable[type];
                if(!listeners) {
                    listeners = [];
                    dispatcherTable[type] = listeners;
                }
                var listenerWrapper = function(type, event) {
                    eventListener(type,event);
                }
                listeners.push(listenerWrapper);
                return function() {
                    var idx = listeners.indexOf(listenerWrapper);
                    if(idx != -1) {
                        listeners.splice(idx,1);
                    }
                };
            };

            var publishToBackend = function(type, event) {
                if(!event) {
                    event={};
                }
                if(backendEventHandler) {
                    backendEventHandler(type,event);
                }
            };

            var publishToFrontend = function(type, event) {
                if(!event) {
                    event={};
                }
                var listeners = dispatcherTable[type];
                if(listeners) {
                    for(var k in listeners) {
                        listeners[k](type,event);
                    }
                }
            };

            var broadcastToFrontends = function(loopBack) {
                return function(type,event) {
                    publishToBackend('ui-broadcast',{
                        nestedEvent : {
                            type : type,
                            event : event
                        },
                        loopBack : loopBack
                    });
                }
            };

            var setBackendEventHandler = function(handler) {
                backendEventHandler = handler;
            }

            return {
                // Register a new event listener. The event may be coming from the frontend (sent by NotificationService.$broadcast)
                // or from the backend.
                registerEvent: registerEvent,

                // Publish an event to the current frontend
                publishToFrontend : publishToFrontend,

                // Publish an event to the backend
                publishToBackend : publishToBackend,

                // Publish an event to all the frontends (including this one)
                broadcastToFrontends : broadcastToFrontends(true),

                // Publish an event to all the frontends (except this one)
                broadcastToOtherSessions : broadcastToFrontends(false),

                // Register the backend event handler (which is WebSocketService)
                // The purpose is to break the dependency cycle.
                _setBackendEventHandler : setBackendEventHandler

            };
    }]);

})();
(function(){
'use strict';

    const app = angular.module('dataiku.services');

    app.factory("IntercomSupport", function($rootScope, $state, Assert, ContextualMenu, LoggerProvider){
        var Logger = LoggerProvider.getLogger("IntercomSupport");
        var loaded = false;
        var shown = false;

        var svc = {
            activate : function(){
                Assert.inScope($rootScope, "appConfig");

                if (!$rootScope.appConfig.licensing ||
                    !$rootScope.appConfig.licensing.licenseContent ||
                    !$rootScope.appConfig.licensing.licenseContent.properties ||
                    !$rootScope.appConfig.licensing.licenseContent.properties.intercomAppId) {
                    return;
                }

                /* CE users: even if license gives an app id, Intercom is only enabled
                 * during trial period. Except if specially allowed */
                if ($rootScope.appConfig.communityEdition) {
                    if (!$rootScope.appConfig.licensing.ceEntrepriseTrial && 
                        !$rootScope.appConfig.licensing.licenseContent.properties.intercomAfterTrial) {
                        return;
                    }
                }

                var appId = $rootScope.appConfig.licensing.licenseContent.properties.intercomAppId;
                var intercomCode = "<script>(function(){var w=window;var ic=w.Intercom;if(typeof ic==='function'){ic('reattach_activator');ic('update',intercomSettings);}else{var d=document;var i=function(){i.c(arguments)};i.q=[];i.c=function(args){i.q.push(args)};w.Intercom=i;function l(){var s=d.createElement('script');s.type='text/javascript';s.async=true;s.src='https://widget.intercom.io/widget/"+appId+"';var x=d.getElementsByTagName('script')[0];x.parentNode.insertBefore(s,x);} w.dkuIntercomLoadFunction = l;}})()</script>"

                if (!loaded){
                    $("body").append($(intercomCode));
                    loaded = true;
                }
                $rootScope.intercomEnabled = true;

                $rootScope.forceShowIntercom = function(){
                   $("body").removeClass("dku-intercom-hidden");
                   Intercom("show");
                   ContextualMenu.prototype.closeAny();
                }

                var licenseKind = $rootScope.appConfig.licensing.licenseContent.licenseKind;
                var company = $rootScope.appConfig.licensing.licenseContent.licensee.company;
                var niceName = $rootScope.appConfig.user.displayName + " (" + $rootScope.appConfig.user.login + ") ("+ licenseKind + ": " + company + ")";
                Logger.info("Executing Intercom load hook");
                window.dkuIntercomLoadFunction();
                Logger.info("Enqueuing Intercom boot");
                window.Intercom("boot", {
                    app_id: appId,
                    license_kind : $rootScope.appConfig.licensing.licenseContent.licenseKind,
                    license_instance_id : $rootScope.appConfig.licensing.licenseContent.instanceId,
                    licensee_company: company,
                    licensee_email: $rootScope.appConfig.licensing.licenseContent.licensee.name,
                    name : niceName,
                    email: $rootScope.appConfig.user.email
                });
                Intercom("onShow", function(){
                    shown = true;
                })
                Intercom("onHide", function(){
                    shown = false;
                })

                if ($state.current.name == "home") {
                    $("body").removeClass("dku-intercom-hidden")
                } else {
                    $("body").addClass("dku-intercom-hidden")
                }

                $rootScope.$on("$stateChangeSuccess", function(event, toState) {
                    if(toState.name != "home") {
                        if (!shown) {
                            $("body").addClass("dku-intercom-hidden");
                        }
                    } else {
                        $("body").removeClass("dku-intercom-hidden");
                    }
                })
            }
        }
        return svc;
    })

    app.factory('TrackingService', function($rootScope, $state, $stateParams, Assert, Notification) {
            var lastEvent = new Date().getTime();
            var isIdle = false;

            // Max idle time before being considered idle (10 mn)
            var idleTime = 10 * 60 * 1000;

            // Track page changes
            $rootScope.$on("$stateChangeSuccess",function(event, toState, toParams, fromState, fromParams){
                // Some parameters (in catalog) are not a string: scope and _type are arrays.
                const arrayParameters =
                    Object.entries(toParams).filter(paramEntry => Array.isArray(paramEntry[1]));
                if (arrayParameters.length > 0) {
                    toParams = angular.copy(toParams);
                    arrayParameters.forEach(parameter => {
                        toParams[parameter[0]] = JSON.stringify(parameter[1]);
                    });
                }
                Notification.publishToBackend('ui-state-changed', {
                      stateName : toState.name,
                      stateParams : toParams
                  });
                  resetIdleTimer();
            });

            if($state.current && $state.current.name) {
                Notification.publishToBackend('ui-state-changed', {
                    stateName : $state.current.name,
                    stateParams : $stateParams
                });
            }

            var idleTimeout = null;

            var resetIdleTimer = function() {
                setIdleState(false);
                lastEvent = new Date().getTime();
                if(idleTimeout !== null) {
                    clearTimeout(idleTimeout);
                }
                idleTimeout = setTimeout(function() {
                    setIdleState(true);
                },idleTime);
            };

            var setIdleState = function(newIdleState) {
                if(isIdle != newIdleState) {
                    $rootScope.$apply(function() {
                        isIdle = newIdleState;
                        Notification.publishToBackend('ui-idle-state-changed',{
                            isIdle : newIdleState
                        });
                    });
                }
            };

            // Reset idle timer on page events
            var eventList = ['mousemove','mousedown','keypress','mousewheel','touchmove'];

            for(var k in eventList) {
                window.addEventListener(eventList[k],resetIdleTimer,false);
            }

            resetIdleTimer();
            Notification.publishToBackend('ui-idle-state-changed',{
                                    isIdle : false
            });

            return {
                isIdle : function() {
                    return isIdle;
                },
                setIdleTime : function(newIdleTime) {
                    idleTime = newIdleTime;
                },
                resetIdleTimer : resetIdleTimer,
                configurePingTracking : function(){
                    Assert.inScope($rootScope, "appConfig");
                    if ($rootScope.appConfig.udr && $rootScope.appConfig.pingTracking) {
                        window.setInterval(function(){
                            if (window.WT1SVC) {
                                window.WT1SVC.event("pingt", {
                                    "idle": isIdle,
                                    "lastEvent": new Date().getTime() - lastEvent
                                })
                            }
                        }, $rootScope.appConfig.pingTrackingInterval);
                    }
                }
            };

    });


    app.factory('WatchService',["Notification", "$rootScope", "$state", "$stateParams", "Debounce", "WebSocketService",
            function(Notification, $rootScope, $state, $stateParams, Debounce, WebSocketService) {

        var registeredWatchers = [];
        var id = 0;

        var newId = function() {
            id++;
            return 'W'+id;
        }

        var updateWatchList = Debounce().withDelay(50,50).wrap(function() {
            var watches = [];
            for(var k in registeredWatchers) {
                watches.push(registeredWatchers[k].watch);
            }
            Notification.publishToBackend('watch-list-changed',{
                watches : watches
            });
        });

        var watchState = function(callback, statePrefix, stateParams) {
            var watcher = {
                callback: callback,
                watch : {
                    statePrefix : statePrefix?statePrefix:'',
                    stateParams : angular.copy(stateParams?stateParams:{}),
                    watchId : newId()
                }
            };
            registeredWatchers.push(watcher);
            updateWatchList();

            return function() {
                 var idx = registeredWatchers.indexOf(watcher);
                 if(idx!=-1) {
                    registeredWatchers.splice(idx,1);
                 }
            };
        };

        Notification.registerEvent('watch-triggered',function(evt, message) {
            for(var k = 0 ; k <  message.results.length ; k++) {
                var theId = message.results[k].watchId;
                for(var j = 0 ; j < registeredWatchers.length ; j++) {
                    if(registeredWatchers[j].watch.watchId == theId) {
                        var watchResult = message.results[k];
                        var conflictingSessions = watchResult.sessions;
                        for(var l in conflictingSessions) {
                            var conflictingSession = conflictingSessions[l];
                            conflictingSession.isCurrentSession =
                                (conflictingSession.sessionId == WebSocketService.getSessionId());
                        }
                        registeredWatchers[j].callback(conflictingSessions);
                        break;
                    }
                }
            }
        });

        return {
            watchState : watchState
        };

    }]);


    app.factory('ConflictDetector', function($state, $stateParams, $rootScope, Notification, WatchService, Debounce, Logger) {
        var trackedStates = [
            {
                state : 'projects.project.datasets.dataset.settings',
                params : ['projectKey','datasetName'],
                title : 'Users editing this dataset'
            },
            {
                state : 'projects.project.datasets.dataset.edit',
                params : ['projectKey','datasetName'],
                title : 'Users editing this dataset'
            },
            {
                state : 'projects.project.recipes.recipe',
                params : ['projectKey','recipeName'],
                title : 'Users editing this recipe'
            },
            {
                state : 'projects.project.datasets.dataset.shakers.shaker',
                params : ['projectKey','datasetName','scriptId'],
                title : 'Users on this preparation script'
            },
            {
                state : 'projects.project.wiki.article.edit',
                params : ['projectKey', 'articleId'],
                title : 'Users on this article'
            },
            {
                state : 'projects.project.notebooks.jupyter_notebook',
                params : ['projectKey','notebookId'],
                title : 'Users on this notebook'
            },
            {
                state : 'projects.project.notebooks.sql_notebook',
                params : ['projectKey','notebookId'],
                title : 'Users on this notebook'
            },
            {
                state : 'projects.project.analyses.analysis',
                params : ['projectKey','analysisId'],
                title : 'Users on this analysis'
            },
            {
                state : 'projects.project.analyses.analysis.ml.predmltask',
                params : ['projectKey', 'mlTaskId'],
                title : 'Users on this ML task'
            },
            {
                state : 'projects.project.analyses.analysis.ml.clustmltask',
                params : ['projectKey', 'mlTaskId'],
                title : 'Users on this ML task'
            },
            {
                state : 'projects.project.dashboards.dashboard.edit',
                params : ['projectKey', 'dashboardId'],
                title : 'Users editing this dashboard'
            },
            {
                state : 'projects.project.dashboards.insights.insight.edit',
                params : ['projectKey', 'insightId'],
                title : 'Users editing this insight'
            },
            {
                state: 'projects.project.scenarios.scenario',
                params : ['projectKey', 'scenarioId'],
                title : 'Users on this scenario'
            },
            {
                state: 'projects.project.webapps.webapp.edit',
                params : ['projectKey', 'webAppId'],
                title : 'Users editing this webapp'
            },
            {
                state: 'plugindev.editor',
                params : ['pluginId'],
                title : 'Users editing this plugin'
            },
            {
                state : 'projects.project.datasets.dataset.statistics.worksheet',
                params : ['projectKey', 'datasetName', 'worksheetId'],
                title : 'Users on this worksheet'
            },
            {
                state : 'projects.project.foreigndatasets.dataset.statistics.worksheet',
                params : ['projectKey', 'datasetName','worksheetId'],
                title : 'Users on this worksheet'
            }
        ];

        // Sort by depth in the state hierarchy
        trackedStates.sort(function(a,b) {
            var cmp = b.state.length - a.state.length;
            if(cmp == 0) {
                cmp = b.params.length - a.params.length;
            }
            return cmp;
        });



        var notifyConflictListChanged = Debounce().withDelay(50,50).wrap(function() {
            $rootScope.$broadcast('conflict-list-changed');
        });

        var rebuildTrackersForState = function(toState,toParams) {
            for(var k in trackedStates) {
                (function(trackedState) {
                    if(trackedState.tracker) {
                        trackedState.tracker();
                        trackedState.tracker = null;
                    }
                    if(toState.indexOf(trackedState.state)== 0) {
                        var params = {};
                        for(var j in trackedState.params) {
                            var paramName = trackedState.params[j];
                            params[paramName] = toParams[paramName];
                        }
                        trackedState.tracker = WatchService.watchState(function(sessions) {
                            trackedState.sessions = [];
                            for(var k in sessions) {
                                var session = sessions[k];
                                //if(!session.isCurrentSession) {
                                    trackedState.sessions.push(session);
                                //}
                            }
                            notifyConflictListChanged();
                        },trackedState.state,params, trackedState.ignoredValues);
                    }
                })(trackedStates[k]);
            }
            notifyConflictListChanged();
        };

        $rootScope.$on("$stateChangeSuccess",function(event, toState, toParams, fromState, fromParams){
            rebuildTrackersForState(toState.name,toParams);
        });

        if($state.current && $state.current.name) {
            rebuildTrackersForState($state.current.name,$stateParams);
        }

        return {
            listConflicts : function() {

                let out = [];
                let userMap = {};

                for(let trackedStateItem in trackedStates) {
                    let trackedState = trackedStates[trackedStateItem];
                    let userList = [];

                    if($state.current.name.indexOf(trackedState.state) == 0) {
                        if(trackedState.sessions && trackedState.sessions.length) {
                            for(let sessionItem in trackedState.sessions) {
                                let session = trackedState.sessions[sessionItem];
                                if(!userMap[session.user.login]) {

                                    let sessionUser = {
                                        userLogin : session.user.login,
                                        userDisplayName : session.user.displayName,
                                        active : !session.isIdle
                                    };

                                    userList.push(sessionUser);
                                    userMap[session.user.login] = sessionUser;

                                } else {
                                    if(!session.isIdle) {
                                        userMap[session.user.login].active = true;
                                    }
                                }
                            }
                        }
                    }
                    if(userList.length>0) {
                        let totalNbWindows = 0;
                        for(let userListItem in userList) {
                            let user = userList[userListItem];
                            user.nbWindows = 0;
                            for(let s in trackedState.sessions) {
                                let userSession = trackedState.sessions[s];
                                if(userSession.user.login == user.userLogin) {
                                    user.nbWindows++;
                                    totalNbWindows++;
                                }
                            }
                        }

                        out.push({
                            state : trackedState.state,
                            params : trackedState.params,
                            title : trackedState.title,
                            warn : totalNbWindows > 1,
                            users : userList
                        });
                    }
                }
                for(let k in out) {
                    if(out[k].warn) {
                        Logger.info('Detected state conflict with another user!',out[k].users)
                    }
                }

               return out;
            }
        };

    });

})();
(function(){
'use strict';

var app = angular.module('dataiku.services.help', []);


/* ****************************************
 * Coachmarks system
 * ****************************************/

app.controller("CoachmarkController", function($scope, CoachmarksService){
	// In the scope: "seriesState"

    $scope.disableCoachmarks = function(){
        $scope.dismiss();
        CoachmarksService.globallyDisable($scope.seriesState);
    }

	// On State change = dismiss without saving that we advanced
});

app.directive("coachmarkHeader", function($filter, $timeout) {
    return {
        template : '<div class="title">' +
        '{{title}}'+
        // '<span class="close-btn" ng-click="hideCoachmark()" style="display: inline-block; float: right;">╳</span>' +
        '</div>',
        replace : true,
        link: function($scope, element, attrs) {
            $scope.title = attrs["title"];
        }
    }
});

app.directive("coachmarkFooterRegular", function($filter, $timeout) {
    return {
        template : '<div class="footer">' +
        'Disable tooltips from the help menu '+
        // '<img src="/static/dataiku/images/coachmarks/help-menu.png">'+
        '<i class="icon-dku-help" style="opacity: 1; color: rgb(43, 178, 173);"></i>'+
        '<i class="icon-dku-help" style="color: #212121"></i>'+
        // '<span class="close-btn" ng-click="hideCoachmark()" style="display: inline-block; float: right;">╳</span>' +
        '</div>',
        replace : true
    }
});

/**
 * Directive to disable/enable a serie of pulsars
 */
app.directive("coachmarkSerieSwitch", function(CoachmarksService, $timeout) {
    return {
        restrict: 'A',
        replace: true,
        link: function ($scope, element, attrs) {

            $scope.serieId = attrs['serieId'];

            $scope.serieEnabled = !CoachmarksService.isSerieDisabled($scope.serieId);
            $scope.switchOffSerie = function() {
                $timeout(function() {
                    $('.master-status__icon--help .icon-dku-help').removeAttr("style");
                    CoachmarksService.disableSerie($scope.serieId);
                }, 250);
            }

            $timeout(function(){
                if (window.cleanQuestionSignBtnTimeout) {
                    $timeout.cancel(window.cleanQuestionSignBtnTimeout);
                    cleanQuestionSignBtn();
                }
                $('.master-status__icon--help .icon-dku-help').css("opacity", 1);
                $('.master-status__icon--help .icon-dku-help').css("color", "#2BB2AD");
            });

            $scope.$on("$destroy", function(){
                $('.master-status__icon--help .icon-dku-help').css({"transition": "2000ms ease all", "transition-property": "opacity, color"});
                $('.master-status__icon--help .icon-dku-help').css("transition-delay", "1000ms");
                $('.master-status__icon--help .icon-dku-help').css("opacity", 0.7);
                $('.master-status__icon--help .icon-dku-help').css("color", "white");
                window.cleanQuestionSignBtnTimeout = $timeout(cleanQuestionSignBtn, 3050);
            });

            var cleanQuestionSignBtn = function() {
                $('.master-status__icon--help .icon-dku-help').removeAttr("style");
                delete window.cleanQuestionSignBtnTimeout;
            }
        }
    }
});

/**
 * Directive to display a pulsar. On hover, this pulsar will display a coachmark (ie: a big tooltip window)
 */
app.directive("coachmarkPulsar", function($timeout, $compile, CoachmarksService) {
    return {
        restrict: 'A',
        template : '<div class="coachmark-pulsar" ng-mouseenter="displayCoachmark()" ng-mouseleave="setAbovePulsarFalse()" ng-show="!step.noPulsar"></div>',
        replace: true,
        link : function($scope, element, attrs) {

            $scope.coarchmarkAppended = false;
            $scope.coachmarkWrapper = {}

            var appendCoachmark = function() {
                $scope.coachmarkWrapper.element = $('<div class="coachmark-wrapper" ng-mouseenter="setAboveCoachmark(true)" ng-mouseleave="setAboveCoachmark(false)" ng-show="coachmarkDisplayed.step == step"><div ng-include="step.templateUrl" onload="onCoachmarkLoad()" class="coachmark-sub-wrapper"></div></div>');
                $scope.coachmarkWrapper.scope = $scope.$new();
                $compile($scope.coachmarkWrapper.element)($scope.coachmarkWrapper.scope);
                $('.coachmark-container').append($scope.coachmarkWrapper.element);
                $scope.coarchmarkAppended = true;
                $scope.$on("$destroy", function() {
                    $scope.coachmarkWrapper.element.remove();
                })
            };

            $scope.onCoachmarkLoad = function() {
                $scope.coachmarkWrapper.element.css('visibility', 'hidden');
                if ($scope.step.coachmarkSizeCallback) {
                    $scope.step.coachmarkSizeCallback($scope.coachmarkWrapper.element, $scope.coachmarkWrapper.scope);
                }
                if ($scope.step.coachmarkPositionCallback) {
                    $scope.step.coachmarkPositionCallback(element, $scope.coachmarkWrapper.element, $scope.coachmarkWrapper.scope);
                } else {
                    CoachmarksService.positionning.smartCoachmarkPosition(element, $scope.coachmarkWrapper.element);
                }
                $scope.coachmarkWrapper.element.css('visibility', 'visible');
            }

            var uiState = {
                abovePulsar: false,
                aboveCoachmark: false
            };

            $scope.displayCoachmark = function() {
                //appending coachmark content if not previously done
                if (!$scope.coarchmarkAppended) {
                    appendCoachmark();
                }

                //registering this step as the one currently displayed
                $scope.coachmarkDisplayed.step = $scope.step;

                //undoing everything when coachmark get hidden
                var unregisterWatch = $scope.$watch("coachmarkDisplayed.step", function() {
                    if ($scope.coachmarkDisplayed.step != $scope.step) {

                        //since coachmark cannot be redisplayed (no UI to do so since no pulsar), we destroy the all directive
                        if ($scope.step.noPulsar) {
                            $timeout(function() {
                                $scope.$destroy();
                            });
                        }
                        //$watch returns a function to clear itself in angular
                        unregisterWatch();
                    }
                }, true);

                if (setAbovePulsarFalseTimeout) {
                    $timeout.cancel(setAbovePulsarFalseTimeout);
                }
                uiState.abovePulsar = true;
            };

            var setAbovePulsarFalseTimeout = null;
            $scope.setAbovePulsarFalse = function() {
                setAbovePulsarFalseTimeout = $timeout(function() {
                    uiState.abovePulsar = false;
                    if (!uiState.abovePulsar && ! uiState.aboveCoachmark) {
                        $scope.hideCoachmark();
                        //console.log("Hidding coachmark (from pulsar) " + $scope.step.templateUrl);
                    }
                }, 500);
                //console.log()
            };

            var setAboveCoachmarkFalseTimeout = null;
            $scope.setAboveCoachmark = function(isAbove) {
                if (isAbove) {
                    uiState.aboveCoachmark = true;
                    if (setAboveCoachmarkFalseTimeout) {
                        $timeout.cancel(setAboveCoachmarkFalseTimeout);
                    }
                } else {
                    setAboveCoachmarkFalseTimeout = $timeout(function() {
                        uiState.aboveCoachmark = false;
                        if (!uiState.abovePulsar && ! uiState.aboveCoachmark) {
                            $scope.hideCoachmark();
                            //console.log("Hidding coachmark (from coachmark) " + $scope.step.templateUrl);
                        }
                    }, 500);
                }
            };

            $scope.hideCoachmark = function() {
                if ($scope.coachmarkDisplayed.step == $scope.step) {
                    $scope.coachmarkDisplayed.step = null;
                }
            };

            if ($scope.step.autoDisplay) {
                $scope.displayCoachmark();
            }
            $timeout(function() {
                if ($scope.step.pulsarCallback) {
                    $scope.step.pulsarCallback(element, $scope);
                }
            }, 0);
        }
    }
});

/**
 * Directive to display a serie of coachmarks (coachmarks are grouped by series, there is roughly a serie of coachmarks per screen in the app)
 */
app.directive("coachmarkSerie", function(CoachmarksService, Logger, WT1, CreateModalFromTemplate) {
    return {
        restrict: 'A',
        link: function ($scope, element, attrs) {

            // Displaying Coachmarks Series
            var onCoachmarksStateChanged = function() {
                $scope.displayPulsars = CoachmarksService.canDisplaySerie($scope.serieId);
                if ($scope.displayPulsars) {
                    WT1.event("coachmark-series-start", { seriesId : $scope.serieId });
                    if (!CoachmarksService.isSerieAlreadyWatched($scope.serieId)) {
                        CoachmarksService.setAlreadyWatched($scope.serieId);
                    }
                }
            };

            // Computing extra steps
            var computeExtraStepsList = function() {
                $scope.extraSteps = [];
                if ($scope.extraSerieIds && $scope.extraSerieIds.length) {
                    $scope.extraSerieIds.forEach(function(id) {
                        $scope.extraSteps = $scope.extraSteps.concat(CoachmarksService.registry[id].steps);
                    });
                }
            };

            /*
             * Main
             */

            $scope.displayPulsars = false;
            $scope.serieAlreadyWatched = CoachmarksService.isSerieAlreadyWatched($scope.serieId);
            $scope.coachmarkDisplayed = {};
            $scope.serie = {
                id : $scope.serieId,
                def : CoachmarksService.registry[$scope.serieId]
            }
            $scope.$on("coachmarks-state-changed", onCoachmarksStateChanged);
            onCoachmarksStateChanged();

            $scope.$watch('extraSerieIds', computeExtraStepsList);
            computeExtraStepsList();

            // currentSerieId handling
            $scope.$watch('serieId', function () {
                CoachmarksService.setCurrentSerieId($scope.serieId);
            });
            $scope.$on("$destroy", function(){
                CoachmarksService.setCurrentSerieId(null);
            });

            if (!CoachmarksService.isCoachmarkEverSeen() && $scope.serieId == 'project-home') {
                CreateModalFromTemplate("/templates/coachmarks/coachmark-first-time-popin.html", $scope, null, function(newScope) {
                    newScope.setCoachmarkEverSeen = CoachmarksService.setCoachmarkEverSeen();
                });
            }
        }
    };
});

/**
 * Directive to append to the root element of the DOM a coachmarkSerie directive.
 * This enable to call a coachmarkSerie from any template without having to consider z-index issue
 */
app.directive("coachmarkSerieCaller", function($timeout, $http, $templateCache, $compile) {
    return {
        restrict: 'A',
        scope: {
            serieId: '=',
            extraSerieIds: '=?'
        },
        link: function ($scope, element, attrs) {
            $http.get("/templates/coachmarks/coachmark-serie.html", {cache: $templateCache}).then(function(response) {
                var newDOMElt = $(response.data);
                $('body').append(newDOMElt);
                $timeout(function () {
                    var newScope = $scope.$new();
                    $compile(newDOMElt)(newScope);
                    $scope.$on("$destroy", function(){
                        newDOMElt.remove();
                    });
                }, 1000);
            });
        }
    }
});

/**
 * A set of utilitaries to use coachmarks.
 * Also contains the list of existing coachmarks.
 */
app.factory("CoachmarksService", function(LocalStorage, WT1, ActivityIndicator, Logger, $rootScope){
	var svc = {};

	svc.registry = {};

    /*
     *  Local Storage Handling
     */

    function getPersistentState(){
        var state = LocalStorage.get("dss.coachmarks.state");

        if (!state){
            state = {}
        }
        if (!state.series) {
            state.series = {}
        }
        return state;
    }

    function setPersistentState(state){
        LocalStorage.set("dss.coachmarks.state", state);
        $rootScope.$broadcast("coachmarks-state-changed");
    }

    function setSeriePersistentState(id, attr, value){
        var pState = getPersistentState();

        if (!pState.series[id]) {
            pState.series[id] = {};
        }
        pState.series[id][attr] = value;
        setPersistentState(pState);
    }

    svc.setAlreadyWatched = function(id) {
        setSeriePersistentState(id, 'watched', true);
    };

    svc.disableSerie = function(id) {
        WT1.event("coachmark-series-disabled", { seriesId : id });
        setSeriePersistentState(id, 'disabled', true);
    };

    svc.enableSerie = function(id) {
        WT1.event("coachmark-series-enabled", { seriesId : id });
        setSeriePersistentState(id, 'disabled', false);
    };

    svc.disableAllSeries = function() {
        WT1.event("coachmark-global-disable", { wasAtSeries : svc.getCurrentSerieId()});
        var msg = "All helpers disabled";
        ActivityIndicator.info(msg, 5000);
        for (var serie in svc.registry) {
            svc.disableSerie(serie);
        }
    };

    svc.enableAllSeries = function() {
        WT1.event("coachmark-global-reenable");
        ActivityIndicator.info("All helpers are now enabled");
        for (var serie in svc.registry) {
            svc.enableSerie(serie);
        }
    };

    svc.isSerieDisabled = function(id){
        var seriesState = getPersistentState().series[id];
        if (!seriesState) return false;
        return seriesState.disabled == true;
    };

    svc.canDisplaySerie = function(id){
        return !svc.isSerieDisabled(id) && !svc.isCoachmarksHardDisabled();
    }

    svc.isSerieAlreadyWatched = function(id) {
        var seriesState = getPersistentState().series[id];
        if (!seriesState) return false;
        return seriesState.watched == true;
    };

    svc.isCoachmarkEverSeen = function() {
        return getPersistentState().everSawPulsar;
    }

    svc.setCoachmarkEverSeen = function() {
        var pState = getPersistentState();
        pState.everSawPulsar = true;
        setPersistentState(pState);
    }

    svc.isCoachmarksHardDisabled = function() {
        var pState = getPersistentState();
        return pState.hardDisabled;
    }

    /*
     *  Current Serie Handling
     */

    svc.setCurrentSerieId = function(id) {
        $rootScope.coachmarks = {
            serieId: id
        }
    };

    svc.getCurrentSerieId = function(id) {
        if ($rootScope.coachmarks) {
            return $rootScope.coachmarks.serieId;
        }
        return null;
    };

    /*
     *  Positionning
     */


    function positionToRightOfElt(elt, selector, fallbackTop, fallbackLeft, options) {
         var offset = {
            top: fallbackTop,
            left: fallbackLeft
        }
        var sel = $(selector);
        if (sel.length) {
            offset = sel.offset();
            offset.left += sel.outerWidth() + 10;
            if (options.maxLeft && offset.left > options.maxLeft) {
                offset.left = options.maxLeft;
            }
        } else {
            Logger.warn("Did not find selector", selector);
        }
        if (!options.topShift) {
            offset.top += options.topShift;
        }
        elt.css("left", offset.left + "px");
        elt.css("top", offset.top + "px");
    }

    function appendPulsarToElement(pulsarEl, pulsarScope, selector) {
        var pulsarElDetached = pulsarEl.detach();
        var sel = $(selector);
        if (sel.length) {
            var element = $(sel[0]);
            element.addClass('coachmark-pulsar-wrapper');
            element.append(pulsarElDetached);

            pulsarScope.$on("$destroy", function(){
                pulsarEl.remove();
                element.removeClass('coachmark-pulsar-wrapper');
            });
        } else {
            Logger.warn("Did not find selector", selector);
        }
    }

    function positionCoachmark(coachmarkElt, left, top) {
        coachmarkElt.css("left", left + "px");
        coachmarkElt.css("top", top + "px");
        coachmarkElt.css("right", "auto");
        coachmarkElt.css("bottom", "auto");
    }

    svc.positionning = {};

    svc.positionning.coachmarkToBottomLeftOfPulsar = function(pulsarElt, coachmarkElt) {
        var offset = pulsarElt.offset();
        var left = offset.left - coachmarkElt.width();
        var top = offset.top + pulsarElt.height();
        positionCoachmark(coachmarkElt, left, top);
    };

    svc.positionning.coachmarkToBottomRightOfPulsar = function(pulsarElt, coachmarkElt) {
        var offset = pulsarElt.offset();
        var left = offset.left + pulsarElt.width();
        var top = offset.top + pulsarElt.height();
        positionCoachmark(coachmarkElt, left, top);
    };

    svc.positionning.coachmarkToTopLeftOfPulsar = function(pulsarElt, coachmarkElt) {
        var offset = pulsarElt.offset();
        var left = offset.left - coachmarkElt.width();
        var top = offset.top - coachmarkElt.height();
        positionCoachmark(coachmarkElt, left, top);
    };

    svc.positionning.coachmarkToTopRightOfPulsar = function(pulsarElt, coachmarkElt) {
        var offset = pulsarElt.offset();
        var left = offset.left + pulsarElt.width();
        var top = offset.top - coachmarkElt.height();
        positionCoachmark(coachmarkElt, left, top);
    };

    svc.positionning.smartCoachmarkPosition = function (pulsarElt, coachmarkElt) {
        var pulsarOffset = pulsarElt.offset();
        var isLeft = pulsarOffset.left < window.innerWidth/2;
        var isTop = pulsarOffset.top < window.innerHeight/2;
        if (isLeft) {
            if (isTop) {
                svc.positionning.coachmarkToBottomRightOfPulsar(pulsarElt, coachmarkElt);
            } else {
                svc.positionning.coachmarkToTopRightOfPulsar(pulsarElt, coachmarkElt);
            }
        } else {
            if (isTop) {
                svc.positionning.coachmarkToBottomLeftOfPulsar(pulsarElt, coachmarkElt);
            } else {
                svc.positionning.coachmarkToTopLeftOfPulsar(pulsarElt, coachmarkElt);
            }
        }
    };

    svc.registry["shaker-hello"] = {
        steps : [
            {
                "templateUrl" : "/templates/coachmarks/shaker-hello/intro.html",
                pulsarCallback : function(elt, scope) {
                    appendPulsarToElement(elt, scope, '.leftPane');
                    elt.css("top", "29px");
                    elt.css("left", "25px");
                },
                coachmarkSizeCallback : function(elt, scope) {
                    elt.css("width", "420px");
                }
            },
            {
                "templateUrl" : "/templates/coachmarks/shaker-hello/column-header.html",
                pulsarCallback : function(elt, scope) {
                    appendPulsarToElement(elt, scope, '.filter.global-search');
                    elt.css("left", "0px");
                    elt.css("bottom", "-11px");
                },
                coachmarkSizeCallback : function(elt, scope) {
                    elt.css("width", "500px");
                }
            },
            {
                "templateUrl" : "/templates/coachmarks/shaker-hello/cell-click.html",
                pulsarCallback : function(elt, scope) {
                    appendPulsarToElement(elt, scope, '.filter.global-search');
                    elt.css("left", "50vw");
                    elt.css("bottom", "5px");
                },
                coachmarkSizeCallback : function(elt, scope) {
                    elt.css("width", "500px");
                }
            },
            // {
            //     templateUrl : "/templates/coachmarks/shaker-hello/select-content.html",
            //     pulsarCallback : function(elt, scope) {
            //         appendPulsarToElement(elt, scope, '.leftPane');
            //         elt.css("right", "-680px");
            //         elt.css("top", "85px");
            //     },
            //     coachmarkSizeCallback : function(elt, scope) {
            //         elt.css("width", "380px");
            //     }
            // },
            {
                "templateUrl" : "/templates/coachmarks/shaker-hello/processors-library.html",
                pulsarCallback : function(elt, scope) {
                    appendPulsarToElement(elt, scope, '.leftPane');
                    elt.css("top", "20%");
                    elt.css("right", "50%");
                },
                coachmarkSizeCallback : function(elt, scope) {
                    elt.css("width", "300px");
                    // elt.css("height", "160px");
                }
            }
        ]
    };

    // svc.registry["shaker-processors"] = {
    //     steps : [
    //         {
    //             templateUrl : "/templates/coachmarks/shaker-hello/processors-library.html",
    //             pulsarCallback : function(elt, scope) {
    //                 appendPulsarToElement(elt, scope, '.leftPane');
    //                 elt.css("top", "20%");
    //                 elt.css("right", "50%");
    //             },
    //             coachmarkSizeCallback : function(elt, scope) {
    //                 elt.css("width", "390px");
    //                 // elt.css("height", "160px");
    //             }
    //         }
    //     ]
    // }

    svc.registry["shaker-eye"] = {
        steps : [
            {
                "templateUrl" : "/templates/coachmarks/shaker-eye/eye.html",
                pulsarCallback : function(elt, scope) {
                    positionToRightOfElt(elt, ".eye-switch", 150, 400, { maxLeft : 500, topShift: -30});
                },
                coachmarkSizeCallback : function(elt, scope) {
                    elt.css("width", "500px");
                }
            }
        ]
    };

    svc.registry["shaker-run"] = {
        steps : [
            {
                "templateUrl" : "/templates/coachmarks/shaker-run/run-button.html",
                pulsarCallback : function(elt, scope) {
                    appendPulsarToElement(elt, scope, '.leftPane');
                    elt.css("bottom", "36px");
                    elt.css("left", "30%");
                },
                coachmarkSizeCallback : function(elt, scope) {
                    elt.css("width", "300px");
                    // elt.css("height", "160px");
                }
            }
        ]
    };

    svc.registry["analysis-deploy"] = {
        steps : [
            {
                "templateUrl" : "/templates/coachmarks/analysis-deploy/deploy-script.html",
                pulsarCallback : function(elt, scope) {
                    elt.css("top", "71px");
                    elt.css("right", "100px");
                },
                coachmarkSizeCallback : function(elt, scope) {
                    elt.css("width", "430px");
                }
            }
        ]
    };

    svc.registry["explore-hello"] = {
        steps : [
            {
                "templateUrl" : "/templates/coachmarks/explore-hello/dataset-sample.html",
                pulsarCallback : function(elt, scope) {
                    appendPulsarToElement(elt, scope, '#configure-sample-button');
                    elt.css("right", "-20px");
                    elt.css("bottom", "-2px");
                },
                coachmarkSizeCallback : function(elt, scope) {
                    elt.css("width", "380px");

                }
            },
            {
                "templateUrl" : "/templates/coachmarks/explore-hello/column-information.html",
                pulsarCallback : function(elt, scope) {
                    appendPulsarToElement(elt, scope, '.filter.global-search');
                    elt.css("left", "0px");
                    elt.css("bottom", "-11px");
                },
                coachmarkSizeCallback : function(elt, scope) {
                    elt.css("width", "500px");
                },
                autoDisplay: false,
                noPulsar: false,
            },
            {
                "templateUrl" : "/templates/coachmarks/explore-hello/lab.html",
                pulsarCallback : function(elt, scope) {
                    appendPulsarToElement(elt, scope, '#qa_generic_actions-dropdown');
                    elt.css("right", "56px");
                    elt.css("top", "24px");
                }
            },
        ]
    };


    svc.registry["dataset-tabs"] = {
        steps : [
            {
                "templateUrl" : "/templates/coachmarks/dataset-tabs/explore.html",
                pulsarCallback : function(elt, scope) {
                    appendPulsarToElement(elt, scope, '.tab');
                    elt.css("right", "-55px");
                    elt.css("bottom", "-10px");
                },
                coachmarkSizeCallback : function(elt, scope) {
                    elt.css("width", "380px");

                }
            },
            {
                "templateUrl" : "/templates/coachmarks/dataset-tabs/charts.html",
                pulsarCallback : function(elt, scope) {
                    // elt.css("width", "380px");
                    appendPulsarToElement(elt, scope, '.tab');
                    elt.css("right", "-130px");
                    elt.css("bottom", "-10px");
                },
                coachmarkSizeCallback : function(elt, scope) {
                    elt.css("width", "380px");

                }
            },
            {
                "templateUrl" : "/templates/coachmarks/dataset-tabs/status.html",
                pulsarCallback : function(elt, scope) {
                    // elt.css("width", "380px");
                    appendPulsarToElement(elt, scope, '.tab');
                    elt.css("right", "-200px");
                    elt.css("bottom", "-10px");
                },
                coachmarkSizeCallback : function(elt, scope) {
                    elt.css("width", "380px");

                }
            }
        ]
    };


    svc.registry["charts-hello"] = {
        steps : [
            {
                "templateUrl" : "/templates/coachmarks/charts-hello/drag-drop.html",
                pulsarCallback: function(elt, scope) {
                    // elt.css("width", "800px");
                    appendPulsarToElement(elt, scope, '.chart-param-bar');
                    elt.css("left", "-10px");
                    elt.css("top", "20%");
                    // elt.css("left", "calc(50% - 400px)");
                    // elt.css("top", "100px");
                },
                coachmarkSizeCallback: function(elt, scope) {
                    elt.css("width", "500px");
                },
                autoDisplay: false,
                noPulsar: false,
            },
            {
                "templateUrl" : "/templates/coachmarks/charts-hello/chart-options.html",
                pulsarCallback: function(elt, scope) {
                    // elt.css("width", "800px");
                    appendPulsarToElement(elt, scope, '.chart-param-bar');
                    elt.css("left", "-10px");
                    elt.css("top", "60%");
                    // elt.css("left", "calc(50% - 400px)");
                    // elt.css("top", "100px");
                },
                coachmarkSizeCallback: function(elt, scope) {
                    elt.css("width", "500px");
                },
                autoDisplay: false,
                noPulsar: false,
            },
            {
                "templateUrl" : "/templates/coachmarks/charts-hello/chart-types.html",
                pulsarCallback : function(elt, scope) {
                    positionToRightOfElt(elt, ".switch-chart-type-picker", 150, 400, { maxLeft : 500, topShift: -30});
                },
                coachmarkSizeCallback: function(elt, scope) {
                    elt.css("width", "600px");
                }
            }
        ]
    };

    svc.registry["charts-datasets"] = {
        steps : [
            {
                "templateUrl" : "/templates/coachmarks/charts-datasets/publish.html",
                pulsarCallback : function(elt, scope) {
                    appendPulsarToElement(elt, scope, '.share-bar');
                    elt.css("left", "50%");
                    elt.css("bottom", "5px");
                },
                coachmarkSizeCallback: function(elt, scope) {
                    elt.css("width", "380px");
                }
            },
            {
                "templateUrl" : "/templates/coachmarks/charts-datasets/engines.html",
                pulsarCallback : function(elt, scope) {
                    appendPulsarToElement(elt, scope, '.tab-sampling-engine');
                    elt.css("right", "30%");
                    elt.css("top", "15px");
                },
                coachmarkSizeCallback: function(elt, scope) {
                    elt.css("width", "380px");
                }
            }
        ]
    };

    svc.registry["status-metrics"] = {
        steps : [
            {
                "templateUrl" : "/templates/coachmarks/status-metrics/metrics.html",
                pulsarCallback : function(elt, scope) {
                    appendPulsarToElement(elt, scope, 'button.btn[displayed-metrics-selector]');
                    elt.css("right", "-15px");
                    elt.css("bottom", "-15px");
                },
                coachmarkSizeCallback: function(elt, scope) {
                    elt.css("width", "380px");
                }
            },
            {
                "templateUrl" : "/templates/coachmarks/status-metrics/checks-tab.html",
                pulsarCallback : function(elt, scope) {
                    appendPulsarToElement(elt, scope, '.checks-tab');
                    elt.css("left", "50%");
                    // elt.css("bottom", "-10px");
                },
                coachmarkSizeCallback: function(elt, scope) {
                    elt.css("width", "380px");
                }
            }
        ]
    };

    svc.registry["status-checks"] = {
        steps : [
            {
                "templateUrl" : "/templates/coachmarks/status-checks/checks.html",
                pulsarCallback : function(elt, scope) {
                    appendPulsarToElement(elt, scope, '.controls');
                    elt.css("right", "30%");
                    elt.css("bottom", "-15px");
                },
                coachmarkSizeCallback: function(elt, scope) {
                    elt.css("width", "380px");
                }
            }
        ]
    };

    svc.registry["model-hello"] = {
        steps : [
            {
                "templateUrl" : "/templates/coachmarks/model-hello/intro.html",
                pulsarCallback : function(elt, scope) {
                    appendPulsarToElement(elt, scope, '.object-breadcrumb');
                    elt.css("left", "50px");
                    elt.css("bottom", "-10px");
                },
                coachmarkSizeCallback: function(elt, scope) {
                    elt.css("width", "380px");
                }
            }
        ]
    };

    svc.registry["model-analysis"] = {
        steps : [
            {
                "templateUrl" : "/templates/coachmarks/model-analysis/deploy.html",
                pulsarCallback : function(elt, scope) {
                    elt.css("right", "10px");
                    elt.css("top", "90px");
                },
                coachmarkSizeCallback: function(elt, scope) {
                    elt.css("width", "380px");
                }
            },
            {
                "templateUrl" : "/templates/coachmarks/model-analysis/charts.html",
                pulsarCallback : function(elt, scope) {
                    appendPulsarToElement(elt, scope, '.tab-charts');
                    elt.css("left", "50%");
                    // elt.css("bottom", "-10px");
                },
                coachmarkSizeCallback: function(elt, scope) {
                    elt.css("width", "380px");
                }
            }
        ]
    };

    svc.registry["model-savedmodel"] = {
        steps : [
            {
                "templateUrl" : "/templates/coachmarks/model-savedmodel/origin-analysis.html",
                pulsarCallback : function(elt, scope) {
                    elt.css("right", "24px");
                    elt.css("top", "65px");                },
                coachmarkSizeCallback: function(elt, scope) {
                    elt.css("width", "380px");
                }
            },
            {
                "templateUrl" : "/templates/coachmarks/model-savedmodel/publish.html",
                pulsarCallback : function(elt, scope) {
                    elt.css("right", "210px");
                    elt.css("top", "65px");
                },
                coachmarkSizeCallback: function(elt, scope) {
                    elt.css("width", "380px");
                }
            }
        ]
    };

    svc.registry["project-home"] = {
        steps: [
            {
                "templateUrl" : "/templates/coachmarks/project-home/guide.html",
                pulsarCallback: function(elt, scope) {
                        appendPulsarToElement(elt, scope, '.master-nav__home');
                        elt.css("left", "10%");
                        elt.css("bottom", "-10px");
                }
            },
            {
				"templateUrl" : "/templates/coachmarks/project-home/settings.html",
				pulsarCallback: function(elt, scope) {
						appendPulsarToElement(elt, scope, '.home-settings-link');
						elt.css("left", "50%");
				},
                coachmarkSizeCallback: function(elt, scope) {
                    elt.css("width", "400px");
                }
			}
		]
    };

    return svc;
})
})();

(function() {
'use strict';

const app = angular.module('dataiku.common.nav', ['dataiku.notebooks']);


app.service("TopNav", function($stateParams, $rootScope, Logger) {
    const svc = this;

    let currentPageTitle = "Dataiku";
    $rootScope.topNav = { item : {}, isProjectAnalystRO : true, homeSearchFilter: "" }

    function getItemKey(item) {
        const projectKey = item.projectKey || $stateParams.projectKey;
        const type = item.type || "";
        return projectKey + ':' + type + ':' + item.id;
    }

    function sameItem(item1, item2) {
        return item1 && item2 && (getItemKey(item1) == getItemKey(item2));
    }

    svc.setOverrideLeftType = function(type) {
        $rootScope.topNav.overrideLeftType = type;
    };

    svc.setPageTitle = function(title) {
        currentPageTitle = title;
        svc.refreshPageTitle();
    };

    svc.refreshPageTitle = function(){
        var pn = "";
        if ($rootScope.totalUnreadNotifications && $rootScope.totalUnreadNotifications > 0) {
            pn = "(" + $rootScope.totalUnreadNotifications + ") "
        }
        var it = "";
        if ($rootScope.appConfig && $rootScope.appConfig.isAutomation) {
            it = " (Automation)";
        }
        document.title = pn + currentPageTitle + " | Dataiku" + it;
    }

    /**
     * Valid "top" elements
     * Frontend only
     */
    svc.LOGIN = "LOGIN";
    svc.DSS_HOME = "DSS_HOME";
    svc.TOP_HOME = "HOME";
    svc.TOP_FLOW = "FLOW";
    svc.TOP_ANALYSES = "ANALYSES";
    svc.TOP_NOTEBOOKS = "NOTEBOOKS";
    svc.TOP_JOBS = "JOBS";
    svc.TOP_DASHBOARD = "DASHBOARD";
    svc.TOP_WIKI = "WIKI";
    svc.TOP_DEPLOYER = "DEPLOYER";
    svc.TOP_API_DEPLOYER = "API_DEPLOYER";
    svc.TOP_PROJECT_DEPLOYER = "PROJECT_DEPLOYER";
    svc.TOP_MORE = "MORE";

    /**
     * Valid item types
     * Shared with backend
     */
    svc.ITEM_DATASET = "DATASET";
    svc.ITEM_RECIPE = "RECIPE";
    svc.ITEM_ANALYSIS = "ANALYSIS";
    svc.ITEM_DASHBOARD = "DASHBOARD";
    svc.ITEM_WEB_APP = "WEB_APP";
    svc.ITEM_REPORT = "REPORT";
    svc.ITEM_SQL_NOTEBOOK = "SQL_NOTEBOOK";
    svc.ITEM_JUPYTER_NOTEBOOK = "JUPYTER_NOTEBOOK";
    svc.ITEM_SAVED_MODEL = "SAVED_MODEL";
    svc.ITEM_MODEL_EVALUATION_STORE = "MODEL_EVALUATION_STORE";
    svc.ITEM_MANAGED_FOLDER = "MANAGED_FOLDER";
    svc.ITEM_STREAMING_ENDPOINT = "STREAMING_ENDPOINT";
    svc.ITEM_JOB = "JOB";
    svc.ITEM_CONTINUOUS_ACTIVITY = "CONTINUOUS_ACTIVITY";
    svc.ITEM_INSIGHT = "INSIGHT";
    svc.ITEM_LAMBDA_SERVICE = "LAMBDA_SERVICE";
    svc.ITEM_SCENARIO = "SCENARIO";
    svc.ITEM_MONITORING = "MONITORING";
    svc.ITEM_PROJECT = "PROJECT";
    svc.ITEM_ARTICLE = "ARTICLE";

    /**
     * Valid tabs-type
     * Frontend only
     */
    svc.TABS_NONE = "NONE";
    svc.TABS_ANALYSIS = "ANALYSIS";
    svc.TABS_DATASET = "DATASET";
    svc.TABS_STREAMING_ENDPOINT = "STREAMING_ENDPOINT";
    svc.TABS_NEW_DATASET = "NEW-DATASET";
    svc.TABS_SAVED_MODEL = "SAVED_MODEL";
    svc.TABS_SAVED_MODEL_VERSION = "SAVED_MODEL-VERSION";
    svc.TABS_MODEL_EVALUATION_STORE = "MODEL_EVALUATION_STORE";
    svc.TABS_RECIPE = "RECIPE";
    svc.TABS_SQL_NOTEBOOK = "SQL_NOTEBOOK";
    svc.TABS_JUPYTER_NOTEBOOK = "JUPYTER_NOTEBOOK";
    svc.TABS_DASHBOARD = "DASHBOARD";
    svc.TABS_INSIGHT = "INSIGHT";
    svc.TABS_JOB = "JOB";
    svc.TABS_CONTINUOUS_ACTIVITY = "CONTINUOUS_ACTIVITY";
    svc.TABS_MANAGED_FOLDER = "MANAGED_FOLDER";
    svc.TABS_LAMBDA = "LAMBDA";
    svc.TABS_SCENARIO = "SCENARIO";
    svc.TABS_MONITORING = "MONITORING";
    svc.TABS_RUNNABLE = "RUNNABLE";


    svc.refreshPageTitle = function() {
        let pn = "";
        if ($rootScope.totalUnreadNotifications && $rootScope.totalUnreadNotifications > 0) {
            pn = "(" + $rootScope.totalUnreadNotifications + ") "
        }
        let it = "";
        if ($rootScope.appConfig && $rootScope.appConfig.isAutomation) {
            it = " (Automation)";
        }
        document.title = pn + currentPageTitle + " | Dataiku" + it;
    };

    /**
     * top = which universe is highlighted in the global nav (+color for item icon)
     * left = which "sub-universe" is active (e.g. Project Home > Settings)
     * tabsType = which tabs to show on the right on secondary nav
     * tab = which tab is active on the right on secondary nav
     */
    svc.setLocation = function setLocation(top, left, tabsType, tab) {
        $rootScope.topNav.top = top;
    	$rootScope.topNav.left = left;
    	$rootScope.topNav.tabsType = tabsType;
    	$rootScope.topNav.tab = tab;

    	$rootScope.topNav.isTall = (top == 'DSS_HOME' && !left);

    	Logger.debug("Set location to ", $rootScope.topNav);
    };

    svc.setProjectData = function(projectSummary, projectCurrentBranch) {
    	$rootScope.topNav.project = projectSummary;
    	$rootScope.topNav.projectCurrentBranch = (projectCurrentBranch && projectCurrentBranch !== "master") ? projectCurrentBranch : "";
    };

    svc.setItem = function(type, id, data) {
        Logger.debug("Set item", type, id, data);
        const oldItem = $rootScope.topNav.item;
    	const newItem = {
            type: type,
            id: id,
            data: data
        }
        const same = svc.sameItem(oldItem, newItem);
        $rootScope.topNav.item = newItem;
        // If we change item and don't have data yet, show "Loading..." state
        if (type && !same && !data) {
            $rootScope.topNav.item.data = {name: "Loading ...", loading: true };
        }
    };

    svc.getItem = function() {
        return $rootScope.topNav.item;
    };

    svc.setNoItem = function() {
        svc.setItem(null, null, null);
    };

    // Only changes the tab, nothing elses
    svc.setTab = function(tab) {
        $rootScope.topNav.tab = tab;
    };

    svc.sameItem = function(item1, item2) {
        return item1 && item2 && (getItemKey(item1) == getItemKey(item2));
    };

    svc.isShowHomePageNavSearch = function() {
        return ('showSearchInNav' in $stateParams) && !('filterBy' in $stateParams);
    }

    svc.sameItem = sameItem;
});


app.factory("StateUtils", function($state, $stateParams, $filter, $rootScope, objectTypeFromNodeFlowType, SmartId, ActiveProjectKey) {
    function makeStateService(handlingFunction) {
        const that = {
            project: function(projectKey, options = {}) {
                return handlingFunction('projects.project.home.regular', {
                    projectKey: projectKey,
                    discussionId: options.discussionId
                });
            },
            pinboard: function(projectKey) {
                return handlingFunction('projects.project.pinboard', {
                    projectKey: projectKey
                });
            },
            dataset: function(datasetName, contextProject, options = {}) {
                contextProject = contextProject || ActiveProjectKey.get();
                const ref = SmartId.resolve(datasetName, contextProject);
                const tab = options.tab || 'explore';

                if (contextProject && ref.projectKey != contextProject && !options.moveToTargetProject) {
                    return handlingFunction('projects.project.foreigndatasets.dataset.' + tab, {
                        datasetFullName: datasetName,
                        projectKey: contextProject,
                        discussionId: options.discussionId
                    });
                } else {
                    return handlingFunction('projects.project.datasets.dataset.' + tab, {
                        projectKey: ref.projectKey,
                        datasetName: ref.id,
                        discussionId: options.discussionId
                    });
                }
            },
            //reprecated, use dataset
            datasetChart: function(chartIdx, datasetSmartName, projectKey) {
                const parts = datasetSmartName.split('.');
                if (parts.length == 2) {
                    if (parts[0] != projectKey) {
                        return handlingFunction('projects.project.foreigndatasets.dataset.visualize', {
                            chartIdx: chartIdx,
                            datasetFullName: datasetSmartName,
                            projectKey: projectKey || ActiveProjectKey.get()
                        });
                    } else {
                        datasetSmartName = parts[1];
                    }
                }

                return handlingFunction('projects.project.datasets.dataset.visualize', {
                    chartIdx: chartIdx,
                    datasetName: datasetSmartName,
                    projectKey: projectKey || ActiveProjectKey.get()
                });
            },
            managedFolder: function(id, projectKey, contextProject, options = {}) {
                //Note that foreign dataset view is not implemented
                contextProject = contextProject || ActiveProjectKey.get();
                const ref = SmartId.resolve(id, projectKey);
                const tab = options.tab || 'view'

                if (contextProject && ref.projectKey != contextProject && !options.moveToTargetProject) {
                    return handlingFunction('projects.project.foreignmanagedfolders.managedfolder.' + tab, {
                        projectKey: contextProject,
                        sourceProjectKey: ref.projectKey,
                        odbId: ref.id,
                        discussionId: options.discussionId
                    });
                } else {
                    return handlingFunction('projects.project.managedfolders.managedfolder.' + tab, {
                        projectKey: ref.projectKey,
                        odbId: ref.id,
                        discussionId: options.discussionId
                    });
                }
            },
            streamingEndpoint: function(id, projectKey, contextProject, options = {}) {
                //Note that foreign streaming endpoint view is not implemented
                contextProject = contextProject || ActiveProjectKey.get();
                const ref = SmartId.resolve(id, projectKey);
                const tab = options.tab || 'settings' // TODO:

                if (contextProject && ref.projectKey != contextProject && !options.moveToTargetProject) {
                    return handlingFunction('projects.project.foreignstreaming-endpoints.streaming-endpoint.' + tab, {
                        projectKey: contextProject,
                        sourceProjectKey: ref.projectKey,
                        streamingEndpointId: ref.id,
                        discussionId: options.discussionId
                    });
                } else {
                    return handlingFunction('projects.project.streaming-endpoints.streaming-endpoint.' + tab, {
                        projectKey: ref.projectKey,
                        streamingEndpointId: ref.id,
                        discussionId: options.discussionId
                    });
                }
            },
            savedModel: function(id, projectKey, options = {}) {
                //Note that foreign saved model view is not implemented
                const ref = SmartId.resolve(id, projectKey);
                const tab = options.tab || 'versions';
                return handlingFunction('projects.project.savedmodels.savedmodel.' + tab, {
                    projectKey: ref.projectKey,
                    smId: ref.id,
                    discussionId: options.discussionId
                });
            },
            //deprecated use savedModel
            savedModelVersion: function(savedModelType, smId, fullModelId, projectKey) {
                return handlingFunction('projects.project.savedmodels.savedmodel.' +  savedModelType.toLowerCase() + '.report', {
                    smId: smId,
                    fullModelId: fullModelId,
                    projectKey: projectKey || ActiveProjectKey.get()
                });
            },
            modelEvaluationStore: function(id, projectKey, options = {}) {
                //Note that foreign model evaluation store view is not implemented
                const ref = SmartId.resolve(id, projectKey);
                return handlingFunction('projects.project.modelevaluationstores.modelevaluationstore.evaluations', {
                    projectKey: ref.projectKey,
                    mesId: ref.id,
                    discussionId: options.discussionId
                });
            },
            modelEvaluation: function(mesId, runId, projectKey) {
                //Note that foreign model evaluation store view is not implemented
                const ref = SmartId.resolve(mesId, projectKey);
                return handlingFunction('projects.project.modelevaluationstores.modelevaluationstore.evaluation.report', {
                    projectKey: ref.projectKey,
                    mesId: ref.id,
                    runId: runId
                });
            },
            recipe: function(recipeName, projectKey, options = {}) {
                const ref = SmartId.resolve(recipeName, projectKey);
                return handlingFunction('projects.project.recipes.recipe', {
                    projectKey: ref.projectKey,
                    recipeName: ref.id,
                    discussionId: options.discussionId
                });
            },
            analysis: function(id, projectKey, options = {}) {
                const ref = SmartId.resolve(id, projectKey);
                const tab = options.tab || 'script';
                return handlingFunction('projects.project.analyses.analysis.' + tab, {
                    projectKey: ref.projectKey,
                    analysisId: ref.id,
                    discussionId: options.discussionId
                });
            },
            //deprecated use analysis
            analysisChart: function(chartIdx, analysisId, projectKey) {
                return handlingFunction('projects.project.analyses.analysis.charts', {
                    chartIdx: chartIdx,
                    analysisId: analysisId,
                    projectKey: projectKey || ActiveProjectKey.get()
                });
            },
            //deprecated use analysis
            mlTask: function(mlTaskType, projectKey, analysisId, mlTaskId) {
                return handlingFunction(
                    'projects.project.analyses.analysis.ml.' + (mlTaskType == 'PREDICTION' ? 'predmltask' : 'clustmltask')+'.list.results',
                    {
                        projectKey: projectKey || ActiveProjectKey.get(),
                        analysisId: analysisId,
                        mlTaskId: mlTaskId
                    }
                );
            },
            sqlNotebook: function(id, projectKey, options = {}) {
                const ref = SmartId.resolve(id, projectKey);
                return handlingFunction('projects.project.notebooks.sql_notebook', {
                    projectKey: ref.projectKey,
                    notebookId: ref.id,
                    discussionId: options.discussionId
                });
            },
            jupyterNotebook: function(id, projectKey, options = {}) {
                const ref = SmartId.resolve(id, projectKey);
                return handlingFunction('projects.project.notebooks.jupyter_notebook', {
                    projectKey: ref.projectKey,
                    notebookId: ref.id,
                    discussionId: options.discussionId
                });
            },
            notebook: function(notebookType, notebookId, projectKey, options = {}) {
                if (notebookType.toUpperCase().includes('SQL')) {
                    return that.sqlNotebook(notebookId, projectKey, options);
                }
                return that.jupyterNotebook(notebookId, projectKey, options);
            },
            webapp: function(webAppId, projectKey, options = {}) {
                const ref = SmartId.resolve(webAppId, projectKey);
                const tab = options.tab || 'view';
                return handlingFunction("projects.project.webapps.webapp." + tab, {
                    projectKey: ref.projectKey || ActiveProjectKey.get(),
                    webAppId: ref.id,
                    webAppName: options.name,
                    discussionId: options.discussionId
                });
            },
            report: function(reportId, projectKey, options = {}) {
                const ref = SmartId.resolve(reportId, projectKey);
                const tab = options.tab || 'view';
                return handlingFunction("projects.project.reports.report." + tab, {
                    projectKey: ref.projectKey || ActiveProjectKey.get(),
                    reportId: ref.id,
                    reportName: options.name,
                    discussionId: options.discussionId
                });
            },
            scenario: function(scenarioId, projectKey, options = {}) {
                const ref = SmartId.resolve(scenarioId, projectKey);
                const tab = options.tab || 'runs.list';
                return handlingFunction("projects.project.scenarios.scenario." + tab, {
                    projectKey: ref.projectKey || ActiveProjectKey.get(),
                    scenarioId: ref.id,
                    discussionId: options.discussionId
                });
            },

            dashboard: function(id, projectKey, options = {}) {
                const ref = SmartId.resolve(id, projectKey);
                const tab = options.tab || 'view';
                return handlingFunction('projects.project.dashboards.dashboard.' + tab, {
                    projectKey: ref.projectKey,
                    dashboardId: ref.id,
                    dashboardName: options.name ? $filter('slugify')(options.name) : '',
                    pageId: options.pageId ? options.pageId : '',
                    fullScreen: options.fullScreen,
                    separator: '_',
                    discussionId: options.discussionId
                });
            },
            insight: function(id, projectKey, options = {}) {
                const ref = SmartId.resolve(id, projectKey);
                const tab = options.tab || 'view';
                return handlingFunction('projects.project.dashboards.insights.insight.' + tab, {
                    projectKey: ref.projectKey,
                    insightId: ref.id,
                    insightName: options.name ? $filter('slugify')(options.name) : '',
                    fullScreen: options.fullScreen,
                    discussionId: options.discussionId
                });
            },
            lambdaService: function(id, projectKey, options = {}) {
                const ref = SmartId.resolve(id, projectKey);
                const tab = options.tab || 'endpoints';
                return handlingFunction('projects.project.lambdaservices.service.' + tab, {
                    projectKey: ref.projectKey,
                    serviceId: ref.id,
                    discussionId: options.discussionId
                });
            },
            article: function(articleId, projectKey, options = {}) {
                const ref = SmartId.resolve(articleId, projectKey);
                const tab = options.tab || 'view';
                return handlingFunction("projects.project.wiki.article." + tab, {
                    projectKey: ref.projectKey || ActiveProjectKey.get(),
                    articleId: ref.id,
                    articleName: options.articleName,
                    discussionId: options.discussionId,
                    '#': ''
                });
            },
            cluster: function(clusterId, options = {}) {
                return handlingFunction('admin.clusters.cluster', {
                    clusterId: clusterId,
                    discussionId: options.discussionId
                });
            },
            statisticsWorksheet: function(worksheetId, contextProject) {
                const ref = SmartId.resolve(worksheetId, contextProject);
                return handlingFunction('projects.project.statisticsWorksheet', {
                    projectKey: ref.projectKey,
                    worksheetId: ref.id
                });
            },
            flowZone: function(id, contextProject, name, options = {}) {
                contextProject = contextProject || ActiveProjectKey.get();
                const ref = SmartId.resolve(id, contextProject);

                return handlingFunction('projects.project.flow', {
                    projectKey: ref.projectKey,
                    zoneId: ref.id,
                });
            },
            continuousActivity: function(id, contextProject, options = {}) {
                contextProject = contextProject || ActiveProjectKey.get();
                const ref = SmartId.resolve(id, contextProject);

                return handlingFunction('projects.project.continuous-activities.continuous-activity.runs', {
                    projectKey: ref.projectKey,
                    continuousActivityId: ref.id,
                });
            },
            /* for all taggable types */
            dssObject: function(type, id, projectKey, options = {}) { //if moveToTargetProject is falsish, explore as foreign object
                projectKey = projectKey || ActiveProjectKey.get();
                switch (type) {
                    case 'DATASET':
                        return that.dataset(id, projectKey, options);
                    case 'SAVED_MODEL':
                        return that.savedModel(id, projectKey, options);
                    case 'MODEL_EVALUATION_STORE':
                        return that.modelEvaluationStore(id, projectKey, options);
                    case 'MANAGED_FOLDER':
                        return that.managedFolder(id, projectKey, null, options);
                    case 'STREAMING_ENDPOINT':
                        return that.streamingEndpoint(id, projectKey, null, options);
                    case 'RECIPE':
                        return that.recipe(id, projectKey, options);
                    case 'ANALYSIS':
                        return that.analysis(id, projectKey, options);
                    case 'STATISTICS_WORKSHEET':
                        return that.statisticsWorksheet(id, projectKey, options);
                    case 'SQL_NOTEBOOK':
                        return that.sqlNotebook(id, projectKey, options);
                    case 'JUPYTER_NOTEBOOK':
                        return that.jupyterNotebook(id, projectKey, options);
                    case 'INSIGHT':
                        return that.insight(id, projectKey, options);
                    case 'WEB_APP':
                        return that.webapp(id, projectKey, options);
                    case 'REPORT':
                        return that.report(id, projectKey, options);
                    case 'ARTICLE':
                        return that.article(id, projectKey, options);
                    case 'SCENARIO':
                        return that.scenario(id, projectKey, options);
                    case 'DASHBOARD':
                        return that.dashboard(id, projectKey, options);
                    case 'PROJECT':
                        return that.project(id || projectKey, options);
                    case 'LAMBDA_SERVICE':
                        return that.lambdaService(id, projectKey, options);
                    case 'CLUSTER':
                        return that.cluster(id, options);
                    case 'JOB':
                        return that.job(projectKey, id);
                    case 'FLOW_ZONE':
                        return that.flowZone(id, projectKey, options);
                    case 'CONTINUOUS_ACTIVITY':
                        return that.continuousActivity(id, projectKey, options);
                }
                throw new Error("Unknown object type: '" + type + "' for " + projectKey + '.' + id);
            },
            taggableObject: function(tor, options = {}) { //if moveToTargetProject is falsish, explore as foreign object
                return that.dssObject(tor.type, tor.id, tor.projectKey, options);
            },
            table: function(projectKey, options = {}) {
                return handlingFunction('external-table', {
                    projectKey: projectKey,
                    discussionId: options.discussionId
                });
            },
            node: function(flowNode) {
                if (!flowNode) return;
                switch (flowNode.nodeType) {
                    case 'LOCAL_DATASET':
                        return that.dataset(flowNode.name, flowNode.projectKey);
                    case 'FOREIGN_DATASET':
                        return that.dataset(flowNode.projectKey + '.' + flowNode.name, ActiveProjectKey.get());
                    case 'LOCAL_SAVEDMODEL':
                        return that.savedModel(flowNode.name, flowNode.projectKey);
                    case 'FOREIGN_SAVEDMODEL':
                        return that.savedModel(flowNode.name, flowNode.projectKey);
                    case 'LOCAL_MODELEVALUATIONSTORE':
                        return that.modelEvaluationStore(flowNode.name, flowNode.projectKey);
                    case 'FOREIGN_MODELEVALUATIONSTORE':
                        return that.modelEvaluationStore(flowNode.name, flowNode.projectKey);
                    case 'LOCAL_MANAGED_FOLDER':
                        return that.managedFolder(flowNode.name, flowNode.projectKey);
                    case 'FOREIGN_MANAGED_FOLDER':
                        return that.managedFolder(flowNode.name, flowNode.projectKey);
                    case "LOCAL_STREAMING_ENDPOINT":
                        return that.streamingEndpoint(flowNode.name, flowNode.projectKey);
                    case "FOREIGN_STREAMING_ENDPOINT":
                        return that.streamingEndpoint(flowNode.name, flowNode.projectKey);
                    case 'RECIPE':
                        return that.recipe(flowNode.name, flowNode.projectKey);
                }
            },
            // contextProjectKey is the project the foreign dataset currently is in
            flowLink: function(flowNode, contextProjectKey) {
                const type = objectTypeFromNodeFlowType(flowNode.nodeType).toLowerCase();
                return handlingFunction('projects.project.flow', {
                    id: type + '_' + (type == 'recipe' ? '' : (flowNode.projectKey + '.')) + flowNode.name,
                    projectKey: contextProjectKey || flowNode.projectKey
                });
            },
            job: function(projectKey, jobId) {
                return handlingFunction("projects.project.jobs.job", {
                    projectKey : projectKey || ActiveProjectKey.get(),
                    jobId : jobId
                });
            },
            home: function() {
                return handlingFunction("home", {});
            },
            projectFolder: function(folderId) {
                return handlingFunction("project-list", {
                    folderId: folderId
                });
            },
            pluginDefinition: function(pluginId) {
                return handlingFunction('plugindev.definition', {
                    pluginId: pluginId
                });
            },
            pluginEditor: function(pluginId, path) {
                return handlingFunction('plugindev.editor', {
                    pluginId: pluginId,
                    filePath: path
                });
            }
        };
        return that;
    }

    function getDefaultTab(alternate) {
        const scd = $state.current.data;
        return scd && scd.tab ? scd.tab : alternate;
    }

    return {
        href: makeStateService($state.href.bind($state)),
        go: makeStateService($state.go.bind($state)),
        defaultTab: getDefaultTab
    };
});


app.directive("stdObjectBreadcrumb", function($rootScope, $state, Navigator, DatasetCustomFieldsService) {
    return {
        templateUrl: '/templates/widgets/std-object-breadcrumb.html',
        scope: {
            jobDef: "=jobDef",
            jobStatus: "=jobStatus"
        },
        link: function(scope) {
            scope.topNav = $rootScope.topNav;
            scope.$state = $state;
            scope.Navigator = Navigator;
            scope.DatasetCustomFieldsService = DatasetCustomFieldsService;
        }
    };
});


app.directive("itemHeader", function() {
    return {
        scope: {
            item: '=',
            href: '=',
            color: '@',
            icon: '@',
            title: '@',
            class: '@',
            flowLink: '=?',
            exposeObjectFn: '=?',
            exposeLabel: '=?',
            exposeDisabled: '=?',
            navigatorFn: '=?',
            editable: '=?',
            edit: '&?',
            deletable: '=?',
            delete: '&?',
        },
        transclude: true,
        template:
            `<div class="{{class}} item-header horizontal-flex">
                <div class="noflex object-icon universe-background {{color}}">
                    <div class="middle"><i class="icon {{icon}}"></i></div>
                </div>
                <h2 class="flex" title="{{title}}">
                    <a href="{{href}}" ng-if="href"><ng-transclude></ng-transclude></a>
                   <span ng-if="!href"><ng-transclude></ng-transclude></span>
                </h2>
                <div class="btn-items">
                    <button disabled-if='exposeDisabled' disabled-message="{{exposeLabel}}" ng-if="exposeObjectFn" ng-click="exposeObjectFn()" class="btn btn--secondary" alt="{{exposeLabel}}" title="{{exposeLabel}}" toggle="tooltip"><i class='icon-dku-share'></i> EXPOSE</button>
                    <a ng-if="navigatorFn" ng-click="navigatorFn()" class="btn btn--secondary btn--icon" alt="Navigate around" title="Navigate around">
                        <i class="icon-compass"></i>
                    </a>
                    <a ng-if="flowLink" class="btn btn--secondary btn--icon" href="{{flowLink}}" alt="See in flow" title="See in flow">
                        <i class="icon-dku-nav_flow"></i>
                    </a>
                    <a ng-if="editable" ng-click="edit()" class="btn btn--secondary btn--icon" alt="Edit">
                        <i class="icon-pencil"></i>
                    </a>
                    <a ng-if="deletable" ng-click="delete()" class="btn btn--secondary btn--icon" alt="Delete">
                        <i class="icon-trash"></i>
                    </a>
                </div>
            </div>`,
        link: function(scope, element, attrs, ctrl, transclude) {
          //NOSONAR ng1.6 doesnt work; doesnt appear necessary probably due to https://github.com/angular/angular.js/commit/32aa7e7395527624119e3917c54ee43b4d219301 //element.find('ng-transclude').replaceWith(transclude());
        }
    };
});


app.directive("simpleRightColActionHref", function($rootScope) {
    return {
        scope: {
            href: '@',
            label: '@',
            icon: '@',
            title: '@',
            target: '@'
        },
        replace: true,
        template:   `<div class="action-icon" full-click>
                        <a href="{{href}}" target="{{target}}" main-click><i class="{{icon}}"></i></a>
                        <label>{{label}}</label>
                    </div>`
    };
});


app.directive("simpleRightColActionClick", function($rootScope) {
    return {
        scope: {
            onClick : '&',
            label : '@',
            icon : '@',
            title : '@',
            isclickable : '<'
        },
        replace: true,
        template:   `<div class="action-icon" full-click>
                        <a ng-click="localClick()" main-click><i class="{{icon}}"></i></a>
                        <label>{{label}}</label>
                    </div>`,
        link: function(scope) {
            scope.localClick = function() {
                scope.onClick();
            }
        }
    };
});

app.directive("clickNext", function($timeout, $stateParams, $state, Dialogs) {
    return {
        scope: false,
        restrict: 'A',
        link: function(scope, element, attrs) {
            const $e = $(element);
            $e.on('click', function(evt) {
                $e.next().trigger(evt);
            });
        }
    };
});

app.directive("tabModel", function($timeout, $stateParams, $state, Dialogs) {
    return {
        scope: false,
        restrict: 'A',
        link: function(scope, element, attrs) {
            const $e = $(element),
                expr = attrs.tabModel + ' = $tab',
                klass = attrs.tabActiveClass || 'active',
                notify = attrs.tabModelNotify === "true" ? true : false,
                disableTransition = attrs.disableTransition === "true" ? true : false;

            function transition(evt, e) {
                const tab = e.getAttribute('tab-set');
                if (disableTransition) {
                    scope.$eval.bind(scope, expr, {$tab: tab})();
                } else {
                    $state.go('.', {selectedTab: tab}, {location: true, inherit: true, relative: $state.$current, notify: notify }).then(function() {
                        scope.$eval.bind(scope, expr, {$tab: tab})();
                    });
                }
            }

            $e.on('click', '[tab-set]', function(evt) {
                const that = this;
                if(scope.hooks && scope.hooks.dirty && scope.hooks.dirty()) {
                    Dialogs.confirm(scope, 'Unsaved changes', "You have unsaved changes. Are you sure you want to leave this page ?")
                        .then( _ => transition(evt, that) );
                } else {
                    scope.$apply( _ => transition(evt, that) );
                }
            });

            scope.$watch(attrs.tabModel, function(val) {
                $timeout(function() {
                    $e.find('[tab-active]').each(function() {
                        this.classList[this.getAttribute('tab-active') === val ? 'add' : 'remove'](klass);
                    });
                }, 0);
            });
        }
    };
});


app.service("QuickView", function(CreateCustomElementFromTemplate, $rootScope, $timeout) {
    const svc = this;

    let elScope, removeListener;

    this.show = function(projectKey, objectType, objectId) {
        if (projectKey === false) return;

        if (!elScope) {
            CreateCustomElementFromTemplate("/templates/object-details/quick-view.html", $rootScope, null, function(newScope) {
                elScope = newScope;
                elScope.hasObject = false;
                elScope.objectType = objectType;
                elScope.objectId = objectId;
                elScope.projectKey = projectKey;
                $timeout(function() { $('.object-quick-view-wrapper').addClass('visible'); });
            });
        } else {
            elScope.hasObject = false;
            elScope.objectType = objectType;
            elScope.objectId = objectId;
            elScope.projectKey = projectKey;
        }

        $('.object-quick-view-wrapper').removeClass('loading');
        removeListener = $rootScope.$on("$stateChangeStart", svc.hide);
    };

    this.showObject = function(object, objectType) {
        if (object === false) return;

        const objectData = {};
        objectData[objectType.toLowerCase()] = object;

        if (!elScope) {
            CreateCustomElementFromTemplate("/templates/object-details/quick-view.html", $rootScope, null, function(newScope) {
                elScope = newScope;
                elScope.hasObject = true;
                elScope.objectType = objectType;
                elScope.objectData = objectData;
                $timeout(function() { $('.object-quick-view-wrapper').addClass('visible'); });
            });
        } else {
            elScope.hasObject = true;
            elScope.objectType = objectType;
            elScope.objectData = objectData;
        }

        $('.object-quick-view-wrapper').removeClass('loading');
        removeListener = $rootScope.$on("$stateChangeStart", svc.hide);
    };

    this.hide = function() {
        if (elScope && elScope.dismiss) {
            elScope.dismiss();
            elScope = null;
        }

        if (removeListener) removeListener();
    };

    this.setLoading = function() {
        $('.object-quick-view-wrapper').addClass('loading');
    };
});

app.directive("objectDetails", function ($rootScope, $q, $stateParams, DataikuAPI, ActivityIndicator, RecipesUtils, QuickView, NotebooksUtils, StateUtils, LoggerProvider, CreateModalFromTemplate, TaggingService, TAGGABLE_TYPES, ActiveProjectKey, _SummaryHelper) {
    const logger = LoggerProvider.getLogger('objectDetails');

    return {
        restrict: 'E',
        template: '<div ng-if="objectType" ng-include="getTemplateFile()" />',
        scope: {
            projectKey: '=',
            objectType: '@',
            objectId: '=',
            data: '=?objectData',
            context: '@',
            hoverIntentCallback: '=?',
            editable: '=?',
            editCustomFields: '='
        },
        link: function($scope, element, attrs) {
            _SummaryHelper.addEditBehaviour($scope, element);

            $scope.uiState = {
                isHoverEdit: false
            };
            $scope.appConfig = $rootScope.appConfig;

            $scope.resolveObjectSmartId = resolveObjectSmartId;

            $scope.QuickView = QuickView;
            $scope.StateUtils = StateUtils;

            $scope.canWriteProject = () => $scope.editable;

            $scope.saveCustomFields = function (customFields) {
                $scope.$emit('customFieldsSummaryEdited', customFields);
            };

            $scope.inNavigator = function() {
                return $scope.context != 'right-column';
            };

            $scope.setHoverEdit = function (on)  {
                $scope.uiState.isHoverEdit = on;
            };

            $scope.inRightColumn = function() {
                return $scope.context == 'right-column';
            };

            $scope.inQuickView = function() {
                return $scope.context && $scope.context.toLowerCase() === 'quick-view'
            };

            if (!$scope.context) $scope.context = '';
            if ($scope.inQuickView()) {
                $scope.maxListItems = 5;
            }

            $scope.getTemplateFile = function() {
                return '/templates/object-details/' + $scope.objectType.toLowerCase() + '.html';
            };

            $scope.getTaggableObject = function() {
                return {
                    type: $scope.objectType.toUpperCase(),
                    projectKey: $scope.object.projectKey,
                    id: $scope.object.id || $scope.object.name,
                    displayName: $scope.object.displayName || $scope.object.name
                }
            };

            $rootScope.$on('toggleActiveRightCol', function(){
                $scope.object.active = !$scope.object.active;
            });

            $scope.toggleActive = function(scenario) {
                var message = scenario.active ? 'Activate ' : 'Deactivate ';
                $rootScope.$emit('toggleActiveList');
                message = message + 'auto-triggers of ' + scenario.projectKey + '.' + (scenario.name || scenario.id);
                DataikuAPI.scenarios.saveNoParams(scenario.projectKey, scenario, {commitMessage:message}).success(function(data){
                    // save the expanded states
                    ActivityIndicator.success("Saved");
                }).error(setErrorInScope.bind($scope));
            };

            $scope.isMetaDataEditable = function () {
                return !$scope.inNavigator() && $stateParams.projectKey;
            };

            $scope.isMetaDataSupported = function(){
                return TAGGABLE_TYPES.includes($scope.objectType.toUpperCase());
            }

            $scope.getAllTagsForProject = function () {
                const deferred = $q.defer();
                deferred.resolve(TaggingService.getProjectTags());
                return getRewrappedPromise(deferred);
            }

            $scope.setUpdatedMetaData = function(update) {
                const o = $scope.object;
                o.tags = update.tags;
                o.shortDesc = update.shortDesc;
                o.description = update.description;
            };

            $scope.$watch("data", function(nv) {
                if (!nv) return;
                enrichData();
                if($scope.object) {
                    $scope.object.isFlowObj = isShownInFlow($scope.objectType.toUpperCase())
                }
            });

            $scope.showEditMetadataModal = function () {
                if (!$scope.editable) {
                    return;
                }
                // _SummaryHelper add edit behavior and create a shortDesc obj
                // but we can erase safely the things related to the description
                $scope.state.shortDesc = '';
                $scope.state.description = '';
		$scope.state.customFields = {};

                CreateModalFromTemplate("/templates/widgets/edit-metadata-modal.html", $scope, null, function(modalScope) {

                    modalScope.cancel = function() {modalScope.dismiss();};

                    if (!modalScope.object) {
                        return;
                    }

                    modalScope.state.tags = {
                        newVal : undefined,
                        savedVal :angular.copy(modalScope.object.tags),
                        editing: false
                    };
                    modalScope.state.shortDesc = angular.copy(modalScope.object.shortDesc);
                    modalScope.state.description = angular.copy(modalScope.object.description);
		            modalScope.state.customFields = angular.copy(modalScope.object.customFields);

                    modalScope.startEditTags  = function() {
                        modalScope.state.tags.newVal = angular.copy(modalScope.state.tags.savedVal);
                        modalScope.state.tags.editing = true;
                    }
                    modalScope.cancelEditTags  = function() {
                        modalScope.state.tags.newVal = null;
                        modalScope.state.tags.editing = false;
                    }
                    modalScope.validateEditTags  = function() {
                        if (modalScope.state.tags.editing) {
                            modalScope.state.tags.savedVal = modalScope.state.tags.newVal;
                            modalScope.state.tags.editing = false;
                        }
                    }

                    modalScope.getAllTagsForProject = function () {
                        const deferred = $q.defer();
                        deferred.resolve(TaggingService.getProjectTags());
                        return getRewrappedPromise(deferred);
                    }
                    modalScope.save = function() {
                        const ui = modalScope.state;

                        if (modalScope.state.tags.editing) {
                            modalScope.validateEditTags();
                        }

                        const request = {
                            shortDesc: ui.shortDesc,
                            description: ui.description,
			    customFields: ui.customFields,
                            tags: ui.tags.newVal ? ui.tags.newVal : ui.tags.savedVal
                        };
                        DataikuAPI.taggableObjects.setMetaData($scope.getTaggableObject(), request)
                        .success(function() {
                            $scope.setUpdatedMetaData(request);
                            $rootScope.$broadcast('objectMetaDataChanged', request);
                            modalScope.resolveModal();
                        })
                        .error(setErrorInScope.bind($scope));
                    };

                },true);
                }

            $scope.isDescMoreLinkSupported = function () {
                return ($scope.objectType != "JUPYTER_NOTEBOOK");
            }

            $scope.showDescMoreLink = function () {
                if (!$scope.isDescMoreLinkSupported()) return false;
                if (!$scope.elDescWrapDiv || $scope.elDescWrapDiv.height()==0) {
                    $scope.elDescWrapDiv = $(element).find('.description-wrapper');
                    $scope.elDescFullDiv = $scope.elDescWrapDiv.children().first();
                }
                const showMore = ($scope.elDescWrapDiv.height() < $scope.elDescFullDiv.height());
                if (showMore) {
                    $scope.elDescWrapDiv.removeClass('full');
                } else if (!$scope.elDescWrapDiv.hasClass('full')) {
                    $scope.elDescWrapDiv.addClass('full');
                }
                return showMore;
            };

            $scope.expandDescription = () => {
                $scope.object.$descriptionExpanded = true;
            };

            $scope.objectSummaryLink = function() {
                const to = $scope.getTaggableObject();
                return $scope.StateUtils.href.taggableObject(to, {tab: 'summary'});
            };

            $scope.$watchCollection('[objectType, projectKey, objectId]', function(nv, ov) {
                if (!nv[0]) return;
                if (!attrs.hasOwnProperty('objectData') && (!nv[1] || !nv[2])) return;

                if (!attrs.hasOwnProperty('objectData')) {
                    switch ($scope.objectType.toUpperCase()) {
                    case 'CONNECTION':
                        return;

                    case 'DATASET_CONTENT':
                        let projectKey = $scope.projectKey,
                            name = $scope.objectId;
                        const parts = $scope.objectId.split('.');
                        if (parts.length == 2) {
                            projectKey = parts[0];
                            name = parts[1];
                        }
                        DataikuAPI.datasets.get(projectKey, name, ActiveProjectKey.get()).noSpinner()
                            .success(function(data) {
                                $scope.data = {dataset_content: data}
                            })
                            .error(setErrorInScope.bind($scope));
                        return;

                    case 'RECIPE':
                        DataikuAPI.flow.recipes.getFullInfo($scope.projectKey, $scope.objectId).noSpinner()
                            .success(function(data) {
                                $scope.data = data;
                            })
                            .error(setErrorInScope.bind($scope));
                        return;

                    case 'MANAGED_FOLDER':
                        DataikuAPI.managedfolder.getWithStatus($scope.projectKey, $scope.objectId).noSpinner()
                            .success(function(data) {
                                $scope.data = {folder: data};
                            })
                            .error(setErrorInScope.bind($scope));
                        return;

                    case 'STREAMING_ENDPOINT':
                        DataikuAPI.streamingEndpoints.getFullInfo($scope.projectKey, $scope.objectId).noSpinner()
                            .success(function(data){
                                $scope.data = data;
                            }).error(setErrorInScope.bind(scope));
                        return;

                    case 'SAVED_MODEL':
                        DataikuAPI.savedmodels.get($scope.projectKey, $scope.objectId).noSpinner()
                            .success(function(data) {
                                $scope.data = {model: data};
                            })
                            .error(setErrorInScope.bind($scope));
                        return;

                    case 'MODEL_EVALUATION_STORE':
                        DataikuAPI.modelevaluationstores.get($scope.projectKey, $scope.objectId).noSpinner()
                            .success(function(data) {
                                $scope.data = {model: data};
                            })
                            .error(setErrorInScope.bind($scope));
                        return;

                    case 'ANALYSIS':
                        DataikuAPI.analysis.getCore($scope.projectKey, $scope.objectId).noSpinner()
                            .success(function(data) {
                                 $scope.data = {analysis: data};
                            })
                            .error(setErrorInScope.bind($scope));
                        return;

                    case 'SQL_NOTEBOOK':
                        DataikuAPI.sqlNotebooks.get($scope.projectKey, $scope.objectId).noSpinner()
                            .success(function(data) {
                                $scope.data = {notebook: data};
                            })
                            .error(setErrorInScope.bind($scope));
                        return;

                    case 'JUPYTER_NOTEBOOK':
                        DataikuAPI.jupyterNotebooks.getNotebook($scope.projectKey, $scope.objectId, undefined).noSpinner()
                            .success(function(data) {
                                $scope.data = {notebook: data};
                            })
                            .error(setErrorInScope.bind($scope));
                        return;

                    case 'INSIGHT':
                        DataikuAPI.dashboards.insights.get($scope.projectKey, $scope.objectId).noSpinner()
                            .success(function(data) {
                                 $scope.data = {insight: data};
                            })
                            .error(setErrorInScope.bind($scope));
                        return;

                    case 'DASHBOARD':
                        DataikuAPI.dashboards.getFullInfo($scope.projectKey, $scope.objectId).noSpinner()
                          .success(function(data) {
                              $scope.data = data;
                          })
                          .error(setErrorInScope.bind($scope));
                        return;

                    case 'FLOW_ZONE':
                        DataikuAPI.zones.getFullInfo($scope.projectKey, $scope.objectId).noSpinner()
                          .success(function(data) {
                              $scope.data = data;
                          })
                          .error(setErrorInScope.bind($scope));
                        return;

                    case 'CONTINUOUS_ACTIVITY':

                        DataikuAPI.continuousActivities.getState(ActiveProjectKey.get(), $stateParams.continuousActivityId).noSpinner()
                            .success(function(data) {
                                $scope.data = data;
                            }).error(setErrorInScope.bind($scope));
                        return;
                    }
                    logger.error("Unknown type: "+$scope.objectType.toUpperCase());
                }
           });

           function refreshMetadata(o) {
                if (o.metaRefreshed) return;
                DataikuAPI.taggableObjects.getMetadata($scope.getTaggableObject()).success(function(data) {
                    o.description = data.description;
                    o.shortDesc = data.shortDesc;
                    o.tags = data.tags; //mjt suspicious that this was missing....
                    o.metaRefreshed = true;
                });
            }

            function isShownInFlow(objType) {

                switch(objType) {
                    case 'DATASET_CONTENT':
                    case 'RECIPE':
                    case 'DATASET':
                    case 'SAVED_MODEL':
                    case 'MODEL_EVALUATION_STORE':
                    case 'MANAGED_FOLDER':
                    case 'STREAMING_ENDPOINT':
                        return true;

                    //'CONNECTION', 'SCENARIO', 'ANALYSIS', 'SQL_NOTEBOOK', 'JUPYTER_NOTEBOOK', 'INSIGHT', 'DASHBOARD', 'WEB_APP', 'REPORT'
                    default:
                        return false;
                }
            }

            function enrichData() {
                const objectData = $scope.data;
                const objType = $scope.objectType.toUpperCase()

                switch(objType) {

                case 'CONNECTION':
                case 'BUNDLE':
                    return;
                case 'SCENARIO':
                    $scope.object = objectData.object;
                    refreshMetadata(objectData.object);
                    return;
                case 'DATASET_CONTENT':
                    if ($scope.data.dataset_content) {
                        $scope.dataset = $scope.data.dataset_content;
                    }
                    $scope.object = $scope.dataset;
                    return;

                case 'ANALYSIS':
                    if (!objectData.mlTasks) {
                        DataikuAPI.analysis.listMLTasks(objectData.analysis.projectKey, objectData.analysis.id)
                            .success(function (data) {
                                objectData.mlTasks = data;
                            })
                            .error(setErrorInScope.bind($scope));
                    }

                    if (!objectData.timeline) {
                        objectData.timeline = {};
                        if (objectData.analysis.creationTag) {
                            objectData.timeline.createdBy = objectData.analysis.creationTag.lastModifiedBy;
                            objectData.timeline.createdOn = objectData.analysis.creationTag.lastModifiedOn;
                        }
                        if (objectData.analysis.versionTag) {
                            objectData.timeline.lastModifiedBy = objectData.analysis.versionTag.lastModifiedBy;
                            objectData.timeline.lastModifiedOn = objectData.analysis.versionTag.lastModifiedOn;
                        }
                    }
                    $scope.object = objectData.analysis;
                    return;
                case 'RECIPE':
                    RecipesUtils.parseScriptIfNeeded(objectData);
                    //fetchTimeline(objectData.recipe.projectKey, objectData.recipe.name);
                    $scope.object = objectData.recipe;
                    return;
                case 'DATASET':
                    //fetchTimeline(objectData.dataset.projectKey, objectData.dataset.name);
                    $scope.object = objectData.dataset;
                    return;
                case 'STREAMING_ENDPOINT':
                    //fetchTimeline(objectData.streamingEndpoint.projectKey, objectData.streamingEndpoint.id);
                    $scope.object = objectData.streamingEndpoint;
                    return;
                case 'SQL_NOTEBOOK':
                    if (!objectData.notebook) objectData.notebook = objectData.sql_notebook;
                    $scope.object = objectData.notebook;
                    if (!objectData.notebook.niceConnection) {
                        objectData.notebook.niceConnection = NotebooksUtils.parseConnection(objectData.notebook.connection).niceConnection;
                    }
                    refreshMetadata(objectData.notebook);
                    return;
                case 'JUPYTER_NOTEBOOK':
                    if (!objectData.notebook) objectData.notebook = objectData.jupyter_notebook;
                    $scope.object = objectData.notebook;
                    refreshMetadata(objectData.notebook);
                    return;
                case 'INSIGHT':
                    $scope.object = objectData.insight;
                    return;
                case 'DASHBOARD':
                    $scope.object = objectData.dashboard;
                    return;
                case 'WEB_APP':
                    $scope.object = objectData.webapp;
                    return;
                case 'REPORT':
                    $scope.object = objectData.report;
                    return;
                case 'LAMBDA_SERVICE':
                    $scope.object = objectData.object;
                    return;
                case 'FLOW_ZONE':
                    $scope.object = objectData.zone;
                    return;
                case 'SAVED_MODEL':
                    if (!objectData.model) objectData.model = objectData.saved_model;
                    if (!objectData.status) {
                        switch (objectData.model.miniTask.taskType) {
                            case 'CLUSTERING':
                                DataikuAPI.savedmodels.clustering.getStatus(objectData.model.projectKey, objectData.model.id)
                                    .success(function (data) {
                                        objectData.status = data;
                                    })
                                    .error(setErrorInScope.bind($scope));
                                break;
                            case 'PREDICTION':
                                DataikuAPI.savedmodels.prediction.getStatus(objectData.model.projectKey, objectData.model.id)
                                    .success(function (data) {
                                        objectData.status = data;
                                    })
                                    .error(setErrorInScope.bind($scope));
                                break;
                        }
                    }
                    $scope.object = objectData.model;
                    return;
                case 'MODEL_EVALUATION_STORE':
                    if (!objectData.evaluationStore) objectData.evaluationStore = objectData.model_evaluation_store;
                    $scope.object = objectData.evaluationStore;
                    return;
                case 'MANAGED_FOLDER':
                    if (!objectData.folder) objectData.folder = objectData.managed_folder;
                    $scope.object = objectData.folder;
                    if (!objectData.timeline) {
                        objectData.timeline = {};
                        if (objectData.folder.creationTag) {
                            objectData.timeline.createdBy = objectData.folder.creationTag.lastModifiedBy;
                            objectData.timeline.createdOn = objectData.folder.creationTag.lastModifiedOn;
                        }
                        if (objectData.folder.versionTag) {
                            objectData.timeline.lastModifiedBy = objectData.folder.versionTag.lastModifiedBy;
                            objectData.timeline.lastModifiedOn = objectData.folder.versionTag.lastModifiedOn;
                        }
                    }
                    return;
                case "ARTICLE":
                    $scope.object = objectData.article ? objectData.article.data : (objectData.object ? objectData.object : undefined);
                    return
                case 'CONTINUOUS_ACTIVITY':
                    $scope.object = objectData.object;
                    return;
                }

                logger.error("Unknown type: "+$scope.objectType.toUpperCase());
            }

           function fetchTimeline(projectKey, objectId) {
                if (!$scope.data.timeline) {
                    const objectType = $scope.objectType == 'DATASET_CONTENT' ? 'DATASET' : $scope.objectType.toUpperCase();
                    DataikuAPI.timelines.getForObject(projectKey, objectType, objectId)
                        .success(function(data) {
                            $scope.data.timeline = data;
                        })
                        .error(setErrorInScope.bind($scope));
                }
            }
        }
    };
});


app.directive("rightColumnTab", function(QuickView) {
    return {
        scope: false,
        link: function(scope, element, attrs) {
            function updateActiveTab(tabName = "actions", update = false) {
                scope.uiState = { activeTab: tabName };
                if(scope.setCurrentTab !== undefined){ // old right panel still need to work
                    scope.setCurrentTab(tabName, update);
                }
            }

            attrs.$observe("rightColumnTab", value => {
              updateActiveTab(value);
            });

            Mousetrap.bind('space', function() {
                const nextTab = scope.displayedTabs[((scope.displayedTabs.findIndex(tab => tab.name === scope.currentTab) + 1) % scope.displayedTabs.length)];
                if (nextTab !== undefined) {
                    updateActiveTab(nextTab.name, true);
                }
            });
            scope.$on('$destroy', function() {
                Mousetrap.unbind('space');
                QuickView.hide();
            });
        }
    };
});


app.directive("samplingDetailsBlock", function($controller) {
    return {
        scope: {
            selection: '='
        },
        restrict: 'AE',
        templateUrl: '/templates/object-details/sampling-block.html'
    };
});


app.constant("STANDARDIZED_SIDE_PANEL_KEY", "dss.standardizedSidePanel");

app.service("ActivateOldRightPanel", function($state){
    return {
        isActivated: function(){
            return !["projects.project.analyses.list",
                     "projects.project.datasets.list",
                     "projects.project.streaming-endpoints.list",
                     "projects.project.bundlesdesign.list",
                     "projects.project.lambdaservices.list",
                     "projects.project.recipes.list",
                     "projects.project.notebooks.list",
                     "projects.project.scenarios.list",
                     "projects.project.continuous-activities.list",
                     "projects.project.webapps.list",
                     "projects.project.reports.list",
                     "projects.project.dashboards.list",
                     "projects.project.dashboards.insights.list",
                     "projects.project.flow"].includes($state.current.name);
        }
    }
});

app.directive('standardizedSidePanel', function (LocalStorage, STANDARDIZED_SIDE_PANEL_KEY, $rootScope, $stateParams) {
    return {
        restrict: "E",
        scope: true,
        templateUrl: '/templates/standardized-right-panel.html',
        link: function($scope, $element, attrs) {
            let allTabs = [
              {
                name: "actions",
                icon: "icon-dku-right-panel-actions"
              },
              {
                name: "details",
                icon: "icon-dku-right-panel-info"
              },
              {
                name: "preview",
                icon: "icon-dku-right-panel-preview"
              },
              {
                name: "schema",
                icon: "icon-dku-right-panel-schema"
              },
              {
                name: "discussions",
                icon: "icon-dku-right-panel-discussions"
              },
              {
                name: "lab",
                icon: "icon-dku-right-panel-lab"
              }
            ];

            let objectsToTabsMapping = [
              {
                objectTypes: ["DATASET", "LOCAL_DATASET", "FOREIGN_DATASET"],
                tabNames: ["actions", "details", "schema", "discussions", "lab"]
              },
              {
                objectTypes: ["RECIPE"],
                tabNames: ["actions", "details", "discussions"] // TO DO : add & implement preview tab
              },
              {
                objectTypes: ["ANALYSIS"],
                tabNames: ["actions", "details", "discussions"]
              },
              {
                objectTypes: ["SQL_NOTEBOOK"],
                tabNames: ["actions", "details", "discussions"]
              },
              {
                objectTypes: ["JUPYTER_NOTEBOOK"],
                tabNames: ["actions", "details", "discussions"]
              },
              {
                objectTypes: ["SCENARIO"],
                tabNames: ["actions", "details", "discussions"]
              },
              {
                objectTypes: ["WEB_APP"],
                tabNames: ["actions", "details", "discussions"]
              },
              {
                objectTypes: ["REPORT"],
                tabNames: ["actions", "details", "discussions"]
              },
              {
                objectTypes: ["SAVED_MODEL", "LOCAL_SAVEDMODEL", "FOREIGN_SAVEDMODEL"],
                tabNames: ["actions", "details", "discussions"]
              },
              {
                objectTypes: ["MODEL_EVALUATION_STORE", "LOCAL_MODELEVALUATIONSTORE", "FOREIGN_MODELEVALUATIONSTORE"],
                tabNames: ["actions", "details", "discussions"]
              },
              {
                objectTypes: ["MANAGED_FOLDER", "LOCAL_MANAGED_FOLDER", "FOREIGN_MANAGED_FOLDER"],
                tabNames: ["actions", "details", "discussions"]
              },
              {
                objectTypes: ["DASHBOARD"],
                tabNames: ["actions", "details", "discussions"]
              },
              {
                objectTypes: ["INSIGHT"],
                tabNames: ["actions", "details", "discussions"]
              },
              {
                objectTypes: ["ZONE"],
                tabNames: ["actions", "details", "discussions"]
              },
              {
                objectTypes: ["CONTINUOUS_ACTIVITY"],
                tabNames: ["actions", "details"]
              },
              {
                objectTypes: ["STREAMING_ENDPOINT", "LOCAL_STREAMING_ENDPOINT", "FOREIGN_STREAMING_ENDPOINT"], // the foreign version doesn't exist yet
                tabNames: ["actions", "details", "discussions"]
              },
              {
                objectTypes: ["BUNDLES_DESIGN"],
                tabNames: ["actions", "details"]
              },
              {
                objectTypes: ["BUNDLES_DESIGN_MULTI"], // not a taggable object, has own multi
                tabNames: ["actions"]
              },
              {
                objectTypes: ["LAMBDA_SERVICE"],
                tabNames: ["actions", "details"]
              },
              {
                objectTypes: ["MULTI"],
                tabNames: ["actions"]
              },
              {
                objectTypes: [""],
                tabNames: []
              }
            ];

            $scope.standardizedSidePanel.tabToToggle = '';

            function getLatestUsedTab(objectType, tabs) {
                const key = !objectType ? `${STANDARDIZED_SIDE_PANEL_KEY}.tab` : `${STANDARDIZED_SIDE_PANEL_KEY}.${objectType}.tab`;
                const lastTabState = LocalStorage.get(key);
                let lastGeneralTab = undefined;
                if (objectType) {
                    lastGeneralTab = getLatestUsedTab(null, tabs);
                }
                if (lastGeneralTab !== undefined) {
                    return lastGeneralTab;
                }
                if (lastTabState !== undefined && Array.isArray(tabs)) {
                    const found = tabs.map(tab => tab.name).find(tabName => tabName === lastTabState);
                    return found !== undefined || objectType === null ? found : "actions";
                }
                return Array.isArray(tabs) && tabs.length > 0 ? tabs[0].name : "actions";
            }

            function updateLatestUsedTab(objectType, tab) {
                const key = !objectType ? `${STANDARDIZED_SIDE_PANEL_KEY}.tab` : `${STANDARDIZED_SIDE_PANEL_KEY}.${objectType}.tab`;
                LocalStorage.set(key, tab);
                if (objectType) {
                    updateLatestUsedTab(null, tab);
                }
            }

            let panel = document.getElementsByClassName('right-panel')[0];
            $scope.standardizedSidePanel.opened = false;
            $scope.defaultTab = "actions"; // TO DO : replace with remembered state

            let openPanelOnLoad;
            switch (attrs.page) {
                case 'flow':
                    openPanelOnLoad = getLastPanelState(true);
                    break;
                case 'objects_list':
                    openPanelOnLoad = true;
                    break;
                case 'object':
                default:
                    openPanelOnLoad = false;
            }

            function computeTabsToDisplay() {
                for (let e of objectsToTabsMapping) {
                    if (e.objectTypes.includes(attrs.objectType)) {
                        $scope.displayedTabs = allTabs
                            .filter(tab => e.tabNames.includes(tab.name))
                            .sort((a, b) => e.tabNames.indexOf(a.name) - e.tabNames.indexOf(b.name));
                        if (e.tabNames && e.tabNames.length > 0 && !e.tabNames.includes($scope.defaultTab)) {
                            $scope.defaultTab = e.tabNames[0].name;
                        }
                        break;
                    }
                }
            }
            computeTabsToDisplay();

            attrs.$observe("closeOnClickOutside", newValue => {
                if (newValue) {
                    let mainPanes = document.getElementsByClassName('main-panel');
                    if (mainPanes.length > 0) {
                        let mainPane = mainPanes[0];
                        mainPane.addEventListener("click", (event) => {
                            if (event && event.target && event.target.id === "qa_generic_actions-dropdown") {
                                return;
                            }
                            $scope.closePanel();
                        });
                    }
                }
            });

            attrs.$observe("page", newValue => {
                computeTabsToDisplay();
                $scope.page = newValue;
            });

            attrs.$observe("objectType", newValue => {
                computeTabsToDisplay();
                $scope.objectType = newValue;
                const mayChooseDiscussionsTab = $stateParams.discussionId && $scope.displayedTabs.find(tab => tab.name == 'discussions');
                const lastUsedTab = (mayChooseDiscussionsTab && 'discussions') || getLatestUsedTab(newValue, $scope.displayedTabs);
                if (lastUsedTab !== $scope.currentTab && newValue !== '') {
                    $scope.currentTab = lastUsedTab;
                    updateLatestUsedTab(newValue, $scope.currentTab);
                }
                if (mayChooseDiscussionsTab) {
                    $scope.openPanel();
                }
            });

            attrs.$observe("toggleTab", tabName => {
                if (tabName && tabName != "") {
                    $scope.clickTab(tabName, true);
                }
            });

            attrs.$observe("singleType", newValue => {
                $scope.singleType = newValue;
            });

            $scope.getTooltipText = function (tab) {
                return tab.name.charAt(0).toUpperCase() + tab.name.slice(1);
            }

            $scope.togglePanel = function () {
                if ($scope.isPanelOpened()) {
                    $scope.closePanel();
                } else {
                    $scope.openPanel();
                }
            }
            
            $scope.openPanel = function () {
                $scope.changePanelStateIfNeeded(true);
                if (!angular.isDefined($scope.currentTab) || !$scope.currentTab) {
                    $scope.setCurrentTab($scope.defaultTab, false);
                }
            }
            
            $scope.closePanel = function () {
                $scope.changePanelStateIfNeeded(false);
            }

            $scope.clickTab = function (tabName, forceOpen=false) {
                if ($scope.isPanelOpened() && $scope.isCurrentTab(tabName) && !forceOpen) {
                    $scope.closePanel();
                } else {
                    $scope.setCurrentTab(tabName);
                    $scope.openPanel();
                }
            }

            $scope.setCurrentTab = function (tabName, update = true) {
                $scope.currentTab = tabName;
                if (update === true) {
                    if (tabName === 'actions' && attrs.objectType && attrs.objectType.includes('DATASET')) {
                        $rootScope.$broadcast('taggableObjectTagsChanged');
                    }
                    updateLatestUsedTab($scope.objectType, tabName);
                }
            }

            $scope.getCurrentTab = function() {
                return $scope.currentTab;
            };
            
            $scope.isCurrentTab = function (tabName) {
                return $scope.currentTab === tabName;
            }
            
            $scope.isPanelOpened = function () {
                return $scope.standardizedSidePanel.opened;
            }
            
            $scope.isTabActive = function (tabName) {
                return ($scope.isPanelOpened() && $scope.isCurrentTab(tabName));
            }

            $scope.changePanelStateIfNeeded = function (newState) {
                let currentState = $scope.isPanelOpened();
                if (currentState != newState) {
                    $scope.standardizedSidePanel.slidePanel();
                    savePanelState();
                }
            };

            // Init states
            if (openPanelOnLoad) {
                $scope.openPanel();
            }

            // Activate transitions only after page load
            // N.B. : If we start using this mecanism in other places in the code it would be better
            // to place the following block in a stateChange event in DataikuController
            let httpRequestsListener = $rootScope.$watch('httpRequests.length', (newVal) => {
                if (newVal !== 0) {
                    return;
                }

                const noTransitionsOnLoadClass = 'no-transitions-on-load';
                let noTransitionsElements = document.getElementsByClassName(noTransitionsOnLoadClass);
                const nbElmts = noTransitionsElements.length;
                
                for (let i = 0; i < nbElmts; i++) {
                    noTransitionsElements[0].classList.remove(noTransitionsOnLoadClass);
                }
                
                httpRequestsListener();
            });

            // Refresh fat-repeats of the object list views
            panel.addEventListener('transitionend', refreshFatRepeats); // To do : add event only if the page contains fat-repeat
            function refreshFatRepeats() {
                $rootScope.$broadcast("reflow"); // To do : call reflow only on the fat-repeat scope ?
            }

            // Settings using Local Storage
            function getLastPanelState(defaultValue) {
                let key = STANDARDIZED_SIDE_PANEL_KEY + '.' + attrs.page + 'Panel';
                let lastPanelState = LocalStorage.get(key);

                if (lastPanelState != undefined) {
                    return lastPanelState;
                } else {
                    return defaultValue;
                }
            }

            function savePanelState() {
                let key = STANDARDIZED_SIDE_PANEL_KEY + '.' + attrs.page + 'Panel';
                LocalStorage.set(key, $scope.isPanelOpened());
            }

        }
    };
});

app.directive("hideIfNoFilter", function($controller) {
    return {
        restrict : 'A',
        link : function(scope, element, attrs) {

            scope.$watch("noTags", function(nv) {
                let elmts = document.getElementsByClassName('list-page__filter');
                let c = 0;

                for(let i = 0; i < elmts.length; i++) {
                    c += elmts[i].childNodes.length;
                }

                if (c == 0 && nv) {
                    element.addClass('display-none');
                } else {
                    element.removeClass('display-none');
                }
            });
            
        }
    }
});

})();

(function(){
    'use strict';

    var app = angular.module('dataiku.common.lists', []);

    app.factory('ListFilter', function() {

        function filterList(list, query) {
            // query is either A. an ["array", "of", "strings"],
            // or B. a single /regexp/ or "string"
            return (Array.isArray(query)
                ? query.reduce(filterList, list)    // A
                : list.filter(objectMatchesQuery.bind(null, query)));   // B
        }

        function Pagination(list, perPage) {
            this.list = list;
            this.page = 1;  // /!\ 1-based
            this.perPage = perPage || 100;
            this.update();
        }
        Pagination.prototype.update = function updatePagination() {
            if (!this.list || !this.list.length || this.page <= 0) {
                this.slice = [];
                this.from = this.to = this.size = 0;
                return;
            } else {
                this.size = this.list.length;
            }
            this.maxPage = Math.ceil(this.size / this.perPage);
            this.page = Math.min(this.page, this.maxPage);
            this.from = (this.page - 1) * this.perPage;
            this.to = Math.min(this.list.length, this.from + this.perPage) - 1;
            this.slice = this.list.slice(this.from, this.to + 1);
            // page controls, e.g. when on page 6: [1, null, 4, 5, 6, 7, 8, null, 16]
            this.controls = Array(this.maxPage);
            for(var i = this.controls.length; i > 0; i--) { this.controls[i-1] = i; }
            if (this.maxPage > 10) { // keep 2 before, 2 after, and both ends
                if (this.page > 5) {
                    i = this.controls.splice(1, this.page - 4, null).length - 1;
                } // else i = 0; // already from the loop
                if (this.maxPage - this.page > 4) {
                    this.controls.splice(this.page - i + 2, this.maxPage - this.page - 3, null);
                }
            }
        };
        Pagination.prototype.go = function(p) { switch (p) {
            case 0 : this.page = Math.min(this.maxPage, this.page + 1); break;
            case -1: this.page = Math.max(           1, this.page - 1); break;
            default: this.page = p;
        } };    // NB: doesn't call update, this.page is probably $watch()ed
        Pagination.prototype.next = function() { this.go( 0); };
        Pagination.prototype.prev = function() { this.go(-1); };

        Pagination.prototype.nextPage = function(){
            this.page = Math.min(this.maxPage, this.page + 1);
        }
        Pagination.prototype.prevPage = function(){
            this.page = Math.max(1, this.page - 1);
        }
        // No bounds check is performed. Pages are 1-indexed
        Pagination.prototype.goToPage = function(page){
            this.page = page;
        }

        Pagination.prototype.updateAndGetSlice = function(list){
            this.list = list;
            this.update();
            return this.slice;
        }

        return {
            /**
             * Filters a list (array) of Objects according to a queryString.
             * If queryString looks like a /regex/i, filter will use a regex,
             * otherwise it will use whitespace-separated literal tokens.
             */
            filter: function filter(list, queryString) {
                queryString = queryString && queryString.trim();
                if (!list) return [];
                if (!queryString) return list.concat();  // no-filter fast-pass
                var regex = queryString.match(/^\/(.+)\/$/);
                return filterList(list, regex ? new RegExp(regex[1], 'i')
                    : queryString.toLowerCase().split(/\s+/));
            },
            /**
             * Handles pagination.
             * Invoke with `new`, then set its `page` and call `update()`.
             */
            Pagination: Pagination
        };
    });

})();

(function(){
    'use strict';

    var app = angular.module('dataiku.common.func', []);

    app.factory('Collections', function(Fn) {
        var Collections = {

            indexByField : function indexBy(list, field) {
                var ret = {}
                list.forEach(function(x) {
                    ret[x[field]] = x;
                })
                return ret;
            },

            // copy src into dest without dereference.
            // Use dest = updateNoDereference(dest, src) to avoid NPE
            updateNoDereference: function(dest, src) {
              if ($.isPlainObject(dest)) {
                var i;
                for (i in dest) {
                  if (src[i]) {
                    dest[i] = Collections.updateNoDereference(dest[i],src[i]);
                  } else if (!i.startsWith("$")) {
                    delete dest[i];
                  }
                }
                for (i in src) {
                  if (!dest[i]) {
                    dest[i] = src[i];
                  }
                }
                return dest;
              } else if ($.isArray(dest)) {
                for (i=dest.length-1; i>=0; i--) {
                  if (src[i]) {
                    dest[i] = Collections.updateNoDereference(dest[i],src[i]);
                  } else {
                    dest.splice(i,1);
                  }
                }
                for (i in src) {
                  if (!dest[i]) {
                    dest[i] = src[i];
                  }
                }
                return dest;
              } else {
                return src;
              }
            },
            // Do array : dest = src without dereference (equality based on dest[i][key] = src[i][key])
            updateArrayBasedOn: function(dest, src, key) {
                if (!dest) { return src }
                var srcDict = Collections.indexByField(src, key);
                for (var i = dest.length-1; i>= 0;i--) {
                    if (dest[i] && dest[i][key] && srcDict[dest[i][key]]) {
                      dest[i] = Collections.updateNoDereference(dest[i], srcDict[dest[i][key]]);
                    } else {
                      dest.splice(i,1);
                    }
                }
                var destKeys = dest.map(Fn.prop(key));
                src.forEach(function(o){
                  if (destKeys.indexOf(o[key]) === -1) {
                    dest.push(o);
                  }
                });
                return dest;
            },


        }
        return Collections;
    });

    app.factory('Fn', function() {

        function compose2(f1, f2) {
            return function() { return f2.call(this, f1.apply(this, arguments)); }
        };

        function cartesianProduct(arr)
        {
            return arr.reduce(function(a,b){
                return a.map(function(x){
                    return b.map(function(y){
                        return x.concat(y);
                    })
                }).reduce(function(a,b){ return a.concat(b) },[])
            }, [[]])
        }

        var Fn = {
            // constant functions & reducers /!\ use directly
            NOOP: function NOOP() {},
            SELF: function SELF(a) { return a; },
            INDEX: function INDEX(_, i) { return i; },  // for array utils
            LOG: function LOG(a) { /*@console*/ console.log(a); return a; }, // NOSONAR - by design
            DEBUG: function DEBUG(a) { debugger; return a; }, // NOSONAR - by design
            AND: function AND(a, b) { return a && b; },
            OR: function OR(a, b) { return a || b; },
            SUM: function SUM(a, b) { return a + b; },  // also works as string joiner
            MUL: function MUL(a, b) { return a * b; },
            MAX: function MAX(a, b) { return Math.max(a,b); },
            MIN: function MIN(a, b) { return Math.min(a,b); },
            CMP: function(a, b) { return a.valueOf() < b.valueOf() ? -1 : (a.valueOf() > b.valueOf() ? 1 : 0) },

            // composers
            not: function not(f) { return function() { return !f.apply(this, arguments); } },
            compose: function compose(f1) { return Array.prototype.slice.call(arguments, 1).reduce(compose2, f1); },
            args: function fnArgs(args, f) { return function() {
                for (var i in args) { if (typeof args[i] !== 'undefined') arguments[i] = args[i]; }
                return f.apply(this, arguments);
            }; },

            // arrays
            // cartesian product
            product: function() {
              return cartesianProduct(arguments);
            },
            // cartesian power
            pow: function(arr, p) {
              var res = [];
              for (var i=0;i<p;i+=1) {
                res.push(arr);
              }
              return cartesianProduct(res);
            },

            /* When this function is called with N arguments, it calls f with only the first argument */
            passFirstArg : function passFirstArg(f) {
                return function() {
                    return f(arguments[0]);
                }
            },

            // ready-made functors
            cst: function cst(a) { return function() { return a; }; },
            eq: function eq(to) { return function(o) { return to === o; }; },
            like: function like(to) { return function(o) { return to == o; }; },
            ofType: function ofType(t) { return function(o) { return typeof o === t; }; },
            unique: function unique() {
                var a = [], t = Fn.inArray(a);
                return function(o) { return !t(o) && a.push(o) && true; };
            },
            inArray: function inArray(arr) { return function(o) { return arr.indexOf(o) !== -1; } },
            regexp: function regexp(re) { return re.test.bind(re); },

            // extractors

            /**
             * Extracts a property from current element, optionally using deep access
             * @param name: the property to extract, or an array for deep access
             *  Fn.prop("a")(x) -> returns x["a"]
             *  Fn.prop(["a", "b"])(x) -> returns x["a"]["b"]
             *  Fn.prop([])(x) -> returns x
             */
            prop: function prop(name) {
                if (!Array.isArray(name))   { return (function(o) { return o[name]}); }
                else if (name.length === 0) { return Fn.SELF; }
                else                        { return Fn.compose.apply(null, name.map(Fn.prop)); }
            },
            /**
             * Extracts a property from current element using string-based deep access
             * @param name: a dotted expression denoting the property to extract
             *  Fn.propStr("a")(x) -> returns x["a"]
             *  Fn.propStr("a.b")(x) -> returns x["a"]["b"]
             *  Fn.propStr("")(x) -> returns x
             */
            propStr: function propStr(name) {
                if (name == null || name.length == 0) return Fn.prop([])
                return Fn.prop(name.split("."))
            },

            // setters
            /**
             * Sets a property from current element, optionally using deep access
             * @param name: the property to extract, or an array for deep access
             *  Fn.setProp(e, "a")(x) -> set x["a"] = e , returns x["a"]
             *  Fn.setProp(e, ["a", "b"])(x) -> sets x["a"]["b"] = e , returns x["a"]["b"]
             *  Fn.setProp(e, [])(x) -> return e , does nothing to x (you should use x = e)
             */
            setProp: function setProp(value, name) {
                if (!Array.isArray(name))   { return (function(o) { if(!o) return o ; o[name] = value ; return o[name] }); }
                else if (name.length === 0) { return (function(o) { return value; }); }
                else                        { return compose2.call(null,
                    Fn.compose.apply(null, name.slice(0,name.length-1).map(Fn.propSafe)) || Fn.SELF ,
                    Fn.setProp.call(null, value, name[name.length-1])
                ); }
            },
            propSafe: function propSafe(name) {
                if (!Array.isArray(name))   { return (function(o) { if(!o[name]) { o[name] = {} } ; return o[name] }); }
                else if (name.length === 0) { return Fn.SELF; }
                else                        { return Fn.compose.apply(null, name.map(Fn.propSafe)); }
            },
            propStrSafe: function propStr(name) {
                if (name == null || name.length == 0) return Fn.propSafe([])
                return Fn.propSafe(name.split("."))
            },
            /**
             * Sets a property from current element using string-based deep access
             * @param name: a dotted expression denoting the property to extract
             *  Fn.setPropStr(e, "a")(x) -> sets x["a"] = e
             *  Fn.setPropStr(e, "a.b")(x) -> sets x["a"]["b"] = e
             *  Fn.setPropStr(e, "")(x) -> return e , does nothing to x (you should use x = e)
             */
            setPropStr: function setPropStr(value, name) {
                if (name == null || name.length == 0) return Fn.setProp(value, [])
                return Fn.setProp(value, name.split("."))
            },


            /** Calls the identified method on the current element (cur.method())
              * @param m: function to call with the current element as @this
              *    or name of the method on the element (NOOP when does not exist).
              * @param args: additional arguments for the call (optional)
              */
            method: function method(m, args) { return function(o) {
                return (typeof m === 'function' ? m : (o[m] || Fn.NOOP)).apply(o, args || []);
            }; },
            assign: function assign(name, f) { return function(o) { o[name] = f.apply(this, arguments); return o; }; },
            from: function from(o, i) { i = i || 0; return (function() { return this[arguments[i]]; }).bind(o); },
            dict: function dict(o, def) { return function(a) {
                return a in o ? o[a] : typeof def ==='function' ? def(a) : def; }; 
            },

            // misc

            /**
             * Returns a function F that executes {@param fn} when F is called with a non-null
             * first argument
             */
            doIfNv : function doIf(fn) {
                return (function(nv) { if (nv !== null && nv !== undefined) fn(); });
            },

            getCustomTimeFormat() {
                var customTimeFormat = d3.time.format.multi([
                    [".%L", function(d) { return d.getMilliseconds(); }],
                    [":%S", function(d) { return d.getSeconds(); }],
                    ["%H:%M", function(d) { return d.getMinutes(); }],
                    ["%H:00", function(d) { return d.getHours(); }],
                    ["%a %d", function(d) { return d.getDay() && d.getDate() != 1; }],
                    ["%b %d", function(d) { return d.getDate() != 1; }],
                    ["%B", function(d) { return d.getMonth(); }],
                    ["%Y", function() { return true; }]
                ]);
                return customTimeFormat;
            }
        };

        Fn.neq = compose2(Fn.eq, Fn.not);

        return angular.extend(Fn.compose, Fn);
    });
})();


(function(){
'use strict';
/**
 * Services for building computables
 */

var app = angular.module('dataiku.common.build', []);

app.service('PartitionSelection', ['LocalStorage', '$stateParams', 'Logger', function(LocalStorage, $stateParams, Logger) {
    function get() {
        if ($stateParams.projectKey) {
        	var stored = LocalStorage.get($stateParams.projectKey + '.partitionSettings') || {};
            Logger.info("reading partitionSettings", stored);
            return stored;
        }
        throw new Error("projectKey not defined");
    }
    function set(partitionSettings) {
        //TODO cleanup mechanism to avoid growing partitionSettings too much
        Logger.info("saving partitionSettings", partitionSettings);
        LocalStorage.set($stateParams.projectKey + '.partitionSettings', partitionSettings);
    }
    function save(dimName, value) {
        var partitionSettings = get();
        if (value != null && (value.start !== undefined || value.end !== undefined || value.explicit !== undefined)) {
            var startKey = dimName+"_start_"+value.format;
            partitionSettings[startKey] = value.start;
            var endKey = dimName+"_end_"+value.format;
            partitionSettings[endKey] = value.end;
            var explicitKey = dimName+"_explicit_"+value.format;
            partitionSettings[explicitKey] = value.explicit;
            var useExplicitKey = dimName+"_useExplicit_"+value.format;
            partitionSettings[useExplicitKey] = value.useExplicit;
        } else {
            partitionSettings[dimName] = value;
        }
        set(partitionSettings);
    }
    function getTimeFormat(dimType, params) {
        var format;
        if (dimType == 'time' && params.period != 'YEAR') {
            var format = 'YYYY';
            if(params.period == 'MONTH'){
                format = 'YYYY-MM';
            } else if(params.period == 'DAY'){
                format = 'YYYY-MM-DD';
            } else if(params.period == 'HOUR'){
                format = 'YYYY-MM-DD-HH';
            }
        }
        return format;
    }

    //Legacy
    function getPartitionsFromCookie(dimName, timeFormat) {
        var dimName2 = 'partition_' + dimName;
        var ret, found;
        if (timeFormat) {
            var start = getCookie(dimName2 + "_start_" + timeFormat);
            var end = getCookie(dimName2 + "_end_" + timeFormat);
            var explicit = getCookie(dimName2 + "_explicit" + timeFormat);
            var useExplicit = getCookie(dimName2 + "_useExplicit" + timeFormat);
            ret = {
                'start': start || moment().format(timeFormat),
                'end': end || moment().format(timeFormat),
                'explicit': explicit || moment().format(timeFormat),
                'useExplicit': useExplicit || false,
                'format': timeFormat
            };
            found = start !== undefined || end !== undefined;
        } else {
            ret = getCookie(dimName2) || undefined;;
            found = ret !== undefined;
        }
        return found ? ret : undefined;
    }

    function getPartitions(dimName, timeFormat) {
        var partitionSettings = get();
        var ret, found;
        if (timeFormat) {
            var start = partitionSettings[dimName + "_start_" + timeFormat];
            var end = partitionSettings[dimName + "_end_" + timeFormat];
            var explicit = partitionSettings[dimName + "_explicit_" + timeFormat];
            var useExplicit = partitionSettings[dimName + "_useExplicit_" + timeFormat];
            ret = {
                'start': start || moment().format(timeFormat),
                'end': end || moment().format(timeFormat),
                'explicit': explicit || moment().format(timeFormat),
                'useExplicit': useExplicit || false,
                'format': timeFormat
            };
            found = start !== undefined || end !== undefined;
        } else {
            ret = partitionSettings[dimName];
            found = ret !== undefined;
        }
        if (!found) {
            var fromCookie = getPartitionsFromCookie(dimName, timeFormat);
            if (fromCookie !== undefined) {
                ret = fromCookie;
                save(dimName, fromCookie);
            }
        }
        return ret;
    }

    return {
        getBuildPartitions: function(partitioning) {
            const buildPartitions = {};
            if (partitioning) {
                angular.forEach(partitioning.dimensions, function(dim) {
                    const timeFormat = getTimeFormat(dim.type, dim.params);
                    buildPartitions[dim.name] = getPartitions(dim.name, timeFormat);
                });
            }
            return buildPartitions;
        },
        saveBuildPartitions: function(partitioning, buildPartitions) {
            if (partitioning) {
                angular.forEach(partitioning.dimensions, function(dim) {
                    save(dim.name, buildPartitions[dim.name]);
                });
            }
        },
    }
}]);


app.service("JobDefinitionComputer", function(AnyLoc, $stateParams){
    var svc = {
        computeTargetPartition : function(partitioning, buildPartitions = {}) {
            if (partitioning && partitioning.dimensions.length > 0) {
                var dimensionValuesList = []; // will do a cartesian product of these
                angular.forEach(partitioning.dimensions, function(dimension, index){
                    var bp = buildPartitions[dimension.name];
                    if (!bp) {
                        return;
                    }
                    if (dimension.type == 'time') {
                         if (dimension.params.period == "YEAR") {
                             dimensionValuesList.push([bp]);
                         } else if (bp.useExplicit) {
                             if (bp.explicit.indexOf(',') >= 0) {
                                 dimensionValuesList.push(bp.explicit.split(','))
                             } else {
                                 dimensionValuesList.push([bp.explicit]);
                             }
                         } else {
                             if(bp.start != bp.end) {
                                 dimensionValuesList.push([bp.start + '/' + bp.end]);
                             } else {
                                 dimensionValuesList.push([bp.start]);
                             }
                         }
                    } else {
                        dimensionValuesList.push([bp]);
                    }
                });
                var partitionIds = [''];
                dimensionValuesList.forEach(function(dimensionValues) {
                    var newPartitionIds = [];
                    dimensionValues.forEach(function(dimensionValue) {
                        partitionIds.forEach(function(partitionId) {
                            newPartitionIds.push(partitionId + (partitionId ? '|' : '') + dimensionValue);
                        });
                    });
                    Array.prototype.splice.apply(partitionIds, [0, partitionIds.length].concat(newPartitionIds));
                });
                return partitionIds.join(',');
            } else {
                return null;
            }
        },

        computeOutputForDataset : function(dataset, buildPartitions) {
            var output =  {
                targetDataset : dataset.name,
                targetDatasetProjectKey : dataset.projectKey,
                type : 'DATASET',
                targetPartition : svc.computeTargetPartition(dataset.partitioning, buildPartitions)
            };
            return output;
        },

        computeOutputForSavedModel : function(model, buildPartitions) {
            return {
                targetDataset : model.id,
                targetDatasetProjectKey : model.projectKey,
                type : 'SAVED_MODEL',
                targetPartition : svc.computeTargetPartition(model.partitioning, buildPartitions)
            };
        },

        computeJobDefForSavedModel : function(projectKey, mode, model, buildPartitions, triggeredFrom, recipe) {
            var jd = {};
            jd.type = mode;
            jd.refreshHiveMetastore = true;
            jd.projectKey = projectKey;
            jd.outputs = [svc.computeOutputForSavedModel(model, buildPartitions)];
            if (recipe) {
                jd.recipe = recipe;
            }
            if (triggeredFrom) {
                jd.triggeredFrom = triggeredFrom;
            }
            return jd;
        },

        computeOutputForBox : function(box, buildPartitions) {
           return {
               targetDataset : box.id,
               targetDatasetProjectKey : box.projectKey,
               type : 'MANAGED_FOLDER',
               targetPartition : svc.computeTargetPartition(box.partitioning, buildPartitions)
           };
        },

        computeOutputForModelEvaluationStore : function(store, buildPartitions) {
           return {
               targetDataset : store.id,
               targetDatasetProjectKey : store.projectKey,
               type : 'MODEL_EVALUATION_STORE',
               targetPartition : svc.computeTargetPartition(store.partitioning, buildPartitions)
           };
        },


       //TODO is that deprecated?
       computeJobDefForSingleDataset: function(projectKey, mode, dataset, buildPartitions, triggeredFrom, recipe){
           var svc = this;
           var jd = {
               type: mode,
               refreshHiveMetastore: true,
               projectKey: projectKey,
               outputs: [svc.computeOutputForDataset(dataset, buildPartitions)]
           }
           if (triggeredFrom) {
               jd.triggeredFrom = triggeredFrom;
           }
           if (recipe) {
               jd.recipe = recipe;
           }
           return jd;
       },
       computeJobDefForBox : function(projectKey, mode, box, buildPartitions, triggeredFrom, recipe) {
           var jd = {};
           jd.type = mode;
           jd.refreshHiveMetastore = true;
           jd.projectKey = projectKey;
           jd.outputs = [svc.computeOutputForBox(box, buildPartitions)];
           if (recipe) {
               jd.recipe = recipe;
           }
           if (triggeredFrom) {
               jd.triggeredFrom = triggeredFrom;
           }
           return jd;
        },
       computeJobDefForModelEvaluationStore : function(projectKey, mode, store, buildPartitions, triggeredFrom, recipe) {
           var jd = {};
           jd.type = mode;
           jd.refreshHiveMetastore = true;
           jd.projectKey = projectKey;
           jd.outputs = [svc.computeOutputForModelEvaluationStore(store, buildPartitions)];
           if (recipe) {
               jd.recipe = recipe;
           }
           if (triggeredFrom) {
               jd.triggeredFrom = triggeredFrom;
           }
           return jd;
        },
        computeOutputForStreamingEndpoint : function(projectKey, streamingEndpointId) {
            return {
                targetDataset : streamingEndpointId,
                targetDatasetProjectKey : projectKey,
                type : 'STREAMING_ENDPOINT'
            };
        },

        computeJobDefForStreamingEndpoint : function(projectKey, mode, streamingEndpoint, buildPartitions, triggeredFrom, recipe) {
           var jd = {};
           jd.type = mode;
           jd.refreshHiveMetastore = true;
           jd.projectKey = projectKey;
           jd.outputs = [svc.computeOutputForStreamingEndpoint(projectKey, streamingEndpoint.id)];
           if (recipe) {
               jd.recipe = recipe;
           }
           if (triggeredFrom) {
               jd.triggeredFrom = triggeredFrom;
           }
           return jd;
        }
    }
	return svc;
});

})();
(function(){
    'use strict';

    var app = angular.module('dataiku.common.pictures', []);

    app.factory('ImageUrl', function(ProjectInitials) {
        return function(projectName, projectKey, objectId, objectType, localHash, size, color, pattern, showInitials) {
            if (objectType == 'TUTORIAL' || objectType == 'SAMPLE') {
                // the url is passed through object-id
                return '/dip/api/image/get-thumbnail?type=' + objectType + '&imageUrl=' + objectId;
            } else {
                // ensure color is correct format
                projectName = showInitials ? projectName : '';
                const initials = ProjectInitials(projectName);

                color = color ? color.replace('#', '0x') : color;
                return '/dip/api/image/get-image?size=' + encodeURIComponent(size) + 
                                                '&projectKey=' + encodeURIComponent(projectKey) + 
                                                '&type=' + encodeURIComponent(objectType) + 
                                                '&id=' + encodeURIComponent(objectId) +
                                                "&hash=" + encodeURIComponent(localHash) + 
                                                (color ? "&color=" + encodeURIComponent(color) : "")+
                                                (pattern ? "&pattern=" + encodeURIComponent(pattern) : "")+
                                                (initials ? "&initials=" + encodeURIComponent(initials) : "");
            }
        };
    });

    app.factory('UserImageUrl', function($rootScope) {
        return function(userLogin, size) {
            if (!userLogin) return "";
            size = size || 32;
            return `/dip/api/image/get-image?type=USER&id=${encodeURIComponent(userLogin)}&size=${size}x${size}&hash=${$rootScope.userPicturesHash}`;
        }
    });

    /*
        \b\w   Works with non-accented Latin characters
        (?<!\p{Alphabetic})\p{Alphabetic} Works with accented characters but requires lookbehind support, which JS lacks
        (?:^|\P{Alphabetic})\p{Alphabetic} + only take the last character but \p{UnicodeNamedCharacterClass} is not supported in Firefox
    */
    app.factory('ProjectInitials', function() {
        return function(name) {
            let initials = name || '';

            if (name) {
                let match = name.match(/\b(\w)/g);
                if (match && match.length >= 2) {
                    initials = match.join('');
                }
                initials = initials.charAt(0).toUpperCase() + initials.charAt(1);
            }

            return initials;
        }
    });

    app.directive('totem', function(CreateModalFromTemplate, ImageUrl) {
        return {
            restrict: 'E',
            scope: {
                'projectName': '=',
                'projectKey': '=',
                'projectAppType' : '=?',
                'isAppAsRecipe' : '=?',
                'objectType': '=',
                'objectId': '=',
                'editable': '=',
                'totemClass': '@',
                'size': '=',
                'sizeX' : '=',
                'sizeY' : '=',
                'insightMode' : '=',
                'objectImgHash' : '=',
                'imgColor' : '=',
                'imgPattern' : '=',
                'showInitials' : '=',
                'isProjectImg' : '=',
                'defaultImgColor' : '='
            },
            replace: true,
            template: `
                <span>
                    <img ng-src='{{ imageUrl() }}' editable='{{!!editable}}' class='totem {{totemClass}}' title='{{projectName}}'/>
                    <span ng-if="projectAppType === 'APP_TEMPLATE'" class="app-template-overlay" title="{{ (isAppAsRecipe ? 'Application-as-recipe' : 'Visual application') + ' template'}}">
                        <i class="{{isAppAsRecipe ? 'icon-dku-application-as-recipe' : 'icon-project-app'}}"></i>
                    </span>
                </span>
            `,
            link: function(scope, element, attrs) {
                scope.$watch("objectImgHash", function(nv, ov) {
                    if (nv === null || nv === undefined || nv === 0) {
                        scope.localHash = (Math.random() * 10000) | 0;
                    } else {
                        scope.localHash = nv;
                    }
                })

                scope.imageUrl = function() {
                    if (scope.sizeX) {
                        return ImageUrl(scope.projectName, scope.projectKey, scope.objectId, scope.objectType, scope.localHash, scope.sizeX + 'x' + scope.sizeY, scope.imgColor, scope.imgPattern, scope.showInitials);
                    } else {
                        return ImageUrl(scope.projectName, scope.projectKey, scope.objectId, scope.objectType, scope.localHash, scope.size ? (scope.size + 'x' + scope.size) : '', scope.imgColor, scope.imgPattern, scope.showInitials);
                    }
                }

                scope.forceRefreshImage = function() {
                    scope.localHash = (Math.random() * 10000) | 0;
                    scope.objectImgHash = scope.localHash;
                }

                scope.openUploadPictureDialog = function() {
                    CreateModalFromTemplate(
                        "/templates/widgets/image-uploader-dialog.html",
                        scope,
                        null,
                        function(newScope) {},
                        "image-uploader-dialog")
                        .then(function(id) { scope.objectId = id; });
                }

                if (scope.editable === true) {
                    element.on('click', function(e) {
                        scope.openUploadPictureDialog();
                    });
                }

            }
        }
    });

    app.directive('cropedProjectPicture', function(ImageUrl) {
        return {
            restrict: 'E',
            scope: {
                'projectName': '=',
                'projectKey': '=',
                'objectType': '=',
                'imgColor' : '=',
                'imgPattern' : '=',
                'showInitials' : '=',
                'objectId': '=',
                'sizeX': '=',
                'sizeY': '=',
                'objectImgHash' : '=',
            },
            replace: true,
            template: "<div style='background-image:url(\"{{ imageUrl() }}\")' class='croped-project-picture'/>",
            link: function(scope, element, attrs) {
                scope.$watch("objectImgHash", function(nv, ov) {
                    if (nv === null || nv === undefined || nv === 0) {
                        scope.localHash = (Math.random() * 10000) | 0;
                    } else {
                        scope.localHash = nv;
                    }
                })

                scope.imageUrl = function() {                 
                	return ImageUrl(scope.projectName, scope.projectKey, scope.objectId, scope.objectType, scope.localHash, scope.sizeX + 'x' + scope.sizeY, scope.imgColor, scope.imgPattern, scope.showInitials);
                }
            }
        }
    });

    app.directive('imageUploader', function(DataikuAPI, $rootScope, Notification, SpinnerService, ProjectInitials) {
        // only designed to appear in a image upload dialog.
        // no independant scope here.
        return {
            restrict: 'E',
            scope: false,
            replace: true,
            templateUrl: '/templates/widgets/image-uploader.html',
            link: function(scope, element, attrs) {
                /* DOCUMENTATION: one might come across the following variables many times, here is a definition of what they rely to:
                 *   scope.originalW/H  = uploaded image width/height
                 *   scope.W/H = size of displayed image in dropzone, adjusted to image aspect ratio (hence wide images=> shorter H)
                 *   scope.box.width/height/top/left = defines selection rect using same co-ords system as scope.W etc
                 *   TARGET_SIZE.width/height = size of preview area.  SLICE and STRETCH always drawn into preview at 0,0
                 *   TARGET_SIZE sizes NOT DEFINED when simple crop and upload as per dashboard images!
                 *   scale = scaling of original image to fit drop zone. BEWARE This is actually the recipical - ie multiply box.w/h by scale to get original image sizing
                 */

                scope.empty = true;
                var imgUploadPaneEl = element.find("#image-upload-pane");
                var dropZone = element.find("div.original");
                var selectionEl = element.find("div.selection");
                var imageOptionsEl = element.find("div.image-options");
                var dragging = null;

                var previewEl = element.find("canvas.preview");
                var previewImageEl = element.find("div.preview-image");
                var previewFrameEl = element.find("div.preview-frame");

                var TARGET_SIZE = {
                    width: 0,
                    height: 0
                }

                const PATTERNS = 8;

                scope.uiState = {
                    resizeMode : "SLICE",
                    lastResizeMode: "SLICE",
                    imgColor : scope.imgColor ? scope.imgColor : scope.defaultImgColor,
                    imgPattern : scope.imgPattern ? scope.imgPattern : 1,
                    isProjectImg: scope.isProjectImg,
                    isAppImg: scope.isAppImg,
                    isUseColor: !!scope.imgColor || !(scope.isProjectImg || scope.isAppImg),
                    showInitials: scope.showInitials
                }

                scope.stockColors = ["#e13d3c", "#8c2da7", "#31439c", "#1789ce", "#0f786b", "#699e3f", "#f9be40", "#f27c22", "#e44b27", "#465a64" ];

                scope.showColorPicker = false;
                scope.showResizeModes = true;

                switch (scope.objectType) {
                case "USER":
                    TARGET_SIZE.width= 166;
                    TARGET_SIZE.height = 166;
                    scope.uiState.forcedRatio = 1;
                    break;
                case "PROJECT":
                case "PUBLISHED_PROJECT":
                    TARGET_SIZE.width= 80;
                    TARGET_SIZE.height = 200;
                    scope.uiState.forcedRatio = 2.5;
                    scope.showColorPicker = true;
                    break;
                case "APP":
                    TARGET_SIZE.width= 140;
                    TARGET_SIZE.height = 120;
                    scope.uiState.forcedRatio = 0.85714286;
                    scope.showColorPicker = true;
                    break;
                case "INSIGHT":
                    TARGET_SIZE.width = 310;
                    TARGET_SIZE.height= 166;
                    scope.uiState.forcedRatio = 1 / (1.6180339887); // let's be precise !
                    break;
                default:
                    scope.uiState.resizeMode = "CROP";
                    scope.uiState.noPreview = true;
                    scope.showResizeModes = false;
                    TARGET_SIZE.none = true;
                    break;
                }

                var targetAdjustedSize; // adjusted target drawing coords for scaling / best-fit options.

                var resetTargetAdjustment = function() {
                    targetAdjustedSize = {
                        width:TARGET_SIZE.width,
                        height: TARGET_SIZE.height,
                        x: 0,
                        y: 0
                    };
                }

                var isAdjustTarget = function() {
                    var mode = scope.uiState.resizeMode
                    return (mode=="SCALE" || mode=="FILL")
                }

                resetTargetAdjustment();

                var resetBox = function(force) {
                    resetTargetAdjustment();
                    if (!scope.W) return;
                    scope.box = scope.box || {left:0, top:0, width:0, height:0 };

                    if (scope.uiState.resizeMode === "SLICE") {
                        var f = Math.min(scope.W/80, scope.H/80/scope.uiState.forcedRatio, 1);
                        scope.box.width = 80 * f;
                        scope.box.height = 80 * f * scope.uiState.forcedRatio;
                        scope.box.left = scope.box.left ? Math.min(scope.box.left, scope.W - scope.box.width) : 0;
                        scope.box.top = scope.box.top ? Math.min(scope.box.left, scope.H - scope.box.height) : 0;

                    } else if (force || scope.uiState.lastResizeMode === "SLICE") {
                        scope.box.top = 0;
                        scope.box.left = 0;
                        scope.box.width = scope.W;
                        scope.box.height = scope.H;
                    }

                    scope.uiState.lastResizeMode = scope.uiState.resizeMode;
                    scope.setSelection(scope.box);
                };

                scope.$watch("uiState.resizeMode", _ => resetBox(false));
                scope.$watch("uiState.isUseColor", function () {
                    if (scope.uiState.isUseColor) scope.clearImageForUpload();});
                scope.$watch("uiState.showInitials", _ => {
                    let initials = scope.uiState.showInitials ? scope.projectName : '';

                    scope.initials = ProjectInitials(initials);
                });

                previewEl.attr(TARGET_SIZE);
                previewImageEl.css(TARGET_SIZE);
                previewFrameEl.css({"height": TARGET_SIZE.height, "width": scope.objectType=="PROJECT" || scope.objectType=="APP" ? "auto" : TARGET_SIZE.width});

                var previewCtx = previewEl[0].getContext('2d');
                previewCtx.imageSmoothingEnabled = true;
                previewCtx.mozImageSmoothingEnabled = true;
                previewCtx.oImageSmoothingEnabled = true;
                previewCtx.webkitImageSmoothingEnabled = true;

                scope.averagePixel = {r:0, g:0, b:0};

                scope.uploadFileDialog = function() {
                    var uploadFile = $('<input type="file" id="fileUpload" accept="image/*" />');
                    uploadFile.on("change", function() {
                        if (uploadFile[0].files.length > 0) {
                            scope.setImageFile(uploadFile[0].files[0]);
                        }
                    });
                    uploadFile.click();
                };

                var saveProjectStateChanges = function () {
                    scope.$emit('projectImgEdited', scope.uiState);
                };

                scope.uploadImage = function() {
                    var canvas = document.createElement("canvas");

                    var scaleBox = isAdjustTarget() ? TARGET_SIZE : scope.box;

                    var originalW = (scaleBox.width * scale) | 0;
                    var originalH = (scaleBox.height * scale) | 0;

                    canvas.width =  originalW;
                    canvas.height = originalH;
                    var canvasCtx = canvas.getContext('2d');

                    scope.uiState.imgColor = undefined;
                    scope.uiState.showInitials = false;
                    scope.uiState.isProjectImg = true;
                    scope.uiState.isAppImg = false;

                    saveProjectStateChanges();

                    canvasCtx.drawImage(scope.image, (scope.box.left * scale) | 0, (scope.box.top * scale) | 0, (scope.box.width * scale) | 0, (scope.box.height * scale) | 0, //0, 0, originalW, originalH);
                        targetAdjustedSize.x * scale,
                        targetAdjustedSize.y * scale,
                        originalW * targetAdjustedScaleFactorForUpload("width"), //(targetAdjustedSize.width  / TARGET_SIZE.width),
                        originalH * targetAdjustedScaleFactorForUpload("height")); //(targetAdjustedSize.height / TARGET_SIZE.height));


                    var data = canvas.toDataURL("image/png");
                    SpinnerService.lockOnPromise(DataikuAPI.images.uploadImage(scope.projectKey, scope.objectType, scope.objectId, data)
                    .then(function(data) {
                        const id = JSON.parse(data).id;
                        scope.resolveModal(id);
                        if (scope.objectType == "USER") {
                            Notification.broadcastToFrontends("user-profile-picture-updated");
                        }
                        $rootScope.$broadcast("currentItemImageUpdated");
                        if (scope.forceRefreshImage) scope.forceRefreshImage();
                    }));
                };

                scope.removeImage = function() {
                    DataikuAPI.images.removeImage(scope.projectKey, scope.objectType, scope.objectId).then(function() {
                        if (scope.objectType == "USER") {
                            Notification.broadcastToFrontends("user-profile-picture-updated");
                        }
                        $rootScope.$broadcast("currentItemImageUpdated");
                        if (scope.forceRefreshImage) scope.forceRefreshImage();
                        scope.uiState.isProjectImg = false;
                        saveProjectStateChanges();
                    });
                };

                scope.onClickImage = function() {
                    if (scope.empty) {
                        scope.uploadFileDialog();
                    }
                };

                scope.onClickColor = function() {
                    scope.uiState.isUseColor = true;
                };

                scope.shufflePattern = function() {
                    scope.uiState.isUseColor = true;
                    scope.uiState.imgPattern = scope.uiState.imgPattern % PATTERNS + 1 || 1;
                };

                scope.processProjectChanges = function () {
                    var ui = scope.uiState;
                    if (ui.imgColor != scope.imgColor || ui.isProjectImg != scope.isProjectImg || ui.imgPattern != scope.imgPattern || ui.showInitials != scope.showInitials) {
                        saveProjectStateChanges();
                        scope.removeImage();
                    }
                };

                scope.clearSolidColor = function() {
                    scope.uiState.imgColor = undefined;
                };

                scope.saveColor = function() {
                    scope.processProjectChanges();
                    scope.dismiss();
                };

                scope.pickStockColor = function(color) {
                    scope.uiState.imgColor = color;
                    scope.uiState.isUseColor = true;
                };

                scope.previewBackgroundColor = function() {
                    return scope.uiState.isUseColor ? scope.uiState.imgColor : '#FFFFFF';
                };

                scope.close = function() {
                    scope.dismiss();
                };

                scope.paintImage = function() {
                    if (!scope.image) return;
                    var originalW = (scope.box.width * scale) | 0;
                    var originalH = (scope.box.height * scale) | 0;
                    previewCtx.fillStyle = "#FFFFFF";
                    previewCtx.fillRect(0,0,TARGET_SIZE.width,TARGET_SIZE.height)
                    previewCtx.drawImage(scope.image,
                        Math.max((scope.box.left * scale) | 0, 0),
                        Math.max((scope.box.top * scale) | 0, 0),
                        originalW, originalH,
                        targetAdjustedSize.x,
                        targetAdjustedSize.y,
                        targetAdjustedSize.width,
                        targetAdjustedSize.height);
                    safeApply(scope);
                };

                var scale;

                scope.setImageFile = function(file) {
                    scope.empty = false;
                    scope.uiState.isUseColor = false;
                    element.removeClass("empty")
                    dropZone.removeClass('empty');
                    var reader = new FileReader();
                    reader.onload = function(event) {
                        scope.image = new Image();
                        scope.image.src = event.target.result;
                        scope.image.onload = function() {
                            scope.originalW = scope.image.width;
                            scope.originalH = scope.image.height;
                            var maxW = dropZone.width();
                            var maxH = dropZone.height() - imageOptionsEl.height();
                            scale = Math.max(scope.originalW / maxW, scope.originalH / maxH);
                            scope.W = scope.originalW / scale;
                            scope.H = scope.originalH / scale;
                            resetBox();
                            element.find("div.original").css("flex-grow", 0).css("height", scope.H).css( "background-image", "url(" + event.target.result + ")");
                            scope.setSelection(scope.box);
                        }
                    };
                    reader.readAsDataURL(file);
                };

                scope.clearImageForUpload = function(file) {
                    resetBox(true);
                    scope.empty = true;
                    element.addClass("empty")
                    dropZone.addClass('empty');
                    scope.image = undefined;
                    element.find("div.original").css("background-image", "").css("flex-grow", 1).css("height", undefined);
                };

                scope.W = 0;
                scope.H = 0;

                var adjustTarget = function () {

                    if (isAdjustTarget()) {
                            resetTargetAdjustment();

                            var boxAspectRatio = scope.box.width / scope.box.height;
                            var targetAspectRatio = TARGET_SIZE.width / TARGET_SIZE.height;

                            var isFitToWidth =  scope.uiState.resizeMode=="FILL" ? boxAspectRatio < targetAspectRatio : boxAspectRatio > targetAspectRatio;

                            if (isFitToWidth) {
                                targetAdjustedSize.height = TARGET_SIZE.width / boxAspectRatio;
                                targetAdjustedSize.y = (TARGET_SIZE.height - targetAdjustedSize.height) / 2;
                            } else {
                                targetAdjustedSize.width = TARGET_SIZE.height * boxAspectRatio;
                                targetAdjustedSize.x = (TARGET_SIZE.width - targetAdjustedSize.width) / 2;
                            }
                    }
                };

                var targetAdjustedScaleFactorForUpload = function(dim) {
                    return  TARGET_SIZE.none ? 1 : (targetAdjustedSize[dim]  / TARGET_SIZE[dim]);
                };

                function isMostlyToTheLeft() {
                    let leftPart = Math.max(0, scope.W/2 - scope.box.left);
                    let rightPart = Math.max(0, scope.box.left + scope.box.width - scope.W/2);
                    return leftPart > rightPart;
                };

                function isMostlyToTheTop() {
                    let topPart = Math.max(0, scope.H/2 - scope.box.top);
                    let bottomtPart = Math.max(0, scope.box.top + scope.box.height - scope.H/2);
                    return topPart > bottomtPart;
                };

                function getStaticCorner(cornerType) {
                    let getAmbiguousHorizontal = function() {
                        let h = 'l';
                        let isFullWidth = scope.box.left==0 && scope.box.width == scope.W;
                        if (isFullWidth) {
                            if (dragging && dragging.originalStaticCorner) {
                                h = dragging.originalStaticCorner[1];
                            }
                        } else {
                            h = isMostlyToTheLeft() ? 'l':'r'
                        }
                        return h;
                    };

                    let getAmbiguousVertical = function() {
                        let v = 't';
                        let isFullHeight = scope.box.top == 0 && scope.box.height == scope.H;
                        if (isFullHeight) {
                            if (dragging && dragging.originalStaticCorner) {
                                v = dragging.originalStaticCorner[0];
                            }
                        } else {
                            v = isMostlyToTheTop() ? 't':'b'
                        }
                        return v;
                    };

                    switch(cornerType) {
                        case 'tt':
                            return 'b' + getAmbiguousHorizontal();
                            break;
                        case 'tr':
                            return 'bl';
                            break;
                        case 'rr':
                            return getAmbiguousVertical() + 'l';
                            break;
                        case 'br':
                            return 'tl';
                            break;
                        case 'bb':
                            return 't' + getAmbiguousHorizontal();
                            break;
                        case 'bl':
                            return 'tr';
                            break;
                        case 'll':
                            return getAmbiguousVertical() + 'r';
                            break;
                        case 'tl':
                            return 'br';
                            break;
                        default:
                            break;
                    }
                };

                scope.setSelection = function(box, dragging) {
                    if (dragging && dragging.type=="move") {
                        $.extend(scope.box, box);
                        scope.box.left = Math.min(scope.W - scope.box.width, scope.box.left);
                        scope.box.left = Math.max(0, scope.box.left);

                        scope.box.top = Math.min(scope.H - scope.box.height, scope.box.top);
                        scope.box.top = Math.max(0, scope.box.top);
                    } else if (scope.uiState.resizeMode!=="SLICE") {
                        $.extend(scope.box, box);
                        let maxHeight = scope.H - scope.box.top;
                        let maxWidth = scope.W - scope.box.left;

                        scope.box.width = Math.min(maxWidth, scope.box.width);
                        scope.box.width = Math.max(16, scope.box.width);

                        scope.box.height = Math.min(maxHeight, scope.box.height);
                        scope.box.height = Math.max(16, scope.box.height);

                        if (scope.box.top < 0) {
                            scope.box.height += scope.box.top;
                            scope.box.top = 0;
                        }
                        if (scope.box.left < 0) {
                            scope.box.width += scope.box.left;
                            scope.box.left = 0;
                        }

                        scope.box.width = scope.box.width | 0;
                        scope.box.height = scope.box.height | 0;
                        scope.box.left = scope.box.left | 0;
                        scope.box.top = scope.box.top | 0;
                    } else {
                        let isValidPosition = function(box, newPosition) {
                            return newPosition.top >= 0 && (Math.floor(newPosition.top + box.height) < (scope.H + 1)) && newPosition.left >= 0 && (Math.floor(newPosition.left + box.width) < (scope.W + 1));
                        };
                        let computeNewPosition = function(box, staticCorner) {
                            let newPosition = {top: scope.box.top, left: scope.box.left};
                            if (staticCorner[0] == 'b') {
                                newPosition.top += scope.box.height - box.height;
                            }
                            if (staticCorner[1] == 'r') {
                                newPosition.left += scope.box.width - box.width;
                            }
                            return newPosition;
                        };
                        let computeMaxDimensions = function(staticCorner) {
                            let maxHeightNoRatio = staticCorner[0] == 't' ? scope.H - scope.box.top : scope.box.top + scope.box.height;
                            let maxWidthNoRatio = staticCorner[1] == 'l' ? scope.W - scope.box.left : scope.box.left + scope.box.width;
                            let maxHeight = scope.uiState.forcedRatio * maxWidthNoRatio;
                            let maxWidth = maxWidthNoRatio;
                            if (maxHeight > maxHeightNoRatio) {
                                maxHeight = maxHeightNoRatio;
                                maxWidth = maxHeightNoRatio / scope.uiState.forcedRatio;
                            }
                            return {maxHeight: maxHeight, maxWidth: maxWidth};
                        };
                        let adjustDimensions = function(cornerType, staticCorner) {
                            let maxDimensions = computeMaxDimensions(staticCorner);
                            box.width = Math.max(16, box.width);
                            box.height = Math.max(16, box.height);
                            if (box.height != box.width * scope.uiState.forcedRatio) {
                                if (['bb', 'tt'].includes(cornerType)) {
                                    box.width = Math.min(maxDimensions.maxWidth, box.height / scope.uiState.forcedRatio);
                                    box.height = box.width * scope.uiState.forcedRatio;
                                } else {
                                    box.height = Math.min(maxDimensions.maxHeight, box.width * scope.uiState.forcedRatio);
                                    box.width = box.height / scope.uiState.forcedRatio;
                                }
                            }
                        };

                        if (dragging) {
                            let staticCorner = getStaticCorner(dragging.cornerType);
                            adjustDimensions(dragging.cornerType, staticCorner);
                            let newPosition = computeNewPosition(box, staticCorner);
                            if (isValidPosition(box, newPosition)) {
                                scope.box.height = box.height;
                                scope.box.width = box.width;
                                scope.box.top = newPosition.top;
                                scope.box.left = newPosition.left;
                            }
                        }
                    }

                    adjustTarget()
                    scope.paintImage();
                    selectionEl.css(scope.box);
                };

                scope.startResizing = function(evt, cornerType) {
                    let originalStaticCorner = getStaticCorner(cornerType);
                    dragging = {
                        type: "resize",
                        cornerType: cornerType,
                        leftOrigin: scope.box.left + (cornerType[1] == "l" ?  -evt.pageX : 0),
                        topOrigin: scope.box.top + (cornerType[0] == "t" ?  -evt.pageY : 0),
                        widthOrigin: selectionEl.width() + (cornerType[1] == "l" ?  1 : -1) * evt.pageX,
                        heightOrigin: selectionEl.height() + (cornerType[0] == "t" ?  1 : -1) * evt.pageY,
                        originalStaticCorner: originalStaticCorner
                    }
                    $('body').on("mousemove", resize);
                    $('body').on("mouseup", function() {
                        $('body').off("mousemove", resize);
                        dragging = null;
                    });
                    evt.stopPropagation();
                    return false;
                }

                function resize(evt) {
                    var box = {};

                    if (dragging.cornerType[0]=="t") {
                        box.top = dragging.topOrigin + evt.pageY;
                        box.height = dragging.heightOrigin - evt.pageY;
                    } else if (dragging.cornerType[0]=="b") {
                        box.height = dragging.heightOrigin + evt.pageY;
                    } else {
                        box.height = scope.box.height;
                    }

                    if (dragging.cornerType[1]=="l") {
                        box.left = dragging.leftOrigin + evt.pageX;
                        box.width = dragging.widthOrigin - evt.pageX;
                    } else if (dragging.cornerType[1]=="r") {
                        box.width = dragging.widthOrigin + evt.pageX;
                    } else {
                        box.width = scope.box.width;
                    }

                    scope.setSelection(box, dragging);
                };

                scope.startMoving = function(evt) {
                    dragging = {
                        type: "move",
                        originLeft: scope.box.left - evt.pageX,
                        originTop: scope.box.top - evt.pageY
                    };
                    $('body').on("mousemove", move);
                    $('body').on("mouseup", function() {
                        $('body').off("mousemove", move);
                        dragging = null;
                    });
                    evt.stopPropagation();
                    return false;
                }

                function move(evt) {
                    scope.setSelection({
                        left: evt.pageX + dragging.originLeft,
                        top: evt.pageY + dragging.originTop
                    }, dragging);
                }

                // selectionEl
                dropZone.parent().on("dragenter", function(e) {
                    dropZone.addClass('hover');
                    e.preventDefault();
                    e.stopPropagation();
                    dropZone.addClass('hover');
                    return false;
                });
                dropZone.parent().on("dragover", function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                });
                dropZone.parent().on("dragleave", function(e) {
                    dropZone.removeClass('hover');
                    return false;
                });
                dropZone.parent().on("drop", function(e) {
                    e.preventDefault();
                    var file = e.originalEvent.dataTransfer.files[0];
                    scope.setImageFile(file);
                    return false;
                });
            }
        }

    });

})();

(function(){
'use strict';

/**
 * Services related to sampling
 */

var app = angular.module('dataiku.common.sampling', []);

app.service("SamplingData", function(){
	var svc = {

		memSamplingMethods : [
	        ["HEAD_SEQUENTIAL", "First records"],
	        ["RANDOM_FIXED_NB_EXACT", "Random (nb. records)"],
	        ["RANDOM_FIXED_RATIO", "Random (approx. ratio)"],
	        /*["RANDOM_FIXED_RATIO_EXACT", "Random (target ratio of data)"],*/
	        ["COLUMN_BASED", "Column values subset (approx. nb. records)"],
	        ["STRATIFIED_TARGET_NB_EXACT", "Stratified (nb. records)"],
	        ["STRATIFIED_TARGET_RATIO_EXACT", "Stratified (ratio)"],
			["RANDOM_FIXED_NB", "Random (approx. nb. records)"],
	        ["CLASS_REBALANCE_TARGET_NB_APPROX", "Class rebalance (approx. nb. records)"],
	        ["CLASS_REBALANCE_TARGET_RATIO_APPROX", "Class rebalance (approx. ratio)"],
	        ["TAIL_SEQUENTIAL", "Last records"]
	    ],

	    memSamplingMethodsDesc : [
	        "Takes the first N rows of the dataset. Very fast (only reads N rows) but may result in a very biased view of the dataset.",
	        "Randomly selects N rows. Requires a full pass reading the data.",
	        "Randomly selects approximately X% of the rows. Requires a full pass reading the data.",
	       /* "Randomly selects X% of the rows. Requires 2 full passes reading the data.",*/
	        "Randomly selects a subset of values and chooses all rows with these values, in order to obtain approximately N rows. This is useful for selecting a subset of customers, for example. Requires 2 full passes.",
	        "Randomly selects N rows, ensuring that the repartition of values in a column is respected in the sampling. Ensures that all modalities of the column appear in the output. May return a few more than N rows. Requires 2 full passes reading the data.",
	        "Randomly selects X% of the rows, ensuring that the repartition of values in a column is respected in the sampling. Ensures that all modalities of the column appear in the output. May return a bit more than X% rows. Requires 2 full passes reading the data.",
	        "Randomly selects approximately N rows. Requires 2 full passes reading the data. ",
	        "Randomly selects approximately N rows, trying to rebalance equally all modalities of a column. Does not oversample, only undersample (so some rare modalities may remain under-represented). Rebalancing is not exact. Requires 2 full passes.",
	        "Randomly selects approximately X% of the rows, trying to rebalance equally all modalities of a column. Does not oversample, only undersample  (so some rare modalities may remain under-represented). Rebalancing is not exact. Requires 2 full passes.",
	        "Takes the last N rows of the dataset. Requires a full pass."
	    ],

	    streamSamplingMethods : [
	    	["FULL", "No sampling (whole data)"],
            ["HEAD_SEQUENTIAL", "First records"],
	        ["RANDOM_FIXED_RATIO", "Random (approx. ratio)"],
	        ["RANDOM_FIXED_NB", "Random (approx. nb. records)"],
	        ["COLUMN_BASED", "Column values subset (approx. nb. records)"],
	        ["CLASS_REBALANCE_TARGET_NB_APPROX", "Class rebalance (approx. nb. records)"],
	        ["CLASS_REBALANCE_TARGET_RATIO_APPROX", "Class rebalance (approx. ratio)"],
	    ],

	    streamSamplingMethodsDesc : [
	    	"Takes the whole data",
        	"Takes the first N rows of the dataset. Very fast (only reads N rows) but may result in a very biased view of the dataset.",
        	"Randomly selects approximately X% of the rows. Requires a full pass reading the data.",
        	"Randomly selects approximately N rows. Requires 2 full passes.",
	        "Randomly selects a subset of values and chooses all rows with these values, in order to obtain approximately N rows. This is useful for selecting a subset of customers, for example. Requires 2 full passes.",
	        "Randomly selects approximately N rows, trying to rebalance equally all modalities of a column. Does not oversample, only undersample (so some rare modalities may remain under-represented). Rebalancing is not exact. Requires 2 full passes.",
	        "Randomly selects approximately X% of the rows, trying to rebalance equally all modalities of a column. Does not oversample, only undersample  (so some rare modalities may remain under-represented). Rebalancing is not exact. Requires 2 full passes."
	    ],

	    partitionSelectionMethods : [
	        ["ALL", "All partitions"],
    	    ["SELECTED", "Select partitions"],
    	    ["LATEST_N", "Latest partitions"]
    	],

    	partitionSelectionMethodsDesc : [
    		"Use all partitions of the dataset",
    		"Use an explicitly selected list of partitions",
    		"Use the 'latest' partitions currently available in the dataset. This option is only defined for single-dimension time-based partitioning. This method is slower because the list of partitions needs to be recomputed often."
    	],

    	needsColumn : function(method) {
    		return [
    			"STRATIFIED_TARGET_NB_EXACT", "STRATIFIED_TARGET_RATIO_EXACT",
    			"CLASS_REBALANCE_TARGET_NB_APPROX", "CLASS_REBALANCE_TARGET_RATIO_APPROX",
    			"COLUMN_BASED"].indexOf(method) >= 0;
    	},

    	needsRatio : function(method) {
    		return [
    			"RANDOM_FIXED_RATIO",
    			"RANDOM_FIXED_RATIO_EXACT",
    			"STRATIFIED_TARGET_RATIO_EXACT",
    			"CLASS_REBALANCE_TARGET_RATIO_APPROX",
    			].indexOf(method) >= 0;
    	},

    	needsMaxRecords : function(method) {
    		return [
    			"HEAD_SEQUENTIAL",
    			"TAIL_SEQUENTIAL",
    			"RANDOM_FIXED_NB",
    			"RANDOM_FIXED_NB_EXACT",
    			"STRATIFIED_TARGET_NB_EXACT",
    			"CLASS_REBALANCE_TARGET_NB_APPROX",
    			"COLUMN_BASED"].indexOf(method) >= 0;
    	},

    	// Warning: must be kept in sync with Java code in PivotTablesService
    	makeStreamableFromMem : function(memSelection) {
    		var ret = angular.copy(memSelection);
            if (ret.samplingMethod == "RANDOM_FIXED_NB_EXACT") {
                ret.samplingMethod = "RANDOM_FIXED_NB";
            } else if (ret.samplingMethod == "STRATIFIED_TARGET_NB_EXACT") {
                ret.samplingMethod = "RANDOM_FIXED_NB";
            } else if (ret.samplingMethod == "STRATIFIED_TARGET_RATIO_EXACT") {
                ret.samplingMethod = "RANDOM_FIXED_RATIO";
            } else if (ret.samplingMethod == "TAIL_SEQUENTIAL") {
            	ret.samplingMethod = "HEAD_SEQUENTIAL";
            }
            return ret;
    	},

        getSamplingMethodForDocumentation: function (samplingMethod, mlTaskDesign) {
            let samplingMethodDoc = 'No sampling (whole data)';

            switch (samplingMethod) {
                case 'HEAD_SEQUENTIAL':
                    samplingMethodDoc = `First ${mlTaskDesign.splitParams.ssdSelection.maxRecords || 0} records`;
                break;
                case 'RANDOM_FIXED_NB_EXACT':
                    samplingMethodDoc = `Random (${mlTaskDesign.splitParams.ssdSelection.maxRecords || 0} records)`;
                break;
                case 'RANDOM_FIXED_RATIO':
                    samplingMethodDoc = `Random (approximately ${Math.round(mlTaskDesign.splitParams.ssdSelection.targetRatio * 100) || 0}%)`;
                break;
                case 'COLUMN_BASED':
                    samplingMethodDoc = `Column values subset (approximately ${mlTaskDesign.splitParams.ssdSelection.maxRecords || 0} records)`;
                break;
                case 'STRATIFIED_TARGET_NB_EXACT':
                    samplingMethodDoc = `Stratified (${mlTaskDesign.splitParams.ssdSelection.maxRecords || 0} records)`;
                break;
                case 'STRATIFIED_TARGET_RATIO_EXACT':
                    samplingMethodDoc = `Stratified (${Math.round(mlTaskDesign.splitParams.ssdSelection.targetRatio * 100) || 0}%)`;
                break;
                case 'RANDOM_FIXED_NB':
                    samplingMethodDoc = `Random (approximately ${mlTaskDesign.splitParams.ssdSelection.maxRecords || 0} records)`;
                break;
                case 'CLASS_REBALANCE_TARGET_NB_APPROX':
                    samplingMethodDoc = `Class rebalance (approximately ${mlTaskDesign.splitParams.ssdSelection.maxRecords || 0} records)`;
                    break;
                case 'CLASS_REBALANCE_TARGET_RATIO_APPROX':
                    samplingMethodDoc = `Class rebalance (approximately ${Math.round(mlTaskDesign.splitParams.ssdSelection.targetRatio * 100) || 0}%)`;
                break;
                case 'TAIL_SEQUENTIAL':
                    samplingMethodDoc = `Last ${mlTaskDesign.splitParams.ssdSelection.maxRecords || 0} records`;
                    break;
            }

            return samplingMethodDoc;
        }
    }

	return svc;
})

app.directive("datasetSelectionSamplingDetailsFields", function(SamplingData){
	return {
		templateUrl : "/templates/widgets/dataset-selection-sampling-details-fields.html",
		scope : {
			selection : '=',
		},
		link : function($scope) {
			$scope.SamplingData = SamplingData;
		}
	}
})

app.directive("datasetSelectionSorting", function(SamplingData){
	return {
		templateUrl : "/templates/widgets/dataset-selection-sampling-details-fields.html",
		scope : {
			selection : '=',
		},
		link : function($scope) {
			$scope.SamplingData = SamplingData;
		}
	}
})

app.directive("datasetSelectionSamplingDetailsControlgroups", function(SamplingData){
	return {
		templateUrl : "/templates/widgets/dataset-selection-sampling-details-controlgroups.html",
		scope : {
			selection : '=',
		},
		link : function($scope) {
			$scope.SamplingData = SamplingData;
		}
	}
})


app.directive("datasetSelectionOrderingFields", function(){
	return {
		templateUrl : "/templates/widgets/dataset-selection-ordering-fields.html",
		scope : {
			selection : '=',
			datasetSupportsReadOrdering: '=',
			shakerState : '='
		},
		link : function($scope) {
		}
	}
})


app.directive("datasetSelectionPartitionsSelectionFields", function(SamplingData){
	return {
		templateUrl : "/templates/widgets/dataset-selection-partitions-selection-fields.html",
		scope : {
			selection : '=',
			partitioned : '=',
			getPartitionsList: '=',
		},
		link : function($scope) {
			$scope.SamplingData = SamplingData;

			$scope.loadPartitionsList = function(){
				$scope.getPartitionsList().then(function(data){
					$scope.partitionsList = data.sort(function(a,b){
						if ($.isNumeric(a) && $.isNumeric(b)) {return b - a}
						else {return a === b ? 0 : (a < b ? 1 : -1)}
					});
				})
			}
		}
	}
})
app.directive("datasetSelectionPartitionsSelectionControlgroups", function(SamplingData, $timeout){
	return {
		templateUrl : "/templates/widgets/dataset-selection-partitions-selection-controlgroups.html",
		scope : {
            selection: '=',
            partitioned: '=',
            getPartitionsList: '=',
        },
		link : function($scope) {
			$scope.SamplingData = SamplingData;
            $scope.$on('datasetChange', function () {
                $scope.partitionsList = null;
            });
			$scope.loadPartitionsList = function(){
                $scope.getPartitionsList().then(function (data) {
                    $scope.partitionsList = data.sort(function (a, b) {
                        if ($.isNumeric(a) && $.isNumeric(b)) {
                            return b - a
                        }
                        else {
                            return a === b ? 0 : (a < b ? 1 : -1)
                        }
                    });
                });
			}
		}
	}
})
})();

(function() {
'use strict';

const app = angular.module('dataiku.services');

// To simplify the migration to ng1.6 which removes the .success and .error from $http
// we monkeypatch $http in this module with replacement versions of the missing functions
// Cqll addSuccessErrorToPromise to directly add these methods to any promise.
//
app.run (function initMonkeyPatchPromiseWithSuccessError($http) {
    app.addSuccessErrorToPromise = function (promise) {
        promise.success = function(callback) {
            promise.then( (resp) => {return callback(resp.data, resp.status, resp.headers, resp.config, resp.statusText, resp.xhrStatus)});
            return promise;
        };

        promise.error = function(callback) {
            promise.then(null, resp => callback(resp.data, resp.status, resp.headers, resp.config, resp.statusText, resp.xhrStatus));
            return promise;
        };
        return promise;
    }

    function monkeyPatchHttpGetForSuccessError() {
        const get = $http.get;
        $http.get = function () {
            let promise =  get.apply(this, arguments);
            const decoratedPromise =  app.addSuccessErrorToPromise(promise);
            return decoratedPromise;
        }
    }
    monkeyPatchHttpGetForSuccessError();
});

app.factory("DataikuCloudAPI", function(APIXHRService, $q, $rootScope) {
return {
    getWebConfig: function() {
        var deferred = $q.defer();
        $.ajax({
            url: "https://tracker.dataiku.com/public/globalId",
            jsonp: "fun",
            dataType: "jsonp",
            success: function(response) {
                deferred.resolve(response)
            }
        })
        return deferred.promise;
    },
    getNewWebConfig: function() {
        var deferred = $q.defer();
        $.ajax({
            url: "https://www.dataiku.com/api/get-config.php",
            jsonp: "callback",
            dataType: "jsonp",
            success: function(response) {
                deferred.resolve(response)
            }
        })
        return deferred.promise;
    },
    community: {
        register: function(firstName, lastName, company, persona, email,
                                     newsletter, wantEETrial, dssVersion, webVisitorId, webVisitorLocalId, webVisitorHSId, registrationChannel) {
            return APIXHRService("POST",
                $rootScope.appConfig.saasManagerURL + "/community/register-v5", {
                    firstName: firstName,
                    lastName: lastName,
                    company: company,
                    email: email,
                    persona: persona,
                    newsletter: newsletter,
                    wantEETrial: wantEETrial,
                    dssVersion: dssVersion,
                    webVisitorId: webVisitorId,
                    webVisitorLocalId: webVisitorLocalId,
                    webVisitorHSId: webVisitorHSId,
                    registrationChannel: registrationChannel
                }
            );
        },
        requestEETrial: function(instanceId, updatedEmailAddress) {
            return APIXHRService("POST",
                $rootScope.appConfig.saasManagerURL + "/community/request-ee-trial", {
                    instanceId: instanceId, updatedEmailAddress: updatedEmailAddress
                }
            );
        }
    }
}
});


app.factory("DataikuAPI", ["APIXHRService", '$q', '$rootScope', 'Logger', '$$cookieReader', function(APIXHRService, $q, $rootScope, Logger, $$cookieReader) {
    var API_PATH = '/dip/api/';
    var FIXTURES_PATH = '/fixtures/';
    var JUPYTER_API_PATH = '/jupyter/';

    var uploadFileRequest = function(requestUrl, formdataCustomizer, callback) {
        var url = API_PATH + requestUrl;

        // angular doesn't provide a way to get the progress event yet, we explicitly redo it
        var deferred = $q.defer();

        var xhr = new XMLHttpRequest();

        if (callback != null) {
            xhr.upload.addEventListener("progress", callback, false);
        }
        xhr.addEventListener("load", function(e) {
            var payload = e.target||e.srcElement;
            if(payload.status == 200) {
                deferred.resolve(payload.response);
            } else {
                deferred.reject(payload);
            }
            $rootScope.$apply();
        }, false);
        xhr.addEventListener("error", function(e) {
            var payload = e.target||e.srcElement;
            deferred.reject(payload);
            $rootScope.$apply();
        }, false);

        var start = new Date().getTime();
        Logger.debug("[S] POST_FILE " + requestUrl);

        var logDone = function(result) {
            var end = new Date().getTime();
            Logger.debug("[D] POST_FILE " + requestUrl + " (" + (end-start) +"ms)");
        };

        xhr.open("POST", url);
        xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');

        const xsrfToken = $$cookieReader()[$rootScope.appConfig.xsrfCookieName];
        xhr.setRequestHeader('X-XSRF-TOKEN', xsrfToken);

        var formdata = new FormData();
        formdataCustomizer(formdata);
        xhr.send(formdata);

        deferred.promise.then(logDone, logDone);
        return app.addSuccessErrorToPromise(deferred.promise);
    };

    var stripDollarKeys = function(key, value) {
        return key.startsWith("$") ? undefined : value;
    };

return {
debug: {

},
timezone: {
    list: function() {
        // Return the full java list of the avaiblable timezone
        return APIXHRService("GET", API_PATH + "timezones/list");
    },
    shortlist: function() {
        // Return a shortlist of the most interesting human readable timezone
        return APIXHRService("GET", API_PATH + "timezones/shortlist");
    }
},
usage: {
    popNextReport: function() {
        return APIXHRService("POST", API_PATH + "pop-next-report", null, 'nospinner');
    },
    popReflectedEvents: function() {
        return APIXHRService("POST", API_PATH + "pop-reflected-events", null, 'nospinner');
    }

},
registration: {
    initialRegisterCommunity: function(firstName, lastName, userEmail, instanceId, license) {
        return APIXHRService("POST", API_PATH + "registration/initial-register-community", {
            userFirstName: firstName, userLastName: lastName,
            userEmail: userEmail,
            instanceId: instanceId, license: JSON.stringify(license)
        });
    },
    initialRegisterLicensed: function(license) {
        return APIXHRService("POST", API_PATH + "registration/post-initial-register-licensed", {
            license: license
        });
    },
    setOfflineLicense: function(license) {
        return APIXHRService("POST", API_PATH + "registration/set-offline-license", {
            license: license
        });
    },
    renewExpiredLicense: function(license) {
        return APIXHRService("POST", API_PATH + "registration/renew-expired-license", {
            license: license
        });
    }
},
projects: {
    list: function() {
        return APIXHRService("GET", API_PATH + "projects/list");
    },
    listHeads: function(requiredPrivilege = null) {
        return APIXHRService("GET", API_PATH + "projects/list-heads", {requiredPrivilege});
    },
    listExtended: function(lightMode, nospinner) {
        return APIXHRService("GET", API_PATH + "projects/list-extended", {lightMode: lightMode}, nospinner ? "nospinner" : undefined);
    },
    getExtended: function(projectKey, lightMode, nospinner) {
        return APIXHRService("GET", API_PATH + "projects/get-extended", {projectKey: projectKey, lightMode: lightMode}, nospinner ? "nospinner" : undefined);
    },
    listPromotedWikis: function(withHomeArticle, nospinner){
      return APIXHRService("GET", API_PATH + "projects/wikis/list-promoted", {withHomeArticle:withHomeArticle}, nospinner ? "nospinner" : undefined);
    },
    getGraph: function(layoutEngine, projectFolderId, recursive) {
        return APIXHRService("GET", API_PATH + "flow/projects/get-graph-serialized", {layoutEngine: layoutEngine, projectFolderId: projectFolderId, recursive: recursive});
    },
    checkDeletability: function(projectKey) {
        return APIXHRService("GET", API_PATH + "projects/check-deletability", {projectKey: projectKey});
    },
    delete: function(projectKey, dropManagedData, dropManagedFoldersOutputOfRecipe) {
        return APIXHRService("POST", API_PATH + "projects/delete", {projectKey, dropManagedData, dropManagedFoldersOutputOfRecipe});
    },
    listAllKeys: function() {
        return APIXHRService("GET", API_PATH + "projects/list-all-keys");
    },
    listAllTags: function() {
        return APIXHRService("GET", API_PATH + "projects/list-all-tags");
    },
    getSummary: function(projectKey) {
        return APIXHRService("GET", API_PATH + "projects/get-summary", {projectKey: projectKey});
    },
    create: function(projectKey, name, projectFolderId) {
         return APIXHRService("POST", API_PATH + "projects/create", {projectKey: projectKey, name: name, projectFolderId: projectFolderId});
    },
    getSettings: function(projectKey) {
        return APIXHRService("GET", API_PATH + "projects/get-settings", {projectKey: projectKey});
    },
    getDashboardAuthorizations: function(projectKey) {
        return APIXHRService("GET", API_PATH + "projects/get-dashboard-authorizations", {projectKey: projectKey});
    },
    getExposedObjects: function(projectKey) {
        return APIXHRService("GET", API_PATH + "projects/get-exposed-objects", {projectKey: projectKey});
    },
    getEnrichedExposedObjects: function(projectKey) {
        return APIXHRService("GET", API_PATH + "projects/get-enriched-exposed-objects", {projectKey: projectKey});
    },
    saveExposedObjects: function(projectKey, exposedObjects) {
        return APIXHRService("POST", API_PATH + "projects/save-exposed-objects", {
            projectKey: projectKey,
            exposedObjects: JSON.stringify(exposedObjects, stripDollarKeys)
        });
    },
    addExposedObject: function(projectKey, type, objectId, targetProjectKey) {
        return APIXHRService("POST", API_PATH + "projects/add-exposed-object", {
            projectKey,
            type,
            objectId,
            targetProjectKey
        });
    },
    getObjectExposition: function(projectKey, objectType, objectId) {
        return APIXHRService("GET", API_PATH + "projects/get-object-exposition", {projectKey: projectKey, objectType: objectType, objectId: objectId});
    },
    getObjectsExpositions: function(items) {
        //POST because request might be big
        return APIXHRService("POST", API_PATH + "projects/get-objects-expositions", {
            items: JSON.stringify(items)
        });
    },
    saveObjectExposition: function(projectKey, objectType, objectId, objectExposition) {
        return APIXHRService("POST", API_PATH + "projects/save-object-exposition", {projectKey: projectKey, objectType: objectType, objectId: objectId, objectExposition: JSON.stringify(objectExposition) });
    },
    addObjectsExpositions: function(items, settings) {
        return APIXHRService("POST", API_PATH + "projects/add-objects-expositions", {
            items: JSON.stringify(items),
            settings: JSON.stringify(settings)
        });
    },
    unshare: function(items, targetProjectKey) {
        return APIXHRService("POST", API_PATH + "projects/unshare", {
            items: JSON.stringify(items),
            targetProjectKey: targetProjectKey
        });
    },
    addReaderAuthorizations: function(projectKey, readerAuthorizations) {
        return APIXHRService("POST", API_PATH + "projects/add-reader-authorizations", {projectKey: projectKey, readerAuthorizations: JSON.stringify(readerAuthorizations)});
    },
    saveDashboardAuthorizations: function(projectKey, dashboardAuthorizations) {
        return APIXHRService("POST", API_PATH + "projects/save-dashboard-authorizations", {projectKey: projectKey, dashboardAuthorizations: JSON.stringify(dashboardAuthorizations)});
    },
    getAdditionalDashboardUsers : function(projectKey) {
        return APIXHRService("GET", API_PATH + "projects/get-additional-dashboard-users", {projectKey: projectKey})
    },
    saveAdditionalDashboardUsers: function(projectKey, additionalDashboardUsers) {
        return APIXHRService("POST", API_PATH + "projects/save-additional-dashboard-users", {projectKey: projectKey, data: JSON.stringify(additionalDashboardUsers)});
    },
    saveSummary: function(projectKey, data) {
        return APIXHRService("POST", API_PATH + "projects/save-summary", {projectKey: projectKey, data: JSON.stringify(data)});
    },
    saveSettings: function(projectKey, data) {
        return APIXHRService("POST", API_PATH + "projects/save-settings", {projectKey: projectKey, data: JSON.stringify(data)});
    },
    savePermissions: function(projectKey, project){
      return APIXHRService("POST", API_PATH + "projects/save-permissions", {projectKey: projectKey, project: JSON.stringify(project)});
    },
    createTutorial: function(tutorialId, tutorialType, projectFolderId) {
        return APIXHRService("POST", API_PATH + "projects/create-tutorial", {id: tutorialId, type: tutorialType, projectFolderId: projectFolderId})
    },
    listTutorials: function() {
        return APIXHRService("GET", API_PATH + "tutorials/list");
    },
    startProjectExport: function(projectKey, exportOptions) {
        return APIXHRService("POST", API_PATH + "projects/start-export", {
            projectKey: projectKey,
            exportOptions: JSON.stringify(exportOptions)
        })
    },
    startProjectDuplication: function(projectKey, duplicateOptions) {
        return APIXHRService("POST", API_PATH + "projects/duplicate", {
            projectKey: projectKey,
            duplicateOptions: JSON.stringify(duplicateOptions)
        })
    },
    getProjectDatasets: function(projectKey){
        return APIXHRService("POST", API_PATH + "projects/export/prepare", {
            projectKey: projectKey
        })
    },
    getProjectExportURL: function(projectKey, exportId) {
        return API_PATH + "projects/download-export?projectKey=" + encodeURIComponent(projectKey)
        + '&exportId='+encodeURIComponent(exportId);
    },
    uploadForImport: function(file, callback) {
        return uploadFileRequest("projects/import/upload", function(formdata) {
            formdata.append("file", file);
        }, callback)
    },
    startImport: function(importId, importSettings) {
        return APIXHRService("POST", API_PATH + "projects/import/start", {
            importId: importId,
            importSettings: JSON.stringify(importSettings)
        })
    },
    prepareImport: function(importId, importSettings) {
        return APIXHRService("POST", API_PATH + "projects/import/prepare", {
            importId: importId,
            importSettings: JSON.stringify(importSettings)
        })
    },
    resyncHDFSDatasetPermissions : function(projectKey) {
        return APIXHRService("POST", API_PATH + "projects/admin/resync-hdfs-permissions", {
            projectKey: projectKey
        })
    },
    getAppManifest: function(projectKey) {
        return APIXHRService("GET", API_PATH + "projects/get-app-manifest", {
            projectKey: projectKey
        })
    },
    saveAppManifest: function(projectKey, appManifest) {
        return APIXHRService("POST", API_PATH + "projects/save-app-manifest", {
            projectKey: projectKey,
            appManifest: JSON.stringify(appManifest)
        })
    },
    getAppRemapping: function(projectKey) {
        return APIXHRService("GET", API_PATH + "projects/get-app-remapping", {
            projectKey: projectKey
        })
    },
    saveAppRemapping: function(projectKey, settings) {
        return APIXHRService("POST", API_PATH + "projects/save-app-remapping", {
            projectKey: projectKey,
            settings: JSON.stringify(settings)
        })
    },
    publicApi: {
        listProjectApiKeys: function(projectKey) {
            return APIXHRService("GET", API_PATH + "admin/publicapi/get-project-api-keys", {
                projectKey: projectKey
            });
        },
        createProjectApiKey: function(key) {
            return APIXHRService("POST", API_PATH + "admin/publicapi/create-project-api-key", {
                key: JSON.stringify(key)
            });
        },
        saveProjectApiKey: function(key) {
            return APIXHRService("POST", API_PATH + "admin/publicapi/save-project-api-key", {
                key: JSON.stringify(key)
            });
        },
        deleteProjectApiKey: function(projectKey, key) {
            return APIXHRService("POST", API_PATH + "admin/publicapi/delete-project-api-key", {
                projectKey: projectKey,
                key: key
            });
        }
    },
    variables: {
        get: function(projectKey) {
            return APIXHRService("GET", API_PATH + "projects/variables/get", {
                projectKey: projectKey
            })
        },
        save: function(projectKey, data) {
            return APIXHRService("POST", API_PATH + "projects/variables/save", {
                projectKey: projectKey,
                data: JSON.stringify(data)
            })
        }
    },
    design: {
        prepareBundleCreation: function(projectKey) {
            return APIXHRService("GET", API_PATH + "projects/design/prepare-bundle-creation", {
                projectKey: projectKey
            })
        },
        createBundle: function(projectKey, bundleId, preparationResult) {
            return APIXHRService("POST", API_PATH + "projects/design/create-bundle", {
                projectKey: projectKey,
                bundleId: bundleId,
                preparationResult: JSON.stringify(preparationResult)
            })
        },
        deleteBundle: function(projectKey, bundleId) {
            return APIXHRService("POST", API_PATH + "projects/design/delete-bundle", {
                projectKey: projectKey,
                bundleId: bundleId
            })
        },
        listBundles: function(projectKey) {
            return APIXHRService("GET", API_PATH + "projects/design/list-bundles", {
                projectKey: projectKey
            })
        },
        getBundleDetails: function(projectKey, bundleId) {
            return APIXHRService("GET", API_PATH + "projects/design/get-bundle-details", {
                projectKey: projectKey,
                bundleId: bundleId
            })
        },
        getBundleDownloadURL: function(projectKey, bundleId) {
            return API_PATH
                    +"projects/design/download-bundle?projectKey=" + encodeURIComponent(projectKey)
                    + '&bundleId='+ encodeURIComponent(bundleId);
        },
        getBundleExporterSettings: function(projectKey) {
            return APIXHRService("GET", API_PATH + "projects/design/get-bundle-exporter-settings", {
                projectKey: projectKey
            })
        },
        saveBundleExporterSettings: function(projectKey, settings) {
            return APIXHRService("POST", API_PATH + "projects/design/save-bundle-exporter-settings", {
                projectKey: projectKey, settings: JSON.stringify(settings)
            })
        },
        checkBundleReversion: function(projectKey, bundleId) {
            return APIXHRService("GET", API_PATH + "projects/design/check-bundle-reversion", {
                projectKey: projectKey, bundleId: bundleId
            })
        },
        revertBundle: function(projectKey, bundleId, importOptions) {
            return APIXHRService("POST", API_PATH + "projects/design/revert-bundle", {
                projectKey: projectKey, bundleId: bundleId, importOptions: JSON.stringify(importOptions)
            })
        },
        publishToDeployer: function(projectKey, bundleId, publishedProjectKey) {
            return APIXHRService("POST", API_PATH + "projects/design/publish-to-project-deployer", {
                projectKey, bundleId, publishedProjectKey
            });
        }
    },
    automation: {
        createWithInitialBundle: function(file, projectFolderId, projectKey) {
            return uploadFileRequest("projects/automation/create-with-initial-bundle", function(formdata) {
                formdata.append("file", file);
                formdata.append("projectFolderId", projectFolderId || "");
                formdata.append("projectKey", projectKey || "");
            }, null);
        },
        importBundle: function(projectKey, file) {
            return uploadFileRequest("projects/automation/import-bundle", function(formdata) {
                formdata.append("projectKey", projectKey);
                formdata.append("file", file);
            }, null);
        },
        listBundles: function(projectKey) {
            return APIXHRService("GET", API_PATH + "projects/automation/list-bundles", {
                projectKey: projectKey
            })
        },
        getBundleDetails: function(projectKey, bundleId) {
            return APIXHRService("GET", API_PATH + "projects/automation/get-bundle-details", {
                projectKey: projectKey, bundleId: bundleId
            })
        },
        checkBundleActivation: function(projectKey, bundleId) {
            return APIXHRService("GET", API_PATH + "projects/automation/check-bundle-activation", {
                projectKey: projectKey, bundleId: bundleId
            })
        },
        preloadBundle: function(projectKey, bundleId) {
            return APIXHRService("POST", API_PATH + "projects/automation/preload-bundle", {
                projectKey: projectKey, bundleId: bundleId
            })
        },
        activateBundle: function(projectKey, bundleId) {
            return APIXHRService("POST", API_PATH + "projects/automation/activate-bundle", {
                projectKey: projectKey, bundleId: bundleId
            })
        },
        getBundleActivationSettingsExt: function(projectKey) {
            return APIXHRService("GET", API_PATH + "projects/automation/get-activation-settings-ext", {
                projectKey: projectKey
            })
        },
        saveBundleActivationSettings: function(projectKey, settings) {
            return APIXHRService("POST", API_PATH + "projects/automation/save-activation-settings", {
                projectKey: projectKey, settings: JSON.stringify(settings)
            });
        },
        deleteBundle: function(projectKey, bundleId) {
            return APIXHRService("POST", API_PATH + "projects/automation/delete-bundle", {
                projectKey: projectKey, bundleId: bundleId
            })
        },
    },
    activity: {
        getActivitySummary: function(projectKey, timeSpan) {
            return APIXHRService("GET", API_PATH + "projects/activity/get-summary", {
                projectKey: projectKey, timeSpan: timeSpan
            })
        }
    },
    folderEdit: {
        listContents: function(projectKey, type) {
            return APIXHRService("GET", API_PATH + "projects/folder-edition/list-contents", {
                projectKey: projectKey, type: type
            });
        },
        getContent: function(projectKey, type, path, sendAnyway) {
            return APIXHRService("GET", API_PATH + "projects/folder-edition/get-content", {
                projectKey: projectKey, type: type, path: path, sendAnyway: sendAnyway
            });
        },
        setContent: function(projectKey, type, path, data) {
            return APIXHRService("POST", API_PATH + "projects/folder-edition/set-content", {
                projectKey: projectKey, type: type, path: path, data: data
            });
        },
        setContentMultiple: function(projectKey, type, contentMap) {
            return APIXHRService("POST", API_PATH + "projects/folder-edition/set-content-multiple", {
                projectKey: projectKey, type: type, contentMap: JSON.stringify(contentMap)
            });
        },
        createContent: function(projectKey, type, path, isFolder) {
            return APIXHRService("POST", API_PATH + "projects/folder-edition/create-content", {
                projectKey: projectKey, type: type, path: path, isFolder: isFolder
            });
        },
        deleteContent: function(projectKey, type, path) {
            return APIXHRService("POST", API_PATH + "projects/folder-edition/delete-content", {
                projectKey: projectKey, type: type, path: path
            });
        },
        decompressContent: function(projectKey, type, path) {
            return APIXHRService("POST", API_PATH + "projects/folder-edition/decompress-content", {
                projectKey: projectKey, type: type, path: path
            });
        },
        renameContent: function(projectKey, type, path, newName) {
            return APIXHRService("POST", API_PATH + "projects/folder-edition/rename-content", {
                projectKey: projectKey, type: type, path: path, newName: newName
            });
        },
        moveContent: function(projectKey, type, path, toPath) {
            return APIXHRService("POST", API_PATH + "projects/folder-edition/move-content", {
                projectKey: projectKey, type: type, path: path, toPath: toPath
            });
        },
        copyContent: function(projectKey, type, path) {
            return APIXHRService("POST", API_PATH + "projects/folder-edition/copy-content", {
                projectKey: projectKey, type: type, path: path
            });
        },
        uploadContent: function(projectKey, type, path, file, callback) {
            return uploadFileRequest("projects/folder-edition/upload-content", function(formdata) {
                formdata.append("projectKey", projectKey);
                formdata.append("type", type);
                formdata.append("path", path);
                formdata.append("file", file);
            }, callback);
        },
        checkUploadContent: function(projectKey, type, path, filePaths) {
            return APIXHRService("POST", API_PATH + "projects/folder-edition/check-upload-content", {
                projectKey: projectKey, type: type, path: path, filePaths: JSON.stringify(filePaths)
            });
        }
    },
    checkReaderAuthorizations: function(projectKey, readerAuthorizations) {
        return APIXHRService("GET", API_PATH + "projects/check-reader-authorizations", {
            projectKey: projectKey,
            readerAuthorizations: JSON.stringify(readerAuthorizations)
        });
    },
    listComputedMetrics: function(projectKey) {
        return APIXHRService("GET", API_PATH + "projects/list-computed-metrics", {
            projectKey: projectKey
        });
    },
    saveMetrics: function(projectKey, metrics, checks) {
        return APIXHRService("POST", API_PATH + "projects/save-metrics", {
            projectKey: projectKey,
            metricsData: JSON.stringify(metrics),
            checksData: JSON.stringify(checks)
        });
    },
    listAvailableMetrics: function(projectKey, folderId) {
        return APIXHRService("GET", API_PATH + "projects/list-available-metrics", {
            projectKey: projectKey,
            folderId: folderId
        });
    },
    getPreparedMetricHistory: function(projectKey, partitionId, metric, metricId) {
        return APIXHRService("GET", API_PATH + "projects/get-prepared-metric-history", {
            projectKey: projectKey,
            data: JSON.stringify(metric),
            metricId: metricId,
            partitionId: partitionId
        });
    },
    getPreparedMetricHistories: function(projectKey, displayedState) {
        return APIXHRService("POST", API_PATH + "projects/get-prepared-metric-histories", {
            projectKey: projectKey,
            data: JSON.stringify(displayedState || {})
        });
    },
    getCheckHistories: function(projectKey, displayedState) {
        return APIXHRService("POST", API_PATH + "projects/get-prepared-check-histories", {
            projectKey: projectKey,
            data: JSON.stringify(displayedState || {})
        });
    },
    listComputedChecks: function(projectKey) {
        return APIXHRService("GET", API_PATH + "projects/list-computed-checks", {
            projectKey: projectKey
        });
    },
    createMetricsDataset: function(projectKey, view, partition, filter) {
        return APIXHRService("GET", API_PATH + "datasets/create-metrics-dataset", {
            projectKey: projectKey,
            objectId: '',
            view: view,
            partition: partition,
            filter: filter
        });
    },
    clearMetrics: function(projectKey) {
        return APIXHRService("GET", API_PATH + "projects/clear-metrics", {
            projectKey: projectKey
        });
    },
    saveExternalMetricsValues: function(projectKey, metrics, types) {
        return APIXHRService("POST", API_PATH + "projects/save-external-metrics-values", {
            projectKey: projectKey,
            data: JSON.stringify(metrics),
            typesData: JSON.stringify(types || {})
        });
    },
    saveExternalChecksValues: function(projectKey, checks) {
        return APIXHRService("POST", API_PATH + "projects/save-external-checks-values", {
            projectKey: projectKey,
            data: JSON.stringify(checks)
        });
    },
    switchAppType: function(projectKey, appType, settings, manifest) {
        return APIXHRService("POST", API_PATH + "projects/switch-app-type", {
            projectKey: projectKey,
            appType: appType,
            settings: settings ? JSON.stringify(settings) : null,
            manifest: manifest ? JSON.stringify(manifest) : null
        });
    },
    createOrUpdatePlugin: function(projectKey, pluginId, appName) {
        return APIXHRService("POST", API_PATH + "projects/create-or-update-plugin", {
            projectKey: projectKey,
            pluginId: pluginId,
            appName: appName
        });
    },

    git: {
        pull: function(projectKey, remoteName, branchName) {
            return APIXHRService("GET", API_PATH + "projects/git/pull", {
                projectKey: projectKey,
                remoteName: remoteName,
                branchName: branchName
            });
        },
        fetch: function(projectKey, remoteName) {
            return APIXHRService("GET", API_PATH + "projects/git/fetch", {
                projectKey: projectKey,
                remoteName: remoteName
            });
        },
        push: function(projectKey, remoteName, branchName) {
            return APIXHRService("GET", API_PATH + "projects/git/push", {
                projectKey: projectKey,
                remoteName: remoteName,
                branchName: branchName
            });
        },
        resetToUpstream: function(projectKey, remoteName, branchName) {
            return APIXHRService("POST", API_PATH + "projects/git/reset-to-upstream", {
                projectKey: projectKey,
                remoteName: remoteName,
                branchName: branchName
            });
        },
        resetToHead: function(projectKey) {
            return APIXHRService("POST", API_PATH + "projects/git/reset-to-head", {
                projectKey: projectKey
            });
        },
        getFullStatus: function(projectKey) {
            return APIXHRService("GET", API_PATH + "projects/git/get-full-status", {
                projectKey: projectKey
            });
        },
        listBranches: function(projectKey) {
            return APIXHRService("GET", API_PATH + "projects/git/list-branches", {
                projectKey: projectKey
            });
        },
        deleteBranches: function(projectKey, /*String[]*/branchNames, deleteOptions) {
            return APIXHRService("GET", API_PATH + "projects/git/delete-branches", {
                projectKey: projectKey,
                branchNames: JSON.stringify(branchNames),
                remoteDelete: deleteOptions.remoteDelete,
                forceDelete: deleteOptions.forceDelete
            });
        },
        commit: function(projectKey, commitMessage) {
            return APIXHRService("GET", API_PATH + "projects/git/commit", {
                projectKey: projectKey,
                commitMessage: commitMessage
            });
        },
        prepareCommit: function(projectKey) {
            return APIXHRService("GET", API_PATH + "projects/git/prepare-commit", {
                projectKey: projectKey
            });
        },
        createBranch: function(projectKey, branchName, commitId) {
            return APIXHRService("GET", API_PATH + "projects/git/create-branch", {
                projectKey: projectKey,
                branchName: branchName,
                commitId: commitId
            });
        },
        switchBranch: function(projectKey, branchName, clearOutputDatasets) {
            return APIXHRService("GET", API_PATH + "projects/git/switch-branch", {
                projectKey: projectKey,
                branchName: branchName,
                clearOutputDatasets: clearOutputDatasets
            });
        },
        setRemote: function(projectKey, remoteName, remoteUrl) {
            return APIXHRService("GET", API_PATH + "projects/git/set-remote", {
                projectKey: projectKey,
                remoteName: remoteName,
                remoteUrl: remoteUrl
            });
        },
        removeRemote: function(projectKey, remoteName) {
            return APIXHRService("GET", API_PATH + "projects/git/rm-remote", {
                projectKey: projectKey,
                remoteName: remoteName
            });
        },
        listProjectsMatchingRemoteRepository: function(projectKey, branchName) {
            return APIXHRService("GET", API_PATH + "projects/git/list-projects-matching-remote-repository", {
                projectKey: projectKey,
                branchName: branchName
            });
        }
    }
},
projectFolders: {
    listRootContents: (lightMode) => APIXHRService("GET", `${API_PATH}project-folders/list-contents`, { lightMode }),
    listContents: (folderId, lightMode, maxLevel = -1, silent = false) => APIXHRService("GET",  `${API_PATH}project-folders/${folderId}/list-contents`, { lightMode, maxLevel }, silent === true ? 'nospinner' : undefined),
    create: (parentId, name) => APIXHRService("POST", `${API_PATH}project-folders/create`, { folderId: parentId, name }),
    moveItems: (destination, folderIds, projectKeys = null, projectParent = null) => APIXHRService("POST", `${API_PATH}project-folders/move-items`, { folderIds: JSON.stringify(folderIds), projectKeys: JSON.stringify(projectKeys), projectParent, destination }),
    delete: (folders, destination) => APIXHRService("POST", `${API_PATH}project-folders/delete`, { folderIds: JSON.stringify(folders), destination }),
    getSettings: (folderId) => APIXHRService("GET", `${API_PATH}project-folders/${folderId}/settings`),
    setSettings: (folderId, settings) => APIXHRService("PUT", `${API_PATH}project-folders/${folderId}/settings`, { projectFolderSettings: JSON.stringify(settings) }),
    getEffectiveReaders: (folderId) => APIXHRService("GET", `${API_PATH}project-folders/${folderId}/list-readers`),
    listExtended: silent => APIXHRService("GET", `${API_PATH}project-folders/`, {}, silent === true ? 'nospinner' : undefined),
},
globalfinder: {
    search: (query, limit = 10, contextualProjectKey) => APIXHRService("POST", `${API_PATH}search/`, { query, limit, contextualProjectKey}, 'nospinner'),
},
apps: {
    listTemplates: function(noSpinner) {
        return APIXHRService("GET", API_PATH + "apps/list-templates", {}, noSpinner ? "nospinner" : undefined);
    },
    listInstances: function() {
        return APIXHRService("GET", API_PATH + "apps/list-instances");
    },
    getTemplateSummary: function(appId) {
        return APIXHRService("GET", API_PATH + "apps/get-template-summary", {appId: appId});
    },
    getInstanceSummary: function(projectKey) {
        return APIXHRService("GET", API_PATH + "apps/get-instance-summary", {projectKey: projectKey});
    },
    instantiate: function(appId, targetProjectKey, targetProjectLabel) {
        return APIXHRService("POST", API_PATH + "apps/instantiate", {
            appId: appId,
            targetProjectKey:targetProjectKey,
            targetProjectLabel: targetProjectLabel
        })
    },
    createOrUpdateTestInstance: function(appId, fullUpdate) {
        return APIXHRService("POST", API_PATH + "apps/create-or-update-test-instance", {appId: appId, fullUpdate: fullUpdate});
    },
    getTestInstance: function(appId) {
        return APIXHRService("GET", API_PATH + "apps/get-test-instance", {appId: appId});
    },
    getAppRecipeUsability: function(recipeType) {
        return APIXHRService("GET", API_PATH + "apps/get-app-recipe-usability", {recipeType: recipeType});
    },
    checkInstancesDeletability: function(appId, projectKeys) {
        return APIXHRService("GET", API_PATH + "apps/check-instances-deletability", {appId:appId, projectKeys: JSON.stringify(projectKeys)});
    },
    deleteInstances: function(appId, projectKeys, dropManagedData, dropManagedFoldersOutputOfRecipe) {
        return APIXHRService("POST", API_PATH + "apps/delete-instances", {
            appId:appId,
            projectKeys: JSON.stringify(projectKeys),
            dropManagedData: dropManagedData,
            dropManagedFoldersOutputOfRecipe:dropManagedFoldersOutputOfRecipe
        });
    }
},
git: {
    getObjectLog: function(projectKey, objectType, objectId, since, count) {
        return APIXHRService("GET", API_PATH + "git/get-object-log", {
            projectKey: projectKey,
            objectType: objectType,
            objectId: objectId,
            since: since,
            count: count
        });
    },
    revertObjectToRevision: function(projectKey, objectType, objectId, hash) {
        return APIXHRService("POST", API_PATH + "git/revert-object-to-revision", {
            projectKey: projectKey,
            objectType: objectType,
            objectId: objectId,
            hash:hash
        });
    },
    revertProjectToRevision: function(projectKey, hash) {
        return APIXHRService("POST", API_PATH + "git/revert-project-to-revision", {
            projectKey: projectKey,
            hash:hash
        });
    },

    revertSingleCommit : function(projectKey, objectRef, hash) {
        return APIXHRService("POST", API_PATH + "git/revert-single-commit", {
            projectKey: projectKey,
            objectRef: objectRef,
            hash:hash
        });
    },

    prepareObjectCommit: function(projectKey, objectType, objectId) {
        return APIXHRService("GET", API_PATH + "git/prepare-object-commit", {
            projectKey: projectKey,
            objectType: objectType,
            objectId: objectId
        });
    },
    commitObject: function(projectKey, objectType, objectId, message) {
        return APIXHRService("POST", API_PATH + "git/commit-object", {
            projectKey: projectKey,
            objectType: objectType,
            objectId: objectId, message: message
        });
    },
    getCommitDiff: function(projectKey, objectRef, commitId) {
        return APIXHRService("GET", API_PATH + "git/get-commit-diff", {
            projectKey: projectKey,
            objectRef: objectRef,
            commitId: commitId
        });
    },
    getRevisionsDiff: function(projectKey, commitFrom, commitTo, objectRef) {
        return APIXHRService("GET", API_PATH + "git/get-revisions-diff", {
            projectKey: projectKey,
            commitFrom: commitFrom,
            commitTo: commitTo,
            objectRef: JSON.stringify(objectRef)
        });
    },
    listRemoteRefs: function(repository) {
        return APIXHRService("GET", API_PATH + "git/list-remote-references", {
            repository: repository
        });
    },
    listRemotes : function(projectKey) {
        return APIXHRService("GET", API_PATH + "git/list-remotes", {
            projectKey: projectKey
        })
    },
    addRemote : function(projectKey, name, url) {
        return APIXHRService("POST", API_PATH + "git/add-remote", {
            projectKey: projectKey,
            name: name,
            url: url
        })
    },
    removeRemote : function(projectKey, name) {
        return APIXHRService("POST", API_PATH + "git/remove-remote", {
            projectKey: projectKey,
            name: name
        })
    },
    setProjectGitRef: function(projectKey, gitRef, gitRefPath, addPythonPath) {
        return APIXHRService("POST", API_PATH + "git/set-project-git-ref", {
            projectKey: projectKey,
            gitReference: JSON.stringify(gitRef),
            gitReferencePath: gitRefPath,
            addPythonPath: addPythonPath
        });
    },
    rmProjectGitRef: function(projectKey, gitRefPath, deleteDirectory) {
        return APIXHRService("POST", API_PATH + "git/rm-project-git-ref", {
            projectKey: projectKey,
            gitReferencePath: gitRefPath,
            deleteDirectory: deleteDirectory
        });
    },
    pullProjectGitRef: function(projectKey, gitRefPath) {
        return APIXHRService("GET", API_PATH + "git/pull-project-git-ref", {
            projectKey: projectKey,
            gitReferencePath: gitRefPath
        });
    },
    getProjectExternalLibs: function(projectKey) {
        return APIXHRService("GET", API_PATH + "git/get-project-external-libraries", {
            projectKey: projectKey
        });
    },
    pullProjectGitRefs: function(projectKey) {
        return APIXHRService("GET", API_PATH + "git/pull-project-git-refs", {
            projectKey: projectKey
        });
    }
},
wikis : {
    getWiki: function(projectKey) {
        return APIXHRService("GET", API_PATH + "projects/wikis/get-wiki", {
            projectKey: projectKey
        });
    },
    getArticleSummary: function(projectKey, articleIdOrName) {
        return APIXHRService("GET", API_PATH + "projects/wikis/get-article-summary", {
            projectKey: projectKey,
            articleIdOrName: articleIdOrName
        });
    },
    getArticlePayload: function(projectKey, articleId) {
        return APIXHRService("GET", API_PATH + "projects/wikis/get-article-payload",  {
            projectKey: projectKey,
            articleId: articleId
        });
    },
    createArticle: function(projectKey, articleName, parent, templateDesc) {
        return APIXHRService("POST", API_PATH + "projects/wikis/create-article", {
            projectKey: projectKey,
            articleName: articleName,
            parent: parent,
            templateDesc: JSON.stringify(templateDesc)
        });
    },
    checkSaveConflict: function(article) {
        return APIXHRService("POST", API_PATH + "projects/wikis/check-save-article-conflict", {
            article: JSON.stringify(article)
        });
    },
    saveArticle: function(article, payload, commitMessage) {
        let articleRequest = {
            article: JSON.stringify(article),
            commitMessage: commitMessage
        };
        if (angular.isString(payload)) {
            articleRequest['payload'] = payload;
        }
        return APIXHRService("POST", API_PATH + "projects/wikis/save-article", articleRequest);
    },
    changeArticleParent: function(projectKey, id, parentId) {
        return APIXHRService("POST", API_PATH + "projects/wikis/change-article-parent", {
            projectKey: projectKey,
            id: id,
            parentId: parentId
        });
    },
    editTaxonomy: function(projectKey, wiki) {
        return APIXHRService("POST", API_PATH + "projects/wikis/edit-taxonomy", {
            projectKey: projectKey,
            wiki: JSON.stringify(wiki)
        });
    },
    setHomeArticle: function(projectKey, homeArticleId) {
        return APIXHRService("POST", API_PATH + "projects/wikis/set-home-article", {
            projectKey: projectKey,
            homeArticleId: homeArticleId
        });
    },
    renameArticle: function(projectKey, oldId, newId) {
        return APIXHRService("POST", API_PATH + "projects/wikis/rename-article", {
            projectKey: projectKey,
            oldId: oldId,
            newId: newId
        });
    },
    deleteArticle: function(projectKey, articleId, deleteChildren) {
        return APIXHRService("POST", API_PATH + "projects/wikis/delete-article", {
            projectKey: projectKey,
            articleId: articleId,
            deleteChildren: deleteChildren
        });
    },
    listTemplates: function() {
        return APIXHRService("GET", API_PATH + "projects/wikis/list-templates", {});
    },
    upload: function(projectKey, articleId, file, callback) {
        return uploadFileRequest("projects/wikis/upload", function(formdata) {
            formdata.append("projectKey", projectKey);
            formdata.append("articleId", articleId);
            formdata.append("file", file);
        }, callback);
    },
    copyArticle: function(projectKey, articleName, parent, originalArticleId, withAttachments) {
        return APIXHRService("POST", API_PATH + "projects/wikis/copy-article", {
            projectKey: projectKey,
            articleName: articleName,
            parent: parent,
            originalArticleId: originalArticleId,
            withAttachments: withAttachments
        });
    },
    exportArticle: function(projectKey, articleId, exportFormat, exportChildren, exportAttachments) {
        return APIXHRService("POST", API_PATH + "projects/wikis/export", {
            projectKey: projectKey,
            articleId: articleId,
            exportFormat: JSON.stringify(exportFormat),
            exportChildren: exportChildren,
            exportAttachments: exportAttachments
        });
    },
    getExportURL: function(projectKey, exportId) {
        return API_PATH + "projects/wikis/download-export?"
        + "projectKey=" + encodeURIComponent(projectKey)
        + "&exportId=" + encodeURIComponent(exportId);
    }
},
analysis: {
    listHeads: function(projectKey, withMLTasks) {
        return APIXHRService("GET", API_PATH + "analysis/list-heads", {
            projectKey: projectKey,
            withMLTasks: !!withMLTasks
        });
    },
    listOnDataset: function(projectKey, datasetSmartName, withMLTasks) {
        return APIXHRService("GET", API_PATH + "analysis/list-on-dataset", {
            projectKey: projectKey,
            datasetSmartName: datasetSmartName,
            withMLTasks: !!withMLTasks
        });
    },
    create: function(projectKey, inputDatasetSmartName, name) {
         return APIXHRService("POST", API_PATH + "analysis/create", {
            projectKey: projectKey,
            inputDatasetSmartName: inputDatasetSmartName,
            name: name
        });
    },
    createPredictionTemplate: function(projectKey, inputDatasetSmartName, analysisName, mlBackendType, mlBackendName, targetVariable, guessPolicy) {
         return APIXHRService("POST", API_PATH + "analysis/create-prediction-template", {
            projectKey: projectKey,
            inputDatasetSmartName: inputDatasetSmartName,
            analysisName: analysisName,
            mlBackendType: mlBackendType,
            mlBackendName: mlBackendName,
            targetVariable: targetVariable,
            guessPolicy: guessPolicy
        });
    },
    createClusteringTemplate: function(projectKey, inputDatasetSmartName, analysisName, mlBackendType, mlBackendName, guessPolicy) {
         return APIXHRService("POST", API_PATH + "analysis/create-clustering-template", {
            projectKey: projectKey,
            inputDatasetSmartName: inputDatasetSmartName,
            analysisName: analysisName,
            mlBackendType: mlBackendType,
            mlBackendName: mlBackendName,
            guessPolicy: guessPolicy
        });
    },
    duplicate: function(projectKey, analysisId) {
        return APIXHRService("POST", API_PATH + "analysis/duplicate", {projectKey: projectKey, analysisId: analysisId });
    },
    getCore: function(projectKey, analysisId) {
        return APIXHRService("GET", API_PATH + "analysis/get-core", {projectKey: projectKey, analysisId: analysisId });
    },
    getPostScriptSchema: function(projectKey, analysisId) {
        return APIXHRService("GET", API_PATH + "analysis/get-post-script-schema", {projectKey: projectKey, analysisId: analysisId});
    },
    getSummary: function(projectKey, analysisId, withMLTasksAndSavedModels) {
        return APIXHRService("GET", API_PATH + "analysis/get-summary", {
            projectKey: projectKey,
            analysisId: analysisId,
            withMLTasksAndSavedModels: !!withMLTasksAndSavedModels
        });
    },
    saveCore: function(data, saveInfo) {
        return APIXHRService("POST", API_PATH + "analysis/save-core", {data: JSON.stringify(data), saveInfo: JSON.stringify(saveInfo || {})});
    },
    listMLTasks: function(projectKey, analysisId) {
        return APIXHRService("GET", API_PATH + "analysis/list-mltasks", {projectKey: projectKey, analysisId: analysisId});
    },
    listSavedModels: function(projectKey, analysisId) {
        return APIXHRService("GET", API_PATH + "analysis/list-saved-models", { projectKey: projectKey, analysisId: analysisId });
    },
    addToFlow: function(projectKey, analysisId, createOutput, outputDatasetName, outputDatasetSettings, options) {
        return APIXHRService("POST", API_PATH + "analysis/add-to-flow/", {
                projectKey: projectKey,
                analysisId: analysisId,
                createOutput: createOutput,
                outputDatasetName: outputDatasetName,
                outputDatasetSettings: JSON.stringify(outputDatasetSettings),
                options: JSON.stringify(options)
            }
        );
    },
    exportProcessedData: function(projectKey, analysisId, params) {
        return APIXHRService("POST", API_PATH + "analysis/export-processed-data/", {
                projectKey: projectKey,
                analysisId: analysisId,
                params: JSON.stringify(params)
            }
        );
    },
    mlcommon: {
        stopGridSearch: function(fullModelIds) {
            return APIXHRService("POST", API_PATH + "analysis/mlcommon/stop-grid-search", {fullModelIds: fullModelIds });
        },
        stopGridSearchSession: function(projectKey, analysisId, mlTaskId, sessionId) {
            return APIXHRService("POST", API_PATH + "analysis/mlcommon/stop-grid-search-session", {projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId, sessionId: sessionId });
        },
        interruptPartitionedTraining: function (fullModelIds) {
            return APIXHRService("POST", API_PATH + "analysis/mlcommon/interrupt-partitioned-training", {fullModelIds: fullModelIds});
        },
        listBackends: function(projectKey, datasetSmartName, taskType) {
            return APIXHRService("POST", API_PATH + "analysis/mlcommon/list-backends", {projectKey: projectKey, datasetSmartName: datasetSmartName, taskType: taskType });
        },
        getDiagnosticsDefinition: function() {
            return APIXHRService("GET", API_PATH + "analysis/mlcommon/diagnostics-definition");
        },
        setModelMeta: function(fullModelId, data) {
            return APIXHRService("POST", API_PATH + "analysis/mlcommon/set-model-meta", {fullModelId: fullModelId, data: JSON.stringify(data)});
        },
        getCurrentSettings: function(projectKey, analysisId, mlTaskId) {
            return APIXHRService("POST", API_PATH + "analysis/mlcommon/get-current-settings", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId
            });
        },
        getLastPreprocessingStatus: function(projectKey, analysisId, mlTaskId) {
            return APIXHRService("GET", API_PATH + "analysis/mlcommon/get-last-preprocessing-status", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId
            });
        },
        forgetFeatureSelection: function(projectKey, analysisId, mlTaskId) {
            return APIXHRService("POST", API_PATH + "analysis/mlcommon/forget-feature-selection", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId
            });
        },
        trainAbort: function(projectKey, analysisId, mlTaskId) {
            return APIXHRService("POST", API_PATH + "analysis/mlcommon/train-abort", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId
            });
        },
        trainAbortPartial: function(projectKey, analysisId, mlTaskId, fullModelIds) {
            return APIXHRService("POST", API_PATH + "analysis/mlcommon/train-abort-partial", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId, fullModelIds: fullModelIds
            });
        },
        deleteMLTask: function(projectKey, analysisId, mlTaskId) {
            return APIXHRService("POST", API_PATH + "analysis/mlcommon/delete-mltask", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId
            });
        },
        copyFeatureSettings: function(projectKeyFrom, analysisIdFrom, mlTaskIdFrom, projectKeyTo, analysisIdTo, mlTaskIdTo) {
            return APIXHRService("POST", API_PATH + "analysis/mlcommon/copy-features-handling", {
               projectKeyFrom: projectKeyFrom, analysisIdFrom: analysisIdFrom, mlTaskIdFrom: mlTaskIdFrom,
               projectKeyTo: projectKeyTo, analysisIdTo: analysisIdTo, mlTaskIdTo: mlTaskIdTo
           });
        },
        revertScriptToSession: function(projectKey, analysisId, mlTaskId, sessionId) {
            return APIXHRService("POST", API_PATH + "analysis/mlcommon/revert-script-to-session", {
                projectKey:projectKey,
                analysisId:analysisId,
                mlTaskId:mlTaskId,
                sessionId:sessionId
            });
        }
    },
    /* Prediction ML Task */
    pml: {
        listPredictableColumns: function(projectKey, analysisId) {
            return APIXHRService("GET", API_PATH + "analysis/pml/list-predictable-columns", {projectKey: projectKey, analysisId: analysisId});
        },
        listGuessPolicies: function() {
            return APIXHRService("GET", API_PATH + "analysis/pml/list-guess-policies");
        },
        listCustomPythonAlgos: function(projectKey) {
            return APIXHRService("GET", API_PATH + "analysis/pml/list-custom-python-algos", {projectKey: projectKey});
        },
        createAndGuess: function(projectKey, analysisId, targetVariable, mlBackendType, mlBackendName, guessPolicy) {
            return APIXHRService("POST", API_PATH + "analysis/pml/create-and-guess", {
                projectKey: projectKey,
                analysisId: analysisId,
                targetVariable: targetVariable,
                mlBackendType: mlBackendType,
                mlBackendName: mlBackendName || '',
                guessPolicy: guessPolicy || 'DEFAULT'
            });
        },
        duplicate: function(projectKeyFrom, analysisIdFrom, mlTaskIdFrom, projectKeyTo, analysisIdTo, newTarget) {
            return APIXHRService("POST", API_PATH + "analysis/pml/duplicate", {
                projectKeyFrom,
                analysisIdFrom,
                mlTaskIdFrom,
                projectKeyTo,
                analysisIdTo,
                newTarget
            });
        },
        getModelSnippets: function(projectKey, analysisId, mlTaskId, fullModelIds, spinner) {
            return APIXHRService("GET", API_PATH + "analysis/pml/get-model-snippets", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId, fullModelIds: fullModelIds
            }, spinner ? undefined : "nospinner");
        },
        getPartitionedModelSnippets: function(fullModelId, spinner) {
            return APIXHRService("GET", API_PATH + "analysis/pml/get-partitioned-model-snippets", {
                fullModelId: fullModelId
            }, spinner ? undefined : "nospinner");
        },
        getTaskStatus: function(projectKey, analysisId, mlTaskId) {
            return APIXHRService("GET", API_PATH + "analysis/pml/get-mltask-status", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId
            }, "nospinner");
        },
        getUpdatedSettings: function(projectKey, analysisId, mlTaskId) {
            return APIXHRService("POST", API_PATH + "analysis/pml/get-updated-settings", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId
            });
        },
        getSessionTask: function(projectKey, analysisId, mlTaskId, sessionId) {
            return APIXHRService("POST", API_PATH + "analysis/pml/get-session-task", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId, sessionId: sessionId
            });
        },
        getPretrainEquivalentMLTask: function(fullModelId, usePostTrain) {
            return APIXHRService("POST", API_PATH + "analysis/pml/get-pretrain-equivalent-mltask", {
                fullModelId:fullModelId,
                usePostTrain: usePostTrain
            });
        },
        getPreTrainStatus: function(projectKey, analysisId, mlTaskId) {
            return APIXHRService("GET", API_PATH + "analysis/pml/get-pretrain-status", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId
            });
        },
        retrainStart: function(projectKey, analysisId, mlTaskId, sessionId, fullModelIds) {
            return APIXHRService("POST", API_PATH + "analysis/pml/retrain-start", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId, sessionId: sessionId, fullModelIds: fullModelIds
            });
        },
        trainStart: function(projectKey, analysisId, mlTaskId, userSessionName, userSessionDescription, forceRefresh) {
            return APIXHRService("POST", API_PATH + "analysis/pml/train-start", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId,
                userSessionName: userSessionName, userSessionDescription: userSessionDescription,
                forceRefresh: forceRefresh
            });
        },
        resumePartitionedTraining: function(projectKey, analysisId, mlTaskId, sessionId, fullModelIds) {
            return APIXHRService("POST", API_PATH + "analysis/pml/resume-partitioned-training", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId, sessionId: sessionId, fullModelIds: fullModelIds
            });
        },
        checkCanEnsemble: function(modelIds) {
            return APIXHRService("POST", API_PATH + "analysis/pml/check-can-ensemble", {
                modelIds: JSON.stringify(modelIds),
            });
        },
        createEnsemble: function(projectKey, analysisId, mlTaskId, modelIds, method) {
            return APIXHRService("POST", API_PATH + "analysis/pml/create-ensemble", {
                projectKey: projectKey,
                analysisId: analysisId,
                mlTaskId: mlTaskId,
                modelIds: JSON.stringify(modelIds),
                method: method
            });
        },
        saveSettings: function(projectKey, analysisId, mlTask) {
            return APIXHRService("POST", API_PATH + "analysis/pml/save-settings", {
                projectKey: projectKey, analysisId: analysisId, mlTask: JSON.stringify(mlTask)
            });
        },
        reguessWithTarget: function(projectKey, analysisId, mlTaskId, targetVariable, redetect) {
            return APIXHRService("POST", API_PATH + "analysis/pml/reguess-with-target", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId,
                targetVariable: targetVariable, redetect: redetect
            });
        },
        reguessWithType: function(projectKey, analysisId, mlTaskId, newType, redetect) {
            return APIXHRService("POST", API_PATH + "analysis/pml/reguess-with-type", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId,
                newType: newType, redetect: redetect
            });
        },
        changeGuessPolicy: function(projectKey, analysisId, mlTaskId, policyId) {
            return APIXHRService("POST", API_PATH + "analysis/pml/change-guess-policy", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId,
                newPolicyId: policyId
            });
        },
        saveCostMatrixWeights: function(fullModelId, data) {
          return APIXHRService("POST", API_PATH + "analysis/pml/save-costmatrix-weights", {
                fullModelId: fullModelId, data: JSON.stringify(data)
            });
        },
        deployTrain: function(fullModelId, trainDatasetSmartName, testDatasetSmartName, modelName, options) {
            return APIXHRService("POST", API_PATH + "analysis/pml/flow/deploy-train", {
                fullModelId: fullModelId,
                trainDatasetSmartName: trainDatasetSmartName,
                testDatasetSmartName: testDatasetSmartName,
                modelName: modelName,
                options: JSON.stringify(options)
            });
        },
        listRedeployableTrain: function(fullModelId) {
            return APIXHRService("POST", API_PATH + "analysis/pml/flow/list-redeployable-train", {fullModelId: fullModelId });
        },
        redeployTrain: function(fullModelId, recipeName, activate, options) {
            return APIXHRService("POST", API_PATH + "analysis/pml/flow/redeploy-train", {
                fullModelId: fullModelId,
                recipeName: recipeName,
                activate: !!activate,
                options: JSON.stringify(options)
            });
        },
        createNotebook: function(fullModelId, notebookTitle) {
            return APIXHRService("POST", API_PATH + "analysis/pml/create-notebook", {fullModelId: fullModelId, notebookTitle: notebookTitle});
        },
        validateArchitecture: function(payload, envSelection, projectKey) {
            return APIXHRService("POST", API_PATH + "analysis/pml/validate-keras-architecture", {
                payload : payload,
                envSelection : JSON.stringify(envSelection),
                projectKey : projectKey
            });
        },
        copyAlgorithmSettings: function(projectKeyFrom, analysisIdFrom, mlTaskIdFrom, projectKeyTo, analysisIdTo, mlTaskIdTo) {
            return APIXHRService("POST", API_PATH + "analysis/pml/copy-algorithm-settings", {
               projectKeyFrom: projectKeyFrom, analysisIdFrom: analysisIdFrom, mlTaskIdFrom: mlTaskIdFrom,
               projectKeyTo: projectKeyTo, analysisIdTo: analysisIdTo, mlTaskIdTo: mlTaskIdTo
           });
        }
    },
    /* Clustering MLTask */
    cml: {
        listGuessPolicies: function() {
            return APIXHRService("GET", API_PATH + "analysis/cml/list-guess-policies");
        },
        createAndGuess: function(projectKey, analysisId, mlBackendType, mlBackendName, guessPolicy) {
            return APIXHRService("POST", API_PATH + "analysis/cml/create-and-guess", {
                projectKey: projectKey,
                analysisId: analysisId,
                mlBackendType: mlBackendType,
                mlBackendName: mlBackendName || '',
                guessPolicy: guessPolicy || 'DEFAULT'
            });
        },
        duplicate: function(projectKeyFrom, analysisIdFrom, mlTaskIdFrom, projectKeyTo, analysisIdTo) {
            return APIXHRService("POST", API_PATH + "analysis/cml/duplicate", {
                projectKeyFrom,
                analysisIdFrom,
                mlTaskIdFrom,
                projectKeyTo,
                analysisIdTo
            });
        },
        getModelSnippets: function(projectKey, analysisId, mlTaskId, fullModelIds) {
            return APIXHRService("GET", API_PATH + "analysis/cml/get-model-snippets", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId, fullModelIds: fullModelIds
            }, "nospinner");
        },
        getTaskStatus: function(projectKey, analysisId, mlTaskId) {
            return APIXHRService("GET", API_PATH + "analysis/cml/get-mltask-status", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId
            }, "nospinner");
        },
        getUpdatedSettings: function(projectKey, analysisId, mlTaskId) {
            return APIXHRService("POST", API_PATH + "analysis/cml/get-updated-settings", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId
            });
        },
        getSessionTask: function(projectKey, analysisId, mlTaskId, sessionId) {
            return APIXHRService("POST", API_PATH + "analysis/cml/get-session-task", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId, sessionId: sessionId
            });
        },
        getPreTrainStatus: function(projectKey, analysisId, mlTaskId) {
            return APIXHRService("GET", API_PATH + "analysis/cml/get-pretrain-status", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId
            });
        },
        trainStart: function(projectKey, analysisId, mlTaskId, userSessionName, userSessionDescription, forceRefresh) {
            return APIXHRService("POST", API_PATH + "analysis/cml/train-start", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId,
                userSessionName: userSessionName, userSessionDescription: userSessionDescription,
                 forceRefresh: forceRefresh
            });
        },
        saveSettings: function(projectKey, analysisId, mlTask) {
            return APIXHRService("POST", API_PATH + "analysis/cml/save-settings", {
                projectKey: projectKey, analysisId: analysisId, mlTask: JSON.stringify(mlTask)
            });
        },
        reguess: function(projectKey, analysisId, mlTaskId) {
            return APIXHRService("POST", API_PATH + "analysis/cml/reguess", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId
            });
        },
        deployTrain: function(fullModelId, inputDatasetSmartName, modelName) {
            return APIXHRService("POST", API_PATH + "analysis/cml/flow/deploy-train", {
                fullModelId: fullModelId,
                inputDatasetSmartName: inputDatasetSmartName,
                modelName: modelName
            });
        },
        listRedeployableTrain: function(fullModelId) {
            return APIXHRService("POST", API_PATH + "analysis/cml/flow/list-redeployable-train", {fullModelId: fullModelId });
        },
        redeployTrain: function(fullModelId, recipeName, activate) {
            return APIXHRService("POST", API_PATH + "analysis/cml/flow/redeploy-train", {
                fullModelId: fullModelId, recipeName: recipeName, activate: !!activate
            });
        },
        deployCluster: function(fullModelId, inputDatasetSmartName, outputDatasetName, outputDatasetSettings) {
            return APIXHRService("POST", API_PATH + "analysis/cml/flow/deploy-cluster", {
                fullModelId: fullModelId,
                inputDatasetSmartName:inputDatasetSmartName,
                outputDatasetName:outputDatasetName,
                outputDatasetSettings: JSON.stringify(outputDatasetSettings)
            });
        },
        listRedeployableCluster: function(fullModelId) {
            return APIXHRService("POST", API_PATH + "analysis/cml/flow/list-redeployable-cluster", {fullModelId: fullModelId });
        },
        redeployCluster: function(fullModelId, recipeName) {
            return APIXHRService("POST", API_PATH + "analysis/cml/flow/redeploy-cluster", {
                fullModelId: fullModelId, recipeName: recipeName
            });
        },
        createNotebook: function(fullModelId, notebookTitle) {
            return APIXHRService("POST", API_PATH + "analysis/cml/create-notebook", {
                fullModelId: fullModelId, notebookTitle: notebookTitle
            })
        },
        copyAlgorithmSettings: function(projectKeyFrom, analysisIdFrom, mlTaskIdFrom, projectKeyTo, analysisIdTo, mlTaskIdTo) {
            return APIXHRService("POST", API_PATH + "analysis/cml/copy-algorithm-settings", {
               projectKeyFrom: projectKeyFrom, analysisIdFrom: analysisIdFrom, mlTaskIdFrom: mlTaskIdFrom,
               projectKeyTo: projectKeyTo, analysisIdTo: analysisIdTo, mlTaskIdTo: mlTaskIdTo
           });
        },
        changeGuessPolicy: function(projectKey, analysisId, mlTaskId, policyId) {
            return APIXHRService("POST", API_PATH + "analysis/cml/change-guess-policy", {
                projectKey: projectKey, analysisId: analysisId, mlTaskId: mlTaskId,
                newPolicyId: policyId
            });
        },
    },
    /* Predicted data (common to ML tasks) */
    predicted: {
        predictedRefreshTable: function(fullModelId, displayScript, allowCache, filters) {
            return APIXHRService("POST", API_PATH + "analysis/predicted/refresh-table", {
                fullModelId: fullModelId,
                displayScript: JSON.stringify(displayScript),
                allowCache: allowCache,
                filters: JSON.stringify(filters)
            })
        },
        predictedGetTableChunk: function(fullModelId, displayScript, firstRow, nbRows, firstCol, nbCols, filters) {
            return APIXHRService("POST", API_PATH + "analysis/predicted/get-table-chunk", {
                fullModelId: fullModelId,
                displayScript: JSON.stringify(displayScript),
                filters: JSON.stringify(filters),
                firstRow: firstRow,
                nbRows: nbRows,
                firstCol: firstCol,
                nbCols: nbCols
            })
        },
        chartsGetColumnsSummary: function(fullModelId) {
            return APIXHRService("GET", API_PATH + "analysis/predicted/charts-get-columns-summary", {
                fullModelId: fullModelId
            });
        },
        chartsGetPivotResponse: function(fullModelId, request, requestedSampleId) {
            return APIXHRService("POST", API_PATH + "analysis/predicted/charts-get-pivot-response", {
                fullModelId: fullModelId,
                request: JSON.stringify(request),
                requestedSampleId: requestedSampleId
            });
        },
        detailedColumnAnalysis: function(fullModelId, data, column, alphanumMaxResults) {
            return APIXHRService("POST", API_PATH + "analysis/predicted/detailed-column-analysis/", {
            	fullModelId: fullModelId,
                data: JSON.stringify(data),
                column: column,
                alphanumMaxResults: alphanumMaxResults
            });
        }
    }
},
ml: {
    prediction: {
        getModelDetails: function(fullModelId) {
            return APIXHRService("GET", API_PATH + "ml/prediction/get-model-details", {
                fullModelId: fullModelId
            });
        },
        getTreeSummary: function(fullModelId) {
            return APIXHRService("GET", API_PATH + "ml/prediction/get-tree-summary", {
                 fullModelId: fullModelId
             });
        },
        getEnsembleSummary: function(fullModelId) {
            return APIXHRService("GET", API_PATH + "ml/prediction/get-ensemble-summary", {
                 fullModelId: fullModelId
             });
        },
        getCoefPath: function(fullModelId) {
            return APIXHRService("GET", API_PATH + "ml/prediction/get-coef-path", {
                 fullModelId: fullModelId
             });
        },
        getPreparedInputSchema: function(recipe) {
            return APIXHRService("POST", API_PATH + "ml/prediction/get-prepared-input-schema", {
                 recipeData: JSON.stringify(recipe)
             });
        },
        getSql: function(recipe) {
            return APIXHRService("GET", API_PATH + "ml/prediction/export-sql?recipeData="+ JSON.stringify(recipe));
        },
        getScoringModelDownloadURL: function(format, exportId) {
            format = format.toLowerCase();
            return `${API_PATH}ml/prediction/get-export?format=${format}&exportId=${encodeURIComponent(exportId)}`;
        },
        createScoringModelFile: function(format, fullModelId, params) {
            fullModelId = encodeURIComponent(fullModelId);
            format = format.toLowerCase();
            if (!params) {
                params = "";
            }
            switch (format) {
                case "jar-fat":
                    format = "jar";
                    params += "&includeLibs=true";
                    break;
                case "jar-thin":
                    format = "jar";
                    params += "&includeLibs=false";
                    break;
            }
            const url = `${API_PATH}ml/prediction/export-${format}?fullModelId=${fullModelId}${params}`;
            return APIXHRService("GET", url);
        },
        docGenCustom: function(file, fullModelId, callback) {
            return uploadFileRequest("ml/prediction/render-custom", function(formdata) {
                formdata.append("file", file);
                formdata.append("fullModelId", fullModelId);
            }, callback);
        },
        docGenDefault: function(fullModelId) {
            return APIXHRService("POST", API_PATH + "ml/prediction/render-default" , {
                fullModelId: fullModelId
            });
        },
        getPreDocGenInfoMessages: function(fullModelId) {
            return APIXHRService("POST", API_PATH + "ml/prediction/get-pre-docgen-info-messages" , {
                fullModelId: fullModelId
            });
        },
        exportToSnowflakeFunction: function(connectionName, fullModelId, functionName) {
            return APIXHRService("POST", API_PATH + "ml/prediction/export-to-snowflake-function", {
                connectionName, fullModelId, functionName
            });
        },
        subpopulationComputationStart: function(fullModelId, features, computationParams) {
            return APIXHRService("POST", API_PATH + "ml/prediction/subpopulation-computation-start" , {
                fullModelId: fullModelId,
                features: JSON.stringify(features),
                computationParams: JSON.stringify(computationParams),
            });
        },
        pdpComputationStart: function(fullModelId, features, computationParams) {
            return APIXHRService("POST", API_PATH + "ml/prediction/pdp-computation-start" , {
                fullModelId: fullModelId,
                features: JSON.stringify(features),
                computationParams: JSON.stringify(computationParams),
            });
        },
        individualExplanationsComputationStart: function(fullModelId, computationParams) {
            return APIXHRService("POST", API_PATH + "ml/prediction/individual-explanations-computation-start" , {
                fullModelId: fullModelId,
                computationParams: JSON.stringify(computationParams),
            });
        },
        getIndividualExplanations: function(fullModelId) {
            return APIXHRService("GET", API_PATH + "ml/prediction/get-individual-explanations" , {
                fullModelId: fullModelId,
            });
        },
        getSubpopulation: function(fullModelId, features) {
            return APIXHRService("POST", API_PATH + "ml/prediction/get-subpopulation" , {
                fullModelId: fullModelId,
                features: JSON.stringify(features)
            });
        },
        getSubpopulationsInfo: function(fullModelId) {
            return APIXHRService("GET", API_PATH + "ml/prediction/get-subpopulations-info", {
                fullModelId: fullModelId
            });
        },
        getPartitionsPerf: function(fullModelId) {
            return APIXHRService("GET", API_PATH + "ml/prediction/get-partitions-perf" , {
                fullModelId: fullModelId
            });
        },
        getCollectorData: function(fullModelId) {
            return APIXHRService("GET", API_PATH + "ml/prediction/get-collector-data" , {
                fullModelId: fullModelId
            });
        },
        getColumnImportance: function(fullModelId) {
            return APIXHRService("GET", API_PATH + "ml/prediction/get-column-importance" , {
                fullModelId: fullModelId
            });
        },
        getSplitDesc: function(fullModelId) {
            return APIXHRService("GET", API_PATH + "ml/prediction/get-split-desc" , {
                fullModelId: fullModelId
            });
        },
        getInputDatasetSchema: function(fullModelId) {
            return APIXHRService("GET", API_PATH + "ml/prediction/get-input-dataset-schema" , { fullModelId });
        },
        getPreparationScript: function(fullModelId) {
            return APIXHRService("GET", API_PATH + "ml/prediction/get-preparation-script" , {
                fullModelId: fullModelId
            });
        },


    },
    clustering: {
        getModelDetails: function(fullModelId) {
            return APIXHRService("GET", API_PATH + "ml/clustering/get-model-details", {
                fullModelId: fullModelId
            });
        },
        getScatterPlot: function(projectKey, fullModelId, variable1, variable2) {
            return APIXHRService("GET", API_PATH + "ml/clustering/get-scatter-plot" , {
                projectKey: projectKey, fullModelId: fullModelId,
                variable1: variable1, variable2: variable2
            });
        },
        getClusterHierarchy: function(fullModelId) {
            return APIXHRService("GET", API_PATH + "ml/clustering/get-cluster-hierarchy" , {
                fullModelId: fullModelId
            });
        },
        getAnomalies: function(fullModelId) {
            return APIXHRService("GET", API_PATH + "ml/clustering/get-anomalies" , {
                fullModelId: fullModelId
            });
        },
        getPreparedInputSchema: function(recipe) {
            return APIXHRService("POST", API_PATH + "ml/clustering/get-prepared-input-schema", {
                 recipeData: JSON.stringify(recipe)
             });
        },
        rescore: function(fullModelId) {
            return APIXHRService("POST", API_PATH + "ml/clustering/rescore" , {
                fullModelId: fullModelId
            });
        }
    },
    saveModelUserMeta: function(fullModelId, data) {
        return APIXHRService("POST", API_PATH + "ml/save-model-user-meta", {
            fullModelId: fullModelId, data: JSON.stringify(data)
        });
    },
    deleteModels: function(list) {
        return APIXHRService("POST", API_PATH + "ml/delete-models", {
            list: JSON.stringify(list)
        });
    }
},
interactiveModel: {
    startBackend: function(fullModelId) {
        return APIXHRService("POST", API_PATH + "ml/interactive-model/start-backend" , {
            fullModelId: fullModelId
        });
    },
    backendStatus: function(fullModelId) {
        return APIXHRService("GET", API_PATH + "ml/interactive-model/backend-status" , {
            fullModelId: fullModelId
        }, 'nospinner');
    },
    computeScore: function(fullModelId, params, applyPreparationScript) {
        const computationParams = {
            fullModelId: fullModelId,
            params: JSON.stringify(params),
        };
        if (applyPreparationScript !== null) {
            computationParams.applyPreparationScript = applyPreparationScript;
        }
        return APIXHRService("POST", API_PATH + "ml/interactive-model/compute-score" , computationParams);
    },

    computeExplanations: function(fullModelId, params, method, nExplanations, applyPreparationScript) {
        const computationParams = {
            fullModelId: fullModelId,
            params: JSON.stringify(params),
            method,
            nExplanations,
        };
        if (applyPreparationScript !== null) {
            computationParams.applyPreparationScript = applyPreparationScript;
        }
        return APIXHRService("POST", API_PATH + "ml/interactive-model/compute-explanations" , computationParams);
    }

},
savedmodels: {
    get: function(projectKey, smartId) {
        return APIXHRService("GET", API_PATH + "savedmodels/get", {projectKey: projectKey, smartId: smartId});
    },
    getSummary: function(projectKey, id) {
        return APIXHRService("GET", API_PATH + "savedmodels/get-summary", {projectKey: projectKey, id: id});
    },
    getFullInfo: function(projectKey, id) {
        return APIXHRService("GET", API_PATH + "savedmodels/get-full-info", {projectKey: projectKey, id: id});
    },
    list: function(projectKey) {
        return APIXHRService("GET", API_PATH + "savedmodels/list", {projectKey: projectKey});
    },
    listWithAccessible: function(projectKey) {
        return APIXHRService("GET", API_PATH + "savedmodels/list-with-accessible/", {projectKey: projectKey});
    },
    save: function(data, saveInfo) {
        return APIXHRService("POST", API_PATH + "savedmodels/save", {
            data: JSON.stringify(data),
            saveInfo: JSON.stringify(saveInfo || {})
        });
    },
    prediction: {
        getStatus: function(projectKey, savedModelId) {
            return APIXHRService("GET", API_PATH + "savedmodels/prediction/get-status", {projectKey: projectKey, savedModelId: savedModelId });
        },
        deployScoring: function(projectKey, options) {
            return APIXHRService("POST", API_PATH + "savedmodels/prediction/deploy-scoring", {
                projectKey: projectKey, options: JSON.stringify(options)
            });
        },
        deployEvaluation: function(projectKey, options) {
            return APIXHRService("POST", API_PATH + "savedmodels/prediction/deploy-evaluation",{
                    projectKey:projectKey, options : JSON.stringify(options)
            });
        },
        deployStandaloneEvaluation: function(projectKey, options) {
            return APIXHRService("POST", API_PATH + "savedmodels/prediction/deploy-standalone-evaluation",{
                    projectKey:projectKey, options : JSON.stringify(options)
            });
        },
        setActive: function(projectKey, savedModelId, newActiveVersion) {
            return APIXHRService("POST", API_PATH + "savedmodels/prediction/set-active", {
                projectKey: projectKey,
                savedModelId: savedModelId,
                newActiveVersion: newActiveVersion
            });
        },
        deleteVersions: function(projectKey, savedModelId, versions) {
            return APIXHRService("POST", API_PATH + "savedmodels/prediction/delete-versions", {
                projectKey: projectKey,
                savedModelId: savedModelId,
                versions: JSON.stringify(versions)
            });
        }
    },
    clustering: {
        getStatus: function(projectKey, savedModelId) {
            return APIXHRService("GET", API_PATH + "savedmodels/clustering/get-status", {projectKey: projectKey, savedModelId: savedModelId});
        },
        deployScoring: function(projectKey, savedModelSmartName, inputDatasetSmartName, createOutput, outputDatasetSmartName, outputDatasetSettings) {
            return APIXHRService("POST", API_PATH + "savedmodels/clustering/deploy-scoring", {
                projectKey: projectKey,
                savedModelSmartName: savedModelSmartName,
                inputDatasetSmartName: inputDatasetSmartName,
                createOutput: createOutput,
                outputDatasetSmartName: outputDatasetSmartName,
                outputDatasetSettings: JSON.stringify(outputDatasetSettings)
            });
        },
        setActive: function(projectKey, savedModelId, newActiveVersion) {
            return APIXHRService("POST", API_PATH + "savedmodels/clustering/set-active", {
                projectKey: projectKey, savedModelId: savedModelId,
                newActiveVersion: newActiveVersion
            });
        },
        deleteVersions: function(projectKey, savedModelId, versions) {
            return APIXHRService("POST", API_PATH + "savedmodels/clustering/delete-versions", {
                projectKey: projectKey,
                savedModelId: savedModelId,
                versions: JSON.stringify(versions)
            });
        }
    },
    getPreparedMetricHistory: function(projectKey, modelId, metric, metricId) {
        return APIXHRService("GET", API_PATH + "savedmodels/get-prepared-metric-history", {
            projectKey: projectKey,
            modelId: modelId,
            data: JSON.stringify(metric),
            metricId: metricId
        });
    },
    getPreparedMetricHistories: function(projectKey, modelId, displayedState) {
        return APIXHRService("POST", API_PATH + "savedmodels/get-prepared-metric-histories", {
            projectKey: projectKey,
            modelId: modelId,
            data: JSON.stringify(displayedState || {})
        });
    },
    listComputedMetrics: function(projectKey, modelId) {
        return APIXHRService("GET", API_PATH + "savedmodels/list-computed-metrics", {
            projectKey: projectKey,
            modelId: modelId
        });
    },
    createMetricsDataset: function(projectKey, modelId, view, partition, filter) {
        return APIXHRService("GET", API_PATH + "datasets/create-metrics-dataset", {
            projectKey: projectKey,
            objectId: modelId,
            view: view,
            partition: partition,
            filter: filter
        });
    },
    getPreparedMetricPartitions: function(projectKey, modelId, displayedState) {
        return APIXHRService("POST", API_PATH + "savedmodels/get-prepared-metric-partitions", {
            projectKey: projectKey,
            modelId: modelId,
            data: JSON.stringify(displayedState || {})
        });
    },
    runChecks: function(projectKey, modelId) {
        return APIXHRService("GET", API_PATH + "savedmodels/run-checks", {
            projectKey: projectKey,
            modelId: modelId
        });
    },
    runCheck: function(projectKey, modelId, metricsChecks) {
        return APIXHRService("POST", API_PATH + "savedmodels/run-check", {
            projectKey: projectKey,
            modelId: modelId,
            data: JSON.stringify(metricsChecks)
        });
    },
    getCheckHistories: function(projectKey, modelId, displayedState) {
        return APIXHRService("POST", API_PATH + "savedmodels/get-prepared-check-histories", {
            projectKey: projectKey,
            modelId: modelId,
            data: JSON.stringify(displayedState || {})
        });
    },
    listComputedChecks: function(projectKey, modelId) {
        return APIXHRService("GET", API_PATH + "savedmodels/list-computed-checks", {
            projectKey: projectKey,
            modelId: modelId
        });
    },
    getHint: function(projectKey, modelId, probe) {
        return APIXHRService("POST", API_PATH + "savedmodels/get-hint", {
            projectKey: projectKey,
            modelId: modelId,
            data: JSON.stringify(probe)
        });
    },
    clearMetrics: function(projectKey, modelId, partition) {
        return APIXHRService("GET", API_PATH + "savedmodels/clear-metrics", {
            projectKey: projectKey,
            modelId: modelId,
            partition: partition
        });
    },
    getModelDocumentationExportURL: function(exportId) {
        return API_PATH + "savedmodels/model-documentation-export?exportId=" + encodeURIComponent(exportId);
    },
    guessTrainDeploy: function(projectKey, modelId) {
        return APIXHRService("GET", API_PATH + "savedmodels/guess-train-deploy", {
            projectKey: projectKey,
            modelId: modelId
        });
    }
},
modelevaluationstores: {
    get: function(projectKey, smartId) {
        return APIXHRService("GET", API_PATH + "modelevaluationstores/get", {projectKey: projectKey, smartId: smartId});
    },
    getSummary: function(projectKey, id) {
        return APIXHRService("GET", API_PATH + "modelevaluationstores/get-summary", {projectKey: projectKey, id: id});
    },
    getFullInfo: function(projectKey, id) {
        return APIXHRService("GET", API_PATH + "modelevaluationstores/get-full-info", {projectKey: projectKey, smartId: id});
    },
    list: function(projectKey) {
        return APIXHRService("GET", API_PATH + "modelevaluationstores/list", {projectKey: projectKey});
    },
    listEvaluations: function(projectKey, id) {
        return APIXHRService("GET", API_PATH + "modelevaluationstores/list-evaluations", {projectKey: projectKey, smartId: id});
    },
    deleteEvaluations: function(projectKey, id, evaluations) {
        return APIXHRService("POST", API_PATH + "modelevaluationstores/delete-evaluations", {projectKey: projectKey, smartId: id, evaluations:JSON.stringify(evaluations)});
    },
    getEvaluation: function(projectKey, id, runId) {
        return APIXHRService("GET", API_PATH + "modelevaluationstores/get-evaluation", {projectKey: projectKey, smartId: id, runId: runId});
    },
    listWithAccessible: function(projectKey) {
        return APIXHRService("GET", API_PATH + "modelevaluationstores/list-with-accessible/", {projectKey: projectKey});
    },
    save: function(data, saveInfo) {
        return APIXHRService("POST", API_PATH + "modelevaluationstores/save", {
            data: JSON.stringify(data),
            saveInfo: JSON.stringify(saveInfo || {})
        });
    }
},
modelevaluations: {
    get: function(fme) {
        return APIXHRService("GET", API_PATH + "modelevaluations/get", {
            fme: fme
        });
    },
    getFMIEvaluationInfo: function(contextProjectKey, fmi) {
        return APIXHRService("GET", API_PATH + "modelevaluations/get-fmi-evaluation-info", {
            fmi: fmi,
            contextProjectKey: contextProjectKey
        });
    },
    saveEvaluationUserMeta: function(fme, data) {
        return APIXHRService("POST", API_PATH + "modelevaluations/save-evaluation-user-meta", {
            fme: fme, data: JSON.stringify(data)
        });
    },
    saveEvaluationLabels: function(fme, labels) {
        return APIXHRService("POST", API_PATH + "modelevaluations/save-evaluation-labels", {
            fme: fme, labels: JSON.stringify(labels)
        });
    },
    listCompatibleReferencesForDrift: function(projectKey, currentId, matchLabels) {
        return APIXHRService("GET", API_PATH + "modelevaluations/list-compatible-references-for-drift", {
            projectKey, currentId, matchLabels
        });
    },
    getSubpopulationsInfo: function(fme) {
        return APIXHRService("GET", API_PATH + "modelevaluations/get-subpopulations-info", {
            fme: fme
        });
    },
    subpopulationComputationStart: function(fme, features, computationParams) {
        return APIXHRService("POST", API_PATH + "modelevaluations/subpopulation-computation-start" , {
            fme: fme,
            features: JSON.stringify(features),
            computationParams: JSON.stringify(computationParams),
        });
    },
    getSubpopulation: function(fme, features) {
        return APIXHRService("POST", API_PATH + "modelevaluations/get-subpopulation" , {
            fme: fme,
            features: JSON.stringify(features)
        });
    },
    pdpComputationStart: function(fme, features, computationParams) {
        return APIXHRService("POST", API_PATH + "modelevaluations/pdp-computation-start" , {
            fme: fme,
            features: JSON.stringify(features),
            computationParams: JSON.stringify(computationParams),
        });
    },
    individualExplanationsComputationStart: function(fme, computationParams) {
        return APIXHRService("POST", API_PATH + "modelevaluations/individual-explanations-computation-start" , {
            fme: fme,
            computationParams: JSON.stringify(computationParams),
        });
    },
    getIndividualExplanations: function(fme) {
        return APIXHRService("GET", API_PATH + "modelevaluations/get-individual-explanations" , {
            fme: fme
        });
    },
    computeDataDrift: function(projectKey, referenceId, currentId, params) {
        return APIXHRService("POST", API_PATH + "modelevaluations/compute-data-drift" , {
            referenceId: referenceId,
            currentId: currentId,
            projectKey: projectKey,
            params: JSON.stringify(params)
        });
    }
},
home: {
    projectSearch: function(projectKey, query, taggableType, serializedRecentKeys) {
        return APIXHRService("GET", API_PATH + "home/project-search", {
            projectKey: projectKey,
            query: query,
            taggableType: taggableType,
            serializedRecentKeys: serializedRecentKeys
        }, "nospinner");
    }
},
images: {
    uploadImage: function(projectKey, type, id, dataUrl) {
        return uploadFileRequest("image/set-image", function(formdata) {
            formdata.append("projectKey", projectKey);
            formdata.append("type", type);
            formdata.append("id", id);
            formdata.append("dataUrl", dataUrl);
        }, null);
    },
    removeImage: function(projectKey, type, id) {
        return APIXHRService("GET", API_PATH + "image/remove-image", {projectKey: projectKey, type: type, id: id}, "nospinner");
    }
},
notifications: {
    count: function() {
        return APIXHRService("GET", API_PATH + "notifications/count", {}, "nospinner");
    },
    get: function() {
        return APIXHRService("GET", API_PATH + "notifications/get", {});
    },
    ack: function(timestamp) {
        return APIXHRService("POST", API_PATH + "notifications/acknowledge", {timestamp: timestamp}, "nospinner" );
    }
},
timelines: {
    getForObject: function(projectKey, objectType, objectId, from, limit) {
        return APIXHRService("GET", API_PATH + "timelines/get-for-object", {
            projectKey: projectKey,
            objectType: objectType,
            objectId: objectId,
            from: from,
            limit: limit
        });
    },
    getForProject: function(projectKey, from, limit) {
        return APIXHRService("GET", API_PATH + "timelines/get-for-project", {projectKey: projectKey, from: from, limit: limit});
    }
},
discussions: {
    getCounts: function(projectKey, objectType, objectId) {
        return APIXHRService("GET", API_PATH + "discussions/get-discussion-counts", {
            projectKey: projectKey,
            objectType: objectType,
            objectId: objectId
        }, "nospinner");
    },
    getForObject: function(projectKey, objectType, objectId) {
        return APIXHRService("GET", API_PATH + "discussions/get-for-object", {
            projectKey: projectKey,
            objectType: objectType,
            objectId: objectId
        });
    },
    create: function(projectKey, objectType, objectId, topic, reply) {
        return APIXHRService("POST", API_PATH + "discussions/create", {
            projectKey: projectKey,
            objectType: objectType,
            objectId: objectId,
            topic: topic,
            reply: reply
        });
    },
    save: function(projectKey, objectType, objectId, discussionId, topic) {
        return APIXHRService("POST", API_PATH + "discussions/save", {
            projectKey: projectKey,
            objectType: objectType,
            objectId: objectId,
            discussionId: discussionId,
            topic: topic
        });
    },
    reply: function(projectKey, objectType, objectId, discussionId, content, replyId) {
        return APIXHRService("POST", API_PATH + "discussions/reply", {
            projectKey: projectKey,
            objectType: objectType,
            objectId: objectId,
            discussionId: discussionId,
            replyId: replyId,
            content: content
        });
    },
    ack: function(projectKey, objectType, objectId, discussionId) {
        return APIXHRService("POST", API_PATH + "discussions/ack", {
            projectKey: projectKey,
            objectType: objectType,
            objectId: objectId,
            discussionId: discussionId
        });
    },
    close: function(projectKey, objectType, objectId, discussionId, closed) {
        return APIXHRService("POST", API_PATH + "discussions/close", {
            projectKey: projectKey,
            objectType: objectType,
            objectId: objectId,
            discussionId: discussionId,
            closed: closed
        });
    },
    delete: function(projectKey, objectType, objectId, discussionId) {
        return APIXHRService("POST", API_PATH + "discussions/delete-discussion", {
            projectKey: projectKey,
            objectType: objectType,
            objectId: objectId,
            discussionId: discussionId
        });
    },
    inbox: {
        search: function (query, facets) {
            return APIXHRService("POST", API_PATH + "inbox/search", {
                query: query,
                facets: JSON.stringify(facets)
            });
        },
    }
},
interests: {
    getForObject: function(user, objectType, projectKey, objectId) {
        return APIXHRService("GET", API_PATH + "interests/get-interest-for-object", {
            user: user,
            objectType: objectType,
            projectKey: projectKey,
            objectId: objectId
        });
    },
    getUserInterests: function(user, offset, maxItems, filters, starsOnly, nospinner) {
        return APIXHRService("GET", API_PATH + "interests/get-user-interests", {
            user: user,
            offset: offset,
            maxItems: maxItems,
            filters: filters,
            starsOnly: starsOnly
        }, nospinner ? "nospinner" : undefined);
    },
    watch: function(items, watch) {
        return APIXHRService("POST", API_PATH + "interests/watch", {
            items: JSON.stringify(items),
            watch: watch
        });
    },
    star: function(items, star) {
        return APIXHRService("POST", API_PATH + "interests/star", {
            items: JSON.stringify(items),
            star: star
        });
    },
    listWatchingUsers: function(objectType, projectKey, objectId) {
        return APIXHRService("GET", API_PATH + "interests/list-watching-users", {
            objectType: objectType,
            projectKey: projectKey,
            objectId: objectId
        });
    },
    listUsersWithStar: function(objectType, projectKey, objectId) {
        return APIXHRService("GET", API_PATH + "interests/list-users-with-star", {
            objectType: objectType,
            projectKey: projectKey,
            objectId: objectId
        });
    }
},
magic: function(filter) {
    return APIXHRService("GET", API_PATH + "home/magic", {filter: filter});
},
getConfiguration: function() {
    return APIXHRService("GET", API_PATH + "get-configuration", {});
},
getHomeArticles: function(nospinner) {
    return APIXHRService("GET", API_PATH + "get-home-articles", undefined, nospinner ? "nospinner" : undefined);
},
running: {
    listPersonal: function() {
        return APIXHRService("GET", API_PATH + "running/list-personal", {});
    },
    listAll: function() {
        return APIXHRService("GET", API_PATH + "running/list-all");
    }
},
futures: {
    getUpdate: function(futureId) {
        return APIXHRService("GET", API_PATH + "futures/get-update", {futureId: futureId}, "nospinner");
    },
    peekUpdate: function(futureId) {
        return APIXHRService("GET", API_PATH + "futures/peek-update", {futureId: futureId}, "nospinner");
    },
    abort: function(futureId) {
        return APIXHRService("POST", API_PATH + "futures/abort", {futureId: futureId});
    },
    list: function() {
        return APIXHRService("GET", API_PATH + "futures/list");
    },
    listAll: function() {
        return APIXHRService("GET", API_PATH + "futures/list-all");
    },
    listScenarios: function() {
        return APIXHRService("GET", API_PATH + "futures/list-scenarios");
    },
    listAllScenarios: function() {
        return APIXHRService("GET", API_PATH + "futures/list-all-scenarios");
    }
},
login: function(login, password) {
    return APIXHRService("POST", API_PATH + "login", {
        login: login, password: password
    });
},
noLoginLogin: function() {
    return APIXHRService("POST", API_PATH + "no-login-login");
},
getSAMLRedirectURL : function(){
    return APIXHRService("POST", API_PATH + "get-saml-redirect-url");
},

logout: function() {
    return APIXHRService("POST", API_PATH + "logout");
},
apikeys: {
    setAuthorizedDatasets: function(apiKey, datasets) {
        return APIXHRService("POST", API_PATH + "apikeys/set-authorized-datasets", {apiKey: apiKey, datasets: JSON.stringify(datasets)});
    },
    getAuthorizedDatasets: function(apiKey) {
        return APIXHRService("GET", API_PATH + "apikeys/get-authorized-datasets", {apiKey: apiKey});
    }
},
security: {
    listUsers: function(projectKey) {
        return APIXHRService("GET", API_PATH + "security/list-users", {projectKey});
    },
    listConnectedUsers: function(projectKey) {
        return APIXHRService("GET", API_PATH + "security/list-connected-users", {projectKey});
    },
    listGroups: function(localOnly) {
        return APIXHRService("GET", API_PATH + "security/list-groups", {localOnly: localOnly});
    },
    listGroupsFull: function() {
        return APIXHRService("GET", API_PATH + "security/list-groups-full");
    },
    updateGroup: function(groupData) {
        return APIXHRService("POST", API_PATH + "security/update-group", {groupData: JSON.stringify(groupData)});
    },
    prepareUpdateGroup: function(groupData) {
        return APIXHRService("POST", API_PATH + "security/prepare-update-group", {groupData: JSON.stringify(groupData)});
    },
    createGroup: function(groupData) {
        return APIXHRService("POST", API_PATH + "security/create-group", {groupData: JSON.stringify(groupData)});
    },
    getGroup: function(groupName) {
        return APIXHRService("GET", API_PATH + "security/get-group", {groupName: groupName});
    },
    deleteGroup: function(groupName) {
        return APIXHRService("POST", API_PATH + "security/delete-group", {groupName: groupName});
    },
    prepareDeleteGroup: function(groupName) {
        return APIXHRService("POST", API_PATH + "security/prepare-delete-group", {groupName: groupName});
    },
    getAuthorizationMatrix: function() {
        return APIXHRService("GET", API_PATH + "security/get-authorization-matrix");
    },
    getAuditBuffer: function(includeAllCalls) {
        return APIXHRService("GET", API_PATH + "security/get-audit-buffer", {
            includeAllCalls: includeAllCalls
        });
    }
},
zones : {
    getFullInfo: function(projectKey, zoneId) {
        return APIXHRService("GET", API_PATH + "zones/get-full-info", { projectKey: projectKey, zoneId: zoneId });
    },
    get: function(projectKey, zoneId) {
        return APIXHRService("GET", API_PATH + "zones/get", { projectKey: projectKey, zoneId: zoneId });
    }
},
dashboards : {
    save: function(dashboardData, commitMessage) {
        return APIXHRService("POST", API_PATH + "dashboards/save", { dashboardData: JSON.stringify(dashboardData), commitMessage: commitMessage });
    },
    list: function(projectKey) {
        return APIXHRService("GET", API_PATH + "dashboards/list", { projectKey: projectKey });
    },
    listEditable: function(projectKey) {
    	return APIXHRService("GET", API_PATH + "dashboards/list-editable", {projectKey: projectKey});
    },
    listHeads: function(projectKey, tagFilter) {
        return APIXHRService("GET", API_PATH + "dashboards/list-heads", {projectKey: projectKey, tagFilter: tagFilter});
    },
    listSummaries: function(projectKey) {
        return APIXHRService("GET", API_PATH + "dashboards/list-summaries", {projectKey: projectKey});
    },
    get: function(projectKey, dashboardId) {
        return APIXHRService("GET", API_PATH + "dashboards/get", { projectKey: projectKey, dashboardId: dashboardId });
    },
    getFullInfo: function(projectKey, dashboardId) {
        return APIXHRService("GET", API_PATH + "dashboards/get-full-info", { projectKey: projectKey, dashboardId: dashboardId });
    },
    getSummary: function(projectKey, dashboardId) {
        return APIXHRService("GET", API_PATH + "dashboards/get-summary", { projectKey: projectKey, dashboardId: dashboardId });
    },
    copy: function(projectKey, dashboardId, name, deepCopy) {
        return APIXHRService("POST", API_PATH + "dashboards/copy", { projectKey: projectKey, dashboardId: dashboardId, name: name, deepCopy: deepCopy });
    },
    getEnrichedPage: function(projectKey, dashboardId, pageIdx) {
        return APIXHRService("GET", API_PATH + "dashboards/get-enriched-page", { projectKey: projectKey, dashboardId: dashboardId, pageIdx: pageIdx });
    },
    copyPage: function(projectKey, sourceDashboardId, page, targetedDashboardId, copyPageName, pointerMode) {
        return APIXHRService("POST", API_PATH + "dashboards/copy-page", {projectKey: projectKey, sourceDashboardId: sourceDashboardId, pageData: JSON.stringify(page), targetedDashboardId: targetedDashboardId, copyPageName: copyPageName, pointerMode: pointerMode});
    },
    makeListed: function(projectKey, dashboardIds, listed) {
    	return APIXHRService("POST", API_PATH + "dashboards/make-listed", { projectKey: projectKey, dashboardIds: JSON.stringify(dashboardIds), listed: listed });
    },
    getMissingReaderAuthorizations: function(projectKey, dashboardIds) {
        return APIXHRService("GET", API_PATH + "dashboards/get-missing-reader-authorizations", { projectKey: projectKey, dashboardIds: JSON.stringify(dashboardIds) });
    },
    export: function(projectKey, exportFormat, dashboards) {
        return APIXHRService("POST", API_PATH + "dashboards/export", { projectKey: projectKey, exportFormat: JSON.stringify(exportFormat), dashboards: JSON.stringify(dashboards) });
    },
    getExportURL: function(projectKey, exportId) {
        return API_PATH + "dashboards/download-export?"
        + "projectKey=" + encodeURIComponent(projectKey)
        + "&exportId=" + encodeURIComponent(exportId);
    },
    multiPin: function(projectKey, insightId, tileData, pinningOrdersData, pointerMode) {
    	return APIXHRService("POST", API_PATH + "dashboards/multi-pin", {
    	    projectKey: projectKey,
            insightId: insightId,
            tileData: JSON.stringify(tileData),
            pinningOrdersData: JSON.stringify(pinningOrdersData),
            pointerMode: pointerMode
    	});
    },
    insights: {
        save: function(insightData, commitMessage, payload) {
            return APIXHRService("POST", API_PATH + "dashboards/insights/save", { insightData: JSON.stringify(insightData), commitMessage: commitMessage, payload: payload });
        },
        createAndPin: function(projectKey, insightData, tileData, pinningOrdersData, payloads) {
            return APIXHRService("POST", API_PATH + "dashboards/insights/create-and-pin",
            {
                projectKey: projectKey,
                insightData: JSON.stringify(insightData),
                tileData: JSON.stringify(tileData),
                pinningOrdersData: JSON.stringify(pinningOrdersData),
                payloadsData: payloads?JSON.stringify(payloads):null
            });
        },
        list: function(projectKey) {
            return APIXHRService("GET", API_PATH + "dashboards/insights/list", { projectKey: projectKey });
        },
        listWithAccessState: function(projectKey) {
            return APIXHRService("GET", API_PATH + "dashboards/insights/list-with-access-state", { projectKey: projectKey });
        },
        listHeads: function(projectKey, tagFilter) {
            return APIXHRService("GET", API_PATH + "dashboards/insights/list-heads", {projectKey: projectKey, tagFilter: tagFilter});
        },
        get: function(projectKey, insightId) {
            return APIXHRService("GET", API_PATH + "dashboards/insights/get", { projectKey: projectKey, insightId: insightId });
        },
        getFullInfo: function(projectKey, insightId) {
            return APIXHRService("GET", API_PATH + "dashboards/insights/get-full-info", { projectKey: projectKey, insightId: insightId });
        },
        getWithPayload: function(projectKey, insightId) {
            return APIXHRService("GET", API_PATH + "dashboards/insights/get-with-payload", { projectKey: projectKey, insightId: insightId });
        },
        copy: function(projectKey, insightIds, names, dashboardId) {
            var requestParams = { projectKey: projectKey, insightIds: JSON.stringify(insightIds), names: JSON.stringify(names)};
            if (dashboardId) {
                requestParams.dashboardId = dashboardId
            }
            return APIXHRService("POST", API_PATH + "dashboards/insights/copy", requestParams);
        },
        makeListed: function(projectKey, insightIds, listed) {
        	return APIXHRService("POST", API_PATH + "dashboards/insights/make-listed", { projectKey: projectKey, insightIds: JSON.stringify(insightIds), listed: listed });
        },
        getMissingReaderAuthorizations: function(projectKey, insightIds) {
            return APIXHRService("GET", API_PATH + "dashboards/insights/get-missing-reader-authorizations", { projectKey: projectKey, insightIds: JSON.stringify(insightIds) });
        }
    }
},

webapps : {
    listTypes: function() {
        return APIXHRService("GET", API_PATH + "webapps/list-types", {});
    },
    save: function(webAppData, commitMessage, forceRestartBackend) {
        return APIXHRService("POST", API_PATH + "webapps/save", {
            webAppData: JSON.stringify(webAppData),
            commitMessage: commitMessage,
            forceRestartBackend: forceRestartBackend
        });
    },
    saveMetadata: function(webAppData) {
        return APIXHRService("POST", API_PATH + "webapps/save-metadata", {
            webAppData: JSON.stringify(webAppData)
        });
    },
    create: function(projectKey, name, type, templateDesc, config) {
        return APIXHRService("POST", API_PATH + "webapps/create", { projectKey: projectKey, name: name, type: type, templateDesc: JSON.stringify(templateDesc), config: JSON.stringify(config)});
    },
    copy: function(projectKey, webAppId, newWebAppName) {
        return APIXHRService("POST", API_PATH + "webapps/copy", {
            projectKey: projectKey,
            webAppId: webAppId,
            newWebAppName: newWebAppName
        });
    },
    listTemplates: function(type, language) {
        return APIXHRService("GET", API_PATH + "webapps/list-templates", { type: type });
    },
    list: function(projectKey) {
        return APIXHRService("GET", API_PATH + "webapps/list", { projectKey: projectKey });
    },
    listHeads: function(projectKey, tagFilter) {
        return APIXHRService("GET", API_PATH + "webapps/list-heads", {projectKey: projectKey, tagFilter: tagFilter});
    },
    getFullInfo: function(projectKey, webAppId) {
        return APIXHRService("GET", API_PATH + "webapps/get-full-info", { projectKey: projectKey, webAppId: webAppId });
    },
    getSummary: function(projectKey, webAppId) {
        return APIXHRService("GET", API_PATH + "webapps/get-summary", { projectKey: projectKey, webAppId: webAppId });
    },
    getPreviewAndState: function(webApp) {
        return APIXHRService("GET", API_PATH + "webapps/get-preview-and-state", {projectKey: webApp.projectKey, webAppId: webApp.id});
    },
    getPreviewURL: function(webApp) {
        return API_PATH + "webapps/preview?projectKey=" + webApp.projectKey + "&webAppId=" + webApp.id;
    },
    getBackendUrl: function(projectKey, webAppId, apiKey) {
        return APIXHRService("GET", API_PATH + "webapps/get-backend-url", {projectKey: projectKey, webAppId: webAppId, apiKey: apiKey});
    },
    getBackendState: function(webApp) {
        return APIXHRService("GET", API_PATH + "webapps/get-backend-state", {projectKey: webApp.projectKey, webAppId: webApp.id});
    },
    restartBackend: function(webApp) {
        return APIXHRService("POST", API_PATH + "webapps/restart-backend", {projectKey: webApp.projectKey, webAppId: webApp.id});
    },
    stopBackend: function(webApp) {
        return APIXHRService("POST", API_PATH + "webapps/stop-backend", {projectKey: webApp.projectKey, webAppId: webApp.id});
    },
    startTensorboard: function(projectKey, analysisId, taskId, sessionId ) {
        return APIXHRService("POST", API_PATH + "webapps/webapp-start-tensorboard", {projectKey: projectKey, analysisId: analysisId, taskId:taskId, sessionId: sessionId});
    },
    setDatasetPrivileges: function(projectKey, apiKey, data) {
        return APIXHRService("POST", API_PATH + "webapps/set-apikey-dataset-privileges", {
            projectKey: projectKey, apiKey: apiKey,
            data: JSON.stringify(data)
        })
    },
    getDatasetPrivileges: function(projectKey, apiKey) {
        return APIXHRService("POST", API_PATH + "webapps/get-apikey-dataset-privileges", {projectKey: projectKey, apiKey: apiKey})
    },
    listAllBackendsStates : function(){
        return APIXHRService("GET", API_PATH + "webapps/list-all-backends-states")
    },
    convertToCustom: function(projectKey, webappId, targetPluginId, newWebAppType, targetPluginMode) {
        return APIXHRService("GET", API_PATH + "webapps/convert-to-custom", {projectKey, webappId, targetPluginId, newWebAppType, targetPluginMode});
    },
    getOrCreatePluginSkin: function(projectKey, objectType, objectId, webAppType, webAppConfig, webAppId) {
        return APIXHRService("POST", API_PATH + "webapps/get-or-create-plugin-skin", {
            projectKey: projectKey,
            objectType: objectType,
            objectId: objectId,
            webAppType: webAppType,
            webAppConfig: JSON.stringify(webAppConfig),
            webAppId: webAppId
        });
    },
    getBackendLogURL: function(projectKey, webAppId) {
        return API_PATH + "webapps/backend-log?"
                 + "projectKey=" + encodeURIComponent(projectKey)
                 + "&webAppId=" + encodeURIComponent(webAppId);
    },
},
reports : {
    create: function(projectKey, name, templateDesc) {
        return APIXHRService("POST", API_PATH + "reports/create", {
            projectKey: projectKey,
            name: name,
            templateDesc: JSON.stringify(templateDesc)
        });
    },
    list: function(projectKey) {
        return APIXHRService("GET", API_PATH + "reports/list", { projectKey: projectKey });
    },
    listHeads: function(projectKey, tagFilter) {
        return APIXHRService("GET", API_PATH + "reports/list-heads", {
            projectKey: projectKey,
            tagFilter: tagFilter
        });
    },
    listTemplates: function(type) {
        return APIXHRService("GET", API_PATH + "reports/list-templates", { type: type });
    },
    getSummary: function(projectKey, id) {
        return APIXHRService("GET", API_PATH + "reports/get-summary", {
            projectKey: projectKey,
            id: id
        });
    },
    getFullInfo: function(projectKey, id) {
        return APIXHRService("GET", API_PATH + "reports/get-full-info", {
            projectKey: projectKey,
            id: id
        });
    },
    save: function(report, script, commitMessage) {
        return APIXHRService("POST", API_PATH + "reports/save", {
            reportData: JSON.stringify(report),
            script: script,
            commitMessage: commitMessage
        });
    },
    saveMetadata: function(report) {
        return APIXHRService("POST", API_PATH + "reports/save-metadata", {
            reportData: JSON.stringify(report)
        });
    },
    copy: function(projectKey, id, newName) {
        return APIXHRService("POST", API_PATH + "reports/copy", {
            projectKey: projectKey,
            id: id,
            newName: newName
        });
    },
    build: function(projectKey, id) {
        return APIXHRService("POST", API_PATH + "reports/build", {
            projectKey: projectKey,
            id: id
        });
    },
    prepareDownload: function(projectKey, id, format) {
        return APIXHRService("POST", API_PATH + "reports/prepare-download", {
            projectKey: projectKey,
            id: id,
            format: format
        });
    },
    getDownloadReportURL: function(projectKey, id, format) {
        return API_PATH + "reports/download?projectKey=" + encodeURIComponent(projectKey) + "&id=" + encodeURIComponent(id) + "&format=" + encodeURIComponent(format) ;
    },
    snapshots: { // Should mostly stay in sync with jupyterNotebooks.export
        create: function(projectKey, reportId) {
            return APIXHRService("POST", API_PATH + "reports/snapshots/create", {
                projectKey: projectKey,
                reportId: reportId
            });
        },
        list: function(projectKey, reportId) {
            return APIXHRService("GET", API_PATH + "reports/snapshots/list", {
                projectKey: projectKey,
                reportId: reportId
            });
        },
        listForAll: function(projectKey) {
            return APIXHRService("GET", API_PATH + "reports/snapshots/list-for-all", {
                projectKey: projectKey
            });
        },
        get: function(projectKey, id, timestamp) {
            return APIXHRService("GET", API_PATH + "reports/snapshots/get", {
                projectKey: projectKey,
                id: id,
                timestamp: timestamp
            });
        }
    }
},
runnables: {
    manualRun: function(projectKey, runnableType, params, adminParams) {
        return APIXHRService("POST", API_PATH + "runnables/manual-run", {
            projectKey: projectKey, runnableType: runnableType, params: JSON.stringify(params), adminParams: JSON.stringify(adminParams)
        });
    },
    clusterRun: function(clusterId, runnableType, params, adminParams) {
        return APIXHRService("POST", API_PATH + "runnables/cluster-run", {
            clusterId: clusterId, runnableType: runnableType, params: JSON.stringify(params), adminParams: JSON.stringify(adminParams)
        });
    },
    projectCreationRun: function(runnableType, params, projectFolderId) {
        return APIXHRService("POST", API_PATH + "runnables/project-creation-run", {
            runnableType: runnableType, params: JSON.stringify(params), projectFolderId: projectFolderId
        });
    },
    insightRun: function(projectKey, insightId) {
        return APIXHRService("GET", API_PATH + "runnables/insight-run", {
            projectKey: projectKey, insightId: insightId
        });
    },
    loadKeptFile: function(projectKey, runnableType, item, clusterId) {
        return APIXHRService("GET", API_PATH + "runnables/load-kept-file", {
            projectKey: projectKey,
            clusterId: clusterId,
            runnableType: runnableType,
            item: JSON.stringify(item)
        });
    },
    getDownloadURL: function(projectKey, runnableType, item, clusterId) {
        return API_PATH + "runnables/download-kept-file?"
                 + "projectKey=" + encodeURIComponent(projectKey)
                 + "&clusterId=" + encodeURIComponent(clusterId)
                 + "&runnableType=" + encodeURIComponent(runnableType)
                 + "&item=" + encodeURIComponent(JSON.stringify(item));
    },
    listAccessible: function(projectKey) {
        return APIXHRService("GET", API_PATH + "runnables/list-accessible", {
            projectKey: projectKey
        });
    }
},
scenarios: {
    list: function(projectKey) {
        return APIXHRService("GET", API_PATH + "scenarios/list", {
            projectKey: projectKey
        });
    },
    listAccessible: function(projectKey) {
        return APIXHRService("GET", API_PATH + "scenarios/list-accessible");
    },
    listHeads: function(projectKey) {
        return APIXHRService("GET", API_PATH + "scenarios/list-heads", {
            projectKey: projectKey
        });
    },
    listAllHeads: function() {
        return APIXHRService("GET", API_PATH + "scenarios/list-all-heads");
    },
    listAllReporters: function() {
        return APIXHRService("GET", API_PATH + "scenarios/list-all-reporters");
    },
    get: function(projectKey, scenarioId) {
        return APIXHRService("GET", API_PATH + "scenarios/get", {
            projectKey: projectKey,
            scenarioId: scenarioId
        });
    },
    getSummary: function(projectKey, scenarioId) {
        return APIXHRService("GET", API_PATH + "scenarios/get-summary", {
            projectKey: projectKey,
            scenarioId: scenarioId
        });
    },
	getScript: function(projectKey, scenarioId) {
		return APIXHRService("GET", API_PATH + "scenarios/get-script", {
			projectKey: projectKey,
			scenarioId: scenarioId
		});
	},
	manualRun: function(projectKey, smartScenarioId, params, waitForStart, waitForCompletion) {
		return APIXHRService("POST", API_PATH + "scenarios/manual-run", {
			projectKey: projectKey,
			smartScenarioId: smartScenarioId,
            params: JSON.stringify(params),
            waitForStart: waitForStart,
            waitForCompletion: waitForCompletion
		});
	},
	create: function(projectKey, data) {
		return APIXHRService("GET", API_PATH + "scenarios/create", {
			projectKey: projectKey,
			data: JSON.stringify(data)
		});
	},
	duplicate: function(projectKeyFrom,projectKeyTo,idFrom,idTo, name) {
        return APIXHRService("POST", API_PATH + "scenarios/duplicate", {
            projectKeyFrom: projectKeyFrom,
            projectKeyTo: projectKeyTo,
            idFrom: idFrom,
            idTo: idTo,
            name: name
        });
    },
    save: function(projectKey, data, scriptData, saveInfo) {
        return APIXHRService("POST", API_PATH + "scenarios/save", {
            projectKey: projectKey,
            data: JSON.stringify(data),
            scriptData: scriptData,
            saveInfo: JSON.stringify(saveInfo)
        });
    },
    saveNoParams: function(projectKey, data, saveInfo) {
        return APIXHRService("POST", API_PATH + "scenarios/save-no-params", {
            projectKey: projectKey,
            data: JSON.stringify(data),
            saveInfo: JSON.stringify(saveInfo)
        });
    },
    saveReporterState: function(projectKey, scenarioId, data, saveInfo) {
        return APIXHRService("POST", API_PATH + "scenarios/save-reporter-state", {
            projectKey: projectKey,
            scenarioId: scenarioId,
            data: JSON.stringify(data),
            saveInfo: JSON.stringify(saveInfo)
        });
    },
    deleteReporter: function(projectKey, scenarioId, data, saveInfo) {
        return APIXHRService("POST", API_PATH + "scenarios/delete-reporter", {
            projectKey: projectKey,
            scenarioId: scenarioId,
            data: JSON.stringify(data),
            saveInfo: JSON.stringify(saveInfo)
        });
    },
	getLastScenarioRuns: function(projectKey, smartScenarioId, withFullScenario, limit) {
		return APIXHRService("GET", API_PATH + "scenarios/get-last-scenario-runs", {
			projectKey: projectKey,
			smartScenarioId: smartScenarioId,
            withFullScenario: withFullScenario,
            limit: limit
		});
	},
	getScenarioRunDetails: function(projectKey, scenarioId, runId) {
		return APIXHRService("GET", API_PATH + "scenarios/get-scenario-run-details", {
			projectKey: projectKey,
			scenarioId: scenarioId,
			runId: runId
		});
	},
	getLastTriggerRuns: function(projectKey, scenarioId) {
		return APIXHRService("GET", API_PATH + "scenarios/get-last-trigger-runs", {
			projectKey: projectKey,
			scenarioId: scenarioId
		});
	},
	getScenarioReport: function(projectKey, scenarioId, fromDate, toDate) {
		return APIXHRService("GET", API_PATH + "scenarios/get-scenario-report", {
			projectKey: projectKey,
			scenarioId: scenarioId,
            fromDate: fromDate,
            toDate: toDate
		});
	},
    getProjetReport: function(projectKey, fromDate, toDate) {
        return APIXHRService("GET", API_PATH + "scenarios/get-project-report", {
            projectKey: projectKey,
            fromDate: fromDate,
            toDate: toDate
        });
    },
    getInstanceReport: function(fromDate, toDate) {
        return APIXHRService("GET", API_PATH + "scenarios/get-instance-report", {
            fromDate: fromDate,
            toDate: toDate
        });
    },
	getProjetActivities: function(projectKey, fromDate, toDate) {
		return APIXHRService("GET", API_PATH + "scenarios/get-project-activities", {
			projectKey: projectKey,
			fromDate: fromDate,
			toDate: toDate
		});
	},
    getOutcomes: function(fromDate, toDate, projectKey, scenarioId) {
        return APIXHRService("GET", API_PATH + "scenarios/get-outcomes", {
            projectKey: projectKey,
            scenarioId: scenarioId,
            fromDate: fromDate,
            toDate: toDate
        });
    },
    getOutcomesSummary: function(projectKey, fromDate, toDate) {
        return APIXHRService("GET", API_PATH + "scenarios/get-outcomes-summary", {
            projectKey: projectKey,
            fromDate: fromDate,
            toDate: toDate
        });
    },
    getOutcomesDetails: function(projectKey, scenarioId, date) {
        return APIXHRService("GET", API_PATH + "scenarios/get-outcomes-details", {
            projectKey: projectKey,
            scenarioId: scenarioId,
            date: date
        });
    },
    getRunDiagnosisURL: function(projectKey, scenarioId, runId) {
        return API_PATH + "scenarios/download-run-diagnosis?"
                 + "projectKey=" + encodeURIComponent(projectKey)
                 + "&scenarioId=" + encodeURIComponent(scenarioId)
                 + "&runId=" + encodeURIComponent(runId);
    },
    getRunLogURL: function(projectKey, scenarioId, runId) {
        return API_PATH + "scenarios/run-log?"
                 + "projectKey=" + encodeURIComponent(projectKey)
                 + "&scenarioId=" + encodeURIComponent(scenarioId)
                 + "&runId=" + encodeURIComponent(runId);
    },
    getStepRunLogURL: function(projectKey, scenarioId, runId, stepRunId) {
        return API_PATH + "scenarios/step-run-log?"
                 + "projectKey=" + encodeURIComponent(projectKey)
                 + "&scenarioId=" + encodeURIComponent(scenarioId)
                 + "&runId=" + encodeURIComponent(runId)
                 + "&stepRunId=" + encodeURIComponent(stepRunId);
    },
    listReportTemplates: function() {
        return APIXHRService("GET", API_PATH + "scenarios/list-report-templates", {
        });
    },
    loadKeptFile: function(projectKey, scenarioId, runId, stepName, item) {
        return APIXHRService("GET", API_PATH + "scenarios/load-kept-file", {
            projectKey: projectKey,
            scenarioId: scenarioId,
            runId: runId,
            stepName: stepName,
            item: JSON.stringify(item)
        });
    },
    getDownloadURL: function(projectKey, scenarioId, runId, stepName, item) {
        return API_PATH + "scenarios/download-kept-file?"
                 + "projectKey=" + encodeURIComponent(projectKey)
                 + "&scenarioId=" + encodeURIComponent(scenarioId)
                 + "&runId=" + encodeURIComponent(runId)
                 + "&stepName=" + encodeURIComponent(stepName)
                 + "&item=" + encodeURIComponent(JSON.stringify(item));
    },
    addToScenario: function(items, options) {
        return APIXHRService("POST", API_PATH + "scenarios/add-to-scenario", {
            items: JSON.stringify(items),
            options: JSON.stringify(options)
        });
    },
},
lambda: {
    services: {
        list: function(projectKey) {
            return APIXHRService("GET", API_PATH + "lambda-services/list", {
                projectKey: projectKey
            });
        },
        listHeads: function(projectKey) {
            return APIXHRService("GET", API_PATH + "lambda-services/list-heads", {
              projectKey
            });
        },
        getSummary: function(projectKey, id) {
            return APIXHRService("GET", API_PATH + "lambda-services/get-summary", {
                projectKey: projectKey,
                id: id
            });
        },
        deleteMulti: function(requests, contextProjectKey) {
            return APIXHRService("POST", API_PATH + "lambda-services/delete-multi/", {
                requests: JSON.stringify(requests),
                contextProjectKey: contextProjectKey
            });
        },
        create: function(projectKey, id) {
            return APIXHRService("POST", API_PATH + "lambda-services/create", {
                projectKey: projectKey,
                id: id
            });
        },
        save: function(projectKey, service) {
            return APIXHRService("POST", API_PATH + "lambda-services/save", {
                projectKey: projectKey,
                service: JSON.stringify(service)
            });
        },
        addEndpoint: function(projectKey, serviceId, createService, endpoint) {
            return APIXHRService("POST", API_PATH + "lambda-services/add-endpoint", {
                projectKey: projectKey,
                serviceId: serviceId,
                createService: createService,
                endpoint: angular.toJson(endpoint)
            });
        },
        startPreparePackage: function(projectKey, serviceId, packageId) {
            return APIXHRService("POST", API_PATH + "lambda-services/packages/start-prepare", {
                projectKey: projectKey,
                serviceId: serviceId,
                packageId: packageId
            });
        },
        deployDev: function(projectKey, id) {
            return APIXHRService("POST", API_PATH + "lambda-services/deploy-to-dev", {
                projectKey: projectKey,
                id: id
            });
        },
        playTestQueries: function(projectKey, serviceId, endpointId, testType, queries) {
            return APIXHRService("POST", API_PATH + "lambda-services/play-test-queries", {
                projectKey: projectKey,
                serviceId: serviceId,
                endpointId: endpointId,
                testType: testType,
                queries: JSON.stringify(queries)
            });
        },
        getSampleQueriesFromDataset: function(projectKey, datasetName, modelRef, batchSize=1, method="HEAD_SEQUENTIAL") {
            return APIXHRService("GET", API_PATH + "lambda-services/get-sample-queries", {
                projectKey: projectKey,
                datasetName: datasetName,
                modelRef: modelRef,
                batchSize: batchSize,
                method: method
            });
        }
    },
    packages: {
        list: function(projectKey, serviceId) {
            return APIXHRService("GET", API_PATH + "lambda-services/packages", {
                projectKey: projectKey,
                serviceId: serviceId
            });
        },
        delete: function(projectKey, serviceId, packageId) {
            return APIXHRService("POST", API_PATH + "lambda-services/package/delete", {
                projectKey: projectKey,
                serviceId: serviceId,
                packageId: packageId
            });
        },
        publishToAPIDeployer: function(projectKey, serviceId, packageId, publishedServiceId) {
            return APIXHRService("POST", API_PATH + "lambda-services/package/publish-to-api-deployer", {
                projectKey: projectKey,
                serviceId: serviceId,
                packageId: packageId,
                publishedServiceId: publishedServiceId
            });
        }
    },
    devServer: {
        getStatus: APIXHRService.bind(null, "GET",    API_PATH + "lambda-devserver"),
        start:     APIXHRService.bind(null, "POST",   API_PATH + "lambda-devserver"),
        stop:      APIXHRService.bind(null, "DELETE", API_PATH + "lambda-devserver")
    }
},
exports: {
    list: function() {
        return APIXHRService("GET", API_PATH + "exports/list", {},"nospinner");
    },
    remove: function(exportId) {
        return APIXHRService("POST", API_PATH + "exports/remove", {exportId: exportId});
    },
    getDownloadURL: function(exportId) {
        return API_PATH + "exports/download/?exportId=" + encodeURIComponent(exportId);
    },
    clear: function() {
        return APIXHRService("POST", API_PATH + "exports/clear");
    },
    create: function(name, params) {
        return APIXHRService("POST", API_PATH + "exports/create", {name: name, params: JSON.stringify(params)});
    },
    getOptions: function() {
        return APIXHRService("GET", API_PATH + "exports/get-export-options");
    },
    exportUIData: function(data, params) {
        return APIXHRService("POST", API_PATH + "exports/export-ui-data", {
            data: JSON.stringify(data),
            params: JSON.stringify(params)
        });
    }
},
notebooks: {
    listTemplates: function(type, language) {
        return APIXHRService("GET", API_PATH + "notebooks/list-templates", {
            type: type, language: language
        });
    }
},
sqlNotebooks: {
    abort: function(projectKey, notebookId, cellId, qid) {
        return APIXHRService("POST", API_PATH + "sql-notebooks/abort", {projectKey: projectKey, notebookId: notebookId, cellId: cellId, qid: qid});
    },
    clearHistory: function(projectKey, notebookId, cellId) {
        return APIXHRService("POST", API_PATH + "sql-notebooks/clear-history/", {
            projectKey: projectKey,
            notebookId: notebookId,
            cellId: cellId
        }, "nospinner");
    },
    computeFullCount: function(projectKey, notebookId, cellId, qid) {
        return APIXHRService("POST", API_PATH + "sql-notebooks/full-count/", {
            projectKey: projectKey,
            notebookId: notebookId,
            cellId: cellId,
            qid: qid
        }, "nospinner");
    },
    copy: function(projectKey, notebookId, newNotebookName) {
        return APIXHRService("POST", API_PATH + "sql-notebooks/copy/", {projectKey: projectKey, notebookId: notebookId, newNotebookName: newNotebookName});
    },
    create: function(projectKey, connection, name) {
        return APIXHRService("POST", API_PATH + "sql-notebooks/create/", {projectKey: projectKey, connection: connection, name: name});
    },
    exportResults: function(projectKey, notebookId, cellId, queryId, params) {
        return APIXHRService("POST", API_PATH + "sql-notebooks/export-results/", {
            projectKey: projectKey,
            notebookId: notebookId,
            cellId: cellId,
            qid: queryId,
            params: JSON.stringify(params)
        });
    },
    get: function(projectKey, id) {
        return APIXHRService("GET", API_PATH + "sql-notebooks/get/", {projectKey: projectKey, id: id});
    },
    getSummary: function(projectKey, id) {
        return APIXHRService("GET", API_PATH + "sql-notebooks/get-summary/", {projectKey: projectKey, id: id});
    },
    getHistory: function(projectKey, notebookId) {
        return APIXHRService("GET", API_PATH + "sql-notebooks/get-history/", {projectKey: projectKey, notebookId: notebookId});
    },
    getCellHistory: function(projectKey, notebookId, cellId) {
        return APIXHRService("GET", API_PATH + "sql-notebooks/get-cell-history/", {projectKey: projectKey, notebookId: notebookId, cellId: cellId});
    },
    getHistoryResult: function(projectKey, notebookId, qid) {
        return APIXHRService("POST", API_PATH + "sql-notebooks/get-history-result/", {
            projectKey: projectKey,
            notebookId: notebookId,
            qid: qid
        }, "nospinner");
    },
    createForDataset: function(projectKey, datasetSmartName, type, name) {
        return APIXHRService("POST", API_PATH + "sql-notebooks/create-for-dataset/", {
            projectKey: projectKey,
            datasetSmartName: datasetSmartName,
            type: type,
            name: name
        });
    },
    getProgress: function(projectKey, notebookId, cellId, qid) {
        return APIXHRService("POST", API_PATH + "sql-notebooks/get-progress", {
            projectKey: projectKey,
            notebookId: notebookId,
            cellId: cellId,
            qid: qid
        }, "nospinner");
    },
    listHeads: function(projectKey, tagFilter) {
        return APIXHRService("GET", API_PATH + "sql-notebooks/list-heads/", {projectKey: projectKey, tagFilter: tagFilter});
    },
    listConnections: function(projectKey) {
        return APIXHRService("GET", API_PATH + "sql-notebooks/list-connections/", {projectKey:projectKey});
    },
    removeQuery: function(projectKey, notebookId, cellId, qid) {
        return APIXHRService("POST", API_PATH + "sql-notebooks/remove-query/", {projectKey: projectKey, notebookId: notebookId, cellId: cellId, qid: qid});
    },
    run: function(projectKey, notebookId, cellId, query, fullCount) {
        return APIXHRService("POST", API_PATH + "sql-notebooks/run/", {
            projectKey: projectKey,
            notebookId: notebookId,
            cellId: cellId,
            queryData: JSON.stringify(query),
            fullCount: fullCount
        }, "nospinner");
    },
    getExecutionPlan: function(projectKey, query) {
        return APIXHRService("POST", API_PATH + "sql-notebooks/get-execution-plan", {
            projectKey: projectKey,
            queryData: JSON.stringify(query)
        });
    },
    save: function(notebook) {
        return APIXHRService("POST", API_PATH + "sql-notebooks/save/", {notebook: angular.toJson(notebook)}, "nospinner");
    },
    testStreamedExport: function(projectKey, notebookId, cellId, qid) {
        return APIXHRService("POST", API_PATH + "sql-notebooks/test-streamed-export/", {
            projectKey: projectKey,
            notebookId: notebookId,
            cellId: cellId,
            qid: qid
        });
    }
},
explores: {
    getScript: function(projectKey, datasetSmartName) {
        return APIXHRService("GET", API_PATH + "explores/get-script", {projectKey: projectKey, datasetSmartName: datasetSmartName});
    },
    saveScript: function(projectKey, datasetSmartName, script) {
        return APIXHRService("POST", API_PATH + "explores/save-script", {
            projectKey: projectKey, datasetSmartName: datasetSmartName,
            script: angular.toJson(script)
        });
    },
    getCaptureScript: function(projectKey, streamingEndpointId) {
        return APIXHRService("GET", API_PATH + "explores/get-capture-script", {projectKey: projectKey, streamingEndpointId: streamingEndpointId});
    },
    saveCaptureScript: function(projectKey, streamingEndpointId, script) {
        return APIXHRService("POST", API_PATH + "explores/save-capture-script", {
            projectKey: projectKey, streamingEndpointId: streamingEndpointId,
            script: angular.toJson(script)
        });
    },
    get: function(projectKey, datasetSmartName) {
        return APIXHRService("GET", API_PATH + "explores/get", {projectKey: projectKey, datasetSmartName: datasetSmartName});
    },
    save: function(projectKey, datasetSmartName, data) {
        return APIXHRService("POST", API_PATH + "explores/save", {
            projectKey: projectKey, datasetSmartName: datasetSmartName,
            data: angular.toJson(data)
        });
    },
    setExploreOnSinglePartition: function(projectKey, datasetName, partitionId) {
         return APIXHRService("POST", API_PATH + "explores/set-explore-on-single-partition/", {
            projectKey: projectKey,
            datasetName: datasetName,
            partitionId: partitionId
        });
    },
    setColumnMeaning: function(projectKey, datasetName, columnName, meaning) {
        return APIXHRService("POST", API_PATH + "explores/set-column-meaning/", {
            projectKey: projectKey,
            datasetName: datasetName,
            columnName: columnName,
            meaning: meaning
        });
    },
    setColumnsMeanings: function(data) {
        return APIXHRService("POST", API_PATH + "explores/set-columns-meanings/", {data: JSON.stringify(data)});
    },
    setColumnStorageType: function(projectKey, datasetName, columnName, storageType, actionIds) {
        return APIXHRService("POST", API_PATH + "explores/set-column-storage-type/", {
            projectKey: projectKey, datasetName: datasetName,
            columnName: columnName, storageType: storageType, actionIds: JSON.stringify(actionIds)
        });
    },
    getSetColumnStorageTypeImpact: function(projectKey, datasetName, columnName, storageType) {
        return APIXHRService("POST", API_PATH + "explores/get-set-column-storage-type-impact/", {
            projectKey: projectKey, datasetName: datasetName,
            columnName: columnName, storageType: storageType
        });
    },
    updateColumn: function(projectKey, datasetName, column) {
        return APIXHRService("POST", API_PATH + "explores/update-column", {
            projectKey: projectKey, datasetName: datasetName,
            column: JSON.stringify(column)
        });
    },
    listPluginChartDescs: function(projectKey) {
        return APIXHRService("GET", API_PATH + "explores/list-plugin-chart-descs", {
            projectKey: projectKey
        });
    },
    getOrCreatePluginChart: function(projectKey, datasetSmartName, chartDef, webAppId) {
        return APIXHRService("POST", API_PATH + "explores/get-or-create-plugin-chart", {
            projectKey: projectKey,
            datasetSmartName: datasetSmartName,
            webAppId: webAppId,
            chartDef: JSON.stringify(chartDef)
        });
    },
    getChartEngines: function(dataset, script, chartDef) {
        return APIXHRService("GET", API_PATH + "explores/get-chart-engines", {projectKey: dataset.projectKey, datasetName: dataset.name, script: JSON.stringify(script), chartDef: JSON.stringify(chartDef)});
    },
},
shakers: {
    multiColumnAnalysis: function(contextProjectKey, projectKey, datasetName, streamingEndpointId, data, requestedSampleId, columns, compute, histogram) {
        return APIXHRService("POST", API_PATH + "shaker/multi-column-analysis/", {
            contextProjectKey: contextProjectKey,
            projectKey: projectKey,
            datasetName: datasetName,
            streamingEndpointId: streamingEndpointId,
            data: JSON.stringify(data),
            requestedSampleId: requestedSampleId,
            columns: columns,
            compute: compute,
            histogram: histogram || 1
        });
    },
	multiColumnFullAnalysis: function(contextProjectKey, projectKey, datasetName, data, fullSamplePartitionId, columns) {
		return APIXHRService("POST", API_PATH + "shaker/multi-column-full-analysis/", {
            contextProjectKey: contextProjectKey,
			projectKey: projectKey,
			datasetName: datasetName,
			data: JSON.stringify(data),
			fullSamplePartitionId: fullSamplePartitionId,
			columns: columns
		});
	},
    detailedColumnAnalysis: function(contextProjectKey, projectKey, datasetName, data, requestedSampleId, column, alphanumMaxResults, fullSamplePartitionId, withFullSampleStatistics) {
        return APIXHRService("POST", API_PATH + "shaker/detailed-column-analysis/", {
            contextProjectKey: contextProjectKey,
            projectKey: projectKey,
            datasetName: datasetName,
            data: JSON.stringify(data),
            requestedSampleId: requestedSampleId,
            column: column,
            alphanumMaxResults : alphanumMaxResults,
            fullSamplePartitionId : fullSamplePartitionId,
            withFullSampleStatistics: withFullSampleStatistics
        });
    },
    detailedStreamingColumnAnalysis: function(contextProjectKey, projectKey, streamingEndpointId, data, requestedSampleId, column, alphanumMaxResults, fullSamplePartitionId, withFullSampleStatistics) {
        // same call, different parameters
        return APIXHRService("POST", API_PATH + "shaker/detailed-column-analysis/", {
            contextProjectKey: contextProjectKey,
            projectKey: projectKey,
            streamingEndpointId: streamingEndpointId,
            data: JSON.stringify(data),
            requestedSampleId: requestedSampleId,
            column: column,
            alphanumMaxResults : alphanumMaxResults,
            fullSamplePartitionId : fullSamplePartitionId,
            withFullSampleStatistics: withFullSampleStatistics
        });
    },
    textAnalysis: function(contextProjectKey, projectKey, datasetName, data, requestedSampleId, column, simplificationParameters) {
        return APIXHRService("POST", API_PATH + "shaker/text-analysis/", {
            contextProjectKey: contextProjectKey,
            projectKey: projectKey,
            datasetName: datasetName,
            data: JSON.stringify(data),
            requestedSampleId: requestedSampleId,
            column: column,
            simplificationParameters: JSON.stringify(simplificationParameters)
        });
    },
    smartExtractor: function(contextProjectKey, projectKey, datasetName, data, requestedSampleId, column, selections, excluded, customRegex, onColumnNames, firstSentence, filters) {
        return APIXHRService("POST", API_PATH + "shaker/smart-extractor/", {
            contextProjectKey: contextProjectKey,
            projectKey: projectKey,
            datasetName: datasetName,
            data : JSON.stringify(data),
            requestedSampleId: requestedSampleId,
            column: column,
            selections: JSON.stringify(selections),
            excluded: JSON.stringify(excluded),
            customRegex: customRegex || "",
            onColumnNames: JSON.stringify(onColumnNames),
            firstString: firstSentence,
            filters: JSON.stringify(filters)
        });
    },
    smartDateGuess: function(contextProjectKey, projectKey, datasetName, data, requestedSampleId, column) {
        return APIXHRService("POST", API_PATH + "shaker/smart-date-guess/", {
            contextProjectKey: contextProjectKey,
            projectKey: projectKey,
            datasetName: datasetName,
            data : JSON.stringify(data),
            requestedSampleId: requestedSampleId,
            column: column
        });
    },
    smartDateValidate: function(contextProjectKey, projectKey, datasetName, data, requestedSampleId, column, format) {
        return APIXHRService("POST", API_PATH + "shaker/smart-date-validate/", {
            contextProjectKey: contextProjectKey,
            projectKey: projectKey,
            datasetName: datasetName,
            data: JSON.stringify(data),
            requestedSampleId: requestedSampleId,
            column: column,
            format: format
        });
    },
    suggestionPreview: function(contextProjectKey, projectKey, datasetName, data, requestedSampleId, column, regex) {
        return APIXHRService("POST", API_PATH + "shaker/suggestion-preview/", {
            contextProjectKey: contextProjectKey,
            projectKey: projectKey,
            datasetName: datasetName,
            data: JSON.stringify(data),
            requestedSampleId: requestedSampleId,
            column: column,
            regex: regex
        });
    },
    refreshTable: function(contextProjectKey, projectKey, datasetName, data, requestedSampleId, allowCache, filters, recipeSchema) {
        return APIXHRService("POST", API_PATH + "shaker/refresh-table/", {
            contextProjectKey: contextProjectKey,
            projectKey: projectKey,
            datasetName: datasetName,
            data : JSON.stringify(data),
            requestedSampleId: requestedSampleId,
            allowCache: allowCache,
            filters: JSON.stringify(filters),
            recipeSchema: recipeSchema == null ? null : JSON.stringify(recipeSchema)
        });
    },
    refreshCapture: function(contextProjectKey, projectKey, streamingEndpointId, data, requestedSampleId, allowCache, filters, recipeSchema) {
        return APIXHRService("POST", API_PATH + "shaker/refresh-capture/", {
            contextProjectKey: contextProjectKey,
            projectKey: projectKey,
            streamingEndpointId: streamingEndpointId,
            data : JSON.stringify(data),
            requestedSampleId: requestedSampleId,
            allowCache: allowCache,
            filters: JSON.stringify(filters),
            recipeSchema: recipeSchema == null ? null : JSON.stringify(recipeSchema)
        });
    },
    getClusters: function(contextProjectKey, projectKey, datasetName, data, requestedSampleId, column, setBased, radius, timeOut, blockSize) {
        return APIXHRService("POST", API_PATH + "shaker/get-clusters/", {
            contextProjectKey: contextProjectKey,
            projectKey: projectKey,
            datasetName: datasetName,
            data : JSON.stringify(data),
            requestedSampleId: requestedSampleId,
            column: column,
            setBased: setBased,
            radius: radius,
            timeOut: timeOut,
            blockSize: blockSize
        });
    },
    getTableChunk: function(contextProjectKey, projectKey, datasetName, data, requestedSampleId, firstRow, nbRows, firstCol, nbCols, filters) {
        return APIXHRService("POST", API_PATH + "shaker/get-table-chunk/", {
            contextProjectKey: contextProjectKey,
            projectKey: projectKey,
            datasetName: datasetName,
            data : JSON.stringify(data),
            requestedSampleId: requestedSampleId,
            firstRow: firstRow,
            nbRows: nbRows,
            firstCol: firstCol,
            nbCols: nbCols,
            filters: JSON.stringify(filters)
        });
    },
    getCaptureChunk: function(contextProjectKey, projectKey, streamingEndpointId, data, requestedSampleId, firstRow, nbRows, firstCol, nbCols, filters) {
        return APIXHRService("POST", API_PATH + "shaker/get-capture-chunk/", {
            contextProjectKey: contextProjectKey,
            projectKey: projectKey,
            streamingEndpointId: streamingEndpointId,
            data : JSON.stringify(data),
            requestedSampleId: requestedSampleId,
            firstRow: firstRow,
            nbRows: nbRows,
            firstCol: firstCol,
            nbCols: nbCols,
            filters: JSON.stringify(filters)
        });
    },
    validateExpression: function(projectKey, datasetProjectKey, datasetName, data,
                                 requestedSampleId, expression, mode, column, stepId, subStepId, stepDepth) {
        return APIXHRService("POST", API_PATH + "shaker/validate-expression", {
            projectKey: projectKey,
            datasetProjectKey: datasetProjectKey,
            datasetName: datasetName,
            data: JSON.stringify(data),
            requestedSampleId:requestedSampleId,
            expression:expression,
            mode:mode,
            column:column,
            stepId: stepId,
            subStepId: subStepId,
            stepDepth: stepDepth
        });
    },
    fixExpression: function(projectKey, datasetProjectKey, datasetName, data,
        requestedSampleId, expression, mode, column, stepId, subStepId, stepDepth) {
        return APIXHRService("POST", API_PATH + "shaker/fix-expression", {
        projectKey: projectKey,
        datasetProjectKey: datasetProjectKey,
        datasetName: datasetName,
        data: JSON.stringify(data),
        requestedSampleId:requestedSampleId,
        expression:expression,
        mode:mode,
        column:column,
        stepId: stepId,
        subStepId: subStepId,
        stepDepth: stepDepth
        });
        },
    validateUdf: function(projectKey, datasetProjectKey, datasetName, data, requestedSampleId, expression, stepId, subStepId, stepDepth) {
        return APIXHRService("POST", API_PATH + "shaker/validate-udf", {
            projectKey: projectKey,
            datasetProjectKey: datasetProjectKey,
            datasetName: datasetName,
            data: JSON.stringify(data),
            requestedSampleId:requestedSampleId,
            udf:expression,
            stepId: stepId,
            subStepId: subStepId,
            stepDepth: stepDepth
        });
    },
    randomizeColors: function() {
        return APIXHRService("POST", API_PATH + "shaker/randomize-colors");
    },
    computeRelativeDateInterval: function(params) {
        return APIXHRService("POST", API_PATH + "shaker/compute-relative-date-interval", {
            params: JSON.stringify(params)
        });
    },
    /* Static data for the Shaker */
    getProcessorsLibrary: function() {
        return APIXHRService("GET", API_PATH + "shaker/get-processors-library/", {});
    },
    getCustomFormulasReference: function() {
        return APIXHRService("GET", API_PATH + "shaker/get-expression-syntax");
    },
    listCustomFormulasFunctions: function() {
        return APIXHRService("GET", API_PATH + "shaker/list-custom-formulas-functions");
    },
    charts: {
        getColumnsSummary: function(projectKey, dataSpec) {
            return APIXHRService("POST", API_PATH + "shaker/charts/get-columns-summary", {
                projectKey:projectKey,
                dataSpec: JSON.stringify(dataSpec)
            });
        },
        exportToExcel: function(chartDef, pivotResponse, animationFrameIdx) {
            var params = {
                chartDef:JSON.stringify(chartDef),
                pivotResponse: JSON.stringify(pivotResponse)
            };

            if (animationFrameIdx !== undefined) {
                params.animationFrameIdx = animationFrameIdx;
            }

            return APIXHRService("POST", API_PATH + "shaker/charts/excel-export", params);
        },
        downloadExcelUrl: function(id) {
            return API_PATH + "shaker/charts/excel-download/?id=" + encodeURIComponent(id);
        },
        getPivotResponse: function(projectKey, dataSpec, request, requestedSampleId) {
            return APIXHRService("POST", API_PATH + "shaker/charts/get-pivot-response", {
                projectKey: projectKey,
                dataSpec : JSON.stringify(dataSpec),
                request: JSON.stringify(request),
                requestedSampleId: requestedSampleId
            });
        }
    },
    getCorrelationResponse: function(shakerId, data, requestedSampleId) {
         return APIXHRService("POST", API_PATH + "shaker/charts/get-correlation-response", {
            shakerId: shakerId,
            data: JSON.stringify(data),
            requestedSampleId: requestedSampleId
        });
    },
    getLastKnownCurrencyRateDate: function() {
        return APIXHRService("GET", API_PATH + "shaker/get-last-known-currency-rate-date");
    }
},
connections: {
   getNames: function(type) {
        return APIXHRService("GET", API_PATH + "connections/get-names/", {type: type});
   },
   getTypeAndNames: function (connectionType) {
        return APIXHRService("GET", API_PATH + "connections/get-type-and-names", { connectionType: connectionType });
   },
   getHiveNames: function(projectKey) {
       return APIXHRService("GET", API_PATH + "connections/get-hive-names/", {projectKey:projectKey});
   },
   listUsages: function(projectKey) {
        return APIXHRService("GET", API_PATH + "connections/list-usages", {projectKey: projectKey});
   },
   listSQLTables: function(connectionName, projectKey) {
        return APIXHRService("GET", API_PATH + "connections/list-sql-tables", {connectionName:connectionName, projectKey:projectKey});
   },
   listSQLTablesFromProject: function(connectionName, projectKey) {
        return APIXHRService("GET", API_PATH + "connections/list-sql-tables-from-project", {connectionName:connectionName, projectKey:projectKey});
   },
   listSQLFields: function(name, tables, projectKey) {
       var x = {tables: tables};
        return APIXHRService("POST", API_PATH + "connections/list-sql-fields", {name:name, tables: JSON.stringify(x), projectKey:projectKey});
   },
   getSQLTableMapping: function(connection) {
       return APIXHRService("GET", API_PATH + "connections/get-sql-table-mapping", {connection:connection});
   },
   getTwitterConfig: function() {
       return APIXHRService("GET", API_PATH + "connections/get-twitter-config");
   },
   getFSLike: function() {
        // TODO TODO FIXME TODO TODO
        return APIXHRService("GET", API_PATH + "connections/get-names/", {type: "Filesystem"});
   },
    countIndexedAndUnindexed: function (data) {
        return APIXHRService("GET", API_PATH + "/connections/count-indexed-and-unindexed");
    },
    listMassImportSources: function(projectKey) {
        return APIXHRService("GET", API_PATH + "connections/list-mass-import-sources", {projectKey: projectKey});
    },
    listSQLMassImportSchemas: function(connectionName, projectKey) {
        return APIXHRService("GET", API_PATH + "connections/list-sql-mass-import-schemas", {connectionName: connectionName, projectKey:projectKey});
    },
    listSQLMassImportSchemasWithCatalogs: function(connectionName, projectKey) {
        return APIXHRService("GET", API_PATH + "connections/list-sql-mass-import-schemas-with-catalogs", {connectionName: connectionName, projectKey:projectKey});
    },
    listSQLMassImportTables: function (connectionName, sourceCatalog, sourceSchema, projectKey) {
        return APIXHRService("GET", API_PATH + "connections/list-sql-mass-import-tables", {
            connectionName: connectionName, sourceCatalog: sourceCatalog, sourceSchema: sourceSchema, projectKey:projectKey
        });
    },
    listHiveMassImportTables: function (connectionName, projectKey) {
        return APIXHRService("GET", API_PATH + "connections/list-hive-mass-import-tables", {
            connectionName: connectionName, projectKey: projectKey
        });
    },
    getTableImportCandidatesFromExplorer: function (workflowType, tables, projectKey, targetHDFSConnection) {
        return APIXHRService("POST", API_PATH + "connections/get-table-import-candidates-from-explorer", {
            workflowType: workflowType,
            tables: JSON.stringify(tables),
            projectKey: projectKey,
            targetHDFSConnection: targetHDFSConnection
        });
    },
    getTableImportCandidatesFromKeys: function (tables, projectKey, targetConnection) {
        return APIXHRService("POST", API_PATH + "connections/get-table-import-candidates-from-keys", {
            tables: JSON.stringify(tables),
            projectKey: projectKey,
            targetConnection:targetConnection
        });
    },
    massImportTableCandidates: function (projectKey, sqlTableCandidates, hiveTableCandidates, zoneId) {
        return APIXHRService("POST", API_PATH + "connections/mass-import-candidates", {
            projectKey: projectKey,
            sqlTableCandidates: JSON.stringify(sqlTableCandidates),
            hiveTableCandidates: JSON.stringify(hiveTableCandidates),
            zoneId
        });
    },

   /* Alation "embedded catalog chooser" integration */
   getTableImportCandidatesFromAlationMCC: function(projectKey, alationSelection) {
        return APIXHRService("POST", API_PATH + "connections/get-table-import-candidates-from-alation-mcc", {
            projectKey: projectKey,
            alationSelection: JSON.stringify(alationSelection)
        })
   },

   /* Alation "open in" integration" */
   registerAlationOpener : function(alationAPIToken) {
        return APIXHRService("POST", API_PATH + "connections/register-alation-opener", {
            alationAPIToken : alationAPIToken
        })
   },
   getAlationOpenInfo: function(alationOpenId) {
        return APIXHRService("POST", API_PATH + "connections/get-alation-open-info", {
            alationOpenId: alationOpenId
        })
   }
},

managedfolder: {
    list: function(projectKey) {
        return APIXHRService("GET", API_PATH + "managedfolder/list/", {projectKey: projectKey})
    },
    listWithAccessible: function(projectKey) {
        return APIXHRService("GET", API_PATH + "managedfolder/list-with-accessible/", {projectKey: projectKey});
    },
    get: function(contextProjectKey, projectKey, id) {
        return APIXHRService("GET", API_PATH + "managedfolder/get/", {contextProjectKey: contextProjectKey, projectKey: projectKey, id: id})
    },
    getSummary: function(projectKey, id) {
        return APIXHRService("GET", API_PATH + "managedfolder/get-summary/", {projectKey: projectKey, id: id})
    },
    getForInsight: function(contextProjectKey, projectKey, smartId) {
        return APIXHRService("GET", API_PATH + "managedfolder/get-for-insight/", {contextProjectKey: contextProjectKey, projectKey: projectKey, smartId: smartId})
    },
    getWithStatus: function(projectKey, id) {
        return APIXHRService("GET", API_PATH + "managedfolder/get-with-status/", {projectKey: projectKey, id: id})
    },
    getFullInfo: function(contextProjectKey, projectKey, id) {
        return APIXHRService("GET", API_PATH + "managedfolder/get-full-info/", {contextProjectKey: contextProjectKey, projectKey: projectKey, id: id})
    },
    testPartitioning: function(odb) {
        return APIXHRService("POST", API_PATH + "managedfolder/test-partitioning", {data: JSON.stringify(odb)});
    },
    detectPartitioning: function(odb) {
        return APIXHRService("POST", API_PATH + "managedfolder/detect-partitioning", {data: JSON.stringify(odb)});
    },
    browse: function(projectKey, folderId, path) {
        return APIXHRService("GET", API_PATH + "managedfolder/browse", {projectKey: projectKey, folderId: folderId, path: path})
    },
    listFS: function(projectKey, smartId) {
        return APIXHRService("GET", API_PATH + "managedfolder/list-fs", {projectKey: projectKey, smartId: smartId})
    },
    listPartitionFS: function(projectKey, smartId, partition) {
        return APIXHRService("GET", API_PATH + "managedfolder/list-partition-fs", {projectKey: projectKey, smartId: smartId, partition: partition})
    },
    listPartitionsWithName: function(projectKey, folderId) {
        return APIXHRService("POST", API_PATH + "managedfolder/list-partitions-with-name/", {
            projectKey: projectKey, folderId: folderId
        });
    },
    save: function(data, saveInfo) {
        return APIXHRService("POST", API_PATH + "managedfolder/save", {data: JSON.stringify(data), saveInfo: JSON.stringify(saveInfo || {})})
    },
    deleteItems: function(projectKey, odbId, itemPaths) {
        return APIXHRService("POST", API_PATH + "managedfolder/delete-items", {
            projectKey: projectKey, odbId: odbId, itemPaths: JSON.stringify(itemPaths)
        })
    },
    renameItem: function(projectKey, odbId, itemPath, isDirectory, newName) {
        return APIXHRService("GET", API_PATH + "managedfolder/rename-item", {
            projectKey: projectKey, odbId: odbId, itemPath: itemPath, newName: newName, isDirectory: isDirectory
        })
    },
    moveItems: function(projectKey, odbId, items) {
        return APIXHRService("GET", API_PATH + "managedfolder/move-items", {
            projectKey: projectKey, odbId: odbId, items: JSON.stringify(items)
        })
    },
    clearPartitions: function(projectKey, odbId, partitions) {
        return APIXHRService("POST", API_PATH + "managedfolder/clear-partitions/", {
            projectKey:projectKey,
            odbId:odbId,
            partitions:JSON.stringify(partitions)
        });
    },
    setExploreOnSinglePartition: function(projectKey, folderId, partitionId) {
        return APIXHRService("POST", API_PATH + "managedfolder/set-explore-on-single-partition/", {
           projectKey: projectKey,
           folderId: folderId,
           partitionId: partitionId
       });
    },
    saveSampling: function(projectKey, folderId, data) {
        return APIXHRService("GET", API_PATH + "managedfolder/save-sampling", {
            projectKey: projectKey,
            folderId: folderId,
            data: JSON.stringify(data)
        });
    },
    uploadItem: function(projectKey, odbId, path, file, forceUpload, callback) {
        return uploadFileRequest("managedfolder/upload-item", function(formdata) {
            formdata.append("projectKey", projectKey);
            formdata.append("odbId", odbId);
            formdata.append("file", file);
            formdata.append("path", path);
            formdata.append("forceUpload", forceUpload);
        }, callback);
    },
    createSubFolder: function(projectKey, folderId, path) {
        return APIXHRService("POST", API_PATH + "managedfolder/create-sub-folder", {
            projectKey: projectKey,
            folderId: folderId,
            path: path
        });
    },
    getDownloadItemURL: function(contextProjectKey, projectKey, obdId, path) {
        return API_PATH + "managedfolder/download-item/?contextProjectKey=" + encodeURIComponent(contextProjectKey)
            + "&projectKey=" + encodeURIComponent(projectKey)
            + "&obdId=" + encodeURIComponent(obdId)
            + "&path=" + encodeURIComponent(path) ;
    },
    getDownloadFolderURL: function(contextProjectKey, projectKey, obdId, path) {
        return API_PATH + "managedfolder/download-folder/?contextProjectKey=" + encodeURIComponent(contextProjectKey) + "&projectKey=" + encodeURIComponent(projectKey) + "&obdId=" + encodeURIComponent(obdId) + "&path=" + encodeURIComponent(path) ;
    },
    getItemInfo: function(projectKey, smartId, itemPath) {
        return APIXHRService("GET", API_PATH + "managedfolder/get-item-info", {
            projectKey: projectKey, smartId: smartId, itemPath: itemPath
        })
    },
    previewItem: function(contextProjectKey, projectKey, smartId, itemPath) {
        return APIXHRService("GET", API_PATH + "managedfolder/preview-item", {
            contextProjectKey: contextProjectKey, projectKey: projectKey, smartId: smartId, itemPath: itemPath
        })
    },
    decompressItem: function(projectKey, odbId, itemPath) {
        return APIXHRService("GET", API_PATH + "managedfolder/decompress-item", {
            projectKey: projectKey, odbId: odbId, itemPath: itemPath
        })
    },
    listAvailableMetrics: function(projectKey, folderId) {
        return APIXHRService("GET", API_PATH + "managedfolder/list-available-metrics", {
            projectKey: projectKey,
            folderId: folderId
        });
    },
    saveMetrics: function(projectKey, folderId, metrics, checks) {
        return APIXHRService("POST", API_PATH + "managedfolder/save-metrics", {
            projectKey: projectKey,
            folderId: folderId,
            metricsData: JSON.stringify(metrics),
            checksData: JSON.stringify(checks)
        });
    },
    computeMetrics: function(projectKey, folderId, partitionId, allPartitions) {
        return APIXHRService("GET", API_PATH + "managedfolder/compute-metrics", {
            projectKey: projectKey,
            folderId: folderId,
            partitionId: partitionId,
            allPartitions: allPartitions
        });
    },
    computePlan: function(projectKey, folderId, metrics) {
        return APIXHRService("POST", API_PATH + "managedfolder/compute-plan", {
            projectKey: projectKey,
            folderId: folderId,
            metricsData: JSON.stringify(metrics)
        });
    },
    getPreparedMetricHistory: function(projectKey, folderId, partitionId, metric, metricId) {
        return APIXHRService("GET", API_PATH + "managedfolder/get-prepared-metric-history", {
            projectKey: projectKey,
            folderId: folderId,
            data: JSON.stringify(metric),
            metricId: metricId,
            partitionId: partitionId
        });
    },
    getPreparedMetricHistories: function(projectKey, folderId, displayedState) {
        return APIXHRService("POST", API_PATH + "managedfolder/get-prepared-metric-histories", {
            projectKey: projectKey,
            folderId: folderId,
            data: JSON.stringify(displayedState || {})
        });
    },
    getPreparedMetricPartitions: function(projectKey, folderId, displayedState) {
        return APIXHRService("POST", API_PATH + "managedfolder/get-prepared-metric-partitions", {
            projectKey: projectKey,
            folderId: folderId,
            data: JSON.stringify(displayedState || {})
        });
    },
    getPartitionListMetric: function(projectKey, folderId ) {
        return APIXHRService("GET", API_PATH + "managedfolder/get-partition-list-metric", {
            projectKey: projectKey,
            folderId: folderId
        });
    },
    refreshPartitionListMetric: function(projectKey, folderId ) {
        return APIXHRService("GET", API_PATH + "managedfolder/refresh-partition-list-metric", {
            projectKey: projectKey,
            folderId: folderId
        });
    },
    listComputedMetrics: function(projectKey, folderId) {
        return APIXHRService("GET", API_PATH + "managedfolder/list-computed-metrics", {
            projectKey: projectKey,
            folderId: folderId
        });
    },
    computeProbe: function(projectKey, folderId, partitionId, allPartitions, metrics) {
        return APIXHRService("POST", API_PATH + "managedfolder/compute-probe", {
            projectKey: projectKey,
            folderId: folderId,
            partitionId: partitionId,
            allPartitions: allPartitions,
            data: JSON.stringify(metrics)
        });
    },
    runChecks: function(projectKey, folderId, partitionId, allPartitions) {
        return APIXHRService("GET", API_PATH + "managedfolder/run-checks", {
            projectKey: projectKey,
            folderId: folderId,
            partitionId: partitionId,
            allPartitions: allPartitions
        });
    },
    runCheck: function(projectKey, folderId, partitionId, allPartitions, metricsChecks) {
        return APIXHRService("POST", API_PATH + "managedfolder/run-check", {
            projectKey: projectKey,
            folderId: folderId,
            partitionId: partitionId,
            allPartitions: allPartitions,
            data: JSON.stringify(metricsChecks)
        });
    },
    createMetricsDataset: function(projectKey, folderId, view, partition, filter) {
        return APIXHRService("GET", API_PATH + "datasets/create-metrics-dataset", {
            projectKey: projectKey,
            objectId: folderId,
            view: view,
            partition: partition,
            filter: filter
        });
    },
    getCheckHistories: function(projectKey, folderId, displayedState) {
        return APIXHRService("POST", API_PATH + "managedfolder/get-prepared-check-histories", {
            projectKey: projectKey,
            folderId: folderId,
            data: JSON.stringify(displayedState || {})
        });
    },
    listComputedChecks: function(projectKey, folderId) {
        return APIXHRService("GET", API_PATH + "managedfolder/list-computed-checks", {
            projectKey: projectKey,
            folderId: folderId
        });
    },
    getHint: function(projectKey, folderId, probe) {
        return APIXHRService("POST", API_PATH + "managedfolder/get-hint", {
            projectKey: projectKey,
            folderId: folderId,
            data: JSON.stringify(probe)
        });
    },
    clearMetrics: function(projectKey, folderId) {
        return APIXHRService("GET", API_PATH + "managedfolder/clear-metrics", {
            projectKey: projectKey,
            folderId: folderId
        });
    }
},
fsproviders: {
    testConnection: function(type, params, projectKey, contextVars, listBuckets) {
        return APIXHRService("POST", API_PATH + "fsproviders/test-connection/", {
            type:type,
            params:JSON.stringify(params),
            projectKey:projectKey,
            contextVars:JSON.stringify(contextVars),
            listBuckets:listBuckets
        });
    },
    browse: function(type, params, projectKey, contextVars, path) {
        return APIXHRService("POST", API_PATH + "fsproviders/fs-browse/", {
            type:type,
            params:JSON.stringify(params),
            projectKey:projectKey,
            contextVars:JSON.stringify(contextVars),
            path:path
        });
    },
    listFiles: function(type, params, projectKey, contextVars, selectionRules, selectedOnly) {
        return APIXHRService("POST", API_PATH + "fsproviders/list-files/", {
            type:type,
            params:JSON.stringify(params),
            projectKey:projectKey,
            contextVars:JSON.stringify(contextVars),
            selectionRules:JSON.stringify(selectionRules),
            selectedOnly:selectedOnly
        });
    }
},
taggableObjects: {
    countAccessibleObjects: function(projectKey) {
        return APIXHRService("GET", API_PATH + "taggable-objects/count-accessible-objects", {
            projectKey: projectKey
        });
    },
    listAccessibleObjects: function(projectKey, type, mode) {
        return APIXHRService("GET", API_PATH + "taggable-objects/list-accessible-objects", {
            projectKey: projectKey,
            type: type,
            mode: mode
        });
    },
    listTags: function(projectKey) {
        return APIXHRService("GET", API_PATH + "taggable-objects/list-tags", {projectKey: projectKey});
    },
    listAllTags: function() {
        return APIXHRService("GET", API_PATH + "taggable-objects/list-all-tags");
    },
    listTagsUsage: function(projectKey, options, spinnerMode) {
        return APIXHRService("GET", API_PATH + "taggable-objects/list-tags-usage", {
            projectKey: projectKey,
            options: JSON.stringify(options)
        }, spinnerMode);
    },
    setTags: function(projectKey, tags) {
        return APIXHRService("POST", API_PATH + "taggable-objects/set-tags", {
            projectKey: projectKey,
            data: JSON.stringify({tags: tags})
        });
    },
    applyTagging: function(projectKey, request)  {
        return APIXHRService("POST", API_PATH + "taggable-objects/apply-tagging/", {
            projectKey: projectKey,
            request: JSON.stringify(request)
        });
    },
    clear: function(requests) {
        return APIXHRService("POST", API_PATH + "taggable-objects/clear/", {
            requests: JSON.stringify(requests)
        });
    },
    checkDeletedObjects: function (requests) {
        return APIXHRService("POST", API_PATH + "taggable-objects/check-deleted-objects/", {
            requests: JSON.stringify(requests)
        });
    },
    computeDeletionImpact: function(request, contextProjectKey) {
        //POST because requests might be large
        return APIXHRService("POST", API_PATH + "taggable-objects/compute-deletion-impact/", {
            request: JSON.stringify(request),
            contextProjectKey: contextProjectKey
        });
    },
    delete: function(request, contextProjectKey) {
        return APIXHRService("POST", API_PATH + "taggable-objects/delete/", {
            request: JSON.stringify(request),
            contextProjectKey: contextProjectKey
        });
    },
    setShortDesc: function(taggableObject, shortDesc) {
        return APIXHRService("POST", API_PATH + "taggable-objects/set-short-desc/", {
            taggableObject: JSON.stringify(taggableObject),
            shortDesc: shortDesc
        });
    },
    getMetadata: function(taggableObject) {
        return APIXHRService("GET", API_PATH + "taggable-objects/get-metadata/", {
            taggableObject: JSON.stringify(taggableObject)
        });
    },
    setMetaData: function(taggableObject, request) {
        return APIXHRService("POST", API_PATH + "taggable-objects/set-metadata/", {
            taggableObject: JSON.stringify(taggableObject),
            request: JSON.stringify(request)
        });
    },

},
datasets: {
    /* CRUD stuff */
    rename: function(projectKey, oldName, newName) {
        return APIXHRService("POST", API_PATH + "datasets/rename/", {projectKey: projectKey, oldName: oldName, newName: newName});
    },
    list: function(projectKey) {
        return APIXHRService("GET", API_PATH + "datasets/list/", {projectKey: projectKey});
    },
    listWithAccessible: function(projectKey) {
        return APIXHRService("GET", API_PATH + "datasets/list-with-accessible/", {projectKey: projectKey});
    },
    listNames: function(projectKey) {
        return APIXHRService("GET", API_PATH + "datasets/list-names/", {projectKey: projectKey});
    },
    listHeaders: function(projectKey) {
        return APIXHRService("GET", API_PATH + "datasets/list-headers/", {projectKey: projectKey});
    },
    // Takes into account Tags Filter
    listHeads: function(projectKey, tagFilter, withStatus) {
        return APIXHRService("GET", API_PATH + "datasets/list-heads/", {projectKey: projectKey, tagFilter: tagFilter, withStatus: withStatus});
    },
    listCreatableDatasetTypes: function(projectKey) {
        return APIXHRService("GET", API_PATH + "datasets/list-creatable-dataset-types/", { projectKey });
    },
    create: function(projectKey, data, zoneId) {
        return APIXHRService("POST", API_PATH + "datasets/create/", {projectKey: projectKey, data:JSON.stringify(data), zoneId});
    },
    checkNameSafety: function(projectKey, datasetName, data) {
        return APIXHRService("POST", API_PATH + "datasets/check-name-safety/", {
            projectKey: projectKey,
            datasetName: datasetName,
            data: JSON.stringify(data)
        });
    },
    checkSaveConflict: function(projectKey, data) {
        return APIXHRService("POST", API_PATH + "datasets/check-save-conflict/", {projectKey: projectKey, data:JSON.stringify(data)});
    },
    save: function(projectKey, data, saveInfo) {
        return APIXHRService("POST", API_PATH + "datasets/save/", {projectKey: projectKey, data:JSON.stringify(data), saveInfo:JSON.stringify(saveInfo)});
    },
    saveWithRecipesFixup: function(projectKey, data, saveInfo, forceRecipesFixup) {
        return APIXHRService("POST", API_PATH + "datasets/save-with-recipes-fixup", {
            projectKey: projectKey,
            data:JSON.stringify(data),
            saveInfo:JSON.stringify(saveInfo),
            forceRecipesFixup:forceRecipesFixup
        });
    },
    exportDS: function(contextProjectKey, projectKey, name, exportParams) {
        return APIXHRService("POST", API_PATH + "datasets/export/", {contextProjectKey:contextProjectKey, projectKey: projectKey, name: name, params: JSON.stringify(exportParams)});
    },
    get: function(projectKey, name, contextProjectKey) {
        return APIXHRService("GET", API_PATH + "datasets/get/", {projectKey: projectKey, name: name, contextProjectKey: contextProjectKey});
    },
    getForExport: function(projectKey, name, contextProjectKey) {
        return APIXHRService("GET", API_PATH + "datasets/get-for-export/", {projectKey: projectKey, name: name, contextProjectKey: contextProjectKey});
    },
    getWithMetricsStatus: function(projectKey, name) {
        return APIXHRService("GET", API_PATH + "datasets/get-with-metrics-status/", {projectKey: projectKey, name: name});
    },
    getSummary: function(projectKey, name) {
        return APIXHRService("GET", API_PATH + "datasets/get-summary/", {projectKey: projectKey, name: name});
    },
    computeRenamingImpact: function(projectKey, name, newName) {
        return APIXHRService("GET", API_PATH + "datasets/compute-renaming-impact/", {projectKey: projectKey, name: name, newName: newName});
    },
    controlTwitterStreaming: function(projectKey, name, start) {
        return APIXHRService("POST", API_PATH + "datasets/control-twitter-streaming/", {projectKey: projectKey, name: name, start: start});
    },
    getTwitterStatus: function(projectKey, name) {
        return APIXHRService("GET", API_PATH + "datasets/get-twitter-status/", {projectKey: projectKey, name: name});
    },
    clearPartitions: function(projectKey, datasetName, partitions) {
        return APIXHRService("POST", API_PATH + "datasets/clear-partitions/", {
            projectKey:projectKey,
            datasetName:datasetName,
            partitions:JSON.stringify(partitions)
        });
    },
    /* Autodetection stuff */
    testAndDetectFormat: function(projectKey, data, detectPossibleFormats, inferStorageTypes) {
        return APIXHRService("POST", API_PATH + "datasets/test-and-detect-format/", {
            projectKey: projectKey,
            data: JSON.stringify(data),
            detectPossibleFormats: detectPossibleFormats,
            inferStorageTypes: inferStorageTypes
        });
    },
    detect_format: function(projectKey, data, inferStorageTypes) {
        return APIXHRService("POST", API_PATH + "datasets/test-and-detect-format/", {
            projectKey: projectKey,
            data: JSON.stringify(data),
            detectPossibleFormats: true,
            inferStorageTypes: inferStorageTypes
        });
    },
    preview: function(projectKey, data, inferStorageTypes) {
        return APIXHRService("POST", API_PATH + "datasets/test-and-detect-format/", {
            projectKey: projectKey,
            data:JSON.stringify(data),
            detectPossibleFormats:false,
            inferStorageTypes: inferStorageTypes
        });
    },
    detectOneFormat: function(projectKey, data, format) {
        return APIXHRService("POST", API_PATH + "datasets/detect-one-format/", {
            projectKey: projectKey,
            data:JSON.stringify(data), format:format
        });
    },
    testFilePartitioning: function(dataset) {
        return APIXHRService("POST", API_PATH + "datasets/test-file-partitioning", {data: JSON.stringify(dataset)});
    },
    testGeneralPartitioning: function(dataset) {
        return APIXHRService("POST", API_PATH + "datasets/test-general-partitioning", {data: JSON.stringify(dataset)});
    },
    detectFilePartitioning: function(dataset) {
        return APIXHRService("POST", API_PATH + "datasets/detect-file-partitioning", {data: JSON.stringify(dataset)});
    },
    listPartitions: function(data) {
        return APIXHRService("POST", API_PATH + "datasets/list-partitions/", {data: JSON.stringify(data)});
    },
    listPartitionsWithName: function(projectKey, datasetName) {
        return APIXHRService("POST", API_PATH + "datasets/list-partitions-with-name/", {
            projectKey: projectKey, datasetName: datasetName
        });
    },
    synchronizeHiveMetastore: function(datasets) {
        return APIXHRService("POST", API_PATH + "datasets/synchronize-hive-metastore", {datasets: JSON.stringify(datasets)});
    },
    synchronizeOneHiveMetastore: function(datasetRef, datasetParams) {
        return APIXHRService("POST", API_PATH + "datasets/synchronize-one-hive-metastore", {ref: JSON.stringify(datasetRef), params: JSON.stringify(datasetParams)});
    },
    updateFromHive : function(projectKey, name) {
        return APIXHRService("POST", API_PATH + "datasets/update-from-hive", {
            projectKey : projectKey, name:name
        });
    },
    checkHiveSync : function(projectKey, name) {
        return APIXHRService("POST", API_PATH + "datasets/check-hive-sync", {
            projectKey : projectKey, name:name
        }, "nospinner");
    },
    /* auto stuff (done backend-side) */
    autoUpdateFormat: function(projectKey, data, detectPossibleFormats, inferStorageTypes) {
        return APIXHRService("POST", API_PATH + "datasets/auto-update-format/", {
            projectKey: projectKey,
            data: JSON.stringify(data),
            detectPossibleFormats: detectPossibleFormats,
            inferStorageTypes: inferStorageTypes
        });
    },
    autoUpdateSQLSchema: function(projectKey, data) {
        return APIXHRService("POST", API_PATH + "datasets/auto-update-sql-schema/", {
            projectKey: projectKey,
            data: JSON.stringify(data)
        });
    },
    /* TODO: Move to a proper API path */
    newManagedDataset: function(projectKey, name, settings) {
        return APIXHRService("POST", API_PATH + "flow/recipes/new-managed-dataset", {
            projectKey: projectKey, name: name,
            settings: JSON.stringify(settings)
        });
    },
    newManagedFolder: function(projectKey, name, settings) {
        return APIXHRService("POST", API_PATH + "flow/recipes/new-managed-folder", {
            projectKey: projectKey, name: name,
            settings: JSON.stringify(settings)
        });
    },
    newModelEvaluationStore: function(projectKey, name, settings) {
        return APIXHRService("POST", API_PATH + "flow/recipes/new-model-evaluation-store", {
            projectKey: projectKey, name: name,
            settings: JSON.stringify(settings)
        });
    },
    newStreamingEndpoint: function(projectKey, name, settings) {
        return APIXHRService("POST", API_PATH + "flow/recipes/new-streaming-endpoint", {
            projectKey: projectKey, name: name,
            settings: JSON.stringify(settings)
        });
    },
    listManagedDatasetConnections: function() {
        return APIXHRService("GET", API_PATH + "flow/recipes/list-managed-dataset-connections");
    },
    listManagedUploadableConnections: function(projectKey) {
        return APIXHRService("GET", API_PATH + "flow/recipes/list-managed-uploadable-connections",{
            projectKey:projectKey
        });
    },
    getManagedDatasetOptions: function(recipeData, role) {
        return APIXHRService("POST", API_PATH + "flow/recipes/get-managed-dataset-options", {
            recipeData: JSON.stringify(recipeData), role: role
        });
    },
    getManagedDatasetOptionsNoContext: function(projectKey) {
        return APIXHRService("GET", API_PATH + "flow/recipes/get-managed-dataset-options-no-context", { projectKey: projectKey });
    },
    getManagedFolderOptions: function(recipeData, role) {
        return APIXHRService("POST", API_PATH + "flow/recipes/get-managed-folder-options", {
            recipeData: JSON.stringify(recipeData), role: role
        });
    },
    getManagedFolderOptionsNoContext: function(projectKey) {
        return APIXHRService("GET", API_PATH + "flow/recipes/get-managed-folder-options-no-context", { projectKey: projectKey });
    },
    getModelEvaluationStoreOptions: function(recipeData, role) {
        return APIXHRService("POST", API_PATH + "flow/recipes/get-model-evaluation-store-options", {
            recipeData: JSON.stringify(recipeData), role: role
        });
    },
    getModelEvaluationStoreOptionsNoContext: function(projectKey) {
        return APIXHRService("GET", API_PATH + "flow/recipes/get-model-evaluation-store-options-no-context", { projectKey: projectKey });
    },
    getStreamingEndpointOptions: function(recipeData, role) {
        return APIXHRService("POST", API_PATH + "flow/recipes/get-streaming-endpoint-options", {
            recipeData: JSON.stringify(recipeData), role: role
        });
    },
    getStreamingEndpointOptionsNoContext: function(projectKey) {
        return APIXHRService("GET", API_PATH + "flow/recipes/get-streaming-endpoint-options-no-context", { projectKey: projectKey });
    },
    listRemoteDatasetConnections: function() {
        return APIXHRService("GET", API_PATH + "flow/recipes/list-remote-dataset-connections");
    },
    listFSProviderTypes: function(withNonWritable) {
        return APIXHRService("GET", API_PATH + "flow/recipes/list-fs-providers", {withNonWritable : withNonWritable});
    },
    listAllUsable: function(projectKey) {
        return APIXHRService("GET", API_PATH + "datasets/list-all-usable",  {projectKey:projectKey});
    },
    getForTimeRange: function(projectKey, name, computeRecords, runChecks, forceRefresh, rangeStart, rangeEnd) {
        return APIXHRService("GET", API_PATH + "datasets/get-status-for-time-range/", {
            projectKey: projectKey,
            name: name,
            computeRecords: computeRecords,
            runChecks: runChecks,
            forceRefresh: forceRefresh,
            rangeStart: rangeStart,
            rangeEnd: rangeEnd
        });
    },
    getFullStatus: function(projectKey, name, computeRecords, runChecks, forceRefresh) {
        return APIXHRService("GET", API_PATH + "datasets/get-full-status/", {
            projectKey: projectKey,
            name: name,
            computeRecords: computeRecords,
            runChecks: runChecks,
            forceRefresh: forceRefresh
        });
    },
    getHead: function(contextProjectKey, projectKey, name) {
        return APIXHRService("GET", API_PATH + "datasets/get-head", {contextProjectKey: contextProjectKey, projectKey: projectKey, name: name});
    },
    getFullInfo: function(contextProjectKey, projectKey, name) {
        return APIXHRService("GET", API_PATH + "datasets/get-full-info", {contextProjectKey: contextProjectKey, projectKey: projectKey, name: name});
    },
    /** Futures */
    //TODO @flow deprecated
    getRefreshedSummaryStatus: function(projectKey, datasetName, computeRecords, forceRecompute) {
        return APIXHRService("POST", API_PATH + "datasets/get-refreshed-summary-status", {
            projectKey: projectKey,
            datasetName:datasetName,
            computeRecords:computeRecords,
            forceRecompute: forceRecompute
        });
    },
    refreshSummaries: function(datasets, computeRecords, forceRecompute) {
        return APIXHRService("POST", API_PATH + "datasets/refresh-summaries", {
            datasets: JSON.stringify(datasets),
            computeRecords: computeRecords,
            forceRecompute: forceRecompute
        });
    },
    markAsBuilt: function(datasets) {
        return APIXHRService("POST", API_PATH + "datasets/mark-as-built", {
            datasets: JSON.stringify(datasets)
        });
    },
    testSchemaConsistency: function(data) {
        return APIXHRService("POST", API_PATH + "datasets/test-schema-consistency", {
            data: JSON.stringify(data)
        });
    },
    testSchemaConsistencyOnAllFiles: function(data) {
        return APIXHRService("POST", API_PATH + "datasets/test-schema-consistency-on-all-files", {
            data: JSON.stringify(data)
        });
    },
    listNotebooks: function(projectKey, datasetSmartName) {
        return APIXHRService("POST", API_PATH + "datasets/list-notebooks", {
            projectKey: projectKey, datasetSmartName: datasetSmartName
        });
    },
    setVirtualizable: function(items, virtualizable) {
        return APIXHRService("POST", API_PATH + "datasets/set-virtualizable", {
            items: JSON.stringify(items),
            virtualizable: virtualizable
        });
    },
    setAutoCountOfRecords: function(items, autoCountOfRecords) {
        return APIXHRService("POST", API_PATH + "datasets/set-auto-count-of-records", {
            items: JSON.stringify(items),
            autoCountOfRecords: autoCountOfRecords
        });
    },
    managedSQL: {
        test: function(projectKey, dataset, maxSamples, connectionOnly) {
            return APIXHRService("POST", API_PATH + "datasets/managed-sql/test/", {projectKey: projectKey, data: JSON.stringify(dataset),
                    maxSamples: maxSamples, connectionOnly: connectionOnly });
        },
        createTable: function(projectKey, dataset) {
            return APIXHRService("POST", API_PATH + "datasets/managed-sql/create-table/", {projectKey: projectKey, data: JSON.stringify(dataset)});
        },
        dropTable: function(projectKey, dataset) {
            return APIXHRService("POST", API_PATH + "datasets/managed-sql/drop-table/", {projectKey: projectKey, data: JSON.stringify(dataset)});
        }
    },
    externalSQL: {
        test: function(projectKey, dataset, maxSamples, listTables, testTableOrQuery) {
            return APIXHRService("POST", API_PATH + "datasets/external-sql/test/", {
                projectKey: projectKey,
                data: JSON.stringify(dataset),
                maxSamples: maxSamples,
                listTables: listTables,
                testTableOrQuery: testTableOrQuery
            });
        },
        listPartitions: function(projectKey, dataset) {
            return APIXHRService("POST", API_PATH + "datasets/external-sql/list-partitions/", {projectKey: projectKey, data: JSON.stringify(dataset)});
        }
    },
    elasticsearch: {
        test: function(projectKey, dataset, connectionOnly) {
            return APIXHRService("POST", API_PATH + "datasets/elasticsearch/test", {
                projectKey: projectKey,
                data: JSON.stringify(dataset),
                connectionOnly: connectionOnly
            });
        }
    },
    mongoDB: {
    	test: function(projectKey, dataset, connectionOnly, inferStorageTypes) {
            return APIXHRService("POST", API_PATH + "datasets/mongodb/test", {projectKey: projectKey, data: JSON.stringify(dataset),
                connectionOnly: connectionOnly,
                inferStorageTypes: inferStorageTypes == null ? false : inferStorageTypes });
    	},
    	createCollection: function(dataset) {
    		return APIXHRService("POST", API_PATH + "datasets/mongodb/create-collection", {data: JSON.stringify(dataset) });
    	},
    	deleteCollection: function(dataset) {
            return APIXHRService("POST", API_PATH + "datasets/mongodb/delete-collection", {data: JSON.stringify(dataset) });
    	}
    },
    dynamoDB: {
        	test: function(projectKey, dataset, connectionOnly, inferStorageTypes, listTables) {
                return APIXHRService("POST", API_PATH + "datasets/dynamodb/test", {projectKey: projectKey, data: JSON.stringify(dataset),
                    connectionOnly: connectionOnly,
                    listTables: listTables,
                    inferStorageTypes: inferStorageTypes == null ? false : inferStorageTypes });
        	},
        	createTable: function(dataset) {
        		return APIXHRService("POST", API_PATH + "datasets/dynamodb/create-table", {data: JSON.stringify(dataset) });
        	},
        	deleteTable: function(dataset) {
                return APIXHRService("POST", API_PATH + "datasets/dynamodb/delete-table", {data: JSON.stringify(dataset) });
        	},
        	updateIndex: function(dataset) {
                    		return APIXHRService("POST", API_PATH + "datasets/dynamodb/update-index", {data: JSON.stringify(dataset) });
            }
    },
    cassandra: {
    	test: function(projectKey, dataset, connectionOnly) {
            return APIXHRService("POST", API_PATH + "datasets/cassandra/test", {projectKey: projectKey, data: JSON.stringify(dataset),
                connectionOnly: connectionOnly });
    	},
    	createTable: function(dataset) {
    		return APIXHRService("POST", API_PATH + "datasets/cassandra/create-table", {data: JSON.stringify(dataset) });
    	},
    	dropTable: function(dataset) {
    		return APIXHRService("POST", API_PATH + "datasets/cassandra/drop-table", {data: JSON.stringify(dataset) });
    	}
    },
    editable: {
        getData: function(projectKey, dataset) {
            return APIXHRService("GET", API_PATH + "datasets/editable/get", {
                projectKey: projectKey,
                dataset: dataset
            });
        },
        save: function(projectKey, dataset, data) {
            return APIXHRService("POST", API_PATH + "datasets/editable/save", {
                projectKey: projectKey,
                dataset: dataset,
                data: data
            });
        },
        import: function(projectKey, dataset, data) {
            return APIXHRService("POST", API_PATH + "datasets/editable/import", {
                projectKey: projectKey,
                dataset: dataset, data: data
            });
        },
        test: function(projectKey, dataset) {
            return APIXHRService("POST", API_PATH + "datasets/editable/test", {
                projectKey: projectKey,
                dataset: dataset
            });
        }
    },
    customDataset: {
        test: function(projectKey, dataset, showPreview) {
            return APIXHRService("POST", API_PATH + "datasets/custom-dataset/test", {
                projectKey: projectKey,
                dataset: JSON.stringify(dataset),
                showPreview: showPreview
            })
        }
    },
    jobsdb: {
        test: function(projectKey, dataset) {
            return APIXHRService("POST", API_PATH + "datasets/jobsdb/test/", {projectKey: projectKey, data: JSON.stringify(dataset)});
        }
    },
    statsdb: {
        test: function(projectKey, dataset) {
            return APIXHRService("POST", API_PATH + "datasets/statsdb/test/", {projectKey: projectKey, data: JSON.stringify(dataset)});
        }
    },
    /* Static data */
    get_common_charsets: function() {
        return APIXHRService("GET", API_PATH + "datasets/get-common-charsets/", {});
    },
    get_types: function() {
        return APIXHRService("GET", API_PATH + "datasets/get-types/", {});
    },
    get_format_types: function() {
        return APIXHRService("GET", API_PATH + "datasets/get-format-types/", {});
    },
    /* OpenStreetMap specific */
    osm: {
        get_data_files: function() {
            return APIXHRService("GET", API_PATH + "datasets/osm/get-data-files", {});
        }
    },
    upload: {
        /* Returns {id: uploadBoxId } */
        createUploadBox: function() {
            return APIXHRService("POST", API_PATH + "datasets/upload/create-upload-box", {});
        },
        /* This method should only be called in case of premature abort.
         * In case of normal dataset creation, the upload box is automatically purged */
        deleteUploadBox: function(uploadBoxId) {
            return APIXHRService("POST", API_PATH + "datasets/upload/delete-upload-box");
        },
        createDataset: function(projectKey, datasetName, uploadBoxId) {
            return APIXHRService("POST", API_PATH + "datasets/upload/create-dataset", {
                projectKey: projectKey,
                datasetName:datasetName,
                uploadBoxId: uploadBoxId
            });
        },
        /* Returns [ {path, length}] */
        listFiles: function(projectKey, datasetName) {
            return APIXHRService("GET", API_PATH + "datasets/upload/list-files", {projectKey: projectKey, datasetName:datasetName});
        },
        /* Returns [ {path, length}] */
        addFileToDataset: function(projectKey, file, dataset, callback) {
            return uploadFileRequest("datasets/upload/add-file", function(formdata) {
                formdata.append("projectKey", projectKey);
                formdata.append("file", file);
                formdata.append('dataset', JSON.stringify(dataset));
            }, callback);
        },
        removeFile: function(projectKey, dataset, path) {
            return APIXHRService("POST", API_PATH + "datasets/upload/remove-file", {
                projectKey: projectKey,
                dataset:JSON.stringify(dataset),
                fileName:path
            });
        }
    },
    getRequirements: function(projectKey, datasetType) {
        return APIXHRService("GET", API_PATH + "datasets/get-requirements", {
            projectKey:projectKey,
            datasetType:datasetType
        });
    },
    listAvailableMetrics: function(projectKey, datasetName) {
        return APIXHRService("GET", API_PATH + "datasets/list-available-metrics", {
            projectKey: projectKey,
            datasetName: datasetName
        });
    },
    saveMetrics: function(projectKey, datasetName, metrics, checks) {
        return APIXHRService("POST", API_PATH + "datasets/save-metrics", {
            projectKey: projectKey,
            datasetName: datasetName,
            metricsData: JSON.stringify(metrics),
            checksData: JSON.stringify(checks)
        });
    },
    computeMetrics: function(projectKey, datasetName, partitionId, allPartitions) {
        return APIXHRService("GET", API_PATH + "datasets/compute-metrics", {
            projectKey: projectKey,
            datasetName: datasetName,
            partitionId: partitionId,
            allPartitions: allPartitions
        });
    },
	computeColumnMetrics : function(projectKey, datasetName, columnName, partitionId, allPartitions) {
		return APIXHRService("GET", API_PATH + "datasets/compute-column-metrics",{
			projectKey : projectKey,
			datasetName : datasetName,
			columnName : columnName,
			partitionId : partitionId,
			allPartitions: allPartitions
		});
	},
	computeDetailedColumnMetrics : function(projectKey, datasetName, columnName, statisticsConfig, partitionId, forceRefresh) {
		return APIXHRService("GET", API_PATH + "datasets/compute-detailed-column-metrics",{
			projectKey : projectKey,
			datasetName : datasetName,
			columnName : columnName,
			statisticsConfig : JSON.stringify(statisticsConfig),
			partitionId : partitionId,
			forceRefresh : forceRefresh
		});
	},
    computePlan: function(projectKey, datasetName, metrics) {
        return APIXHRService("POST", API_PATH + "datasets/compute-plan", {
            projectKey: projectKey,
            datasetName: datasetName,
            metricsData: JSON.stringify(metrics)
        });
    },
    computeProbe: function(projectKey, datasetName, partitionId, allPartitions, metrics) {
        return APIXHRService("POST", API_PATH + "datasets/compute-probe", {
            projectKey: projectKey,
            datasetName: datasetName,
            partitionId: partitionId,
            allPartitions: allPartitions,
            data: JSON.stringify(metrics)
        });
    },
    runChecks: function(projectKey, datasetName, partitionId, allPartitions) {
        return APIXHRService("GET", API_PATH + "datasets/run-checks", {
            projectKey: projectKey,
            datasetName: datasetName,
            partitionId: partitionId,
            allPartitions: allPartitions
        });
    },
    runCheck: function(projectKey, datasetName, partitionId, allPartitions, metricsChecks) {
        return APIXHRService("POST", API_PATH + "datasets/run-check", {
            projectKey: projectKey,
            datasetName: datasetName,
            partitionId: partitionId,
            allPartitions: allPartitions,
            data: JSON.stringify(metricsChecks)
        });
    },
    getPreparedMetricHistory: function(projectKey, datasetName, partitionId, metric, metricId) {
        return APIXHRService("GET", API_PATH + "datasets/get-prepared-metric-history", {
            projectKey: projectKey,
            datasetName: datasetName,
            partitionId: partitionId,
            data: JSON.stringify(metric),
            metricId: metricId
        });
    },
    getPreparedMetricHistories: function(projectKey, datasetName, displayedState) {
        return APIXHRService("POST", API_PATH + "datasets/get-prepared-metric-histories", {
            projectKey: projectKey,
            datasetName: datasetName,
            data: JSON.stringify(displayedState || {})
        });
    },
    getPreparedMetricPartitions: function(projectKey, datasetName, displayedState) {
        return APIXHRService("POST", API_PATH + "datasets/get-prepared-metric-partitions", {
            projectKey: projectKey,
            datasetName: datasetName,
            data: JSON.stringify(displayedState || {})
        });
    },
	getPreparedMetricColumns : function(projectKey, datasetName, displayedState) {
		return APIXHRService("POST", API_PATH + "datasets/get-prepared-metric-columns",{
			projectKey : projectKey,
			datasetName : datasetName,
			data : JSON.stringify(displayedState || {})
    	});
	},
    listComputedMetrics: function(projectKey, datasetName) {
        return APIXHRService("GET", API_PATH + "datasets/list-computed-metrics", {
            projectKey: projectKey,
            datasetName: datasetName
        });
    },
    getPartitionListMetric: function(projectKey, datasetName ) {
        return APIXHRService("GET", API_PATH + "datasets/get-partition-list-metric", {
            projectKey: projectKey,
            datasetName: datasetName
        });
    },
    refreshPartitionListMetric: function(projectKey, datasetName ) {
        return APIXHRService("GET", API_PATH + "datasets/refresh-partition-list-metric", {
            projectKey: projectKey,
            datasetName: datasetName
        });
    },
    createMetricsDataset: function(projectKey, datasetName, view, partition, filter) {
        return APIXHRService("GET", API_PATH + "datasets/create-metrics-dataset", {
            projectKey: projectKey,
            objectId: datasetName,
            view: view,
            partition: partition,
            filter: filter
        });
    },
    getCachedNbRecords: function(projectKey, datasetName) {
        return APIXHRService("GET", API_PATH + "datasets/get-cached-nb-records", {
            projectKey: projectKey,
            datasetName: datasetName
        });
    },
    updateNbRecords: function(projectKey, datasetName, recomputeAll) {
        return APIXHRService("GET", API_PATH + "datasets/update-nb-records", {
            projectKey: projectKey,
            datasetName: datasetName,
            recomputeAll: recomputeAll
        });
    },
    getCheckHistories: function(projectKey, datasetName, displayedState) {
        return APIXHRService("POST", API_PATH + "datasets/get-prepared-check-histories", {
            projectKey: projectKey,
            datasetName: datasetName,
            data: JSON.stringify(displayedState || {})
        });
    },
    listComputedChecks: function(projectKey, datasetName) {
        return APIXHRService("GET", API_PATH + "datasets/list-computed-checks", {
            projectKey: projectKey,
            datasetName: datasetName
        });
    },
    getHint: function(projectKey, datasetName, probe) {
        return APIXHRService("POST", API_PATH + "datasets/get-hint", {
            projectKey: projectKey,
            datasetName: datasetName,
            data: JSON.stringify(probe)
        });
    },
    clearMetrics: function(projectKey, datasetName, partition) {
        return APIXHRService("GET", API_PATH + "datasets/clear-metrics", {
            projectKey: projectKey,
            datasetName: datasetName,
            partition: partition
        });
    },
    getFullSampleStatisticsConfig : function(contextProjectKey, projectKey, datasetName) {
    	return APIXHRService("GET", API_PATH + "datasets/get-full-sample-statistics-config",{
            contextProjectKey: contextProjectKey,
    		projectKey : projectKey,
        	datasetName : datasetName
        });
	}
},
jupyterNotebooks: {
    get: function(projectKey, notebookName, kernelName) {
        if (kernelName) {
            return APIXHRService("GET", "/jupyter/api/contents/" + projectKey + "/" + notebookName + ".ipynb?kernel_name=" + kernelName);
        } else {
            return APIXHRService("GET", "/jupyter/api/contents/" + projectKey + "/" + notebookName + ".ipynb");
        }
    },
    getNotebook: function(projectKey, notebookName, kernelName) {
        return APIXHRService("GET", API_PATH + "jupyter/get-notebook", {projectKey:projectKey, name:notebookName, kernelName:kernelName});
    },
    createOnDataset: function(projectKey, datasetSmartName, language) {
        return APIXHRService("POST", API_PATH + "jupyter/new-dataset-notebook", {
            projectKey: projectKey,
            datasetSmartName: datasetSmartName,
            language: language
        });
    },
    create: function(projectKey, language) {
        return APIXHRService("POST", API_PATH + "jupyter/new-notebook", {
            projectKey: projectKey,
            language: language
        });
    },
    unload: function(session_id) {
        return APIXHRService("DELETE", JUPYTER_API_PATH + "api/sessions/" + session_id, {
        });
    },
    listHeads: function(projectKey, tagFilter) {
        return APIXHRService("GET", API_PATH + "jupyter/list-heads", {projectKey: projectKey, tagFilter: tagFilter});
    },
    listAccessible: function() {
        return APIXHRService("GET", API_PATH + "jupyter/list-accessible-notebooks");
    },
    listAll: function() {
        return APIXHRService("GET", API_PATH + "jupyter/list-all-notebooks");
    },
    mapNotebooksToExports: function(projectKey) {
        return APIXHRService("GET", API_PATH + "jupyter/map-notebook-exports", {projectKey: projectKey});
    },
    newNotebookWithTemplate: function(projectKey, baseName, templateDesc, codeEnv, containerConf) {
        return APIXHRService("POST", API_PATH + "jupyter/new-notebook-with-template", {
            projectKey: projectKey,
            baseName: baseName,
            templateDesc: JSON.stringify(templateDesc),
            codeEnv:codeEnv,
            containerConf:containerConf
        });
    },
    newNotebookFromFile: function(projectKey, baseName, language, datasetSmartName, file) {
        return uploadFileRequest('jupyter/new-notebook-from-file', formdata => {
            formdata.append('projectKey', projectKey);
            formdata.append('baseName', baseName);
            formdata.append('language', language);
            if (datasetSmartName) {
                formdata.append('datasetSmartName', datasetSmartName);
            }
            formdata.append('file', file);
        }, null);
    },
    newNotebookForDataset: function(projectKey, baseName, datasetSmartName, templateDesc, codeEnv, containerConf) {
        return APIXHRService("POST", API_PATH + "jupyter/new-notebook-for-dataset", {
            projectKey: projectKey,
            baseName: baseName,
            datasetSmartName: datasetSmartName,
            templateDesc: JSON.stringify(templateDesc),
            codeEnv:codeEnv,
            containerConf:containerConf
        });
    },
    createRecipeFromNotebook: function(projectKey, notebook, recipe) {
        return APIXHRService("POST", API_PATH + "jupyter/create-recipe-from-notebook", {
            projectKey: projectKey,
            notebook: notebook,
            recipe: JSON.stringify(recipe)
        });
    },
    saveBackToRecipe: function(projectKey, notebook) {
        return APIXHRService("POST", API_PATH + "jupyter/save-back-to-recipe", {
            projectKey: projectKey,
            notebook: notebook
        });
    },
    export: { // Should mostly stay in sync with reports.snapshots
        create: function(projectKey, notebookSmartName, execute) {
	    	return APIXHRService("POST", API_PATH + "jupyter/export/create", {
	            projectKey: projectKey,
	            notebookSmartName: notebookSmartName,
                execute: !!execute
	        });
    	},
    	get: function(projectKey, notebookSmartName, timestamp) {
    		return APIXHRService("GET", API_PATH + "jupyter/export/get", {
	            projectKey: projectKey,
	            notebookSmartName: notebookSmartName,
	            timestamp: timestamp
	        });
    	},
    	getLast: function(projectKey, notebookSmartName) {
    		return APIXHRService("GET", API_PATH + "jupyter/export/get-last", {
	            projectKey: projectKey,
	            notebookSmartName: notebookSmartName
	        });
    	},
        list: function(projectKey, notebookSmartName, withContent) {
    		return APIXHRService("GET", API_PATH + "jupyter/export/list", {
	            projectKey: projectKey,
	            notebookSmartName: notebookSmartName,
	            withContent: withContent
	        });
    	}
    },
    git: {
        listRemoteNotebooks: function(repository, ref) {
            return APIXHRService("GET", API_PATH + "jupyter/git/list-remote-notebooks", {repository, ref});
        },
        importNotebooks: function(projectKey, repository, ref, notebooks) {
            return APIXHRService("POST", API_PATH + "jupyter/git/import-remote-notebooks", {projectKey, repository, ref, notebooks: JSON.stringify(notebooks)});
        },
        getConflictingNotebooks: function(projectKey, notebooks, checkPull = false) {
            return APIXHRService("GET", API_PATH + "jupyter/git/get-conflicting-notebooks", {projectKey, checkPull, notebooks: JSON.stringify(notebooks)});
        },
        pushNotebooksToGit: function(projectKey, notebooks, message) {
            return APIXHRService("POST", API_PATH + "jupyter/git/push-remote-notebooks", {projectKey, message, notebooksWithHash: JSON.stringify(notebooks.map(n => ({notebookName: n.notebookName, remoteHashFileDuringConflict: n.remoteHashFileDuringConflict})))});
        },
        pullNotebooks: function(projectKey, notebooks) {
            return APIXHRService("POST", API_PATH + "jupyter/git/pull-remote-notebooks", {projectKey, notebooks: JSON.stringify(notebooks)});
        },
        editReference: function(projectKey, notebook, gitReference) {
            return APIXHRService("POST", API_PATH + "jupyter/git/edit-reference", {projectKey, notebook, reference: JSON.stringify(gitReference)});
        },
        unlinkReference: function(projectKey, notebook) {
            return APIXHRService("POST", API_PATH + "jupyter/git/unlink-reference", {projectKey, notebook});
        },
    }
},
continuousActivities: {
    start : function(projectKey, recipeId, loopParams) {
        return APIXHRService("POST", API_PATH + "continuous-activities/start", {projectKey: projectKey, recipeId:recipeId, loopParams:JSON.stringify(loopParams)});
    },
    stop : function(projectKey, recipeId) {
        return APIXHRService("POST", API_PATH + "continuous-activities/stop", {projectKey: projectKey, recipeId:recipeId});
    },
    listProjectStates: function(projectKey) {
        return APIXHRService("GET", API_PATH + "continuous-activities/list-project-states", {projectKey: projectKey});
    },
    getState: function(projectKey, continuousActivityId) {
        return APIXHRService("GET", API_PATH + "continuous-activities/get-state", {
            projectKey: projectKey, continuousActivityId: continuousActivityId
        }, 'nospinner');
    },
    getStates: function(projectKey) {
        return APIXHRService("GET", API_PATH + "continuous-activities/get-states", {
            projectKey: projectKey
        });
    },
    getFullInfo: function(projectKey, continuousActivityId) {
        return APIXHRService("GET", API_PATH + "continuous-activities/get-full-info", {
            projectKey: projectKey, continuousActivityId: continuousActivityId
        });
    },
    listLastRuns : function(projectKey, continuousActivityId) {
        return APIXHRService("GET", API_PATH + "continuous-activities/list-last-runs", {
            projectKey: projectKey, continuousActivityId: continuousActivityId
        });
    },
    listRunLastAttempts: function(projectKey, continuousActivityId, runId) {
        return APIXHRService("GET", API_PATH + "continuous-activities/list-run-last-attempts", {
            projectKey: projectKey, continuousActivityId: continuousActivityId,
            runId: runId,
        });
    },
    smartTailAttemptLog: function(projectKey, continuousActivityId, runId, attemptId) {
        return APIXHRService("GET", API_PATH + "continuous-activities/smart-tail-attempt-log", {
            projectKey: projectKey, continuousActivityId: continuousActivityId,
            runId: runId, attemptId: attemptId
        });
    },
    getGlobalStatus : function(){
        return APIXHRService("GET", API_PATH + "continuous-activities/get-global-status")
    },
    getDownloadURL: function(projectKey, continuousActivityId, runId, attemptId) {
        return API_PATH + "continuous-activities/cat-attempt-log?"
                 + "projectKey=" + encodeURIComponent(projectKey)
                 + "&continuousActivityId=" + encodeURIComponent(continuousActivityId)
                 + "&runId=" + encodeURIComponent(runId)
                 + "&attemptId=" + encodeURIComponent(attemptId);
    },
},
streamingEndpoints:  {
    listHeads: function(projectKey) {
        return APIXHRService("GET", API_PATH + "streaming-endpoints/list", {projectKey:projectKey})
    },
    listNames: function(projectKey) {
        return APIXHRService("GET", API_PATH + "streaming-endpoints/list-names/", {projectKey: projectKey});
    },
    create:function(projectKey, streamingEndpoint) {
      return APIXHRService("POST", API_PATH + "streaming-endpoints/create", {
            projectKey:projectKey,
            streamingEndpoint: JSON.stringify(streamingEndpoint
        )})
    },
    get: function(projectKey, id) {
        return APIXHRService("GET", API_PATH + "streaming-endpoints/get", {projectKey:projectKey, id:id})
    },
    save: function(projectKey, streamingEndpoint, saveInfo) {
        return APIXHRService("POST", API_PATH + "streaming-endpoints/save", {
            projectKey:projectKey,
            streamingEndpoint: JSON.stringify(streamingEndpoint),
            saveInfo:JSON.stringify(saveInfo)
        })
    },
    getFullInfo: function(projectKey, id) {
        return APIXHRService("GET", API_PATH + "streaming-endpoints/get-full-info", {projectKey:projectKey, id:id})
    },
    collectSample: function(projectKey, streamingEndpoint, limit, timeout, inferStorageTypes) {
        return APIXHRService("GET", API_PATH + "streaming-endpoints/collect-sample", {projectKey:projectKey, streamingEndpoint:JSON.stringify(streamingEndpoint), limit:limit, timeout:timeout, inferStorageTypes:inferStorageTypes})
    },
    testKafka: function(projectKey, streamingEndpoint) {
        return APIXHRService("POST", API_PATH + "streaming-endpoints/test-kafka", {projectKey:projectKey, streamingEndpoint:JSON.stringify(streamingEndpoint)})
    },
    testSQS: function(projectKey, streamingEndpoint) {
        return APIXHRService("POST", API_PATH + "streaming-endpoints/test-sqs", {projectKey:projectKey, streamingEndpoint:JSON.stringify(streamingEndpoint)})
    },
    testHttpSSE: function(projectKey, streamingEndpoint) {
        return APIXHRService("POST", API_PATH + "streaming-endpoints/test-httpsse", {projectKey:projectKey, streamingEndpoint:JSON.stringify(streamingEndpoint)})
    },
    syncKsql: function(projectKey, streamingEndpointId, terminateQueries) {
        return APIXHRService("POST", API_PATH + "streaming-endpoints/sync-ksql", {projectKey:projectKey, streamingEndpointId:streamingEndpointId, terminateQueries:terminateQueries || false})
    },
    fetchKafkaSchema: function(projectKey, streamingEndpoint) {
        return APIXHRService("POST", API_PATH + "streaming-endpoints/fetch-kafka-schema", {projectKey:projectKey, streamingEndpoint:JSON.stringify(streamingEndpoint)})
    }
},
flow: {
    zones: {
        create: (projectKey, name, color) => {
            return APIXHRService("POST", API_PATH + "flow/create-zone", { projectKey, name, color});
        },
        moveItems: (projectKey, zoneId, movingItems) => {
            return APIXHRService("POST", API_PATH + "flow/move-to-zone", { projectKey, zoneId, movingItems: JSON.stringify(movingItems)});
        },
        shareItems: (projectKey, zoneId, sharingItems) => {
            return APIXHRService("POST", API_PATH + "flow/share-to-zone", { projectKey, zoneId, sharingItems: JSON.stringify(sharingItems)});
        },
        unshareItems: (projectKey, zoneIds, sharingItems) => {
            return APIXHRService("POST", API_PATH + "flow/unshare-to-zone", { projectKey, zoneIds: JSON.stringify(zoneIds), sharingItems: JSON.stringify(sharingItems)});
        },
        list: projectKey => {
            return APIXHRService("GET", API_PATH + "flow/zones", { projectKey });
        },
        edit: (projectKey, id, name, color) => {
            return APIXHRService("POST", API_PATH + "flow/edit-zone", { projectKey, zoneId: id, newName: name, newColor: color});
        },
        delete: (projectKey, id) => {
            return APIXHRService("POST", `${API_PATH}flow/zones/${id}/delete`, { projectKey });
        },
        getZoneId: (projectKey, item) => {
            return APIXHRService("POST", `${API_PATH}flow/retrieve-zone-item`, { projectKey, item: JSON.stringify(item) });
        }
    },
    jobs: {
        /* ********** Status ************ */
        listLastJobs: function(projectKey, nb) {
            return APIXHRService("GET", API_PATH + "flow/jobs/list-last-jobs", {projectKey: projectKey, nb:nb});
        },
        listRunningJobs: function() {
            return APIXHRService("GET", API_PATH + "flow/jobs/list-running-jobs");
        },
        listAllRunningJobs: function() {
            return APIXHRService("GET", API_PATH + "flow/jobs/list-all-running-jobs");
        },
        getJobStatus: function(projectKey, jobId) {
            return APIXHRService("GET", API_PATH + "flow/jobs/get-job-status", {
                projectKey: projectKey,
                jobId: jobId,
            });
        },
        fetchYarnLogs: function(projectKey, jobId) {
            return APIXHRService("GET", API_PATH + "flow/jobs/fetch-yarn-logs", {
                projectKey: projectKey,
                jobId: jobId,
            });
        },
        getJobGraphURL: function(projectKey, jobId, type) {
            return API_PATH + "flow/jobs/get-job-graph?jobId=" + jobId + "&projectKey=" + projectKey+ "&type=" + type;
        },
        getJobGraphData: function(projectKey, jobId, type) {
            return APIXHRService("GET", API_PATH +  "flow/jobs/get-job-graph?jobId=" + jobId + "&projectKey=" + projectKey+ "&type=" + type);
        },
        tailJobLog: function(projectKey, jobId) {
            return APIXHRService("GET", API_PATH + "flow/jobs/tail-job-log", {
                projectKey: projectKey,
                jobId: jobId,
            });
        },
        getJobDiagnosisURL: function(projectKey, jobId) {
            return API_PATH + "flow/jobs/download-job-diagnosis?"
                     + "projectKey=" + encodeURIComponent(projectKey)
                     + "&jobId=" + encodeURIComponent(jobId);
        },
        smartTailActivityLog: function(projectKey, jobId, activityId, nbLines) {
            return APIXHRService("GET", API_PATH + "flow/jobs/smart-tail-activity-log", {
                projectKey: projectKey,
                jobId: jobId, activityId: activityId, nbLines: nbLines
            });
        },

        /* ************* Execution *********** */
        startPreview: function(data) {
            return APIXHRService("POST", API_PATH + "flow/jobs/start-preview/", {
                data: JSON.stringify(data)
            });
        },
        getPreviewResult: function(jobProjectKey, jobId) {
            return APIXHRService("GET", API_PATH + "flow/jobs/get-preview-result", {
                jobProjectKey: jobProjectKey,
                jobId: jobId
            });
        },
        validateRunFully: function(jobProjectKey, jobId, skippedActivityIds) {
            return APIXHRService("POST", API_PATH + "flow/jobs/validate-run-fully", {
                jobProjectKey: jobProjectKey,
                jobId: jobId,
                skippedActivityIds: JSON.stringify(skippedActivityIds)
            });
        },
        start: function(data) {
            return APIXHRService("POST", API_PATH + "flow/jobs/start/", {
                data: JSON.stringify(data)
            });
        },
        abort: function(jobProjectKey, jobId) {
            return APIXHRService("POST", API_PATH + "flow/jobs/abort/", {
                jobProjectKey: jobProjectKey,
                jobId: jobId
            });
        },
        retry: function(jobProjectKey, jobId) {
            return APIXHRService("POST", API_PATH + "flow/jobs/retry/", {
                jobProjectKey: jobProjectKey,
                jobId: jobId
            });
        },
        /* ***************** List handling *************** */
        clearLogsWithFilter: function(jobProjectKey, filter) {
            return  APIXHRService("POST", API_PATH + "flow/jobs/clear-logs-with-filter/", {
                jobProjectKey: jobProjectKey,
                filter:filter
            });
        },
        clearLogs: function(jobProjectKey, jobId) {
            return  APIXHRService("POST", API_PATH + "flow/jobs/clear-logs/", {
                jobProjectKey: jobProjectKey,
                jobId:jobId
            });
        }
    },
    status: {
        getDailyPartitionedDatasets: function() {
            return APIXHRService("GET", API_PATH + "flow/status/get-daily-partitioned-datasets");
        },
        initMultiStatusOperation: function() {
            return APIXHRService("GET", API_PATH + "flow/status/init-multi-status-operation");
        },
        getDatasetPartitionStatusMulti: function(operationId, dataset, partition) {
            return APIXHRService("GET", API_PATH + "flow/status/get-dataset-partition-status-multi", {
                operationId: operationId,
                dataset:dataset,
                partition:partition
            });
        }
    },
    snippets: {
    	getSnippets: function(snippetType, categories) {
            return APIXHRService("GET", API_PATH + "flow/snippets/get", {snippetType: snippetType, categories: categories.join(",")});
    	},
    	saveSnippet: function(snippetAsString, snippetType, category) {
            return APIXHRService("POST", API_PATH + "flow/snippets/save", {data: snippetAsString, snippetType: snippetType, category: category});
    	},
    	deleteSnippet: function(snippetId, snippetType) {
            return APIXHRService("POST", API_PATH + "flow/snippets/delete", {snippetId: snippetId, snippetType: snippetType});
    	}
    },
    refactoring: {
        startChangeConnections: function(projectKey, items) {
            // POST because request might be big
            return APIXHRService("POST", API_PATH + "flow/refactoring/start-change-connections", {
                projectKey: projectKey,
                items: JSON.stringify(items)
            });
        },
        testChangeConnections: function(projectKey, items, options) {
            return APIXHRService("POST", API_PATH + "flow/refactoring/test-change-connections", {
                projectKey: projectKey,
                items: JSON.stringify(items),
                options: JSON.stringify(options)
            });
        },
        changeConnections: function(projectKey, items, options) {
            return APIXHRService("POST", API_PATH + "flow/refactoring/change-connections", {
                projectKey: projectKey,
                items: JSON.stringify(items),
                options: JSON.stringify(options)
            });
        },
        startCopySubFlow: function(items) {
            // POST because request might be big
            return APIXHRService("POST", API_PATH + "flow/refactoring/start-copy-subflow", {
                items: JSON.stringify(items)
            });
        },
        testCopySubFlow: function(items, options, contextProjectKey) {
            // POST because request might be big
            return APIXHRService("POST", API_PATH + "flow/refactoring/test-copy-subflow", {
                items: JSON.stringify(items),
                options: JSON.stringify(options),
                contextProjectKey: contextProjectKey
            });
        },
        copySubFlow: function(items, options, contextProjectKey) {
            return APIXHRService("POST", API_PATH + "flow/refactoring/copy-subflow", {
                items: JSON.stringify(items),
                options: JSON.stringify(options),
                contextProjectKey: contextProjectKey
            });
        }
    },
    tools: {
        start: function(projectKey, type, data) {
            return APIXHRService("POST", API_PATH + "flow/tools/start", {
                projectKey: projectKey,
                type: type,
                data: JSON.stringify(data)
            });
        },
        stop: function(projectKey, toolId) {
            return APIXHRService("POST", API_PATH + "flow/tools/stop", {
                projectKey: projectKey,
                toolId: toolId
            });
        },
        getSessions: function(projectKey) {
            return APIXHRService("GET", API_PATH + "flow/tools/get-sessions", {
                projectKey: projectKey
            });
        },
        setActive: function(projectKey, toolId) {
            return APIXHRService("POST", API_PATH + "flow/tools/set-active", {
                projectKey: projectKey,
                toolId: toolId
            });
        },
        setDefaultActive: function(projectKey) {
            return APIXHRService("POST", API_PATH + "flow/tools/set-default-active", {
                projectKey: projectKey
            });
        },
        getState: function(projectKey, tool, options, spinnerMode) {
            return APIXHRService("GET", API_PATH + "flow/tools/get-state", {
                projectKey: projectKey,
                tool: tool,
                options: JSON.stringify(options)
            }, spinnerMode);
        },
        setFocused: function(projectKey, focused, mode) {
            return APIXHRService("POST", API_PATH + "flow/tools/set-focused", {
                projectKey: projectKey,
                focused: JSON.stringify(focused),
                mode : mode
            }, 'nospinner');
        },
        startUpdate: function(projectKey, tool, updateOptions) {
            return APIXHRService("POST", API_PATH + "flow/tools/start-update", {
                projectKey: projectKey,
                tool: tool,
                updateOptions: JSON.stringify(updateOptions)
            });
        },
        propagateSchema: {
            markRecipeAsOKForced: function(projectKey, recipeName) {
                return APIXHRService("POST", API_PATH + "flow/tools/propagate-schema/mark-recipe-as-ok-forced", {
                    projectKey: projectKey,
                    recipeName: recipeName
                });
            },
            markRecipeAsOKAfterUpdate: function(projectKey, recipeName) {
                return APIXHRService("POST", API_PATH + "flow/tools/propagate-schema/mark-recipe-as-ok-after-update", {
                    projectKey: projectKey,
                    recipeName: recipeName
                });
            },
            markDatasetAsBeingRebuilt: function(projectKey, datasetName) {
                return APIXHRService("POST", API_PATH + "flow/tools/propagate-schema/mark-dataset-as-being-rebuilt", {
                    projectKey: projectKey,
                    datasetName: datasetName
                });
            },
            runAutomatically: function(projectKey, datasetName, rebuild, recipeUpdateOptions, excludedRecipes, partitionByDim, partitionByComputable, markAsOkRecipes) {
                return APIXHRService("POST", API_PATH + "flow/tools/propagate-schema/run-automatically", {
                    projectKey: projectKey,
                    datasetName: datasetName,
                    rebuild: rebuild,
                    recipeUpdateOptions: JSON.stringify(recipeUpdateOptions),
                    partitionByDim: JSON.stringify(partitionByDim),
                    partitionByComputable: JSON.stringify(partitionByComputable),
                    excludedRecipes: JSON.stringify(excludedRecipes),
                    markAsOkRecipes: JSON.stringify(markAsOkRecipes)
                });
            }
        },
        checkConsistency: {
            markAsOK: function(projectKey, nodeIds) {
                return APIXHRService("POST", API_PATH + "flow/tools/check-consistency/mark-as-ok", {
                    projectKey: projectKey,
                    nodeIds: JSON.stringify(nodeIds)
                });
            },
            recheck: function(projectKey, nodeIds) {
                return APIXHRService("POST", API_PATH + "flow/tools/check-consistency/recheck", {
                    projectKey: projectKey,
                    nodeIds: JSON.stringify(nodeIds)
                });
            }
        }
    },
    recipes: {
        getTypesDescriptors: function(recipeData, role) {
            return APIXHRService("GET", API_PATH + "flow/recipes/get-types-descriptors");
        },
        list: function(projectKey) {
            return APIXHRService("GET", API_PATH + "flow/recipes/list", {projectKey: projectKey});
        },
        listHeads: function(projectKey, tagFilter) {
            return APIXHRService("GET", API_PATH + "flow/recipes/list-heads", {projectKey: projectKey, tagFilter: tagFilter});
        },
        getWithInlineScript: function(projectKey, name) {
            return APIXHRService("GET", API_PATH + "flow/recipes/get-with-inline-script", {
                projectKey: projectKey, name:name
            });
        },
        getFullInfo: function(projectKey, name) {
            return APIXHRService("GET", API_PATH + "flow/recipes/get-full-info", {
                projectKey: projectKey, name:name
            });
        },
        save: function(projectKey, recipe, scriptData, commitMessage) {
            return APIXHRService("POST", API_PATH + "flow/recipes/save", {
                projectKey: projectKey,
                recipe:JSON.stringify(recipe),
                scriptData: scriptData,
                commitMessage: commitMessage
            });
        },
        rename: function(projectKey, origName, newName) {
            return APIXHRService("POST", API_PATH + "flow/recipes/rename", {
                projectKey: projectKey, origName: origName, newName: newName
            });
        },
        getShakerSaveImpact: function(projectKey, recipe, shaker, outputSchema) {
            return APIXHRService("POST", API_PATH + "flow/recipes/get-shaker-save-impact", {
                projectKey: projectKey,
                recipe:JSON.stringify(recipe),
                shaker: JSON.stringify(shaker),
                outputSchema: JSON.stringify(outputSchema)
            });
        },
        checkSaveConflict: function(projectKey, name, recipe) {
            return APIXHRService("POST", API_PATH + "flow/recipes/check-save-conflict", {
                projectKey: projectKey,
                name:name,
                recipe:JSON.stringify(recipe)
            });
        },
        getComputableSaveImpact: function(projectKey, recipeData, payloadData) {
            return APIXHRService("POST", API_PATH + "flow/recipes/get-computable-save-impact", {
                projectKey: projectKey, recipe: JSON.stringify(recipeData),
                payload: payloadData
            })
        },
        getComputableSaveImpacts: function(projectKey, recipesData, payloadsData) {
            return APIXHRService("POST", API_PATH + "flow/recipes/get-computable-save-impacts", {
                projectKey: projectKey,
                recipes: JSON.stringify(recipesData),
                payloads: JSON.stringify(payloadsData)
            })
        },
        saveOutputSchema: function(projectKey, computableType, computableId, newSchema, dropAndRecreate, synchronizeMetastore, extraOptions) {
            return APIXHRService("POST", API_PATH + "flow/recipes/save-output-schema", {
                projectKey: projectKey, computableType: computableType, computableId: computableId,
                newSchema: JSON.stringify(newSchema),
                dropAndRecreate: dropAndRecreate,
                synchronizeMetastore: synchronizeMetastore,
                extraOptions: extraOptions == null ? null : JSON.stringify(extraOptions)
            })
        },
        get: function(projectKey, name) {
            return APIXHRService("GET", API_PATH + "flow/recipes/get", {projectKey: projectKey, name:name});
        },
        checkNotebookEdition: function(projectKey, name) {
            return APIXHRService("GET", API_PATH + "flow/recipes/check-notebook-edition", {projectKey:projectKey, name:name});
        },
        editInNotebook: function(projectKey, name, codeEnvSelection, containerSelection) {
            return APIXHRService("POST", API_PATH + "flow/recipes/edit-in-notebook", {projectKey:projectKey, name:name, codeEnvSelection:(codeEnvSelection ? JSON.stringify(codeEnvSelection) : null), containerSelection:(containerSelection ? JSON.stringify(containerSelection) : null)});
        },
        getGraph: function(projectKey, tagFilter, withSvg, drawZones, zoneId, collapsedZones) {
            return APIXHRService("GET", API_PATH + "flow/recipes/get-graph-serialized", {projectKey: projectKey, tagFilter: tagFilter, withSvg: withSvg, drawZones: drawZones, zoneId: zoneId, collapsedZones: JSON.stringify(collapsedZones)});
        },
        getHiveCompatibilityStatus: function() {
            return APIXHRService("GET", API_PATH + "flow/recipes/get-hive-compatibility-status");
        },
        basicResyncSchema: function(projectKey, recipe) {
            return APIXHRService("POST", API_PATH + "flow/recipes/basic-resync-schema", {
                projectKey: projectKey, recipeData: JSON.stringify(recipe)
            });
        },
        basicDropSchema: function(projectKey, recipe) {
            return APIXHRService("POST", API_PATH + "flow/recipes/basic-drop-schema", {
                projectKey: projectKey, recipeData: JSON.stringify(recipe)
            });
        },
        /* Get the schema update result for a single recipe.
         * This is the call used when you are NOT editing the recipe.
         */
        getSchemaUpdateResult: function(projectKey, recipeName) {
            return APIXHRService("GET", API_PATH + "flow/recipes/get-schema-update-result", {
                projectKey:projectKey,
                recipeName:recipeName
            });
        },
        getRequirements: function(projectKey, recipeType) {
            return APIXHRService("GET", API_PATH + "flow/recipes/get-requirements", {
                projectKey:projectKey,
                recipeType:recipeType
            });
        },
        getIOChangeResult: function(projectKey, recipeAndPayloadBefore, recipeAndPayloadAfter) {
            return APIXHRService("POST", API_PATH + "flow/recipes/get-io-change-result", {
                projectKey: projectKey,
                recipeAndPayloadBefore : JSON.stringify(recipeAndPayloadBefore),
                recipeAndPayloadAfter : JSON.stringify(recipeAndPayloadAfter)
            });
        },
        getInsertableFragments: function(projectKey, recipe) {
            return APIXHRService("POST", API_PATH + "flow/recipes/get-insertable-fragments", {
                projectKey: projectKey,
                recipe : JSON.stringify(recipe)
            });
        },
        massActions: {
            startSetImpalaWriteMode(recipes, runInStreamMode) {
                // POST because query might be big
                return APIXHRService("POST", API_PATH + "flow/recipes/mass-actions/start-set-impala-write-mode", {
                    recipes: JSON.stringify(recipes)
                });
            },
            setImpalaWriteMode(recipes, runInStreamMode) {
                return APIXHRService("POST", API_PATH + "flow/recipes/mass-actions/set-impala-write-mode", {
                    recipes: JSON.stringify(recipes),
                    runInStreamMode: runInStreamMode
                });
            },
            startSetHiveEngine(recipes) {
                // POST because query might be big
                return APIXHRService("POST", API_PATH + "flow/recipes/mass-actions/start-set-hive-engine", {
                    recipes: JSON.stringify(recipes)
                });
            },
            setHiveEngine(recipes, executionEngine) {
                return APIXHRService("POST", API_PATH + "flow/recipes/mass-actions/set-hive-engine", {
                    recipes: JSON.stringify(recipes),
                    executionEngine: executionEngine
                });
            },
            startSetSparkEngine(recipes) {
                // POST because query might be big
                return APIXHRService("POST", API_PATH + "flow/recipes/mass-actions/start-set-spark-engine", {
                    recipes: JSON.stringify(recipes)
                });
            },
            setSparkEngine(recipes, executionEngine) {
                return APIXHRService("POST", API_PATH + "flow/recipes/mass-actions/set-spark-engine", {
                    recipes: JSON.stringify(recipes),
                    executionEngine: executionEngine
                });
            },
            startSetSparkConfig(recipes, sparkConfig) {
                // POST because query might be big
                return APIXHRService("POST", API_PATH + "flow/recipes/mass-actions/start-set-spark-config", {
                    recipes: JSON.stringify(recipes),
                    sparkConfig: JSON.stringify(sparkConfig)
                });
            },
            setSparkConfig(recipes, sparkConfig) {
                return APIXHRService("POST", API_PATH + "flow/recipes/mass-actions/set-spark-config", {
                    recipes: JSON.stringify(recipes),
                    sparkConfig: JSON.stringify(sparkConfig)
                });
            },
            startSetPipelineability(recipes, pipelineType) {
                // POST because query might be big
                return APIXHRService("POST", API_PATH + "flow/recipes/mass-actions/start-set-pipelineability", {
                    recipes: JSON.stringify(recipes),
                    pipelineType: pipelineType
                });
            },
            setPipelineability(recipes, pipelineType, allowStart, allowMerge) {
                return APIXHRService("POST", API_PATH + "flow/recipes/mass-actions/set-pipelineability", {
                    recipes: JSON.stringify(recipes),
                    pipelineType: pipelineType,
                    allowStart: allowStart,
                    allowMerge: allowMerge
                });
            },
            testConvertToImpala(recipes, checkRecipesRunOnImpala) {
                // POST because query might be big
                return APIXHRService("POST", API_PATH + "flow/recipes/mass-actions/test-convert-to-impala", {
                    recipes: JSON.stringify(recipes),
                    checkRecipesRunOnImpala: checkRecipesRunOnImpala
                });
            },
            convertToImpala(recipes, checkRecipesRunOnImpala) {
                return APIXHRService("POST", API_PATH + "flow/recipes/mass-actions/convert-to-impala", {
                    recipes: JSON.stringify(recipes),
                    checkRecipesRunOnImpala: checkRecipesRunOnImpala
                });
            },
            testConvertToHive(recipes, checkRecipesRunOnHive) {
                // POST because query might be big
                return APIXHRService("POST", API_PATH + "flow/recipes/mass-actions/test-convert-to-hive", {
                    recipes: JSON.stringify(recipes),
                    checkRecipesRunOnHive: checkRecipesRunOnHive
                });
            },
            convertToHive(recipes, checkRecipesRunOnHive) {
                return APIXHRService("POST", API_PATH + "flow/recipes/mass-actions/convert-to-hive", {
                    recipes: JSON.stringify(recipes),
                    checkRecipesRunOnHive: checkRecipesRunOnHive
                });
            },
            startChangeEngines(recipes) {
                // POST because query might be big
                return APIXHRService("POST", API_PATH + "flow/recipes/mass-actions/start-change-engines", {
                    recipes: JSON.stringify(recipes)
                });
            },
            testChangeEngines(recipes, engine) {
                // POST because query might be big
                return APIXHRService("POST", API_PATH + "flow/recipes/mass-actions/test-change-engines", {
                    recipes: JSON.stringify(recipes),
                    engine: engine
                });
            },
            changeEngines(recipes, engine) {
                return APIXHRService("POST", API_PATH + "flow/recipes/mass-actions/change-engines", {
                    recipes: JSON.stringify(recipes),
                    engine: engine
                });
            },
            changeCodeEnv(recipes, envSelection) {
                return APIXHRService("POST", API_PATH + "flow/recipes/mass-actions/change-code-env", {
                    recipes: JSON.stringify(recipes),
                    envSelection: JSON.stringify(envSelection)
                });
            }
        },
        visual: {
            convert: function(projectKey, recipe, payload, target) {
                return APIXHRService("POST", API_PATH + "flow/recipes/visual/convert", {
                    projectKey: projectKey, recipeData: JSON.stringify(recipe),
                    payload: payload, target: target
                });
            },
            convertSamplingRecipeToSplitRecipe: function(projectKey, recipe, secondOutputDataset) {
                return APIXHRService("POST", API_PATH + "flow/recipes/visual/convert-sampling-to-split", {
                    projectKey: projectKey,
                    recipeName: recipe.name,
                    secondOutputDataset: secondOutputDataset
                });
            },
            testInputReplacement: function (projectKey, recipe, payload, inputIndex, newInputName) {
            return APIXHRService("POST", API_PATH + "flow/recipes/visual/test-input-replacement", {
                    projectKey: projectKey,
                    recipeData: JSON.stringify(recipe),
                    payloadData: payload,
                    inputIndex: inputIndex,
                    newInputName: newInputName
                });
            }
        },
        download: {
            checkDownloadURL: function(projectKey, url) {
                return APIXHRService("POST", API_PATH + "recipes/download/check-url", { url: url, projectKey: projectKey });
            },
            checkDownloadSource: function(projectKey, recipe, source, partitionId) {
            return APIXHRService("POST", API_PATH + "recipes/download/check-source", {
                    recipe: JSON.stringify(recipe),
                    source: JSON.stringify(source),
                    projectKey: projectKey,
                    partitionId: partitionId
                });
            }
        },
        filter: {
            validateExpression: function(expression, schemaData, projectKey) {
            return APIXHRService("POST", API_PATH + "recipes/validate-expression", {
                    schemaData: schemaData,
                    expression: expression,
                    projectKey: projectKey
                }, "nospinner");
            },
            validateAst: function(ast, projectKey) {
            return APIXHRService("POST", API_PATH + "recipes/validate-ast", {
                    astData: JSON.stringify(ast),
                    projectKey: projectKey
                }, "nospinner");
            }
        },
        join: {
            getSuggestions: function(projectKey, recipe, payload) {
            return APIXHRService("POST", API_PATH + "flow/recipes/join/get-suggestions", {
                    projectKey: projectKey,
                    recipeData: JSON.stringify(recipe),
                    payloadData: payload
                });
            }
        },
        fuzzyjoin: {
            getSuggestions: function(projectKey, recipe, payload) {
            return APIXHRService("POST", API_PATH + "flow/recipes/fuzzyjoin/get-suggestions", {
                    projectKey: projectKey,
                    recipeData: JSON.stringify(recipe),
                    payloadData: payload
                });
            }
        },
        pig: {
            check: function(projectKey, recipe, scriptData, targetPartition) {
            return APIXHRService("POST", API_PATH + "flow/recipes/pig/check", {
                    projectKey: projectKey, recipeData: JSON.stringify(recipe),
                    scriptData: scriptData, targetPartition: targetPartition
                });
            }
        },
        shell: {
            check: function(projectKey, recipe, scriptData, targetPartition) {
            return APIXHRService("POST", API_PATH + "flow/recipes/shell/check", {
                    projectKey: projectKey, recipeData: JSON.stringify(recipe),
                    scriptData: scriptData, targetPartition: targetPartition
                });
            }
        },
        scala: {
            checkSyntax: function(projectKey, recipe, scriptData, targetPartition) {
            return APIXHRService("POST", API_PATH + "flow/recipes/scala/check-syntax", {
                    projectKey: projectKey, recipeData: JSON.stringify(recipe),
                    scriptData: scriptData, targetPartition: targetPartition
                });
            },
            convertToCustom: function(targetPluginId, targetPluginMode, scriptData, recipeFolder, recipeSerialized) {
            return APIXHRService("POST", API_PATH + "flow/recipes/scala/convert-to-custom", {
                    targetPluginId: targetPluginId,
                    targetPluginMode: targetPluginMode,
                    scriptData: scriptData,
                    recipeFolder: recipeFolder,
                    codeMode: recipeSerialized.params.codeMode
                });
            }
        },
        python: {
            checkSyntax: function(projectKey, recipe, scriptData, targetPartition) {
            return APIXHRService("POST", API_PATH + "flow/recipes/python/check-syntax", {
                    projectKey: projectKey, recipeData: JSON.stringify(recipe),
                    scriptData: scriptData, targetPartition: targetPartition
                });
            },
            convertToCustom: function(targetPluginId, targetPluginMode, scriptData, recipeFolder, recipe) {
            return APIXHRService("POST", API_PATH + "flow/recipes/python/convert-to-custom", {
                    targetPluginId: targetPluginId,
                    targetPluginMode: targetPluginMode,
                    recipeData: JSON.stringify(recipe),
                    scriptData: scriptData,
                    recipeFolder: recipeFolder
                });
            }
        },
        hive: {
            checkImpalaConvertibility: function(projectKey, recipe, scriptData, targetPartition) {
            return APIXHRService("POST", API_PATH + "flow/recipes/hive/check-impala-convertibility", {
                    projectKey: projectKey, recipeData: JSON.stringify(recipe),
                    scriptData: scriptData, targetPartition: targetPartition
                });
            }
        },
        impala: {
            validate: function(projectKey, recipe, scriptData, targetPartition) {
            return APIXHRService("POST", API_PATH + "flow/recipes/impala/validate", {
                    projectKey: projectKey, recipeData: JSON.stringify(recipe),
                    scriptData: scriptData, targetPartition: targetPartition
                });
            },
            getExecutionPlan: function(projectKey, recipe, scriptData, targetPartition) {
            return APIXHRService("POST", API_PATH + "flow/recipes/impala/get-execution-plan", {
                    projectKey: projectKey,
                    recipe: JSON.stringify(recipe),
                    script: scriptData,
                    targetPartition: targetPartition
                });
            },
            run: function(projectKey, recipe, scriptData, targetPartition) {
            return APIXHRService("POST", API_PATH + "flow/recipes/impala/run", {
                    projectKey: projectKey, recipe: JSON.stringify(recipe),
                    script: scriptData, targetPartition: targetPartition
                });
            },
            checkFullSqlAvailability: function(projectKey, recipe) {
            return APIXHRService("POST", API_PATH + "flow/recipes/impala/check-full-sql-availability", {
                    projectKey: projectKey, recipeData: JSON.stringify(recipe)
                });
            }
        },
        sqlScript: {
            validate: function(projectKey, recipe, scriptData, targetPartition) {
            return APIXHRService("POST", API_PATH + "flow/recipes/sql-script/validate", {
                    projectKey: projectKey, recipe: JSON.stringify(recipe),
                    script: scriptData, targetPartition: targetPartition
                });
            }
        },
        sqlQuery: {
            //TODO merge validate/get execution plan?
            validate: function(projectKey, recipe, scriptData, targetPartition) {
            return APIXHRService("POST", API_PATH + "flow/recipes/sql-query/validate", {
                    projectKey: projectKey, recipe: JSON.stringify(recipe),
                    script: scriptData, targetPartition: targetPartition
                });
            },
            getExecutionPlan: function(projectKey, recipe, scriptData, targetPartition) {
            return APIXHRService("POST", API_PATH + "flow/recipes/sql-query/get-execution-plan", {
                    projectKey: projectKey,
                    recipe: JSON.stringify(recipe),
                    script: scriptData,
                    targetPartition: targetPartition
                });
            },
            run: function(projectKey, recipe, scriptData, targetPartition) {
            return APIXHRService("POST", API_PATH + "flow/recipes/sql-query/run", {
                    projectKey: projectKey, recipe: JSON.stringify(recipe),
                    script: scriptData, targetPartition: targetPartition
                });
            }
        },
        sparkSql: {
            //TODO merge validate/get execution plan?
            validate: function(projectKey, recipe, scriptData, targetPartition) {
            return APIXHRService("POST", API_PATH + "flow/recipes/sparksql-query/validate", {
                    projectKey: projectKey, recipe: JSON.stringify(recipe),
                    query: scriptData, targetPartition: targetPartition
                });
            },
        },
        r: {
             validate: function(projectKey, recipe, scriptData, targetPartition) {
            return APIXHRService("POST", API_PATH + "flow/recipes/r/validate", {
                    projectKey: projectKey, recipeData: JSON.stringify(recipe),
                    scriptData: scriptData, targetPartition: targetPartition
                });
            },
            convertToCustom: function(targetPluginId, targetPluginMode, scriptData, recipeFolder) {
            return APIXHRService("POST", API_PATH + "flow/recipes/r/convert-to-custom", {
                    targetPluginId: targetPluginId,
                    targetPluginMode: targetPluginMode,
                    scriptData: scriptData,
                    recipeFolder: recipeFolder
                });
            }
        },
        pyspark: {
            convertToCustom: function(targetPluginId, targetPluginMode, scriptData, recipeFolder) {
            return APIXHRService("POST", API_PATH + "flow/recipes/pyspark/convert-to-custom", {
                    targetPluginId: targetPluginId,
                    targetPluginMode: targetPluginMode,
                    scriptData: scriptData,
                    recipeFolder: recipeFolder
                });
            }
        },
        pivot: {
            getDatasetModalities: function(projectKey, datasetSmartName, pivot) {
                return APIXHRService("POST", API_PATH + "flow/recipes/pivot/get-dataset-modalities", {
                    projectKey : projectKey,
                    datasetSmartName : datasetSmartName,
                    pivot : JSON.stringify(pivot)
                });
            }
        },
        generic: {
            create: function(recipe, creationSettings) {
                return APIXHRService("POST", API_PATH + "flow/recipes/generic/create", {
                    recipeData : JSON.stringify(recipe),
                    creationSettingsData: JSON.stringify(creationSettings)
                });
            },
            copy: function(projectKey, sourceProjectKey, sourceRecipeName, copySettings) {
                return APIXHRService("POST", API_PATH + "flow/recipes/generic/copy", {
                    projectKey: projectKey,
                    sourceProjectKey: sourceProjectKey,
                    sourceRecipeName : sourceRecipeName,
                    copySettingsData: JSON.stringify(copySettings)
                });
            },
            getStatus : function(recipe, payload, sequenceId, request) {
                return APIXHRService("POST", API_PATH + "flow/recipes/generic/get-status", {
                    recipeData: JSON.stringify(recipe),
                    payloadData: payload,
                    sequenceId: sequenceId,
                    requestData : JSON.stringify(request)
                }, "nospinner");
            },
            getStatusWithSpinner: function(recipe, payload, sequenceId, request) {
                return APIXHRService("POST", API_PATH + "flow/recipes/generic/get-status", {
                    recipeData: JSON.stringify(recipe),
                    payloadData: payload,
                    sequenceId: sequenceId,
                    requestData : JSON.stringify(request)
                });
            },
            validate: function(projectKey, recipe) {
            return APIXHRService("POST", API_PATH + "flow/recipes/generic/validate", {
                    projectKey: projectKey, recipe: JSON.stringify(recipe)
                });
            },
            pdepTest: function(recipe, pdepInputRef, pdep) {
                return APIXHRService("POST", API_PATH + "flow/recipes/pdep-test", {
                    recipeData: JSON.stringify(recipe),
                    pdepInputRef : pdepInputRef,
                    pdepData: JSON.stringify(pdep)
                });
            },
            getVariables: function(projectKey) {
                return APIXHRService("GET", API_PATH + "flow/recipes/generic/get-variables", {
                    projectKey: projectKey
                });
            }
        }
    },
    listUsableComputables: function(projectKey, filter) {
        return APIXHRService("GET", API_PATH + "flow/list-usable-computable", {
            projectKey: projectKey,
            filter: JSON.stringify(filter)
        });
    },
    listDownstreamComputables: function(projectKey, from) {
        return APIXHRService("GET", API_PATH + "flow/list-downstream-computable",
            angular.extend({projectKey: projectKey}, from)
        );
    },
    getComputables: function(taggableObjectRefs) {
        // POST because query might be big
        return APIXHRService("POST", API_PATH + "flow/get-computables", {
            items: JSON.stringify(taggableObjectRefs)
        });
    },
    getObjectContext: function(projectKey, objectType, objectId) {
        return APIXHRService("GET", API_PATH + "flow/get-object-context", {
            projectKey: projectKey,
            objectType: objectType,
            objectId: objectId
        }, "nospinner");
    },
    applyFlowFilter: function(projectKey, filter, drawZones, zoneId, collapsedZones) {
        return APIXHRService("GET", API_PATH + "flow/apply-flow-filtering", {projectKey: projectKey, filter: filter, drawZones: drawZones, zoneId: zoneId, collapsedZones: JSON.stringify(collapsedZones)});
    },
    loadFlowFilterSettings: function(projectKey, zoneId, collapsedZones) {
        return APIXHRService("GET", API_PATH + "flow/load-flow-filter-settings", {projectKey: projectKey, zoneId: zoneId, collapsedZones: JSON.stringify(collapsedZones)});
    },
    saveProjectFlowFilter: function(projectKey, filter, drawZones, zoneId, collapsedZones) {
        return APIXHRService("POST", API_PATH + "flow/save-project-flow-filter", {projectKey: projectKey, filter: JSON.stringify(filter), drawZones: drawZones, zoneId: zoneId, collapsedZones: JSON.stringify(collapsedZones)});
    },
    activateFlowFilter: function(projectKey, id, drawZones, zoneId, collapsedZones) {
        return APIXHRService("POST", API_PATH + "flow/activate-flow-filter", {projectKey: projectKey, id: id, drawZones: drawZones, zoneId: zoneId, collapsedZones: JSON.stringify(collapsedZones)});
    },
    enableFlowFiltering: function(projectKey, enable, collapsedZones) {
        return APIXHRService("POST", API_PATH + "flow/enable-flow-filter", {projectKey: projectKey, enable: enable, collapsedZones: JSON.stringify(collapsedZones)});
    },
    deleteFlowFilter: function(projectKey, id, drawZones, zoneId, collapsedZones) {
        return APIXHRService("POST", API_PATH + "flow/delete-flow-filter", {projectKey: projectKey, id: id, drawZones: drawZones, zoneId: zoneId, collapsedZones: JSON.stringify(collapsedZones)});
    },
    revertDirtyFilter: function(projectKey, id, drawZones, zoneId, collapsedZones) {
        return APIXHRService("POST", API_PATH + "flow/revert-dirty-filter", {projectKey: projectKey, id: id, drawZones: drawZones, zoneId: zoneId, collapsedZones: JSON.stringify(collapsedZones)});
    },
    export: function(projectKey, exportFormat) {
        return APIXHRService("POST", API_PATH + "flow/export", { projectKey: projectKey, exportFormat: JSON.stringify(exportFormat) });
    },
    getExportURL: function(projectKey, exportId) {
        return API_PATH + "flow/download-export?"
            + "projectKey=" + encodeURIComponent(projectKey)
            + "&exportId=" + encodeURIComponent(exportId);
    }
},
profile: {
    get: function(login) {
        if(login) {
            return APIXHRService("GET", API_PATH + "/profile/get", {login:login});
        } else {
            return APIXHRService("GET", API_PATH + "/profile/get");
        }
    },
    achievements: function(login) {
        return APIXHRService("GET", API_PATH + "/profile/achievements", {login:login});
    },
    setNPSSettings: function(action) {
        return APIXHRService("POST", API_PATH + "/myprofile/update-nps-settings" , { action: action });
    },
    edit: function(user) {
        return APIXHRService("POST", API_PATH + "/myprofile/edit" , {user: JSON.stringify(user)});
    },
    uploadPicture: function(file) {
        var url = API_PATH + "myprofile/upload-picture";

        // angular doesn't provide a way to get the progress event yet, we explicitly redo it
        var deferred = $q.defer();

        var xhr = new XMLHttpRequest();

        xhr.addEventListener("load", function(e) {
            deferred.resolve((e.target||e.srcElement).response);
            $rootScope.$apply();
        }, false);
        xhr.addEventListener("error", function(e) {deferred.reject(e);$rootScope.$apply();}, false);

        xhr.open("POST", url);
        xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');

        var formdata = new FormData();
        formdata.append("file", file);
        xhr.send(formdata);

        return deferred.promise;
    },
    setUserSettings: function(userSettings) {
    	return APIXHRService("POST", API_PATH + "/myprofile/set-user-settings" , {userSettingsAsString: JSON.stringify(userSettings)});
    },
    listPersonalAPIKeys: function(){
        return APIXHRService("GET", API_PATH + "/publicapi/list-personal-api-keys");
    },
    createPersonalAPIKey : function(){
        return APIXHRService("POST", API_PATH + "/publicapi/create-personal-api-key");
    },
    deletePersonalAPIKey: function(key) {
        return APIXHRService("POST", API_PATH + "/publicapi/delete-personal-api-key",{
            key:key
        });
    },
    listConnectionCredentials : function(){
        return APIXHRService("GET", API_PATH + "/myprofile/list-connection-credentials");
    },
    setBasicConnectionCredential : function(connection, user, password){
        return APIXHRService("POST", API_PATH + "/myprofile/set-basic-connection-credential",{
            connection: connection,
            user: user,
            password: password
        });
    },
    connectionCredentials: {
        azureOAuthDeviceCodeDanceStep1: function(connection) {
            return APIXHRService("POST", API_PATH + "myprofile/connection-credentials/azure-oauth-devicecode-dance-step1",{
                connection: connection
            });
        },
        azureOAuthDeviceCodeDanceStep2: function(connection, deviceCode) {
            return APIXHRService("POST", API_PATH + "myprofile/connection-credentials/azure-oauth-devicecode-dance-step2",{
                connection: connection,
                deviceCode: JSON.stringify(deviceCode)
            });
        },
        getOAuth2AuthorizationEndpoint: function(dssUrl, userCurrentState, connection) {
            return APIXHRService("POST", API_PATH + "myprofile/connection-credentials/oauth2-authorization-endpoint", {
                dssUrl: dssUrl,
                userCurrentState: userCurrentState,
                connection: connection
            });
        }
    },
    pluginCredentials: {
        setBasicCredential : function(pluginId, paramSetId, presetId, paramName, user, password){
            return APIXHRService("POST", API_PATH + "/myprofile/plugin-credentials/set-basic-credential", {
                pluginId: pluginId,
                paramSetId: paramSetId,
                presetId: presetId,
                paramName: paramName,
                user: user,
                password: password
            });
        },
        getOAuth2AuthorizationEndpoint: function(dssUrl, userCurrentState, pluginId, paramSetId, presetId, paramName) {
            return APIXHRService("GET", API_PATH + "myprofile/plugin-credentials/oauth2-authorization-endpoint", {
                dssUrl: dssUrl,
                userCurrentState: userCurrentState,
                pluginId: pluginId,
                paramSetId: paramSetId,
                presetId: presetId,
                paramName: paramName
            });
        }
    }
},
globalTags: {
    getGlobalTagsInfo: function() {
        return APIXHRService("GET", API_PATH + "global-tags/get-global-tags-info");
    }
},
variables: {
    expandExpr: function(projectKey, expr) {
         return APIXHRService("GET", API_PATH + "/variables/expand-expr", {
            projectKey: projectKey, expr: expr
         });
    }
},
integrations: {
    listChannelsForIntegrationType: function(integrationType) {
        return APIXHRService("GET", API_PATH + "/integrations/list-available-channels-for-integration-type", {
            integrationType: integrationType
        })
    }
},
codeenvs: {
    list: function(envLang) {
        return APIXHRService("GET", API_PATH + "code-envs/list",{ envLang: envLang })
    },
    listNames: function(envLang) {
        return APIXHRService("GET", API_PATH + "code-envs/list-names",{ envLang: envLang })
    },
    listNamesWithDefault: function(envLang, projectKey) {
        return APIXHRService("GET", API_PATH + "code-envs/list-names-with-default",{ envLang: envLang, projectKey:projectKey })
    },
    listWithVisualMlPackages: function(projectKey) {
        return APIXHRService("GET", API_PATH + "code-envs/list-python-with-visual-ml-packages", {projectKey: projectKey})
    },
    listForPlugins: function(pluginId) {
        return APIXHRService("GET", API_PATH + "code-envs/plugin/list",{ pluginId: pluginId })
    },
    createForPlugin: function(pluginId, desc) {
        return APIXHRService("GET", API_PATH + "code-envs/plugin/create",{ pluginId: pluginId, desc: JSON.stringify(desc) })
    },
    updateForPlugin: function(pluginId, envName) {
        return APIXHRService("GET", API_PATH + "code-envs/plugin/update",{ pluginId: pluginId, envName: envName })
    },
    listUsages: function(projectKey) {
        return APIXHRService("GET", API_PATH + "code-envs/list-usages",{ projectKey: projectKey })
    }
},
containers: {
    listNames: function() {
        return APIXHRService("GET", API_PATH + "containers/list-names");
    },
    listSparkNames: function() {
        return APIXHRService("GET", API_PATH + "containers/list-spark-names");
    },
    listNamesWithDefault: function(projectKey, type) {
        return APIXHRService("GET", API_PATH + "containers/list-names-with-default", { projectKey, type })
    },
    getConfigInfo: function(projectKey, exposableKind, expositionUsageContext, containerSelection, inlineContainerConfig) {
        return APIXHRService("POST", API_PATH + "containers/get-config-info", {
            projectKey:projectKey,
            exposableKind:exposableKind,
            expositionUsageContext: expositionUsageContext,
            containerSelection:JSON.stringify(containerSelection),
            inlineContainerConfig: JSON.stringify(inlineContainerConfig)
        })
    },
    getExpositions: function(containerType, exposableKind, expositionUsageContext) {
        return APIXHRService("GET", API_PATH + "containers/get-expositions", {
            containerType: containerType,
            exposableKind: exposableKind,
            expositionUsageContext: expositionUsageContext
        })
    },
},
admin: {
    getInstanceInfo: function() {
        return APIXHRService("GET", API_PATH + "/admin/get-instance-info");
    },
    containerExec: {
        pushBaseImages: function(){
            return APIXHRService("POST", API_PATH + "/admin/container-exec/push-base-images")
        },
        installJupyterSupport: function() {
            return APIXHRService("POST", API_PATH + "/admin/container-exec/install-jupyter-support")
        },
        removeJupyterSupport: function() {
            return APIXHRService("POST", API_PATH + "/admin/container-exec/remove-jupyter-support")
        },
        testConf: function(data, clusterDefinedConfig, clusterId, executionConfigsGenericOverrides) {
            return APIXHRService("POST", API_PATH + "/admin/container-exec/test-conf", {data: JSON.stringify(data), clusterDefinedConfig: clusterDefinedConfig || false, clusterId: clusterId, genericOverridesData: JSON.stringify(executionConfigsGenericOverrides)})
        },
        applyK8SPolicies: function(data, clusterDefinedConfig, clusterId, executionConfigsGenericOverrides) {
            return APIXHRService("POST", API_PATH + "/admin/container-exec/apply-kubernetes-policies", {})
        }
    },
    connections: {
        list: function () {
            return APIXHRService("GET", API_PATH + "/admin/connections/list");
        },
        listHiveVirtual: function(){
            return APIXHRService("GET", API_PATH + "/admin/connections/list-hive-virtual");
        },
        listRunningJobs: function () {
            return APIXHRService("GET", API_PATH + "/admin/connections/metadata", null, "nospinner");
        },
        get: function (name) {
            return APIXHRService("GET", API_PATH + "/admin/connections/get", {name: name});
        },
        save: function (data) {
            return APIXHRService("POST", API_PATH + "/admin/connections/save", {data: JSON.stringify(data)});
        },
        listProcessableConnections: function (type, selectedConnections) {
            return APIXHRService("GET", API_PATH + "/admin/connections/list-indexable-connections", {
                type: type,
                selectedConnections: selectedConnections
            });
        },
        index: function (data) {
            return APIXHRService("POST", API_PATH + "/admin/connections/index", {data: JSON.stringify(data)});
        },
        scan: function (data) {
            return APIXHRService("POST", API_PATH + "/admin/connections/scan", {data: JSON.stringify(data)});
        },
        abortIndexation: function (data) {
            return APIXHRService("GET", API_PATH + "/admin/connections/abort-indexation");
        },
        delete: function (data) {
            return APIXHRService("POST", API_PATH + "/admin/connections/delete", {data: JSON.stringify(data)});
        },
        testSQL: function(data, massImportTargetProjectKey) {
            return APIXHRService("POST", API_PATH + "admin/connections/test-sql", {
                data: JSON.stringify(data),
                massImportTargetProjectKey: massImportTargetProjectKey
            });
        },
        testPostgreSQL: function(data) {
            return APIXHRService("POST", API_PATH + "admin/connections/test-postgresql", {data: JSON.stringify(data)});
        },
        testEC2: function(data) {
            return APIXHRService("POST", API_PATH + "admin/connections/test-ec2", {data: JSON.stringify(data)});
        },
        testGCS: function(data) {
            return APIXHRService("POST", API_PATH + "admin/connections/test-gcs", {data: JSON.stringify(data)});
        },
        testAzure: function(data) {
            return APIXHRService("POST", API_PATH + "admin/connections/test-azure", {data: JSON.stringify(data)});
        },
        testMongoDB: function(data, sequenceId) {
            return APIXHRService("POST", API_PATH + "admin/connections/test-mongodb", {data: JSON.stringify(data), sequenceId: sequenceId});
        },
        testDynamoDB: function(data, sequenceId) {
            return APIXHRService("POST", API_PATH + "admin/connections/test-dynamodb", {data: JSON.stringify(data), sequenceId: sequenceId});
        },
        testCassandra: function(data) {
            return APIXHRService("POST", API_PATH + "admin/connections/test-cassandra", {data: JSON.stringify(data)});
        },
        testTwitter: function(data) {
            return APIXHRService("POST", API_PATH + "admin/connections/test-twitter", {data: JSON.stringify(data)});
        },
        testKafka: function(data) {
            return APIXHRService("POST", API_PATH + "admin/connections/test-kafka", {data: JSON.stringify(data)});
        },
        testKsql: function(data) {
            return APIXHRService("POST", API_PATH + "admin/connections/test-ksql", {data: JSON.stringify(data)});
        },
        testSQS: function(data) {
            return APIXHRService("POST", API_PATH + "admin/connections/test-sqs", {data: JSON.stringify(data)});
        },
        testElasticSearch: function(data) {
            return APIXHRService("POST", API_PATH + "admin/connections/test-elasticsearch", {data: JSON.stringify(data)});
        },
        setActiveTwitterConnection: function(name) {
           return APIXHRService("POST", API_PATH + "admin/connections/set-active-twitter-connection", {name:name});
        },

        hdfs : {
            resyncPermissions : function(connectionName) {
                return APIXHRService("POST", API_PATH + "admin/connections/hdfs/resync-permissions", {
                    connectionName : connectionName
                });
            },
            resyncRootPermissions : function(connectionName) {
                return APIXHRService("POST", API_PATH + "admin/connections/hdfs/resync-root-permissions", {
                    connectionName : connectionName
                });
            }

        }
    },
    integrationChannels: {
        list: function() {
            return APIXHRService("GET", API_PATH + "/admin/integration-channels/list");
        },
        saveAll: function(data) {
            return APIXHRService("POST", API_PATH + "/admin/integration-channels/save-all" , {data: JSON.stringify(data)});
        }
    },
    logs: {
        list: function() {
           return APIXHRService("GET", API_PATH + "admin/logs/list");
        },
        get: function(name) {
           return APIXHRService("GET", API_PATH + "admin/logs/get-content", {name: name});
        },
    },
    diagnostics: {
        getLatest: function() {
           return APIXHRService("GET", API_PATH + "admin/diagnostics/get-latest-diagnosis");
        },
        run: function(options) {
           return APIXHRService("POST", API_PATH + "admin/diagnostics/run", {options: JSON.stringify(options)});
        },
        getResults: function(id) {
           return APIXHRService("GET", API_PATH + "admin/diagnostics/get-results", {id: id});
        },
    },
    globalTags: {
        updateGlobalTags: function(data) {
            return APIXHRService("POST", API_PATH + "admin/global-tags/update-global-tags", {data: JSON.stringify(data)});
        }
    },
    users:{
        list: function() {
            return APIXHRService("GET", API_PATH + "admin/users/list");
        },
        get: function(login) {
            return APIXHRService("GET", API_PATH + "admin/users/get", {login: login});
        },
        update: function(usr) {
            return APIXHRService("POST", API_PATH + "admin/users/edit", {user: JSON.stringify(usr)});
        },
        prepareUpdate: function(usr) {
            return APIXHRService("POST", API_PATH + "admin/users/prepare-edit", {user: JSON.stringify(usr)});
        },
        create : function(usr) {
            return APIXHRService("POST", API_PATH + "admin/users/create", {user: JSON.stringify(usr)});
        },
        delete: function(logins) {
            return APIXHRService("POST", API_PATH + "admin/users/delete", {logins: JSON.stringify(logins)});
        },
        enableOrDisable: function(logins, enable) {
            return APIXHRService("POST", API_PATH + "admin/users/enable-or-disable", {logins: JSON.stringify(logins), enable: enable});
        },
        prepareDelete: function(logins) {
            return APIXHRService("POST", API_PATH + "admin/users/prepare-delete", {logins: JSON.stringify(logins)});
        },
        prepareDisable: function(logins) {
            return APIXHRService("POST", API_PATH + "admin/users/prepare-disable", {logins: JSON.stringify(logins)});
        },
        assignUsersGroups: function(logins, groupsToAdd, groupsToRemove) {
            return APIXHRService("POST", API_PATH + "admin/users/assign-groups", {groupsToAdd: JSON.stringify(groupsToAdd), groupsToRemove: JSON.stringify(groupsToRemove), logins: JSON.stringify(logins)});
        },
        prepareAssignUsersGroups: function(logins, groupsToAdd, groupsToRemove) {
            return APIXHRService("POST", API_PATH + "admin/users/prepare-assign-groups", {groupsToAdd: JSON.stringify(groupsToAdd), groupsToRemove: JSON.stringify(groupsToRemove), logins: JSON.stringify(logins)});
        }
    },
    publicApi: {
        listGlobalKeys: function() {
            return APIXHRService("GET", API_PATH + "admin/publicapi/get-global-keys");
        },
        createGlobalKey: function(key) {
            return APIXHRService("POST", API_PATH + "admin/publicapi/create-global-key", {
                key: JSON.stringify(key)
            });
        },
        saveGlobalKey: function(key) {
            return APIXHRService("POST", API_PATH + "admin/publicapi/save-global-key", {
                key: JSON.stringify(key)
            });
        },
        getGlobalKey: function(keyId) {
            return APIXHRService("POST", API_PATH + "admin/publicapi/get-global-key", {
                keyId: keyId
            });
        },
        deleteGlobalKey: function(key) {
            return APIXHRService("POST", API_PATH + "admin/publicapi/delete-global-key", {
                key: key
            });
        },
        listPersonalKeys : function(){
            return APIXHRService("GET", API_PATH + "admin/publicapi/list-personal-api-keys");
        },
        deletePersonalKey : function(key){
            return APIXHRService("GET", API_PATH + "admin/publicapi/delete-personal-api-key",{
                key : key
            });
        }
    },
    scheduledTasks: {
        getStatus: function() {
            return APIXHRService("GET", API_PATH + "admin/scheduled-tasks/get-status", {
            });
        },
        fire: function(jobGroup, jobName) {
            return APIXHRService("POST", API_PATH + "admin/scheduled-tasks/fire", {
                jobGroup: jobGroup, jobName: jobName
            });
        }
    },
    codeenvs: {
        design: {
            list: function(){
                return APIXHRService("GET", API_PATH + "code-envs/design/list")
            },
            listNames: function(envLang) {
        	    return APIXHRService("GET", API_PATH + "code-envs/design/list-names",{ envLang: envLang })
        	},
            create: function(envLang, envSpec) {
                return APIXHRService("POST", API_PATH + "code-envs/design/create", {
                    envLang: envLang, envSpec: JSON.stringify(envSpec)
                });
            },
            get : function(envLang, envName){
                return APIXHRService("POST", API_PATH + "code-envs/design/get", {
                    envLang: envLang, envName: envName
                });
            },
            listLogs : function(envLang, envName){
                return APIXHRService("POST", API_PATH + "code-envs/design/list-logs", {
                    envLang: envLang, envName: envName
                });
            },
            getLog : function(envLang, envName, logName){
                return APIXHRService("POST", API_PATH + "code-envs/design/get-log", {
                    envLang: envLang, envName: envName, logName: logName
                });
            },
            streamLog : function(envLang, envName, logName){
                return APIXHRService("GET", API_PATH + "code-envs/design/stream-log", {
                    envLang: envLang, envName: envName, logName: logName
                });
            },
            save: function(envLang, envName, data) {
                return APIXHRService("POST", API_PATH + "code-envs/design/save", {
                    envLang: envLang, envName: envName, data: JSON.stringify(data)
                });
            },
            listUsages : function(envLang, envName){
                return APIXHRService("POST", API_PATH + "code-envs/design/list-usages", {
                    envLang: envLang, envName: envName
                });
            },
            delete : function(envLang, envName){
                return APIXHRService("POST", API_PATH + "code-envs/design/delete", {
                    envLang: envLang, envName: envName
                });
            },
            update: function(envLang, envName, updateSettings) {
                return APIXHRService("POST", API_PATH + "code-envs/design/update", {
                    envLang: envLang, envName: envName, updateSettings: JSON.stringify(updateSettings)
                });
            },
            fetchNonManagedEnvDetails: function(envLang, envName) {
                return APIXHRService("GET", API_PATH + "code-envs/design/fetch-non-managed-env-details", {
                    envLang: envLang, envName: envName
                });
            },
            installJupyterSupport: function(envLang, envName) {
                return APIXHRService("GET", API_PATH + "code-envs/design/install-jupyter-support", {
                    envLang: envLang, envName: envName
                });
            },
            removeJupyterSupport: function(envLang, envName) {
                return APIXHRService("GET", API_PATH + "code-envs/design/remove-jupyter-support", {
                    envLang: envLang, envName: envName
                });
            },
            getExportURL: function(envLang, envName) {
                return API_PATH + "code-envs/design/export?"
                         + "envLang=" + encodeURIComponent(envLang)
                         + "&envName=" + encodeURIComponent(envName);
            },
            getDiagnosticURL: function(envLang, envName) {
                return API_PATH + "code-envs/design/download-diagnostic?"
                         + "envLang=" + encodeURIComponent(envLang)
                         + "&envName=" + encodeURIComponent(envName);
            },
            import: function(file) {
                return uploadFileRequest("code-envs/design/import", function(formdata) {
                    formdata.append("file", file);
                }, null);
            }
        },
        automation: {
            list: function(){
                return APIXHRService("GET", API_PATH + "code-envs/automation/list")
            },
            create: function(envLang, envSpec) {
                 return APIXHRService("POST", API_PATH + "code-envs/automation/create", {
                    envLang: envLang, envSpec:JSON.stringify(envSpec)
                });
            },
            get: function(envLang, envName) {
                return APIXHRService("POST", API_PATH + "code-envs/automation/get", {
                    envLang: envLang, envName: envName
                });
            },
            getVersion: function(envLang, envName, versionId) {
                return APIXHRService("POST", API_PATH + "code-envs/automation/get-version", {
                    envLang: envLang, envName: envName, versionId: versionId
                });
            },
            save: function(envLang, envName, data) {
                return APIXHRService("POST", API_PATH + "code-envs/automation/save", {
                    envLang: envLang, envName: envName, data: JSON.stringify(data)
                });
            },
            saveVersion: function(envLang, envName, versionId, data) {
                return APIXHRService("POST", API_PATH + "code-envs/automation/save-version", {
                    envLang: envLang, envName: envName, versionId: versionId, data: JSON.stringify(data)
                });
            },
            listLogs : function(envLang, envName){
                return APIXHRService("POST", API_PATH + "code-envs/automation/list-logs", {
                    envLang: envLang, envName: envName
                });
            },
            getLog : function(envLang, envName, logName){
                return APIXHRService("POST", API_PATH + "code-envs/automation/get-log", {
                    envLang: envLang, envName: envName, logName: logName
                });
            },
            streamLog : function(envLang, envName, logName){
                return APIXHRService("GET", API_PATH + "code-envs/automation/stream-log", {
                    envLang: envLang, envName: envName, logName: logName
                });
            },
            listUsages : function(envLang, envName){
                return APIXHRService("POST", API_PATH + "code-envs/automation/list-usages", {
                    envLang: envLang, envName: envName
                });
            },
            delete : function(envLang, envName){
                return APIXHRService("POST", API_PATH + "code-envs/automation/delete", {
                    envLang: envLang, envName: envName
                });
            },
            update: function(envLang, envName, updateSettings) {
                return APIXHRService("POST", API_PATH + "code-envs/automation/update", {
                    envLang: envLang, envName: envName, updateSettings: JSON.stringify(updateSettings)
                });
            },
            fetchNonManagedEnvDetails: function(envLang, envName) {
                return APIXHRService("GET", API_PATH + "code-envs/automation/fetch-non-managed-env-details", {
                    envLang: envLang, envName: envName
                });
            },
            installJupyterSupport: function(envLang, envName, versionId) {
                return APIXHRService("GET", API_PATH + "code-envs/automation/install-jupyter-support", {
                    envLang: envLang, envName: envName, versionId: versionId
                });
            },
            removeJupyterSupport: function(envLang, envName, versionId) {
                return APIXHRService("GET", API_PATH + "code-envs/automation/remove-jupyter-support", {
                    envLang: envLang, envName: envName, versionId: versionId
                });
            },
            import: function(file) {
                return uploadFileRequest("code-envs/automation/import", function(formdata) {
                    formdata.append("file", file);
                }, null);
            },
            importVersion: function(file, envLang, envName) {
                return uploadFileRequest("code-envs/automation/import-version", function(formdata) {
                    formdata.append("envName", envName);
                    formdata.append("envLang", envLang);
                    formdata.append("file", file);
                }, null);
            },
            getDiagnosticURL: function(envLang, envName) {
                return API_PATH + "code-envs/automation/download-diagnostic?"
                         + "envLang=" + encodeURIComponent(envLang)
                         + "&envName=" + encodeURIComponent(envName);
            }
        },
        setRemoteSparkSupport: function(envLang, envName, remoteKernelType, active) {
            return APIXHRService("POST", API_PATH + "code-envs/set-remote-kernel-support", {
                envLang: envLang, envName: envName, remoteKernelType:remoteKernelType, active:active
            })
        }
    },
    monitoring: {
        getGlobalUsageSummary: function() {
            return APIXHRService("GET", API_PATH + "admin/monitoring/get-global-usage-summary", {
            });
        },
        getConnectionTasksHistory: function(connectionId) {
            return APIXHRService("GET", API_PATH + "admin/monitoring/ct/get-history", {
                connectionId: connectionId
            });
        },
        connectionData: {
            get: function(connectionId) {
            return APIXHRService("GET", API_PATH + "admin/monitoring/cd/get", {
                    connectionId: connectionId
                });
            },
            getForProject: function(connectionId, projectKey) {
            return APIXHRService("GET", API_PATH + "admin/monitoring/cd/get-for-project", {
                    connectionId: connectionId, projectKey: projectKey
                });
            },
            updateForProject: function(connectionId, projectKey, computeRecords, forceRecompute) {
            return APIXHRService("POST", API_PATH + "admin/monitoring/cd/update-for-project", {
                    connectionId: connectionId, projectKey: projectKey,
                    computeRecords: computeRecords, forceRecompute: forceRecompute
                });
            },
            updateForDataset: function(projectKey, datasetName, computeRecords, forceRecompute) {
            return APIXHRService("POST", API_PATH + "admin/monitoring/cd/update-for-dataset", {
                    projectKey: projectKey, datasetName: datasetName,
                    computeRecords: computeRecords, forceRecompute: forceRecompute
                });
            }
        },
        getProjectsIntegrations: function() {
            return APIXHRService("GET", API_PATH + "admin/monitoring/get-projects-integrations", {
            });
        },
        saveProjectIntegration: function(projectKey, data) {
            return APIXHRService("POST", API_PATH + "admin/monitoring/save-project-integration", {
                projectKey: projectKey,
                data: JSON.stringify(data)
            });
        },
        deleteProjectIntegration: function(projectKey, data) {
            return APIXHRService("POST", API_PATH + "admin/monitoring/delete-project-integration", {
                projectKey: projectKey,
                data: JSON.stringify(data)
            });
        },
    },
    clusters:{
        list: function() {
            return APIXHRService("GET", API_PATH + "clusters/list");
        },
        listAccessible: function(architecture) {
            return APIXHRService("GET", API_PATH + "clusters/list-accessible", {architecture: architecture});
        },
        get: function(clusterId) {
            return APIXHRService("GET", API_PATH + "clusters/get", {id: clusterId});
        },
        getStatus: function(clusterId) {
            return APIXHRService("GET", API_PATH + "clusters/get-status", {id: clusterId});
        },
        save: function(cluster) {
            return APIXHRService("POST", API_PATH + "clusters/save", {data: JSON.stringify(cluster)});
        },
        create : function(cluster) {
            return APIXHRService("POST", API_PATH + "clusters/create", {data: JSON.stringify(cluster)});
        },
        delete: function(clusterId) {
            return APIXHRService("POST", API_PATH + "clusters/delete", {id: clusterId});
        },
        start: function(clusterId) {
            return APIXHRService("POST", API_PATH + "clusters/start", {id: clusterId});
        },
        stop: function(clusterId, terminate) {
            return APIXHRService("POST", API_PATH + "clusters/stop", {id: clusterId, terminate: terminate});
        },
        markStopped: function(clusterId) {
            return APIXHRService("POST", API_PATH + "clusters/mark-stopped", {id: clusterId});
        },
        listLogs : function(clusterId){
            return APIXHRService("POST", API_PATH + "clusters/list-logs", {
            	clusterId: clusterId
            });
        },
        getLog : function(clusterId, logName){
            return APIXHRService("POST", API_PATH + "clusters/get-log", {
            	clusterId: clusterId, logName: logName
            });
        },
        streamLog : function(clusterId, logName){
            return APIXHRService("GET", API_PATH + "clusters/stream-log", {
            	clusterId: clusterId, logName: logName
            });
        },
        getDiagnosisURL: function(clusterId) {
            return API_PATH + "clusters/download-diagnosis?"
                     + "clusterId=" + encodeURIComponent(clusterId);
        },
        abortKernel : function(prefix, kernelId) {
            return APIXHRService("POST", API_PATH + "clusters/abort-kernel", {
                kernelId: kernelId, prefix: prefix
            });
        },
        preloadYarnClusterFiles : function(yarnClusterSettings) {
            return APIXHRService("POST", API_PATH + "clusters/preload-yarn-cluster-files", {
                yarnClusterSettings: JSON.stringify(yarnClusterSettings)
            });
        },
        testLivy : function(clusterId, livySettings) {
            return APIXHRService("POST", API_PATH + "clusters/test-livy", {
                clusterId : clusterId,
                livySettings: JSON.stringify(livySettings)
            });
        }
    },
    getGeneralSettings: function() {
        return APIXHRService("GET", API_PATH + "admin/get-general-settings");
    },
    getGlobalVariables: function() {
        return APIXHRService("GET", API_PATH + "admin/get-global-variables");
    },
    saveGlobalVariables: function(data) {
        return APIXHRService("POST", API_PATH + "admin/save-global-variables", {data: JSON.stringify(data)});
    },
    saveGeneralSettings: function(data) {
        return APIXHRService("POST", API_PATH + "admin/save-general-settings", {data: JSON.stringify(data)});
    },
    invalidateConfigCache: function(path) {
        return APIXHRService("POST", API_PATH + "admin/invalidate-config-cache", {path});
    },
    testLdapSettings: function(data) {
        return APIXHRService("POST", API_PATH + "admin/test-ldap-settings", {data: JSON.stringify(data)});
    },
    testLdapGetUserDetails: function(data) {
        return APIXHRService("POST", API_PATH + "admin/test-ldap-get-user-details", {data: JSON.stringify(data)});
    },
    executeVariablesUpdate: function() {
        return APIXHRService("POST", API_PATH + "admin/execute-variables-update");
    },
    getLimitsStatus: function() {
        return APIXHRService("GET", API_PATH + "admin/get-limits-status");
    },
    getThemes: function() {
        return APIXHRService("GET", API_PATH + "admin/get-themes");
    },
    folderEdit: {
        listContents: function(type) {
            return APIXHRService("GET", API_PATH + "admin/folder-edition/list-contents", {
                type: type
            });
        },
        getContent: function(type, path, sendAnyway) {
            return APIXHRService("GET", API_PATH + "admin/folder-edition/get-content", {
                type: type, path: path, sendAnyway: sendAnyway
            });
        },
        setContent: function(type, path, data) {
            return APIXHRService("POST", API_PATH + "admin/folder-edition/set-content", {
                type: type, path: path, data: data
            });
        },
        setContentMultiple: function(type, contentMap) {
            return APIXHRService("POST", API_PATH + "admin/folder-edition/set-content-multiple", {
                type: type, contentMap: JSON.stringify(contentMap)
            });
        },
        createContent: function(type, path, isFolder) {
            return APIXHRService("POST", API_PATH + "admin/folder-edition/create-content", {
                type: type, path: path, isFolder: isFolder
            });
        },
        deleteContent: function(type, path) {
            return APIXHRService("POST", API_PATH + "admin/folder-edition/delete-content", {
                type: type, path: path
            });
        },
        decompressContent: function(type, path) {
            return APIXHRService("POST", API_PATH + "admin/folder-edition/decompress-content", {
                type: type, path: path
            });
        },
        renameContent: function(type, path, newName) {
            return APIXHRService("POST", API_PATH + "admin/folder-edition/rename-content", {
                type: type, path: path, newName: newName
            });
        },
        moveContent: function(type, path, toPath) {
            return APIXHRService("POST", API_PATH + "admin/folder-edition/move-content", {
                type: type, path: path, toPath: toPath
            });
        },
        copyContent: function(type, path) {
            return APIXHRService("POST", API_PATH + "admin/folder-edition/copy-content", {
                type: type, path: path
            });
        },
        uploadContent: function(type, path, file, callback) {
            return uploadFileRequest("admin/folder-edition/upload-content", function(formdata) {
                formdata.append("type", type);
                formdata.append("path", path);
                formdata.append("file", file);
            }, callback);
        },
        checkUploadContent: function(type, path, filePaths) {
            return APIXHRService("POST", API_PATH + "admin/folder-edition/check-upload-content", {
                type: type, path: path, filePaths: JSON.stringify(filePaths)
            });
        }
    }
},
plugins: {
    get: function(pluginId, projectKey) {
        return APIXHRService("GET", API_PATH + "plugins/get", {
            pluginId: pluginId,
            projectKey: projectKey
        });
    },
    list: function(forceFetch) {
        return APIXHRService("GET", API_PATH + "plugins/list", {forceFetch: forceFetch});
    },
    listPluginsWithPresets: function() {
        return APIXHRService("GET", API_PATH + "plugins/list-plugins-with-presets");
    },
    install: function(pluginId, update) {
    	return APIXHRService("GET", API_PATH + "plugins/install-from-store", {pluginId: pluginId, update: update});
    },
    triggerRestart: function(pluginId, update) {
    	return APIXHRService("GET", API_PATH + "plugins/trigger-restart");
    },
    uploadPlugin: function(file, isUpdate) {
        return uploadFileRequest("plugins/upload", function(formdata) {
            formdata.append("file", file);
            formdata.append("isUpdate", isUpdate);
        }, null);
    },
    clonePlugin: function(uri, checkout, path, isUpdate) {
        return APIXHRService("POST", API_PATH + "plugins/clone", {
            repository: uri,
            checkout: checkout,
            path: path,
            isUpdate: isUpdate
        });
    },
    moveToDev: function(pluginId) {
        return APIXHRService("POST", API_PATH + "plugins/move-to-dev", {
            pluginId: pluginId
        });
    },
    useCodeEnv: function(pluginId, envName) {
        return APIXHRService("POST", API_PATH + "plugins/use-code-env", {
            pluginId: pluginId, envName: envName
        });
    },
    saveSettings: function(pluginId, projectKey, settings) {
    	return APIXHRService("POST", API_PATH + "plugins/save-settings", {
            pluginId: pluginId,
            projectKey: projectKey,
            data: JSON.stringify(settings)
        });
    },
    installRequirements: function(pluginId, type, envName) {
    	return APIXHRService("GET", API_PATH + "plugins/install-requirements", {pluginId: pluginId, type: type, envName: envName});
    },
    callPythonDo: function(sessionId, pluginId, componentId, config, payload, recipeConfig, projectKey, clusterId, part) {
        return APIXHRService("POST", API_PATH + "plugins/call-python-do", {
    		sessionId: sessionId,
    		pluginId: pluginId,
            componentId: componentId,
            projectKey: projectKey,
            clusterId: clusterId,
    		config: JSON.stringify(config),
    		payload: (payload != null ? JSON.stringify(payload) : null),
    		recipeConfig: (recipeConfig != null ? JSON.stringify(recipeConfig) : null),
    		part: part
    	});
    },
    listAccessiblePresets: function(pluginId, projectKey, elementId) {
        return APIXHRService("GET", API_PATH + "plugins/list-accessible-presets", {pluginId: pluginId, projectKey: projectKey, elementId: elementId});
    },
    getUsages: function(pluginId, projectKey) {
        return APIXHRService("GET", API_PATH + "plugins/get-usages", {pluginId: pluginId, projectKey: projectKey});
    },
    prepareDelete: function(pluginId) {
        return APIXHRService("GET", API_PATH + "plugins/prepare-delete", {pluginId: pluginId});
    },
    delete: function(pluginId, force = false) {
        return APIXHRService("GET", API_PATH + "plugins/delete", {pluginId: pluginId, force: force});
    }
},
plugindev: {
    git: {
        getLog: function(pluginId, since, count) {
            return APIXHRService("GET", API_PATH + "plugins-git/git-log", {
                pluginId: pluginId,
                since: since,
                count: count
            });
        },
        pull: function(pluginId, remoteName, branchName) {
            return APIXHRService("GET", API_PATH + "plugins-git/git-pull", {
                pluginId: pluginId,
                remoteName: remoteName,
                branchName: branchName
            });
        },
        fetch: function(pluginId, remoteName) {
            return APIXHRService("GET", API_PATH + "plugins-git/git-fetch", {
                pluginId: pluginId,
                remoteName: remoteName
            });
        },
        push: function(pluginId, remoteName, branchName) {
            return APIXHRService("GET", API_PATH + "plugins-git/git-push", {
                pluginId: pluginId,
                remoteName: remoteName,
                branchName: branchName
            });
        },
        resetToUpstream: function(pluginId, remoteName, branchName) {
            return APIXHRService("POST", API_PATH + "plugins-git/git-reset-to-upstream", {
                pluginId: pluginId,
                remoteName: remoteName,
                branchName: branchName
            });
        },
        resetToHead: function(pluginId) {
            return APIXHRService("POST", API_PATH + "plugins-git/git-reset-to-head", {
                pluginId: pluginId
            });
        },
        getFullStatus: function(pluginId) {
            return APIXHRService("GET", API_PATH + "plugins-git/git-full-status", {
                pluginId: pluginId
            });
        },
        listBranches: function(pluginId) {
            return APIXHRService("GET", API_PATH + "plugins-git/git-list-branches", {
                pluginId: pluginId
            });
        },
        commit: function(pluginId, commitMessage) {
            return APIXHRService("GET", API_PATH + "plugins-git/commit", {
                pluginId: pluginId,
                commitMessage: commitMessage
            });
        },
        prepareCommit: function(pluginId) {
            return APIXHRService("GET", API_PATH + "plugins-git/prepare-commit", {
                pluginId: pluginId
            });
        },
        createBranch: function(pluginId, branchName, commitId) {
            return APIXHRService("GET", API_PATH + "plugins-git/git-create-branch", {
                pluginId: pluginId,
                branchName: branchName,
                commitId: commitId
            });
        },
        switchBranch: function(pluginId, branchName, creation) {
            return APIXHRService("GET", API_PATH + "plugins-git/git-switch-branch", {
                pluginId: pluginId,
                branchName: branchName
            });
        },
        deleteBranches: function(pluginId, /*String[]*/branchNames, deleteOptions) {
            return APIXHRService("GET", API_PATH + "plugins-git/git-delete-branches", {
                pluginId: pluginId,
                branchNames: JSON.stringify(branchNames),
                remoteDelete: deleteOptions.remoteDelete,
                forceDelete: deleteOptions.forceDelete
            });
        },
        setRemote: function(pluginId, remoteName, remoteUrl) {
            return APIXHRService("GET", API_PATH + "plugins-git/git-set-remote", {
                pluginId: pluginId,
                remoteName: remoteName,
                remoteUrl: remoteUrl
            });
        },
        removeRemote: function(pluginId, remoteName) {
            return APIXHRService("GET", API_PATH + "plugins-git/git-rm-remote", {
                pluginId: pluginId,
                remoteName: remoteName
            });
        },
        getCommitDiff: function(pluginId, commitId) {
            return APIXHRService("GET", API_PATH + "plugins-git/get-commit-diff", {
                pluginId: pluginId,
                commitId: commitId
            });
        },
        getRevisionsDiff: function(pluginId, commitFrom, commitTo) {
            return APIXHRService("GET", API_PATH + "plugins-git/get-revisions-diff", {
                pluginId: pluginId,
                commitFrom: commitFrom,
                commitTo: commitTo
            });
        },
        revertPluginToRevision: function(pluginId, hash) {
            return APIXHRService("GET", API_PATH + "plugins-git/revert-plugin-to-revision", {
                pluginId: pluginId,
                hash: hash
            });
        },
        revertSingleCommit: function(pluginId, hash) {
            return APIXHRService("GET", API_PATH + "plugins-git/revert-single-commit", {
                pluginId: pluginId,
                hash: hash
            });
        },
    },
    reloadAll: function() {
        return APIXHRService("GET", API_PATH + "plugins/dev/reload-all");
    },
    list: function() {
       return APIXHRService("GET", API_PATH + "plugins/dev/list");
    },
    get: function(pluginId) {
        return APIXHRService("GET", API_PATH + "plugins/dev/get", {
            pluginId: pluginId
        });
    },
    create: function(pluginId, bootstrapMode, gitRepository, gitCheckout, gitPath) {
        return APIXHRService("POST", API_PATH + "plugins/dev/create", {
            pluginId: pluginId,
            bootstrapMode: bootstrapMode,
            gitRepository: gitRepository,
            gitCheckout: gitCheckout,
            gitPath: gitPath
        });
    },
    reload: function(pluginId) {
        return APIXHRService("POST", API_PATH + "plugins/dev/reload", {
            pluginId: pluginId
        });
    },
    addPythonDataset: function(pluginId, datasetId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-python-dataset", {
            pluginId: pluginId,
            datasetId: datasetId
        });
    },
    addJavaDataset: function(pluginId, datasetId, classNameForPlugin) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-java-dataset", {
            pluginId: pluginId,
            datasetId: datasetId,
            className: classNameForPlugin
        });
    },
    addJavaRecipe: function(pluginId, recipeId, classNameForPlugin) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-java-recipe", {
            pluginId: pluginId,
            recipeId: recipeId,
            className: classNameForPlugin
        });
    },
    addJavaDialect: function(pluginId, dialectId, classNameForPlugin) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-java-dialect", {
            pluginId: pluginId,
            dialectId: dialectId,
            className: classNameForPlugin
        });
    },
    addJavaExposition: function(pluginId, expositionId, classNameForPlugin) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-java-exposition", {
            pluginId: pluginId,
            expositionId: expositionId,
            className: classNameForPlugin
        });
    },
    addJythonProcessor: function(pluginId, stepId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-jython-processor", {
            pluginId: pluginId,
            stepId: stepId
        });
    },
    addPythonFormat: function(pluginId, formatId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-python-format", {
            pluginId: pluginId,
            formatId: formatId
        });
    },
    addJavaFormat: function(pluginId, formatId, classNameForPlugin) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-java-format", {
            pluginId: pluginId,
            formatId: formatId,
            className: classNameForPlugin
        });
    },
    addPythonProbe: function(pluginId, probeId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-python-probe", {
            pluginId: pluginId,
            probeId: probeId
        });
    },
    addPythonExporter: function(pluginId, exporterId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-python-exporter", {
            pluginId: pluginId,
            exporterId: exporterId
        });
    },
    addJavaExporter: function(pluginId, exporterId, classNameForPlugin) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-java-exporter", {
            pluginId: pluginId,
            exporterId: exporterId,
            className: classNameForPlugin
        });
    },
    addPythonCheck: function(pluginId, checkId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-python-check", {
            pluginId: pluginId,
            checkId: checkId
        });
    },
    addCustomFields: function(pluginId, customFieldsId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-custom-fields", {
            pluginId: pluginId,
            customFieldsId: customFieldsId
        });
    },
    addJavaPolicyHooks: function(pluginId, policyHooksId, classNameForPlugin) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-java-policy-hooks", {
            pluginId: pluginId,
            policyHooksId: policyHooksId,
            className: classNameForPlugin
        });
    },
    addSqlProbe: function(pluginId, probeId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-sql-probe", {
            pluginId: pluginId,
            probeId: probeId
        });
    },
    addPredictionPythonAlgorithm: function(pluginId, algoId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-python-prediction-algorithm", {
            pluginId, algoId
        });
    },
    addStandardWebAppTemplate: function(pluginId, webAppId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-standard-webapp-template", {
            pluginId: pluginId,
            webAppId: webAppId
        });
    },
    addBokehWebAppTemplate: function(pluginId, webAppId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-bokeh-webapp-template", {
            pluginId: pluginId,
            webAppId: webAppId
        });
    },
    addDashWebAppTemplate: function(pluginId, webAppId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-dash-webapp-template", {
            pluginId: pluginId,
            webAppId: webAppId
        });
    },
    addShinyWebAppTemplate: function(pluginId, webAppId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-shiny-webapp-template", {
            pluginId: pluginId,
            webAppId: webAppId
        });
    },
    addRMarkdownReportTemplate: function(pluginId, reportId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-rmarkdown-report-template", {
            pluginId: pluginId,
            reportId: reportId
        });
    },
    addNotebookTemplate: function(type, language, preBuilt, pluginId, notebookId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-notebook-template", {
            pluginId: pluginId,
            notebookId: notebookId,
            type:type,
            language : language,
            preBuilt : preBuilt
        });
    },
    addPythonCluster: function(pluginId, clusterId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-python-cluster", {
            pluginId: pluginId,
            clusterId: clusterId
        });
    },
    addPythonStep: function(pluginId, stepId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-python-step", {
            pluginId: pluginId,
            stepId: stepId
        });
    },
    addPythonTrigger: function(pluginId, triggerId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-python-trigger", {
            pluginId: pluginId,
            triggerId: triggerId
        });
    },
    addPythonRunnable: function(pluginId, runnableId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-python-runnable", {
            pluginId: pluginId,
            runnableId: runnableId
        });
    },
    addJavaRunnable: function(pluginId, runnableId, classNameForPlugin) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-java-runnable", {
            pluginId: pluginId,
            runnableId: runnableId,
            className : classNameForPlugin
        });
    },
    addCustomCodeRecipe: function(pluginId, customCodeRecipeId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-custom-code-recipe", {
            pluginId: pluginId,
            customCodeRecipeId: customCodeRecipeId
        });
    },
    addPythonFSProvider: function(pluginId, fsProviderId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-python-fs-provider", {
            pluginId: pluginId,
            fsProviderId: fsProviderId
        });
    },
    addJavaFSProvider: function(pluginId, fsProviderId, classNameForPlugin) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-java-fs-provider", {
            pluginId: pluginId,
            fsProviderId: fsProviderId,
            className : classNameForPlugin
        });
    },
    addPythonCodeEnv: function(pluginId, unused, unused2, forceConda) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-python-code-env", {
            pluginId: pluginId,
            forceConda: forceConda
        });
    },
    addRCodeEnv: function(pluginId, unused, unused2, forceConda) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-r-code-env", {
            pluginId: pluginId,
            forceConda: forceConda
        });
    },
    addParameterSet: function(pluginId, parameterSetId) {
        return  APIXHRService("POST", API_PATH + "plugins/dev/add-parameter-set", {
            pluginId: pluginId,
            parameterSetId: parameterSetId
        });
    },
    listContents: function(pluginId) {
        return APIXHRService("GET", API_PATH + "plugins/dev/list-contents", {
            pluginId: pluginId
        });
    },
    getContent: function(pluginId, path, sendAnyway) {
        return APIXHRService("GET", API_PATH + "plugins/dev/get-content", {
            pluginId: pluginId, path: path, sendAnyway: sendAnyway
        });
    },
    setContent: function(pluginId, path, data) {
        return APIXHRService("POST", API_PATH + "plugins/dev/set-content", {
            pluginId: pluginId, path: path, data: data
        });
    },
    validate: function(pluginId, contentMap) {
        return APIXHRService("POST", API_PATH + "plugins/dev/validate", {
            pluginId: pluginId, contentMap: JSON.stringify(contentMap)
        });
    },
    setContentMultiple: function(pluginId, contentMap) {
        return APIXHRService("POST", API_PATH + "plugins/dev/set-content-multiple", {
            pluginId: pluginId, contentMap: JSON.stringify(contentMap)
        });
    },
    createContent: function(pluginId, path, isFolder) {
        return APIXHRService("POST", API_PATH + "plugins/dev/create-content", {
            pluginId: pluginId, path: path, isFolder: isFolder
        });
    },
    deleteContent: function(pluginId, path) {
        return APIXHRService("POST", API_PATH + "plugins/dev/delete-content", {
            pluginId: pluginId, path: path
        });
    },
    decompressContent: function(pluginId, path) {
        return APIXHRService("POST", API_PATH + "plugins/dev/decompress-content", {
            pluginId: pluginId, path: path
        });
    },
    renameContent: function(pluginId, path, newName) {
        return APIXHRService("POST", API_PATH + "plugins/dev/rename-content", {
            pluginId: pluginId, path: path, newName: newName
        });
    },
    moveContent: function(pluginId, path, toPath) {
        return APIXHRService("POST", API_PATH + "plugins/dev/move-content", {
            pluginId: pluginId, path: path, toPath: toPath
        });
    },
    copyContent: function(pluginId, path) {
        return APIXHRService("POST", API_PATH + "plugins/dev/copy-content", {
            pluginId: pluginId, path: path
        });
    },
    uploadContent: function(pluginId, path, file, callback) {
        return uploadFileRequest("plugins/dev/upload-content", function(formdata) {
            formdata.append("pluginId", pluginId);
            formdata.append("path", path);
            formdata.append("file", file);
        }, callback);
    },
    checkUploadContent: function(pluginId, path, filePaths) {
        return APIXHRService("POST", API_PATH + "plugins/dev/check-upload-content", {
            pluginId: pluginId, path: path, filePaths: JSON.stringify(filePaths)
        });
    },
    useCodeEnv: function(pluginId, envName) {
        return APIXHRService("POST", API_PATH + "plugins/dev/use-code-env", {
            pluginId: pluginId, envName: envName
        });
    },
    updateCodeEnv: function(pluginId) {
        return APIXHRService("POST", API_PATH + "plugins/dev/update-code-env", {
            pluginId: pluginId
        });
    },
    setActiveRemote: function(pluginId, remoteName) {
        return APIXHRService("POST", API_PATH + "plugins/dev/set-active-remote", {
            pluginId: pluginId,
            remoteName: remoteName
        });
    },
    removeCodeEnv: function(pluginId) {
        return APIXHRService("GET", API_PATH + "plugins/dev/remove-code-env", {
            pluginId: pluginId
        });
    },
},
metrics: {
    getComputedMetricWithHistory: function(projectKey, objectType, objectSmartName, partitionId, metricId) {
        return APIXHRService("GET", API_PATH + "metrics/get-computed-metric-with-history", {
            projectKey: projectKey,
            objectType: objectType,
            objectSmartName: objectSmartName,
            partitionId: partitionId,
            metricId: metricId
        });
    }
},
catalog: {
    search: function (query, facets, nospinner) {
        return APIXHRService("POST", API_PATH + "catalog/search", {
            query: query,
            facets: JSON.stringify(facets)
        }, nospinner ? "nospinner" : undefined);
    },
    searchColumns: function (query, facets) {
        return APIXHRService("POST", API_PATH + "catalog/search", {
            query: query,
            facets: JSON.stringify($.extend({}, facets, {scope: ['dss-column']}))
        })
    },
    searchMeanings: function (query, facets) {
        return APIXHRService("POST", API_PATH + "catalog/search", {
            query: query,
            facets: JSON.stringify($.extend({}, facets, {scope: ['meanings']})),
            type: "meanings"
        })
    },
    flush: function () {
        return APIXHRService("GET", API_PATH + "catalog/flush");
    },
    listDashboards: function () {
        return APIXHRService("GET", API_PATH + "catalog/list-dashboards");
    }
},
externalTable: {
    summary: function (tableKey) {
        return APIXHRService("POST", API_PATH + "external-table/get-summary", tableKey);
    },
    sample: function (tableKey) {
        return APIXHRService("POST", API_PATH + "external-table/preview", tableKey);
    },
    save: function (tableKey, dssMetadata) {
        return APIXHRService("POST", API_PATH + "external-table/save-metadata", $.extend({}, tableKey, {
            dssMetadata: JSON.stringify(dssMetadata)
        }))
    }
},
meanings: {
    listUDM: function() {
        return APIXHRService("GET", API_PATH + "meanings/udm/list-with-state");
    },
    saveUDM: function(userDefinedMeaning) {
        return  APIXHRService("POST", API_PATH + "meanings/udm/save", {
            userDefinedMeaning: JSON.stringify(userDefinedMeaning)
        });
    },
    createUDM: function(userDefinedMeaning) {
        return  APIXHRService("POST", API_PATH + "meanings/udm/create", {
            userDefinedMeaning: JSON.stringify(userDefinedMeaning)
        });
    },
    deleteUDM: function(id) {
        return  APIXHRService("POST", API_PATH + "meanings/udm/delete", {
            id: id
        });
    },
    prepareDeleteUDM: function(id) {
        return  APIXHRService("POST", API_PATH + "meanings/udm/prepare-delete", {
            id: id
        });
    },
    getUDM: function(id) {
        return  APIXHRService("GET", API_PATH + "meanings/udm/get", {
            id: id
        });
    }
},
internal: {
    debugKillBackend: function() {
        return APIXHRService("POST", API_PATH + "debugging/kill-backend")
    },
    debugGetBackendStacks: function() {
        return APIXHRService("GET", API_PATH + "debugging/dump-backend-stacks")
    },
    restartAllHTMLBackends: function() {
        return APIXHRService("GET", API_PATH + "debugging/restart-all-html-backends");
    },
    runScenarioTriggers:  function() {
        return APIXHRService("GET", API_PATH + "debugging/run-scenario-triggers");
    },
    fakeScenarioRun: function(projectKey, scenarioId, date, outcome) {
        return APIXHRService("POST", API_PATH + "debugging/run-fake-scenario", {
            projectKey: projectKey,
            scenarioId: scenarioId,
            date: date,
            outcome: outcome
        });
    },
    fakeFuture: function(projectKey, payloadClassName, payloadMethodName, randomUser) {
        return APIXHRService("POST", API_PATH + "debugging/run-fake-future", {
            projectKey: projectKey,
            payloadClassName: payloadClassName,
            payloadMethodName: payloadMethodName,
            randomUser: randomUser
        });
    },
    sendOfflineQueues: function() {
        return APIXHRService("GET", API_PATH + "debugging/send-offline-queues");
    },
    sendDigests: function() {
        return APIXHRService("GET", API_PATH + "debugging/send-digests");
    },
    buildUsageSummaryReports: function() {
        return APIXHRService("GET", API_PATH + "debugging/build-usage-summary-reports");
    },
    getTriggerQueueingInfo: function() {
        return APIXHRService("GET", API_PATH + "debugging/get-trigger-queueing-info");
    },
    fail: function(fail) {
        return APIXHRService("GET", API_PATH + "debugging/slow-fail", {fail});
    },
    resyncProjectFolders: () => {
        return APIXHRService("GET", API_PATH + "debugging/resync-project-folders");
    },
    clearScenarioReportsCaches: function() {
        return APIXHRService("POST", API_PATH + "debugging/clear-scenario-report-caches")
    }
},
apideployer: {
    globalLightStatus: function() {
        return APIXHRService("GET", API_PATH + "api-deployer/global-light-status", null);
    },
    client: {
        listPublishedServices: function() {
            return APIXHRService("GET", API_PATH + "api-deployer/client/published-api-services/list-light-status");
        },
        listDeployments: function() {
            return APIXHRService("GET", API_PATH + "api-deployer/client/deployments/list-light-status");
        }
    },
    publishedAPIServices: {
        listBasicInfo: function() {
            return APIXHRService("GET", API_PATH + "api-deployer/published-api-services/list-basic-info");
        },
        listLightStatus: function() {
            return APIXHRService("GET", API_PATH + "api-deployer/published-api-services/list-light-status");
        },
        getLightStatus: function(serviceId) {
            return APIXHRService("GET", API_PATH + "api-deployer/published-api-services/get-light-status", {
                serviceId: serviceId
            });
        },
        getSettings: function(serviceId) {
            return APIXHRService("GET", API_PATH + "api-deployer/published-api-services/get-settings", {
                serviceId: serviceId
            });
        },
        create: function(serviceId, label) {
            return APIXHRService("POST", API_PATH + "api-deployer/published-api-services/create", {
                serviceId: serviceId,
                label: label
            });
        },
        save: function(service) {
            return APIXHRService("POST", API_PATH + "api-deployer/published-api-services/save", {
                service: angular.toJson(service)
            });
        },
        delete: function(serviceId) {
            return APIXHRService("POST", API_PATH + "api-deployer/published-api-services/delete", {
                serviceId: serviceId
            });
        },
        publishVersion: function(serviceId, file, callback) {
            return uploadFileRequest("api-deployer/versions/publish", function(formdata) {
                formdata.append("serviceId", serviceId);
                formdata.append("file", file);
            }, callback);
        },
        deletePackage: function(serviceId, versionId) {
            return APIXHRService("POST", API_PATH + "api-deployer/versions/delete", {
                serviceId: serviceId,
                versionId: versionId
            });
        }
    },
    infras: {
        listBasicInfo: function() {
            return APIXHRService("GET", API_PATH + "api-deployer/infras/list-basic-info");
        },
        listLightStatus: function() {
            return APIXHRService("GET", API_PATH + "api-deployer/infras/list-light-status");
        },
        getLightStatus: function(infraId) {
            return APIXHRService("GET", API_PATH + "api-deployer/infras/get-light-status", {
                infraId: infraId
            });
        },
        getSettings: function(infraId) {
            return APIXHRService("GET", API_PATH + "api-deployer/infras/get-settings", {
                infraId: infraId
            });
        },
        create: function(infra) {
            return APIXHRService("POST", API_PATH + "api-deployer/infras/create", {
                infraId: infra.id,
                stage: infra.stage,
                type: infra.type
            });
        },
        save: function(infra) {
            return APIXHRService("POST", API_PATH + "api-deployer/infras/save", {
                infra: JSON.stringify(infra)
            });
        },
        delete: function(infraId) {
            return APIXHRService("POST", API_PATH + "api-deployer/infras/delete", {
                infraId: infraId
            });
        }
    },
    deployments: {
        listTags: function() {
            return APIXHRService("GET", API_PATH + "api-deployer/deployments/list-tags");
        },
        listBasicInfo: function() {
            return APIXHRService("GET", API_PATH + "api-deployer/deployments/list-basic-info");
        },
        listLightStatus: function() {
            return APIXHRService("GET", API_PATH + "api-deployer/deployments/list-light-status");
        },
        getLightStatus: function(deploymentId) {
            return APIXHRService("GET", API_PATH + "api-deployer/deployments/get-light-status", {
                deploymentId: deploymentId
            });
        },
        getSettings: function(deploymentId) {
            return APIXHRService("GET", API_PATH + "api-deployer/deployments/get-settings", {
                deploymentId: deploymentId
            });
        },
        create: function(deploymentId, publishedServiceId, infraId, version) {
            return APIXHRService("POST", API_PATH + "api-deployer/deployments/create", {
                deploymentId: deploymentId,
                publishedServiceId: publishedServiceId,
                infraId: infraId,
                version: version
            })
        },
        save: function(deployment) {
            return APIXHRService("POST", API_PATH + "api-deployer/deployments/save", {
                deployment: JSON.stringify(deployment)
            });
        },
        copy: function(deploymentId, newDeploymentId, newInfraId) {
            return APIXHRService("POST", API_PATH + "api-deployer/deployments/copy", {
                deploymentId: deploymentId,
                newDeploymentId: newDeploymentId,
                newInfraId: newInfraId
            });
        },
        switchVersion: function(deploymentId, versionId) {
            return APIXHRService("POST", API_PATH + "api-deployer/deployments/switch-version", {
                deploymentId: deploymentId,
                versionId: versionId
            });
        },
        delete: function(deploymentId) {
            return APIXHRService("POST", API_PATH + "api-deployer/deployments/delete", {
                deploymentId: deploymentId
            });
        },
        getHeavyStatus : function(deploymentId, withTestQueries) {
            return APIXHRService("GET", API_PATH + "api-deployer/deployments/get-heavy-status", {
                deploymentId: deploymentId, withTestQueries: withTestQueries
            }, "nospinner");
        },
        executeSyncK8S : function(deploymentId )  {
            return APIXHRService("POST", API_PATH + "api-deployer/deployments/execute-sync-k8s", {
                deploymentId: deploymentId
            });
        },
        prepareSyncStatic : function(deploymentId)  {
            return APIXHRService("POST", API_PATH + "api-deployer/deployments/prepare-sync-static", {
                deploymentId: deploymentId
            });
        },
        executeSyncStatic : function(deploymentId, forceRefresh)  {
            return APIXHRService("POST", API_PATH + "api-deployer/deployments/execute-sync-static", {
                deploymentId: deploymentId,
                forceRefresh: forceRefresh
            });
        },
        getChartData : function(deploymentId, endpointId, chartType, timeRange) {
            return APIXHRService("GET", API_PATH + "api-deployer/deployments/carbonapi-chart", {
                deploymentId:deploymentId,
                endpointId : endpointId,
                chartType : chartType,
                timeRange: timeRange,
                format: "json"
            }, "nospinner");
        },
        chartURL : function(deploymentId, endpointId, chartType, timeRange, format) {
            return API_PATH + `api-deployer/deployments/carbonapi-chart?deploymentId=${deploymentId}&endpointId=${endpointId}&chartType=${chartType}&timeRange=${timeRange}&format=${format}`;
        },
        runTestQuery: function(deploymentId, endpointId, testQueries, unsavedTestQueries) {
            return APIXHRService("POST", API_PATH + "api-deployer/deployments/run-test-queries", {
                deploymentId:deploymentId,
                endpointId: endpointId,
                testQueries: JSON.stringify(testQueries),
                unsavedTestQueries: JSON.stringify(unsavedTestQueries)
            });
        }
    }
},
help: {
    search: (q, params = {}, key="AIzaSyAI-tob6ERG-Pz-kYxPc8s6BNNa6Fl1M-A", cx="718d55b8e3d8705a6") => {
        return APIXHRService("GET", 'https://www.googleapis.com/customsearch/v1/siterestrict', Object.assign({key, cx, q}, params), 'nospinner');
    }
},
projectdeployer: {
    globalLightStatus: function() {
        return APIXHRService("GET", API_PATH + "project-deployer/global-light-status", null);
    },
    client: {
        listPublishedProjects: function() {
            return APIXHRService("GET", API_PATH + "project-deployer/client/published-projects/list-light-status");
        },
        listDeployments: function() {
            return APIXHRService("GET", API_PATH + "project-deployer/client/deployments/list-light-status");
        }
    },
    publishedProjects: {
        listBasicInfo: function() {
            return APIXHRService("GET", API_PATH + "project-deployer/published-projects/list-basic-info");
        },
        listLightStatus: function() {
            return APIXHRService("GET", API_PATH + "project-deployer/published-projects/list-light-status");
        },
        getLightStatus: function(projectKey) {
            return APIXHRService("GET", API_PATH + "project-deployer/published-projects/get-light-status", {
                projectKey: projectKey
            });
        },
        getSettings: function(projectKey) {
            return APIXHRService("GET", API_PATH + "project-deployer/published-projects/get-settings", {
                projectKey: projectKey
            });
        },
        create: function(projectKey, label) {
            return APIXHRService("POST", API_PATH + "project-deployer/published-projects/create", {
                projectKey: projectKey,
                label: label
            });
        },
        save: function(project) {
            return APIXHRService("POST", API_PATH + "project-deployer/published-projects/save", {
                project: angular.toJson(project)
            });
        },
        delete: function(projectKey) {
            return APIXHRService("POST", API_PATH + "project-deployer/published-projects/delete", {
                projectKey: projectKey
            });
        },
        uploadBundle: function(projectKey, file, callback) {
            return uploadFileRequest("project-deployer/bundles/upload", function(formdata) {
                formdata.append("projectKey", projectKey ? projectKey : "");
                formdata.append("file", file);
            }, callback);
        },
        getBundleDetails: function(projectKey, bundleId) {
            return APIXHRService("GET", API_PATH + "project-deployer/bundles/get-details", {
                projectKey: projectKey,
                bundleId: bundleId
            });
        },
        getBundleDetailsExtended: function(projectKey, bundleId) {
            return APIXHRService("GET", API_PATH + "project-deployer/bundles/get-details-extended", {
                projectKey: projectKey,
                bundleId: bundleId
            });
        },
        deleteBundle: function(projectKey, bundleId) {
            return APIXHRService("POST", API_PATH + "project-deployer/bundles/delete", {
                projectKey: projectKey,
                bundleId: bundleId
            });
        }
    },
    infras: {
        checkStatus: function(infraId) {
            return APIXHRService("GET", API_PATH + "project-deployer/infras/check-status", {infraId: infraId}, "nospinner");
        },
        listBasicInfo: function() {
            return APIXHRService("GET", API_PATH + "project-deployer/infras/list-basic-info");
        },
        listLightStatus: function() {
            return APIXHRService("GET", API_PATH + "project-deployer/infras/list-light-status");
        },
        getLightStatus: function(infraId) {
            return APIXHRService("GET", API_PATH + "project-deployer/infras/get-light-status", {
                infraId: infraId
            });
        },
        getSettings: function(infraId) {
            return APIXHRService("GET", API_PATH + "project-deployer/infras/get-settings", {
                infraId: infraId
            });
        },
        create: function(infra) {
            return APIXHRService("POST", API_PATH + "project-deployer/infras/create", {
                infraId: infra.id,
                stage: infra.stage,
                automationNodeUrl: infra.automationNodeUrl,
                apiKey: infra.apiKey
            });
        },
        save: function(infra) {
            return APIXHRService("POST", API_PATH + "project-deployer/infras/save", {
                infra: JSON.stringify(infra)
            });
        },
        delete: function(infraId) {
            return APIXHRService("POST", API_PATH + "project-deployer/infras/delete", {
                infraId: infraId
            });
        },
        getProjectKeys: function(infraId) {
            return APIXHRService("GET", API_PATH + "project-deployer/infras/get-project-keys", {
                infraId: infraId
            });
        },
        getProjectFolderHierarchy: function(infraId) {
            return APIXHRService("GET", API_PATH + "project-deployer/infras/project-folder-hierarchy", {
                infraId: infraId
            });
        }
    },
    deployments: {
        listTags: function() {
            return APIXHRService("GET", API_PATH + "project-deployer/deployments/list-tags");
        },
        listBasicInfo: function() {
            return APIXHRService("GET", API_PATH + "project-deployer/deployments/list-basic-info");
        },
        listLightStatus: function() {
            return APIXHRService("GET", API_PATH + "project-deployer/deployments/list-light-status");
        },
        getLightStatus: function(deploymentId) {
            return APIXHRService("GET", API_PATH + "project-deployer/deployments/get-light-status", {
                deploymentId: deploymentId
            });
        },
        getSettings: function(deploymentId) {
            return APIXHRService("GET", API_PATH + "project-deployer/deployments/get-settings", {
                deploymentId: deploymentId
            });
        },
        create: function(deploymentId, publishedProjectKey, infraId, bundleId, deployedProjectKey, projectFolderId) {
            return APIXHRService("POST", API_PATH + "project-deployer/deployments/create", {
                deploymentId: deploymentId,
                publishedProjectKey: publishedProjectKey,
                infraId: infraId,
                bundleId: bundleId,
                deployedProjectKey: deployedProjectKey,
                projectFolderId: projectFolderId
            })
        },
        save: function(deployment) {
            return APIXHRService("POST", API_PATH + "project-deployer/deployments/save", {
                deployment: JSON.stringify(deployment)
            });
        },
        copy: function(deploymentId, newDeploymentId, newInfraId, newDeployedProjectKey, newProjectFolderId) {
            return APIXHRService("POST", API_PATH + "project-deployer/deployments/copy", {
                deploymentId: deploymentId,
                newDeploymentId: newDeploymentId,
                newInfraId: newInfraId,
                newDeployedProjectKey: newDeployedProjectKey,
                newProjectFolderId: newProjectFolderId
            });
        },
        switchBundle: function(deploymentId, bundleId) {
            return APIXHRService("POST", API_PATH + "project-deployer/deployments/switch-bundle", {
                deploymentId: deploymentId,
                bundleId: bundleId
            });
        },
        delete: function(deploymentId) {
            return APIXHRService("POST", API_PATH + "project-deployer/deployments/delete", {
                deploymentId: deploymentId
            });
        },
        getHeavyStatus : function(deploymentId) {
            return APIXHRService("GET", API_PATH + "project-deployer/deployments/get-heavy-status", {
                deploymentId: deploymentId
            }, "nospinner");
        },
        listHeavyStatus: function(infraId) {
            return APIXHRService("GET", API_PATH + "project-deployer/deployments/list-heavy-status", {
                infraId
            }, "nospinner");
        },
        scenarioLastRuns : function(deploymentId, fromDate, toDate)  {
            return APIXHRService("POST", API_PATH + "project-deployer/deployments/scenario-runs-in-date-range", {
                deploymentId: deploymentId,
                fromDate: fromDate,
                toDate: toDate
            });
        },
        prepareSync : function(deploymentId)  {
            return APIXHRService("POST", API_PATH + "project-deployer/deployments/prepare-sync", {
                deploymentId: deploymentId
            });
        },
        startPreload : function(deploymentId)  {
            return APIXHRService("POST", API_PATH + "project-deployer/deployments/start-preload", {
                deploymentId: deploymentId
            });
        },
        activateCheck : function(deploymentId)  {
            return APIXHRService("POST", API_PATH + "project-deployer/deployments/activate-check", {
                deploymentId: deploymentId
            });
        },
        startActivate : function(deploymentId)  {
            return APIXHRService("POST", API_PATH + "project-deployer/deployments/start-activate", {
                deploymentId: deploymentId
            });
        }
    }
}
};
}]);

})();

(function () {
    'use strict';

    var app = angular.module('dataiku.projects.actions', []);

    app.directive("scrollyMenu", function () {
        return {
             scope: true,
            link: function (scope, element, attrs) {

                scope.posnMenu = function(evt) {
                    var $menuItem = $(evt.currentTarget);
                    var $submenuWrapper = $('> .scrolly-wrapper', $menuItem);
                    if ($submenuWrapper.length==0) return;

                    // grab the menu item's position relative to its positioned parent (position=relative)
                    var menuItemPos = $menuItem.position();

                    var subT = menuItemPos.top;
                    var subH = $submenuWrapper.height();
                    var vH = $(window).height()

                    if (subT + subH > 0.8 * vH) {
                        subT = Math.max(Math.round(0.7 * vH - subH), 0); //shift up submenu to fit on screen
                    }

                    // place submenu relative to the positioned parent
                    $submenuWrapper.css({
                        top: subT,
                        left: menuItemPos.left - Math.round($submenuWrapper.outerWidth())
                    });

                }
            }
        }
    });
    app.directive("newRecipeMenu", function (GlobalProjectActions) {
        return {
            templateUrl: '/templates/recipes/new-recipe-menu.html',
            scope: true,
            link: function (scope, element, attrs) {
                scope.title = attrs.title;
                scope.displayedItems = GlobalProjectActions.getAllRecipesBySection(scope);

                scope.do = function (cb) {
                    cb();
                }
            }
        }
    });
    
    app.directive("newStreamingRecipeMenu", function (GlobalProjectActions, $filter, CreateModalFromTemplate,DataikuAPI,$state) {
        return {
            templateUrl: '/templates/recipes/new-streaming-recipe-menu.html',
            scope: true,
            link: function (scope, element, attrs) {
                scope.title = attrs.title;
                scope.displayedItems = GlobalProjectActions.getStreamingRecipesBySection(scope);
                
                scope.do = function (cb) {
                    cb();
                }
            }
        }
    });
    
    app.directive("zoneSelectionMenu", function (GlobalProjectActions, DataikuAPI, $rootScope, $stateParams, $state) {
        return {
            templateUrl: '/templates/recipes/zone-selection-menu.html',
            scope: true,
            link: function (scope, element, attrs) {
                scope.selectedZone = $stateParams.zoneId;
                scope.$watch(attrs.color, function(nv, ov) {
                    scope.bgColor = nv;
                    scope.fgColor = '#' + getContrastYIQ(stripNumberSign(nv));
                });
                scope.zones = [];
                scope.changeZone = () => {
                    $state.go('projects.project.flow', Object.assign({}, $stateParams, { zoneId: scope.selectedZone, id: null }));
                };

                scope.listZones = () => {
                    DataikuAPI.flow.zones.list($stateParams.projectKey).then(data => {
                        scope.zones = data.data;
                    });
                };
                scope.listZones();

                const zonesListChangedListener = $rootScope.$on("zonesListChanged", scope.listZones);
                scope.$on('$destroy', zonesListChangedListener);

                function getContrastYIQ(hexcolor) {
                    var r = parseInt(hexcolor.substr(0,2),16);
                    var g = parseInt(hexcolor.substr(2,2),16);
                    var b = parseInt(hexcolor.substr(4,2),16);
                    var yiq = ((r*299)+(g*587)+(b*114))/1000;
                    return (yiq >= 128) ? '000000' : 'FFFFFF';
                };

                function stripNumberSign(color) {
                    if(color[0] === "#") {
                        color = color.substring(1, color.length);
                    }
                    return color;
                };
            }
        }
    });

    app.directive("newDatasetMenu", function (GlobalProjectActions, $filter, CreateModalFromTemplate,DataikuAPI,$state) {
        return {
            templateUrl: '/templates/datasets/new-dataset-menu.html',
            scope: true,
            link: function (scope, element, attrs) {
                scope.title = attrs.title;
                GlobalProjectActions.getAllDatasetsBySection(scope).then((displayedItems) => scope.displayedItems = displayedItems);
                scope.searchAndImport = function(zoneId) {
                    DataikuAPI.connections.countIndexedAndUnindexed().success(function (data) {
                        if (data.indexedConnections > 0) {
                            $state.go('projects.project.catalog.items', {zoneId});
                        } else {
                            $state.go("projects.project.catalog.connectionexplorer", {zoneId})
                        }

                    }).error(setErrorInScope.bind(scope));
                };

                scope.do = function (cb) {
                    cb();
                }
            }
        }
    });

    app.component('newDatasetMenuItemLabel', { // new-dataset-menu-item-label
        bindings: {
            'item': '<',
        },
        template: `
            <span ng-if="!$ctrl.item.em"><i class="icon-fixed-width-small {{$ctrl.item.icon}}" />&nbsp;{{$ctrl.item.label}}</span>
            <em ng-if="$ctrl.item.em"><i class="icon-fixed-width-small {{$ctrl.item.icon}}" />&nbsp;{{$ctrl.item.label}}</em>
        `,
    });

    app.directive("newOtherFlowMenu", function (GlobalProjectActions, $filter, CreateModalFromTemplate,DataikuAPI,$state) {
        return {
            templateUrl: '/templates/flow-editor/new-other-flow-menu.html',
            scope: true,
            link: function (scope, element, attrs) {
                scope.title = attrs.title;
                scope.displayedItems = GlobalProjectActions.getFlowOtherItemsBySection(scope);
                scope.do = function (cb) {
                    cb();
                }
            }
        }
    });

    app.directive("newStreamingEndpointMenu", function (GlobalProjectActions, $filter, CreateModalFromTemplate,DataikuAPI,$state) {
        return {
            templateUrl: '/templates/streaming-endpoints/new-streaming-endpoint-menu.html',
            scope: true,
            link: function (scope, element, attrs) {
                scope.title = attrs.title;
                scope.displayedItems = GlobalProjectActions.getAllStreamingEndpointsBySection(scope);
            
                scope.do = function (cb) {
                    cb();
                }
            }
        }
    });

    app.controller("MassImportConnectionSelectionController", function ($scope, $state, $stateParams, DataikuAPI, TopNav) {
        $scope.connection = null;
        $scope.connections = [];
        DataikuAPI.connections.listMassImportSources($stateParams.projectKey).success(function (data) {
            $scope.connections = data.sources;
            $scope.hiveError = data.hiveError;
        }).error(setErrorInScope.bind($scope));
        $scope.isValid = function () {
            return $scope.connection != null;
        };
        $scope.massImport = function () {
            $state.go("projects.project.catalog.connectionexplorer", {
                projectKey: $stateParams.projectKey,
                connectionName: $scope.connection.name
            });
            $scope.dismiss();
        };
    });

    app.controller("TablesImportProjectSelectionModalController", function ($scope, $state, $stateParams, DataikuAPI) {
        DataikuAPI.projects.list().success(function (data) {
            $scope.projects = data;
        }).error(setErrorInScope.bind($scope));

        $scope.clickImport = function () {
            $scope.dismiss();
            $state.go('projects.project.tablesimport', {
                    projectKey: $scope.project,
                    importData: JSON.stringify($scope.getImportData())
            });
        };
    });

    app.controller("MassImportTablesFromCatalogModalController", function ($scope, $state, $stateParams, DataikuAPI) {
         DataikuAPI.projects.list().success(function (data) {
            $scope.projects = data;
            if ($scope.projects.length === 1) {
                $scope.project = $scope.projects[0].projectKey;
            }
        }).error(setErrorInScope.bind($scope));

        $scope.clickImport = function () {
            $scope.dismiss();
            $state.go('projects.project.tablesimport', {
                    projectKey: $scope.project,
                    importData: JSON.stringify($scope.getImportData())
            });
        }
    });


    app.factory("GlobalProjectActions", function ($stateParams, $rootScope, $filter, $state,
        Assert, CreateModalFromTemplate, DatasetUtils, Logger, Dialogs, DataikuAPI, ComputablesService, TaggableObjectsService, RecipeDescService, uiCustomizationService) {

        function ok(details) {
            return {ok: true, details: details}
        }

        function nok(reason) {
            return {ok: false, reason: reason}
        }

        function makePluginSection(pluginId, items) {
            var plugin = Array.dkuFindFn($rootScope.appConfig.loadedPlugins, function (n) {
                return n.id == pluginId
            });
            if (plugin == null) return null; // could have been deleted on disk
            items.forEach(function (dtype) {
                if (!dtype.icon) dtype.icon = plugin.icon;
            });
            // add an item to point to the info
            items.splice(0, 0, {isInfo: true, pluginId: plugin.id});
            return {
                isSection: true,
                id: "plugin_" + plugin.id,
                icon: plugin.icon,
                label: plugin.label || plugin.id,
                items: items
            };
        }

        function mostFrequentIcon(pluginList) {
            let max = 0, last = 'icon-puzzle-piece', items = {};

            pluginList.some(function(plugin) {
                if (!plugin.icon) return false;

                items[plugin.icon] = !items[plugin.icon] ? 1 : items[plugin.icon] + 1;

                if (max < items[plugin.icon]) {
                    last = plugin.icon;
                    max = items[plugin.icon];

                    if (max > pluginList.length / 2) {
                        return true;
                    }
                }
                return false;
            });

            return last;
        }


        /* **************************************************
         * Recipes that have license restrictions
         *
         * - When you have a CE, we show as enabled and show an upgrade CTA
         * - When you have a real EE, we don't want to show a CTA so we disable the icon
         * if not configured.
         * - The "configured but not licensed mode" should be fairly rare
         */

        function notLicensedCE() {
            return {
                usable: false,
                iconEnabled: true,
                enableStatus: "NOT_LICENSED_CE"
            }
        }

        function notConfigured(reason) {
            return {
                usable: false,
                iconEnabled: false,
                enableStatus: "NOT_CONFIGURED",
                iconDisabledReason: reason
            }
        }

        function notLicensedEE() {
            return {
                usable: false,
                iconEnabled: true,
                enableStatus: "NOT_LICENSED_EE"
            }
        }

        function usable() {
            return {
                usable: true,
                iconEnabled: true,
                enableStatus: "OK"
            }
        }

        function notDataScientist() {
            return {
                usable: false,
                iconEnabled: false,
                enableStatus: "NOT_LICENSED_EE",
                iconDisabledReason: "Your user profile does not allow you to create this kind of recipe"
            }
        }

        function noUnsafeCode() {
            return {
                usable: false,
                iconEnabled: false,
                enableStatus: "NOT_LICENSED_EE",
                iconDisabledReason: "You may not write unisolated code"
            }
        }

        function noSafeCode() {
            return {
                usable: false,
                iconEnabled: false,
                enableStatus: "NOT_LICENSED_EE",
                iconDisabledReason: "You may not write isolated code"
            }
        }


        function getHiveStatus() {
            if ($rootScope.appConfig.communityEdition) {
                return notLicensedCE();
            } else {
                if (!$rootScope.appConfig.hiveEnabled) {
                    return notConfigured("Hive not configured on this DSS instance");
                }
                if (!$rootScope.addLicInfo.hiveLicensed) {
                    return notLicensedEE();
                }
                return usable();
            }
        }

        function getImpalaStatus() {
            if ($rootScope.appConfig.communityEdition) {
                return notLicensedCE();
            } else {
                if (!$rootScope.appConfig.impalaEnabled) {
                    return notConfigured("Impala not configured on this DSS instance");
                }
                if (!$rootScope.addLicInfo.impalaLicensed) {
                    return notLicensedEE();
                }
                return usable();
            }
        }

        function getPigStatus() {
            if ($rootScope.appConfig.communityEdition) {
                return notLicensedCE();
            } else {
                if (!$rootScope.appConfig.pigEnabled) {
                    return notConfigured("Pig not configured on this DSS instance");
                }
                if (!$rootScope.addLicInfo.pigLicensed) {
                    return notLicensedEE();
                }
                return usable();
            }
        }

        function getSparkStatus() {
            if ($rootScope.appConfig.communityEdition) {
                return notLicensedCE();
            } else {
                if (!$rootScope.appConfig.sparkEnabled) {
                    return notConfigured("Spark not configured on this DSS instance");
                }
                if (!$rootScope.addLicInfo.sparkLicensed) {
                    return notLicensedEE();
                }
                return usable();
            }
        }

        var svc = {
            /**
             * Returns [
             *   { isSection : false, ... }
             *   { isSection : true, id, label: icon: item : []}}}
             * ]
             */
            getAllRecipesBySection: function (scope) {
                var ret = [];

                ret.push({
                    isSection: true,
                    id: "visual",
                    label: "Visual",
                    icon: "icon-eye", // TODO
                    items: [
                        {
                            type: "shaker", label: "Data preparation",
                            fn: function () {
                                scope.showCreateShakerModal(undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId));
                            }
                        },
                        {
                            type: "sync", label: "Sync",
                            fn: function () {
                                scope.showCreateSyncModal(undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId));
                            }
                        },
                        {
                            type: "filter", label: "Sample / Filter",
                            fn: function () {
                                scope.showCreateSamplingModal(undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId));
                            }
                        },
                        {
                            type: "grouping", label: "Group",
                            fn: function () {
                                scope.showCreateGroupingModal(undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId));
                            }
                        },
                        {
                            type : "distinct", label : "Distinct",
                            fn : function(){ scope.showCreateDistinctModal(undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId)); }
                        },
                        {
                            type: "window", label: "Window",
                            fn: function () {
                                scope.showCreateWindowRecipeModal(undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId));
                            }
                        },
                        {
                            type: "join", label: "Join",
                            fn: function () {
                                scope.showCreateJoinModal(undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId));
                            }
                        },
                        {
                            type: "fuzzyjoin", label: "Fuzzy join",
                            fn: function () {
                                scope.showCreateFuzzyJoinModal(undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId));
                            }
                        },
                        {
                            type: "split", label: "Split",
                            fn: function () {
                                scope.showCreateSplitModal(undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId));
                            }
                        },
                        {
                            type: "topn", label : "Top N",
                            fn : function(){ scope.showCreateTopNModal(undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId)); }
                        },
                        {
                            type: "sort", label : "Sort",
                            fn : function(){ scope.showCreateSortModal(undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId)); }
                        },
                        {
                            type: "pivot", label : "Pivot",
                            fn : function(){ scope.showCreatePivotModal(undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId)); }
                        },
                        {
                            type: "vstack", label: "Stack vertically",
                            fn: function () {
                                scope.showCreateVStackModal(undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId));
                            }
                        },
                        {
                            type: "merge_folder", label: "Merge folders",
                            fn: function () {
                                scope.showCreateMergeFolderModal(undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId));
                            }
                        },
                        {
                            type: "update", label: "Push to Editable",
                            fn: function () {
                                scope.showCreateUpdateModal(undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId));
                            }
                        },
                        {
                            type: "export", label: "Export",
                            fn: function () {
                                scope.showCreateExportModal(undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId));
                            }
                        },
                        {
                            type : "download", label : "Download",
                            fn : function(){ scope.showCreateDownloadModal(undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId)); }
                        }
                    ]
                });

                var pyScientistStatus = usable();
                if (!scope.appConfig.userProfile.mayPython) {
                    pyScientistStatus = notDataScientist();
                }
                var rScientistStatus = usable();
                if (!scope.appConfig.userProfile.mayR) {
                    rScientistStatus = notDataScientist();
                }
                var jlScientistStatus = usable();
                if (!scope.appConfig.userProfile.mayJulia) {
                    jlScientistStatus = notDataScientist();
                }

                var scalaScientistStatus = usable();
                if (!scope.appConfig.userProfile.mayScala) {
                    scalaScientistStatus = notDataScientist();
                }

                var unsafeStatus = usable();
                if (!$rootScope.appConfig.globalPermissions || !$rootScope.appConfig.globalPermissions.mayWriteUnsafeCode) {
                    unsafeStatus = noUnsafeCode();
                }
                var safeStatus = usable();
                if ($rootScope.appConfig.impersonationEnabled && (!$rootScope.appConfig.globalPermissions || !$rootScope.appConfig.globalPermissions.mayWriteSafeCode)) {
                    safeStatus = noSafeCode();
                }

                var safeCodeStatus = $rootScope.appConfig.impersonationEnabled ? safeStatus : unsafeStatus;

                const codeRecipeItems = []
                codeRecipeItems.push({
                    type: "python",
                    label: "Python",
                    disabled: !pyScientistStatus.iconEnabled || !safeCodeStatus.iconEnabled,
                    reason: pyScientistStatus.iconDisabledReason || safeCodeStatus.iconDisabledReason,
                    fn: function () {
                        scope.showCreateCodeBasedModal("python", undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId));
                    }
                });
                if($rootScope.appConfig.uiCustomization.showR) {
                    codeRecipeItems.push({
                        type: "r",
                        label: "R",
                        disabled: !rScientistStatus.iconEnabled || !safeCodeStatus.iconEnabled || !$rootScope.appConfig.rEnabled,
                        reason: (rScientistStatus.iconDisabledReason || safeCodeStatus.iconDisabledReason) ? (rScientistStatus.iconDisabledReason || safeCodeStatus.iconDisabledReason) : ( $rootScope.appConfig.rEnabled ? null : "R not configured on your DSS instance"),
                        fn: function () {
                            scope.showCreateCodeBasedModal("r", undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId))
                        }
                    });
                }
                if($rootScope.featureFlagEnabled('julia')) {
                    codeRecipeItems.push({
                        type: "julia",
                        label: "Julia",
                        disabled: !jlScientistStatus.iconEnabled || !safeCodeStatus.iconEnabled,
                        reason: (jlScientistStatus.iconDisabledReason || safeCodeStatus.iconDisabledReason) ? (jlScientistStatus.iconDisabledReason || safeCodeStatus.iconDisabledReason) : ( $rootScope.featureFlagEnabled('julia') ? null : "Julia plugin not installed"),
                        fn: function () {
                            scope.showCreateCodeBasedModal("julia", undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId))
                        }
                    });
                }
                
                codeRecipeItems.push({
                    type: "sql_query",
                    label: "SQL",
                    fn: function () {
                        scope.showSQLRecipeModal(undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId))
                    }
                });
                codeRecipeItems.push({
                    type: "shell",
                    label: "Shell",
                    disabled: !pyScientistStatus.iconEnabled || !safeCodeStatus.iconEnabled,
                    reason: pyScientistStatus.iconDisabledReason || safeCodeStatus.iconDisabledReason,
                    fn: function () {
                        scope.showCreateCodeBasedModal("shell", undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId));
                    }
                })

                ret.push({
                    isSection: true,
                    id: "code",
                    label: "Code",
                    icon: "icon-code",
                    items: codeRecipeItems,
                });

                var sparkStatus = getSparkStatus();
                var hiveStatus = getHiveStatus();
                var impalaStatus = getImpalaStatus();
                var pigStatus = getPigStatus();

                const hadoopSparkRecipeItems = [];
                if($rootScope.appConfig.uiCustomization.showTraditionalHadoop) {
                    hadoopSparkRecipeItems.push({
                        type: "hive",
                        icon: "icon-code_hive_recipe",
                        label: "Hive",
                        disabled: !hiveStatus.iconEnabled,
                        reason: hiveStatus.iconDisabledReason,
                        fn: function () {
                            if (hiveStatus.enableStatus == "OK") {
                                scope.showCreateCodeBasedModal("hive", undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId))
                            } else if (hiveStatus.enableStatus == "NOT_LICENSED_CE") {
                                scope.showCERestrictionModal("Hadoop / Hive is")
                            }
                        }
                    });

                    hadoopSparkRecipeItems.push({
                        type: "impala",
                        icon: "icon-code_impala_recipe",
                        label: "Impala",
                        disabled: !impalaStatus.iconEnabled,
                        reason: impalaStatus.iconDisabledReason,
                        fn: function () {
                            if (impalaStatus.enableStatus == "OK") {
                                scope.showCreateCodeBasedModal("impala", undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId))
                            } else if (impalaStatus.enableStatus == "NOT_LICENSED_CE") {
                                scope.showCERestrictionModal("Hadoop / Impala is")
                            }
                        }
                    });

                    hadoopSparkRecipeItems.push({
                        type: "pig",
                        label: "Pig",
                        disabled: !pigStatus.iconEnabled,
                        reason: pigStatus.iconDisabledReason,
                        fn: function () {
                            if (pigStatus.enableStatus == "OK") {
                                scope.showCreateCodeBasedModal("pig", undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId))
                            } else if (pigStatus.enableStatus == "NOT_LICENSED_CE") {
                                scope.showCERestrictionModal("Hadoop / Pig is")
                            }
                        }
                    });

                    hadoopSparkRecipeItems.push({divider: true});
                }

                hadoopSparkRecipeItems.push({
                    type: "spark_sql_query",
                    label: "Spark SQL",
                    disabled: !sparkStatus.iconEnabled,
                    reason: sparkStatus.iconDisabledReason,
                    fn: function () {
                        if (sparkStatus.enableStatus == "OK") {
                            scope.showCreateCodeBasedModal("spark_sql_query", undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId))
                        } else if (sparkStatus.enableStatus == "NOT_LICENSED_EE") {
                            scope.showSparkNotLicensedModal();
                        } else if (sparkStatus.enableStatus == "NOT_LICENSED_CE") {
                            scope.showCERestrictionModal("Spark is")
                        }
                    }
                });

                if($rootScope.appConfig.uiCustomization.showScala) {
                    hadoopSparkRecipeItems.push({
                        type: "spark_scala",
                        label: "Spark Scala",
                        disabled: !sparkStatus.iconEnabled || !scalaScientistStatus.iconEnabled || !safeCodeStatus.iconEnabled,
                        reason: sparkStatus.iconDisabledReason || scalaScientistStatus.iconDisabledReason || safeCodeStatus.iconDisabledReason,
                        fn: function () {
                            if (sparkStatus.enableStatus == "OK") {
                                scope.showCreateCodeBasedModal("spark_scala", undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId))
                            } else if (sparkStatus.enableStatus == "NOT_LICENSED_EE") {
                                scope.showSparkNotLicensedModal();
                            } else if (sparkStatus.enableStatus == "NOT_LICENSED_CE") {
                                scope.showCERestrictionModal("Spark is")
                            }
                        }
                    });
                }

                hadoopSparkRecipeItems.push({
                    type: "pyspark",
                    label: "PySpark",
                    disabled: !sparkStatus.iconEnabled || !pyScientistStatus.iconEnabled || !safeCodeStatus.iconEnabled,
                    reason: sparkStatus.iconDisabledReason || pyScientistStatus.iconDisabledReason || safeCodeStatus.iconDisabledReason,
                    fn: function () {
                        if (sparkStatus.enableStatus == "OK") {
                            scope.showCreateCodeBasedModal("pyspark", undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId))
                        } else if (sparkStatus.enableStatus == "NOT_LICENSED_EE") {
                            scope.showSparkNotLicensedModal();
                        } else if (sparkStatus.enableStatus == "NOT_LICENSED_CE") {
                            scope.showCERestrictionModal("Spark is")
                        }
                    }
                });

                if($rootScope.appConfig.uiCustomization.showR) {
                    hadoopSparkRecipeItems.push({
                        type: "sparkr",
                        label: "SparkR",
                        disabled: !sparkStatus.iconEnabled || !rScientistStatus.iconEnabled || !safeCodeStatus.iconEnabled,
                        reason: sparkStatus.iconDisabledReason || rScientistStatus.iconDisabledReason || safeCodeStatus.iconDisabledReason,
                        fn: function () {
                            if (sparkStatus.enableStatus == "OK") {
                                scope.showCreateCodeBasedModal("sparkr", undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId))
                            } else if (sparkStatus.enableStatus == "NOT_LICENSED_EE") {
                                scope.showSparkNotLicensedModal();
                            } else if (sparkStatus.enableStatus == "NOT_LICENSED_CE") {
                                scope.showCERestrictionModal("Spark is")
                            }
                        }
                    });
                }

                ret.push({
                    isSection: true,
                    id: "code",
                    label: "Hadoop & Spark",
                    icon: "icon-HDFS",
                    items: hadoopSparkRecipeItems,
                });

                let pluginsByCategory = {};
                let recipeCategories = {};
                const pluginById = $rootScope.appConfig.loadedPlugins.reduce(function(map, obj) {
                    map[obj.id] = obj;
                    return map;
                }, {});

                $rootScope.appConfig.customCodeRecipes.forEach(function (x) {
                    const plugin = pluginById[x.ownerPluginId];
                    if (angular.isUndefined(plugin)) return; // could have been deleted on disk

                    let category = angular.isDefined(plugin.category) ? plugin.category : 'Misc';

                    if (category.toLowerCase() in recipeCategories) {
                        category = recipeCategories[category.toLowerCase()];
                    } else {
                        recipeCategories[category.toLowerCase()] = category = $filter('capitalize')(category);
                    }

                    pluginsByCategory[category] = pluginsByCategory[category] || {};
                    pluginsByCategory[category][plugin.id] = {
                        label: plugin.label ? plugin.label : plugin.id,
                        icon: plugin.icon,
                        fn: () => scope.showCreateRecipeFromPlugin(plugin.id, null, scope.getRelevantZoneId(scope.$stateParams.zoneId))
                    }
                });

                let appsByCategory = {};
                let appCategories = {};
                $rootScope.appConfig.appRecipes.forEach(function (x) {
                    let category = x.category || "Applications";
                    if (category.toLowerCase() in appCategories) {
                        category = appCategories[category.toLowerCase()];
                    } else {
                        appCategories[category.toLowerCase()] = category = $filter('capitalize')(category);
                    }

                    appsByCategory[category] = appsByCategory[category] || {};
                    appsByCategory[category][x.recipeType] = {
                        label: x.label,
                        icon: x.icon,
                        fn: () => scope.showCreateAppRecipeModal(x.recipeType)
                    }
                });

                let displayedAppSections = [];

                $.each(appsByCategory, function (category, apps) {
                    let appItems = Object.values(apps);
                    appItems.sort(function(a, b) { return a.label.toLowerCase().localeCompare(b.label.toLowerCase()); });

                    displayedAppSections.push({
                        isSection: true,
                        id: "tag_" + category,
                        icon: mostFrequentIcon(appItems),
                        label: category,
                        items: appItems
                    });
                });

                displayedAppSections.sort(function(a, b) { return a.label.toLowerCase().localeCompare(b.label.toLowerCase()); });
                if (displayedAppSections.length > 0) {
                    ret.push({divider: true});
                    Array.prototype.push.apply(ret, displayedAppSections);
                }

                ret.push({divider: true});

                let displayedPluginSections = [];
                let miscPlugins = null;

                $.each(pluginsByCategory, function (category, plugins) {
                    let pluginItems = Object.values(plugins);
                    pluginItems.sort(function(a, b) { return a.label.toLowerCase().localeCompare(b.label.toLowerCase()); });

                    if (category === 'Misc') {
                        miscPlugins = pluginItems;
                    } else {
                        displayedPluginSections.push({
                            isSection: true,
                            id: "tag_" + category,
                            icon: mostFrequentIcon(pluginItems),
                            label: category,
                            items: pluginItems
                        });
                    }
                });

                displayedPluginSections.sort(function(a, b) { return a.label.toLowerCase().localeCompare(b.label.toLowerCase()); });
                Array.prototype.push.apply(ret, displayedPluginSections);

                if (miscPlugins) {
                    Array.prototype.push.apply(ret, miscPlugins);
                }

                var f = $filter("recipeTypeToIcon");

                ret.forEach(function (a1) {
                    if (a1.isSection) {
                        a1.items.forEach(function (a2) {
                            if (!a2.icon) a2.icon = f(a2.type);
                        });

                    } else {
                        if (!a1.icon) a1.icon = f(a1.type);
                    }
                });
                return ret;
            },

            /**
             * Returns [
             *   { isSection : false, type, label, icon, fn?, licenseStatus, disabled?, em? }
             *   { isSection : true, id, label: icon: item : []}
             * ]
             */
            getAllDatasetsBySection: function (scope) {
                var ret = [];

                ret.push({
                    type: 'search_and_import', label: 'Search and import\u2026', icon: 'icon-mail-forward',
                    em: true, fn: () => scope.searchAndImport(scope.getRelevantZoneId($stateParams.zoneId))
                });

                if($rootScope.appConfig.alationSettings.enabled) {
                    ret.push({
                        type: 'import_from_alation', label: 'Import from Alation\u2026', icon: 'icon-book',
                        em: true, fn: () => scope.importFromAlation()
                    });
                }
                ret.push({ divider: true });

                // type, label, disabled, reason, icon
                ret.push({
                    type: "UploadedFiles", label: "Upload your files"
                });
                ret.push({
                    type: "Filesystem", label: "Filesystem"
                });

                ret.push({
                    isSection : true,
                    id : "network",
                    label : "Network",
                    icon : "icon-FTP-HTTP-SSH",
                    items : [
                        { type: "FTP", label: " FTP" },
                        { type: "SFTP", label: " SFTP" },
                        { type: "SCP", label: " SCP" },
                        { type: "HTTP", label: "HTTP" },
                        { type: "CachedHTTP", label: "HTTP (with cache)", fn: () => scope.showCreateUrlDownloadToFolderDataset($stateParams.projectKey)}
                    ]
                });

                ret.push({
                    type: "HDFS", label: "HDFS",
                    disabled: !$rootScope.appConfig.hadoopEnabled,
                    reason: $rootScope.appConfig.hadoopEnabled ? null : "Hadoop not configured on your DSS instance"
                });

                ret.push({divider: true});

                ret.push({
                    type: "hiveserver2", label: "Hive",
                    disabled: !$rootScope.appConfig.hadoopEnabled,
                    reason: $rootScope.appConfig.hadoopEnabled ? null : "Hadoop not configured on your DSS instance"
                });

                var sql = {
                    isSection: true,
                    id: "sql",
                    label: "SQL databases",
                    icon: "icon-database",
                    items: [
                        {
                            type: "Snowflake", label: "Snowflake", section: "SQL Databases"
                        },
                        {
                            type: "Redshift", label: "Amazon Redshift", section: "SQL Databases"
                        },
                        {
                            type: "Synapse", label: "Azure Synapse", section: "SQL Databases"
                        },
                        {
                            type: "BigQuery", label: "Google BigQuery", section: "SQL Databases"
                        },
                        {
                            type: "PostgreSQL", label: "PostgreSQL", section: "SQL Databases"
                        },
                        {
                            type: "MySQL", label: "MySQL", section: "SQL Databases"
                        },
                        {
                            type: "SQLServer", label: "MS SQL Server", section: "SQL Databases"
                        },
                        {
                            type: "Oracle", label: "Oracle", section: "SQL Databases"
                        },
                        {
                            type: "Teradata", label: "Teradata", section: "SQL Databases"
                        },
                        {
                            type: "Greenplum", label: "Greenplum", section: "SQL Databases"
                        },
                        {
                            type: "Vertica", label: "Vertica", section: "SQL Databases"
                        },
                        {
                            type: "Athena", label: "Athena", section: "SQL Databases"
                        },
                        {
                            type: "SAPHANA", label: "SAP HANA", section: "SQL Databases"
                        },
                        {
                            type: "Netezza", label: "IBM Netezza", section: "SQL Databases"
                        }
                    ]
                };

                if ($rootScope.featureFlagEnabled("kdbplus")) {
                    sql.items.push({
                        type: "KDBPlus", label: "KDB+", section: "SQL Databases"
                    })
                }

                sql.items.push({
                    type: "JDBC", label: "Other SQL databases", section: "SQL Databases"
                });
                ret.push(sql);

                ret.push({
                    isSection: true,
                    id: "cloud",
                    label: "Cloud storages & Social",
                    icon: "icon-database",
                    items: [
                        {
                            type: "S3", label: "Amazon S3"
                        },
                        {
                            type: "Azure", label: "Azure Blob Storage"
                        },
                        {
                            type: "GCS", label: "Google Cloud Storage"
                        },
                        {
                            type: "Twitter", label: "Twitter",
                            disabled: !$rootScope.appConfig.twitterEnabled,
                            reason: $rootScope.appConfig.twitterEnabled ? null : "Twitter not configured on your DSS instance"
                        }
                    ]
                })

                let noSQLSection = {
                    isSection: true,
                    id: "nosql",
                    label: "NoSQL",
                    icon: "icon-database",
                    items: [
                        {
                            type: "MongoDB", label: "MongoDB"
                        }, {
                            type: "Cassandra", label: "Cassandra"
                        }, {
                            type: "ElasticSearch", label: "ElasticSearch"
                        }
                    ]
                };
                if ($rootScope.featureFlagEnabled('DynamoDB')) {
                    noSQLSection.items.push({
                        type: "DynamoDB", label: "DynamoDB"
                    });
                }
                ret.push(noSQLSection);

                ret.push({divider: true});
                ret.push({
                    type: "Inline", label: "Editable"
                });
                ret.push({
                    type: "managed_folder", label: "Folder", icon: "icon-box", fn: scope.newManagedFolder
                });
                if ($rootScope.featureFlagEnabled('model_evaluation_stores')) {
                    ret.push({
                        type: "model_evaluation_store", label: "Evaluation store", icon: "icon-model-evaluation-store", fn: scope.newModelEvaluationStore
                    });
                }
                
                ret.push({
                    isSection: true,
                    id: "internal",
                    label: "Internal",
                    icon: "icon-tasks",
                    items: [
                        {
                            type: "JobsDB", label: "Metrics"
                        },
                        {
                            type: "StatsDB", label: "Internal stats"
                        },
                        {
                            type: "FilesInFolder", label: "Files from folder"
                        },
                        {
                            type: "managed", label: "Managed dataset", icon: "icon-beaker", fn: scope.newManagedDataset,
                        },
                        {
                            type: "ForeignDataset", label: "Dataset from another project", icon: "icon-dku-share", fn: () => $state.go('projects.project.catalog.items', {scope: ['dss'], _type: ['dataset']})
                        }
                    ]
                });


                let pluginsByCategory = {};
                let recipeCategories = {};
                const pluginById = $rootScope.appConfig.loadedPlugins.reduce(function (map, obj) {
                    map[obj.id] = obj;
                    return map;
                }, {});

                const orderPluginInCategory = function(dataset, getPluginType) {
                    const plugin = pluginById[dataset.ownerPluginId];
                    if (angular.isUndefined(plugin)) return; // could have been deleted on disk

                    let category = angular.isDefined(plugin.category) ? plugin.category : 'Misc';

                    if (category.toLowerCase() in recipeCategories) {
                        category = recipeCategories[category.toLowerCase()];
                    } else {
                        recipeCategories[category.toLowerCase()] = category = $filter('capitalize')(category);
                    }

                    pluginsByCategory[category] = pluginsByCategory[category] || {};
                    pluginsByCategory[category][plugin.id] = {
                        pluginId: dataset.ownerPluginId,
                        type : getPluginType(dataset),
                        label : plugin.label ? plugin.label : plugin.id,
                        icon : plugin.icon,
                        fn: () => scope.showCreateDatasetFromPlugin(dataset.ownerPluginId)
                    }
                };

                $rootScope.appConfig.customFSProviders.forEach(plugin => orderPluginInCategory(plugin, x => x.fsProviderType));
                $rootScope.appConfig.customDatasets.forEach(plugin => orderPluginInCategory(plugin, x => x.datasetType));

                let displayedPluginSections = [];
                let miscPlugins = null;

                $.each(pluginsByCategory, function (category, plugins) {
                    let pluginItems = Object.values(plugins);
                    pluginItems.sort(function(a, b) { return a.label.toLowerCase().localeCompare(b.label.toLowerCase()); });

                    if (category === 'Misc') {
                        miscPlugins = pluginItems;
                    } else {
                        displayedPluginSections.push({
                            isSection: true,
                            id: "tag_" + category,
                            icon: mostFrequentIcon(pluginItems),
                            label: category,
                            items: pluginItems
                        });
                    }
                });

                ret.push({divider: true});
                ret.push({header: true, label: 'Plugins'});

                displayedPluginSections.sort(function(a, b) { return a.label.toLowerCase().localeCompare(b.label.toLowerCase()); });
                Array.prototype.push.apply(ret, displayedPluginSections);

                if (miscPlugins) {
                    Array.prototype.push.apply(ret, miscPlugins);
                }

                var getIconFromType = $filter("datasetTypeToIcon");


                /**
                 * Enrich the info with items icons, licence status and filter hidden datasets.
                 */
                const postTreat = (items, computeStatus) => {
                    let haveItemBeforeCurrent = false;
                    return items
                        .map((item) => {
                            if(item.isSection) {
                                item.items = postTreat(item.items, computeStatus);
                                return item;
                            } else {
                                if (item.type) {
                                    item.licenseStatus = svc.getDatasetLicenseStatus(item.type);
                                    if (item.licenseStatus.status === 'NOT_LICENSED_EE') {
                                        item.disabled = true;
                                        item.reason = 'This dataset type is not licensed';
                                    }
                                }
                                if (!item.icon) item.icon = getIconFromType(item.type);
                                return item;
                            }
                        })
                        .filter(item => !( // remove hidden dataset type and empty sections (plugins are always shown)
                            item.isSection && item.items.length === 0 ||
                            item.type && item.pluginId === undefined && computeStatus(item.type) !== uiCustomizationService.datasetTypeStatus.SHOW
                        ))
                        .filter((item, index, arr) => { // remove useless dividers
                            if(item.divider && (
                                !haveItemBeforeCurrent ||                   // remove divider if there is not at least one item before
                                index === arr.length - 1 ||                 // remove divider if in last position
                                arr[index + 1] && arr[index + 1].divider    // remove divider if following item is also a divider
                            )) return false;
                            haveItemBeforeCurrent = true;
                            return true;
                        });
                }

                return uiCustomizationService.getComputeDatasetTypesStatus(scope, $stateParams.projectKey)
                    .then((computeStatus) => postTreat(ret, computeStatus));
            },

            /**
             * Raw unfiltered version of getAllDatasetsByTiles, used internally, but also for options.
             * Neat trick: calling this function with and undefined scope will work if you only want the list, but some clickCallback will be broken.
             * @returns {{title: string, icon: string, types: {type: string, label: string, disabledReason?:string}[]}[]} the list of dataset options, by tiles.
             */
            getAllDatasetByTilesNoFilter: function (scope) {
                const hadoopDisabledMessage = $rootScope.appConfig.hadoopEnabled ? undefined : `Hadoop connection is not enabled on your ${$rootScope.wl.productShortName} instance.` + ($rootScope.isDSSAdmin() ? '' : ` Please contact your administrator`);

                const tiles = [{
                    title: 'Files',
                    icon: 'icon-Filesystem',
                    types: [
                        {type: 'UploadedFiles', label: 'Upload your files'},
                        {type: 'Filesystem'},
                    ]
                }, {
                    title: 'Hadoop',
                    icon: 'icon-elephant',
                    types: [
                        {type: 'HDFS', label: 'HDFS', disabledReason: hadoopDisabledMessage},
                        {type: 'hiveserver2', label: 'Hive', disabledReason: hadoopDisabledMessage},
                    ],
                }, {
                    title: 'SQL',
                    icon: 'icon-sql',
                    types: [
                        {type: 'Snowflake'},
                        {type: 'Redshift'},
                        {type: 'Synapse'},
                        {type: 'BigQuery'},
                        {type: 'PostgreSQL'},
                        {type: 'MySQL'},
                        {type: 'SQLServer'},
                        {type: 'Oracle'},
                        {type: 'Teradata'},
                        {type: 'Greenplum'},
                        {type: 'Vertica'},
                        {type: 'Athena'},
                        {type: 'SAPHANA'},
                        {type: 'Netezza'},
                        {type: 'JDBC', label:'Other SQL'},
                    ]
                }, {
                    title: 'Cloud Storages',
                    icon: 'icon-cloud',
                    types: [
                        {type: 'S3'},
                        {type: 'Azure'},
                        {type: 'GCS'},
                    ],
                    types2: [
                        {type: 'FTP'},
                        {type: 'SFTP'},
                        {type: 'SCP'},
                        {type: 'HTTP'},
                        {type: 'CachedHTTP', clickCallback: () => scope.showCreateUrlDownloadToFolderDataset($stateParams.projectKey)},
                    ]
                }, {
                    title: 'NoSQL',
                    icon: 'icon-signal',
                    types: [
                        {type: 'MongoDB'},
                        {type: 'Cassandra'},
                        {type: 'ElasticSearch'},
                        $rootScope.featureFlagEnabled('DynamoDB') ? {type: 'DynamoDB'} : undefined,
                    ]
                }, {
                    title: 'Social',
                    icon: 'icon-twitter',
                    types: [
                        {type: 'Twitter'},
                    ]
                }, {
                    title: $rootScope.wl.productShortName,
                    icon: 'icon-beaker',
                    types: [
                        {type: 'FilesInFolder', label: 'Files in folder'},
                        {type: 'managed', label: 'Managed dataset', clickCallback: () => scope.newManagedDataset()},
                        {type: 'managed_folder', label:'Folder', clickCallback: () => scope.newManagedFolder()},
                        $rootScope.featureFlagEnabled('model_evaluation_stores') ? {type: 'model_evaluation_store', label: 'Evaluation store', clickCallback: () => scope.newModelEvaluationStore()} : undefined,
                        {type: 'JobsDB'},
                        {type: 'StatsDB'},
                        {type: 'Inline'},
                    ]
                }, {
                    title: 'Import existing',
                    icon: 'icon-cloud-download',
                    types: [
                        {type: 'ForeignDataset', label: 'Dataset from another project', clickCallback: () => $state.go('projects.project.catalog.items', {scope: ['dss'], _type: ['dataset']})},
                        {type: 'connection_explorer', label: 'Choose connection to import from', clickCallback: () => $state.go('projects.project.catalog.connectionexplorer')},
                        $rootScope.appConfig.alationSettings.enabled ? {type: 'import_from_alation', label: 'Import from Alation...', clickCallback: () => scope.importFromAlation()} : undefined,
                        {type: 'import_from_catalog', label:'Import from catalog', clickCallback: () => $state.go('projects.project.catalog.items')},
                    ]
                }];

                return tiles;
            },

            /**
             * Similar to getAllDatasetsBySection, but order according to the new dataset page tiles
             * Used by the new dataset page
             * 
             * returns Tile[]
             * 
             * Tile = {
             *  title: string,
             *  icon: string,
             *  types: DatasetType[] (8 max)
             *  types2: DatasetType[] (second column)
             * }
             * 
             * DatasetType = {
             *  type: string,
             *  label: string,
             *  clickCallback: function
             *  status: 'OK' | 'NOT_LICENCIED_CD' | 'NOT_LICENCIED_EE' | 'NO_CONNECTION' | 'HIDDEN'
             *  disabledReason?: string  if status='NO_CONNECTION', overrides the default tooltip message
             * }
             * 
             */
            getAllDatasetsByTiles: function (scope) {
                return uiCustomizationService.getComputeDatasetTypesStatus(scope, $stateParams.projectKey).then((computeStatus) => {
                    const tiles = svc.getAllDatasetByTilesNoFilter(scope);

                    /**
                     * Finds out how the dataset should be displayed in the new dataset page by merging the uiCustomization effect and the license status
                     * @param {string} type 
                     * @returns {string} 'OK', 'HIDDEN', 'NO_CONNECTION', 'NOT_LICENSED_EE' or 'NOT_LICENSED_CE'
                     */
                    const computeStatusWithLicense = (datasetType) => {
                        const uiCustomizationStatus = computeStatus(datasetType.type);
                        const licenseStatus = svc.getDatasetLicenseStatus(datasetType.type).status;

                        if(uiCustomizationStatus === uiCustomizationService.datasetTypeStatus.HIDE) {
                            return uiCustomizationStatus;
                        } else if(licenseStatus !== 'OK') {
                            return licenseStatus;
                        } else if(datasetType.disabledReason !== undefined) {
                            // when Hadoop is disabled, Hive & HDFS should appear disabled with a specific message. We reuse the NO_CONNECTION status
                            return uiCustomizationService.datasetTypeStatus.NO_CONNECTION;
                        } else {
                            return uiCustomizationStatus;
                        }
                    }
                
                    const datasetTypeToName = $filter('datasetTypeToName');
                    const enrichAndFilterTypes = (types) => types
                        .filter((t) => t) // remove undefined (feature flags not enabled)
                        .map((datasetType) => ({
                            ...datasetType,
                            label: datasetType.label || datasetTypeToName(datasetType.type),
                            status: computeStatusWithLicense(datasetType),
                        }))
                        .filter((dt) => dt.status !== uiCustomizationService.datasetTypeStatus.HIDE);
                    
                    const enrichAndFilterTile = (tile) => ({
                        ...tile,
                        types: enrichAndFilterTypes(tile.types),
                        types2: tile.types2 && enrichAndFilterTypes(tile.types2),
                    });

                    return tiles
                        .map(tile => {
                            const tmp = enrichAndFilterTile(tile);
                            if(tmp.types.length > 8) tmp.types2 = tmp.types.splice(8);
                            if(tmp.types2 && tmp.types.length === 0) {
                                tmp.types = tmp.types2; // if first column is empty but 2nd is defined, move the second column in first place
                                tmp.types2 = undefined;
                            }
                            return tmp;
                        })
                        .filter(tile => tile.types.length > 0); // remove empty tiles
                    
                })

            },

            /**
             * Returns [
             *   { isSection : false, ... }
             *   { isSection : true, id, label: icon: item : []}}}
             * ]
             */
            getAllStreamingEndpointsBySection: function (scope) {
                var ret = [];

                // type, label, disabled, reason, icon
                ret.push({
                    type: "kafka", label: "Kafka", icon: "icon-kafka",
                    fn: () => scope.showCreateStreamingEndpointModal("kafka")
                });
                ret.push({
                    type: "sqs", label: "SQS", icon: "icon-sqs",
                    fn: () => scope.showCreateStreamingEndpointModal("sqs")
                });
                ret.push({
                    label: "HTTP Server-Sent-Events", type:"httpsse", icon: "icon-httpsse",
                    fn: () => scope.showCreateStreamingEndpointModal("httpsse")
                });
                if ($rootScope.featureFlagEnabled('kdbplus')) {
                    ret.push({
                        label: "KDB+Tick ticker plant", type:"kdbplustick", icon: "icon-httpsse",
                        fn: () => scope.showCreateStreamingEndpointModal("kdbplustick")
                    });
                }
                return ret;
            },

            getStreamingRecipesBySection: function(scope) {
                var pyScientistStatus = usable();
                if (!$rootScope.appConfig.userProfile.mayPython) {
                    pyScientistStatus = notDataScientist();
                }

                var unsafeStatus = usable();
                if (!$rootScope.appConfig.globalPermissions || !$rootScope.appConfig.globalPermissions.mayWriteUnsafeCode) {
                    unsafeStatus = noUnsafeCode();
                }
                var safeStatus = usable();
                if ($rootScope.appConfig.impersonationEnabled && (!$rootScope.appConfig.globalPermissions || !$rootScope.appConfig.globalPermissions.mayWriteSafeCode)) {
                    safeStatus = noSafeCode();
                }
                
                var safeCodeStatus = $rootScope.appConfig.impersonationEnabled ? safeStatus : unsafeStatus;

                var ret = [
                        {
                            type: "cpython",
                            label: "Python (streaming)",
                            icon: "icon-continuous_python_recipe",
                            disabled: !pyScientistStatus.iconEnabled || !safeCodeStatus.iconEnabled,
                            reason: pyScientistStatus.iconDisabledReason || safeCodeStatus.iconDisabledReason,
                            fn: function () {
                                scope.showCreateCodeBasedModal("cpython", undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId));
                            }
                        },
                        {
                            type: "ksql",
                            label: "KSQL (streaming)",
                            icon: "icon-continuous_ksql_recipe",
                            disabled: !pyScientistStatus.iconEnabled || !safeCodeStatus.iconEnabled,
                            reason: pyScientistStatus.iconDisabledReason || safeCodeStatus.iconDisabledReason,
                            fn: function () {
                                scope.showCreateCodeBasedModal("ksql", undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId));
                            }
                        },
                        {
                            type: "csync",
                            label: "CSync (streaming)",
                            icon: 'icon-continuous_sync_recipe',
                            fn: function () {
                                scope.showCreateCodeBasedModal("csync", undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId));
                            }
                        },
                    ];
                
                if($rootScope.appConfig.uiCustomization.showScala) {
                    ret.push(                        {
                        type: "streaming_spark_scala",
                        label: "Spark Scala (streaming)",
                        icon: "icon-continuous_spark_scala_recipe",
                        disabled: !pyScientistStatus.iconEnabled || !safeCodeStatus.iconEnabled,
                        reason: pyScientistStatus.iconDisabledReason || safeCodeStatus.iconDisabledReason,
                        fn: function () {
                            scope.showCreateCodeBasedModal("streaming_spark_scala", undefined, scope.getRelevantZoneId(scope.$stateParams.zoneId));
                        }
                    });
                }
                return ret;
            },

            getDatasetLicenseStatus: function (type) {
                /* !! Make sure this is synchronized with the backend !! */
                if (['managed_folder', 'managed', 'ForeignDataset', 'import_from_alation', 'search_and_import', 'model_evaluation_store', 'connection_explorer', 'import_from_catalog'].includes(type)) {
                    return {
                        status: "OK"
                    };
                }
                /* Always allowed */
                const isPluginDataset = ['CustomPython_', 'CustomJava_', 'fsprovider_']
                    .some((it) => type.startsWith(it));

                if (isPluginDataset) {
                    return {
                        status: "OK",
                    };
                }

                // Core minimum for DSS to work properly :)
                if (["Filesystem", "UploadedFiles", "Inline", "FilesInFolder"].indexOf(type) >= 0) {
                    return {
                        status: "OK"
                    };
                }
                // Always included
                if (["MySQL", "GCS", "PostgreSQL", "S3", "Azure", "FTP", "SFTP", "SCP", "HTTP", "CachedHTTP"].indexOf(type) >= 0) {
                    return {
                        status: "OK"
                    };
                }
                // Nothing else in CE
                if ($rootScope.appConfig.communityEdition) {
                    return {
                        status: "NOT_LICENSED_CE"
                    };
                }
                var adt = $rootScope.appConfig.licensedFeatures.allowedDatasetTypes;
                if (adt != null && adt.length > 0) {
                    if (adt.indexOf(type) < 0) {
                        return {status: "NOT_LICENSED_EE"};
                    } else {
                        return {status: "OK"};
                    }
                } else {
                    // All allowed
                    return {
                        status: "OK"
                    }
                }
            },

            getAllStatusForDataset: function (dataset) {
                Assert.trueish(dataset, 'no dataset');
                Assert.trueish(dataset.type, 'no dataset type');

                const allRecipeTypes = $.map(RecipeDescService.getDescriptors(), (desc, type) => type).filter(type => !type.startsWith('Custom') && !type.startsWith('App_'));
                const allThings = ["sql", "hive", "impala", "pig", "sql99"];

                var ret = {recipes: {}, things: {}};
                allRecipeTypes.forEach(function (type) {
                    ret.recipes[type] = svc.recipeMaybePossibleFromDataset(dataset, type);
                });
                allThings.forEach(function (type) {
                    ret.things[type] = svc.specialThingMaybePossibleFromDataset(dataset, type);
                });

                return ret;
            },

            getAllStatusForStreamingEndpoint: function (streamingEndpoint) {
                Assert.trueish(streamingEndpoint, 'no streaming endpoint');
                Assert.trueish(streamingEndpoint.type, 'no streaming endpoint type');

                const allRecipeTypes = $.map(RecipeDescService.getDescriptors(), (desc, type) => type).filter(type => !type.startsWith('Custom'));
                const allThings = ["sql", "hive", "impala", "pig", "sql99"];

                var ret = {recipes: {}, things: {}};
                allRecipeTypes.forEach(function (type) {
                    ret.recipes[type] = svc.recipeMaybePossibleFromStreamingEndpoint(streamingEndpoint, type);
                });
                allThings.forEach(function (type) {
                    ret.things[type] = svc.specialThingMaybePossibleFromStreamingEndpoint(streamingEndpoint, type);
                });

                return ret;
            },

            /**
             * Returns whether this recipe *looks* possible from this dataset.
             * Note that additional restrictions might apply and must be checked later.
             *
             * Returns { ok : boolean, reason : String (only if !ok)}
             */
            recipeMaybePossibleFromDataset: function (dataset, recipeType) {
                var pyScientistStatus = usable();
                if (!$rootScope.appConfig.userProfile.mayPython) {
                    pyScientistStatus = notDataScientist();
                }
                var rScientistStatus = usable();
                if (!$rootScope.appConfig.userProfile.mayR) {
                    rScientistStatus = notDataScientist();
                }
                var jlScientistStatus = usable();
                if (!$rootScope.appConfig.userProfile.mayJulia) {
                    jlScientistStatus = notDataScientist();
                }
                var scalaScientistStatus = usable();
                if (!$rootScope.appConfig.userProfile.mayScala) {
                    scalaScientistStatus = notDataScientist();
                }

                var unsafeStatus = usable();
                if (!$rootScope.appConfig.globalPermissions || !$rootScope.appConfig.globalPermissions.mayWriteUnsafeCode) {
                    unsafeStatus = noUnsafeCode();
                }
                var safeStatus = usable();
                if ($rootScope.appConfig.impersonationEnabled && (!$rootScope.appConfig.globalPermissions || !$rootScope.appConfig.globalPermissions.mayWriteSafeCode)) {
                    safeStatus = noSafeCode();
                }

                var safeCodeStatus = $rootScope.appConfig.impersonationEnabled ? safeStatus : unsafeStatus;

                switch (recipeType) {
                    case "hive": {
                        var hiveStatus = getHiveStatus();
                        if (dataset.type != "HDFS" && dataset.type != "hiveserver2") {
                            return nok("Dataset is not on HDFS or Hive");
                        }
                        if (hiveStatus.iconEnabled) return ok(hiveStatus);
                        else return nok(hiveStatus.iconDisabledReason);
                    }
                    case "impala": {
                        var impalaStatus = getImpalaStatus();
                        if (dataset.type != "HDFS" && dataset.type != "hiveserver2") {
                            return nok("Dataset is not on HDFS or Hive");
                        }
                        if (impalaStatus.iconEnabled) return ok(impalaStatus);
                        else return nok(impalaStatus.iconDisabledReason);
                    }
                    case "pig" : {
                        var pigStatus = getPigStatus();
                        if (dataset.type != "HDFS") {
                            return nok("Dataset is not on HDFS");
                        }
                        if (pigStatus.iconEnabled) return ok(pigStatus);
                        else return nok(pigStatus.iconDisabledReason);
                    }
                    case "spark_sql_query":
                        var sparkStatus = getSparkStatus();
                        if (!sparkStatus.iconEnabled) return nok(sparkStatus);
                        else return ok(sparkStatus);

                    case "pyspark":
                        var sparkStatus = getSparkStatus();
                        if (!sparkStatus.iconEnabled) return nok(sparkStatus);
                        if (!pyScientistStatus.iconEnabled) return nok(pyScientistStatus);
                        if (!safeCodeStatus.iconEnabled) return nok(safeCodeStatus);
                        else return ok(sparkStatus)
                    case "sparkr":
                        var sparkStatus = getSparkStatus();
                        if (!sparkStatus.iconEnabled) return nok(sparkStatus);
                        if (!rScientistStatus.iconEnabled) return nok(rScientistStatus);
                        if (!safeCodeStatus.iconEnabled) return nok(safeCodeStatus);
                        else return ok(sparkStatus)
                    case "spark_scala":
                    case "streaming_spark_scala":
                        var sparkStatus = getSparkStatus();
                        if (!sparkStatus.iconEnabled) return nok(sparkStatus);
                        if (!scalaScientistStatus.iconEnabled) return nok(scalaScientistStatus);
                        if (!safeCodeStatus.iconEnabled) return nok(safeCodeStatus);
                        else return ok(sparkStatus);

                    case "sql_query":
                    case "sql_script":
                        if (DatasetUtils.isSQLTable(dataset)) {
                            return ok();
                        } else {
                            return nok({"iconDisabledReason": "Dataset is not a SQL Table"});
                        }
                    case "sql99":
                        if (getSparkStatus().usable) {
                            return ok();
                        }
                        if (dataset.type == "HDFS") {
                            if ($rootScope.appConfig.hiveEnabled) {
                                return ok();
                            } else {
                                return nok("Hive or Spark configuration required");
                            }
                        }
                        if (DatasetUtils.isSQLTable(dataset) && dataset.type != "MySQL") {
                            return ok();
                        }
                        return ok();
                    //return nok("Requires an SQL99-compliant database or Spark");
                    case "python":
                    case "cpython":
                    case "shell":
                        if (!pyScientistStatus.iconEnabled) return nok(pyScientistStatus);
                        if (!safeCodeStatus.iconEnabled) return nok(safeCodeStatus);
                        else return ok();
                    case "r":
                        if (!rScientistStatus.iconEnabled) return nok(rScientistStatus);
                        if (!safeCodeStatus.iconEnabled) return nok(safeCodeStatus);
                        else return ok();
                    case "julia":
                        if (!jlScientistStatus.iconEnabled) return nok(jlScientistStatus);
                        if (!safeCodeStatus.iconEnabled) return nok(safeCodeStatus);
                        else return ok();
                    case 'update':
                    case 'vstack':
                    case 'sort':
                    case 'download':
                    case 'merge_folder':
                    case 'clustering_cluster':
                    case 'prediction_training':
                    case 'evaluation':
                    case 'standalone_evaluation':
                    case 'distinct':
                    case 'clustering_training':
                    case 'grouping':
                    case 'sync':
                    case 'sampling':
                    case 'export':
                    case 'topn':
                    case 'clustering_scoring':
                    case 'join':
                    case 'fuzzyjoin':
                    case 'shaker':
                    case 'window':
                    case 'split':
                    case 'prediction_scoring':
                    case 'pivot':
                        return ok();
                    case "ksql":
                        return nok("Can only run continuously from a streaming endpoint");
                    case 'csync':
                        return nok("Can only sync continuously from a streaming endpoint");
                    default:
                        Logger.error("Recipe usability not implemented for type:", recipeType)
                }
                return ok();
            },

            specialThingMaybePossibleFromDataset: function (dataset, thing) {
                switch (thing) {
                    case "sql":
                        if (DatasetUtils.isSQLTable(dataset)) {
                            return ok();
                        } else {
                            return nok({"iconDisabledReason": "Dataset is not a SQL Table"});
                        }
                    case "hive":
                    case "impala":
                    case "pig":
                        return svc.recipeMaybePossibleFromDataset(dataset, thing);
                    case "sql99":
                        if (getSparkStatus().usable) {
                            return ok(); // In addition a configuration enabling HiveContext is necessary but we don't check it
                        }
                        if (dataset.type == "HDFS") {
                            if ($rootScope.appConfig.hiveEnabled) {
                                return ok();
                            } else {
                                return nok("Hive or Spark configuration required");
                            }
                        }
                        if (DatasetUtils.isSQLTable(dataset) && dataset.type != "MySQL") {
                            return ok();
                        }
                        return ok();
                    //return nok("Requires an SQL99-compliant database or Spark");
                }
                Logger.warn("Unknown thing type", thing);
                return ok();
            },

            /**
             * Returns whether this recipe *looks* possible from this dataset.
             * Note that additional restrictions might apply and must be checked later.
             *
             * Returns { ok : boolean, reason : String (only if !ok)}
             */
            recipeMaybePossibleFromStreamingEndpoint: function (streamingEndpoint, recipeType) {
                var pyScientistStatus = usable();
                if (!$rootScope.appConfig.userProfile.mayPython) {
                    pyScientistStatus = notDataScientist();
                }
                var rScientistStatus = usable();
                if (!$rootScope.appConfig.userProfile.mayR) {
                    rScientistStatus = notDataScientist();
                }
                var jlScientistStatus = usable();
                if (!$rootScope.appConfig.userProfile.mayJulia) {
                    jlScientistStatus = notDataScientist();
                }
                var scalaScientistStatus = usable();
                if (!$rootScope.appConfig.userProfile.mayScala) {
                    scalaScientistStatus = notDataScientist();
                }

                var unsafeStatus = usable();
                if (!$rootScope.appConfig.globalPermissions || !$rootScope.appConfig.globalPermissions.mayWriteUnsafeCode) {
                    unsafeStatus = noUnsafeCode();
                }
                var safeStatus = usable();
                if ($rootScope.appConfig.impersonationEnabled && (!$rootScope.appConfig.globalPermissions || !$rootScope.appConfig.globalPermissions.mayWriteSafeCode)) {
                    safeStatus = noSafeCode();
                }

                var safeCodeStatus = $rootScope.appConfig.impersonationEnabled ? safeStatus : unsafeStatus;

                switch (recipeType) {
                    case "streaming_spark_scala":
                        var sparkStatus = getSparkStatus();
                        if (!sparkStatus.iconEnabled) return nok(sparkStatus);
                        if (!scalaScientistStatus.iconEnabled) return nok(scalaScientistStatus);
                        if (!safeCodeStatus.iconEnabled) return nok(safeCodeStatus);
                        else return ok(sparkStatus);
                    case 'ksql':
                        if (streamingEndpoint.type != 'kafka') return nok("Only applicable to Kafka endpoints");
                        return ok();
                    case 'cpython':
                        return ok();
                    case 'csync':
                        return ok();
                    default:
                        return nok("Only accept continuous recipes");
                }
                return ok(); // NOSONAR: OK to have a fallback instruction
            },

            specialThingMaybePossibleFromStreamingEndpoint: function (streamingEndpoint, thing) {
                Logger.warn("Unknown thing type", thing);
                return ok();
            },

            newPredictionScoringRecipeFromSMID: function (scope, smProjectKey, smId, dsName, zone) {
                scope.zone = zone;
                CreateModalFromTemplate("/templates/savedmodels/new-prediction-scoring-recipe.html", scope, null, function (newScope) {
                    newScope.projectKey = $stateParams.projectKey;
                    newScope.smId = (smProjectKey === $stateParams.projectKey ? '' : smProjectKey + '.') + smId;
                    if (dsName) {
                        newScope.$broadcast('preselectInputDataset', dsName);
                    }
                });
            },
            newPredictionScoringRecipeFromDataset: function (scope, dsName, zone) {
                scope.zone = zone;
                CreateModalFromTemplate("/templates/savedmodels/new-prediction-scoring-recipe.html", scope, null, function (newScope) {
                    newScope.projectKey = $stateParams.projectKey;
                    newScope.$broadcast('preselectInputDataset', dsName);
                });
            },
            newEvaluationRecipeFromDataset: function (scope, dsName, zone) {
                scope.zone = zone;
                CreateModalFromTemplate("/templates/savedmodels/new-evaluation-recipe.html", scope, null, function (newScope) {
                    newScope.projectKey = $stateParams.projectKey;
                    newScope.$broadcast('preselectInputDataset', dsName);
                });
            },
            newEvaluationRecipeFromSMID: function (scope, smProjectKey, smId, dsName, zone) {
                scope.zone = zone;
                CreateModalFromTemplate("/templates/savedmodels/new-evaluation-recipe.html", scope, null, function (newScope) {
                    newScope.projectKey = $stateParams.projectKey;
                    newScope.recipeParams.smId = (smProjectKey === $stateParams.projectKey ? '' : smProjectKey + '.') + smId;
                    if (dsName) {
                        newScope.$broadcast('preselectInputDataset', dsName);
                    }
                });
            },
            newStandaloneEvaluationRecipeFromDataset: function (scope, dsName, zone) {
                scope.zone = zone;
                CreateModalFromTemplate("/templates/savedmodels/new-standalone-evaluation-recipe.html", scope, null, function (newScope) {
                    newScope.projectKey = $stateParams.projectKey;
                    newScope.$broadcast('preselectInputDataset', dsName);
                });
            },
            newClusteringScoringRecipeFromSMID: function (scope, smProjectKey, smId, dsName, zone) {
                scope.zone = zone;
                CreateModalFromTemplate("/templates/savedmodels/new-clustering-scoring-recipe.html", scope, null, function (newScope) {
                    newScope.projectKey = $stateParams.projectKey;
                    newScope.smId = (smProjectKey === $stateParams.projectKey ? '' : smProjectKey + '.') + smId;
                    if (dsName) {
                        newScope.$broadcast('preselectInputDataset', dsName);
                    }
                });
            },

            newClusteringScoringRecipeFromDataset: function (scope, dsName, zone) {
                scope.zone = zone;
                CreateModalFromTemplate("/templates/savedmodels/new-clustering-scoring-recipe.html", scope, null, function (newScope) {
                    newScope.projectKey = $stateParams.projectKey;
                    newScope.$broadcast('preselectInputDataset', dsName);
                });
            },

            smartNewAnalysis: function smartNewAnalysis(scope, datasetSmartName, forMLTask) {
                CreateModalFromTemplate("/templates/analysis/new-analysis-on-dataset-modal.html", scope, null, function (newScope) {
                    newScope.forMLTask = !!forMLTask;
                    newScope.datasetSmartName = datasetSmartName;
                })
            },

            trainSavedModel: function (scope, id) {
                CreateModalFromTemplate("/templates/savedmodels/build-model-modal.html", scope, "BuildSavedModelController", function(newScope) {
                    newScope.modelId = id;
                });
            },

            deleteTaggableObject: function(scope, taggableType, id, displayName) {
                var deletionRequests = [{
                    type: taggableType,
                    projectKey: $stateParams.projectKey,
                    id: id,
                    displayName: displayName
                }];
                return TaggableObjectsService.delete(deletionRequests)
                    .then(function() {
                        if ($rootScope.topNav.item.id == id) {
                            $state.go("projects.project.flow");
                        } else if (typeof scope.list == "function") {
                            scope.list();
                        }
                    }, setErrorInScope.bind(scope));
            },

            clearDataset: function (scope, id) {
                const taggableItems = [{
                    type: 'DATASET',
                    projectKey: $stateParams.projectKey,
                    id: id,
                    displayName: id
                }];
                return ComputablesService.clear(scope, taggableItems);
            },

            clearManagedFolder: function (scope, id, name) {
                const taggableItems = [{
                    type: 'MANAGED_FOLDER',
                    projectKey: $stateParams.projectKey,
                    id: id,
                    displayName: name
                }];
                return ComputablesService.clear(scope, taggableItems);
            },

            buildManagedFolder: function (scope, id) {
                CreateModalFromTemplate("/templates/managedfolder/build-folder-modal.html", scope, "BuildManagedFolderController", function (newScope) {
                    newScope.projectKey = $stateParams.projectKey;
                    newScope.odbId = id;
                });
            },

            buildModelEvaluationStore: function (scope, id) {
                CreateModalFromTemplate("/templates/modelevaluationstores/build-store-modal.html", scope, "BuildModelEvaluationStoreController", function (newScope) {
                    newScope.projectKey = $stateParams.projectKey;
                    newScope.mesId = id;
                });
            },

        }
        
        
        svc['getFlowOtherItemsBySection'] = function(scope) {
            var ret = [];

            let streamingEndpoints = {
                isSection: true,
                id: "streaming-endpoints",
                label: "Streaming endpoints",
                icon: "icon-double-angle-right",
                items: [
                    {
                        type: "kafka", label: "Kafka", icon: "icon-kafka",
                        fn: () => scope.showCreateStreamingEndpointModal("kafka")
                    },
                    {
                        type: "sqs", label: "SQS", icon: "icon-sqs",
                        fn: () => scope.showCreateStreamingEndpointModal("sqs")
                    },
                    {
                        label: "HTTP Server-Sent-Events", type:"httpsse", icon: "icon-httpsse",
                        fn: () => scope.showCreateStreamingEndpointModal("httpsse")
                    }
                ]
            };
            if ($rootScope.featureFlagEnabled("kdbplus")) {
                streamingEndpoints.items.push({
                    label: "KDB+Tick ticker plant", type:"kdbplustick", icon: "icon-httpsse",
                    fn: () => scope.showCreateStreamingEndpointModal("kdbplustick")
                });
            }
            ret.push(streamingEndpoints);

            var pyScientistStatus = usable();
            if (!scope.appConfig.userProfile.mayPython) {
                pyScientistStatus = notDataScientist();
            }

            var unsafeStatus = usable();
            if (!$rootScope.appConfig.globalPermissions || !$rootScope.appConfig.globalPermissions.mayWriteUnsafeCode) {
                unsafeStatus = noUnsafeCode();
            }
            var safeStatus = usable();
            if ($rootScope.appConfig.impersonationEnabled && (!$rootScope.appConfig.globalPermissions || !$rootScope.appConfig.globalPermissions.mayWriteSafeCode)) {
                safeStatus = noSafeCode();
            }
            
            var safeCodeStatus = $rootScope.appConfig.impersonationEnabled ? safeStatus : unsafeStatus;

            ret.push({
                isSection: true,
                id: "streaming-recipes",
                label: "Streaming recipes",
                icon: "icon-double-angle-right",
                items: svc.getStreamingRecipesBySection(scope)
            });
            return ret;
        }
        
        return svc;
    });



})();

(function() {
'use strict';

const app = angular.module('dataiku.controllers');

/*
 * to add new modules to the existing app, some hacking around angular is needed. And
 * this hacking needs to happen in a config block, so that we have access to the
 * providers.
 * see http://benohead.com/angularjs-requirejs-dynamic-loading-and-pluggable-views/ for
 * explanations.
 */
app.config(['$controllerProvider', '$compileProvider', '$filterProvider', '$provide', '$injector',
    function ($controllerProvider, $compileProvider, $filterProvider, $provide, $injector) {
        // only offer one granularity: module (no injecting just a controller, for ex)
        app.registerModule = function (moduleName) {
            var module = angular.module(moduleName);

            if (module.requires) {
                // recurse if needed
                for (var i = 0; i < module.requires.length; i++) {
                    app.registerModule(module.requires[i]);
                }
            }

            var providers = {
                    $controllerProvider: $controllerProvider,
                    $compileProvider: $compileProvider,
                    $filterProvider: $filterProvider,
                    $provide: $provide
                };

            angular.forEach(module._invokeQueue, function(invokeArgs) {
                var provider = providers[invokeArgs[0]];
                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
            });
            angular.forEach(module._configBlocks, function (fn) {
                $injector.invoke(fn);
            });
            angular.forEach(module._runBlocks, function (fn) {
                $injector.invoke(fn);
            });
        };
    }
]);



app.controller("AppDesignerController", function($scope, $rootScope, $controller, $state, $stateParams, DataikuAPI, Dialogs, TopNav, CreateModalFromTemplate, FutureProgressModal, StateUtils, $filter, ActivityIndicator, $timeout, WT1, CodeMirrorSettingService, StringUtils, PluginsService) {
    $controller('_TaggableObjectsListPageCommon', {$scope: $scope});

    TopNav.setLocation(TopNav.TOP_MORE, "appsdesign", TopNav.TABS_NONE, null);
    TopNav.setNoItem();

    $scope.codeMirrorSettingService = CodeMirrorSettingService;

    $scope.showRemapping = !$rootScope.appConfig.isAutomation;

    $scope.uiState = {tags:{}, instanceTags:{}, toc:{}, useAsRecipe:false};
    
    $scope.tileTypes = [
                            {type:'UPLOAD_DATASET_SET_FILE'},
                            {type:'INLINE_DATASET_EDIT'},
                            {type:'DATASET_EDIT_SETTINGS'},
                            {type:'FILES_BASED_DATASET_BROWSE_AND_PREVIEW'},
                            {type:'CONNECTION_EXPLORER_TO_REPLACE_THE_SETTINGS_OF_A_DATASET_WITH_A_NEW_TABLE_REFERENCE'},
                            {type:'MANAGED_FOLDER_ADD_FILE'},
                            {type:'MANAGED_FOLDER_BROWSE'},
                            {type:'STREAMING_ENDPOINT_EDIT_SETTINGS'},
                            {type:'PROJECT_VARIABLES_EDIT'},
                            {divider:true},
                            {type:'SCENARIO_RUN'},
                            //{type:'GUESS_TRAIN_DEPLOY'},
                            {type:'PERFORM_SCHEMA_PROPAGATION'},
                            {divider:true},
                            {type:'DASHBOARD_LINK'},
                            {type:'MANAGED_FOLDER_LINK'},
                            {type:'DOWNLOAD_DATASET'},
                            {type:'DOWNLOAD_RMARKDOWN'},
                            {type:'DOWNLOAD_MANAGED_FOLDER_FILE'},
                            {type:'DOWNLOAD_DASHBOARD_EXPORT'},
                            {type:'VARIABLE_DISPLAY'}
                        ];
    if (!$rootScope.appConfig.streamingEnabled) {
        $scope.tileTypes = $scope.tileTypes.filter(t => t.type != 'STREAMING_ENDPOINT_EDIT_SETTINGS');
    }
    
    $scope.availableConnections = [];
    DataikuAPI.connections.getTypeAndNames("all").success(function(data) {
         $scope.availableConnections = data;
    }).error(setErrorInScope.bind($scope));
    
    $scope.usedConnections = [];
    DataikuAPI.connections.listUsages($stateParams.projectKey).success(function(data) {
        $scope.usedConnections = data.map(c => c.name);
    }).error(setErrorInScope.bind($scope));

    $scope.availableCodeEnvs = [{envLang:'PYTHON', envName:'Builtin', builtin:true}, {envLang:'R', envName:'Builtin', builtin:true}];
    DataikuAPI.codeenvs.listNames('PYTHON').success(function(data) {
        data.forEach(function(n) {
            $scope.availableCodeEnvs.push({envLang:'PYTHON', envName:n, builtin:false});
        });
    }).error(setErrorInScope.bind($scope));
    DataikuAPI.codeenvs.listNames('R').success(function(data) {
        data.forEach(function(n) {
            $scope.availableCodeEnvs.push({envLang:'R', envName:n, builtin:false});
        });
    }).error(setErrorInScope.bind($scope));
    
    $scope.usedCodeEnvs = [];
    DataikuAPI.codeenvs.listUsages($stateParams.projectKey).success(function(data) {
        $scope.usedCodeEnvs = data.map(c => c.envName);
    }).error(setErrorInScope.bind($scope));

    DataikuAPI.datasets.listHeaders($stateParams.projectKey).success(function(data) {
        $scope.allDatasets = data;
    }).error(setErrorInScope.bind($scope));
    
    DataikuAPI.managedfolder.list($stateParams.projectKey).success(function(data) {
        $scope.allManagedFolders = data;
    }).error(setErrorInScope.bind($scope));

    DataikuAPI.savedmodels.list($stateParams.projectKey).success(function(data) {
        $scope.allSavedModels = data;
    }).error(setErrorInScope.bind($scope));

    $scope.origAppManifest = null;
    $scope.getAppManifest = function() {
        DataikuAPI.projects.getAppManifest($stateParams.projectKey).success(function(data) {
            $scope.uiState.appManifest = data;
            $scope.origAppManifest = angular.copy(data);
            $scope.exportOptions = data.projectExportManifest; // put at the root of the scope for the ng-included export-data-options.html
            $scope.exporterSettings = {exportOptions:data.projectExportManifest} // for the bundle-content-editor
            $scope.getAppSummary();
            $scope.uiState.useAsRecipe = data.useAsRecipeSettings != null;
            regenToc();
        }).error(setErrorInScope.bind($scope));
    }
    
    $scope.origRemapping = null;
    $scope.getAppRemapping = function() {
        if ($scope.showRemapping) {
            DataikuAPI.projects.getAppRemapping($stateParams.projectKey).success(function(data) {
                $scope.uiState.appRemapping = data;
                $scope.origRemapping = angular.copy(data);
            }).error(setErrorInScope.bind($scope));
        }
    };
    
    $scope.appIsDirty = function() {
        let manifestIsDirty = ($scope.origAppManifest != null && !angular.equals($scope.uiState.appManifest, $scope.origAppManifest));
        let remappingIsDirty = ($scope.origRemapping != null && !angular.equals($scope.uiState.appRemapping, $scope.origRemapping));
        return manifestIsDirty || remappingIsDirty;
    };
    // checking for the test instance is done differently, because there is a call to the backend to actually (re)create the instance first
    // and the saves need to be done before that call
    let allowTransitionToTestInstance = data => data.toState.name == 'projects.project.home.regular' && data.toParams.testInstance == "true"
    checkChangesBeforeLeaving($scope, $scope.appIsDirty, null, allowTransitionToTestInstance);
    
    $scope.recipeRoleNamesChanged = function() {
        if (!$scope.uiState.useAsRecipe) return false;
        let oldInputs = (($scope.origAppManifest || {}).useAsRecipeSettings || {}).inputRoles || [];
        let newInputs = (($scope.uiState.appManifest || {}).useAsRecipeSettings || {}).inputRoles || [];
        let oldOutputs = (($scope.origAppManifest || {}).useAsRecipeSettings || {}).outputRoles || [];
        let newOutputs = (($scope.uiState.appManifest || {}).useAsRecipeSettings || {}).outputRoles || [];
        let oldInputsSet = new Set(oldInputs.map(_ => _.objectId));
        let newInputsSet = new Set(newInputs.map(_ => _.objectId));
        let oldOutputsSet = new Set(oldOutputs.map(_ => _.objectId));
        let newOutputsSet = new Set(newOutputs.map(_ => _.objectId));
        let symDiff = function(a, b) {
            let r = new Set();
            for (let x of a) {
                if (!b.has(x)) r.add(x);
            }
            for (let x of b) {
                if (!a.has(x)) r.add(x);
            }
            return r;
        };
        return symDiff(oldInputsSet, newInputsSet).size > 0 || symDiff(oldOutputsSet, newOutputsSet).size > 0;
    };
    
    $scope.getAppSummary = function() {
        return DataikuAPI.apps.getTemplateSummary($scope.uiState.appManifest.id).success(function (data) {
            $scope.uiState.appSummary = data;
        }).error(setErrorInScope.bind($scope));
    }

    $scope.saveApp = function(refetchAppManifest) {
        DataikuAPI.projects.saveAppManifest($stateParams.projectKey, $scope.uiState.appManifest).success(function(data) {
            $scope.origAppManifest = angular.copy($scope.uiState.appManifest);

            if (refetchAppManifest) {
                $scope.getAppManifest();
            }
        }).error(setErrorInScope.bind($scope));
        
        if ($scope.showRemapping && $scope.uiState.appRemapping) {
            DataikuAPI.projects.saveAppRemapping($stateParams.projectKey, $scope.uiState.appRemapping).success(function(data) {
                $scope.origRemapping = angular.copy($scope.uiState.appRemapping);
            }).error(setErrorInScope.bind($scope));
        }
    }

    let init = function() {
        if ($scope.projectSummary.projectAppType == 'APP_TEMPLATE') {
            $scope.getAppManifest();
            $scope.getAppRemapping();
        }
    };
    if ($scope.projectSummary == null || $scope.projectSummary.projectKey != $stateParams.projectKey) {
        // wait until our projectSummary arrives
        let deregisterInit = $scope.$watch('projectSummary', function() {
            if ($scope.projectSummary && $scope.projectSummary.projectKey == $stateParams.projectKey) {
                init();
                deregisterInit();
            }    
        });
    } else {
        init();
    }
    let switchAppType = function(appType, useAsRecipe) {
        DataikuAPI.projects.switchAppType($stateParams.projectKey, appType, {useAsRecipe:useAsRecipe}).success(function(data) {
            WT1.event('app-switch-app-type', {appType:appType})
            $scope.projectSummary.projectAppType = appType; // apply the part we know has changed
            $scope.refreshProjectData(); // start a refresh of the projectSummary (this controller isn't the only one needing it)
            init(); // redo the init, since the app type changed
        }).error(setErrorInScope.bind($scope));
    };
    
    function regenToc() {
        let elems = [];
        elems.push({section:true, label:'Application header', id:'app_header'});
        // elems.push({section:true, label:'Full image', id:'app_image'});
        if (!$scope.uiState.useAsRecipe) {
            elems.push({section:true, label:'Application features', id:'app_features'});
        }
        elems.push({section:true, label:'Included content', id:'app_data'});
        if ($scope.uiState.useAsRecipe) {
            elems.push({section:true, label:'Application-as-recipe', id:'app_as_recipe'});
        } else {
            let itemIdx = 0;
            $scope.uiState.appManifest.homepageSections.forEach(function(section) {
                section.$id = itemIdx++;
                elems.push({section:true, label: function() {return section.sectionTitle || 'Section';}, id:'section_' + section.$id});
                section.tiles.forEach(function(tile) {
                    tile.$id = itemIdx++;
                    elems.push({section:false, label: function() {return tile.prompt || $filter('niceTileType')(tile.type) || 'Tile';}, id:'tile_' + tile.$id});
                });
            });
        }
        $scope.uiState.toc.elems = elems;
    };
    $scope.refreshTocAfterDrag = function() {$timeout(regenToc);}; // timeout to let ui-sortable commit the change 
    
    $scope.addHomepageSection = function() {
        $scope.uiState.appManifest.homepageSections.push({tiles:[]});
        regenToc();
    };
    $scope.removeHomepageSection = function(section) {
        let idx = $scope.uiState.appManifest.homepageSections.indexOf(section);
        if (idx >= 0) {
            $scope.uiState.appManifest.homepageSections.splice(idx, 1);
            regenToc();
        }
    };
    
    $scope.addTile = function(section, type) {
        let tile = {type:type};
        section.tiles.push(tile);
        regenToc();
    };
    $scope.removeTile = function(section, tile) {
        let idx = section.tiles.indexOf(tile);
        if (idx >= 0) {
            section.tiles.splice(idx, 1);
            regenToc();
        }
    };
    
    $scope.convertToApp = function(useAsRecipe) {
        switchAppType('APP_TEMPLATE', useAsRecipe);
    };
    $scope.convertToRegular = function() {
        Dialogs.confirm($scope, 'Project type conversion','Are you sure you want to make the project a regular project again (and lose the application definition) ?').then(function() {
            switchAppType('REGULAR');
        });
    };
    $scope.createOrUpdatePlugin = function() {
        CreateModalFromTemplate("/templates/apps/app-template-to-plugin-modal.html", $scope, null, function(modalScope) {
            modalScope.manifest = $scope.uiState.appManifest;
            WT1.event('app-create-or-update-plugin')
            DataikuAPI.plugindev.list().success(function(data) {
                modalScope.devPlugins = data;
            }).error(setErrorInScope.bind($scope));

            modalScope.convert = {
                mode: 'NEW'
            };
            
            modalScope.isIdValid = function() {
                if (modalScope.convert.mode === 'EXISTING') {
                    if (!modalScope.convert.targetPluginId) return false;
                    const plugin = modalScope.devPlugins.find(_ => _.desc.id === modalScope.convert.targetPluginId);
                    return PluginsService.isValidComponentId(modalScope.convert.targetFolder,
                                                            modalScope.convert.targetPluginId,
                                                            []); // accept that a component exists with the same name, to update it
                } else {
                    if (!modalScope.convert.newPluginId) return false;
                    return PluginsService.isValidComponentId(modalScope.convert.targetFolder,
                                                            modalScope.convert.newPluginId,
                                                            []);
                }
            };

            modalScope.go = function() {
                const params = modalScope.convert;
                const pluginId = params.mode == 'NEW' ? params.newPluginId : params.targetPluginId;
                const appName = params.targetFolder;
                DataikuAPI.projects.createOrUpdatePlugin($stateParams.projectKey, pluginId, appName).success(function(data) {
                    FutureProgressModal.show(modalScope, data, "Creating a plugin application template").then(function(data) {
                        modalScope.dismiss();
                        $scope.reloadPluginConfiguration();
                        StateUtils.go.pluginEditor(data.pluginId, data.pathToFiles);
                    });
                }).error(setErrorInScope.bind($scope));
            };
        });
    };
    
    function checkDirtynessBeforeTesting() {
        if ($scope.appIsDirty()) {
            if (!confirm('You have unsaved changes, are you sure you want to test the previous state and lose changes ?')) { // NOSONAR: Yes we want to display a pop-up
                return false;
            }
        }
        return true;
    };
    
    $scope.goToTestInstanceInNewTabIfNeeded = function($event, projectKey) {
        if ($event.ctrlKey || $event.metaKey) {
            var url = $state.href('projects.project.home.regular', { projectKey: projectKey, testInstance: "true" });
            window.open(url,'_blank');
        } else {
            $state.go('projects.project.home.regular', { projectKey: projectKey, testInstance: "true" });
        }                
    };

    $scope.createOrUpdateTestInstance = function($event) {
        if (!checkDirtynessBeforeTesting()) return;
        WT1.event('app-test-instance', {full:false})
        DataikuAPI.apps.createOrUpdateTestInstance($scope.uiState.appManifest.id, false).success(function(data) {
            FutureProgressModal.show($scope, data, "Creating or updating test instance").then(function(data) {
                if (data.fatal) {
                    Dialogs.infoMessagesDisplayOnly($scope, "Instantiation result", data);
                } else {
                    $scope.goToTestInstanceInNewTabIfNeeded($event, data.targetProjectKey);
                }
            });
        }).error(setErrorInScope.bind($scope));
    }

    $scope.createOrRecreateTestInstance = function($event) {
        if (!checkDirtynessBeforeTesting()) return;
        WT1.event('app-test-instance', {full:true})
        DataikuAPI.apps.createOrUpdateTestInstance($scope.uiState.appManifest.id, true).success(function(data) {
            FutureProgressModal.show($scope, data, "Creating or updating test instance").then(function(data) {
                if (data.fatal) {
                    Dialogs.infoMessagesDisplayOnly($scope, "Instantiation result", data);
                } else {
                    $scope.goToTestInstanceInNewTabIfNeeded($event, data.targetProjectKey);
                }
            });
        }).error(setErrorInScope.bind($scope));
    }

    $scope.goToTestInstance = function($event) {
        if (!checkDirtynessBeforeTesting()) return;
        WT1.event('app-test-instance', {full:null})
        DataikuAPI.apps.getTestInstance($scope.uiState.appManifest.id).success(function(data) {
            if (!data) {
                ActivityIndicator.warning("No test instance found, you must create one first");
            } else {
                $scope.goToTestInstanceInNewTabIfNeeded($event, data);
            }
        }).error(setErrorInScope.bind($scope));
    }
    
    // tags
    $scope.startEditTags  = function() {
        $scope.uiState.tags.newVal = angular.copy($scope.uiState.appManifest.tags);
        $scope.uiState.tags.editing = true;
    };
    $scope.cancelEditTags  = function() {
        $scope.uiState.tags.newVal = null;
        $scope.uiState.tags.editing = false;
    };
    $scope.validateEditTags  = function() {
        if ($scope.uiState.tags.editing) {
            $scope.uiState.appManifest.tags = $scope.uiState.tags.newVal;
            $scope.uiState.tags.editing = false;
        }
    };
    
    // make sure we only edit one field at a time (otherwise it's messy)
    let currentEditingField = {appLabel:null, appShortDesc:null};
    let stopCurrentEdit = function() {
        if (currentEditingField.appLabel) {
            $scope.cancelEditLabel(currentEditingField.appLabel);
        }
        if (currentEditingField.appShortDesc) {
            $scope.cancelEditShortDesc(currentEditingField.appShortDesc);
        }
    };
    
    $scope.startEditLabel = function(manifest) {
        stopCurrentEdit();
        $scope.uiState.$editingLabel = true;
        $scope.uiState.edited = manifest.label;
        currentEditingField.appLabel = manifest;
    };
    $scope.stopEditLabel = function(manifest) {
        $scope.uiState.$editingLabel = false;
        manifest.label = $scope.uiState.edited;
        currentEditingField.appLabel = null;
    };
    $scope.cancelEditLabel = function(manifest) {
        $scope.uiState.$editingLabel = false;
        currentEditingField.appLabel = null;
    };
    $scope.startEditShortDesc = function(manifest) {
        stopCurrentEdit();
        $scope.uiState.$editingShortDesc = true;
        $scope.uiState.edited = manifest.shortDesc;
        currentEditingField.appShortDesc = manifest;
    };
    $scope.stopEditShortDesc = function(manifest) {
        $scope.uiState.$editingShortDesc = false;
        manifest.shortDesc = $scope.uiState.edited;
        currentEditingField.appShortDesc = null;
    };
    $scope.cancelEditShortDesc = function(manifest) {
        $scope.uiState.$editingShortDesc = false;
        currentEditingField.appShortDesc = null;
    };
    
    $scope.addConnectionRemapping = function(name) {
        $scope.uiState.appRemapping.connections.push({
            source: name,
            target: null
        });
    };
    $scope.prepareConnectionRemapping = function(name) {
        return {
            source: name,
            target: null
        };
    };
    $scope.addCodeEnvRemapping = function(name) {
        $scope.uiState.appRemapping.codeEnvs.push({
            source: name,
            target: null
        });
    };
    $scope.prepereCodeEnvRemapping = function(name) {
        return {
            source: name,
            target: null
        };
    };
    
    $scope.hasHelpEditor = function(tile) {
        return tile.$hasHelp || tile.help || tile.helpTitle || tile.$editingHelp || tile.$editingHelpTitle;
    };
    $scope.addHelp = function(tile) {
        tile.$hasHelp = true;
    };
    $scope.removeHelp = function(tile) {
        tile.help = null;
        tile.helpTitle = null;
        tile.$hasHelp = false;
    };
    
    $scope.$watch("uiState.useAsRecipe", function() {
        if ($scope.uiState.appManifest == null) return;
        if ($scope.uiState.useAsRecipe) {
            let defaultUseAsRecipeSettings = {
                                                "icon": "icon-dku-application-as-recipe",
                                                "inputRoles": [],
                                                "outputRoles": [],
                                                "variablesEditionTile": {
                                                   "behavior": "MODAL",
                                                   "params": []
                                                },
                                                "runScenarioTile": {}
                                             }
            $scope.uiState.appManifest.useAsRecipeSettings = $scope.uiState.appManifest.useAsRecipeSettings || defaultUseAsRecipeSettings;
        } else {
            $scope.uiState.appManifest.useAsRecipeSettings = null;
        }
        regenToc();
    });

    $scope.$on("projectImgEdited", function(ev, newState){
        $scope.uiState.appManifest.imgColor = newState.imgColor;
        $scope.uiState.appManifest.imgPattern = parseInt(newState.imgPattern, 10);
        $scope.uiState.appManifest.showInitials = newState.showInitials;
        $scope.saveApp(true);
    });

    function buildNewRoleName(isInput) {
        const newRoleInfo = isInput ?
            {prefix: "Input", existingRoles: $scope.uiState.appManifest.useAsRecipeSettings.inputRoles} :
            {prefix: "Output", existingRoles: $scope.uiState.appManifest.useAsRecipeSettings.outputRoles};
        return StringUtils.transmogrify(newRoleInfo.prefix, newRoleInfo.existingRoles.map(existingRole => existingRole.roleLabel));
    }

    function buildNewRole(isInput) {
        return function () {
            return {roleLabel: buildNewRoleName(isInput), type: 'DATASET', objectId: null};
        };
    }

    $scope.buildNewInputRole = buildNewRole(true);
    $scope.buildNewOutputRole = buildNewRole(false);
});

app.controller('AppsListController', function ($scope, $state, $location, $rootScope, $http, Assert, DataikuAPI, localStorageService, WT1, TopNav, CreateModalFromTemplate, ListFilter, LoggerProvider, Fn, Debounce, DKUConstants, TaggingService, HomePageContextService, openDkuPopin, $q, StateUtils, HomeBehavior) {

    const Logger = LoggerProvider.getLogger('AppsListController');

    $scope.uiState = {};
    $scope.displayMode = {mode: 'mosaic'};
    $scope.query = {tags:[], q:''};
    $scope.sortBy = {mode:'name'};
    $scope.tagsMap = {};
    $scope.tagsList = [];

    TopNav.setLocation(TopNav.DSS_HOME);

    TaggingService.fetchGlobalTags();

    //Items rows for mosaic view
    const getMosaicRows = function (itemsList) {
        /* Compute display characteristics for mosaic mode */
        const tileW = 190;
        const margins = 40;

        let itemsPerRow = 1;
        let ww = window.innerWidth;
        ww -= margins;

        if (ww > tileW) itemsPerRow = Math.floor(ww / tileW);

        const mosaicItemsPerRow = [];
        let i, j;
        for (i = 0, j = itemsList.length; i < j; i += itemsPerRow) {
            mosaicItemsPerRow.push(itemsList.slice(i, i + itemsPerRow));
        }
        return mosaicItemsPerRow;
    };
    
    $scope.prepareApp = function(app, tagsMap) {
        // --- Tags
        //populating tagsMap
        app.tags.forEach(tag => {
            const entry = tagsMap.get(tag);
            if (entry !== undefined) {
                entry.count++;
            } else {
                const tagDef = null; // app.tagsFile.tags[tag] // no tagsFile in apps
                const color = (tagDef == undefined || tagDef.color == undefined) ? TaggingService.getDefaultColor(tag) : tagDef.color;
                tagsMap.set(tag, {count: 1, color: color});
            }
        });
    };
    
    const updateDisplayedItems = function() {
        $scope.filteredAppTemplatesList = filterAppTemplatesList($scope.appTemplatesList, $scope.query);
        $scope.filteredAppTemplatesList = sortAppTemplatesList($scope.filteredAppTemplatesList);

        $scope.filteredAppTemplatesRows = getMosaicRows($scope.filteredAppTemplatesList);
    };

    $scope.appTemplatesList = [];
    $scope.listApps = function () {
        return DataikuAPI.apps.listTemplates().success(function (data) {
            $scope.appTemplatesList = data.items;
            
            const tagsMap = new Map();
            $scope.appTemplatesList.forEach(app => $scope.prepareApp(app, tagsMap));

            $scope.tagsList = [];
            tagsMap.forEach((value, key) => $scope.tagsList.push({ title: key, count: value.count, color: value.color }));
            $scope.tagsList.sort((a, b) => a.title > b.title);
            
            updateDisplayedItems();
        }).error(setErrorInScope.bind($scope));
    };
    $scope.listApps();
        
    var debouncedResizeCB = Debounce().withDelay(200, 200).wrap(updateDisplayedItems);

    $(window).on("resize.appsPageResize", debouncedResizeCB);
    $scope.$on("$destroy", function () {
        $(window).off("resize.appsPageResize", debouncedResizeCB);
    });
    
    $scope.clickOnApp = function(appTemplate, $event) {
        $state.go('apps.app', { appId: appTemplate.appId });
    };
    
    $scope.isFiltering = function () {
        return $scope.query.tags.length > 0 || $scope.isFullStringQuerying();
    };

    $scope.isFullStringQuerying = function () {
        return typeof($scope.query.q) !== "undefined" && $scope.query.q.length > 0;
    };
    
    $scope.clearFilters = function () {
        $scope.query.tags = [];
        $scope.query.q = "";
    };
    
    $scope.toggleTag = function (tagTitle) {
        if (tagTitle) {
            var index = $scope.query.tags.indexOf(tagTitle);
            index > -1 ? $scope.query.tags.splice(index, 1) : $scope.query.tags.push(tagTitle);
        }
    };
   
    $scope.getDefaultTagColor = TaggingService.getTagColor;
    $scope.getAppInstanceOwnerDisplayList = function (contributors, maxDisplayedContributors) {
        if (contributors.length > maxDisplayedContributors) {
            return contributors.slice(0, maxDisplayedContributors - 1);
        }
        return contributors
    };
    
    /**
     * Returns a list of app templates filtered by full text query, tags, users, status, path.
     * Keeps app templates that match at least one condition for each non-empty filtering category (text query, tags, contributors, status, path)
     * @param appTemplatesList: input list to filter
     * @param query: object wrapping query attributes:
     *      - q: textQuery on which projects list will be filtered (looking through all project's attribute)
     *      - tags: list of tags to filter projects list (inclusive filtering - keep items that match at least one tag)
     *      - path: path used to filter projects list (project's path needs to be equal to it, or an extension of it in case of full text filtering)
     * @returns {*}
     */
    function filterAppTemplatesList(appTemplatesList, query) {
        if ($scope.isFiltering()) {
            WT1.event('app-list-fitering', {tags:(query.tags && query.tags.length), fullString:$scope.isFullStringQuerying()})
        }
        // Filtering on full text query
        let filteredAppTemplatesList = ListFilter.filter(appTemplatesList || [], query.q);

        // Keep apps that have at least one of the tag selected in the 'Tags' filter (if there are any)
        if (query.tags && query.tags.length) {
            filteredAppTemplatesList = filteredAppTemplatesList.filter(app => {
                if (!app.tags) {
                    return;
                }
                return query.tags.some(tag => app.tags.includes(tag));
            });
        }

        return filteredAppTemplatesList;
    }

    $scope.$watch("query", function (nv, ov) {
        if (!angular.equals(nv, ov)) {
            updateDisplayedItems();
        }
    }, true);
    $scope.$watch("sortBy", function (nv, ov) {
        if (!angular.equals(nv, ov)) {
            WT1.event('app-list-sort', {by:$scope.sortBy})
            updateDisplayedItems();
        }
    }, true);

    /*
     * Sorting projects list
     */

    $scope.sortByModeTitles = Object.freeze({
        name: "Application Name"
    });

    function sortAppTemplatesList(appTemplatesList) {
        if (!$scope.sortBy) {
            return;
        }
        switch ($scope.sortBy.mode) {
            case "name":
                sortByName(appTemplatesList);
                break;
        }
        if ($scope.sortBy.isReversedSort) {
            appTemplatesList.reverse();
        }
        return appTemplatesList;
    }

    function sortByName(appTemplatesList) {
        appTemplatesList.sort(function (p1, p2) {
            return alphabeticalSort(p1.label || p1.appId, p2.label || p2.appId);
        });
    }

});

app.controller("AppPageController", function($scope, $controller, $state, $stateParams, $rootScope, CreateModalFromTemplate, Dialogs, Logger, DataikuAPI, TopNav, Debounce, ListFilter, Assert, DKUConstants, WT1, TaggingService, StateUtils, openDkuPopin, DetectUtils) {

    $controller('_ProjectsListBaseBehavior', { $scope });

    TopNav.setLocation(TopNav.DSS_HOME);
    TaggingService.fetchGlobalTags();
    $scope.getDefaultTagColor = TaggingService.getTagColor;

    $scope.uiState = {};
    $scope.displayMode = {mode: 'mosaic'};
    $scope.query = {tags:[], projectStatus:[], contributors:[], q:''};
    $scope.sortBy = {mode:'commit'};
    $scope.tagsMap = {};
    $scope.tagsList = [];
    $scope.contributorsMap = {};
    $scope.contributorsList = [];
    
    $scope.os = DetectUtils.getOS();
    
    //Items rows for mosaic view
    const getMosaicRows = function (itemsList) {
        /* Compute display characteristics for mosaic mode */
        const tileW = 310;
        const margins = 40;
        const leftPaneWidth = 400 + 40; // don't forget padding

        let itemsPerRow = 1;
        let ww = window.innerWidth;
        ww -= margins;
        ww -= leftPaneWidth;

        if (ww > tileW) itemsPerRow = Math.floor(ww / tileW);

        const mosaicItemsPerRow = [];
        let i, j;
        for (i = 0, j = itemsList.length; i < j; i += itemsPerRow) {
            mosaicItemsPerRow.push(itemsList.slice(i, i + itemsPerRow));
        }
        return mosaicItemsPerRow;
    };
    
    const updateDisplayedItems = function() {
        $scope.filteredAppInstancesList = filterAppInstancesList($scope.appInstancesList, $scope.query);
        $scope.filteredAppInstancesList = sortAppInstancesList($scope.filteredAppInstancesList);

        $scope.filteredAppInstancesRows = getMosaicRows($scope.filteredAppInstancesList);
    };

    var debouncedResizeCB = Debounce().withDelay(200, 200).wrap(updateDisplayedItems);

    $(window).on("resize.appPageResize", debouncedResizeCB);
    $scope.$on("$destroy", function () {
        $(window).off("resize.appPageResize", debouncedResizeCB);
    });
    

    $scope.appInstancesList = [];
    $scope.fetchAppSummary = function(clearSelectedProjects) {
        $scope.appInstancesList = [];
        return DataikuAPI.apps.getTemplateSummary($stateParams.appId).success(function (data) {
            $scope.appSummary = data;
            $scope.appInstancesList = $scope.appSummary.instances;
            
            const tagsMap = new Map();
            const contributorsMap = new Map();
            $scope.appInstancesList.forEach(p => {
                // --- Tags
                //populating tagsMap will all descendants projects
                p.tags.forEach(tag => {
                    const entry = tagsMap.get(tag);
                    if (entry !== undefined) {
                        entry.count++;
                    } else {
                        const tagDef = p.tagsFile.tags[tag]
                        const color = (tagDef == undefined || tagDef.color == undefined) ? TaggingService.getDefaultColor(tag) : tagDef.color;
                        tagsMap.set(tag, {count: 1, color: color});
                    }
                });

                p.contributors.forEach(contributor => {
                    if (!contributorsMap.has(contributor.login)) {
                        contributorsMap.set(contributor.login, angular.extend({}, contributor, { sortName: contributor.displayName.toLowerCase() }));
                    }
                })
            });

            $scope.tagsList = [];
            tagsMap.forEach((value, key) => $scope.tagsList.push({ title: key, count: value.count, color: value.color }));
            $scope.tagsList.sort((a, b) => a.title > b.title);

            $scope.contributorsList = [];
            contributorsMap.forEach((value) => $scope.contributorsList.push(value));
            $scope.contributorsList.sort((a, b) => a.sortName.localeCompare(b.sortName));

            // don't forget to re-generate the selectedProjects list (and trim it of now-deleted projects at the same time)
            $scope.selectedProjects = [...$scope.appInstancesList.filter(p => $scope.selectedProjects.findIndex(p2 => p.projectKey == p2.projectKey) >= 0)]            
            updateDisplayedItems();
        }).error(setErrorInScope.bind($scope));
    }

    $scope.openInstantiationModal = function() {
        CreateModalFromTemplate("/templates/apps/app-instantiation-modal.html", $scope, "AppInstantiationModalController");
    }

    $scope.fetchAppSummary();
    
    $scope.clickOnAppInstance = function(appInstance, $event) {
        if ($scope.isPopupActive) {
            return;
        }
        event.preventDefault();
        if (event.ctrlKey || event.metaKey) {
            toggleSelectProject(appInstance);
            window.getSelection().removeAllRanges(); //FF fix for messy text selection
        } else {
            appInstance.effectivePermission == "READER" ? StateUtils.go.pinboard(appInstance.projectKey) : StateUtils.go.project(appInstance.projectKey);
        }
    };

    $scope.selectedProjects = [];
    function toggleSelectProject(project, expectSelected) {
        let index = $scope.selectedProjects.findIndex(p => p.projectKey === project.projectKey);
        if (index == -1) {
            if (expectSelected == true || expectSelected === undefined) {
                $scope.selectedProjects.push(project);
            }
        } else {
            if (expectSelected == false || expectSelected === undefined) {
                $scope.selectedProjects.splice(index, 1);
            }
        }
    }
    $scope.isProjectSelected = project => $scope.selectedProjects.findIndex(sp => sp.projectKey === project.projectKey) !== -1;
    
    $scope.selectAllInstances = function() {
        $scope.filteredAppInstancesList.forEach(p => toggleSelectProject(p, true))
    };
    $scope.unselectAllInstances = function() {
        $scope.filteredAppInstancesList.forEach(p => toggleSelectProject(p, false))
    };
    function toggleAllInstancesStartingFrom(project, selectAfter, expectSelected) {
        let idx = $scope.filteredAppInstancesList.findIndex(p => p.projectKey == project.projectKey);
        if (idx >= 0) {
            let affected = selectAfter ? $scope.filteredAppInstancesList.filter((p,i) => i >= idx) : $scope.filteredAppInstancesList.filter((p,i) => i <= idx);
            affected.forEach(p => toggleSelectProject(p, expectSelected))
        } else {
            // project not found, suspicious
        }
    };

    $scope.getProjectContributorDisplayList = function (contributors, maxDisplayedContributors) {
        if (contributors.length > maxDisplayedContributors) {
            return contributors.slice(0, maxDisplayedContributors - 1);
        }
        return contributors
    };
    
    // refactor status color handling out into a service for easier usage in separated scopes
    $scope.getProjectStatusColor = function(status) {
        return ProjectStatusService.getProjectStatusColor(status);
    }
    
    
    $scope.isFiltering = function () {
        return $scope.query.tags.length > 0 || $scope.query.contributors.length > 0 || $scope.query.projectStatus.length > 0 || $scope.isFullStringQuerying();
    };

    $scope.isFullStringQuerying = function () {
        return typeof($scope.query.q) !== "undefined" && $scope.query.q.length > 0;
    };
    
    $scope.clearFilters = function () {
        $scope.query.tags = [];
        $scope.query.projectStatus = [];
        $scope.query.contributors = [];
        $scope.query.q = "";
    };
    
    $scope.toggleTag = function (tagTitle) {
        if (tagTitle) {
            var index = $scope.query.tags.indexOf(tagTitle);
            index > -1 ? $scope.query.tags.splice(index, 1) : $scope.query.tags.push(tagTitle);
        }
    };
    
    /**
     * Returns a list of app instances filtered by full text query, tags, users, status, path.
     * Keep apps that match at least one condition for each non-empty filtering category (text query, tags, contributors, status, path)
     * @param appInstancesList: input list to filter
     * @param query: object wrapping query attributes:
     *      - q: textQuery on which projects list will be filtered (looking through all project's attribute)
     *      - tags: list of tags to filter projects list (inclusive filtering - keep items that match at least one tag)
     *      - contributors: list of contributors to filter projects list (inclusive filtering - keep items that match at least one contributor)
     *      - projectStatus: list of projectStatus to filter projects list (inclusive filtering - keep items that match at least one project status)
     *      - path: path used to filter projects list (project's path needs to be equal to it, or an extension of it in case of full text filtering)
     * @returns {*}
     */
    function filterAppInstancesList(appInstancesList, query) {
        if ($scope.isFiltering()) {
            WT1.event('app-instances-fitering', {tags:(query.tags && query.tags.length), contributors:(query.contributors && query.contributors.length), projectStatus:(query.projectStatus && query.projectStatus.length), fullString:$scope.isFullStringQuerying()})
        }
        // Filtering on full text query
        let filteredAppInstancesList = ListFilter.filter(appInstancesList || [], query.q).filter(app => {

            // Keep apps that have at least one of the tags selected in the 'Tags' filter (if there are any)
            if (query.tags && query.tags.length) {
                if (!app.tags || !query.tags.some(tag => app.tags.includes(tag))) {
                    return;
                }
            }

            // Keep apps that have at least one of the contributors selected in the 'Users' filter (if there are any)
            if (query.contributors && query.contributors.length) {
                if (!app.contributors || !app.contributors.some(contributor => query.contributors.includes(contributor.login))) {
                    return;
                }
            }

            // Keep apps that have at least one of the project status selected in the 'Status' filter (if there are any)
            if (query.projectStatus && query.projectStatus.length) {
                if (query.projectStatus.indexOf(app.projectStatus) < 0) {
                    return;
                }
            } else if (app.projectStatus === DKUConstants.ARCHIVED_PROJECT_STATUS) {
                return;
            }

            return true;
        });

        return filteredAppInstancesList;
    }

    $scope.$watch("query", function (nv, ov) {
        if (!angular.equals(nv, ov)) {
            updateDisplayedItems();
        }
    }, true);
    $scope.$watch("sortBy", function (nv, ov) {
        if (!angular.equals(nv, ov)) {
            updateDisplayedItems();
        }
    }, true);

    /*
     * Sorting projects list
     */

    $scope.sortByModeTitles = Object.freeze({
        name: "Project Name",
        commit: "Last Modified",
        commit_for_user: "Last Modified By Me",
        status: "Status"
    });

    function sortAppInstancesList(appInstancesList) {
        if (!$scope.sortBy) {
            return;
        }
        switch ($scope.sortBy.mode) {
            case "name":
                sortByName(appInstancesList);
                break;
            case "status":
                sortByStatus(appInstancesList);
                break;
            case "commit":
                sortByCommit(appInstancesList);
                break;
            case "commit_for_user":
                sortByCommitForUser(appInstancesList);
                break;
        }
        if ($scope.sortBy.isReversedSort) {
            appInstancesList.reverse();
        }
        return appInstancesList;
    }

    function sortByName(appInstancesList) {
        appInstancesList.sort(function (p1, p2) {
            return alphabeticalSort(p1.name, p2.name);
        });
    }

    function sortByStatus(appInstancesList) {
        Assert.inScope($rootScope, 'appConfig');
        const projectStatusNames = [];
        $rootScope.appConfig.projectStatusList.forEach(function (s) {
            projectStatusNames.push(s.name);
        })
        appInstancesList.sort(function (p1, p2) {
            if (p1.projectStatus && p2.projectStatus) {
                var indexOfStatus1 = projectStatusNames.indexOf(p1.projectStatus);
                var indexOfStatus2 = projectStatusNames.indexOf(p2.projectStatus);
                return indexOfStatus1 < indexOfStatus2 ? -1 : indexOfStatus1 == indexOfStatus2 ? alphabeticalSort(p1.name, p2.name) : 1;
            } else if (p1.projectStatus) {
                return -1;
            } else if (p2.projectStatus) {
                return 1;
            } else {
                return alphabeticalSort(p1.name, p2.name);
            }
        });
    }

    function sortByCommit(appInstancesList) {
        appInstancesList.sort(function (p1, p2) {
            if (p1.lastCommit && p2.lastCommit) {
                return p1.lastCommit.time < p2.lastCommit.time ? 1 : p1.lastCommit.time == p2.lastCommit.time ? 0 : -1;
            } else if (p1.lastCommit) {
                return -1;
            } else if (p2.lastCommit) {
                return 1;
            } else {
                return 0;
            }
        });
    }

    function sortByCommitForUser(appInstancesList) {
        appInstancesList.sort(function (p1, p2) {
            if (p1.lastCommitForUser && p2.lastCommitForUser) {
                return p1.lastCommitForUser.time < p2.lastCommitForUser.time ? 1 : p1.lastCommitForUser.time == p2.lastCommitForUser.time ? 0 : -1;
            } else if (p1.lastCommitForUser) {
                return -1;
            } else if (p2.lastCommitForUser) {
                return 1;
            } else {
                return 0;
            }
        });
    }
    
    $scope.deleteInstances = function() {
        let projectKeys = $scope.selectedProjects.map(p => p.projectKey);
        DataikuAPI.apps.checkInstancesDeletability($stateParams.appId, projectKeys).success(function(data) {
            if(data.anyMessage) {
                // Some error happened!
                CreateModalFromTemplate("/templates/apps/delete-instances-results.html", $scope, null, function(newScope) {
                    newScope.beforeDeletion = true;
                    newScope.results = data.messages;
                });
            } else {
                CreateModalFromTemplate("/templates/apps/delete-instances-confirm-dialog.html", $scope, null, function(newScope) {
                    newScope.projectKeys = projectKeys;
                    newScope.dropManagedData = true;
                    newScope.dropManagedFoldersOutputOfRecipe = true;
                    newScope.confirmProjectDeletion = function(dropManagedData, dropManagedFoldersOutputOfRecipe) {
                        DataikuAPI.apps.deleteInstances($stateParams.appId, projectKeys, dropManagedData, dropManagedFoldersOutputOfRecipe).success(function(deletionResult) {
                            if (deletionResult.anyMessage) {
                                CreateModalFromTemplate("/templates/apps/delete-instances-results.html", $scope, null, function(newScope) {
                                    newScope.beforeDeletion = false;
                                    newScope.results = deletionResult.messages;
                                    newScope.$on('$destroy',function() {
                                        $scope.fetchAppSummary();
                                    });
                                });
                            } else {
                                $scope.fetchAppSummary();
                            }
                        }).error(setErrorInScope.bind($scope));
                        WT1.event("instances-delete",{dropManagedData:dropManagedData, dropManagedFoldersOutputOfRecipe:dropManagedFoldersOutputOfRecipe});
                    }
                });
            }
        }).error(setErrorInScope.bind($scope));
    };
    

    $scope.openInstanceMenu = function (project, $event) {
        let template = `<ul class="dropdown-menu projects-dropdown-menu" >
        <li><a ng-click="toggleSelection()">{{selectedProjects.indexOf(project) < 0 ? 'Select' : 'Unselect'}}</a></li>
        <li><a ng-click="selectBefore()">Select all before</a></li>
        <li><a ng-click="selectAfter()">Select all after</a></li>
        <li><a ng-click="unselectBefore()">Unselect all before</a></li>
        <li><a ng-click="unselectAfter()">Unselect all after</a></li>
        </ul>`;
        let callback = newScope => {
            newScope.projects = newScope.selectedProjects.length > 0 ? newScope.selectedProjects : [project];
            newScope.project = project;
            newScope.appConfig = $scope.appConfig;
            newScope.toggleSelection = () => toggleSelectProject(project);
            newScope.selectAfter = () => toggleAllInstancesStartingFrom(project, true, true);
            newScope.selectBefore = () => toggleAllInstancesStartingFrom(project, false, true);
            newScope.unselectAfter = () => toggleAllInstancesStartingFrom(project, true, false);
            newScope.unselectBefore = () => toggleAllInstancesStartingFrom(project, false, false);
        };
        let isElsewhere = (_, e) => $(e.target).parents('.dropdown-menu').length == 0;
        $scope.lockForPopup();
        let dkuPopinOptions = {
            template: template,
            isElsewhere: isElsewhere,
            popinPosition: 'CLICK',
            callback: callback,
            onDismiss: $scope.unlockAfterPopup
        };
        $scope.popupDismiss = openDkuPopin($scope, $event, dkuPopinOptions);
    };
    
})

app.controller("AppInstantiationModalController", function($scope, $state, $stateParams, DataikuAPI, Dialogs, FutureProgressModal, WT1) {

    $scope.instantiation = {
        targetProjectKey: "",
        targetProjectLabel: ""
    }

    DataikuAPI.projects.listAllKeys()
        .success(function(data) { $scope.allProjectKeys = data; })
        .error(setErrorInScope.bind($scope));

    function isProjectKeyUnique(value) {
        return !$scope.allProjectKeys || $scope.allProjectKeys.indexOf(value) < 0;
    };

    $scope.$watch("instantiation.targetProjectKey", function(nv, ov) {
        $scope.uniq = !nv || isProjectKeyUnique(nv);
    });

    $scope.$watch("instantiation.targetProjectLabel", function(nv, ov) {
        if (!nv) return;
        var slug = nv.toUpperCase().replace(/\W+/g, ""),
            cur = slug,
            i = 0;
        while (!isProjectKeyUnique(cur)) {
            cur = slug + "_" + (++i);
        }
        $scope.instantiation.targetProjectKey = cur;
    });

    $scope.create = function() {
        WT1.event('app-instantiate')
        DataikuAPI.apps.instantiate($stateParams.appId, $scope.instantiation.targetProjectKey, $scope.instantiation.targetProjectLabel).success(function(future) {
            const targetProjectKey = $scope.instantiation.targetProjectKey;
            const appPageScope = $scope.$parent.$parent;
            FutureProgressModal.show(appPageScope, future, "Creating your own copy of the application").then(function(result) {
                if (!result.done) {
                    Dialogs.infoMessagesDisplayOnly(appPageScope, "Instantiation result", result, undefined, undefined, 'static', false);
                } else {
                    $state.go("projects.project.home.regular", {projectKey: targetProjectKey})
                }
            });
            $scope.dismiss();
        }).error(setErrorInScope.bind($scope));
    }
});

app.controller("AppTilesController", function($scope, $rootScope, $controller, $state, $stateParams, DataikuAPI, Dialogs, TopNav, CreateModalFromTemplate, FutureProgressModal, StateUtils, Debounce, WT1) {
    $scope.uiState = {};

    /******
     * get/set the project variables across all the 'edit variables' tiles
     ******/
    $scope.projectLocalVariables = null;
    
    DataikuAPI.projects.variables.get($stateParams.projectKey).success(function(data) {
        $scope.projectLocalVariables = angular.copy(data.local);
        $scope.uiState.localVariables = data.local;
        $scope.uiState.standardVariables = data.standard;
    }).error(setErrorInScope.bind($scope));
    
    let debouncedUpdate = Debounce().withDelay(100, 500).withScope($scope).wrap(function () {
        if ($scope.projectLocalVariables != null && $scope.uiState.localVariables != null && !angular.equals($scope.projectLocalVariables, $scope.uiState.localVariables)) {
            let newLocalVariables = angular.copy($scope.projectLocalVariables);
            let projectVariables = {standard:$scope.uiState.standardVariables, local:newLocalVariables};
            return DataikuAPI.projects.variables.save($stateParams.projectKey, projectVariables).success(function(data) {
                $scope.uiState.localVariables = newLocalVariables;
            }).error(setErrorInScope.bind($scope));
        }
    });
    $scope.$watch("projectLocalVariables", debouncedUpdate, true);
    
    /******
     * utils
     ******/
    $scope.overtakePromptMargin = function(tile) {
        if (!tile || !tile.type) return false;
        if (tile.prompt) return false;
        if (tile.type == 'PROJECT_VARIABLES_EDIT') {
            return tile.behavior && tile.behavior.startsWith("INLINE_");
        } else {
            return false;
        }
    };
});

/**********************
 * Utilities
 **********************/

app.filter('niceTileType', function () {
    // Keep in sync with:
    //  - com.dataiku.dip.coremodel.AppHomepageTile.AppHomepageTileType
    //  - app-designer.html
    //      - in the drop down of `Add tile`
    //      - in the tiles ng-switch
    const displayableTileTypes = {
        UPLOAD_DATASET_SET_FILE: "Upload file in dataset",
        MANAGED_FOLDER_ADD_FILE: "Upload file in folder",
        INLINE_DATASET_EDIT: "Edit dataset",
        DATASET_EDIT_SETTINGS: "Edit dataset settings",
        STREAMING_ENDPOINT_EDIT_SETTINGS: "Edit streaming endpoint settings",
        FILES_BASED_DATASET_BROWSE_AND_PREVIEW: "Select dataset files",
        CONNECTION_EXPLORER_TO_REPLACE_THE_SETTINGS_OF_A_DATASET_WITH_A_NEW_TABLE_REFERENCE: "Select SQL table",
        DASHBOARD_LINK: "View dashboard",
        MANAGED_FOLDER_LINK: "View folder",
        SCENARIO_RUN: "Run scenario",
        PROJECT_VARIABLES_EDIT: "Edit project variables",
        PERFORM_SCHEMA_PROPAGATION: "Propagate schema",
        DOWNLOAD_DATASET: "Download dataset",
        DOWNLOAD_DASHBOARD_EXPORT: "Download dashboard",
        DOWNLOAD_MANAGED_FOLDER_FILE: "Download file",
        DOWNLOAD_RMARKDOWN: "Download report",
        VARIABLE_DISPLAY: "Variable display",
        GUESS_TRAIN_DEPLOY: "Reguess and retrain model",
        MANAGED_FOLDER_BROWSE: "Select folder files"
    };
    return function (input) {
        if (!input) return input;
        const displayable = displayableTileTypes[input];
        return displayable || input;
    }
});

app.directive("appTilesToc", function(DataikuAPI, $stateParams, $timeout) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/fragments/toc.html',
        scope: {
            toc : '=appTilesToc',
            scrollSelector : '@'
        },
        link : function($scope, element, attrs) {
            let scroller = $($scope.scrollSelector);
            function computeVisibilities() {
                if ($scope.toc == null || $scope.toc.elems == null) return;
                
                let viewTop = scroller.offset().top;
                let viewBottom = viewTop + scroller.height();
                
                $scope.toc.elems.forEach(function(elem) {
                    elem.visible = false;
                    elem.active = false;
                    let elemHtml = $('#' + elem.id);
                    if (elemHtml && elemHtml.offset()) {
                        let elemTop = elemHtml.offset().top;
                        elem.visible = (elemTop <= viewBottom) && (elemTop >= viewTop);
                    } else {
                        elem.visible = false;
                    }
                });

                // find first active
                var foundActive = null;
                $scope.toc.elems.forEach(function(elem) {
                    elem.active = elem.visible && foundActive == null;
                    foundActive = foundActive || (elem.active ? elem : null);
                });
                
                if (foundActive != null) {
                    $scope.toc.part = 'tab_' + foundActive.id;
                }
            };
            $scope.$watch('toc.elems', function() {
                computeVisibilities();
            }); // the array is recreated on changes, don't do a deep watch
            scroller.on('scroll', function() {$timeout(computeVisibilities)});
            computeVisibilities();
            
            $scope.scrollTo = function(elem) {
                let elemHtml = $('#' + elem.id);
                elemHtml[0].scrollIntoView();
            };
            
            $scope.getLabel = function(elem) {
                return angular.isFunction(elem.label) ? elem.label() : elem.label;
            };
        }
    };
});

/**********************
 * Tiles
 **********************/

app.directive("uploadDatasetSetFileAppTileEdit", function(DataikuAPI, $stateParams, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/edit/upload-dataset-set-file.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            $scope.behaviors = [
                                   {name:'GO_TO_DATASET',                    label:'Go to dataset settings'},
                                   {name:'INLINE_UPLOAD_ONLY',               label:'Only upload file'},
                                   {name:'INLINE_UPLOAD_AND_REDETECT',       label:'Upload file and automatically redetect format'},
                                   {name:'INLINE_UPLOAD_REDETECT_AND_INFER', label:'Upload file and automatically redetect format and infer schema'}
                               ];
                               
            DataikuAPI.datasets.listHeaders($stateParams.projectKey).success(function(data) {
                $scope.datasets = data.filter(function(x) {return x.type == 'UploadedFiles';});
            }).error(setErrorInScope.bind($scope));
            
            let init = function() {
                if (!$scope.tile.behavior) {
                    $scope.tile.behavior = 'GO_TO_DATASET'; // the default
                }
            };
            if ($scope.tile) {
                init();
            } else {
                let deregister = $scope.$watch('tile', function() {
                    if ($scope.tile) {
                        init();
                        deregister();
                    } 
                });
            }
        }
    }
});

app.directive("uploadDatasetSetFileAppTileView", function(DataikuAPI, $stateParams, MonoFuture, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/view/upload-dataset-set-file.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            let fetchDataset = function() {
                DataikuAPI.datasets.get($stateParams.projectKey, $scope.tile.datasetName, $stateParams.projectKey).success(function(data){
                    $scope.dataset = data;
                }).error(setErrorInScope.bind($scope));
            };
    
            $scope.uiState = {};
            $scope.files = [];
            $scope.downloadingFiles = 0;
            
            let realFileListChanged = function() {
                if ($scope.tile.behavior == 'INLINE_UPLOAD_AND_REDETECT' || $scope.tile.behavior == 'INLINE_UPLOAD_REDETECT_AND_INFER') {
                    let doInfer = $scope.tile.behavior == 'INLINE_UPLOAD_REDETECT_AND_INFER';
                    MonoFuture($scope).wrap(DataikuAPI.datasets.testAndDetectFormat)($stateParams.projectKey, $scope.dataset, true, doInfer).success(function(data) {
                        $scope.uiState.detecting = false;
                        $scope.detectionResults = data.result;
                        if (data.result.connectionOK && !data.result.empty) {
                            $scope.dataset.formatType = data.result.format.type;
                            $scope.dataset.formatParams = data.result.format.params;
                            if (doInfer) {
                                $scope.dataset.schema = data.result.format.schemaDetection.detectedSchema;
                            }
                            DataikuAPI.datasets.save($stateParams.projectKey, $scope.dataset, {}).success(function(data) {
                                fetchDataset();
                            }).error(setErrorInScope.bind($scope));
                        }
                    }).update(function(data) {
                        $scope.uiState.detecting = true;
                    }).error(function (data, status, headers) {
                        $scope.uiState.detecting = false;
                        setErrorInScope.bind($scope)(data, status, headers);
                    });
                }
            };
        
            $scope.drop = function (uploaded_files) {
                // if its a brand new dataset, instantiate an uploadbox first
                // upload files with progress bar

                WT1.event('app-tile-upload-dataset-drop', {nbFiles:uploaded_files.length})
    
                for (var i = uploaded_files.length - 1; i >= 0; i--) {
                    (function (uploaded_file) {
                        var file = {
                                progress: 0,
                                path: uploaded_file.name,
                                length: uploaded_file.size
                            };
                        $scope.files.push(file);
                        $scope.downloadingFiles++;
                        DataikuAPI.datasets.upload.addFileToDataset($stateParams.projectKey, uploaded_file, $scope.dataset, function (e) {
                            // progress bar
                            if (e.lengthComputable) {
                                $scope.$apply(function () {
                                    file.progress = Math.round(e.loaded * 100 / e.total);
                                });
                            }
                        }).then(function (data) {
                            //success
                            var index = $scope.files.indexOf(file);
                            try {
                                data = JSON.parse(data);
                                if (data.wasArchive) {
                                    ActivityIndicator.success("Extracted "  + data.files.length + " files from Zip archive");
                                }
                                // replace stub file object by result of upload
                                $scope.files = $scope.files.slice(0, index).concat(data.files).concat($scope.files.slice(index + 1));
                                $scope.files.sort(function (a, b) {
                                    return a.path < b.path;
                                });
                            } catch(e){
                                // a lot can go wrong
                                $scope.files = $scope.files.slice(0, index).concat($scope.files.slice(index + 1));
                            }
                            $scope.downloadingFiles--;
                            realFileListChanged();
                        }, function(payload){
                            // delete faulty file
                            $scope.files.splice($scope.files.indexOf(file), 1);
    
                            try {
                                setErrorInScope.bind($scope)(JSON.parse(payload.response), payload.status, function(h){return payload.getResponseHeader(h)});
                            } catch(e) {
                                // The payload.response is not JSON
                                setErrorInScope.bind($scope)({$customMessage: true, message: (payload.response || "Unknown error").substring(0, 20000), httpCode: payload.status}, payload.status);
                            }
    
                            $scope.downloadingFiles--;
                        });
                    } (uploaded_files[i]));
                }
            }
            
            $scope.deleteFile = function (file, e) {
                e.preventDefault();
                e.stopPropagation();
                WT1.event('app-tile-upload-dataset-delete')
                DataikuAPI.datasets.upload.removeFile($stateParams.projectKey, $scope.dataset, file.path).success(function(data) {
                    $scope.files.splice($scope.files.indexOf(file), 1);
                    realFileListChanged();
                }).error(setErrorInScope.bind($scope));
            };
            
            let init = function() {
                fetchDataset();
                DataikuAPI.datasets.upload.listFiles($stateParams.projectKey, $scope.tile.datasetName).success(function (data) {
                    $scope.files = data;
                }).error(setErrorInScope.bind($scope));
            };
            if ($scope.tile) {
                init();
            } else {
                let deregister = $scope.$watch('tile', function() {
                    if ($scope.tile) {
                        init();
                        deregister();
                    } 
                });
            }
        }
    }
});

app.directive("folderSetFileAppTileEdit", function(DataikuAPI, $stateParams, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/edit/folder-set-file.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            $scope.behaviors = [
                                   {name:'GO_TO_FOLDER',  label:'Go to folder'},
                                   {name:'INLINE_UPLOAD', label:'Upload file'}
                               ];

            DataikuAPI.managedfolder.list($stateParams.projectKey).success(function(data) {
                $scope.folders = data;
            }).error(setErrorInScope.bind($scope));
            
            let init = function() {
                if (!$scope.tile.behavior) {
                    $scope.tile.behavior = 'GO_TO_FOLDER'; // the default
                }
            };
            if ($scope.tile) {
                init();
            } else {
                let deregister = $scope.$watch('tile', function() {
                    if ($scope.tile) {
                        init();
                        deregister();
                    } 
                });
            }
        }
    }
});

app.directive("folderSetFileAppTileView", function(DataikuAPI, $stateParams, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/view/folder-set-file.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            let fetchFolder = function() {
                DataikuAPI.managedfolder.get($stateParams.projectKey, $stateParams.projectKey, $scope.tile.folderId).success(function(data) {
                    $scope.folder = data;
                }).error(setErrorInScope.bind($scope));
            };
    
            $scope.uiState = {};
            $scope.files = [];
            $scope.downloadingFiles = 0;
            
            $scope.drop = function (uploaded_files) {
                // upload files with progress bar
                WT1.event('app-tile-upload-folder-drop', {nbFiles:uploaded_files.length})
                for (var i = uploaded_files.length - 1; i >= 0; i--) {
                    (function (uploaded_file) {
                        var file = {
                                progress: 0,
                                name: '/' + uploaded_file.name,
                                fullPath: uploaded_file.name,
                                length: uploaded_file.size
                            };
                        $scope.files.push(file);
                        $scope.downloadingFiles++;
                        DataikuAPI.managedfolder.uploadItem($stateParams.projectKey, $scope.tile.folderId, file.fullPath, uploaded_file, true, function (e) {
                            // progress bar
                            if (e.lengthComputable) {
                                $scope.$apply(function () {
                                    file.progress = Math.round(e.loaded * 100 / e.total);
                                });
                            }
                        }).then(function (data) {
                            //success
                            var index = $scope.files.indexOf(file);
                            try {
                                data = JSON.parse(data);
                                // replace stub file object by result of upload
                                $scope.files = $scope.files.slice(0, index).concat(data).concat($scope.files.slice(index + 1));
                                $scope.files.sort(function (a, b) {
                                    return a.path < b.path;
                                });
                            } catch(e){
                                // a lot can go wrong
                                $scope.files = $scope.files.slice(0, index).concat($scope.files.slice(index + 1));
                            }
                            $scope.downloadingFiles--;
                        }, function(payload){
                            // delete faulty file
                            $scope.files.splice($scope.files.indexOf(file), 1);
    
                            try {
                                setErrorInScope.bind($scope)(JSON.parse(payload.response), payload.status, function(h){return payload.getResponseHeader(h)});
                            } catch(e) {
                                // The payload.response is not JSON
                                setErrorInScope.bind($scope)({$customMessage: true, message: (payload.response || "Unknown error").substring(0, 20000), httpCode: payload.status}, payload.status);
                            }
    
                            $scope.downloadingFiles--;
                        });
                    } (uploaded_files[i]));
                }
            }
            
            $scope.getIconClass = function(item) {
                if (!item) return '';
                if (item.directory) return 'icon-folder-close colored-folder-icon';
                return 'icon-file';
            };
            
            $scope.deleteFile = function (file, e) {
                e.preventDefault();
                e.stopPropagation();
                WT1.event('app-tile-upload-folder-delete')
                DataikuAPI.managedfolder.deleteItems($stateParams.projectKey, $scope.tile.folderId, [file.fullPath]).success(function(data) {
                    $scope.files.splice($scope.files.indexOf(file), 1);
                }).error(setErrorInScope.bind($scope));
            };
            
            let init = function() {
                fetchFolder();
                DataikuAPI.managedfolder.browse($stateParams.projectKey, $scope.tile.folderId, '/').success(function (data) {
                    $scope.files = data.children;
                }).error(setErrorInScope.bind($scope));
            };
            if ($scope.tile) {
                init();
            } else {
                let deregister = $scope.$watch('tile', function() {
                    if ($scope.tile) {
                        init();
                        deregister();
                    } 
                });
            }            
            
        }
    }
});

app.directive("editInlineDatasetAppTileEdit", function(DataikuAPI, $stateParams, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/edit/edit-inline-dataset.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            DataikuAPI.datasets.listHeaders($stateParams.projectKey).success(function(data) {
                $scope.datasets = data.filter(function(x) {return x.type == 'Inline';});
            }).error(setErrorInScope.bind($scope));
        }
    }
});

app.directive("editInlineDatasetAppTileView", function(DataikuAPI, $stateParams, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/view/edit-inline-dataset.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
        }
    }
});

app.directive("editAnyDatasetAppTileEdit", function(DataikuAPI, $stateParams, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/edit/edit-any-dataset.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            DataikuAPI.datasets.listHeaders($stateParams.projectKey).success(function(data) {
                $scope.datasets = data;
            }).error(setErrorInScope.bind($scope));
        }
    }
});

app.directive("editAnyDatasetAppTileView", function(DataikuAPI, $stateParams, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/view/edit-any-dataset.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
        }
    }
});

app.directive("editAnyStreamingEndpointAppTileEdit", function(DataikuAPI, $stateParams, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/edit/edit-any-streaming-endpoint.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            return DataikuAPI.streamingEndpoints.listHeads($stateParams.projectKey, {}, true).success(function (data) {
                $scope.streamingEndpoints = data;
            }).error(setErrorInScope.bind($scope));
        }
    }
});

app.directive("editAnyStreamingEndpointAppTileView", function(DataikuAPI, $stateParams, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/view/edit-any-streaming-endpoint.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
        }
    }
});

app.directive("editFsDatasetAppTileEdit", function(DataikuAPI, $stateParams, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/edit/edit-fs-dataset.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            $scope.behaviors = [
                                   {name:'GO_TO_DATASET',                    label:'Go to dataset settings'},
                                   {name:'INLINE_BROWSE_ONLY',               label:'Only browse file'},
                                   {name:'INLINE_BROWSE_AND_REDETECT',       label:'Browse file and automatically redetect format'},
                                   {name:'INLINE_BROWSE_REDETECT_AND_INFER', label:'Browse file and automatically redetect format and infer schema'},
                                   {name:'MODAL_BROWSE_REDETECT_AND_INFER',  label:'Modal to browse file and automatically redetect format and infer schema'}
                               ];
                               
            DataikuAPI.datasets.listHeaders($stateParams.projectKey).success(function(data) {
                $scope.datasets = data.filter(function(x) {return ["HDFS", "Filesystem", "SCP", "SFTP", "FTP", "S3", "GCS", "Azure"].indexOf(x.type) >= 0;});
            }).error(setErrorInScope.bind($scope));
            
            let init = function() {
                if (!$scope.tile.behavior) {
                    $scope.tile.behavior = 'GO_TO_DATASET'; // the default
                }
            };
            if ($scope.tile) {
                init();
            } else {
                let deregister = $scope.$watch('tile', function() {
                    if ($scope.tile) {
                        init();
                        deregister();
                    } 
                });
            }
        }
    }
});

app.directive("editFsDatasetAppTileView", function(DataikuAPI, $stateParams, $state, MonoFuture, CreateModalFromTemplate, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/view/edit-fs-dataset.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            $scope.uiState = {};
            let fetchDataset = function() {
                DataikuAPI.datasets.get($stateParams.projectKey, $scope.tile.datasetName, $stateParams.projectKey).success(function(data){
                    $scope.dataset = data;
                }).error(setErrorInScope.bind($scope));
            };
        
            $scope.browse = function (path) {
                if (path == null) path = '';
                var configAnchoredAtRoot = angular.copy($scope.dataset.params);
                // We discard stuff to have a shorter serialized version of our dataset
                configAnchoredAtRoot.path = '';
                
                WT1.event('app-tile-fs-dataset-browse')

                // Ugly workaround. Angular 1.2 unwraps promises (don't understand why)
                // Except if the promise object has a $$v.
                // See https://github.com/angular/angular.js/commit/3a65822023119b71deab5e298c7ef2de204caa13
                // and https://github.com/angular-ui/bootstrap/issues/949
                var promise = DataikuAPI.fsproviders.browse($scope.dataset.type, configAnchoredAtRoot, $stateParams.projectKey, {}, path);
                promise.$$v = promise;
                return promise;
            };
            
            $scope.doTest = function() {
                let doInfer = $scope.tile.behavior.indexOf('INFER') >= 0;
                let doDetect = $scope.tile.behavior.indexOf('REDETECT') >= 0;
                let commitChangesDirectly = $scope.tile.behavior.startsWith("INLINE_");
                WT1.event('app-tile-fs-dataset-test', {infer:doInfer, detect:doDetect, save:commitChangesDirectly})
                if (doDetect) {
                    MonoFuture($scope).wrap(DataikuAPI.datasets.testAndDetectFormat)($stateParams.projectKey, $scope.dataset, doDetect, doInfer).success(function(data) {
                        $scope.detectionResults = data.result;
                        if (data.result.connectionOK && !data.result.empty) {
                            $scope.dataset.formatType = data.result.format.type;
                            $scope.dataset.formatParams = data.result.format.params;
                            if (doInfer) {
                                $scope.dataset.schema = data.result.format.schemaDetection.detectedSchema;
                            }
                            if (commitChangesDirectly) {
                                DataikuAPI.datasets.save($stateParams.projectKey, $scope.dataset, {}).success(function(data) {
                                    fetchDataset();
                                }).error(setErrorInScope.bind($scope));
                            }
                        }
                    }).update(function(data) {
                    }).error(function (data, status, headers) {
                        setErrorInScope.bind($scope)(data, status, headers);
                    });
                } else {
                    if (commitChangesDirectly) {
                        DataikuAPI.datasets.save($stateParams.projectKey, $scope.dataset, {}).success(function(data) {
                            fetchDataset();
                        }).error(setErrorInScope.bind($scope));
                    }
                }
            };
            
            $scope.openModal = function() {
                WT1.event('app-tile-fs-dataset-modal')
                CreateModalFromTemplate("/templates/apps/tiles/view/edit-fs-dataset-modal.html", $scope, null, function(modalScope) {
                    modalScope.goToDataset = function() {
                        modalScope.dismiss();
                        $state.go('projects.project.datasets.dataset.settings', {datasetName : $scope.tile.datasetName});
                    };
                    modalScope.doTestIfNeeded = function() {
                        if ($scope.uiState.autoTestOnFileSelection) {
                            $scope.doTest();
                        }
                    };
                    modalScope.commit = function() {
                        DataikuAPI.datasets.save($stateParams.projectKey, $scope.dataset, {}).success(function(data) {
                            fetchDataset();
                        }).error(setErrorInScope.bind($scope));
                        modalScope.dismiss();
                    };
                    
                    modalScope.$watch('dataset.params.previewFile', modalScope.doTestIfNeeded, true);
                    modalScope.$watch('dataset.params.filesSelectionRules', modalScope.doTestIfNeeded, true);
                });
            };
        
            let init = function() {
                fetchDataset();
            };
            if ($scope.tile) {
                init();
            } else {
                let deregister = $scope.$watch('tile', function() {
                    if ($scope.tile) {
                        init();
                        deregister();
                    } 
                });
            }
        
        }
    }
});

app.directive("editFolderAppTileEdit", function(DataikuAPI, $stateParams, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/edit/edit-folder.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            $scope.behaviors = [
                                   {name:'GO_TO_FOLDER',  label:'Go to folder settings'},
                                   {name:'INLINE_BROWSE', label:'Browse folder location'},
                                   {name:'MODAL_BROWSE', label:'Modal to browse folder location'}
                               ];
                               
            DataikuAPI.managedfolder.list($stateParams.projectKey).success(function(data) {
                $scope.folders = data;
            }).error(setErrorInScope.bind($scope));
            
            let init = function() {
                if (!$scope.tile.behavior) {
                    $scope.tile.behavior = 'GO_TO_FOLDER'; // the default
                }
            };
            if ($scope.tile) {
                init();
            } else {
                let deregister = $scope.$watch('tile', function() {
                    if ($scope.tile) {
                        init();
                        deregister();
                    } 
                });
            }
        }
    }
});

app.directive("editFolderAppTileView", function(DataikuAPI, $state, $stateParams, MonoFuture, CreateModalFromTemplate, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/view/edit-folder.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            $scope.uiState = {};
            let fetchFolder = function() {
                DataikuAPI.managedfolder.get($stateParams.projectKey, $stateParams.projectKey, $scope.tile.folderId).success(function(data){
                    $scope.folder = data;
                }).error(setErrorInScope.bind($scope));
            };

            $scope.browse = function (path) {
                if (path == null) path = '';
                var configAnchoredAtRoot = angular.copy($scope.folder.params);
                // We discard stuff to have a shorter serialized version of our folder
                configAnchoredAtRoot.path = '';

                WT1.event('app-tile-folder-browse')

                // Ugly workaround. Angular 1.2 unwraps promises (don't understand why)
                // Except if the promise object has a $$v.
                // See https://github.com/angular/angular.js/commit/3a65822023119b71deab5e298c7ef2de204caa13
                // and https://github.com/angular-ui/bootstrap/issues/949
                var promise = DataikuAPI.fsproviders.browse($scope.folder.type, configAnchoredAtRoot, $stateParams.projectKey, {odbId:$scope.tile.folderId}, path);
                promise.$$v = promise;
                return promise;
            };
            
            $scope.doTest = function() {
                WT1.event('app-tile-folder-save')
                DataikuAPI.managedfolder.save($scope.folder).success(function(data) {
                    fetchFolder();
                }).error(setErrorInScope.bind($scope));
            };
            
            $scope.openModal = function() {
                WT1.event('app-tile-folder-modal')
                CreateModalFromTemplate("/templates/apps/tiles/view/edit-folder-modal.html", $scope, null, function(modalScope) {
                    modalScope.goToFolder = function() {
                        modalScope.dismiss();
                        $state.go('projects.project.managedfolders.managedfolder.settings', { odbId: $scope.tile.folderId});
                    };
                    modalScope.commit = function() {
                        $scope.doTest();
                        modalScope.dismiss();
                    };
                });
            };
        
            let init = function() {
                fetchFolder();
            };
            if ($scope.tile) {
                init();
            } else {
                let deregister = $scope.$watch('tile', function() {
                    if ($scope.tile) {
                        init();
                        deregister();
                    } 
                });
            }
        
        }
    }
});

app.directive("editSqlDatasetAppTileEdit", function(DataikuAPI, $stateParams, DatasetUtils, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/edit/edit-sql-dataset.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            $scope.behaviors = [
                                   {name:'GO_TO_DATASET',                    label:'Go to dataset settings'},
                                   {name:'INLINE_BROWSE_ONLY',               label:'Only browse table'},
                                   {name:'INLINE_BROWSE_AND_INFER',          label:'Browse table and automatically redetect schema'},
                                   {name:'MODAL_BROWSE_AND_INFER',           label:'Modal to browse table and automatically redetect schema'}
                               ];
                               
            DataikuAPI.datasets.listHeaders($stateParams.projectKey).success(function(data) {
                $scope.datasets = data.filter(function(x) {return DatasetUtils.isSQLTable(x) && !x.managed;});
            }).error(setErrorInScope.bind($scope));
            
            let init = function() {
                if (!$scope.tile.behavior) {
                    $scope.tile.behavior = 'GO_TO_DATASET'; // the default
                }
            };
            if ($scope.tile) {
                init();
            } else {
                let deregister = $scope.$watch('tile', function() {
                    if ($scope.tile) {
                        init();
                        deregister();
                    } 
                });
            }
        }
    }
});

app.directive("editSqlDatasetAppTileView", function(DataikuAPI, $state, $stateParams, FutureWatcher, CreateModalFromTemplate, WT1, Logger, $q) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/view/edit-sql-dataset.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            $scope.uiState = {fetching:false};

            let fetchDataset = function() {
                DataikuAPI.datasets.get($stateParams.projectKey, $scope.tile.datasetName, $stateParams.projectKey).success(function(data){
                    $scope.dataset = data;
                }).error(setErrorInScope.bind($scope));
            };
        
            $scope.uiState.tableList = null;
            $scope.uiState.schemaList = null;
            $scope.fetchTableList = function() {
                WT1.event('app-tile-sql-dataset-fetch-tables', {type:$scope.dataset.type})
                $scope.uiState.fetching = true;
                if ($scope.dataset.type == 'hiveserver2') {
                    DataikuAPI.connections.listHiveMassImportTables($scope.dataset.params.connection, $stateParams.projectKey).success(function(data) {
                        if (data.hasResult) {
                            $scope.uiState.fetching = false;
                            $scope.uiState.tableList = data.result.tables;
                        } else {
                            FutureWatcher.watchJobId(data.jobId)
                                .success(function(data) {
                                    $scope.uiState.fetching = false;
                                    $scope.uiState.tableList = data.result.tables;
                                }).update(function(data) {
                                    $scope.uiState.fetching = true;
                                }).error(function(a, b, c) {
                                    $scope.uiState.fetching = false;
                                    setErrorInScope.bind($scope)(a, b, c);    
                                });
                        }
                    }).error(function(a, b, c) {
                        $scope.uiState.fetching = false;
                        setErrorInScope.bind($scope)(a, b, c);    
                    });
                } else {
                    DataikuAPI.connections.listSQLMassImportTables($scope.dataset.params.connection, $scope.dataset.params.catalog, $scope.dataset.params.schema, $stateParams.projectKey).success(function(data) {
                        if (data.hasResult) {
                            $scope.uiState.fetching = false;
                            $scope.uiState.tableList = data.result.tables;
                        } else {
                            FutureWatcher.watchJobId(data.jobId)
                                .success(function(data) {
                                    $scope.uiState.fetching = false;
                                    $scope.uiState.tableList = data.result.tables;
                                }).update(function(data) {
                                    $scope.uiState.fetching = true;
                                }).error(function(a, b, c) {
                                    $scope.uiState.fetching = false;
                                    setErrorInScope.bind($scope)(a, b, c);    
                                });
                        }
                    }).error(function(a, b, c) {
                        $scope.uiState.fetching = false;
                        setErrorInScope.bind($scope)(a, b, c);    
                    });
                }
            };
            $scope.fetchSchemaList = function() {
                WT1.event('app-tile-sql-dataset-fetch-schemas')
                if ($scope.dataset.type == 'hiveserver2') {
                    DataikuAPI.connections.getHiveNames($stateParams.projectKey).success(function(data) {
                        $scope.uiState.schemaList = data;
                    }).error(function(a, b, c) {
                        setErrorInScope.bind($scope)(a, b, c);    
                    });
                } else {
                    DataikuAPI.connections.listSQLMassImportSchemas($scope.dataset.params.connection, $stateParams.projectKey).success(function(data) {
                        $scope.uiState.schemaList = data;
                    }).error(function(a, b, c) {
                        setErrorInScope.bind($scope)(a, b, c);    
                    });
                }
            };
                    
            $scope.doTest = function(dataset) {
                var deferred = $q.defer();
                let doInfer = $scope.tile.behavior.indexOf('INFER') >= 0;
                WT1.event('app-tile-sql-dataset-test', {infer:doInfer})
                if (doInfer) {
                    DataikuAPI.datasets.externalSQL.test($stateParams.projectKey, dataset, 10, false, true).success(function(data) {
                        $scope.detectionResults = data;
                        if (data.connectionOK) {
                            dataset.schema = data.schemaDetection.detectedSchema;
                            deferred.resolve('done inference');
                        } else {
                            deferred.reject('failed inference');
                        }
                    }).error(function (data, status, headers) {
                        setErrorInScope.bind($scope)(data, status, headers);
                        deferred.reject('failed test');
                    });
                } else {
                    deferred.resolve('no inference');
                }
                return deferred.promise;
            };
            $scope.doTestAndCommit = function(dataset) {
                $scope.doTest(dataset).then(function() {
                    DataikuAPI.datasets.save($stateParams.projectKey, dataset, {}).success(function(data) {
                        fetchDataset();
                    }).error(setErrorInScope.bind($scope));
                }, function(msg) {
                    Logger.error("Not saving dataset, " + msg);
                });
            };
            
            $scope.openModal = function() {
                WT1.event('app-tile-sql-dataset-modal')
                CreateModalFromTemplate("/templates/apps/tiles/view/edit-sql-dataset-modal.html", $scope, null, function(modalScope) {
                    modalScope.dataset = angular.copy($scope.dataset);
                    
                    modalScope.goToDataset = function() {
                        modalScope.dismiss();
                        $state.go('projects.project.datasets.dataset.settings', {datasetName : $scope.tile.datasetName});
                    };
                    modalScope.commit = function() {
                        $scope.dataset = modalScope.dataset;
                        modalScope.dismiss();
                    };
                    
                    modalScope.doTestNow = function() {
                        $scope.doTest(modalScope.dataset);
                    };
                    modalScope.doTestIfNeeded = function() {
                        if ($scope.uiState.autoTestOnTableSelection) {
                            $scope.doTest(modalScope.dataset);
                        }
                    };
                    
                    modalScope.$watch('dataset.params.table', modalScope.doTestIfNeeded);
                    modalScope.$watch('dataset.params.schema', modalScope.doTestIfNeeded);
                });
            };
            
            
            let init = function() {
                fetchDataset();
                $scope.$watch("dataset.params.table", function(nv, ov) {
                    if (ov && nv && ov != nv) {
                        $scope.doTestAndCommit($scope.dataset);
                    }
                });
            };
            if ($scope.tile) {
                init();
            } else {
                let deregister = $scope.$watch('tile', function() {
                    if ($scope.tile) {
                        init();
                        deregister();
                    } 
                });
            }
        }
    }
});

app.directive("dashboardLinkAppTileEdit", function(DataikuAPI, $stateParams, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/edit/dashboard-link.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            DataikuAPI.dashboards.listHeads($stateParams.projectKey, {}).success(function(data) {
                $scope.dashboards = data.items;
            }).error(setErrorInScope.bind($scope));
        }
    }
});

app.directive("dashboardLinkAppTileView", function(DataikuAPI, $stateParams, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/view/dashboard-link.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            $scope.dashboard = null;
            $scope.$watch('tile.dashboardId', function() {
                if ($scope.dashboard == null && $scope.tile && $scope.tile.dashboardId) {
                    DataikuAPI.dashboards.get($stateParams.projectKey, $scope.tile.dashboardId).success(function(data) {
                        $scope.dashboard = data;
                    }).error(setErrorInScope.bind($scope));
                }
            });
        }
    }
});

app.directive("runScenarioAppTileEdit", function(DataikuAPI, $stateParams, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/edit/run-scenario.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            DataikuAPI.scenarios.listAccessible().success(function(data) {
                $scope.scenarios = data.filter(function(s) {return s.projectKey == $stateParams.projectKey;});
            }).error(setErrorInScope.bind($scope));
        }
    }
});

app.directive("runScenarioAppTileView", function(DataikuAPI, $stateParams, $state, Notification, FutureWatcher, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/view/run-scenario.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            $scope.uiState = {};
            
            $scope.runNow = function() {
                WT1.event('app-tile-scenario-run')
                $scope.uiState.running = false; // start from a clean state. You shouldn't be able to arrive here if $scope.uiState.running = true
                // run and send to scenario's "last runs" tab
                DataikuAPI.scenarios.manualRun($stateParams.projectKey, $scope.tile.scenarioId, {}, true, true).success(function(data) {
                    if (data.hasResult) {
                        $scope.uiState.running = false;
                        $scope.uiState.lastRun = data.result.scenarioRun;
                    } else {
                        FutureWatcher.watchJobId(data.jobId)
                            .success(function(data) {
                                $scope.uiState.running = false;
                                $scope.uiState.lastRun = data.result.scenarioRun;
                            }).update(function(data) {
                                $scope.uiState.running = true;
                                $scope.uiState.lastRun = data.scenarioRun;
                            }).error(function(a, b, c) {
                                $scope.uiState.running = false;
                                setErrorInScope.bind($scope)(a, b, c);    
                            });
                    }
                }).error(setErrorInScope.bind($scope));
            };
            
            $scope.goToCurrentRun = function() {
                WT1.event('app-tile-scenario-current-run')
                $state.go('projects.project.scenarios.scenario.runs.list', {projectKey : $stateParams.projectKey, scenarioId : $scope.tile.scenarioId});
            };
            $scope.goToLastRun = function() {
                WT1.event('app-tile-scenario-last-run')
                $state.go('projects.project.scenarios.scenario.runs.list.run', {projectKey : $stateParams.projectKey, scenarioId : $scope.tile.scenarioId, runId : $scope.uiState.lastRun.runId});
            };
            
            // get the current state (running or not) to show the 
            DataikuAPI.scenarios.getLastScenarioRuns($stateParams.projectKey, $scope.tile.scenarioId, true, 1).success(function(data) {
                $scope.uiState.lastRun = data.length > 0 ? data[0] : null;
                $scope.uiState.running = $scope.uiState.lastRun && $scope.uiState.lastRun.futureId != null;
                if ($scope.uiState.running) {
                    // wait for the notif
                    var unRegister = Notification.registerEvent("scenario-state-change", function(evt, message) {
                        if (message.scenarioId != $scope.tile.scenarioId || message.projectKey != $stateParams.projectKey) return;
                        $scope.uiState.running = message.state == 'RUNNING';
                    });
                    $scope.$on("$destroy", unRegister);
                }
            }).error(setErrorInScope.bind($scope)).noSpinner();
        }
    }
});

app.directive("editProjectVariablesAppTileEdit", function(CodeMirrorSettingService) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/edit/edit-project-variables.html',
        scope: {
            tile : '=',
            noBehavior: '='
        },
        link : function($scope, element, attrs) {
            $scope.codeMirrorSettingService = CodeMirrorSettingService;
            $scope.behaviors = [
                                   {name:'MODAL',                label:'Open modal to edit'},
                                   {name:'INLINE_EXPLICIT_SAVE', label:'Edit inline with explicit save'},
                                   {name:'INLINE_AUTO_SAVE',     label:'Edit inline with auto-save'}
                               ];
            $scope.hasCustomUI = function(tile) {
                if (tile.$useCustomUI !== undefined) return tile.$useCustomUI;
                return tile.html || tile.js || tile.python;
            };
            $scope.useCustomUI = function(tile) {
                tile.$useCustomUI = true;
            };
            $scope.dontUseCustomUI = function(tile) {
                tile.$useCustomUI = false;
                tile.html = null;
                tile.js = null;
                tile.python = null;
            };
            
            let init = function() {
                if (!$scope.tile.behavior) {
                    $scope.tile.behavior = 'MODAL'; // the default
                }
                if (!$scope.tile.params) {
                    $scope.tile.params = [
                                             {name:"variable1", label:"nice label in the form", type:"STRING", description:"Help text for the variable"},
                                             {name:"variable2", label:"another label", type:"INT"},
                                             {name:"variable3", label:"some selector", type:"SELECT", selectChoices:[{value:"val1", label:"First"}, {value:"val2", label:"Second"}]}
                                         ];
                }
            };
            if ($scope.tile) {
                init();
            } else {
                let deregister = $scope.$watch('tile', function() {
                    if ($scope.tile) {
                        init();
                        deregister();
                    } 
                });
            }
            
        }
    }
});

app.directive("editProjectVariablesAppTileView", function(DataikuAPI, $stateParams, Debounce, $q, $templateCache, CreateModalFromTemplate, PluginConfigUtils, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/view/edit-project-variables.html',
        scope: {
            tile : '=',
            sharedConfig: '=',
            columnsPerInputRole: '=', // passed in app-as-recipe forms
            recipeConfig: '=' // passed in app-as-recipe forms
        },
        link : function($scope, element, attrs) {
            $scope.uiState = {isCustom:null, standardVariables:null, localVariables:null, pluginId:null, componentId:null, sessionId:null};
            if ($scope.recipeConfig && $scope.recipeConfig.type) {
                // form in an app-as-recipe instance
                $scope.uiState['pluginId'] = '__dku_app_as_recipe_tile_' + $scope.recipeConfig.type.substring(4); // trim the "App_" prefix
            } else {
                // form in an app instance
                $scope.uiState['pluginId'] = '__dku_app_tile_' + $stateParams.projectKey;
            }
            $scope.config = null;
            
            let doInit = function() {
                if ($scope.tile == null || $scope.sharedConfig == null) return;
                
                PluginConfigUtils.setDefaultValues($scope.tile.params, $scope.sharedConfig);
                /* In addition to default values, set properly the columns stuff */
                $scope.tile.params.forEach(function(param) {
                    if ($scope.sharedConfig[param.name] === undefined) {
                        if ( param.type == "COLUMNS" ) {
                            // the dku-list-typeahead expects something not null
                            $scope.sharedConfig[param.name] = [];
                        }
                    }
                    if (param.columnRole != null) {
                        $scope.columnsPerInputRole[param.columnRole] = [];
                    }
                });
                
                $scope.uiState.isCustom = $scope.tile.html != null && $scope.tile.html.trim().length > 0;
                // let's abuse the componentId, but not send the entire tile (otherwise you'd be able to do remote python exec)
                if ($scope.recipeConfig && $scope.recipeConfig.type) {
                    $scope.uiState.componentId = JSON.stringify({});
                } else {
                    $scope.uiState.componentId = JSON.stringify({section:$scope.tile.$sectionIdx, tile:$scope.tile.$tileIdx});
                }
                if ($scope.tile.js) {
                    eval($scope.tile.js);
                    if ($scope.tile.module) {
                        app.registerModule($scope.tile.module);
                    }
                }
                if ($scope.tile.html) {
                    $scope.uiState.templateKey = 'app_tile_template_' + $stateParams.projectKey + '_' + $scope.tile.$sectionIdx + '_' + $scope.tile.$tileIdx + '.html';
                    $templateCache.put($scope.uiState.templateKey, $scope.tile.html);
                }
                
                if ($scope.tile.behavior == 'INLINE_EXPLICIT_SAVE') {
                    // edit a separate object, that is commited when the save button is clicked
                    $scope.config = angular.copy($scope.sharedConfig);
                    $scope.originalConfig = angular.copy($scope.sharedConfig);
                } else {
                    $scope.config = $scope.sharedConfig;
                }
            };
            
            if ($scope.tile == null || $scope.sharedConfig == null) {
                $scope.deregisterInit = $scope.$watch("[tile,sharedConfig]", function() {
                    if ($scope.tile == null || $scope.sharedConfig == null) return;
                    
                    doInit();
                    
                    if ($scope.deregisterInit) {
                        $scope.deregisterInit();
                    }
                }, true);
            } else {
                doInit();
            }

            // commiting for the 'explicit save' behavior                    
            $scope.save = function() {
                WT1.event('app-tile-project-variables-save')
                if ($scope.tile.behavior == 'INLINE_EXPLICIT_SAVE') {
                    // only copy what has changed w.r.t. the beginning of the edition (ie only the params that this tile touches)
                    let oldKeys = Object.keys($scope.originalConfig);
                    let newKeys = Object.keys($scope.config);
                    let deleted = oldKeys.filter(k => newKeys.indexOf(k) < 0)
                    let updated = oldKeys.filter(k => newKeys.indexOf(k) >= 0 && !angular.equals($scope.originalConfig[k], $scope.config[k]))
                    let created = newKeys.filter(k => oldKeys.indexOf(k) < 0)
                    deleted.forEach(k => delete $scope.sharedConfig[k]);
                    created.forEach(k => $scope.sharedConfig[k] = angular.copy($scope.config[k]));
                    updated.forEach(k => $scope.sharedConfig[k] = angular.copy($scope.config[k]));
                }
            };
            
            /*****
             * python callback
             *****/
            // This function is called when fetching data for custom forms.
            // See in the documentation: Fetching data for custom forms.
            // the pluginId and componentId are "fakes" that the backend redirects to the appropriate tile
            $scope.callPythonDo = function(payload) {
                var deferred = $q.defer();
                DataikuAPI.plugins.callPythonDo($scope.uiState.sessionId, $scope.uiState.pluginId, $scope.uiState.componentId, $scope.config, payload, $scope.recipeConfig, $stateParams.projectKey, null).success(function(data) {
                    $scope.uiState.sessionId = data.sessionId;
                    deferred.resolve(data.data);
                }).error(function(a, b, c) {
                    setErrorInScope.bind($scope)(a,b,c);
                    deferred.reject("Failed to get test result for ui");
                });
                return deferred.promise;
            };
            
            /*****
             * for edition in a modal
             *****/
             $scope.openVariableEditor = function() {
                WT1.event('app-tile-project-variables-modal')
                CreateModalFromTemplate("/templates/apps/tiles/view/edit-project-variables-modal.html", $scope, null, function(modalScope) {
                    modalScope.tile = $scope.tile;
                    modalScope.uiState = $scope.uiState;
                    modalScope.config = angular.copy($scope.config);
                    modalScope.commit = function() {
                        angular.copy(modalScope.config, $scope.config); // deepcopy in place :D
                        modalScope.dismiss();
                    };
                });
             };
        }
    }
});

app.directive("propagateSchemaAppTileEdit", function(DataikuAPI, $stateParams, CodeMirrorSettingService) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/edit/propagate-schema.html',
        scope: {
            tile: '=',
            behaviors: '=?'
        },
        link : function($scope, element, attrs) {
            if (!$scope.behaviors) {
                $scope.behaviors = [
                    {name:'MANUAL',           label:'Run manually'},
                    {name:'AUTO_NO_BUILD',    label:'Run automatically unless building is needed'},
                    {name:'AUTO_WITH_BUILDS', label:'Run fully automatically'}
                ];
            }

            $scope.codeMirrorSettingService = CodeMirrorSettingService;
            let init = function() {
                if (!$scope.tile.behavior) {
                    $scope.tile.behavior = $scope.behaviors[0].name; // the default
                }
                if (!$scope.tile.recipeUpdateOptions) {
                    $scope.tile.recipeUpdateOptions = {};
                }
                if (!$scope.tile.partitionByDim) {
                    $scope.tile.partitionByDim = [];
                }
                if (!$scope.tile.partitionByComputable) {
                    $scope.tile.partitionByComputable = [];
                }
            };
            if ($scope.tile) {
                init();
            } else {
                let deregister = $scope.$watch('tile', function() {
                    if ($scope.tile) {
                        init();
                        deregister();
                    } 
                });
            }
            
        }
    }
});

app.directive("propagateSchemaAppTileView", function(DataikuAPI, $stateParams, $state, FutureProgressModal, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/view/propagate-schema.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            $scope.uiState = {runningId:null};
            $scope.startNow = function() {
                WT1.event('app-tile-propagate-schema', {behavior:$scope.tile.behavior})
                if ($scope.tile.behavior == 'MANUAL') {
                    if ($scope.uiState.runningId) {
                        DataikuAPI.flow.tools.setActive($stateParams.projectKey, $scope.uiState.runningId).success(function(data) {
                            $state.go("projects.project.flow");
                        }).error(setErrorInScope.bind($scope));
                    } else {
                        DataikuAPI.flow.tools.start($stateParams.projectKey, 'PROPAGATE_SCHEMA', {projectKey:$stateParams.projectKey, datasetName:$scope.tile.datasetName, recipeUpdateOptions:$scope.tile.recipeUpdateOptions, excludedRecipes:$scope.tile.excludedRecipes}).success(function(data) {
                            $state.go("projects.project.flow");
                        }).error(setErrorInScope.bind($scope));
                    }
                    DataikuAPI.flow.tools.getSessions($stateParams.projectKey).success(function(data) {
                        angular.forEach(data.active, function(tool, toolId) {
                            if (tool.type == 'PROPAGATE_SCHEMA') {
                                $scope.uiState.runningId = toolId;
                            }
                        });
                    }).error(setErrorInScope.bind($scope));
                } else {
                    DataikuAPI.flow.tools.propagateSchema.runAutomatically($stateParams.projectKey, $scope.tile.datasetName, $scope.tile.behavior == 'AUTO_WITH_BUILDS', $scope.tile.recipeUpdateOptions, $scope.tile.excludedRecipes, $scope.tile.partitionByDim, $scope.tile.partitionByComputable, $scope.tile.markAsOkRecipes).success(function(data) {
                        FutureProgressModal.show($scope, data, "Propagate schema").then(function(data) {
                            console.log("done ok", data);
                        }, function(data) {
                            console.log("done ko", data);
                            setErrorInScope.bind($scope)(data);
                        });
                    }).error(setErrorInScope.bind($scope));
                }
            };
        }
    }
});

app.directive("downloadDatasetAppTileEdit", function(DataikuAPI, $stateParams, ExportService, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/edit/download-dataset.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            DataikuAPI.datasets.listHeaders($stateParams.projectKey).success(function(data) {
                $scope.datasets = data;
            }).error(setErrorInScope.bind($scope));
            
            let setExportParams = function(params) {
                $scope.tile.exportParams = params;
            }
            ExportService.initExportBehavior($scope, {}, {advancedSampling : true, partitionListLoader: null}, $scope.tile, null, $scope.tile.exportParams, setExportParams);
        }
    }
});

app.directive("downloadDatasetAppTileView", function(DataikuAPI, $stateParams, ExportUtils, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/view/download-dataset.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            $scope.downloadNow = function() {
                WT1.event('app-tile-download-dataset')
                DataikuAPI.datasets.exportDS($stateParams.projectKey, $stateParams.projectKey, $scope.tile.datasetName, $scope.tile.exportParams).success(function(data) {
                    ExportUtils.defaultHandleExportResult($scope, $scope.tile.exportParams, data);
                }).error(setErrorInScope.bind($scope));
            };
        }
    }
});

app.directive("downloadDashboardAppTileEdit", function(DataikuAPI, $stateParams, GRAPHIC_EXPORT_OPTIONS, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/edit/download-dashboard.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs, formCtrl) {
            $scope.exportFormController = formCtrl;
            // Utilities that give us all the choices possible
            $scope.paperSizeMap = GRAPHIC_EXPORT_OPTIONS.paperSizeMap;
            $scope.orientationMap = GRAPHIC_EXPORT_OPTIONS.orientationMap;
            $scope.fileTypes = GRAPHIC_EXPORT_OPTIONS.fileTypes;
        
            DataikuAPI.dashboards.listHeads($stateParams.projectKey, {}).success(function(data) {
                $scope.dashboards = data.items;
            }).error(setErrorInScope.bind($scope));
            
            $scope.$watch("tile", function() {
                if ($scope.tile && !$scope.tile.format) {
                    $scope.tile.format = {fileType:'PDF', paperSize:'A4', orientation:'LANDSCAPE'};
                }
            });
        }
    }
});

app.directive("downloadDashboardAppTileView", function(DataikuAPI, $stateParams, FutureProgressModal, ActivityIndicator, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/view/download-dashboard.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            $scope.uiState = {};
            $scope.downloadNow = function() {
                WT1.event('app-tile-download-dashboard')
                let exported = {dashboardId:$scope.tile.dashboardId};
                DataikuAPI.dashboards.export($stateParams.projectKey, $scope.tile.format, [exported]).success(function (data) {
                    $scope.uiState.running = true;
                    
                    FutureProgressModal.show($scope, data, "Export dashboard").then(function (result) {
                        $scope.uiState.running = false;
                        if (result) { // undefined in case of abort
                            downloadURL(DataikuAPI.dashboards.getExportURL(result.projectKey, result.exportId));
                            ActivityIndicator.success("Dashboard export downloaded!", 5000);
                        } else {
                            ActivityIndicator.error("Export dashboard failed", 5000);
                        }
                    }).finally(function() {
                        $scope.uiState.running = false;
                    });
                }).error(setErrorInScope.bind($scope));
            };
        }
    }
});

app.directive("downloadFolderAppTileEdit", function(DataikuAPI, $stateParams, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/edit/download-folder.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            DataikuAPI.managedfolder.list($stateParams.projectKey).success(function(data) {
                $scope.folders = data;
            }).error(setErrorInScope.bind($scope));
        }
    }
});

app.directive("downloadFolderAppTileView", function(DataikuAPI, $stateParams, ExportUtils, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/view/download-folder.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            $scope.downloadNow = function() {
                WT1.event('app-tile-download-folder', {full:!$scope.tile.itemPath})
                if ($scope.tile.itemPath) {
                    DataikuAPI.managedfolder.getItemInfo($stateParams.projectKey, $scope.tile.folderId, $scope.tile.itemPath).success(function(data) {
                        if (data.isDirectory) {
                            downloadURL(DataikuAPI.managedfolder.getDownloadFolderURL($stateParams.projectKey, $stateParams.projectKey, $scope.tile.folderId, $scope.tile.itemPath));
                        } else {
                            downloadURL(DataikuAPI.managedfolder.getDownloadItemURL($stateParams.projectKey, $stateParams.projectKey, $scope.tile.folderId, $scope.tile.itemPath));
                        }
                    }).error(setErrorInScope.bind($scope));
                } else {
                    downloadURL(DataikuAPI.managedfolder.getDownloadFolderURL($stateParams.projectKey, $stateParams.projectKey, $scope.tile.folderId, '/'));
                }
            };
        }
    }
});

app.directive("downloadReportAppTileEdit", function(DataikuAPI, $stateParams, RMARKDOWN_ALL_OUTPUT_FORMATS, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/edit/download-report.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            $scope.formats = RMARKDOWN_ALL_OUTPUT_FORMATS;
        
            DataikuAPI.reports.listHeads($stateParams.projectKey, {}).success(function(data) {
                $scope.reports = data.items;
            }).error(setErrorInScope.bind($scope));
        }
    }
});

app.directive("downloadReportAppTileView", function(DataikuAPI, $stateParams, FutureProgressModal, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/view/download-report.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            $scope.uiState = {};
            $scope.downloadNow = function() {
                WT1.event('app-tile-download-report')
                DataikuAPI.reports.prepareDownload($stateParams.projectKey, $scope.tile.reportId, $scope.tile.format).success(function(initialResponse) {
                    $scope.uiState.running = true;
                    
                    FutureProgressModal.show($scope, initialResponse, "Preparing download").then(function(result) {
                        $scope.uiState.running = false;
                        downloadURL(DataikuAPI.reports.getDownloadReportURL($stateParams.projectKey, $scope.tile.reportId, $scope.tile.format));
                    }).finally(function() {
                        $scope.uiState.running = false;
                    });
                }).error(setErrorInScope.bind($scope));
            };
        }
    }
});

app.directive("folderLinkAppTileEdit", function(DataikuAPI, $stateParams, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/edit/folder-link.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            DataikuAPI.managedfolder.list($stateParams.projectKey).success(function(data) {
                $scope.folders = data;
            }).error(setErrorInScope.bind($scope));
        }
    }
});

app.directive("folderLinkAppTileView", function(DataikuAPI, $stateParams, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/view/folder-link.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            $scope.folder = null;
            $scope.$watch('tile.folderId', function() {
                if ($scope.folder == null && $scope.tile && $scope.tile.folderId) {
                    DataikuAPI.managedfolder.get($stateParams.projectKey, $stateParams.projectKey, $scope.tile.folderId).success(function(data) {
                        $scope.folder = data;
                    }).error(setErrorInScope.bind($scope));
                }
            });
        }
    }
});

app.directive("variableDisplayAppTileEdit", function(CodeMirrorSettingService) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/edit/variable-display.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            $scope.codeMirrorSettingService = CodeMirrorSettingService;
        }
    }
});

app.directive("variableDisplayAppTileView", function(DataikuAPI, $stateParams, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/view/variable-display.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            $scope.uiState = {};
            
            let init = function() {
                DataikuAPI.variables.expandExpr($stateParams.projectKey, $scope.tile.content || '').success(function(data) {
                    $scope.uiState.expanded = data.id;
                }).error(setErrorInScope.bind($scope));
            };
            if ($scope.tile) {
                init();
            } else {
                let deregister = $scope.$watch('tile', function() {
                    if ($scope.tile) {
                        init();
                        deregister();
                    } 
                });
            }
        }
    }
});

app.directive("guessTrainDeployAppTileEdit", function(DataikuAPI, $stateParams, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/edit/guess-train-deploy.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            DataikuAPI.savedmodels.list($stateParams.projectKey).success(function(data) {
                $scope.models = data.filter(function(m) {return m.projectKey == $stateParams.projectKey;});
            }).error(setErrorInScope.bind($scope));
        }
    }
});

app.directive("guessTrainDeployAppTileView", function(DataikuAPI, $stateParams, $state, Notification, FutureProgressModal, WT1) {
    return {
        restrict: 'A',
        templateUrl : '/templates/apps/tiles/view/guess-train-deploy.html',
        scope: {
            tile : '='
        },
        link : function($scope, element, attrs) {
            $scope.uiState = {};
            
            $scope.runNow = function() {
                WT1.event('app-tile-guess-train-deploy')
                DataikuAPI.savedmodels.guessTrainDeploy($stateParams.projectKey, $scope.tile.modelId).success(function(data) {
                    FutureProgressModal.show($scope, data, "Guess, train and redeploy");
                }).error(setErrorInScope.bind($scope));
            };
            
            $scope.model = null;
            $scope.$watch('tile.modelId', function() {
                if ($scope.model == null && $scope.tile && $scope.tile.modelId) {
                DataikuAPI.savedmodels.get($stateParams.projectKey, $scope.tile.modelId).success(function(data) {
                    $scope.model = data;
                }).error(setErrorInScope.bind($scope));
                }
            });
            
        }
    }
});


}()); 
(function () {
'use strict';

var app = angular.module('dataiku.projects.actions');


app.service('DatasetConnectionChangeService', function($rootScope, $q, $stateParams, CreateModalFromTemplate, DataikuAPI, TaggableObjectsCapabilities, TaggableObjectsUtils) {
    this.start = function(allSelectedObjects) {

        return CreateModalFromTemplate("/templates/datasets/change-connection-modal.html", $rootScope, null, function(modalScope) {
            modalScope.selectedObjects = allSelectedObjects.filter(TaggableObjectsCapabilities.canChangeConnection);
            modalScope.commonTaggableType = TaggableObjectsUtils.getCommonType(modalScope.selectedObjects, it => it.type);
            modalScope.options = {
                useExistingParams: false,
                specificSettings: {}
            };

            DataikuAPI.flow.refactoring.startChangeConnections($stateParams.projectKey, modalScope.selectedObjects).success(function(data) {
                modalScope.connections = data.connections.filter(c => c.usable); //TODO @flow, display unsable connections with reason

                modalScope.connectionsMap = {};
                modalScope.connections.forEach(function(c) {
                    modalScope.connectionsMap[c.name] = c;
                });

                modalScope.messages = data.messages;
            }).error(function(...args) {
                modalScope.fatalError = true;
                setErrorInScope.apply(modalScope, args);
            });


            modalScope.test = function() {
                delete modalScope.messages;
                resetErrorInScope(modalScope);
                const deferred = $q.defer();
                DataikuAPI.flow.refactoring.testChangeConnections($stateParams.projectKey, modalScope.selectedObjects, modalScope.options).success(function(data) {
                    modalScope.messages = data;
                    if (data.anyMessage) {
                        deferred.reject();
                    } else {
                        deferred.resolve(data)
                    }
                }).error(setErrorInScope.bind(modalScope));
                return deferred.promise;
            };

            modalScope.ok = function(force) {
                if (force) {
                    performChange();
                } else {
                    modalScope.test().then(performChange);
                }
            };

            modalScope.preselectFormatIfOnlyOne = function() {
                const formats = modalScope.connectionsMap[modalScope.options.connection].formats;
                if (formats && formats.length == 1) {
                    modalScope.options.formatOptionId = formats[0].id;
                }
            }

            function performChange() {
                DataikuAPI.flow.refactoring.changeConnections($stateParams.projectKey, modalScope.selectedObjects, modalScope.options).success(function(data) {
                    modalScope.resolveModal();
                }).error(setErrorInScope.bind(modalScope));
            }
        });
    };
});


app.service('SubFlowCopyService', function($rootScope, $q, $state, $stateParams, CreateModalFromTemplate, DataikuAPI, TaggingService, LoggerProvider, $compile, $timeout, $interpolate, PromiseService) {
    var logger = LoggerProvider.getLogger('refactoring');

	this.start = function(selectedObjects, itemsByZone) {

		CreateModalFromTemplate("/templates/projects/subflow-copy-modal.html", $rootScope, null, function(modalScope) {
            modalScope.selectedObjects = [...selectedObjects];
            modalScope.projectTags = Object.keys({ ...TaggingService.getProjectTags(), ...TaggingService.getGlobalTags() });
            modalScope.options = {
                targetMode: 'CURRENT_PROJECT',
                targetProjectKey: '',
                targetProjectFolderId: '',
                datasetNames: {},
                streamingEndpointNames: {}
            };

            modalScope.dataCanBeCopiedElements = selectedObjects.filter(el =>
                (el.type === 'MANAGED_FOLDER' && el.smType === 'Filesystem') ||
                (el.type === 'DATASET' && ['Inline', 'UploadedFiles'].includes(el.smType)) ||
                el.type === 'SAVED_MODEL' ||
                el.type === 'MODEL_EVALUATION_STORE'
            );

            var copyDataTooltipHtml = `<div>
                            <span>Data will be copied for {{dataCanBeCopiedElements.length > 1? 'these elements:' : 'this element:'}} </span>
                            <ul><li ng-repeat="el in dataCanBeCopiedElements"><i class="{{el.type|typeToIcon}}" /> {{el.displayName}}</li></ul>
                            <div class="help-inline">
                                <span>Copying data is supported for:</span>
                                <ul>
                                    <li>Editable and uploaded datasets</li>
                                    <li>Local filesystem folders</li>
                                    <li>Saved models</li>
                                </ul>
                            </div>

                        </div>  `;

            var el = angular.element(copyDataTooltipHtml);
            $compile(el)(modalScope);

            $timeout(function() {
                modalScope.copyDataTooltipHtml = el.html();
            });

            function reloadSelectionStats() {
                modalScope.hasAnyDataset = !!modalScope.selectedObjects.filter(to => to.type == 'DATASET').length;
                modalScope.hasAnyStreamingEndpoint = !!modalScope.selectedObjects.filter(to => to.type == 'STREAMING_ENDPOINT').length;
                modalScope.selectedZones = modalScope.selectedObjects.filter(to => to.type == 'FLOW_ZONE');
                modalScope.hasAnyZone = !!modalScope.selectedZones.length;
                modalScope.hasComputables = modalScope.hasAnyDataset || modalScope.hasAnyStreamingEndpoint;
            }

            function transmogrifyNames() {
                let projectKey;
                if (modalScope.options.targetMode == 'CURRENT_PROJECT') {
                    projectKey = $stateParams.projectKey;
                } else if (modalScope.options.targetMode == 'EXISTING_PROJECT') {
                    projectKey = modalScope.options.targetProjectKey;
                }
                if (!projectKey) {
                    return;
                }
                DataikuAPI.datasets.listNames(projectKey).success(function(existingNames) {
                    modalScope.options.datasetNames = {};
                    const usedNames = angular.copy(existingNames);

                    modalScope.selectedObjects.forEach(function(to) {
                        if (to.type != 'DATASET') {
                            return;
                        }
                        let newName = to.id;
                        if (!usedNames.includes(newName)) {
                            modalScope.options.datasetNames[to.id] = newName;
                            usedNames.push(newName);
                            return;
                        }
                        for (let i = 1; i < 100; i++) {
                            newName = to.id+'_'+i;
                            if (!usedNames.includes(newName)) {
                                modalScope.options.datasetNames[to.id] = newName;
                                usedNames.push(newName);
                                return;
                            }
                        }
                        logger.error("Failed to transmogrify "+to.id);
                    });
                });
                DataikuAPI.streamingEndpoints.listNames(projectKey).success(function(existingNames) {
                    modalScope.options.streamingEndpointNames = {};
                    const usedNames = angular.copy(existingNames);

                    modalScope.selectedObjects.forEach(function(to) {
                        if (to.type != 'STREAMING_ENDPOINT') {
                            return;
                        }
                        let newName = to.id;
                        if (!usedNames.includes(newName)) {
                            modalScope.options.streamingEndpointNames[to.id] = newName;
                            usedNames.push(newName);
                            return;
                        }
                        for (let i = 1; i < 100; i++) {
                            newName = to.id+'_'+i;
                            if (!usedNames.includes(newName)) {
                                modalScope.options.streamingEndpointNames[to.id] = newName;
                                usedNames.push(newName);
                                return;
                            }
                        }
                        logger.error("Failed to transmogrify "+to.id);
                    });
                });
            }
            transmogrifyNames();
            reloadSelectionStats()

            modalScope.$watch("options.targetMode", transmogrifyNames);
            modalScope.$watch("options.targetProjectKey", transmogrifyNames);

			DataikuAPI.projects.list().success(function (data) {
	            modalScope.projects = data;
	        });

            DataikuAPI.flow.refactoring.startCopySubFlow(selectedObjects).success(function(data) {
                modalScope.messages = data;
            }).error(function(...args) {
                modalScope.fatalError = true;
                setErrorInScope.apply(modalScope, args);
            });


            modalScope.test = function() {
                const deferred = $q.defer();
                delete modalScope.messages;
                resetErrorInScope(modalScope);
                DataikuAPI.flow.refactoring.testCopySubFlow(modalScope.selectedObjects, modalScope.options, $stateParams.projectKey).success(function(data) {
                    modalScope.messages = data;
                    if (data.anyMessage) {
                        deferred.reject();
                    } else {
                        deferred.resolve(data)
                    }
                }).error(setErrorInScope.bind(modalScope));
                return deferred.promise;
            };

            modalScope.ok = function(force) {
                if (force) {
                    performCopy();
                } else {
                    modalScope.test().then(performCopy);
                }
            };

            function performCopy() {
                DataikuAPI.flow.refactoring.copySubFlow(modalScope.selectedObjects, modalScope.options, $stateParams.projectKey).success(function(data) {
                    modalScope.resolveModal();
                    $rootScope.$emit('stopCurrentTool');

                    if (modalScope.options.targetMode != 'CURRENT_PROJECT' && modalScope.options.targetProjectKey != $stateParams.projectKey) {
                        $state.transitionTo("projects.project.flow", {projectKey: modalScope.options.targetProjectKey});
                    } else {
                        $rootScope.$emit('reloadGraph');
                    }
                }).error(setErrorInScope.bind(modalScope));
            }

            modalScope.uniqueProjectKey = true;

            DataikuAPI.projects.listAllKeys()
                .success(function(data) {
                    modalScope.allProjectKeys = data;
                })
                .error(setErrorInScope.bind(modalScope));

            function isProjectKeyUnique(value) {
                return !modalScope.allProjectKeys || modalScope.allProjectKeys.indexOf(value) < 0;
            };

            modalScope.$watch("options.targetProjectKey", function(nv, ov) {
                modalScope.uniqueProjectKey = !nv || isProjectKeyUnique(nv);
            });
            modalScope.$watch("options.copyZoneContent", function(nv, ov) {
                if (nv == ov) {
                    return;
                }
                modalScope.selectedZones.forEach(to => {
                    const items = itemsByZone.get(to.id);
                    if (!items) {
                        return
                    }
                    items.forEach(it => {
                        const found = selectedObjects.find(so => it.type === so.type && it.id === so.id);
                        if (found !== undefined) {
                            return;
                        }
                        if (nv) {
                            modalScope.selectedObjects.push(it);
                        } else {
                            const index = modalScope.selectedObjects.findIndex(sel => sel.id === it.id);
                            if (index != -1) {
                                modalScope.selectedObjects.splice(index, 1);
                            }
                        }
                    });
                });
                transmogrifyNames();
                reloadSelectionStats();
            });


            modalScope.folder = {};

            modalScope.$watch("options.targetProjectName", function(nv, ov) {
                if (!nv) return;
                var slug = nv.toUpperCase().replace(/\W+/g, ""),
                    cur = slug,
                    i = 0;
                while (!isProjectKeyUnique(cur)) {
                    cur = slug + "_" + (++i);
                }
                modalScope.options.targetProjectKey = cur;
            });

            modalScope.browse = folderIds =>  {
                return PromiseService.qToHttp($q(resolve => {
                    const ids = folderIds.split('/');
                    const destination = ids[ids.length - 1];
                    DataikuAPI.projectFolders.listContents(destination, true, 1, true).success(data => {
                        const folders = data.folder.children.map(f => angular.extend({}, f, { directory: true, fullPath: f.id }))
                        const pathElts = treeToList(data.folder, item => item.parent);

                        resolve({
                            children: folders,
                            pathElts: pathElts.map(f => angular.extend({}, f, { toString: () => f.id })),
                            exists: true,
                            directory: true,
                        });
                    }).error(setErrorInScope.bind(modalScope));
                }));
            };

            modalScope.canSelect = item => item.canWriteContents;

            modalScope.getName = item => item.name;
        });
    };
});



})();
(function() {
'use strict';

const app = angular.module('dataiku.controllers');


app.controller('ProjectBaseController', function($scope, $controller, $state, $stateParams, $timeout, $rootScope, $q, $filter,
            Assert, DataikuAPI, WT1, TopNav, Breadcrumb, CreateModalFromTemplate, TaggingService, FlowGraphSelection,
            GlobalProjectActions, Notification, HistoryService, FutureWatcher, ProgressStackMessageBuilder,
            AlationCatalogChooserService, WebAppsService) {

    $controller('_CreateRecipesBehavior', {$scope: $scope});

    $scope.standardizedSidePanel = {};
    $scope.standardizedSidePanel.slidePanel = function() {
        $scope.standardizedSidePanel.opened = !$scope.standardizedSidePanel.opened;
    }
    $scope.standardizedSidePanel.toggleTab = function(tabName) {
        $scope.standardizedSidePanel.tabToToggle = '';
        $timeout(() => { $scope.standardizedSidePanel.tabToToggle = tabName; });
    }
    
	$scope.refreshProjectData = function() {
		DataikuAPI.projects.getSummary($stateParams.projectKey).success(function(data) {
            $scope.projectCurrentBranch = data.projectCurrentBranch;
			$scope.projectSummary = data.object;
            $rootScope.projectSummary = $scope.projectSummary;
            $scope.objectInterest = data.interest;
            $scope.objectTimeline = data.timeline;
            $scope.projectSummaryStatus = data.objectsCounts;

            TopNav.setProjectData($scope.projectSummary, $scope.projectCurrentBranch);

            $scope.topNav.isProjectAnalystRO = $scope.isProjectAnalystRO();
            $scope.topNav.isProjectAnalystRW = $scope.isProjectAnalystRW();
            $scope.topNav.isCurrentProjectAdmin = $scope.isProjectAdmin();
            $scope.topNav.canAccessProjectSettings = $scope.isProjectAdmin();
            $scope.topNav.canAccessProjectSecurity = $scope.canAccessProjectSettings();
            $scope.topNav.isAppInstance = $scope.isAppInstance();
            $scope.topNav.showFlowNavLink = $scope.showFlowNavLink();
            $scope.topNav.showCodeNavLink = $scope.showCodeNavLink();
            $scope.topNav.showLabNavLink = $scope.showLabNavLink();
            $scope.topNav.showVersionControlFeatures = $scope.showVersionControlFeatures();

            if ($scope.projectSummary.tutorialProject) {
                WT1.setVisitorParam("tutorial-project", "true");
                WT1.setVisitorParam("tutorial-id", $scope.projectSummary.tutorialId);
                WT1.event("tutorial-project-open");
            }

            // number app tiles, if any
            if ($scope.projectSummary.appManifest && $scope.projectSummary.appManifest.homepageSections) {
                $scope.projectSummary.appManifest.homepageSections.forEach(function(section, sectionIdx) {
                    if (section.tiles) {
                        section.tiles.forEach(function(tile, tileIdx) {
                            tile.$sectionIdx = sectionIdx;
                            tile.$tileIdx = tileIdx;
                        });
                    }
                });
            }
		}).error(setErrorInScope.bind($scope));
	};

    $scope.$on("$destroy", function(){
        WT1.delVisitorParam("tutorial-project");
        WT1.delVisitorParam("tutorial-id");
        $scope.topNav.isCurrentProjectAdmin = false;
    });

    // The Pinboard controller puts stuff here for use by the pinboard page top level nav bar.
    $scope.dashboardContext = {};

	$scope.isProjectAdmin = function() {
        return $scope.projectSummary != null && $scope.projectSummary.isProjectAdmin;
	};
    $scope.canWriteProject = function() {
        // Alias
        return $scope.isProjectAnalystRW();
    };
	$scope.isProjectAnalystRW = function() {
		return $scope.projectSummary != null && $scope.projectSummary.canWriteProjectContent;
	};
	// To be in sync with PagesSettingsCatalogService:canAccessProjectSettings
    $scope.canAccessProjectSettings = function() {
        return $scope.projectSummary != null && $scope.projectSummary.canWriteProjectContent &&
            ($scope.projectSummary.canManageDashboardAuthorizations ||
             $scope.projectSummary.canManageExposedElements ||
             $scope.projectSummary.canManageAdditionalDashboardUsers);
    };
    $scope.isProjectAnalystRO = function() {
        return $scope.projectSummary != null && $scope.projectSummary.canReadProjectContent;
    };
	$scope.canModerateDashboards = function() {
		return $scope.projectSummary != null && $scope.projectSummary.canModerateDashboards;
	};
	$scope.canWriteDashboards = function() {
		return $scope.projectSummary != null && $scope.projectSummary.canWriteDashboards;
	};
	$scope.canReadDashboards = function() {
		return $scope.projectSummary != null && $scope.projectSummary.canReadDashboards;
	};
	$scope.canRunScenarios = function() {
		return $scope.projectSummary != null && $scope.projectSummary.canRunScenarios;
	};
	$scope.canManageExposedElements = function() {
		return $scope.projectSummary != null && $scope.projectSummary.canManageExposedElements;
	};
	$scope.canExportDatasetsData = function() {
		return $scope.projectSummary != null && $scope.projectSummary.canExportDatasetsData;
	};
    $scope.canExecuteApp = function() {
        return $scope.projectSummary != null && $scope.projectSummary.canExecuteApp;
    };
    $scope.isAppInstance = function() {
        return $scope.projectSummary != null && $scope.projectSummary.projectAppType == 'APP_INSTANCE';
    };
    $scope.showFlowNavLink = function() {
        return !$scope.isAppInstance() || $scope.projectSummary.appManifest.instanceFeatures.showFlowNavLink;
    };
    $scope.showCodeNavLink = function() {
        return !$scope.isAppInstance() || $scope.projectSummary.appManifest.instanceFeatures.showCodeNavLink;
    };
    $scope.showLabNavLink = function() {
        return !$scope.isAppInstance() || $scope.projectSummary.appManifest.instanceFeatures.showLabNavLink;
    };
    $scope.showVersionControlFeatures = function() {
        return !$scope.isAppInstance() || $scope.projectSummary.appManifest.instanceFeatures.showVersionControlFeatures;
    };

    $scope.newManagedDataset = function() {
        CreateModalFromTemplate("/templates/flow-editor/new-managed-dataset.html",
            $scope, "NewManagedDatasetController");
    };
    $scope.newManagedFolder = function() {
        CreateModalFromTemplate("/templates/managedfolder/new-box-modal.html", $scope);
    };
    $scope.newModelEvaluationStore = function() {
        CreateModalFromTemplate("/templates/modelevaluationstores/new-model-evaluation-store-modal.html", $scope);
    };

    $scope.importFromAlation = function(){
        AlationCatalogChooserService.openChooser();
    }

    $scope.displayPluginInfo = function(pluginId, showDatasets, showRecipes) {
    	var newScope = $scope.$new();
    	newScope.showDatasets = showDatasets;
    	newScope.showRecipes = showRecipes;
    	newScope.pluginDesc = $scope.appConfig.loadedPlugins.filter(function(x){
            return x.id == pluginId;
        })[0];
        CreateModalFromTemplate("/templates/plugins/modals/plugin-learn-more.html", newScope);
    };

    $scope.getRelevantZoneId = function(zoneId) {
        $scope.relevantZoneId = zoneId;
        let selectedItems = FlowGraphSelection.getSelectedNodes();
        if (selectedItems.length == 1 && selectedItems[0].nodeType == "ZONE") {
            $scope.relevantZoneId = selectedItems[0].cleanId;
        } else if (selectedItems.length == 1) {
            $scope.relevantZoneId = selectedItems[0].ownerZone;
        }
        return $scope.relevantZoneId;
    }

    $scope.getDatasetWithStatus = function(datasetName, target) {
        DataikuAPI.datasets.getWithMetricsStatus($stateParams.projectKey, datasetName).success(function(data){
            target.dataset = data.dataset;
            target.datasetShortStatus = data.shortStatus;
        }).error(function(){
            // if an error occurs consider the dataset was removed. TODO discard also relatedItems? (analyses)
            HistoryService.notifyRemoved({ type: "DATASET", id: datasetName });
            setErrorInScope.apply('$id' in target ? target : $scope, arguments);
        });
    };
    $scope.showLabModal = function(datasetSmartName, datasetFullInfo) {
        CreateModalFromTemplate("/templates/datasets/lab-modal.html", $scope, null, function(newScope) {
            newScope.datasetFullInfo = datasetFullInfo;
            newScope.datasetSmartName = datasetSmartName;
        });
    };

    $scope.showSparkNotLicensedModal = function() {
        CreateModalFromTemplate("/templates/widgets/spark-not-licensed-modal.html", $scope);
    };
    $scope.showCERestrictionModal = function(feature) {
        CreateModalFromTemplate("/templates/profile/community-vs-enterprise-modal.html",
            $scope, null, function(newScope){ newScope.lockedFeature = feature; });
    };

    $rootScope.showCERestrictionModal = $scope.showCERestrictionModal;
    $scope.$on("$destroy", function(){
        $rootScope.showCERestrictionModal = null;
    })

    $scope.GlobalProjectActions = GlobalProjectActions;

	$scope.refreshProjectData();

    /* ********************** Tags handling **************** */

    $scope.tagColor = TaggingService.getTagColor;
    $rootScope.activeProjectTagColor = TaggingService.getTagColor;
    $rootScope.activeGlobalTagsCategory = TaggingService.getGlobalTagCategory;

    $scope.projectTagsMap = {};
    var refreshTagMapRefs = function () {
        $scope.projectTagsMap = TaggingService.getProjectTags();
        $scope.projectTagsMapDirty = angular.copy($scope.projectTagsMap); // For settings, we want to be able to change and cancel/save then
    }
    TaggingService.fetchGlobalTags();

    function updateTagList(type) {
        TaggingService.update(type=="page-reload").success(refreshTagMapRefs);
    }
    updateTagList("page-reload");

    function refreshForTagListChanged() {
        updateTagList();
        TaggingService.fetchGlobalTags(true);
        $rootScope.$broadcast('taggableObjectTagsChanged');
    }

    var deregister = Notification.registerEvent("tags-list-changed", refreshForTagListChanged);

    $scope.$on('projectTagsUpdated', refreshTagMapRefs);

    $scope.getTagsMap = function () {
        return $scope.projectTagsMap;
    }

    $scope.getAllProjectTags = function () {
        var deferred = $q.defer();
        if (!$scope.hasOwnProperty("allProjectLevelTags")) {
            $scope.allProjectLevelTags = [];
            DataikuAPI.projects.listAllTags()
            .success(function(data) {
                $scope.allProjectLevelTags = TaggingService.fillTagsMapFromArray(data);
                deferred.resolve($scope.allProjectLevelTags);
            })
            .error(() => {
                setErrorInScope.bind($scope);
                deferred.resolve($scope.allProjectLevelTags);
            });
        }
        else {
            deferred.resolve($scope.allProjectLevelTags);
        }
        return getRewrappedPromise(deferred);
    }

    $scope.getTags = function(global){
        var deferred = $q.defer();
        deferred.resolve($scope.projectTagsMap);
        return getRewrappedPromise(deferred);
    };

    $scope.$on("$destroy", function(){
        $rootScope.activeProjectTagColor = null;
        $rootScope.activeGlobalTagsCategory = null;
        deregister();
    });

    /* Macro roles mapping */

    $scope.macroRoles = {};
    $scope.webappRoles = {};

    const pluginsById = $rootScope.appConfig.loadedPlugins.reduce(function (map, obj) {
        map[obj.id] = obj;
        return map;
    }, {});

    $rootScope.appConfig.customRunnables.forEach(function(runnable) {
        if (!runnable.desc.macroRoles) return;

        const plugin = pluginsById[runnable.ownerPluginId];
        if (!plugin) return; // plugin might have been deleted

        runnable.desc.macroRoles.forEach(function(macroRole) {
            $scope.macroRoles[macroRole.type] = $scope.macroRoles[macroRole.type] || [];

            $scope.macroRoles[macroRole.type].push({
                label: runnable.desc.meta.label || runnable.id,
                icon: runnable.desc.meta.icon || plugin.icon,
                roleTarget: macroRole.targetParamsKey || macroRole.targetParamsKeys,
                roleType: macroRole.type,
                applicableToForeign: macroRole.applicableToForeign,
                runnable: runnable
            });
        });
    });
    $scope.showCreateRunnable = function(runnable, targetKey, targetValue) {
        CreateModalFromTemplate('/templates/macros/runnable-modal.html', $scope, null, function(newScope) {
            newScope.runnable = runnable;
            newScope.targetKey = targetKey;
            newScope.targetValue = targetValue;
        });
    };


    $rootScope.appConfig.customWebApps.forEach(function(loadedWebApp) {
        if (!loadedWebApp.desc.roles) {
            return;
        }

        const plugin = pluginsById[loadedWebApp.ownerPluginId];
        if (!plugin) {
            return; // plugin might have been deleted
        }

        loadedWebApp.desc.roles.forEach(function(role) {
            $scope.webappRoles[role.type] = $scope.webappRoles[role.type] || [];

            $scope.webappRoles[role.type].push({
                label: loadedWebApp.desc.meta.label || loadedWebApp.id,
                icon: loadedWebApp.desc.meta.icon || plugin.icon,
                roleTarget: role.targetParamsKey || role.targetParamsKeys,
                roleType: role.type,
                applicableToForeign: role.applicableToForeign,
                loadedWebApp: loadedWebApp
            });
        });
    });

    $scope.showCreateWebAppModal = function(webappCategory, loadedWebApp, targetKey, targetValue, defaultName) {

        if (webappCategory !== 'code' && webappCategory !== 'visual') {
           return; 
        }

        let templateName;

        $scope.webappCategory = webappCategory;

        if (webappCategory === 'code') {
            templateName = '/templates/webapps/new-code-webapp-modal.html';
        } else {
            templateName = '/templates/webapps/new-visual-webapp-modal.html';
        }

        CreateModalFromTemplate(templateName, $scope, null, function(modalScope) {
            if (loadedWebApp) {
                modalScope.loadedWebApp = loadedWebApp;
                modalScope.app.type = loadedWebApp.webappType;
                modalScope.loadedDesc = WebAppsService.getWebAppLoadedDesc(modalScope.app.type) || {};
                modalScope.desc = modalScope.loadedDesc.desc;
                modalScope.pluginDesc = WebAppsService.getOwnerPluginDesc(modalScope.app.type);
            }
            modalScope.app.name = defaultName;
            modalScope.app.configFromRole = modalScope.app.configFromRole || {};
            modalScope.app.configFromRole[targetKey] = targetValue;
            modalScope.app.config = modalScope.app.config || {};
            modalScope.app.config[targetKey] = targetValue;

        }).then(function(webapp) {
        	if (webapp.backendReadyOrNoBackend) {
        		// backend up and running, go directly to view 
	            $state.go("projects.project.webapps.webapp.view", {projectKey : $stateParams.projectKey, webAppId: webapp.id, webAppName: $filter('slugify')(webapp.name)});
        	} else {
	            $state.go("projects.project.webapps.webapp.edit", {projectKey : $stateParams.projectKey, webAppId: webapp.id, webAppName: $filter('slugify')(webapp.name)});
        	}
        });
    }
    
    $scope.showCreateCodeWebAppModal = function(loadedWebApp, targetKey, targetValue, defaultName) {
        $scope.showCreateWebAppModal('code', loadedWebApp, targetKey, targetValue, defaultName);
    };

    $scope.showCreateVisualWebAppModal = function(loadedWebApp, targetKey, targetValue, defaultName) {
        $scope.showCreateWebAppModal('visual', loadedWebApp, targetKey, targetValue, defaultName);
    };

    /* Global actions */

    $scope.deleteThisProject = function() {
        DataikuAPI.projects.checkDeletability($stateParams.projectKey).success(function(data) {
            if(data.anyMessage) {
                // Some error happened!
                CreateModalFromTemplate("/templates/projects/delete-project-results.html", $scope, null, function(newScope) {
                    newScope.beforeDeletion = true;
                    newScope.results = data.messages;
                });
            } else {
                CreateModalFromTemplate("/templates/projects/delete-project-confirm-dialog.html", $scope, null, function(newScope) {
                    newScope.dropManagedData = false;
                    newScope.dropManagedFoldersOutputOfRecipe = false;
                    newScope.confirmProjectDeletion = function(dropManagedData, dropManagedFoldersOutputOfRecipe) {
                        DataikuAPI.projects.delete($stateParams.projectKey, dropManagedData, dropManagedFoldersOutputOfRecipe).success(function(deletionResult) {
                            if(deletionResult.anyMessage) {
                                CreateModalFromTemplate("/templates/projects/delete-project-results.html", $scope, null, function(newScope) {
                                    newScope.beforeDeletion = false;
                                    newScope.results = deletionResult.messages;
                                    newScope.$on('$destroy',function() {
                                        $timeout(function() {
                                            $state.transitionTo("home",{});
                                        });
                                    });
                                });
                            } else {
                                $state.transitionTo("home",{});
                            }

                        }).error(setErrorInScope.bind($scope));
                        WT1.event("project-delete",{dropManagedData, dropManagedFoldersOutputOfRecipe});
                    }
                });
            }
        }).error(setErrorInScope.bind($scope));
    };

    $scope.saveCustomFields = function(newCustomFields) {
        WT1.event('custom-fields-save', {objectType: 'PROJECT'});
        let oldCustomFields = angular.copy($scope.projectSummary.customFields);
        $scope.projectSummary.customFields = newCustomFields;
        return DataikuAPI.projects.saveSummary($stateParams.projectKey, $scope.projectSummary)
            .success(function() {
                $rootScope.$broadcast('customFieldsSaved', TopNav.getItem(), $scope.projectSummary.customFields);
            })
            .error(function(a, b, c) {
                $scope.projectSummary.customFields = oldCustomFields;
                setErrorInScope.bind($scope)(a, b,c);
            });
    };

    $scope.editCustomFields = function() {
        if (!$scope.projectSummary) {
            return;
        }
        let modalScope = angular.extend($scope, {objectType: 'PROJECT', objectName: $scope.projectSummary.name, objectCustomFields: $scope.projectSummary.customFields});
        CreateModalFromTemplate("/templates/taggable-objects/custom-fields-edit-modal.html", modalScope).then(function(customFields) {
            $scope.saveCustomFields(customFields);
        });
    };

    $scope.exportThisProject = function() {
        CreateModalFromTemplate("/templates/projects/export-project-dialog.html", $scope, null, function(newScope) {
            newScope.exportOptions = {
                exportUploads: true,
                exportManaged: true,
                exportAnalysisModels: true,
                exportSavedModels: true,
                exportInsights: true
            };
            newScope.uiState = {
                showAdvancedOptions : false
            }
            newScope.export = function() {

                DataikuAPI.projects.startProjectExport($stateParams.projectKey,
                    newScope.exportOptions).error(function() {newScope.dismiss();}).success(function(initialResponse){

                    CreateModalFromTemplate("/templates/projects/export-progress-modal.html", $scope, null, function(progressScope) {
                        newScope.dismiss();

                        progressScope.download = function(){
                            Assert.trueish(progressScope.finalResponse, 'no future final response');
                            downloadURL(DataikuAPI.projects.getProjectExportURL(progressScope.finalResponse.projectKey,
                                progressScope.finalResponse.exportId));
                            progressScope.dismiss();
                            WT1.event("project-download");
                        }

                        progressScope.abort = function(){
                            DataikuAPI.futures.abort(initialResponse.jobId).error(setErrorInScope.bind(progressScope));
                        }

                        progressScope.done = false;
                        progressScope.aborted = false;
                        FutureWatcher.watchJobId(initialResponse.jobId)
                        .success(function(data) {
                            progressScope.done = data.hasResult;
                            progressScope.aborted = data.aborted;
                            progressScope.futureResponse = null;
                            progressScope.finalResponse = data.result;
                        }).update(function(data){
                            progressScope.percentage =  ProgressStackMessageBuilder.getPercentage(data.progress);
                            progressScope.futureResponse = data;
                            progressScope.stateLabels = ProgressStackMessageBuilder.build(progressScope.futureResponse.progress, true);
                        }).error(function(data, status, headers) {
                            progressScope.done = true;
                            progressScope.futureResponse = null;
                            setErrorInScope.bind(progressScope)(data, status, headers);
                        });
                    });
                }).error(setErrorInScope.bind($scope));
                WT1.event("project-export", newScope.exportOptions);
            };
        });
    };
    $scope.duplicateThisProject = function() {
        CreateModalFromTemplate("/templates/projects/duplicate-project-dialog.html", $scope, "DuplicateProjectController");
    };
});


app.controller('_CreateRecipesBehavior', function($scope, CreateModalFromTemplate, RecipeDescService) {
    function preselect(inputDatasetSmartName,zone) {
        return function(newScope) {
            newScope.zone = zone;
            if (inputDatasetSmartName) {
                newScope.$broadcast('preselectInputDataset', inputDatasetSmartName);
            }
        };
    }
    $scope.showCreateShakerModal = function(inputDatasetSmartName, zone) {
        CreateModalFromTemplate('/templates/recipes/single-output-recipe-creation.html', $scope, 'ShakerRecipeCreationController', preselect(inputDatasetSmartName,zone));
    };
    $scope.showCreateWindowRecipeModal = function(inputDatasetSmartName, zone) {
        CreateModalFromTemplate('/templates/recipes/single-output-recipe-creation.html', $scope, 'WindowRecipeCreationController', preselect(inputDatasetSmartName,zone));
    };
    $scope.showCreateSamplingModal = function(inputDatasetSmartName,zone) {
        CreateModalFromTemplate('/templates/recipes/single-output-recipe-creation.html', $scope, 'SamplingRecipeCreationController', preselect(inputDatasetSmartName,zone));
    };
    $scope.showCreateSyncModal = function(inputDatasetSmartName,zone) {
        CreateModalFromTemplate('/templates/recipes/single-output-recipe-creation.html', $scope, 'SyncRecipeCreationController', preselect(inputDatasetSmartName,zone));
    };
    $scope.showCreateCSyncModal = function(inputDatasetSmartName, zone) {
        CreateModalFromTemplate('/templates/recipes/single-output-recipe-creation.html', $scope, 'CsyncRecipeCreationController', preselect(inputDatasetSmartName, zone));
    };
    $scope.showCreateUpdateModal = function(inputDatasetSmartName, zone) {
        CreateModalFromTemplate('/templates/recipes/update-recipe-creation.html', $scope, null, preselect(inputDatasetSmartName,zone));
    };
    $scope.showCreateExportModal = function(inputDatasetSmartName, zone) {
        CreateModalFromTemplate('/templates/recipes/export-recipe-creation.html', $scope, null, preselect(inputDatasetSmartName,zone));
    };
    $scope.showCreateDownloadModal = function(preselectedOutput, zone) {
        CreateModalFromTemplate('/templates/recipes/download-recipe-creation.html', $scope, null, function (newScope) {
            newScope.zone = zone;
            if (preselectedOutput) {
                newScope.io.newOutputTypeRadio = 'select';
                newScope.io.existingOutputDataset = preselectedOutput;
            }
        });
    };
    $scope.showCreateGroupingModal = function(inputDatasetSmartName,zone) {
        CreateModalFromTemplate('/templates/recipes/grouping-recipe-creation.html', $scope, null, preselect(inputDatasetSmartName,zone));
    };
    $scope.showCreateDistinctModal = function(inputDatasetSmartName,zone) {
        CreateModalFromTemplate('/templates/recipes/single-output-recipe-creation.html', $scope, 'DistinctRecipeCreationController', preselect(inputDatasetSmartName,zone));
    };
    $scope.showCreateSplitModal = function(inputDatasetSmartName,zone) {
        CreateModalFromTemplate('/templates/recipes/split-recipe-creation.html', $scope, null, preselect(inputDatasetSmartName,zone));
    };
    $scope.showCreateTopNModal = function(inputDatasetSmartName,zone) {
        CreateModalFromTemplate('/templates/recipes/single-output-recipe-creation.html', $scope, 'TopNRecipeCreationController', preselect(inputDatasetSmartName,zone));
    };
    $scope.showCreateSortModal = function(inputDatasetSmartName,zone) {
        CreateModalFromTemplate('/templates/recipes/single-output-recipe-creation.html', $scope, 'SortRecipeCreationController', preselect(inputDatasetSmartName,zone));
    };
    $scope.showCreatePivotModal = function(inputDatasetSmartName,zone) {
        CreateModalFromTemplate("/templates/recipes/pivot-recipe-creation.html", $scope, null, preselect(inputDatasetSmartName,zone));
    };
    $scope.showCreatePredictionModal = function() {
        CreateModalFromTemplate('/templates/models/prediction/create-scoring-recipe-modal.html', $scope, null);
    };
    $scope.showCreateAssignClustersModal = function() {
        CreateModalFromTemplate('/templates/models/clustering/create-scoring-recipe-modal.html', $scope, null);
    };

    $scope.showCreateJoinModal = function(preselectedInputs, zone) {
        CreateModalFromTemplate('/templates/recipes/2to1-recipe-creation.html', $scope, 'JoinRecipeCreationController', function(newScope) {
            newScope.zone = zone;
            if (preselectedInputs && preselectedInputs.length >= 1) {
                newScope.io.inputDataset = preselectedInputs[0]
            }
            if (preselectedInputs && preselectedInputs.length >= 2) {
                newScope.io.inputDataset2 = preselectedInputs[1];
            }
        });
    };
    $scope.showCreateFuzzyJoinModal = function(preselectedInputs, zone) {
            CreateModalFromTemplate('/templates/recipes/2to1-recipe-creation.html', $scope, 'FuzzyJoinRecipeCreationController', function(newScope) {
                newScope.zone = zone;
                if (preselectedInputs && preselectedInputs.length >= 1) {
                    newScope.io.inputDataset = preselectedInputs[0];
                }
                if (preselectedInputs && preselectedInputs.length >= 2) {
                    newScope.io.inputDataset2 = preselectedInputs[1];
                }
            });
        };
    $scope.showCreateVStackModal = function(preselectedInputs, zone) {
        CreateModalFromTemplate('/templates/recipes/Nto1-recipe-creation.html', $scope, 'VStackRecipeCreationController', function(newScope) {
            newScope.zone = zone;
            if (preselectedInputs) {
                preselectedInputs.forEach(function(input) {
                    newScope.recipe.inputs.main.items.push({ref: input});
                });
            }
        });
    };
    $scope.showCreateMergeFolderModal = function(preselectedInputs, zone) {
        CreateModalFromTemplate('/templates/recipes/merge_folder-recipe-creation.html', $scope, 'MergeFolderRecipeCreationController', function(newScope) {
            newScope.zone = zone;
            if (preselectedInputs) {
                preselectedInputs.forEach(function(input) {
                    newScope.recipe.inputs.main.items.push({ref: input});
                });
            }
        });
    };

    $scope.showSQLRecipeModal = function(inputDatasetSmartName, zone) {
        CreateModalFromTemplate('/templates/flow-editor/new-sql-recipe-box.html', $scope, null, function(newScope) {
            newScope.zone = zone;
            newScope.preselectedInputDataset = inputDatasetSmartName;
        }, 'new-sql-recipe-box');
    };

    $scope.showCreateRecipeFromNotebookModal = function(notebookName, recipeType, analyzedDataset) {
        CreateModalFromTemplate("/templates/recipes/recipe-from-notebook-creation.html", $scope, null, function(newScope) {
            newScope.notebookName = notebookName;
            newScope.newRecipeType = recipeType;
            newScope.analyzedDataset = analyzedDataset;
        });
    };

    // preselectedInputs can be a computable smartName or an array of smartNames
    $scope.showCreateCodeBasedModal = function(recipeType, preselectedInputs, zone, prefillKey) {
        CreateModalFromTemplate('/templates/recipes/code-based-recipe-creation.html', $scope, 'CodeBasedRecipeCreationController', function(newScope) {
            newScope.zone = zone;
            newScope.newRecipeType = recipeType;
            newScope.preselectedInputs = preselectedInputs;
            newScope.recipePrefillKey = prefillKey;
        });
    };

    $scope.showCreateCustomCodeRecipeModal = function(recipeType, inputRefs, inputRole, zone){
        CreateModalFromTemplate('/templates/recipes/custom-code-recipe-creation.html', $scope, null, function(newScope) {
            newScope.zone = zone;
            newScope.newRecipeType = recipeType;
            // there can be more than one preselected input,
            // but they have to be for the same role as there can only be one preselected role.
            newScope.preselectedInputs = inputRefs;
            newScope.preselectedInputRole = inputRole;
        });
    };

    $scope.showCreateRecipeFromPlugin = function(pluginId, inputRefs, zone) {
        let modalScope;
        CreateModalFromTemplate('/templates/recipes/recipe-from-plugin-creation.html', $scope, null, function(newScope) {
            newScope.zone = zone;
            newScope.pluginId = pluginId;
            newScope.inputs = inputRefs;
            if (inputRefs) {
                newScope.inputCount = {}
                for (const key in inputRefs) {
                    newScope.inputCount[key] = inputRefs[key].length
                }
            }
            modalScope = newScope;
            modalScope.$on('$destroy', () => modalScope = null);
        });
        // on opener scope destroy, dismiss the modal
        // e.g. recipe was created, going on recipe page
        this.$on('$destroy', () => modalScope && modalScope.dismiss());
    };

    $scope.showCreateAppRecipeModal = function(recipeType, inputRefs, inputRole){
        CreateModalFromTemplate('/templates/recipes/app-recipe-creation.html', $scope, null, function(newScope) {
            newScope.newRecipeType = recipeType;
            // there can be more than one preselected input,
            // but they have to be for the same role as there can only be one preselected role.
            newScope.preselectedInputs = inputRefs;
            newScope.preselectedInputRole = inputRole;
        });
    };

    $scope.showCreateDatasetFromPlugin = function(pluginId) {
        CreateModalFromTemplate('/templates/datasets/dataset-from-plugin-creation.html', $scope, null, function(newScope) {
            newScope.pluginId = pluginId;
        });
    };

    $scope.showCreateUrlDownloadToFolderDataset = function(projectKey) {
        CreateModalFromTemplate('/templates/recipes/download-url-to-folder-dataset.html', $scope, null, function(newScope) {
            newScope.params.projectKey = projectKey;
        });
    };

    $scope.showCreateStreamingEndpointModal = function(type) {
        CreateModalFromTemplate('/templates/streaming-endpoints/new-streaming-endpoint-modal.html', $scope, "NewStreamingEndpointController", function(newScope) {
            newScope.newStreamingEndpoint.type = type;
        });
    }

    // --- Copy

    $scope.recipeTypeIsCopiable = function(recipeType) {
        if (!recipeType) return false;
        const desc = RecipeDescService.getDescriptor(recipeType);
        if (!desc) {
            throw Error(`Could not find descriptor for recipe type ${recipeType}`);
        }
        return desc.copiable;
    };

    $scope.showCopyRecipeModal = function(recipe) {
        const newScope = $scope.$new();
        newScope.recipe = recipe;
        newScope.newInputs = angular.copy(recipe.inputs);
        newScope.newOutputs = {};
        newScope.zone = recipe.zone;
        CreateModalFromTemplate('/templates/recipes/recipe-copy-modal.html', newScope);
    };
});


app.controller('ProjectHomeTabController', function($scope, $state, $stateParams, Breadcrumb, TopNav, DataikuAPI, ActivityIndicator, HistoryService, StateUtils) {
    $scope.tabUiState = {
        projectAppView : 'REGULAR'
    };

    $scope.$watch("projectSummary", function(nv, ov) {
        if (!nv)  return;

        if ($scope.projectSummary.projectAppType == 'APP_INSTANCE') {
            $scope.tabUiState.projectAppView = "APP_TILES";
        } else {
            $scope.tabUiState.projectAppView = "REGULAR";
        }
    });

    $scope.switchToAppView = function(){
        $scope.tabUiState.projectAppView = "APP_TILES";
    }
    $scope.switchToRegularProjectView = function(){
        $scope.tabUiState.projectAppView = "REGULAR";
    }

});

app.controller('ProjectHomeController', function($scope, $state, $stateParams, Breadcrumb, TopNav, DataikuAPI, ActivityIndicator, HistoryService, StateUtils, WatchInterestState) {
    TopNav.setLocation(TopNav.TOP_HOME, null, null, "summary");
    TopNav.setItem(TopNav.ITEM_PROJECT, $stateParams.projectKey);

    $scope.$watch("projectSummary", function(nv, ov) {
        if (!nv)  return;
        if (nv.projectKey == $stateParams.projectKey) {
            if ($scope.projectSummary.name) {
                HistoryService.recordProjectOpen($scope.projectSummary);
                TopNav.setPageTitle($scope.projectSummary.name);
            }
            if ($scope.projectSummary.projectAppType == 'APP_INSTANCE' && nv.projectKey) {
                DataikuAPI.apps.getInstanceSummary(nv.projectKey).success(function (data) {
                    $scope.appSummary = data;
                }).error(setErrorInScope.bind($scope));
            }
        }
    });

    $scope.uiState = {
        editSummary: false,
        activeTimelineTab : 'full'
    };

    $scope.projectRecentItems = HistoryService.getRecentlyViewedItems(5, null, $stateParams.projectKey);

	$scope.refreshTimeline = function() {
        if ($scope.isProjectAnalystRO()) {
		    DataikuAPI.timelines.getForProject($stateParams.projectKey).success(function(data) {
	   		  $scope.objectTimeline = data;
    		}).error(setErrorInScope.bind($scope));
        }
	};

    $scope.historyItemHref = function(item) {
        return StateUtils.href.dssObject(item.type, item.id, item.projectKey);
    };

    $scope.isProjectStatusSelected = function(projectStatus) {
    	return projectStatus.name == $scope.projectSummary.projectStatus;
    };

    /* For update of name/tags/description */
    function save(){
        DataikuAPI.projects.saveSummary($stateParams.projectKey, $scope.projectSummary).success(function(data){
            ActivityIndicator.success("Saved!");
        }).error(setErrorInScope.bind($scope));
    };

	$scope.$on("objectSummaryEdited", function(event, currentEditing){
        save();
        // remove pattern image from cache to update initials on project image (for graph/list view on project explorer page)
        if (currentEditing === 'name' && $scope.projectSummary.showInitials && !$scope.projectSummary.isProjectImg) {
            DataikuAPI.images.removeImage($stateParams.projectKey, 'PROJECT', $stateParams.projectKey);
        }
        $scope.refreshTimeline();
    });

    $scope.$on('customFieldsSummaryEdited', function(event, customFields) {
        $scope.saveCustomFields(customFields);
    });

    $scope.$on("projectImgEdited", function(ev, newState){
        $scope.projectSummary.imgColor = newState.imgColor;
        $scope.projectSummary.isProjectImg = newState.isProjectImg;
        $scope.projectSummary.imgPattern = parseInt(newState.imgPattern, 10);
        $scope.projectSummary.showInitials = newState.showInitials;
        save();
        $scope.refreshTimeline();
    });

    const { isWatching, isShallowWatching, isFullyWatching } = WatchInterestState;
    $scope.isWatching = isWatching;
    $scope.isShallowWatching = isShallowWatching;
    $scope.isFullyWatching = isFullyWatching;
});


app.controller('ProjectActivityViewCommonController', function($scope, Fn) {
    $scope.prepareData = function(data) {
        $scope.activitySummary = data;
        $scope.dailyData = {
            commits: data.totalCommits.dayTS.data.map(function(ts, i) {
                return { date: new Date(ts), value: data.totalCommits.value.data[i] };
            }),
            writeHours: data.totalHoursWithWrites.dayTS.data.map(function(ts, i) {
                return { date: new Date(ts), value: data.totalHoursWithWrites.value.data[i] };
            }),
            presenceHours: data.totalPresence.dayTS.data.map(function(ts, i) {
                return { date: new Date(ts), value: Math.round(data.totalPresence.value.data[i] / 1000) };
            })
        };

        data.contributorsChart.dates = data.contributorsChart.bucketsTS.data
            .map(function (ts) { return new Date(ts); });
        data.contributorsSummaryAllTime.forEach(function(c) {
            if (c.user in data.contributorsChart.perContributor) {
                data.contributorsChart.perContributor[c.user].totalCommits = c.commits;
                data.contributorsChart.perContributor[c.user].totalAddedLines = c.addedLines;
                data.contributorsChart.perContributor[c.user].totalRemovedLines = c.removedLines;
            }
        });
        // To array for sortability
        data.contributorsChart.perContributor = Object.keys(data.contributorsChart.perContributor)
            .map(Fn.from(data.contributorsChart.perContributor));
        // Scope is computed by first 'global' chart, then copy it to inididual charts
        // (global charts must render first)
        data.contributorsChart.scale = null;
        $scope.setContributorsChartScale = function(scale) {
            data.contributorsChart.scale = scale;
            return scale;
        };

        data.contributorsSummary.forEach(function (c) {
            c.presenceHours = c.totalPresence / 3600 / 1000; // precence in hours
        });

        $scope.totalCommitsPerHour = Array.reshape2d(data.totalCommitsPerHour.matrix, 24);
    }
});


app.controller('ProjectActivityDashboardController', function($scope, DataikuAPI, TopNav, $stateParams, $controller) {
    $controller('ProjectActivityViewCommonController', {$scope: $scope});

    TopNav.setLocation(TopNav.TOP_HOME, null, null, "activity");
    TopNav.setItem(TopNav.ITEM_PROJECT, $stateParams.projectKey);
    $scope.uiState = {
        settingsPane : "summary",
        summaryChart: 'commits',
        contributorsChart: 'commits'
    };

    $scope.niceHours = function(sec) {
        var h = (sec/3600);
        return h.toFixed(1).replace(/\.0$/, '') + (h >= 2 ? ' hrs' : ' hr');
    };

    $scope.$watch('uiState.timeSpan', function(timeSpan) {
        DataikuAPI.projects.activity.getActivitySummary($stateParams.projectKey, timeSpan).success(function(data){
            $scope.prepareData(data);
        }).error(setErrorInScope.bind($scope));
    });
    $scope.uiState.timeSpan = 'year';
});

app.controller('ProjectMetricsController', function($scope, DataikuAPI, TopNav, $stateParams, $controller) {
    TopNav.setLocation(TopNav.TOP_HOME, null, null, "status");
    TopNav.setItem(TopNav.ITEM_PROJECT, $stateParams.projectKey);

    $scope.$watch("projectSummary", function(nv, ov) {
        if (!nv)  return;
        TopNav.setPageTitle($scope.projectSummary.name);
    });
});


app.controller('ProjectMetricsEditionController', function($scope, DataikuAPI, TopNav, $stateParams, $controller, WT1) {
    $scope.newMetric = {};

    $scope.addMetricPoint = function(newMetric) {
        var metricsData = {};
        metricsData[newMetric.name] = newMetric.value;
        DataikuAPI.projects.saveExternalMetricsValues($stateParams.projectKey, metricsData, {}).success(function(data){
            WT1.event("project-metric-inserted");
        }).error(setErrorInScope.bind($scope));
    };
});

app.controller('ProjectChecksEditionController', function($scope, DataikuAPI, TopNav, $stateParams, $controller, WT1) {
    $scope.newCheck = {};

    $scope.addCheckPoint = function(newCheck) {
        var checksData = {};
        if (newCheck.message && newCheck.message.length > 0) {
            checksData[newCheck.name] = [newCheck.value, newCheck.message];
        } else {
            checksData[newCheck.name] = newCheck.value;
        }
        DataikuAPI.projects.saveExternalChecksValues($stateParams.projectKey, checksData).success(function(data){
            WT1.event("project-check-inserted");
        }).error(setErrorInScope.bind($scope));
    };
});

app.directive('projectScenariosRuns', function($controller, $state){
    return {
        templateUrl: '/templates/projects/home/project-scenarios-runs.html',
        scope: {
            scenariosDays: '<',
            activeScenarios: '=',
            totalScenarios: '=',
            projectKey: '='
        },
        link: function($scope, element, attrs){
            $controller('OutcomesBaseController', {$scope: $scope});

            $scope.uiState = {};

            $scope.$watch('scenariosDays', function(nv, ov) {
                if (!nv) return;
                $scope.fixupOutcomes($scope.scenariosDays.columns, 14);
                computeLastRuns();
                sortRows();
                fixupRows();
                $scope.hasNoScenario = computeHasNoScenario();
                $scope.scenariosDays.rows = $scope.scenariosDays.rows.slice(0,4);
                $scope.displayedColumns = $scope.scenariosDays.columns; // b/c the underlying directive, outcomeCells, needs it in its scope
            });

            function computeLastRuns() {
                $scope.scenariosDays.rows.forEach(function(row) {
                    const id = row.uniqueId;
                    for (let i = $scope.scenariosDays.columns.length - 1; i>=0; i--) {
                        const column = $scope.scenariosDays.columns[i];
                        if (column.actions && column.actions[id]) {
                            const actions = column.actions[id];
                            row.lastRun = {
                                date: column.date,
                                outcome: actions[actions.length - 1].outcome.toLowerCase()
                            };
                            break;
                        }
                    }
                });
            }

            function sortRows() {
                $scope.scenariosDays.rows.sort(function(r1, r2) {
                    if (angular.equals({}, r2)) {
                        return -1;
                    }
                    if (angular.equals({}, r1)) {
                        return 1;
                    }
                    if (r1.lastRun.date == r2.lastRun.date) {
                        return r1.info.name.localeCompare(r2.info.name)
                    }
                    return r1.lastRun.date.localeCompare(r2.lastRun.date);
                });
            }

            function fixupRows() {
                while($scope.scenariosDays.rows.length < 4) {
                    $scope.scenariosDays.rows.push({});
                }
            }

            function computeHasNoScenario() {
                for (let i = 0; i<$scope.scenariosDays.rows.length; i++) {
                    const row = $scope.scenariosDays.rows[i];
                    if (!angular.equals({}, row)) {
                        return false;
                    }
                }
                return true;
            }

            $scope.hover = function(evt, column, row, localScope) {
                if (!$scope.hasNoScenario) {
                    $scope.hovered.date = column.date;
                    if (row && row.uniqueId) {
                        $scope.hovered.row = row;
                    }
                    $scope.hovered.actions = row && row.uniqueId ? column.actions[row.uniqueId] : null;
                }
            };

            $scope.unhover = function(evt, column, row, localScope) {
                $scope.hovered.date = null;
                $scope.hovered.row = null;
                $scope.hovered.actions = null;
            };

            $scope.select = function(evt, column, row, localScope) {
                if (row && row.uniqueId) {
                    evt.stopPropagation();
                    $state.go('projects.project.monitoring.scenarios.scoped', {
                        projectKey: $scope.projectKey,
                        scopeToDay: column.date,
                        scenarioQuery: row.info.name
                    });
                }
            }
        }
    };
});

}());

(function() {
'use strict';

const app = angular.module('dataiku.controllers');

app.controller('ProjectVersionControlController', function($scope, TopNav, DataikuAPI, Dialogs, FullGitSupportService, $stateParams, $filter, WT1, CreateModalFromTemplate,ActivityIndicator){
    var PAGE_SIZE = 20;

    TopNav.setLocation(TopNav.TOP_MORE, "version-control", "NONE", null);
    TopNav.setItem(TopNav.ITEM_PROJECT, $stateParams.projectKey);

    function warnBeforeGlobalOperation(opName, opText){
        return Dialogs.confirm($scope, opName,
            opText + " will not have any impact on any data. "+
            " This could lead to some data becoming orphan, or to some datasets pointing to stale data");
    }

    $scope.getGitFullStatus = function() {
        return FullGitSupportService.getFullStatus($scope, 
            DataikuAPI.projects.git.getFullStatus($stateParams.projectKey));
    };

    $scope.getGitBranches = function () {
         return FullGitSupportService.getBranches($scope, 
                    DataikuAPI.projects.git.listBranches($stateParams.projectKey));
    };

    $scope.filterBranches = function (query) {
        $scope.gitBranchesFiltered = $filter("filter")($scope.gitBranches, query);
    };

    $scope.formatTrackingCount = function(count) {
        return count != null ? count : "-";
    };

    $scope.switchToBranch = function(branchName) {
        if ($scope.gitStatus.hasRemoteOrigin) {
            DataikuAPI.projects.git.listProjectsMatchingRemoteRepository($stateParams.projectKey, branchName)
                .success(function(projectCandidates) {
                    CreateModalFromTemplate("/templates/projects/git/checkout-branch-modal.html", $scope, "ProjectCheckoutBranchController", function (newScope) {
                        newScope.checkoutModel.createBranch = false;
                        newScope.checkoutModel.targetBranchName = branchName;
                        if (projectCandidates && projectCandidates.length > 0) {
                            newScope.checkoutModel.checkoutMode = "GO_TO_ALTERNATE_PROJECT";
                            newScope.checkoutModel.alternateProjectKey = projectCandidates[0].projectKey;
                            newScope.checkoutModel.alternateProjectName = projectCandidates[0].projectName;
                        } else {
                            newScope.checkoutModel.checkoutMode = "DUPLICATE_PROJECT";
                        }
                    });
                    WT1.event("projects-git-switch-branch");
                })
                .error(setErrorInScope.bind($scope));
        } else {
            CreateModalFromTemplate("/templates/projects/git/checkout-branch-modal.html", $scope, "ProjectCheckoutBranchController", function (newScope) {
                newScope.checkoutModel.createBranch = false;
                newScope.checkoutModel.targetBranchName = branchName;
                newScope.checkoutModel.checkoutMode = "USE_CURRENT_PROJECT";
            });
            WT1.event("projects-git-switch-branch");
        }
    };

    $scope.modalCreateBranch = function(wantedBranch) {
        CreateModalFromTemplate("/templates/projects/git/checkout-branch-modal.html", $scope, "ProjectCheckoutBranchController", function (newScope) {
            newScope.checkoutModel.createBranch = true;
            newScope.checkoutModel.targetBranchName = wantedBranch || "";
            newScope.checkoutModel.checkoutMode = $scope.gitStatus.hasRemoteOrigin ? "DUPLICATE_PROJECT" : "USE_CURRENT_PROJECT";
        });
        WT1.event("projects-git-create-branch", {source: "branch"});
    };

    $scope.createBranchFromCommit = function(commitId) {
        CreateModalFromTemplate("/templates/projects/git/checkout-branch-modal.html", $scope, "ProjectCheckoutBranchController", function (newScope) {
            newScope.checkoutModel.createBranch = true;
            newScope.checkoutModel.targetBranchName = "";
            newScope.checkoutModel.commitId = commitId;
            newScope.checkoutModel.checkoutMode = $scope.gitStatus.hasRemoteOrigin ? "DUPLICATE_PROJECT" : "USE_CURRENT_PROJECT";
        });
        WT1.event("projects-git-create-branch", {source: "commit"});
    };

    $scope.modalDeleteLocalBranches = function() {
        const callback = function(modalScope, branchesToDelete, deleteOptions) {
            DataikuAPI.projects.git.deleteBranches($stateParams.projectKey, branchesToDelete, deleteOptions).then(function() {
                $scope.getGitBranches();
                modalScope.dismiss();
                WT1.event("projects-git-delete-branches");
            }, setErrorInScope.bind(modalScope));
        };
        FullGitSupportService.deleteBranches($scope, callback);
    };

    $scope.modalFetch = function () {
        FullGitSupportService.fetch($scope, DataikuAPI.projects.git.fetch($stateParams.projectKey));
        WT1.event("projects-git-fetch");
    };

    $scope.modalPull = function() {
        warnBeforeGlobalOperation("Pulling project", "Pulling updates from remote").then(function(){
            FullGitSupportService.pull($scope, DataikuAPI.projects.git.pull($stateParams.projectKey, $scope.gitStatus.remoteOrigin.name, $scope.gitStatus.currentBranch));
            WT1.event("projects-git-pull");
        });
    };

    $scope.modalPush = function() {
        FullGitSupportService.push($scope, DataikuAPI.projects.git.push($stateParams.projectKey));
        WT1.event("projects-git-push");
    };

    $scope.modalReset = function() {
        warnBeforeGlobalOperation("Dropping changes", "Dropping changes").then(function(){
            CreateModalFromTemplate("/templates/plugins/development/git/reset-modal.html", $scope, "ProjectGitResetController");
        });
    };

    $scope.modalAddOrEditRemote = function() {
        const callback = function(remoteName, newURL) {
            DataikuAPI.projects.git.setRemote($stateParams.projectKey, remoteName, newURL).then(function() {
                $scope.getGitFullStatus();
                ActivityIndicator.success("Remote saved", 5000);
                WT1.event("projects-git-set-remote");
            }, setErrorInScope.bind($scope));
        };
        FullGitSupportService.editRemote($scope, callback);
    };

    $scope.modalRemoveRemote = function() {
        const callback = function(remoteName) {
            DataikuAPI.projects.git.removeRemote($stateParams.projectKey, remoteName).then(function() {
                $scope.getGitFullStatus();
                $scope.getGitBranches();
                ActivityIndicator.success("Remote removed", 5000);
                WT1.event("projects-git-remove-remote");
            }, setErrorInScope.bind($scope));
        };
        FullGitSupportService.removeRemote($scope, callback);
    };

    $scope.modalCommit = function() {
        CreateModalFromTemplate("/templates/plugins/development/git/commit-modal.html", $scope, "ProjectGitCommitController");
    };

    $scope.getResetModes = function() {
        let modes = [];

        if ($scope.projectSummary && $scope.projectSummary.commitMode !== 'AUTO') {
            modes.push('HEAD');
        }

        if ($scope.gitStatus.hasRemoteOrigin && $scope.gitStatus.hasTrackingCount) {
            modes.push('UPSTREAM');
        }

        return modes;
    };

    $scope.needsExplicitCommit = function(){
        return $scope.projectSummary && $scope.projectSummary.commitMode !== 'AUTO';
    };

    $scope.gitBranchesLoaded = false;
    const updatePermissions = function() {
        if ($scope.projectSummary) {
            $scope.canChangeRemote = $scope.projectSummary.isProjectAdmin;
            $scope.canChangeBranch = $scope.projectSummary.isProjectAdmin;
            $scope.canUpdateContent = $scope.projectSummary.isProjectAdmin;
            if (!$scope.gitBranchesLoaded && $scope.canChangeBranch) {
                $scope.getGitBranches();
                $scope.gitBranchesLoaded = true;
            }
        } else {
            $scope.canChangeRemote = false;
            $scope.canChangeBranch = false;
            $scope.canUpdateContent = false;
        }
    };

    $scope.getGitFullStatus();
    updatePermissions();
    $scope.$watch('projectSummary', updatePermissions);

    $scope.loadMore = function () {
        if ($scope.hasMore && !$scope.loading) {
            $scope.loading = true;
            DataikuAPI.git.getObjectLog($stateParams.projectKey, 'PROJECT', $stateParams.projectKey, $scope.nextCommit, PAGE_SIZE).success(function (data) {
                $scope.logEntries = $scope.logEntries.concat(data.logEntries);
                $scope.nextCommit = data.nextCommit;
                if (!$scope.nextCommit) {
                    $scope.hasMore = false;
                }
                $scope.loading = false;
            }).error(setErrorInScope.bind($scope));
        }
    };

    $scope.loadLogFromStart = function() {
        $scope.nextCommit = null;
        $scope.logEntries = [];
        $scope.hasMore = true;

        $scope.loadMore();
    };

    $scope.loadLogFromStart();
});

app.controller("ProjectGitCommitController", function($scope, $stateParams, $filter, DataikuAPI, ActivityIndicator, $timeout, WT1) {
    DataikuAPI.git.prepareObjectCommit($stateParams.projectKey, 'PROJECT', $stateParams.projectKey).success(function (data) {
        $scope.preparationData = data;
    }).error(setErrorInScope.bind($scope));

    $scope.uiState = {
        activeTab: 'message',
        message: ''
    };

    $timeout(() => {
        // Magic happens here: if commitEditorOptions is defined too early, the textarea won't properly autofocus
        $scope.commitEditorOptions = {
            mode : 'text/plain',
            lineNumbers : false,
            matchBrackets : false,
            autofocus: true,
            onLoad : function(cm) {$scope.codeMirror = cm;}
        };
    }, 100);


    $scope.gitCommit = function() {
        DataikuAPI.git.commitObject($stateParams.projectKey, 'PROJECT', $stateParams.projectKey, $scope.uiState.message)
            .success(function () {
                ActivityIndicator.success('Changes successfully committed.');
                $scope.dismiss();
                $scope.getGitFullStatus();
                $scope.loadLogFromStart();
                WT1.event("projects-git-commit");
            }).error(setErrorInScope.bind($scope));
    };
});

app.controller("ProjectCheckoutBranchController", function($scope, $state, $stateParams, DataikuAPI, FutureWatcher, ProgressStackMessageBuilder, WT1, ProjectFolderContext, PromiseService, Dialogs, $q) {
    function isProjectKeyAlreadyUsed(projectKey) {
        return projectKey && $scope.allProjectKeys && $scope.allProjectKeys.indexOf(projectKey) >= 0;
    }

    function isBranchNameAlreadyUsed(branchName) {
        return branchName && $scope.gitBranches && $scope.gitBranches.indexOf(branchName) >= 0;
    }

    function doesBranchNameContainsInvalidCharacters(branchName) {
        // must not have ASCII control characters (00-40 + DEL=177), space, tilde, caret, colon, at, star, question mark, left square bracket.
        return /[\000-\037\177 ~^:@*?\[\\]/g.test(branchName);
    }

    function isBranchNameValid(branchName) {
        return branchName
            && !doesBranchNameContainsInvalidCharacters(branchName)
            // must not start with slash (/)
            && !/^\//g.test(branchName)
            // must not end with slash (/), dot (.) or ".lock"
            && !/(\/|\.|\.lock)$/g.test(branchName)
            // must not contain "/." or ".." or "//"
            && !/(\/\.|\.\.|\/\/)/g.test(branchName);
    }

    function sanitizeProjectKey(projectKey) {
        return projectKey.toUpperCase().replace(/\W+/g, "_").replace(/_+$/,'');
    }

    function fixProjectKey(newProjectKey) {
        if (!newProjectKey || !$scope.allProjectKeys) { // Not initialized or all project keys not loaded yet
            return;
        }
        const slug = sanitizeProjectKey(newProjectKey);
        let cur = slug;
        let i = 0;
        while (isProjectKeyAlreadyUsed(cur)) {
            cur = slug + "_" + (++i);
        }
        $scope.checkoutModel.projectKey = cur;
    }

    var abortHook = null;

    // Initialize scope variables
    $scope.phase = 'INITIAL';
    $scope.checkoutModel = {
        // Initial phase
        createBranch: false,
        targetBranchName: undefined,
        checkoutMode: "USE_CURRENT_PROJECT",
        branchNameError: false, // true if the branch name already exists or is invalid (only used when creating a new branch)

        // Switch phase
        clearOutputDatasets: false,

        // Duplicate phase
        projectKey: sanitizeProjectKey($scope.projectSummary.projectKey),
        projectName: $scope.projectSummary.name,
        projectKeyAlreadyUsed: false
    };
    $scope.checkoutModel.projectKeyAlreadyUsed = isProjectKeyAlreadyUsed($scope.checkoutModel.projectKey);
    $scope.dupOptions = {
        exportAnalysisModels: true,
        exportSavedModels: true,
        exportModelEvaluationStores: false,
        exportGitRepository: true,
        exportInsightsData: true,
        duplicationMode: 'UPLOADS_ONLY',
        exportUploads: true,
        exportAllInputDatasets: false,
        exportAllInputManagedFolders: false,
        exportAllDatasets: false,
        exportManagedFolders: false,
        targetProjectFolderId: ProjectFolderContext.getCurrentProjectFolderId()
    };

    // Define scope functions
    $scope.setDuplicationMode = function(mode) {
        $scope.dupOptions.duplicationMode = mode;
    };

    $scope.validateInitialPhase = function() {
        if ($scope.checkoutModel.createBranch && !isBranchNameValid($scope.checkoutModel.targetBranchName)) {
            $scope.checkoutModel.branchNameError = true;
            $scope.checkoutModel.branchNameErrorMessage = "This branch name is invalid.";
            return;
        }
        if ($scope.checkoutModel.checkoutMode === "GO_TO_ALTERNATE_PROJECT") {
            $scope.dismiss();
            $state.transitionTo("projects.project.home.regular", {projectKey : $scope.checkoutModel.alternateProjectKey});
        } else if ($scope.checkoutModel.checkoutMode === "DUPLICATE_PROJECT") {
            $scope.moveToDuplicatePhase();
        } else if (!$scope.checkoutModel.createBranch) {
            $scope.moveToSwitchPhase();
        } else {
            $scope.createBranch();
        }
    };

    $scope.moveToInitialPhase = function() {
        $scope.phase = "INITIAL";
        $scope.fatalAPIError = null;
        $scope.duplicateResponse = null;
    };

    $scope.moveToDuplicatePhase = function() {
        $scope.phase = "READY_TO_DUPLICATE";
        $scope.checkoutModel.projectKey = sanitizeProjectKey($scope.projectSummary.projectKey + "_" + $scope.checkoutModel.targetBranchName);
        $scope.checkoutModel.projectName = $scope.projectSummary.name + " (" + $scope.checkoutModel.targetBranchName + ")";
        fixProjectKey($scope.checkoutModel.projectKey);
    };

    $scope.moveToSwitchPhase = function() {
        $scope.phase = "READY_TO_SWITCH";
        DataikuAPI.projects.checkDeletability($stateParams.projectKey).success(function(data) {
            if (data.anyMessage) {
                $scope.hasDependencyWarnings = true;
                $scope.dependencyWarnings = { messages : data.messages };
            }
        });
     };

    $scope.browse = folderIds => {
        return PromiseService.qToHttp($q(resolve => {
            const ids = folderIds.split('/');
            $scope.destination = ids[ids.length - 1];
            DataikuAPI.projectFolders.listContents($scope.destination, true, 1, true).success(data => {
                const folders = data.folder.children.map(f => angular.extend({}, f, { directory: true, fullPath: f.id }))
                const pathElts = treeToList(data.folder, item => item.parent);

                resolve({
                    children: folders,
                    pathElts: pathElts.map(f => angular.extend({}, f, { toString: () => f.id })),
                    exists: true,
                    directory: true,
                });
            }).error(setErrorInScope.bind($scope));
        }));
    };
    $scope.getProjectFolderName = item => item.name;

    $scope.createBranch = function() {
        DataikuAPI.projects.git.createBranch($stateParams.projectKey, $scope.checkoutModel.targetBranchName, $scope.checkoutModel.commitId).then(function () {
            $state.reload();
            $scope.dismiss();
        }, setErrorInScope.bind($scope));
    };

    $scope.switchBranch = function () {
        $scope.duplicateResponse = null;
        DataikuAPI.projects.git.switchBranch($stateParams.projectKey, $scope.checkoutModel.targetBranchName, $scope.checkoutModel.clearOutputDatasets).then(function (result) {
            var parentScope = $scope.$parent;
            $scope.dismiss();
            const success = result.data.commandSucceeded;
            const hasWarnOrErrorMessage = result.data.messages && (result.data.messages.warning || result.data.messages.error);
            const hasInfoMessages = result.data.messages && result.data.messages.messages.length > 1;
            const hasLogMessages = result.data.log && result.data.log.lines && result.data.log.lines.length > 2; // If everything went smoothly, we get 2 lines of logs.
            if (!success || hasWarnOrErrorMessage || hasInfoMessages || hasLogMessages) {
                Dialogs.infoMessagesDisplayOnly(parentScope, "Switch branch result", result.data.messages, result.data.log, true).then(function() {
                    if (success) {
                        $state.reload();
                    }
                }, null);
            } else {
                $state.reload();
            }
        }, setErrorInScope.bind($scope));
    };

    $scope.duplicate = function() {
        $scope.duplicateResponse = null;
        $scope.phase = 'DUPLICATING';
        $scope.dupOptions.targetProjectKey = $scope.checkoutModel.projectKey;
        $scope.dupOptions.targetProjectName = $scope.checkoutModel.projectName;
        $scope.dupOptions.createBranch = $scope.checkoutModel.createBranch;
        $scope.dupOptions.targetBranchName = $scope.checkoutModel.targetBranchName;
        $scope.dupOptions.commitId = $scope.checkoutModel.commitId;
        DataikuAPI.projects.startProjectDuplication(
            $scope.projectSummary.projectKey,
            $scope.dupOptions
        ).success(function(initialResponse){
            abortHook = function() {
                DataikuAPI.futures.abort(initialResponse.jobId).error(setErrorInScope.bind($scope));
            };
            FutureWatcher.watchJobId(initialResponse.jobId).success(function(data){
                abortHook = null;
                $scope.futureResponse = null;
                $scope.duplicateResponse = data.result;
                if (!data.aborted && (data.result.success || data.result.messages == null || data.result.messages.length === 0)) {
                    $scope.gotoResult();
                } else if ((data.result.warning || data.result.error) && !data.result.fatal) {
                    $scope.phase = "SHOW_WARNINGS";
                } else {
                    $scope.phase = "READY_TO_DUPLICATE";
                }
            }).update(function(data){
                $scope.percentage = ProgressStackMessageBuilder.getPercentage(data.progress);
                $scope.futureResponse = data;
                $scope.stateLabels = ProgressStackMessageBuilder.build($scope.futureResponse.progress, true);
            }).error(function(data, status, headers) {
                abortHook = null;
                $scope.futureResponse = null;
                $scope.duplicateResponse = null;
                $scope.phase = "READY_TO_DUPLICATE";
                setErrorInScope.bind($scope)(data, status, headers);
            })
        }).error(function(a,b,c){
            $scope.phase = 'READY_TO_DUPLICATE';
            setErrorInScope.bind($scope)(a,b,c);
            $scope.duplicateResponse = null;
        });
        WT1.event("projects-git-create-branch-and-duplicate", {
            duplicationMode: $scope.dupOptions.duplicationMode,
            exportAnalysisModels: $scope.dupOptions.exportAnalysisModels,
            exportSavedModels: $scope.dupOptions.exportSavedModels,
            exportModelEvaluationStores: $scope.dupOptions.exportModelEvaluationStores,
            exportInsightsData: $scope.dupOptions.exportInsightsData
        });
    };

    $scope.gotoResult = function() {
        $scope.dismiss();
        $state.transitionTo("projects.project.home.regular", {projectKey : $scope.checkoutModel.projectKey});
    };

    $scope.canSelect = item => item.canWriteContents;

    // Add watches
    $scope.$on("$destroy", function() {
        // cancel import if modal dismissed
        if (abortHook) {
            abortHook();
        }
    });
    $scope.$watch("checkoutModel.targetBranchName", function(newBranchName) {
        if ($scope.checkoutModel.createBranch) {
            if (doesBranchNameContainsInvalidCharacters(newBranchName)) {
                $scope.checkoutModel.branchNameError = true;
                $scope.checkoutModel.branchNameErrorMessage = "This branch name contains invalid characters.";
            } else if (isBranchNameAlreadyUsed(newBranchName)) {
                $scope.checkoutModel.branchNameError = true;
                $scope.checkoutModel.branchNameErrorMessage = "This branch name already exists.";
            } else {
                $scope.checkoutModel.branchNameError = false;
            }
        }
    });
    $scope.$watch("checkoutModel.projectName", fixProjectKey);
    $scope.$watch("checkoutModel.projectKey", function(newProjectKey) {
        $scope.checkoutModel.projectKeyAlreadyUsed = isProjectKeyAlreadyUsed(newProjectKey);
    });

    // Call backend to initialize form
    DataikuAPI.projects.listAllKeys()
        .success(function(data) {
            $scope.allProjectKeys = data;
            fixProjectKey($scope.checkoutModel.projectKey);
        })
        .error(setErrorInScope.bind($scope));

    DataikuAPI.projectFolders.listContents($scope.dupOptions.targetProjectFolderId === null ? '' : $scope.dupOptions.targetProjectFolderId, true, 1, true).success(data => {
        const pathElts = treeToList(data.folder, item => item.parent);
        $scope.dupFolder = angular.extend({}, data.folder, { pathElts: pathElts.map(f => f.name).join('/') });
    }).error(setErrorInScope.bind($scope));

});

app.controller("ProjectGitResetController", function($scope, $filter, $stateParams, DataikuAPI, ActivityIndicator, Dialogs, $state, WT1) {
    $scope.resetStrategy = $scope.getResetModes()[0];

    $scope.setStrategy = function(strategy) {
        if ($scope.getResetModes().includes(strategy)) {
            $scope.resetStrategy = strategy;
        }
    };

    $scope.gitReset = function() {
        const resetToUpstream = () => DataikuAPI.projects.git.resetToUpstream($stateParams.projectKey);
        const resetToHead = () => DataikuAPI.projects.git.resetToHead($stateParams.projectKey);
        const resetAPICall = $scope.resetStrategy === 'HEAD' ? resetToHead : resetToUpstream;

        resetAPICall().then(function () {
                ActivityIndicator.success('Reset succeeded.');
                $state.reload();
                $scope.dismiss();
                WT1.event("projects-git-reset", {resetStrategy: $scope.resetStrategy});
            },
            setErrorInScope.bind($scope));
    };
});

}());
(function(){
'use strict';

const app = angular.module('dataiku.projects.settings',[]);

//TODO: common controller
app.controller("ProjectSettingsVariablesController", function($scope, $stateParams, DataikuAPI, Logger, ActivityIndicator, TopNav) {
    TopNav.setLocation(TopNav.TOP_MORE, "variables", "NONE", null);
    $scope.projectVariables = {};

    function getSerialized() {
        return {
            standard : JSON.parse($scope.projectVariables.standardAsJSON || '{}'),
            local : JSON.parse($scope.projectVariables.localAsJSON || '{}')
        };
    }

    $scope.dirtyVariables = function() {
        if (!$scope.projectVariables.saved) {return false;}
        try {
            return !angular.equals(getSerialized(), $scope.projectVariables.saved);
        } catch (err) {
            Logger.error(err);
            return true; // Always dirty if invalid
        }
    };

    $scope.saveVariables = function(){
        try {
            var serialized = getSerialized();
            var gv = JSON.parse($scope.projectVariables.asJSON || '{}');
            return DataikuAPI.projects.variables.save($stateParams.projectKey, serialized).success(function(data) {
                $scope.projectVariables.saved = serialized;
                ActivityIndicator.success("Saved variables");
            }).error(setErrorInScope.bind($scope));
        } catch (err) {
            ActivityIndicator.error("Invalid format: "+err.message);
        }
    };

    DataikuAPI.projects.variables.get($stateParams.projectKey).success(function(data){
        $scope.projectVariables.saved = angular.copy(data);
        $scope.projectVariables.standardAsJSON = JSON.stringify(data.standard, null, 2);
        $scope.projectVariables.localAsJSON = JSON.stringify(data.local, null, 2);

    }).error(setErrorInScope.bind($scope));

    checkChangesBeforeLeaving($scope, $scope.dirtyVariables);
});

//TODO: common controller
app.controller("ProjectSettingsSettingsController", function($scope, $controller, $stateParams,$timeout, DataikuAPI, WT1, TopNav,
                                                             Dialogs, $q, ActivityIndicator,
                                                             ProjectIntegrations, FutureProgressModal, TaggingService, PluginConfigUtils) {

    $scope.uiState = {
        settingsPane : $stateParams.selectedTab || 'tags',
        selectedPlugin: null
    };

    $scope.sqlLikeRecipesInitializationModes = [
        ["RESOLVED_TABLE_REFERENCES", "Fully-resolved table references"],
        ["VARIABILIZED_TABLE_REFERENCES", "Table references with variables"],
        ["DATASET_REFERENCES", "Virtual dataset references"]
    ]
    $scope.sqlLikeRecipesInitializationModesDesc = [
        "Like MYPROJECT_mytable. The most 'understandable' form, it does not permit relocation to another project since the recipe will not 'follow'",
        "Like ${projectKey}_mytable. This form permits relocation to another project key, but does not support changing the name of the table in the datasets",
        "Like ${tbl:datasetName}. This is the most versatile form but is slightly less familiar for SQL developers"
    ]

    $scope.virtualWebAppBackendSettingsModes = [{id:"USE_DEFAULT", label:"Run as local processes"}, {id:"INHERIT", label:"Inherit instance-level settings"}, {id:"EXPLICIT", label:"Run in container"}];
    
    DataikuAPI.security.listUsers().success(function(data) {
        $scope.allUsers = data;
    }).error(setErrorInScope.bind($scope));

    var savedSettings = null;

    $scope.invalidTabs = new Set();

    $scope.$watch("uiState.settingsPane", function(nv, ov) {
        if (nv === ov) return;
        // We do not set 'Resource control' tab as invalid to avoid weird UI behavior. For this tab, a ng-model is not
        // changed if the new input value is not valid. Hence if a user exits the 'Resource control' tab with some
        // invalid fields and then switch back to it, the fields will no longer be invalid, which can be confusing.
        if ($scope.projectSettingsForms.$invalid && ov !== 'limits') {
            $scope.invalidTabs.add(ov);
        }
        $scope.invalidTabs.delete(nv);
    });

    $scope.isProjectSettingsFormInvalid = function() {
        return $scope.projectSettingsForms.$invalid || $scope.invalidTabs.size;
    }

    $scope.dirtySettings = function() {
        return !$scope.projectSettings
            || !angular.equals($scope.projectSettings.settings, savedSettings)
            || !angular.equals($scope.projectTagsMapDirty, $scope.projectTagsMap)
            || ($scope.originalPluginSettings !== null && !angular.equals($scope.originalPluginSettings, $scope.pluginSettings));
    };

    $scope.validIntegration = ProjectIntegrations.getValidity;

    loadSettings();

    function loadSettings() {
         DataikuAPI.projects.getSettings($stateParams.projectKey).success(function(projectSettings) {
             $scope.projectSettings = projectSettings;
             savedSettings = angular.copy($scope.projectSettings.settings);
             $scope.savedSettings = savedSettings;
         }).error(setErrorInScope.bind($scope));
    }

    // Settings mgmt
    $scope.saveSettings = function() {
        // filter out rules of exposed datasets where the projectKey is still null
        var settings = angular.copy($scope.projectSettings.settings);

        var promises = [];
        if (!angular.equals($scope.projectSettings.settings, savedSettings)) {
            promises.push(DataikuAPI.projects.saveSettings($stateParams.projectKey, settings).error(setErrorInScope.bind($scope)));
        }

        $q.all(promises).then(loadSettings).then($scope.refreshProjectData).then(() => {
            if (!$scope.validIntegration() || $scope.projectSettingsForms.$invalid) {
                ActivityIndicator.warning("Saved with some invalid fields");
            } else {
                ActivityIndicator.success("Saved!");
            }
        });

        TaggingService.saveToBackend($scope.projectTagsMapDirty).success(function() {
            $scope.projectTagsMap = angular.copy($scope.projectTagsMapDirty);
            $scope.$broadcast('projectSettingsSaved');
        });

        // Save plugins at project level by providing the project key
        $scope.dirtyPluginSettings() && $scope.savePluginSettings($stateParams.projectKey);
    };

    $scope.availableIntegrationTypes = ProjectIntegrations.integrationTypes;
    $scope.getIntegrationTypeLabel = function(type) {
        const integration = $scope.availableIntegrationTypes.find(element => element.id === type);
        return integration === undefined ? type : integration.label;
    };

    $scope.addIntegration = function(type) {
        WT1.event("project-integration-add", {type: type});
        var intConf = {};
        var integration = {
            active : true,
            hook : {
                type : type,
                configuration : intConf
            },
            $expanded:true
        };

        switch (type) {
            case "slack-project":
                intConf.mode = 'WEBHOOK';
                intConf.useProxy = true;
                intConf.selection = {
                    timelineEditionItems: true,
                    timelineItemsExceptEditions: true,
                    watchStar: true
                };
                break;
            case "msft-teams-project":
                intConf.useProxy = true;
                intConf.selection = {
                    timelineEditionItems: true,
                    timelineItemsExceptEditions: true,
                    watchStar: true
                };
                break;
        }

        $scope.projectSettings.settings.integrations.integrations.push(integration);
    };

    $scope.removeIntegration = function(index) {
        $scope.projectSettings.settings.integrations.integrations.splice(index, 1);
        ProjectIntegrations.removeIntegration(index);
    };

    $timeout(function() {
        checkChangesBeforeLeaving($scope, $scope.dirtySettings);
    });

    $scope.resyncHDFSDatasetPermissions = function(){
        DataikuAPI.projects.resyncHDFSDatasetPermissions($stateParams.projectKey).success(function(data){
            FutureProgressModal.show($scope, data, "ACLs sync").then(function(result){
                Dialogs.infoMessagesDisplayOnly($scope, "ACLs sync result", result);
            });
        });
    };
    
    DataikuAPI.admin.clusters.listAccessible('HADOOP').success(function(data){
        $scope.clusterIds = data.map(function(c) {return c.id;});
    }).error(setErrorInScope.bind($scope));

    DataikuAPI.admin.clusters.listAccessible('KUBERNETES').success(function(data){
        $scope.k8sClusterIds = data.map(function(c) {return c.id;});
    }).error(setErrorInScope.bind($scope));

    DataikuAPI.containers.listNames().success(function(data){
        $scope.containerNames = data;
    }).error(setErrorInScope.bind($scope));

    // Plugins presets
    $controller("PluginsExploreController", { $scope: $scope });
    $controller("PluginSettingsController", { $scope: $scope });

    $scope.refreshPluginsList = function() {
        DataikuAPI.plugins.listPluginsWithPresets().success(function(data) {
            $scope.projectPluginsList = { plugins: data };
        }).error(setErrorInScope.bind($scope));
    };

    $scope.selectPlugin = function(pluginId) {
        if (!pluginId) {
            return;
        }
        // Get plugin with project-level settings (by providing the project key)
        DataikuAPI.plugins.get(pluginId, $stateParams.projectKey).success(function(data) {
            $scope.pluginData = data;
            $scope.installed = data.installedDesc;

            if ($scope.installed.desc.params && data.settings.config) {
                PluginConfigUtils.setDefaultValues($scope.installed.desc.params, data.settings.config);
            }
            $scope.setPluginSettings(data.settings);
            $scope.uiState.selectedPlugin = data;
        }).error(setErrorInScope.bind($scope));
    };

    $scope.refreshPluginsList();

    TopNav.setLocation(TopNav.TOP_MORE, "settings", "NONE", "config");
});

app.service("ProjectIntegrations", function(){
    var validIntegrations = [];
    return {
        integrationTypes :[
            {"id" : "slack-project", "label" : "Slack"},
            {"id" : "msft-teams-project", "label" : "Microsoft Teams"},
            {"id" : "github", "label" : "Github"}
        ],
        getValidity : () => !validIntegrations.includes(false),
        setValidity : (index, flag) => {
            validIntegrations[index] = flag;
        },
        removeIntegration : (index) => validIntegrations.splice(index,1)
    };
});

app.directive("projectIntegrationEditor", function(ProjectIntegrations){
    return {
        scope : true,
        templateUrl : '/templates/projects/project-integration-editor.html',
        link : function($scope, element, attrs) {
            $scope.integrationTypes = ProjectIntegrations.integrationTypes;
        }
    }
});

app.directive("projectIntegrationParams", function(ProjectIntegrations){
    return {
        scope : {
            hook : '=',
            form : '=',
            index : '='
        },
        link : function($scope, element) {
            $scope.$watch("form.$valid", () => ProjectIntegrations.setValidity($scope.index, $scope.form.$valid)); 
        },
        templateUrl : '/templates/projects/project-integration-params.html',
    }
});

app.controller("NotificationsReporterController", function($scope, $timeout) {
    $scope.noStartMessage = $scope.noStartMessage || false;
    $scope.showItemHeader = $scope.showItemHeader == undefined || $scope.showItemHeader;

    $scope.conditionEditorOptions = {
            mode:'text/grel',
            theme:'elegant',
            indentUnit: 4,
            lineNumbers : false,
            lineWrapping : true,
            autofocus: true,
            onLoad : function(cm) {$scope.codeMirror = cm;}
        };

    // because otherwise the codemirror pops up shrunk when the ng-show on reporter.messaging.channelId changes state
    $scope.$watch("reporter.messaging.channelId", function() {
        if ( $scope.codeMirror ) {
            $timeout(function() {$scope.codeMirror.refresh();});
        }
    }, true);

    if ($scope.reporter.messaging == null) {
        $scope.reporter.messaging = {};
    }
});

/***********************************
 * Security
 ***********************************/

 //TODO: common controller
app.controller("ProjectSettingsSecurityController", function($scope, TopNav, $stateParams) {
    TopNav.setLocation(TopNav.TOP_MORE, "security", "NONE", null);
    $scope.uiState = {
        securityPane : $stateParams.selectedTab || 'permissions',
    };
    $scope.$watch("projectSummary", function(nv) {
        if (!nv || $stateParams.selectedTab) return;

        if ($scope.projectSummary.isProjectAdmin) {
            $scope.uiState.securityPane = "permissions";
        } else if ($scope.projectSummary.canManageDashboardAuthorizations) {
            $scope.uiState.securityPane = "dashboard";
        } else if ($scope.projectSummary.canManageAdditionalDashboardUsers) {
            $scope.uiState.securityPane = "dashboardUsers";
        } else {
            $scope.uiState.securityPane = "exposed";
        }
    });
})

app.controller("ProjectSettingsAPIController", function($scope, $stateParams,
               DataikuAPI, Dialogs,CreateModalFromTemplate) {

    $scope.canAPI = function(){
        if ($scope.appConfig.communityEdition && !$scope.appConfig.licensing.ceEntrepriseTrial) return false;
        if ($scope.appConfig.licensingMode == "SAAS") return false;
        return true;
    }

    $scope.refreshProjectApiKeysList = function() {
        DataikuAPI.projects.publicApi.listProjectApiKeys($stateParams.projectKey).success(function(data) {
            $scope.apiKeys = data;
        }).error(setErrorInScope.bind($scope));
    };


    $scope.createProjectApiKey = function() {
        CreateModalFromTemplate("/templates/projects/project-api-key-modal.html", $scope, null, function(newScope) {
            newScope.apiKey = {
                projectKey : $stateParams.projectKey,
                label : "New key",
                localDatasets : [ {
                    datasets : ['__rw__dataset1__', '__rw__dataset2__'],
                    privileges : [
                        'READ_DATA',
                        'WRITE_DATA',
                        'READ_METADATA',
                        'WRITE_METADATA',
                        'READ_SCHEMA',
                        'WRITE_SCHEMA'
                    ]
                }, {
                    datasets : ['__r__dataset__'],
                    privileges : [
                        'READ_DATA',
                        'READ_METADATA',
                        'READ_SCHEMA'
                    ]
                }],
                projectPrivileges : {
                    admin: false,
                    readProjectContent: true,
                    writeProjectContent: false,
                    exportDatasetsData: true,
                    readDashboards: true,
                    writeDashboard: false,
                    moderateDashboards: false,
                    runScenarios: false,
                    manageDashboardAuthorizations: false,
                    manageExposedElements: false,
                    executeApp: false
                },
                execSQLLike: false
            };
            newScope.creation = true;
        });
    };

    $scope.editProjectApiKey = function(key) {
        CreateModalFromTemplate("/templates/projects/project-api-key-modal.html", $scope, null, function(newScope) {
            newScope.apiKey = angular.copy(key);
            newScope.creation = false;
        });
    };

    $scope.deleteProjectApiKey = function(keyLabel) {
        Dialogs.confirm($scope, "Remove API key", "Are you sure you want to remove this API key?").then(function() {
            DataikuAPI.projects.publicApi.deleteProjectApiKey($stateParams.projectKey, keyLabel).success(function(data){
               $scope.refreshProjectApiKeysList();
            }).error(setErrorInScope.bind($scope));
        });
    };

    $scope.keyIsProjectAdmin = function(key) {
        return key && key.projectPrivileges && key.projectPrivileges.admin;
    };

    $scope.refreshProjectApiKeysList();
});


app.controller("ProjectSettingsPermissionsController", function($scope, $stateParams, DataikuAPI, Dialogs,
    ActivityIndicator, PermissionsService) {
    $scope.ui = {};
    
    function makeNewPerm(){
        $scope.newPerm = {
            writeProjectContent: true,
            exportDatasetsData: true
        }
    }
    makeNewPerm();

    $scope.isDirty = function() {
        return !angular.equals(lastProjectSettings,$scope.projectSettings);
    };
    checkChangesBeforeLeaving($scope, $scope.isDirty);

    let lastProjectSettings;
    DataikuAPI.security.listGroups(false).success(function(allGroups) {
        if (allGroups) {
            allGroups.sort();
        }
        $scope.allGroups = allGroups;
        DataikuAPI.security.listUsers().success(function(data) {
            $scope.allUsers = data;

            $scope.allUsers.sort(function(a, b){
                if (a.displayName < b.displayName) return -1;
                if (a.displayName > b.displayName) return 1;
                return 0;
            });

            DataikuAPI.projects.getSettings($stateParams.projectKey).success(function(projectSettings) {
                $scope.projectSettings = projectSettings;
                lastProjectSettings = angular.copy($scope.projectSettings);
                if ($scope.ui) {
                    $scope.ui.ownerLogin = projectSettings && projectSettings.owner;
                }
            }).error(setErrorInScope.bind($scope));
        }).error(setErrorInScope.bind($scope));
    }).error(setErrorInScope.bind($scope));

    $scope.save = function() {
        DataikuAPI.projects.savePermissions($stateParams.projectKey, $scope.projectSettings).success(function(data) {
            lastProjectSettings = angular.copy($scope.projectSettings);
            if (data.anyMessage) {
                Dialogs.infoMessagesDisplayOnly($scope, "Permissions update", data);
            }
            ActivityIndicator.success("Saved!");
        }).error(setErrorInScope.bind($scope));
    };

    $scope.addPermission = function() {
        $scope.projectSettings.permissions.push($scope.newPerm);
        makeNewPerm();
    };

    $scope.getUserDisplayName = function (login) {
        const user = $scope.allUsers.find(u => u.login === login);
        return user ? user.displayName : null;
    }

    $scope.$watch("projectSettings.permissions", function(nv, ov) {
        if (!nv) return;

        $scope.unassignedGroups = PermissionsService.buildUnassignedGroups($scope.projectSettings, $scope.allGroups);
        $scope.unassignedUsers = PermissionsService.buildUnassignedUsers($scope.projectSettings, $scope.allUsers);

        /* Handle implied permissions */
        $scope.projectSettings.permissions.forEach(function(p) {
            p.$readProjectContentDisabled = false;
            p.$writeProjectContentDisabled = false;
            p.$exportDatasetsDataDisabled = false;
            p.$readDashboardsDisabled = false;
            p.$writeDashboardsDisabled = false;
            p.$moderateDashboardsDisabled = false;
            p.$runScenariosDisabled = false;
            p.$manageDashboardAuthorizationsDisabled = false;
            p.$manageExposedElementsDisabled = false;
            p.$manageAdditionalDashboardUsersDisabled = false;
            p.$executeAppDisabled = false;
            
            if (p.admin) {
                p.$readProjectContentDisabled = true;
                p.$writeProjectContentDisabled = true;
                p.$exportDatasetsDataDisabled = true;
                p.$readDashboardsDisabled = true;
                p.$writeDashboardsDisabled = true;
                p.$moderateDashboardsDisabled = true;
                p.$runScenariosDisabled = true;
                p.$manageDashboardAuthorizationsDisabled = true;
                p.$manageExposedElementsDisabled = true;
                p.$manageAdditionalDashboardUsersDisabled = true;
                p.$executeAppDisabled = true;
            }
            if (p.writeProjectContent) {
                p.$readProjectContentDisabled = true;
                p.$readDashboardsDisabled = true;
                p.$writeDashboardsDisabled = true;
                p.$moderateDashboardsDisabled = true;
                p.$runScenariosDisabled = true;
                p.$executeAppDisabled = true;
            }
            if (p.readProjectContent) {
                p.$readDashboardsDisabled = true;
                p.$executeAppDisabled = true;
            }
            if (p.writeDashboards) {
                p.$readDashboardsDisabled = true;
            }
            if (p.moderateDashboards) {
                p.$readDashboardsDisabled = true;
                p.$writeDashboardsDisabled = true;
            }
        });

    }, true);

    // Ownership mgmt
    $scope.$watch("ui.ownerLogin", function() {
        PermissionsService.transferOwnership($scope, $scope.projectSettings, "project");
    });
    $scope.$watch("projectSettings.owner", function(newOwnerLogin) {
        if (! newOwnerLogin) return;
        // Remove individual permissions for this user, if any
        let i;
        while ((i = $scope.projectSettings.permissions.findIndex(p => p.user === newOwnerLogin)) >= 0) {
            $scope.projectSettings.permissions.splice(i, 1);
        }
        // Rebuild assignable users list
        $scope.unassignedUsers = PermissionsService.buildUnassignedUsers($scope.projectSettings, $scope.allUsers);
    });
});


app.controller("EditProjectAPIKeyModalController", function($scope, DataikuAPI) {
    $scope.create = function(){
        DataikuAPI.projects.publicApi.createProjectApiKey($scope.apiKey).success(function(data){
            $scope.dismiss();
            $scope.refreshProjectApiKeysList();
        }).error(setErrorInScope.bind($scope));
    };

    $scope.save = function(){
        DataikuAPI.projects.publicApi.saveProjectApiKey($scope.apiKey).success(function(data){
            $scope.dismiss();
            $scope.refreshProjectApiKeysList();
        }).error(setErrorInScope.bind($scope));
    };

    $scope.makeAdmin = function(key) {
        if (angular.isObject(key.projectPrivileges)) {
            key.projectPrivileges.admin = true;
            key.projectPrivileges = angular.copy(key.projectPrivileges);
        } else {
            key.projectPrivileges = {'admin': true};
        }
        key.localDatasets = [];
    };
});


app.factory("ProjectSettingsObjectsListService", function(DataikuAPI, $stateParams, Fn) {
    var svc = {
        addOnScope: function($scope) {
            var projectKey = $stateParams.projectKey;

            function idsAndNames(data) {
                return data.map(function(x){return [x.id, x.name]});
            }

            DataikuAPI.savedmodels.list(projectKey).success(function(data){
                $scope.savedModels = idsAndNames(data);
            });
            DataikuAPI.modelevaluationstores.list(projectKey).success(function(data){
                $scope.modelEvaluationStores = idsAndNames(data);
            });
            DataikuAPI.managedfolder.list(projectKey).success(function(data){
                $scope.managedFolders = idsAndNames(data);
            });
            DataikuAPI.webapps.list(projectKey).success(function(data){
                $scope.webApps = idsAndNames(data);
            });
            DataikuAPI.reports.list(projectKey).success(function(data){
                $scope.reports = idsAndNames(data);
            });

            DataikuAPI.datasets.listNames(projectKey).success(function(data){
                $scope.datasetNames = data;
            });

            DataikuAPI.jupyterNotebooks.listHeads(projectKey, {}).success(function(data){
                $scope.jupyterNotebooks = data.items.map(Fn.prop('name'));
            });

            DataikuAPI.projects.list().success(function(data) {
                $scope.projectsList = data;
            }).error(setErrorInScope.bind($scope));
        }
    }
    return svc;
})

app.controller("ProjectSettingsExposedController", function($scope, $state, $stateParams, $filter,
               DataikuAPI, WT1, TopNav, Dialogs, CreateModalFromTemplate, ActivityIndicator, EXPOSABLE_TYPES) {

    $scope.exposableTypes = EXPOSABLE_TYPES;

    // object links
    $scope.openObject = function(object) {
        switch (object.type) {
            case 'DATASET':
                $state.go('projects.project.datasets.dataset.explore',{datasetName: object.localName});
                break;
            case 'SAVED_MODEL':
                $state.go('projects.project.savedmodels.savedmodel.versions',{smId: object.localName});
                break;
            case 'MODEL_EVALUATION_STORE':
                $state.go('projects.project.modelevaluationstoress.modelevaluationstores.versions',{mesId: object.localName});
                break;
            case 'MANAGED_FOLDER':
                $state.go('projects.project.managedfolders.managedfolder.view',{odbId: object.localName});
                break;
            case 'JUPYTER_NOTEBOOK':
                $state.go('projects.project.notebooks.jupyter_notebook',{notebookId: object.localName});
                break;
            case 'WEB_APP':
                $state.go('projects.project.webapps.webapp.view',{webAppId: object.localName, webAppName:$filter('slugify')(object.displayName)});
                break;
            case 'REPORT':
                $state.go('projects.project.reports.report.view',{reportId: object.localName});
                break;
            case 'SCENARIO':
                $state.go('projects.project.scenarios.scenario.steps',{scenarioId: object.localName});
                break;
        }
    };

    function removeItemFromArray(item, arr) {
        var idx = arr.indexOf(item);
        if (idx > -1) {
            arr.splice(idx, 1);
        }
    }

    $scope.uiState = $scope.uiState || {};
    $scope.uiState.view = 'objects';

    $scope.newSource = {};
    $scope.projects = [];

    // Global indices to disable existing objects / projects when adding to list (per-object and per-project indices are stored on the object/project itself)
    $scope.projectsIndex = {};
    $scope.objectsIndex = {};

    if ($stateParams.projectKey) {
        $scope.projectsIndex[$stateParams.projectKey] = true;
    }

    // Caches for object-picker objects
    $scope.available = {};

    function loadSettings() {
        DataikuAPI.projects.getEnrichedExposedObjects($stateParams.projectKey, true).success(function(exposedObjects) {
            $scope.exposedObjects = exposedObjects;
            $scope.origExposedObjects = dkuDeepCopy($scope.exposedObjects, function(key) { return !key.startsWith('$'); });

            $scope.exposedObjects.objects.forEach(function(object) {
                object.$open = object.rules.length == 0;
                for (var i = 0; i < object.rules.length; i++) {

                    var project = object.rules[i];
                    if (!$scope.projectsIndex[project.targetProject]) {
                        $scope.projectsIndex[project.targetProject] = project;
                        $scope.projects.push(project);
                    } else {
                        project = $scope.projectsIndex[project.targetProject];
                        object.rules[i] = project;
                    }

                    $scope.getProjectKeysForObject(object)[project.targetProject] = true;
                    $scope.getObjectsForProject(project).push(object);
                    $scope.getObjectIdsForProject(project, object.type)[object.localName] = true;
                }
                $scope.getObjectsIndex(object.type)[object.localName] = object;
            });
            $scope.projects.forEach(function(project){
                project.$open = project.$exposedObjects.length == 0;
            });
        }).error(setErrorInScope.bind($scope));
    }

    loadSettings();

    $scope.saveAndMaybePerformChanges = function() {
        var copy = dkuDeepCopy($scope.exposedObjects, function(key) { return !key.startsWith('$'); });
        DataikuAPI.projects.saveExposedObjects($stateParams.projectKey, $scope.exposedObjects).success(function(){
            ActivityIndicator.success("Saved!");
            $scope.origExposedObjects = copy;
        }).error(setErrorInScope.bind($scope));
    };

    $scope.isDirty = function() {
        return !angular.equals($scope.exposedObjects, $scope.origExposedObjects);
    };
    checkChangesBeforeLeaving($scope, $scope.isDirty);

    $scope.addObject = function(newObject) {
        if (!newObject) return
        var object = {
            type: newObject.type,
            localName: newObject.id,
            displayName: newObject.label,
            rules: [],
            $open: true
        };
        $scope.exposedObjects.objects.push(object);
        $scope.getObjectsIndex(object.type)[object.localName] = object;
    };

    $scope.addProject = function(newProject) {
        var project = {
            targetProject : newProject.id,
            targetProjectDisplayName: newProject.label,
            appearOnFlow : true,
            $exposedObjects: [],
            $open: true
        };

        $scope.projects.push(project);
        $scope.projectsIndex[project.targetProject] = project;
    };

    $scope.removeObject = function(object) {
        // Remove from every project
        $scope.getProjectsForObject(object).forEach(function(project) {
            $scope.removeRule(project, object);
            if (!$scope.getObjectsForProject(project).length) {
                $scope.removeProject(project);
            }
        });

        removeItemFromArray(object, $scope.exposedObjects.objects);
        delete $scope.getObjectsIndex(object.type)[object.localName];
    };

    $scope.removeProject = function(project) {
        // Remove from every object
        $scope.getObjectsForProject(project).forEach(function(object) {
            $scope.removeRule(project, object);
            if (!$scope.getProjectsForObject(object).length) {
                $scope.removeObject(object);
            }
        });

        removeItemFromArray(project, $scope.projects);
        delete $scope.projectsIndex[project.targetProject];
    };

    $scope.addObjectToProject = function(newObject, project) {
        if (!$scope.getObjectsIndex(newObject.type)[newObject.id]) {
            $scope.addObject(newObject);
        }

        var object = $scope.getObjectsIndex(newObject.type)[newObject.id];
        $scope.addRule(project, object);
    };

    $scope.addProjectToObject = function(newProject, object) {
        if (!$scope.projectsIndex[newProject.id]) {
            $scope.addProject(newProject);
        }

        var project = $scope.projectsIndex[newProject.id];
        $scope.addRule(project, object);
    };

    $scope.addRule = function(project, object) {
        $scope.getProjectsForObject(object).push(project);
        $scope.getProjectKeysForObject(object)[project.targetProject] = true;
        $scope.getObjectsForProject(project).push(object);
        $scope.getObjectIdsForProject(project, object.type)[object.localName] = true;
    };

    $scope.removeRule = function(project, object) {
        removeItemFromArray(project, $scope.getProjectsForObject(object));
        removeItemFromArray(object, $scope.getObjectsForProject(project));

        delete $scope.getProjectKeysForObject(object)[project.targetProject];
        delete $scope.getObjectIdsForProject(project, object.type)[object.localName];
    };


    // Getters with empty defaults for object lists / maps

    $scope.getProjectsForObject = function(object) {
        if (!object.rules) {
            object.rules = [];
        }
        return object.rules;
    };

    $scope.getProjectKeysForObject = function(object) {
        if (!object.$targetProjectKeys) {
            object.$targetProjectKeys = {};
            if ($stateParams.projectKey) {
                object.$targetProjectKeys[$stateParams.projectKey] = true;
            }
        }
        return object.$targetProjectKeys;
    };

    $scope.getObjectsForProject = function(project) {
        if (!project.$exposedObjects) {
            project.$exposedObjects = [];
        }
        return project.$exposedObjects;
    };

    $scope.getObjectIdsForProject = function(project, objectType) {
        if (!project.$exposedObjectIds) {
            project.$exposedObjectIds = {};
        }
        if (!project.$exposedObjectIds[objectType]) {
            project.$exposedObjectIds[objectType] = {};
        }
        return project.$exposedObjectIds[objectType];
    };

    $scope.getObjectsIndex = function(objectType) {
        if (!$scope.objectsIndex[objectType]) {
            $scope.objectsIndex[objectType] = {};
        }
        return $scope.objectsIndex[objectType];
    };

});

app.controller("ProjectSettingsDashboardController", function($scope, $stateParams, $timeout,
        DataikuAPI, ActivityIndicator, SmartId, ProjectSettingsObjectsListService, EXPOSABLE_TYPES) {

    ProjectSettingsObjectsListService.addOnScope($scope);

    $scope.exposableTypes = EXPOSABLE_TYPES;

    function loadSettings() {
        DataikuAPI.projects.getDashboardAuthorizations($stateParams.projectKey, true).success(function(authorizations) {

            $scope.dashboardAuthorizations = authorizations;
            $scope.initialDashboardAuthorizations = angular.copy($scope.dashboardAuthorizations);

            $scope.readerAuthorizationsByType = {};
            $scope.dashboardAuthorizations.authorizations.forEach(function(ref) {
                if (!$scope.readerAuthorizationsByType[ref.objectRef.objectType]) {
                    $scope.readerAuthorizationsByType[ref.objectRef.objectType] = [SmartId.fromRef(ref.objectRef)];
                } else {
                    $scope.readerAuthorizationsByType[ref.objectRef.objectType].push(SmartId.fromRef(ref.objectRef));
                }
            });
            $timeout(function(){
                $scope.$broadcast('redrawFatTable')
            });
        }).error(setErrorInScope.bind($scope));
    }

    loadSettings();

    $scope.saveAuthorizations = function() {
        DataikuAPI.projects.saveDashboardAuthorizations($stateParams.projectKey, $scope.dashboardAuthorizations).success(function(){
            ActivityIndicator.success("Saved!");
            $scope.initialDashboardAuthorizations = angular.copy($scope.dashboardAuthorizations);
        }).error(setErrorInScope.bind($scope));
    }

    $scope.newSource = {
        modes: ['READ'],
        type: null
    };

    $scope.isDashboardAuthorizationDirty = function() {
        return !angular.equals($scope.dashboardAuthorizations, $scope.initialDashboardAuthorizations);
    }
    checkChangesBeforeLeaving($scope, $scope.isDashboardAuthorizationDirty);

    $scope.addReaderAuthorization = function(object) {
        if ($scope.dashboardAuthorizations.allAuthorized || !object || !object.id
            || ($scope.readerAuthorizationsByType[object.type] || []).indexOf(object.smartId) != -1) {
            return;
        }

        var readerAuth = {
            modes: angular.copy($scope.newSource.modes),
            objectRef: {
                objectId: object.id,
                objectType: object.type,
                objectDisplayName: object.label
            }
        };

        if (!object.localProject) {
            readerAuth.objectRef.projectKey = object.projectKey;
        }

        $scope.dashboardAuthorizations.authorizations.push(readerAuth);

        if (!$scope.readerAuthorizationsByType[readerAuth.objectRef.objectType]) {
            $scope.readerAuthorizationsByType[readerAuth.objectRef.objectType] = [SmartId.fromRef(readerAuth.objectRef)];
        } else {
            $scope.readerAuthorizationsByType[readerAuth.objectRef.objectType].push(SmartId.fromRef(readerAuth.objectRef));
        }

        $scope.clearFilters();
        $timeout(function(){
            $scope.$broadcast('redrawFatTable');
            $scope.$broadcast('scrollToLine', -1);
        },10); // wait for clearfilters
    };

    $scope.removeReaderAuthorization = function(ref) {
        var idx1 = $scope.dashboardAuthorizations.authorizations.indexOf(ref);
        $scope.dashboardAuthorizations.authorizations.splice(idx1, 1);
        var idx2 = $scope.readerAuthorizationsByType[ref.objectRef.objectType].indexOf(SmartId.fromRef(ref.objectRef));
        if (idx2 > -1) {
            $scope.readerAuthorizationsByType[ref.objectRef.objectType].splice(idx2, 1);
        }
    };
    $scope.removeReaderAuthorizations = function(refs) {
        refs.forEach(function(ref) {
            $scope.removeReaderAuthorization(ref);
        })
    };

    $scope.getReaderAuthUrl = function(readerAuth) {
        if (readerAuth&&$stateParams.projectKey) {
            return $scope.$root.StateUtils.href.dssObject(readerAuth.objectRef.objectType, SmartId.fromRef(readerAuth.objectRef))
        } else {
            return "";
        }
    }
    $scope.isDisabledReaderAuth = function(selection,mode) {
        if (!selection || !selection.selectedObjects) {return false;}
        return selection.selectedObjects.map(function(o){
            return ($scope.availableModesForType[o.objectRef.objectType] || []).indexOf(mode) === -1;
        }).reduce(function(a,b){return a&&b},true);
    }

    $scope.isAllReaderAuth = function(selection, mode) {
        if (!selection || !selection.selectedObjects) {return false;}
        return selection.selectedObjects.filter(function(o){
            return ($scope.availableModesForType[o.objectRef.objectType] || []).indexOf(mode) > -1
        }).map(function(o){
            return (o.modes.indexOf(mode) > -1)
        }).reduce(function(a,b){return a&&b},true);
    }
    $scope.setReaderAuth = function(objects, val, mode) {
        objects.forEach(function(o){
            if (($scope.availableModesForType[o.objectRef.objectType] || []).indexOf(mode) > -1) {
                if (val&&o.modes.indexOf(mode)===-1) {
                    o.modes.push(mode);
                }
                if (!val&&o.modes.indexOf(mode)>-1) {
                    o.modes.splice(o.modes.indexOf(mode),1);
                }
            }
        });
    }

    $scope.setNewSourceType = function(sourceType) {
        $scope.newSourceType = sourceType;
        this.hidePopover();
    }

    $scope.availableModesForType = {
        'DATASET':  ['READ', 'WRITE'],
        'SCENARIO': ['READ', 'RUN']
    };
    $scope.$watch("newSource.type", function(nv) {
       if (!nv) return;
       $scope.availableReaderAuthModes = $scope.availableModesForType[nv] || ['READ'];
       $scope.newSource.modes = ['READ'];
    });
});

app.controller("ProjectSettingsDashboardUsersController", function($scope, $stateParams,$timeout, DataikuAPI, ActivityIndicator) {

    function loadSettings() {
        DataikuAPI.projects.getAdditionalDashboardUsers($stateParams.projectKey).success(function(data) {
            $scope.additionalDashboardUsers = data;
            $scope.initialAdditionalDashboardUsers = angular.copy($scope.additionalDashboardUsers);
            $timeout(function(){
                $scope.$broadcast('redrawFatTable')
            });
        }).error(setErrorInScope.bind($scope));

        DataikuAPI.security.listUsers().success(function(data) {
            $scope.userLogins = data.map(function(x) { return x.login });
        }).error(setErrorInScope.bind($scope));
    }

    loadSettings();

    $scope.save = function() {
        DataikuAPI.projects.saveAdditionalDashboardUsers($stateParams.projectKey, $scope.additionalDashboardUsers).success(function(){
            ActivityIndicator.success("Saved!");
            $scope.initialAdditionalDashboardUsers = angular.copy($scope.additionalDashboardUsers);
        }).error(setErrorInScope.bind($scope));
    }

    $scope.isDirty = function() {
        return !angular.equals($scope.additionalDashboardUsers, $scope.initialAdditionalDashboardUsers);
    }
    checkChangesBeforeLeaving($scope, $scope.isDirty);

    $scope.add = function() {
        $scope.additionalDashboardUsers.users.push({
            login: ""
        });
        $scope.clearFilters();
        $timeout(function(){
            $scope.$broadcast('redrawFatTable');
            $scope.$broadcast('scrollToLine', -1);
        },10); // wait for clearfilters
    };

    function removeOne(user) {
        var idx = $scope.additionalDashboardUsers.users.indexOf(user);
        if (idx >= 0) {
            $scope.additionalDashboardUsers.users.splice(idx, 1);
        }
    }

    $scope.remove = function(users) {
        users.forEach(removeOne);
    }
});


// expects dates corresponding to UTC days
app.directive("weekDayHeatmap", function(Fn){
    function previousSunday(date) { return d3.time.week.utc(date); }
    function niceDate(date, year) {
        return date.toUTCString().replace(/^\w+,? 0?(\d+) (\w+) (\d+) .+$/,
            year ? '$2 $1, $3' : '$2 $1');
    }

    function monthTickFormat(date) {
        var endOfWeek = new Date(date.getTime() + 7*24*60*60*1000);
        var range = d3.time.days.utc(date, endOfWeek);
        for (var i = 0; i < range.length; i++) {
            if (range[i].getDate() == 1) {
                return range[i].toUTCString().replace(/^\w+,? 0?(\d+) (\w+) (\d+) .+$/, '$2').toUpperCase();
            }
        }
        return '';
    }

    return {
        scope: { data: '=', formatter: '=?', light: '=?'},
        require: ['?svgTitles'],
        link: function(scope, element, attrs, controllers) {
            var itemSize = 16, // ajusted for project summary (1 year w/o scroll @ 925px container)
                gap = 2,
                cellSize = itemSize - gap,
                margin = scope.light ? {top:15,right:0,bottom:0,left:0} : {top:40,right:20,bottom:20,left:30},
                data = [],
                weeks = 0,
                dayScale = d3.scale.ordinal().domain([0, 1, 2, 3, 4, 5, 6])
                    .rangeBands([0, 7 * itemSize - gap], gap / (7 * itemSize - gap), 0),
                weekScale = d3.scale.ordinal(),
                heatScale = d3.scale.linear().range(['#bbdefb', '#0a69b5']),
                svg = d3.select(element.get(0)),
                svgTitles = controllers[0],
                minWidth = 140;

            scope.$watch('data', function() {
                svg.selectAll('g').remove();
                data = scope.data && scope.data.length ? scope.data.concat() : [{date: new Date(), value:0}];
                data.sort(function(a, b) { return Fn.CMP(a.date, b.date); });

                weeks = d3.time.weeks.utc(data[0].date, data[data.length-1].date).length + 1;
                var previousSundayOfDate = previousSunday(data[0].date);
                var weekDomain = [];
                for (var i=0;i<weeks;i++) {weekDomain.push(previousSundayOfDate);}
                weekScale = weekScale.domain(
                        weekDomain
                            .map(function(first, i){ return d3.time.week.utc.offset(first, i); })
                    ).rangeBands([0, weeks * itemSize - gap], gap / (weeks * itemSize - gap), 0);
                heatScale = heatScale.domain([d3.min(data.map(Fn.prop('value'))), d3.max(data.map(Fn.prop('value')))]);

                var xAxis = d3.svg.axis().orient('top').scale(weekScale)
                        .tickFormat(function(d){ return scope.light ? monthTickFormat(new Date(d)) : niceDate(new Date(d), false); }),
                    yAxis = d3.svg.axis().orient('left').scale(dayScale).tickSize(1)
                        .tickFormat(Fn.from(['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'])),
                    years = weeks > 26,
                    width  = Math.max(minWidth, xAxis.scale().rangeExtent()[1] + margin.left + margin.right),
                    height = yAxis.scale().rangeExtent()[1] + margin.top + margin.bottom + (years ? 16 : 0);
                svg .attr('viewBox', [0, 0, width, height].join(' '))
                    .attr('width', width).attr('height', height)
                    .classed('crisp-edges svg-defaults', true);

                svg.selectAll("text").remove();
                svg.selectAll("defs").remove();

                //declaring diagonal stripes pattern
                svg.append('defs').append('pattern')
                    .attr("id","pattern-stripes")
                    .attr("width","4")
                    .attr("height","4")
                    .attr("patternUnits","userSpaceOnUse")
                    .attr("patternTransform","rotate(45)")
                    .append("rect")
                        .attr("width","2")
                        .attr("height","4")
                        .attr("transform","translate(0,0)")
                        .attr("fill","#eee")

                //render axes
                svg.append('g')
                    .attr('transform','translate('+margin.left+','+margin.top+')')
                    .attr('class','x axis')
                    .call(xAxis)
                if (scope.light) {
                    svg.selectAll('g.tick text').style("text-anchor", "start").attr('transform', 'translate('+ -cellSize/2 +','+ xAxis.innerTickSize() +')');
                } else {
                    svg.selectAll('g.tick text').attr('transform', 'translate(18,-8) rotate(-45)');
                }
                if (years) {
                    var extent = d3.extent(weekScale.domain());
                    extent[1] = d3.time.week.utc.offset(extent[1], 1);   // end of axis = last week + 1
                    var yearScale = d3.time.scale.utc().domain(extent).range(weekScale.rangeExtent());
                    svg.append('g')
                        .attr('transform','translate('+margin.left+','+ (height - margin.bottom - 18) +')')
                        .attr('class','x axis')
                        .call(d3.svg.axis().orient('bottom').scale(yearScale)
                            .tickValues(yearScale.ticks(d3.time.year.utc, 1).map(d3.time.week.utc.ceil))
                            .tickFormat(d3.time.format('%Y')));
                }
                if (!scope.light) {
                    svg.append('g')
                        .attr('transform','translate(' + margin.left + ',' + margin.top + ')')
                        .attr('class','y axis')
                        .call(yAxis);
                }
                svg.selectAll('path.domain, g.tick line').remove();

                svg.append('g')
                    .attr('transform','translate(' + (margin.left + gap) + ',' + (margin.top + gap) + ')')
                    .attr('class','heatmap')
                    .selectAll('rect').data(data).enter().append('rect')
                        .attr('width', cellSize)
                        .attr('height', cellSize)
                        .attr('x', Fn(Fn.prop('date'), previousSunday, weekScale))
                        .attr('y', Fn(Fn.prop('date'), Fn.method('getUTCDay'), dayScale))
                        .attr('fill', function(d) {
                            if (d.value === 0) {
                                return '#eee';
                            } else if (d.value === -1) { //meaning project did not exist at this time
                                return 'url(#pattern-stripes)';
                            } else {
                                return heatScale(d.value);
                            }
                        })
                        .attr('data-title', function(d) {
                            return d.value === -1 ? "Project did not exist on {0}".format(niceDate(d.date, true)) : "<strong>{0}</strong> on {1}".format((scope.formatter || Fn.SELF)(d.value), niceDate(d.date, true));
                        });

                if (svgTitles) {
                    svgTitles.update();
                }

                //If no activity at all adding overlaying text entitled 'No activity'
                var noActivity = data.every(function(d) {
                    return d.value <= 0;
                });

                if (noActivity) {
                    svg.append('text')
                        .attr('transform','translate(' + margin.left + ',' + margin.top + ')')
                        .attr('x', (width - margin.left - margin.right)/2)
                        .attr('y', (height - margin.top - margin.bottom)/2)
                        .attr("alignment-baseline", "middle")
                        .attr("text-anchor", "middle")
                        .attr("style", "text-transform:uppercase")
                        .attr("fill", "#999")
                        .text("no activity");
                }
            });
        }
    };
});



app.directive("simpleTimeAreaChart", function(Fn, NumberFormatter){

    return {
        scope: { ts: '=', values: '=', scale: '=?', color: '@?', width: '@?', height: '@?' },
        link: function(scope, element, attrs, controllers) {
            var margin = {top:20,right:20,bottom:30,left:40},
                svg = d3.select(element.get(0)),
                height, width;

            var tScale = d3.time.scale(),
                yScale = d3.scale.linear(),
                viz = svg.append('g').attr('transform','translate(' + margin.left + ',' + margin.top + ')'),
                xAxis = d3.svg.axis().orient('bottom').scale(tScale).outerTickSize(0),
                yAxis = d3.svg.axis().orient('left').scale(yScale).ticks(3),
                yAxisG = viz.append('g').attr('class','y axis crisp-edges').style('stroke', '#bdbdbd'),
                area = viz.append('g').attr('class', 'area').append('path').attr('fill', scope.color || '#64B5F6'),
                xAxisG = viz.append('g').attr('class','x axis crisp-edges stroke-cc').style('color', '#bdbdbd');

            var resize = function() {
                height = scope.height == '100%' ? element.parent().height() : (parseInt(scope.height) || 160);
                width = scope.width === '100%' ? element.parent().width() : (parseInt(scope.width) || 400);

                svg .attr('viewBox', [0, 0, width, height].join(' '))
                    .attr('width', width).attr('height', height)
                    .classed('svg-defaults', true);

                xAxisG.attr('transform','translate(0,' + (height - margin.bottom - margin.top) + ')');
                xAxis.ticks(width/100);
                yAxis.tickSize(-width + margin.left + margin.right, 0);
            };

            resize();
            scope.$on('resize', function() {
                resize();
                draw();
            });


            var draw = function() {
                if (!scope.ts || !scope.ts.length || !scope.values.length) return;

                var xs = scope.ts,
                    ys = scope.values;

                tScale.domain([d3.min(xs, Fn.method('valueOf')), d3.max(scope.ts, Fn.method('valueOf'))])
                      .range([0, width - margin.left - margin.right]);

                yScale.range([height - margin.top - margin.bottom, 0]);

                if (d3.time.weeks.utc.apply(null, tScale.domain()).length > 4) {
                    // aggregate by week to avoid jigsaw graph
                    xs = xs.map(d3.time.week.utc).filter(Fn(Fn.method('valueOf'), Fn.unique()));
                    ys = xs.map(Fn.cst(0));
                    scope.values.forEach(function(y, i) {
                        ys[this.indexOf(d3.time.week.utc(scope.ts[i]).valueOf())] += y;
                    }, xs.map(Fn.method('valueOf')));
                    xs = xs.map(d3.time.thursday.utc.ceil); // place data points on thursdays, 12am (~middle of the week)
                    tScale.domain([d3.min(xs, Fn.method('valueOf')), d3.max(xs, Fn.method('valueOf'))]); // readjust axis
                }

                yScale.domain([d3.min(ys.concat(0)), d3.max(ys)]);
                if (typeof scope.scale === 'function') { // scale callback from computed scale
                    yScale.domain(scope.scale(yScale.domain().concat()));
                } else if (scope.scale) {   // fixed
                    yScale.domain(scope.scale);
                }

                NumberFormatter.addToAxis(yAxis);
                yAxisG.transition().call(yAxis);
                yAxisG.selectAll('path.domain').remove();

                area.datum(xs.map(Fn.INDEX))
                    .transition()
                    .attr('d', d3.svg.area().x(Fn(Fn.from(xs), tScale))
                        .y0(yScale.range()[0])
                        .y1(Fn(Fn.from(ys), yScale))
                        .interpolate("monotone"));

                xAxisG.call(xAxis);
                xAxisG.select('path.domain').style('stroke', 'black');
       };

            scope.$watch('values', draw);
        }
    };
});

app.directive("weekPunchCard", function(Fn){
    return {
        scope: { data: '=' }, // data: 7 by 24 numbers array
        link: function(scope, element, attrs) {
            scope.cellSize = scope.cellSize || 25;
            if (!scope.data || !scope.data.length) return;

            var rowHeight = 50,
                colWidth = 35,
                margin = {top: 0, right: 20, bottom: 20, left: 75},
                vizWidth = 24 * colWidth,
                vizHeight = 7 * rowHeight,
                data = scope.data.concat(),
                xScale = d3.scale.ordinal().domain(Array.range(24)).rangeRoundBands([0, vizWidth], 0.1, 0),
                yScale = d3.scale.ordinal().domain(Array.range(7)).rangeRoundBands([0, vizHeight], 0.1, 0),
                maxRadius = Math.min(xScale.rangeBand()/ 2, yScale.rangeBand()/2),
                sizeScale = d3.scale.sqrt().range([2, maxRadius]).domain([0, d3.max(data, Fn.passFirstArg(d3.max))]),
                svg = d3.select(element.get(0)),
                viz = svg.classed('svg-defaults', true).style('color', '#ccc')
                    .attr('viewBox', [0, 0, vizWidth + margin.left + margin.right, vizHeight + margin.top + margin.bottom].join(' '))
                    .append("g")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            /* Draw x axis */
            var xAxis = d3.svg.axis().scale(xScale)
                .tickSize(0)
                .tickFormat(function(d) { return (d % 12 || 12) + (d > 12 ? 'p': 'a'); });
            viz.append("g").call(xAxis)
                .attr('class', 'x axis crisp-edges')
                .attr('transform', 'translate(0,' + vizHeight + ')')
                .select('.domain').remove();

            /* Draw all horizontal lines with ticks */
            var evenHoursAxis = d3.svg.axis().scale(xScale)
                .orient('top')
                .tickFormat('')
                .tickSize(0.1 * scope.cellSize, 0)
                .tickValues(Array.range(12).map(function(_, i) { return 2*i; }));
            var oddHoursAxis = d3.svg.axis().scale(xScale)
                .orient('top')
                .tickFormat('')
                .tickSize(0.2 * scope.cellSize, 0)
                .tickValues(Array.range(12).map(function(_, i) { return 2*i + 1; }));
            var xLines = viz.append("g")
                .attr('class', 'line axis stroke-cc crisp-edges')
                .selectAll('g.line').data(data).enter()
                    .append('g')
                    .attr('transform', function(d,i) { return 'translate(0, ' + (yScale(i) + yScale.rangeBand()) + ')'; });
            xLines.append('g').call(evenHoursAxis);
            xLines.append('g').call(oddHoursAxis);

            // move all ticks to the left by half a column so that circle are in-between full hours
            viz.selectAll('.tick').each(function() { // may already have transform
                this.setAttribute('transform', 'translate(-' + (colWidth/2) + ', 0) ' + this.getAttribute('transform'));
            });

            /* Draw day labels on the left and extend horizontal lines */
            var yLabels = svg.append("g")
                .attr("class", "day-labels stroke-cc crisp-edges")
                .selectAll("g")
                    .data(['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'])
                    .enter().append("g").attr('class', 'y axis');
            yLabels.append('text')
                .text(Fn.SELF)
                .attr('x', 5)
                .attr('y', function(d,i) { return yScale(i) + yScale.rangeBand() * 0.55; });
            yLabels.append('line')
                .attr('x1', 5)
                .attr('x2', margin.left)
                .attr('y1', function(d,i) { return yScale(i) + yScale.rangeBand(); })
                .attr('y2', function(d,i) { return yScale(i) + yScale.rangeBand(); });

            /* Draw circles */
             var circles = viz.selectAll('g.day').data(data).enter().append('g')
                .attr('class', 'day')
                .attr('transform', function (d, i) { return 'translate(0, ' + (yScale(i) + yScale.rangeBand()/2 - 0.1 * scope.cellSize) + ')'; })
                .selectAll('circle').data(Fn.SELF).enter().append('circle')
                    .attr('cx', function(d, i, j) { return xScale(i) + xScale.rangeBand()/2; })
                    .attr('r', sizeScale)
                    .attr('fill', 'grey').classed('hover-fill', true)
                    .attr('data-title', function(d) { return "{0} commit{1}".format(d, d > 1 ? "s" : ""); });
        }
    }
});

app.directive("userLeaderboard", function(Fn, $state, UserImageUrl){
    return {
        scope: { data: '=', prop: '=?' },
        require: ['?svgTitles'],
        link: function(scope, element, attrs, controllers) {

            var margin = {top: 10, right: 20, bottom: 40, left: 40},
                vizHeight = 120,
                barWidth = 24,
                padding = 5,
                vizMaxWidth = 800,
                maxBars = vizMaxWidth / (barWidth + padding),
                xScale = function(i) { return padding + (padding + barWidth) * i; },
                yScale = d3.scale.linear().range([vizHeight, 0]),
                svg = d3.select(element.get(0)).classed('svg-defaults crisp-edges', true),
                svgTitles = controllers[0],
                format = d3.format('.3s');

            /* Draw x axis */

            function redraw() {
                svg.select('g').remove();

                if (!scope.data || !scope.prop || !scope.data.length || !(scope.prop in scope.data[0])) return;

                var extract = Fn.prop(scope.prop),
                    n = Math.min(maxBars, scope.data.length),
                    vizWidth = n * (barWidth + padding),
                    svgWidth = vizWidth + margin.left + margin.right,
                    sorted = scope.data.concat(),
                    viz = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                sorted.sort(function(a,b) { // descending order
                    return extract(a) > extract(b) ? -1 : (extract(a) < extract(b)) ? 1 : 0;
                });
                sorted = sorted.slice(0, n);

                viz.append('clipPath').attr('id', 'user-clip-path')
                    .append('circle').attr('cx', barWidth/2).attr('cy', barWidth/2).attr('r', barWidth/2).attr('fill', 'black');

                svg .attr('viewBox', [0, 0, svgWidth, vizHeight + margin.top + margin.bottom].join(' '))
                    .attr('width', svgWidth);
                yScale.domain([0, Math.max(1, d3.max(sorted, extract))]);
                var yAxis = d3.svg.axis().scale(yScale).orient('left').tickSize(-vizWidth, 0).ticks(3);

                viz.datum(sorted);
                viz.append("g").attr('class', 'y axis').call(yAxis)
                    .select('.domain').remove();
                viz.selectAll('.tick line').attr('stroke', '#ddd');

                var tooltip = function(d) { return '<strong>{0}</strong> for {1}'.format(format(extract(d)), d.user); };
                viz.selectAll('rect.user').data(Fn.SELF).enter().append('rect')
                    .data(Fn.SELF)
                    .attr('class', 'user')
                    .attr('x', function(d,i) { return xScale(i); })
                    .attr('y', Fn(extract, yScale))
                    .attr('fill', '#64B5F6')
                    .attr('height', function(d) { return vizHeight - yScale(extract(d)); })
                    .attr('width', barWidth)
                    .attr('data-title', tooltip);

                viz.append('g').attr('class', 'users')
                    .selectAll('g').data(Fn.SELF).enter().append('g')
                    .attr('clip-path', 'url(#user-clip-path)')
                    .attr('transform', function(d, i) { return 'translate(' + xScale(i) + ',' + (vizHeight+5) + ')'; })
                    .append('a').attr('xlink:href', function(d) { return '/profile/' + d.user + '/'; })
                    .attr('xlink-href', function(d) { return '/profile/' + d.user + '/'; })
                    .on('click', function(d) { // work around xlink:href not fully working in Chrome
                        if (d3.event.which == 1 && !d3.event.metaKey) {
                            $state.go('profile.user.view', {userLogin: d.user});
                        }
                    })
                    .attr('data-title', tooltip)
                    .append('image')
                        .attr ('xlink:href', function(d) {
                            return UserImageUrl(d.user, barWidth);
                        })
                        .attr('x', 0)
                        .attr('y', 0)
                        .attr('width', barWidth).attr('height', barWidth);

                if (svgTitles) {
                    svgTitles.update();
                }
            }
            scope.$watch("data", redraw);
            scope.$watch("prop", redraw);
        }
    }
});


})();

(function(){
'use strict';


const app = angular.module('dataiku.projects.settings');


app.service('ExposedObjectsService', function($rootScope, $stateParams, CreateModalFromTemplate) {

    this.exposeObjects = function(items) {
        return CreateModalFromTemplate("/templates/projects/expose-objects-modal.html", $rootScope, "ExposeObjectsModalController", function(modalScope) {
            modalScope.init(items);
        });
    };

    this.exposeSingleObject = function(objectType, objectId, objectDisplayName, projectKey) {
        if (!projectKey) projectKey = $stateParams.projectKey;
        if (!objectDisplayName) objectDisplayName = objectId;

        return CreateModalFromTemplate("/templates/projects/expose-single-object-modal.html", $rootScope, "ExposeSingleObjectModalController", function(modalScope) {
            modalScope.init(objectType, objectId, objectDisplayName, projectKey);
        });
    };

    this.unshare = function(items) {
        return CreateModalFromTemplate("/templates/projects/unshare-modal.html", $rootScope, "UnshareModalController", function(modalScope) {
            modalScope.init(items);
        });
    };

});


app.controller("ExposeSingleObjectModalController", function($scope, $stateParams, $timeout, DataikuAPI, ActivityIndicator, CatalogItemService) {
    const dashboardsAndInsightsOnlyExposition = ["WEB_APP", "SCENARIO", "JUPYTER_NOTEBOOK", "REPORT"];
    $scope.uiState = {};
    $scope.available = {};

    $scope.init = function(objectType, objectId, objectDisplayName, projectKey) {
        $scope.currentProjectKey = projectKey;
        $scope.objectDisplayName = objectDisplayName;
        $scope.showExpositionInfo = dashboardsAndInsightsOnlyExposition.includes(objectType);

        DataikuAPI.projects.getObjectExposition(projectKey, objectType, objectId).success(function(objectExposition) {
            $scope.objectExposition = objectExposition;
            $scope.projectKeys = {};
            $scope.originalTargetProjects = [];

            if (projectKey) {
                $scope.projectKeys[projectKey] = true;
            }

            objectExposition.rules.forEach(function(rule) {
                $scope.projectKeys[rule.targetProject] = true;
                $scope.originalTargetProjects.push(rule.targetProject);
            });

            $scope.dashboardAuthorized = objectExposition.dashboardAuthorizedModes.indexOf('READ') > -1;
        }).error(setErrorInScope.bind($scope));

        $scope.save = function() {
            DataikuAPI.projects.saveObjectExposition(projectKey, objectType, objectId, $scope.objectExposition)
                .success(function() {
                    function buildLinkToExposedObject(targetProjectKey, objectType, objectId, objectProjectKey) {
                        const href = CatalogItemService.getFlowLink(objectType.toLowerCase(), {id: objectId, projectKey: objectProjectKey}, targetProjectKey);
                        const linkMessage =  `View in ${targetProjectKey} flow`;
                        return `<a href='${href}'>${linkMessage}</a>.`;
                    }
                    const links = "<div>" +
                        $scope.objectExposition.rules
                            .filter(rule => !($scope.originalTargetProjects.includes(rule.targetProject)))
                            .map(rule => buildLinkToExposedObject(rule.targetProject, objectType, objectId, projectKey))
                            .join('<br>')
                        + "</div>";

                    ActivityIndicator.success("Exposed elements updated!" + links, 5000);
                    $scope.resolveModal();
                })
                .error(setErrorInScope.bind($scope));
        };

        $scope.addProject = function(newProject) {
            $scope.objectExposition.rules.push({
                targetProject: newProject.id,
                targetProjectDisplayName: newProject.label,
                appearOnFlow: true
            });

            $scope.projectKeys[newProject.id] = true;
        };

        $scope.removeProject = function(projectKey) {
            const idx = $scope.objectExposition.rules.findIndex(function(rule) {
                return rule.targetProject === projectKey;
            });

            if (idx > -1) {
                $scope.objectExposition.rules.splice(idx, 1);
            }

            delete $scope.projectKeys[projectKey];
        };

        $scope.onDashboardAuthorize = function() {
            if (!$scope.dashboardAuthorized) {
                const idx = $scope.objectExposition.dashboardAuthorizedModes.indexOf('READ');
                if (idx > -1) {
                    $scope.objectExposition.dashboardAuthorizedModes.splice(idx, 1);
                }
            } else {
                $scope.objectExposition.dashboardAuthorizedModes.push('READ');
            }
        };
        $scope.$watch('newProject', function(nv,ov){
            if (nv != ov && !$.isEmptyObject(nv)) {
                $scope.addProject(nv);
                $scope.projectKey = null;
                $timeout(function(){
                    const element = $('.expose-object-modal .project-select');
                    element[0].scrollTop = element.outerHeight();
                });
            }
        });
    };
});


app.controller("ExposeObjectsModalController", function($scope, $stateParams, $timeout, DataikuAPI, TaggableObjectsUtils, ActivityIndicator) {
    $scope.available = {};
    $scope.settings = {
        dashboard: false
    };
    $scope.oldTargetProjects = []
    $scope.newTargetProjects = [];
    $scope.allTargetProjects = {}; //For exclusion in the selector of new projects

    if ($stateParams.projectKey) {
        $scope.allTargetProjects[$stateParams.projectKey] = true;
    }

    $scope.init = function(selectedItems) {
        $scope.selectedItems = selectedItems;
        $scope.itemsType = TaggableObjectsUtils.getCommonType(selectedItems, it => it.type);

        DataikuAPI.projects.getObjectsExpositions(selectedItems).success(function(currentExpositions) {
            $scope.currentExpositions = currentExpositions;
            $.each($scope.currentExpositions.projects, function(projectKey, exp){
                $scope.oldTargetProjects[projectKey] = {exposeAll: false};
                $scope.allTargetProjects[projectKey] = true; //exclude
            });
        }).error(setErrorInScope.bind($scope));

        $scope.save = function() {
            $scope.settings.projects = $.extend({}, $scope.oldTargetProjects);
            $scope.newTargetProjects.forEach(function(p) {
                $scope.settings.projects[p.projectKey] = {projectKey: p.projectKey, exposeAll: true};
            })
            DataikuAPI.projects.addObjectsExpositions(selectedItems, $scope.settings)
                .success(function() {
                    ActivityIndicator.success("Exposed elements updated!");
                    $scope.resolveModal();
                })
                .error(setErrorInScope.bind($scope));
        };

        $scope.addProject = function(newProject) {
            $scope.newTargetProjects.push({
                projectKey: newProject.id,
                appearOnFlow: true,
                label: newProject.label
            });

            $scope.allTargetProjects[newProject.id] = true;
        };

        $scope.removeProject = function(projectKey) {
            const idx = $scope.newTargetProjects.findIndex(x => x.projectKey == projectKey);
            if (idx > -1) {
                $scope.newTargetProjects.splice(idx, 1);
            }
            delete $scope.allTargetProjects[projectKey];
        };

        $scope.$watch('newProject', function(nv,ov){
            if (nv != ov && !$.isEmptyObject(nv)) {
                $scope.addProject(nv);
                $scope.projectKey = null;
                $timeout(function(){
                    const element = $('.expose-object-modal .project-select');
                    element[0].scrollTop = element.outerHeight();
                });
            }
        });
    };
});


app.controller("UnshareModalController", function($scope, $stateParams, DataikuAPI, TaggableObjectsUtils) {

    $scope.init = function(selectedObjects) {
        $scope.selectedObjects = selectedObjects;
        $scope.selectedObjectsType = TaggableObjectsUtils.getCommonType(selectedObjects, it => it.type);

        $scope.ok = function() {
            DataikuAPI.projects.unshare(selectedObjects, $stateParams.projectKey).success(function(data) {
                $scope.resolveModal();
            }).error(setErrorInScope.bind($scope));
        };
    };
});

})();
(function(){
    'use strict';

    var app = angular.module('dataiku.projects.directives', ['dataiku.filters']);

    app.directive('globalTagsList', function(TaggingService){
        return {
            template: 
        	`<div class="tagsList">
                <ul class="tags vertical-flex">
                    <li ng-repeat="tag in tags" ng-class="{\'selected\' : isTagSelected(tag)}">
                        <span ng-click="onClick(tag)" style="{{isTagSelected(tag) ? ' background-color:' + getTagColor(tag.title) : ''}}"
                                class="tag flex horizontal-flex" ng-class="{selected: isTagSelected(tag)}"  >
                            <span class="bullet" style="background-color:{{isTagSelected(tag) ? 'white' : getTagColor(tag.title)}};"> </span>
                            <span class="title flex"><span ui-global-tag="tag.title" object-type="'PROJECT'"/></span>
                            <span class="count noflex">{{tag.count}}</span>
                        </span>
                    </li>
                    <li ng-if="!tags.length">
                        <span class="mleft8">No tags available</span>
                    </li>
                </ul>
            </div>`,
            scope: {
            	tags: '=globalTagsList',
            	selectedTags: '=',
                onClickFunc: '='
            },
            link: function(scope, element){
                scope.onClick = function(tag){
                	scope.onClickFunc(tag.title);
                };
                
                scope.isTagSelected = function(tag) {
                	return scope.selectedTags.indexOf(tag.title) > -1;
                }

                scope.getTagColor = TaggingService.getTagColor;
            }
        };
    });
    
    app.directive('projectStatusList', function($location, DKUConstants){
        return {
            template: 
        	'<ul>' +
            '    <li ng-repeat="projectStatus in projectStatusList" ng-if="projectStatus.name != DKUConstants.ARCHIVED_PROJECT_STATUS" ng-click="$event.stopPropagation();toggleProjectStatus(projectStatus);" class="aic project-status" ng-class="{\'selected\' : isProjectStatusSelected(projectStatus.name)}", \'disabled\' : isProjectStatusSelected( DKUConstants.ARCHIVED_PROJECT_STATUS)}>' +
            '       <span class="status-color" style="background-color:{{projectStatus.color}};"></span> <span class="status-title">{{projectStatus.name}}</span>' +
            '   </li>' +
            '</ul>' + 
            '<button class="btn btn--contained" ng-click="toggleArchive()"><span ng-if="!isProjectStatusSelected(DKUConstants.ARCHIVED_PROJECT_STATUS)">Show archives</span><span ng-if="isProjectStatusSelected( DKUConstants.ARCHIVED_PROJECT_STATUS)">Show non archived</span></button>' +
            '<button class="btn btn--contained" ng-click="manageProjectStatus()">Manage project status</button>',
            scope: {
            	projectStatusList: '=',
            	selectedProjectStatusList: '='
            },
            link: function(scope, element){
            	scope.DKUConstants = DKUConstants;
                scope.toggleProjectStatus = function(projectStatus) {
                	scope.removeArchived();
                	if (projectStatus.name) {
                    	var index = scope.selectedProjectStatusList.indexOf(projectStatus.name);
                    	index > -1 ? scope.selectedProjectStatusList.splice(index, 1) : scope.selectedProjectStatusList.push(projectStatus.name);
                	}
            	}
                
                scope.removeArchived = function() {
                	var archivedIndex = scope.selectedProjectStatusList.indexOf( DKUConstants.ARCHIVED_PROJECT_STATUS);
                	if (archivedIndex != -1) {
                		scope.selectedProjectStatusList.splice(archivedIndex, 1);
                	}
                }
                
                scope.toggleArchive = function() {
                	if (scope.isProjectStatusSelected( DKUConstants.ARCHIVED_PROJECT_STATUS)) {
            			scope.selectedProjectStatusList = [];
                	} else {
                		scope.selectedProjectStatusList = [ DKUConstants.ARCHIVED_PROJECT_STATUS];
                	}
                }
                
                scope.isProjectStatusSelected = function(projectStatusName) {
                	return scope.selectedProjectStatusList.indexOf(projectStatusName) > -1;
                }
                
                scope.manageProjectStatus = function() {
                	$location.path('/admin/general/');
                }
            }
        };
    });
    
    app.directive('projectStatusSelector', function($state){
        return {
            template: 
        	'<ul>' +
            '    <li ng-repeat="projectStatus in projectStatusList" ng-click="onClick(projectStatus)" class="project-status" ng-class="{\'selected\' : isSelectedFunc(projectStatus)}">' +
            '       <span class="status-color" style="background-color:{{projectStatus.color}};"></span> <span class="status-title">{{projectStatus.name}}</span>' +
            '   </li>' +
            '</ul>' + 
            '<button class="btn btn--contained btn-tag-list" full-click><a main-click ng-click="adminProjetStatus()" style="color:#999;text-decoration:none;">Manage project status</a></button>',
            scope: {
            	projectStatusList: '=projectStatusSelector',
                isSelectedFunc: '=',
                onClickFunc: '='
            },
            link: function(scope, element){
                scope.onClick = function(projectStatus){
                	scope.onClickFunc(projectStatus.name);
                };
                
                scope.adminProjetStatus = function() {
                    $state.go("admin.general.themes");
                }
            }
        };
    });
    
    //contributorsList directive's name already used !
    app.directive('usersList', function(){
        return {
            template: 
            `<div class="noflex search-wrapper" >
                <input type="search" autofocus  placeholder="Filter..." ng-model="filterString" />
            </div>
        	<ul class="flex filtered-list"> 
                <li ng-if="customButtonToggleAction" ng-click="customButtonToggleActionFn()" class="contributor" ng-class="{\'selected\' : isCustomButtonSelected}"><span ng-transclude></span></li> 
                <li ng-repeat="contributor in usersList | filter:matchUsersByDisplayName" ng-click="toggleContributor(contributor)" class="contributor" ng-class="{\'selected\' : isContributorSelected(contributor)}"> 
                   <span user-picture="contributor.login" size="20" class="avatar20" /> <span class="contributor-name">{{contributor.displayName}}</span> 
               </li>
            </ul>`,
            scope: {
            	usersList: '=',
                selectedUsersList: '=',
                customButtonToggleAction: '=?',
            },
            transclude: true,
            link: function(scope, element){
                scope.filterString = "";

                scope.matchUsersByDisplayName = function (user){
                    return user.displayName.search(new RegExp(scope.filterString, 'i')) > -1;
                };

                scope.toggleContributor = function(contributor) {
                	if (contributor.login) {
                    	var index = scope.selectedUsersList.indexOf(contributor.login);
                    	index > -1 ? scope.selectedUsersList.splice(index, 1) : scope.selectedUsersList.push(contributor.login);
                	}
            	}
                
                scope.isContributorSelected = function(contributor) {
                	return scope.selectedUsersList.indexOf(contributor.login) > -1;
                }

                scope.isCustomButtonSelected = false;
                scope.customButtonToggleActionFn = function() {
                    scope.isCustomButtonSelected = ! scope.isCustomButtonSelected;
                    scope.customButtonToggleAction(scope.isCustomButtonSelected);
                }
            }
        };
    });

    app.directive("codeEnvOverrideForm", function(DataikuAPI, $stateParams){
        return {
            restrict: 'A',
            templateUrl : '/templates/projects/code-env-override-form.html',
            scope: {
                envSelection: '=codeEnvOverrideForm',
                envLang : '='
            },
            link : function($scope, element, attrs) {
                $scope.envNamesWithDescs = [];
                var selectDefault = function() {
                    if (!$scope.envSelection.useBuiltinEnv && $scope.envSelection.envName == null && $scope.envNamesWithDescs != null && $scope.envNamesWithDescs.envs.length > 0) {
                        $scope.envSelection.envName = $scope.envNamesWithDescs.envs[0].envName;
                    }
                };
                DataikuAPI.codeenvs.listNamesWithDefault($scope.envLang, $stateParams.projectKey).success(function(data) {
                    $scope.envNamesWithDescs = data;
                    selectDefault();
                }).error(setErrorInScope.bind($scope));
                $scope.$watch('envSelection.useBuiltinEnv', selectDefault);
                
            }
        }
    });

})();
(function() {
'use strict';

const app = angular.module('dataiku.projects.directives');


app.directive('projectsFlow', function($rootScope, Logger, $state, $stateParams, $timeout, $q,
        TopNav, CreateModalFromTemplate, DataikuAPI, ContextualMenu, WT1, HistoryService,
        FlowTool, FlowGraph) {
    return {
        restrict: 'EA',
        scope: true,
        controller: function($scope, $element, $rootScope, ProjectFolderContext) {
            $scope.nodesGraph = {};

            $scope.updateGraph = function(zoomTo) {
                DataikuAPI.projects.getGraph($scope.displayMode.flowLayoutEngine, ProjectFolderContext.getCurrentProjectFolderId(), !!$scope.displayMode.recursive).success(function(data) {
                    $scope.nodesGraph = data;
                    data.nodesOnGraphCount = Object.keys(data.nodes).length;
                    FlowGraph.set(data);
                    $scope.nbEoBundles =  0;

                    $scope.isFlowEmpty = data.includedProjects == 0 && data.includedExposedObjectsBundles == 0 && data.includedProjectFolders == 0;

                    for (let k in $scope.nodesGraph.nodes) {
                        if ($scope.nodesGraph.nodes[k].nodeType == 'BUNDLE_EO') $scope.nbEoBundles++;
                    }
                    if (zoomTo) {
                        $timeout(function() {
                            let id = graphVizEscape(zoomTo);
                            $scope.zoomGraph(id);
                            $scope.onItemClick($scope.nodesGraph.nodes[id]);
                        }, 0);
                    } else {
                        $timeout(() => { $scope.reinitGraph(); });
                    }

                    $rootScope.$emit('drawGraph');

                }).error(setErrorInScope.bind($scope));

            };
            $scope.updateGraph();

            $scope.$watch("displayMode", function(nv, ov) {
                if (nv != ov) {
                    $scope.updateGraph();
                }
            }, true);

            $scope.tool = {};
            FlowTool.setCurrent($scope.tool);

            const deregister = $rootScope.$on('reloadGraph', () => { $scope.updateGraph(false); });

            $scope.$on('$destroy', function() {
                deregister();
            });
        },
        link: function(scope, element) {
            scope.onItemDblClick = function(item, evt) {
                let destUrl = "";
                switch (item.nodeType) {
                    case "PROJECT_FOLDER":
                        destUrl = $state.href('project-list', {folderId: item.projectFolderId});
                        break;
                    case "PROJECT":
                        destUrl = $state.href('projects.project.home.regular', {projectKey : item.projectKey});
                        break;
                    case "BUNDLE_EO":
                        destUrl = item.canExposeFromProject ? $state.href('projects.project.security', {
                            projectKey: item.fromProjectKey,
                            selectedTab: 'exposed'
                        }) : '';
                        break;
                }
                fakeClickOnLink(destUrl,evt);
            };
            scope.onContextualMenu = function(item, evt) {
                evt.preventDefault();
            }
        }
    }
});


app.directive('projectRightColumnSummary', function(DataikuAPI) {
    return {
        templateUrl :'/templates/projects/project-right-column-summary.html',
        link: function($scope, element, attrs) {

            function refreshProject() {
                DataikuAPI.projects.getExtended($scope.rightColumnItem.projectKey, false)
                    .success(item => { $scope.project = item; })
                    .error(setErrorInScope.bind($scope));
            }
            $scope.$watch("rightColumnItem", function(nv, ov) {
                if(nv != ov && nv.nodeType == "PROJECT") {
                    refreshProject();
                }
            });
            refreshProject();

        }
    };
});


app.directive('eoBundleRightColumnSummary', function($filter, StateUtils, $state) {
    return {
        templateUrl :'/templates/projects/eo-bundle-right-column-summary.html',
        link: function($scope, element, attrs) {

            $scope.getItemHeaderHref = function(item) {
                return item.canExposeFromProject ? $state.href('projects.project.security', {
                    projectKey: item.fromProjectKey,
                    selectedTab: 'exposed'
                }) : '';
            };

            $scope.goToOriginal = function(node, evt) {
                StateUtils.go.dssObject(node.nodeType, node.id, node.fromProjectKey, {name: node.name});
            };

            $scope.goToForeign = function(node, evt) {
                const fullId = node.fromProjectKey+'.'+node.id;
                StateUtils.go.dssObject(node.nodeType, fullId, node.toProjectKey, {name: node.name});
            };

        }
    };
});

app.directive('projectFolderRightColumnSummary', function($state) {
    return {
        templateUrl: '/templates/projects/project-folder-right-column-summary.html',
        link: function($scope, element, attrs) {

            $scope.folder = $scope.foldersList.find(f => f.id == $scope.rightColumnItem.projectFolderId);
            $scope.$watch("rightColumnItem", function(nv, ov) {
                if(nv != ov && nv.nodeType == "PROJECT_FOLDER") {
                    $scope.folder = $scope.foldersList.find(f => f.id == $scope.rightColumnItem.projectFolderId);
                }
            });

            $scope.getItemHeaderHref = function(item) {
                return $state.href('project-list', {
                    folderId: item.projectFolderId
                });
            };
        }
    };
});

})();
(function() {
    'use strict';
    var app = angular.module('dataiku.directives.dip', ['dataiku.filters', 'dataiku.services', 'ui.keypress', 'dataiku.widgets.tageditfield']);

    app.directive("userPicture", function(Notification, $rootScope, UserImageUrl) {
        $rootScope.userPicturesHash= Math.random() * 200000 | 0;
        Notification.registerEvent("user-profile-picture-updated", function() {
            $rootScope.userPicturesHash = Math.random() * 200000 | 0;
        });
        return {
            template : "<div class=''></div>",
            replace : true,
            scope : {
                userPicture : '=',
                size : '@'
            },
            link : function(scope, element, attrs) {
                if (!scope.size) scope.size = 20;
                function update() {
                    var profileImageBaseUrl = UserImageUrl(scope.userPicture, scope.size);
                    element.addClass("avatar" + scope.size);
                    element.css("background-image", "url("+profileImageBaseUrl + ")");
                }
                scope.$watch("userPicture", function(nv, ov) {
                    if (!nv) return;
                    update();
                });
                $rootScope.$watch("userPicturesHash", function() {
                    update();
                })
            }
        };
    });

    app.directive("avatar", function() {
        return {
            template : '<a toggle="tooltip" title="{{displayName}}" href="{{ $state.href(\'profile.user\',{userLogin:login}) }}">'+
                            '<span user-picture="login" size="20" />'+
                        '</a>',
            replace : true,
            scope : {
                displayName : "=", login: "="
            }
        }
    });

    app.directive("closeTooltipsOnExit", function() {
        return {
            scope: false,
            link: function(scope, element, attrs) {
                function closeTooltips() {
                    $('.nvtooltip').remove(); // nvd3 tooltips (scatterplot)
                    $('.tooltip').remove();
                };
                scope.$watch(attrs.ngHide, function(nv) {if (nv) closeTooltips()});
                scope.$watch(attrs.ngShow, function(nv) {if (!nv) closeTooltips()});
                scope.$on('$destroy', closeTooltips);
            },
        }
    });

    app.directive('dkuBindHtmlUnsafe', ['$compile', function($compile) {
        return function(scope, element, attr) {
            element.addClass('ng-binding').data('$binding', attr.dkuBindHtmlUnsafe);
            scope.$watch(attr.dkuBindHtmlUnsafe, function dkuBindHtmlUnsafeWatchAction(value) {
                element.html(value);
                $compile(element.children())(scope);
            });
        };
    }]);

    app.directive('childFocus', function() {
        return {
            link: function(scope, elem, attrs) {
                var $elem = $(elem);
                $elem.find('input, label, select, option, button').each(
                    function(idx, item) {
                        $(item).focus(function () {
                            $elem.addClass('child-focus');
                        });
                        $(item).blur(function () {
                            $elem.removeClass('child-focus');
                        });
                    }
                );
            }
        };
    });

    app.directive('checkDatasetNameUnique', function(DataikuAPI, $stateParams) {
        return {
            require: 'ngModel',
            link: function(scope, elem, attrs, ngModel) {
                DataikuAPI.datasets.listNames($stateParams.projectKey).success(function(data) {
                    scope.unique_datasets_names = data;
                    /* Re-apply validation as soon as we get the list */
                    apply_validation(ngModel.$modelValue);
                });
                var initialValue = null, initialValueInitialized = false;
                function apply_validation(value) {
                    ngModel.$setValidity('datasetNameUnique', true);
                    // Implicitely trust the first value (== our own name)
                    if (initialValueInitialized == false && value != undefined && value != null && value.length > 0) {
                        initialValue = value;
                        initialValueInitialized = true;
                    }
                    // It is fake, but other check will get it.
                    if (value == null || value.length === 0) return value;
                    // We are back to our name, accept.
                    if (initialValueInitialized && value == initialValue) return value;

                    var valid = true;
                    if(scope.unique_datasets_names) {
                        for(var k in scope.unique_datasets_names) {
                            if(scope.unique_datasets_names[k].toLowerCase()==value.toLowerCase()) {
                                valid = false;
                            }
                        }
                    }

                    ngModel.$setValidity('datasetNameUnique', valid);
                    return value;
                }
                 //For DOM -> model validation
                ngModel.$parsers.unshift(apply_validation);

                //For model -> DOM validation
                ngModel.$formatters.unshift(function(value) {
                    apply_validation(value);
                    return value;
                });
            }
        };
    });

    app.directive('checkNewDatasetNameUnique', function(DataikuAPI, $stateParams) {
        return {
            require: 'ngModel',
            link: function(scope, elem, attrs, ngModel) {
                DataikuAPI.datasets.listNames($stateParams.projectKey).success(function(data) {
                    scope.unique_datasets_names = data;
                    /* Re-apply validation as soon as we get the list */
                    apply_validation(ngModel.$modelValue);
                });
                function apply_validation(value) {
                    ngModel.$setValidity('datasetNameUnique', true);
                    // It is fake, but other check will get it.
                    if (value == null || value.length === 0) return value;
                    var valid = true;
                    if(scope.unique_datasets_names) {
                        for(var k in scope.unique_datasets_names) {
                            if(scope.unique_datasets_names[k].toLowerCase()==value.toLowerCase()) {
                                valid = false;
                            }
                        }
                    }
                    ngModel.$setValidity('datasetNameUnique', valid);
                    return value;
                }
                //For DOM -> model validation
                ngModel.$parsers.unshift(apply_validation);

                //For model -> DOM validation
                ngModel.$formatters.unshift(function(value) {
                    apply_validation(value);
                    return value;
                });
            }
        };
    });

    app.directive('checkHiveHandlesDatasetName', function(DataikuAPI, $stateParams) {
        return {
            restrict: 'E',
            replace: true,
            template: "<span ng-hide='okForHive'><i class='icon-warning-sign'></i>&nbsp;A dataset for Hive/Impala can only contain alphanumeric characters and underscore</span>",
            scope: {
                datasetName : '=',
                datasetConnectionType : '=',
                connectionId: '=',          // when the connection list comes from a call to get-managed-dataset-options
                connectionConnection: '=',  // when the connection list comes from a call to list-managed-dataset-connections
                connectionList : '='        // when the type is not directly sent via datasetConnectionType
            },
            link: function(scope, elem, attrs, ngModel) {
            	// check for hdfs datasets, to warn when they won't work in hive because of their names. Other databases don't
            	// have this problem since the dataset is the table so you can't create one with an incorrect name
            	scope.okForHive = true;
            	var validate = function() {
                	scope.okForHive = true;
                	if (scope.datasetName == null || scope.datasetName.length == 0) return;
                	var selectedConnectionType = scope.datasetConnectionType;
                	if ( selectedConnectionType == null || selectedConnectionType.length == 0) {
                    	if (scope.connectionList != null && scope.connectionList.length > 0) {
                        	if (scope.connectionId != null && scope.connectionId.length > 0) {
                            	scope.connectionList.forEach(function(c) {
                            		if ( c.id == scope.connectionId) {
                            			selectedConnectionType = c.connectionType;
                            		}
                            	});
                        	}
                        	if (scope.connectionConnection != null && scope.connectionConnection.length > 0) {
                            	scope.connectionList.forEach(function(c) {
                            		if ( c.connection == scope.connectionConnection) {
                            			selectedConnectionType = c.type;
                            		}
                            	});
                        	}
                    	}
                	}
                	if (selectedConnectionType != 'HDFS') return; // here we're specifically focusing hive tables
                	scope.okForHive = /^[0-9a-zA-Z_]+$/.test(scope.datasetName);
            	};
                scope.$watch('datasetName', function() {validate();});
                scope.$watch('connectionId', function() {validate();});
                scope.$watch('connectionList', function() {validate();});
                scope.$watch('datasetConnectionType', function() {validate();});
                scope.$watch('connectionConnection', function() {validate();});
            }
        };
    });


    app.directive('checkNewManagedFolderLabelUnique', function(DataikuAPI, $stateParams) {
        return {
            require: 'ngModel',
            link: function(scope, elem, attrs, ngModel) {
                DataikuAPI.managedfolder.list($stateParams.projectKey).success(function(data) {
                    scope.unique_boxes_names = $.map(data, function(box) {
                        return box.name;
                    });
                    // Re-apply validation as soon as we get the list
                    apply_validation(ngModel.$modelValue);
                });
                function apply_validation(value) {
                    ngModel.$setValidity('boxNameUnique', true);
                    // It is fake, but other check will get it.
                    if (value == null || value.length === 0) return value;
                    var valid = true;
                    if(scope.unique_boxes_names) {
                        for(var k in scope.unique_boxes_names) {
                            if(scope.unique_boxes_names[k].toLowerCase()==value.toLowerCase()) {
                                valid = false;
                            }
                        }
                    }
                    ngModel.$setValidity('boxNameUnique', valid);
                    return value;
                }
                //For DOM -> model validation
                ngModel.$parsers.unshift(apply_validation);

                //For model -> DOM validation
                ngModel.$formatters.unshift(function(value) {
                    apply_validation(value);
                    return value;
                });
            }
        };
    });
    
    app.directive('checkNewModelEvaluationStoreLabelUnique', function(DataikuAPI, $stateParams) {
        return {
            require: 'ngModel',
            link: function(scope, elem, attrs, ngModel) {
                DataikuAPI.modelevaluationstores.list($stateParams.projectKey).success(function(data) {
                    scope.unique_evaluationStores_names = $.map(data, function(evaluationStore) {
                        return evaluationStore.name;
                    });
                    // Re-apply validation as soon as we get the list
                    apply_validation(ngModel.$modelValue);
                });
                function apply_validation(value) {
                    ngModel.$setValidity('evaluationStoreNameUnique', true);
                    // It is fake, but other check will get it.
                    if (value == null || value.length === 0) return value;
                    var valid = true;
                    if(scope.unique_evaluationStores_names) {
                        for(var k in scope.unique_evaluationStores_names) {
                            if(scope.unique_evaluationStores_names[k].toLowerCase()==value.toLowerCase()) {
                                valid = false;
                            }
                        }
                    }
                    ngModel.$setValidity('evaluationStoreNameUnique', valid);
                    return value;
                }
                //For DOM -> model validation
                ngModel.$parsers.unshift(apply_validation);

                //For model -> DOM validation
                ngModel.$formatters.unshift(function(value) {
                    apply_validation(value);
                    return value;
                });
            }
        };
    });

    app.service('clickRouter', function() {
        return {
            routeClickEvent: function (element, evt, clickableEmitterSelector, fullClickAttribute, mainClickAttributName, preventRecursionMarker, alsoPreventDefault, closestScope) {
                if(evt.originalEvent && evt.originalEvent.preventRecursionMarker === preventRecursionMarker) {
                    // Prevent event recursion : do not handle this event if we generated it!
                    return;
                }
                var sameElement = (evt.target == element[0]);
                var clickableEmitter = $(evt.target).closest(clickableEmitterSelector, closestScope).length > 0;
                var mainClickEl = fullClickAttribute ? element.find('[' + mainClickAttributName + '="' + fullClickAttribute + '"]') : element.find('['+ mainClickAttributName +']')
                const mainClickDisabled = evt.target.hasAttribute("disable-main-click");  // explicitely disable "main-click" behavior on element

                if(mainClickEl.is(evt.target) || mainClickDisabled) {
                    // The user clicked on the main click target already or the click has been explicitely disabled, so we don't need to do anything
                    // Especially useful for checkbox to avoid the double toggle effect
                    return;
                }

                if (( sameElement || !clickableEmitter ) && mainClickEl.length) {
                    // you cannot redispatch an existing event :(
                    var cloneEvent = document.createEvent('MouseEvents');
                    cloneEvent.preventRecursionMarker = preventRecursionMarker;
                    var e = evt.originalEvent;
                    cloneEvent.initMouseEvent(e.type, e.bubbles, e.cancelable, window, e.detail,
                        e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey,
                        e.metaKey, e.button, e.relatedTarget);
                    mainClickEl[0].dispatchEvent(cloneEvent);
                    e.stopPropagation();
                    if (alsoPreventDefault) e.preventDefault(); // for right-click, because we don't want the browser contextual menu
                }
            }
        }
    });

// attrs: 'ignoreElement' allows to prevent click event redirection for one specific element, if needed
    app.directive('fullClick', function(clickRouter) {
        return {
            restrict: 'A',
            link: function(scope, element, attrs) {
                var preventRecursionMarker = {};

                element.on("click.fullclick", function(evt) {
                    if (scope.isClickable && !scope.isClickable()) {return false;}
                    if (!attrs.ignoreElement || !evt.target.matches(attrs.ignoreElement)) {
                        clickRouter.routeClickEvent(element, evt, 'a,button,[ng-click]', attrs.fullClick, 'main-click', preventRecursionMarker, false, attrs.containClick ? element[0] : undefined);
                    }
                });
                scope.$on("$destroy", function() {
                    element.off("click.fullclick");
                });
            }
        };
    });

    app.directive('fullRightClick', function(clickRouter) {
        return {
            restrict: 'A',
            link: function(scope, element, attrs) {
                var preventRecursionMarker = {};
                element.bind("contextmenu", function(evt) {
                    clickRouter.routeClickEvent(element, evt, '[ng-right-click]', attrs.fullRighClick, 'main-right-click', preventRecursionMarker, true);
                });
                scope.$on("$destroy", function() {
                    element.off("contextmenu");
                });
            }
        };
    });

    app.directive('stopPropagation', function() {
        return function(scope, element, attrs) {
            $(element).click(function(event) {
                event.stopPropagation();
            });
        }
    });

    app.directive('preventDefault', function() {
        return function(scope, element, attrs) {
            $(element).click(function(event) {
                event.preventDefault();
            });
        }
    });

    app.directive('autoFocus', function($timeout) {
        return {
            restrict: 'A',
            link: function(scope, element, attr) {
                attr.$observe('autoFocus', function() {
                    if ((attr.autoFocus === "true") || (attr.autoFocus === true) || (attr.autoFocus===undefined)) {
                        $timeout(function() {element.focus();}, 0);
                    }
                });
            }
        };
    });

     app.directive('autoFocusChild', function($timeout) {
        return {
            restrict: 'A',
            link: function(scope, element, attr) {
                attr.$observe('autoFocusChild', function() {
                    if ((attr.autoFocus === "true") || (attr.autoFocus === true) || (attr.autoFocus===undefined)) {
                        $timeout(function() {
                            element.find("button, input, select").focus();
                        }, 0);
                    }
                });
            }
        };
    });


    app.directive('dkuFrame', function () {
        return {
            restrict: 'E',
            require: '?ngModel',
            replace: true,
            transclude: true,
            template: '<iframe height="100%" detectIframeClicks width="100%" frameborder="0"></iframe>',
            link: function (scope, element, attrs) {
                element.attr('src', attrs.iframeSrc);
            }
        };
    });


    app.factory("ProgressStackMessageBuilder", function($filter) {
        // caution: you can have both hasResult == false and response.progress == null
        // => with a remote future (executed in the fek), there are some extra steps
        // at the end of the computation, where the backend will not have progress for
        return {
            getPercentage : function(progress) {
                var percentage = 0;
                var fractionOf = 100;
                if (progress && progress.states) {
                    angular.forEach(progress.states, function(state) {
                        if(state.target > -1) {
                            if (state.target > 0) {
                                fractionOf = fractionOf / (state.target + 1);
                                percentage += fractionOf * state.cur;
                            } else {
                                percentage += fractionOf;
                            }
                        }
                    });
                }
                return percentage;
            },
            buildFull : function(stack) { // called on trainInfo
                var stackMessage = null;
                if (stack && stack.length) {
                    var messageStack = [];
                    for (var i = 0; i < stack.length; i++) {
                        messageStack.push(stack[i].name)
                    }
                    return messageStack.join(": ");
                } else {
                    return "<span>Please wait...</span>";
                }
            },
            build : function(progress, includeAll) {
                function bytesToSize(bytes) {
                    var sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
                    if (bytes === 0) return '0 B';
                    var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)), 10);
                    return Math.round(bytes / Math.pow(1024, i), 2) + ' ' + sizes[i];
                }
                function roundAfterTwoDecimals(number) {
                    return Math.round(parseFloat(number)*100)/100
                }
                function buildMessage(stackElt) {
                        var message = stackElt.name + " ";
                        switch(stackElt.unit) {
                            case "SIZE":
                                if (stackElt.target > 0) {
                                    message += "<small>(" + bytesToSize(stackElt.cur) + " / " + bytesToSize(stackElt.target) + ")</small>";
                                } else if (stackElt.cur > 0) {
                                    message +="<small>(" + bytesToSize(stackElt.cur) + ")</small>";
                                }
                                break;
                            default:
                                if (stackElt.target > 0) {
                                    message += "<small>(" + roundAfterTwoDecimals(stackElt.cur) + " / " + roundAfterTwoDecimals(stackElt.target) + ")</small>";
                                } else if (stackElt.cur > 0) {
                                    message +="<small>(" + roundAfterTwoDecimals(stackElt.cur) + ")</small>";
                                }
                                break;
                        }
                        return message;
                }
                var stackMessage = null;
                if (progress && progress.states && progress.states.length) {
                    var messageStack = [];
                    var lastStackElt = null;
                    for (var i = 0; i < progress.states.length; i++) {
                        if (i == progress.states.length-1 || progress.states[i].important || includeAll) {
                            var stackMessage = buildMessage(progress.states[i]);
                            lastStackElt = progress.states[i];
                            messageStack.push(stackMessage);
                        }
                    }
                    if (lastStackElt != null) {
                        var k = messageStack.length - 1;
                        var lastStackEltDuration = $filter('friendlyDurationShort')(lastStackElt.msSinceStart);
                        lastStackEltDuration = lastStackEltDuration.replace('<', '&lt;')
                        messageStack[k] = messageStack[k] + "<br /><small>Started " + lastStackEltDuration + " ago</small>";
                    }
                    return messageStack.join("<br />");
                } else {
                    return "<span>Please wait...</span>";
                }
            }
        };
    });

    app.directive('futureWaiting', function(DataikuAPI, ProgressStackMessageBuilder, $rootScope) {
        return {
            templateUrl : '/templates/future-waiting.html',
            scope: {
                response : '='
            },
            // IN scope : "response"
            link : function(scope, element, attrs) {
                scope.percentage = 0;
                scope.started = false;

                scope.$watch('response', function(nv, ov) {
                    if(nv && !nv.hasResult) {
                        scope.percentage = ProgressStackMessageBuilder.getPercentage(scope.response.progress);
                        scope.started = scope.response.progress && scope.response.progress.states && scope.response.progress.states.length;
                        scope.stackMessage = ProgressStackMessageBuilder.build(scope.response.progress);
                    }
                });

                scope.abort = function() {
                    if (scope.response && scope.response.jobId) {
                        DataikuAPI.futures.abort(scope.response.jobId).error(setErrorInScope.bind(scope));
                    }
                };
                $rootScope.$on("futureModalOpen", function() {
                	scope.futureModalOpen = true;
                });
                $rootScope.$on("futureModalClose", function() {
                	scope.futureModalOpen = false;
                });
            }
        };
    });

    function formatDoclinkRef(page) {
        if (page.length > 0 && page[0] == '/') {
            page = page.substring(1);
        }

        const anchorPos = page.indexOf('#');
        if (anchorPos >=0) {
            // add '.html' extension before anchor
            return page.substring(0, anchorPos) + '.html' + page.substring(anchorPos);
        } else {
            return page + '.html';
        }
    }

    app.directive('doclink', function($rootScope) {
        return {
            restrict : 'E',
            replace : 'true',
            template : '<a target="_blank" />',
            scope : {
                page: '@',
                title: '@',
                showIcon: '=?'
            },
            link : function($scope, element) {
                var page = $scope.page;
                element[0].href = $rootScope.versionDocRoot + formatDoclinkRef(page);
                let html = $scope.title;
                if (!!$scope.showIcon) {
                    html += ' <i class="icon-external-link"/>';
                }
                $(element[0]).html(html);
            }
        };
    });

    app.directive('docLink', function($rootScope) {
        return {
            restrict : 'EA',
            transclude:true,
            template : '<a target="_blank"><span ng-transclude /></a>',
            link : function($scope, element, attrs) {
                var page = attrs.docLink;
                element.find("a")[0].href = $rootScope.versionDocRoot + formatDoclinkRef(page);
            }
        };
    });

    app.directive('doclinkWrapper', function($rootScope) {
        return {
            restrict : 'EA',
            transclude:true,
            template : '<a target="_blank"><span ng-transclude /></a>',
            link : function($scope, element, attrs) {
                var page = attrs.page;
                element.find("a")[0].href = $rootScope.versionDocRoot + formatDoclinkRef(page);
            }
        };
    });

    app.directive('learnLink', function($rootScope) {
        return {
            restrict : 'A',
            transclude:true,
            template : '<a target="_blank"><span ng-transclude /></a>',
            link : function($scope, element, attrs) {
                var page = attrs.page;
                element.find("a")[0].href = $rootScope.learnRootUrl + page + ".html";
            }
        };
    });

    app.directive('academyLink', function($rootScope) {
        return {
            restrict : 'A',
            transclude:true,
            template : '<a target="_blank"><span ng-transclude /></a>',
            link : function($scope, element, attrs) {
                var page = attrs.page;
                element.find("a")[0].href = $rootScope.academyRootUrl + page;
            }
        };
    });

    app.directive('aboutPartitioningBox', function(CreateModalFromTemplate) {
        return {
            restrict : 'A',
            replace : 'true',
            template : '<a class="about-trigger"><i class="icon-question-sign" /></a>',
            link: function(scope, element, attrs) {
                var out = scope.$parent,
                    $elt = $(element);
                if (out.appConfig.communityEdition && !out.appConfig.licensing.ceEntrepriseTrial
                        && !attrs.skipCommunityPopup) {
                    $elt.on('click', function(e) {
                        CreateModalFromTemplate("/templates/profile/community-vs-enterprise-modal.html",
                            out, null, function(newScope) { newScope.lockedFeature = 'Partitioning is'; });
                        e.preventDefault();
                    });
                } else {
                    $elt.on('click', out.showAboutPartitioning);
                }
            }
        };
    });

    app.directive('selectedIndex', ['keypressHelper', '$parse','Debounce', function(keypressHelper, $parse,Debounce) {
        return {
            require: 'ngModel',
            restrict: 'A',
            scope: true,
            link: function(scope, element, attrs, ngModel) {

                var parsedSelectedIndexAttr = $parse(attrs.selectedIndex);

                var deselect = $parse(attrs.deselect);
                var inModal = $parse(attrs.inModal);
                scope.$watch(() => ngModel.$modelValue, () => {
                    const initialIndex = parseInt(attrs.initialIndex === undefined ? -1 : attrs.initialIndex, 10);
                    scope.selected = {
                        index: initialIndex,
                        item: initialIndex < 0 ? null : ngModel.$modelValue[initialIndex],
                        itemDelayed:null
                    };
                });
                scope.selectNext = function(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    for (let index = scope.selected.index + 1; index < ngModel.$viewValue.length; index++) {
                        const nextIndex = Math.min(ngModel.$viewValue.length - 1, index);
                        if (ngModel.$viewValue[nextIndex].selectable === undefined || ngModel.$viewValue[nextIndex].selectable === true) {
                            scope.selectIndex(nextIndex);
                            return;
                        }
                    }
                };
                scope.selectPrevious = function(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    for (let index = scope.selected.index - 1; index >= -1; index--) {
                        const nextIndex = Math.max(-1, index);
                        if (nextIndex === -1 || ngModel.$viewValue[nextIndex].selectable === undefined || ngModel.$viewValue[nextIndex].selectable === true) {
                            scope.selectIndex(nextIndex);
                            return;
                        }
                    }
                };
                scope.go = function(e) {
                    if(scope.selected.index >= 0) {
                        parsedSelectedIndexAttr(scope, {item:ngModel.$viewValue[scope.selected.index]});
                    }
                };

                scope.handleEnter = function(evt) {
                    if (["INPUT", "SELECT", "TEXTAREA", "BUTTON"].indexOf(evt.target.tagName) == -1) {
                        scope.go();
                    }
                }

                keypressHelper('keydown', scope, $(document), {
                    Keydown: "{'down': 'selectNext($event)','up': 'selectPrevious($event)','enter': 'handleEnter($event)'}"
                }, '', false, !inModal());

                var sd = Debounce().withDelay(50,500).withScope(scope);

                scope.selectIndex = function(index) {
                    var newItem = null;
                    if(scope.selected.index >= 0 && ngModel.$viewValue[scope.selected.index]) {
                        ngModel.$viewValue[scope.selected.index].selectedIndex = false;
                    }
                    if(index>=0 && ngModel.$viewValue[index]) {
                        newItem = ngModel.$viewValue[index];
                    }

                    if (deselect() && scope.selected.item === newItem) {
                        newItem = null;
                    }

                    // selected.item is the currently selected item
                    scope.selected.item = newItem;

                    // selected.confirmedItem is the currently selected item, defined with a little delay
                    scope.selected.confirmedItem = null;
                    sd.exec(function() {
                        scope.selected.confirmedItem = newItem;
                    });

                    scope.selected.index = index;
                    scope.$emit('selectedIndex', index);
                };
            }
        };
    }]);

    app.directive('editableChartInsightSummary', function($stateParams, $rootScope) {
        return {
            scope : true,
            link : function($scope, element, attrs) {
                $scope.$stateParams = $stateParams;
                $scope.editSummaryState = {};
                $scope.startEdit = function() {
                    $scope.editSummaryState.editSummary = true;
                    $scope.editSummaryState.description = $scope.insight.description;
                    $scope.editSummaryState.tags = angular.copy($scope.insight.tags);
                    clearSelection();
                }
                $scope.cancelEdit = function() {
                    $scope.editSummaryState.editSummary = false;
                }
                $scope.validateEdit = function() {
                    $scope.editSummaryState.editSummary = false;
                    $scope.insight.description = $scope.editSummaryState.description;
                    $scope.insight.tags = angular.copy($scope.editSummaryState.tags);
                    $rootScope.$broadcast("objectSummaryEdited");
                }
            }
        };
    });

    app.directive('foldable', function() {
        return {
            scope : true,
            link : function($scope, element, attrs) {
                if (attrs.foldable == "true") {
                    $scope.unfolded = true;
                }
                $scope.toggleFold = function() {
                    $scope.unfolded = !$scope.unfolded;
                };
            }
        };
    });


   app.directive('abortConfirmation', function() {
	   return {
		   restrict: 'AE',
           scope : {
               aborting:'=',
               abortFn : '=',
               abortParamsArr : '='
           },
           templateUrl: "/templates/profile/abort-confirmation.html",
		   link : function($scope, element, attrs) {

			   $scope.showConfirmationForm = function() {
				   $scope.aborting = true;
			   }

			   $scope.hideConfirmationForm = function() {
				   $scope.aborting = false;
			   }

			   $scope.abort = function() {
				   $scope.abortFn.apply(this, $scope.abortParamsArr);
			   }
		   }
	   }
   });

	/**
	 * directive to hold a multi-selection in a list.
     *
     * it takes parameters from the following attributes:
     *  - ng-model : the list on which the directive operates is passed as a ng-model on the same html element
     *               it can also be an object (its keys will then be added as '_name' attribute of the elements)
     *  - auto-select-first : if true, will start with the first element of the list selected
     *  - auto-focus-first : if true, will start with the first element of the list focused
     *  - select-click-behaviour
     *     if none, will focus the line
     *     if 'select-one', the selected object will be checked and others unselected
     *     if 'select-add', it will select the element (like meta + click)
     *  - double-select-unselects : if set, focusing a focused element will unset focus
     *  - keep-focus-on : if set, when clicking on a checkbox re-focus the element
	 *
	 * it adds a 'selection' object in the scope, with the following fields:
     *  - selectedObject : current selected object
     *  - keyboard : boolean controlling whether selection was made with keyboard
     *  - confirmedItem : equals selectedObject after a delay
	 *  - selectedObjects : current list of selected objects
	 *
     *  - all : everything is selected
	 *  - some : something (not everything) is selected
	 *  - none : nothing is selected
	 *  - single : 1 object exactly is selected
     *  - multiple : several objects are selected
     *  - filtered : not all items in list are displayed due to filters
     *  - loaded : everything is fully loaded
     *
	 *  - allObjects : list of all objects (selected or not)
     *  - filterQuery : text for the filter (used in a $filter('filter')(...) )
     *  - filterParams : Filtering parameters ({userQueryTargets:'name of the param for q search',
     *                   propertyRules: {dict for renaming special props}})
     *
     *  - customFilter : a custom filter specifing function(objects) {return filteredobjects}
     *  - customFilterWatch : name of a model to watch to trigger updateFilter
     *
     *  - orderQuery : string/list of strings for the order ( used in a $filter('orderBy')(...) )
     *  - orderReversed : boolean controlling the reversed state of the orderBy
	 *  - filteredObjects : list of visible objects, matching the filter
	 *  - filteredSelectedObjects : list of visible selected objects, matching the filter
     *
     * If you specify selection.partialProperty = 'Something' it will create (for each value available)
     *  - partial[values].all : every object matching object[partialProperty] = value is selected
     *  - partial[values].some : something (not everything) matching object[partialProperty] = value is selected
     * -> your need to regenselectionstate to register the param on first load
     *
	 * each object in the list gets 2 hidden fields:
	 *  - $idx : index in the original list
	 *  - $selected : flag indicated selection or not
	 *
	 * additionally, the following methods for manipulating the selection are added in the scope:
	 *  - checkBoxChanged(object, $event) : a mass selection checkbox is clicked on some object
	 *  - objectClicked(object, $event) : an object in the list is clicked (not on the mass selection checkbox)
     *  - removeObject(object) : removes an object from the list
     *  - removeSelected()) : remove the selected objects
	 *  - updateMassSelectionCheckbox() : to use in a ng-change on the checkbox linked to $scope.selection.all
     *  - updateOrderQuery(value) : sets orderQuery to value, toggling orderReversed if stays the same
	 */
	app.directive("filteredMultiSelectRows", function($filter, $timeout, Debounce, Throttle, Fn, CollectionFiltering, ActiveProjectKey, ActivateOldRightPanel) {
		return {
			scope : false,
			link : function($scope, element, attrs) {
                $scope.ActivateOldRightPanel = ActivateOldRightPanel;
                var filterWithPartialPropertyValue = function(objects, val) {
                    return objects.filter(function(o) {
                        return o[$scope.selection.partialProperty] === val;
                    });
                }

                var computePartialStates = function() {
                    var partialValues = $scope.selection.filteredObjects.map(function(m) {
                        return m[$scope.selection.partialProperty];
                    }).filter(function(value, index, self) {
                        return self.indexOf(value) === index;
                    });
                    var ssp = $scope.selection.partial;
                    partialValues.map(function(val) {
                        var partialFilteredSelectedObjects = filterWithPartialPropertyValue($scope.selection.filteredSelectedObjects, val);
                        var partialFilteredObjects = filterWithPartialPropertyValue($scope.selection.filteredObjects, val);
                        ssp[val] = {
                            all: partialFilteredSelectedObjects.length == partialFilteredObjects.length && partialFilteredObjects.length > 0,
                            some: partialFilteredSelectedObjects.length > 0 && partialFilteredSelectedObjects.length < partialFilteredObjects.length,
                            none: partialFilteredSelectedObjects.length == 0,
                        }
                    });

                }

                var sd = Debounce().withDelay(50,500).withScope($scope);
                var regenSelectionStateFromFlags = function() {
                    const ss = $scope.selection;

                    if (ss.rememberSelection) {
                        ss.allObjects.forEach(el => {
                            const comparator = getRememberSelectionComparator(el);
                            const selectedObjectIndex = ss.selectedObjects.findIndex(comparator);
                            el.$selected = selectedObjectIndex >= 0;
                            if (el.$selected) {
                                ss.selectedObjects[selectedObjectIndex] = el;
                            }
                        });
                    } else {
                        ss.selectedObjects = ss.allObjects.filter(function (o) {
                            return o.$selected;
                        });
                    }

                    if(!ss.filteredObjects) {
                        ss.filteredObjects = [];
                    }
                    ss.filteredSelectedObjects = ss.filteredObjects.filter(f => f.$selected);
                    // regen flags for the tri-state
                    ss.none = ss.filteredSelectedObjects.length === 0;
                    ss.single = ss.selectedObjects.length === 1 && ss.selectedObject!==null;
                    ss.multiple = ss.selectedObjects.filter($scope.isItemSelectablePredicate).length > 1;
                    ss.all = ss.filteredSelectedObjects.length === ss.filteredObjects.filter($scope.isItemSelectablePredicate).length && ss.filteredObjects.length > 0 && ss.filteredSelectedObjects.length > 0;
                    ss.some = ss.filteredSelectedObjects.length > 0 && ss.filteredSelectedObjects.length < ss.filteredObjects.filter($scope.isItemSelectablePredicate).length;
                    ss.filtered = ss.filteredObjects.length !== ss.allObjects.length;

                    if (ss.partialProperty) {computePartialStates();}
                    // enfore sanity of the selected selectedObject field
                    if (ss.selectedObject && ss.allObjects.indexOf(ss.selectedObject) < 0) {
                        //try and find matching object in the refreshed list corresponding to the currently selected object
                        // this crucial when using the Manage Tag modal via the Edit metadata screen, from a list of taggable objects.
                        const matchId = ss.selectedObject.id;
                        const matchingNewObj = ss.allObjects.find((obj) => {
                            return obj.id == matchId && obj.createdOn == ss.selectedObject.createdOn;
                        });
                        ss.selectedObject = matchingNewObj ? matchingNewObj : null;
                    }
                    sd.exec(function() {ss.confirmedItem = ss.selectedObject});
                };

                var updateSorted = function() {
                    if ($scope.selection.orderQuery && $scope.selection.orderQuery !== "" && !$.isEmptyObject($scope.selection.orderQuery)) {
                        $scope.selection.filteredObjects = $filter('orderBy')($scope.selection.filteredObjects, $scope.selection.orderQuery, $scope.selection.orderReversed);
                    }
                    regenSelectionStateFromFlags();
                };

			    var updateFilter = function() {
					$scope.selection.allObjects = $scope.$eval(attrs.ngModel);
    				if (!$scope.selection.allObjects) {
                        $scope.selection.allObjects = [];
                        $scope.selection.loaded = false;
                    } else {
                        $scope.selection.loaded = true;
                    }
                    if ($scope.selection.allObjects.constructor !== Array) {
                        $scope.selection.allObjects = $.map($scope.selection.allObjects, function(v,k) {v._name=k; return [v]});
                    }
                    $scope.selection.allObjects.forEach(function (c, i) {
                        c.$idx = i;
                    });
                    $scope.selection.filteredObjects = $scope.selection.allObjects;

					if ($scope.selection.filterQuery) {
                        $scope.selection.filteredObjects = CollectionFiltering.filter($scope.selection.filteredObjects, $scope.selection.filterQuery, $scope.selection.filterParams);
					}
                    if ($scope.selection.customFilter) {
                        $scope.selection.filteredObjects = $scope.selection.customFilter($scope.selection.filteredObjects);
                    }
                    updateSorted();
			    };

                var debouncedUpdateFilter = Throttle().withDelay(500).wrap(updateFilter);

                function setSelectedObject(newObject) {
                    if (newObject && newObject.$selected) {
                        $scope.selection.selectedObject = newObject;
                    } else {
                        $scope.selection.selectedObject = null;
                    }

                    // if this list is flagged as updating the ActiveProjectKey service,
                    // pass to the service the projectKey of the newly selected object, where it exists
                    if (attrs.updateActiveProjectKey) {
                        const projectKey = (!!newObject && newObject.projectKey) ? newObject.projectKey : undefined;
                        ActiveProjectKey.set(projectKey);
                    }
                }

                $scope.updateOrderQuery = function(value) {
                    var ss = $scope.selection;
                    if (ss.orderQuery === value) {
                        ss.orderReversed = !ss.orderReversed;
                    } else {
                        ss.orderReversed = false;
                        ss.orderQuery = value;
                    }
                }

                $scope.removeSelected = function() {
                    $scope.selection.selectedObjects.forEach($scope.removeObject);
                }
				$scope.removeObject = function(object) {
			        var idx = $scope.selection.allObjects.indexOf(object);
			        if (idx === -1) {
			            return;
			        }

			        $scope.selection.allObjects.splice(idx, 1);
			        updateFilter();
				};

                var clearNonEmptyKeys = function (obj) {
                    if ($.isPlainObject(obj)) {
                        for (var k in obj) {
                            obj[k] = clearNonEmptyKeys(obj[k]);
                        }
                        return obj;
                    } else if ($.isArray(obj)) {
                        return []
                    } else {
                        return "";
                    }
                };
                $scope.clearFilters = function () {
                    $scope.selection.filterQuery = clearNonEmptyKeys($scope.selection.filterQuery);
                    if ($scope.selection.inclusiveFilter) $scope.selection.inclusiveFilter = clearNonEmptyKeys($scope.selection.inclusiveFilter);
                };
                $scope.isEmptyFilter = function () {
                    return angular.equals($scope.selection.filterQuery, clearNonEmptyKeys(angular.copy($scope.selection.filterQuery))) &&
                        (!$scope.selection.inclusiveFilter || angular.equals($scope.selection.inclusiveFilter, clearNonEmptyKeys(angular.copy($scope.selection.inclusiveFilter))));
                };

                $scope.updateMassSelectionCheckbox = function (partialPropertyValue) {
                    var state, filteredObjects;
                    if (partialPropertyValue) {
                        filteredObjects = filterWithPartialPropertyValue($scope.selection.filteredObjects, partialPropertyValue)
                        state = $scope.selection.partial[partialPropertyValue].none;
                    } else {
                        filteredObjects = $scope.selection.filteredObjects;
                        state = $scope.selection.none;
                    }
                    filteredObjects.forEach(function (object) {
                        handleObjectSelection(object, state);
                    });
                    setSelectedObject(null);
                    regenSelectionStateFromFlags();
                    if (attrs.keepFocusOn) {
                        element.focus();
                    }
                };

                function handleObjectSelection(object, checked) {
                    if (!$scope.isItemSelectablePredicate(object)) {
                        return;
                    }

                    object.$selected = checked;
                    if ($scope.selection.rememberSelection) {
                        addOrRemoveRememberedObject(object);
                    }

                }

                function getRememberSelectionComparator(object) {
                    let comparator;
                    if (angular.isString($scope.selection.rememberSelectionComparator)) {
                        comparator = (el) => {
                            return el[$scope.selection.rememberSelectionComparator] === object[$scope.selection.rememberSelectionComparator];
                        };
                    } else if (angular.isFunction($scope.selection.rememberSelectionComparator)) {
                        comparator = (el) => {
                            return $scope.selection.rememberSelectionComparator(el, object);
                        };
                    } else {
                        comparator = (el) => {
                            return el === object;
                        };
                    }

                    return comparator;
                }

                function addOrRemoveRememberedObject(object) {
                    const comparator = getRememberSelectionComparator(object);
                    const rememberedElementIndex = $scope.selection.selectedObjects.findIndex(comparator);
                    if (object.$selected && rememberedElementIndex === -1) {
                        $scope.selection.selectedObjects.push(object);
                    } else if (!object.$selected && rememberedElementIndex !== -1) {
                        $scope.selection.selectedObjects.splice(rememberedElementIndex, 1);
                    }
                }

                var clickHappened = function(object, event, source, oldSelected) {
                    var idx = $scope.selection.filteredObjects.indexOf(object);
                    if ($scope.selection.rememberSelection) {
                        addOrRemoveRememberedObject(object);
                    }
                    if (idx === -1) {
                        return;
                    }

                    if (source == "checkbox") {
                        setSelectedObject(object);
                    } else if (event.ctrlKey || event.metaKey) {
                        handleObjectSelection(object, !oldSelected);
                    } else {
                        if (attrs.doubleSelectUnselects && $scope.selection.selectedObjects.length == 0 && $scope.selection.selectedObject === object) {
                            setSelectedObject(null);
                        }

                        if (source == "click") {
                            $scope.selection.filteredSelectedObjects.forEach(obj => handleObjectSelection(obj, false));
                            // If multiple objects are selected and we click on an object, unselect everything except the clicked one
                            const selected = $scope.selection.selectedObjects.length > 1 ? true : !oldSelected;
                            handleObjectSelection(object, selected);
                            setSelectedObject(object);
                        }
                    }

                    if (event.shiftKey && $scope.selection.selectedObjects.length > 0) {
                        // extend selection within the filtered objects
                        var firstSelected = $scope.selection.filteredObjects.indexOf($scope.selection.selectedObjects[0]);
                        var lastSelected = $scope.selection.filteredObjects.indexOf($scope.selection.selectedObjects[$scope.selection.selectedObjects.length -1]);
                        var newFirstSelected = Math.min(firstSelected, idx);
                        var newLastSelected = Math.max(lastSelected, idx);
                        $scope.selection.filteredObjects.forEach(function(o, i) {
                            handleObjectSelection(o, i >= newFirstSelected && i <= newLastSelected);
                        });
                    } else if (attrs.selectClickBehaviour && source === 'click') {
                        if (attrs.selectClickBehaviour === 'select-one') {
                            $scope.selection.selectedObjects.forEach(function(o) {
                                handleObjectSelection(o, false);
                            });
                            handleObjectSelection(object, true);
                        } else {
                            handleObjectSelection(object, !object.$selected);
                        }
                    }
                    regenSelectionStateFromFlags();

                    // If only one item remains selected in the list, select it for the right panel
                    if ($scope.selection.selectedObjects.length === 1 && !$scope.selection.selectedObject) {
                        $scope.selection.selectedObject = $scope.selection.selectedObjects[0];
                    }
                };

                $scope.checkBoxChanged = function(object,event) {
                    // in a timeout so that the checkbox doesn't get disconnected from its state
                    var oldSelected = object.$selected;
                    return $timeout(() => {
                        clickHappened(object, event, "checkbox", oldSelected);
                        if (attrs.keepFocusOn) {
                            element.focus();
                        }
                    });
                };
                $scope.objectClicked = function(object, event) {
                    /* Actually handles the click */
                    clickHappened(object, event, "click", object.$selected);
                    event.preventDefault();
                };
                $scope.regenSelectionStateFromFlags = regenSelectionStateFromFlags;
                $scope.updateSorted = updateSorted;

                var keyCodes = {
                    tab: 9,
                    pageup: 33,
                    pagedown: 34,
                    left: 37,
                    up: 38,
                    right: 39,
                    down: 40,
                    space: 32,
                };
                $scope.multiSelectKeydown = function(event, callFromFatTable) {
                    function setNewSelected(newObj) {
                        setSelectedObject(newObj);
                        sd.exec(function() {
                            $scope.selection.confirmedItem = $scope.selection.selectedObject;
                        });
                    }

                    function selectIfNotSelected(newObj) {
                        if (!newObj || newObj.$selected) {
                            return;
                        }
                        if (!event.shiftKey) {
                            $scope.selection.selectedObjects.forEach(o => handleObjectSelection(o, false));
                        }
                        newObj.$selected = true;
                        setNewSelected(newObj);
                    }

                    if ($(event.target).is('input:text')||$(event.target).is('textarea')) {
                        return;
                    }

                    var object = $scope.selection.selectedObject;
                    var idx = $scope.selection.filteredObjects.indexOf(object);
                    if (idx === -1) {return;}

                    if (event.keyCode === keyCodes.up) {
                        event.preventDefault();
                        if (idx > 0) {
                            for (let i = 1; i <= idx; i++) {
                                if ($scope.selection.filteredObjects[i].$selected) {
                                    selectIfNotSelected($scope.selection.filteredObjects[i-1]);
                                    break;
                                }
                            }
                        }
                    } else if (event.keyCode === keyCodes.down) {
                        event.preventDefault();
                        if (idx < $scope.selection.filteredObjects.length - 1) {
                            for (let i = $scope.selection.filteredObjects.length - 2; i >= idx; i--) {
                                if ($scope.selection.filteredObjects[i].$selected) {
                                    selectIfNotSelected($scope.selection.filteredObjects[i+1]);
                                    break;
                                }
                            }
                        }
                    }
                    if (callFromFatTable && (event.keyCode === keyCodes.up || event.keyCode === keyCodes.down)) {
                        $scope.$broadcast('scrollToLine', idx);
                    }
                    regenSelectionStateFromFlags();
                }

                function initSelection() {
                    if ($scope.selection === undefined) {$scope.selection={};}
                    $scope.selection.rememberSelection = attrs.rememberSelection !== undefined;
                    $scope.isItemSelectablePredicate = (el) => {
                        const passedFunction = $scope.$eval(attrs.isItemSelectablePredicate);
                        return passedFunction === undefined || angular.isFunction(passedFunction) && passedFunction(el) === true
                    };
                    if ($scope.selection.rememberSelection) {
                        $scope.selection.rememberSelectionComparator = $scope.$eval(attrs.rememberSelectionComparator);
                        $scope.selection.selectedObjects = [];
                    }
                    if ($scope.selection.orderQuery===undefined) {$scope.selection.orderQuery=[];}
                    if ($scope.selection.filterQuery===undefined) {$scope.selection.filterQuery={};}
                    if ($scope.selection.orderReversed===undefined) {$scope.selection.orderReversed=false;}
                    // fill with empty & wait for scope to refresh to continue
                    if ($scope.selection.allObjects===undefined) {$scope.selection.allObjects=[];}
                    if ($scope.selection.filteredObjects===undefined) {$scope.selection.filteredObjects=[];}
                    if ($scope.selection.filterParams===undefined) {$scope.selection.filterParams={};}
                    if ($scope.selection.partial === undefined) {$scope.selection.partial = {};}

                    if (attrs.updateActiveProjectKey) setSelectedObject(null);

                    $timeout(function () {
                        updateFilter();
                        if (attrs.autoSelectFirst && $scope.selection.allObjects.length > 0) {
                            $scope.selection.filteredObjects.forEach(function (o) {
                                handleObjectSelection(o, false);
                            });
                            setSelectedObject($scope.selection.filteredObjects[0]);
                            handleObjectSelection($scope.selection.filteredObjects[0], true);
                            regenSelectionStateFromFlags();
                        }
                        if (attrs.autoFocusFirst) {
                            $scope.selection.filteredObjects.forEach(function (o) {
                                handleObjectSelection(o, false);
                            });
                            setSelectedObject($scope.selection.filteredObjects[0]);
                            regenSelectionStateFromFlags();
                        }
                    });
                }
                initSelection();
                $scope.$watch('selection.filterQuery', debouncedUpdateFilter, true);
                if ($scope.selection.customFilterWatch) {
                    $scope.$watch($scope.selection.customFilterWatch, debouncedUpdateFilter, true);
                }
                $scope.$watch('selection.orderQuery', updateSorted, true);
                $scope.$watch('selection.orderReversed', updateSorted);

                // We can't deep watch all the objects of the list (very slow), so this event can be used to refresh list's ordering when an item was mutated
                $scope.$on('refresh-list', updateFilter);

                $scope.$watch(attrs.ngModel, updateFilter); // $watchCollection doesn't trigger on array reference changes
			    $scope.$watchCollection(attrs.ngModel, updateFilter); // to catch changes caused by adding/removing
			}
		};
	});

    app.directive("dkuFiltered", function(Fn, CollectionFiltering, $compile) {
        // small directive wrapping CollectionFiltering (magic around angular filter)
        // use <div dku-filtered="collectionToFilter"></div>
        // Defines a new scope with :
        //  * objects.all : list of all elements of collectionToFilter
        //  * objects.filterQuery : filterQuery to be passed to CollectionFiltering (see its doc)
        //  * objects.filterParams : filterParams to be passed to CollectionFiltering (see its doc)
        //  * objects.filtered : filtered elements of collectionToFilter
        return {
            scope : true,
            link : function($scope, element, attrs) {
                $scope.objects = {};
                var updateFilter = function() {
                    $scope.objects.filtered = CollectionFiltering.filter($scope.objects.all, $scope.objects.filterQuery, $scope.objects.filterParams);
                }
                var updateObjects = function(nv) {
                    $scope.objects.all = nv || [];
                    if ($scope.objects.all.constructor !== Array) {
                        $scope.objects.all = $.map($scope.objects.all, function(v,k) {v._name=k; return [v]});
                    }
                    updateFilter();
                };
                $scope.updateObjects = updateObjects;
                $scope.$watch(attrs.dkuFiltered, updateObjects, true);
                $scope.$watch('objects.filterQuery', updateFilter, true);
            }
        };
    });

    app.directive('activityIndicator', function() {
        return {
            restrict: 'E',
            scope : {
                activityIndicator : '='
            },
            templateUrl: "/templates/activity-indicator.html"
        }
    });

})();

(function() {
'use strict';

const app = angular.module('dataiku.directives.forms', ['dataiku.directives.forms']);


app.directive('checkUnique', function(DataikuAPI, $stateParams) {
    return {
        require: 'ngModel',
        scope: {
            exclude: '='
        },
        link: function(scope, elem, attrs, ngModel) {
            function format(v) {
                return v ? v.toLowerCase() : '';
            }

            function apply_validation(value) {
                ngModel.$setValidity('unique', true);
                if (scope.exclude && value) {
                    const valid = !scope.exclude.find(x => format(x) == format(value));
                    ngModel.$setValidity('unique', valid);
                }
                return value;
            }

            //For DOM -> model validation
            ngModel.$parsers.unshift(apply_validation);

            //For model -> DOM validation
            ngModel.$formatters.unshift(function(value) {
                apply_validation(value);
                return value;
            });
        }
    };
});

app.directive("objectTypePicker", function(TAGGABLE_TYPES) {
   return {
       templateUrl: '/templates/widgets/object-type-picker.html',
       restrict: 'A',
       scope: {
            objectTypePicker: '=',     // @param (optional) forwarded to dkuBsSelect
            objectType: '=',           // @model the selected taggable type
            exclude: '=?',             // @param (optional) array of types to exclude
            include: '=?',             // @param (optional) array of types to include (ignored if exclude if non-null)
            ngDisabled: '=?',
            allOption: '=?'
       },
       link: function($scope) {
            $scope.taggableTypes = TAGGABLE_TYPES;
            $scope.typeFilter = function(type) {
                if ($scope.exclude) {
                    return $scope.exclude.indexOf(type) == -1;
                } else if ($scope.include) {
                    return $scope.include.indexOf(type) != -1;
                }
                return true;
           }
       }
   }
});


app.directive("projectKeyPicker", function(DataikuAPI) {
    return {
        templateUrl: '/templates/widgets/project-key-picker.html',
        restrict: 'AE',
        scope: {
            projectKeyPicker: '=',  // @param (optional) forwarded to dkuBsSelect
            projectKey: '=',        // @model the selected projectKey
            project: '=?'           // @model bound to the selected project
        },
        link: function($scope) {
            function findProject() {
                $scope.project = $scope.projects.find(prj => prj.projectKey == $scope.projectKey);
            }
            DataikuAPI.projects.list()
                .success(function (projects) {
                    $scope.projects = projects;
                    findProject();
                });//TODO @errorHandling
            $scope.$watch("projectKey", function() {
                if ($scope.projects) {
                    findProject();
                }
            });
        }
    }
});


app.directive('computablePicker', function(DataikuAPI, $stateParams) {
    return {
        template: '<div dataset-selector="computable" available-datasets="availableComputables"></div>',
        restrict: 'A',
        scope: {
            computable: '=computablePicker',
            type: '@'
        },
        link: function($scope, element) {
            DataikuAPI.flow.listUsableComputables($stateParams.projectKey, {type: $scope.type}).success(function(data) {
                $scope.availableComputables = data;
            }).error(setErrorInScope.bind($scope.$parent));
        }
    };
});


app.directive('objectPicker', function(DataikuAPI, $stateParams, $rootScope, ActiveProjectKey) {
    return {
        templateUrl : '/templates/widgets/object-picker.html',
        restrict: 'A',
        scope: {
            objectSmartId: '=objectPicker',                  // @model bound to the smartId of the selected object
            object: '=?',                                    // @model bound to the selected object
            type: '@',                                       // @param taggable type
            unusable: '=?',                                  // @param smartIds of unusable objects (as array, or map: id -> unusable (boolean))
            popoverPlacement: '@?',
            emptyMessage: '@?',
            ngDisabled: '=?',
            errorScope: '=?',
            availableObjects: '=?',
            permissionMode: '@?',                            // @param the desired ReaderAuthorization.Mode (defaults to READ)
            hideForeign: '=?',                               // @param (boolean) to hide foreign objects,
            projectKey: '=?',
            noLiveUpdate: '=?'                               // @param (boolean) to stop up/down arrows auto-adding items from the pick list
        },
        link: function($scope, element) {
            $scope.object = null;
            const projectKey = $scope.projectKey || ActiveProjectKey.get();

            function findObject() {
                $scope.object = $scope.availableObjects.filter(function(d) {
                    return d.smartId == $scope.objectSmartId;
                })[0];
            }

            function refreshObjects() {
                if (!projectKey && $scope.type != 'PROJECT') {
                    console.info('No project key specified, not listing accessible objects');
                    return;
                }
                DataikuAPI.taggableObjects.listAccessibleObjects(projectKey, $scope.type, $scope.permissionMode).success(function(data) {
                    $scope.availableObjects = data;
                    updateUsability();
                    findObject();
                }).error(function(data, status, headers, config, statusText) {
                    setErrorInScope.bind($scope.errorScope || $scope.$parent)(data, status, headers, config, statusText);
                });
            }

            $scope.$watch("type", function(nv, ov) {
                if (!nv || (nv == ov && $scope.availableObjects)) return;

                if (ov && nv != ov) {
                    $scope.object = null;
                    $scope.objectSmartId = null;
                }

                refreshObjects();
            });

            $scope.$watch("permissionMode", function(nv, ov) {
                if (!nv || !ov || nv == ov) return;
                refreshObjects();
            });

            $scope.$watch('objectSmartId', function(nv) {
                if ($scope.availableObjects) {
                    findObject();
                }
            });

            $scope.$watch(function(scope) {
                if (angular.isObject(scope.unusable)) {
                    var simplified = {};
                    for (var key in scope.unusable) {
                        simplified[key] = !!scope.unusable[key];
                    }
                    return simplified;
                } else {
                    return scope.unusable;
                }
            }, updateUsability, true);

            function updateUsability(nv, ov) {
                if (!$scope.availableObjects) return;

                if (!$scope.unusable) {
                    $scope.availableObjects.forEach(function(item) {
                        item.usable = true;
                    });
                } else if (angular.isArray($scope.unusable)) {
                    $scope.availableObjects.forEach(function(item) {
                        item.usable = ($scope.unusable || []).indexOf(item.smartId) == -1;
                    });
                } else if(angular.isObject($scope.unusable)) {
                    $scope.availableObjects.forEach(function(item) {
                        item.usable = !$scope.unusable[item.smartId];
                    });
                }
            }
        }
    };
});


app.directive('datasetSelector', function(ListFilter, $compile) {
    var ret = {
        restrict : 'A',
        transclude: true,
        scope : {
            type:'@',
            availableDatasets : '=',
            datasetSelector : '=',
            transclude : '@',
            popoverPlacement: '@',
            marginTop: '@',
            noLiveUpdate : '@',
            ngDisabled: '=?',
            hideForeign: '=?',
            emptyMessage: '@?',
            multi: '@'
        },
        templateUrl : '/templates/dataset-selector.html',
    };

    ret.compile = function(element, attrs) {
        var popoverTemplate = element.find('.popover').detach();
        return function($scope, element, attrs) {
            var popover = null;

            if ($scope.multi) {
                $scope.noLiveUpdate = true;
                $scope.datasetSelector = $scope.datasetSelector || [];
            } 

            if ($scope.transclude) $(element).on('click', function(event) {
                if (event && event.target && event.target.hasAttribute('href') || $scope.ngDisabled) return;
                $scope.togglePopover();
                $scope.$apply();
            });

            /* List management */
            function update() {
                $scope.displayedDatasets = [];
                if (!$scope.availableDatasets) return;

                $scope.filtered = $scope.availableDatasets;

                // Filter on terms
                $scope.filtered = ListFilter.filter($scope.availableDatasets, $scope.filter.query);

                var groups = {}
                for (var i in  $scope.filtered) {
                    var group = "";
                    var sort = "";
                    if ( $scope.filtered[i].localProject) {
                        group =  ($scope.filtered[i].label || $scope.filtered[i].name) [0].toUpperCase();
                        sort = "AAAAAAAA" + group;
                    } else {
                        if ($scope.hideForeign) {
                            continue;
                        }
                        group = "Project: " +  $scope.filtered[i].projectKey;
                        sort = group;
                    }
                    if (! groups[group]) {
                         groups[group] = {title : group, datasets : [], sort:sort}
                    }
                    groups[group].datasets.push( $scope.filtered[i]);
                }
                $scope.displayedGroups = [];
                for (var g in groups) {
                    groups[g].datasets.sort(function(a,b) { return (a.label || a.name).localeCompare(b.label || b.name)})
                    $scope.displayedGroups.push(groups[g]);
                }
                $scope.displayedGroups.sort(function(a,b) { return a.sort.localeCompare(b.sort)})

                $scope.currentlySelected = null;
                for (var i in $scope.availableDatasets) {
                    if (($scope.availableDatasets[i].smartName || $scope.availableDatasets[i].smartId) == $scope.datasetSelector) {
                        $scope.currentlySelected = $scope.availableDatasets[i];
                    }
                }


            }
            $scope.filter = {
                allProjects : true,
                query : ""
            }
            $scope.$watch("filter", update, true);
            $scope.$watchCollection("availableDatasets", update);
            update();

            /* Model management */

            $scope.select = function(details) {
                const itemId = details.smartName || details.smartId;
                if (!$scope.multi) {
                    $scope.datasetSelector = itemId;
                    hide();
                } else {
                    $scope.datasetSelector.push(itemId);
                }
            };

            $scope.itemClicked = function(details) {
                const itemId = details.smartName || details.smartId;

                if (!$scope.multi) {
                    if (itemId === $scope.datasetSelector) {
                        $scope.datasetSelector = null;
                    } else {
                        $scope.datasetSelector = itemId;
                    }
                    hide();
                } else {
                    const detailsIndex = $scope.datasetSelector.indexOf(itemId);
                    if (detailsIndex >= 0) {
                        $scope.datasetSelector.splice(detailsIndex, 1);
                    } else {
                        $scope.datasetSelector.push(itemId);
                    }
                }
            };

            $scope.isItemSelected = function(item) {
                const itemId = item.smartName || item.smartId;

                if (!$scope.multi) {
                    return $scope.datasetSelector === itemId;
                } else {
                    return $scope.datasetSelector.indexOf(itemId) >= 0;
                }
            }

            $scope.$watch("datasetSelector", function(newValue, oldValue) {
                update();
            });

            /* Popover management */
            var popoverShown = false;
            $(popover).hide();
            var hide = function() {
                popover.hide().detach();
                $("html").unbind("click", hide);
                popoverShown=false;
            };
            var show = function() {
                var mainZone = $(".mainzone", element);
                popoverShown = true;
                if (popover == null) {
                    popover = $compile(popoverTemplate.clone())($scope);
                }
                popover.appendTo("body");

                popover.css("width", attrs.popoverWidth ? attrs.popoverWidth : Math.max(300, mainZone.width() + 20));
                if ($scope.popoverPlacement == 'right') {
                    popover.css("left", mainZone.offset().left - popover.width() + mainZone.width() +4);
                } else {
                    popover.css("left", mainZone.offset().left);
                }
                popover.css("top", mainZone.offset().top + mainZone.height() + ($scope.marginTop ? parseInt($scope.marginTop) : 8));

                if ($scope.popoverPlacement == 'auto') {
                    if (mainZone.offset().top + mainZone.height() + 280 > $(window).height()) {
                        popover.css("top", mainZone.offset().top - 310);
                    }
                }

                popover.show();

                popover.find("input").off('blur.dsSelector').on('blur.dsSelector',function() {
                    popover.find("input").focus();
                });
                popover.find("input").focus();

                popover.off("click.dku-pop-over").on("click.dku-pop-over", function(e) {
                    //e.stopPropagation();
                });
                $(".mainzone", element).off("click.dku-pop-over").on("click.dku-pop-over", function(e) {
                    //e.stopPropagation();
                });
                window.setTimeout(function() { $("html").click(function(event) {
                    if (event && event.target && $.contains(element[0], event.target)) return;
                    // In multi selection, do not close the dropdown when clicking an item.
                    if (!$scope.multi || !event.target.closest('.dss-object-selector__item')) {
                        hide();
                    } 
                }); }, 0);

                popover.find("input").off('keydown.dsSelector').on('keydown.dsSelector',function(event) {

                    if(event.keyCode==38 || event.keyCode==40 || event.keyCode==13) {
                        event.stopPropagation();
                    } else {
                        return;
                    }

                    // Up and down in list
                    if(event.keyCode==38 || event.keyCode==40) {
                        if($scope.displayedGroups &&  $scope.displayedGroups.length>0) {

                            var previous = null;
                            var next = null;
                            var current = null;
                            var first = null;
                            var foundCurrent = false;
                            var last = null;
                            var updateNext = false;

                            for(var k = 0 ; k < $scope.displayedGroups.length ; k++) {
                                var group = $scope.displayedGroups[k];
                                for(var j = 0 ; j < group.datasets.length ; j++) {
                                    var ds = group.datasets[j];
                                    if(!ds.usable) {
                                        continue;
                                    }
                                    if(!first) {
                                        first = ds;
                                    }
                                    last = ds;
                                    if(foundCurrent) {
                                        if(updateNext) {
                                            next = ds;
                                            updateNext=false;
                                        }
                                    } else {
                                        previous = current;
                                        current = ds;

                                        if($scope.currentlySelected == ds) {
                                            foundCurrent = true;
                                            updateNext = true;
                                        }
                                    }
                                }
                            }
                             $scope.$apply(function() {
                                if(foundCurrent) {
                                    if(event.keyCode == 40) {
                                        if(next) {
                                            $scope.currentlySelected = next;
                                        } else {
                                            $scope.currentlySelected = first;
                                        }
                                    }
                                    if(event.keyCode == 38) {
                                        if(previous) {
                                            $scope.currentlySelected = previous;
                                        } else {
                                            $scope.currentlySelected = last;
                                        }
                                    }
                                } else {
                                    if(first) {
                                        $scope.currentlySelected = first;
                                    }
                                }

                                if($scope.currentlySelected && !$scope.noLiveUpdate) {
                                    $scope.datasetSelector = $scope.currentlySelected.smartName || $scope.currentlySelected.smartId;
                                }
                            });
                        }

                    } 
                    // Enter
                    else if (event.keyCode === 13) {
                        if ($scope.currentlySelected) {
                            $scope.itemClicked($scope.currentlySelected);
                            $scope.$apply();
                        }
                    } else {
                        $scope.currentlySelected = null;
                    }

                });
            };

            $scope.togglePopover =function() {
                if (popoverShown) hide();
                else show();
            }
        }
    }
    return ret;
});


//TODO @dssObjects factorize
app.directive('savedModelSelector', function($timeout, ListFilter, $compile) {
    var ret = {
        restrict : 'A',
        transclude: true,
        scope : {
            type:'@',
            availableSavedModels : '=',
            savedModelSelector : '=',
            transclude : '@',
            popoverPlacement: '@',
            marginTop: '@',
            noLiveUpdate : '@',
            ngDisabled: '=?'
        },
        templateUrl : '/templates/model-selector.html',
    };

    ret.compile = function(element, attrs) {
        var popoverTemplate = element.find('.popover').detach();
        return function($scope, element, attrs) {

            var popover = null;
            if ($scope.transclude) $(element).on('click', function(event) {
                if (event && event.target && event.target.hasAttribute('href') || $scope.ngDisabled) return;
                $scope.togglePopover();
            });

            /* List management */
            function update() {
                $scope.displayedSavedModels = [];
                if (!$scope.availableSavedModels) return;

                $scope.filtered = $scope.availableSavedModels;

                // Filter on terms
                $scope.filtered = ListFilter.filter($scope.availableSavedModels, $scope.filter.query);

                var groups = {}
                for (var i in  $scope.filtered) {
                    var group = "";
                    var sort = "";
                    if ( $scope.filtered[i].localProject) {
                        group =  ($scope.filtered[i].label || $scope.filtered[i].name) [0].toUpperCase();
                        sort = "AAAAAAAA" + group;
                    } else {
                        group = "Project: " +  $scope.filtered[i].projectKey;
                        sort = group;
                    }
                    if (! groups[group]) {
                         groups[group] = {title : group, savedModels : [], sort:sort}
                    }
                    groups[group].savedModels.push( $scope.filtered[i]);
                }
                $scope.displayedGroups = [];
                for (var g in groups) {
                    groups[g].savedModels.sort(function(a,b) { return (a.label || a.name).localeCompare(b.label || b.name)})
                    $scope.displayedGroups.push(groups[g]);
                }
                $scope.displayedGroups.sort(function(a,b) { return a.sort.localeCompare(b.sort)})

                $scope.currentlySelected = null;
                for (var i in $scope.availableSavedModels) {
                    if (($scope.availableSavedModels[i].smartName || $scope.availableSavedModels[i].smartId) == $scope.savedModelSelector) {
                        $scope.currentlySelected = $scope.availableSavedModels[i];
                    }
                }


            }
            $scope.filter = {
                allProjects : true,
                query : ""
            }
            $scope.$watch("filter", function() {
                update();
            }, true);
            $scope.$watch("availableSavedModels", function() {
                update();
            }, true);
            update();

            /* Model management */

            $scope.select = function(details) {
                //ngModel.$setViewValue(details.smartName);
                $scope.savedModelSelector = details.smartName || details.smartId;
                hide();
            };

            $scope.itemClicked = function(details) {
                //ngModel.$setViewValue(details.smartName);
                if ((details.smartName || details.smartId) == $scope.savedModelSelector) {
                    $scope.savedModelSelector = null;
                } else {
                    $scope.savedModelSelector = details.smartName || details.smartId;
                }
                hide();
            };

            $scope.$watch("savedModelSelector", function(newValue, oldValue) {
                update();
            });

            /* Popover management */
            var popoverShown = false;
            $(popover).hide();
            var hide = function() {
                popover.hide().detach();
                $("html").unbind("click", hide);
                popoverShown=false;
            };
            var show = function() {
                var mainZone = $(".mainzone", element);
                popoverShown = true;
                if (popover == null) {
                    popover = $compile(popoverTemplate.clone())($scope);
                }
                popover.appendTo("body");

                popover.css("width", attrs.popoverWidth ? attrs.popoverWidth : Math.max(300, mainZone.width() + 20));
                if ($scope.popoverPlacement == 'right') {
                    popover.css("left", mainZone.offset().left - popover.width() + mainZone.width() +4);
                } else {
                    popover.css("left", mainZone.offset().left);
                }
                popover.css("top", mainZone.offset().top + mainZone.height() + ($scope.marginTop ? parseInt($scope.marginTop) : 8));

                if ($scope.popoverPlacement == 'auto') {
                    if (mainZone.offset().top + mainZone.height() + 280 > $(window).height()) {
                        popover.css("top", mainZone.offset().top - 310);
                    }
                }

                popover.show();

                popover.find("input").off('blur.dsSelector').on('blur.dsSelector',function() {
                    popover.find("input").focus();
                });
                popover.find("input").focus();

                popover.off("click.dku-pop-over").on("click.dku-pop-over", function(e) {
                    //e.stopPropagation();
                });
                $(".mainzone", element).off("click.dku-pop-over").on("click.dku-pop-over", function(e) {
                    //e.stopPropagation();
                });
                window.setTimeout(function() { $("html").click(function(event) {
                    if (event && event.target && $.contains(element[0], event.target)) return;
                    hide();
                }); }, 0);

                popover.find("input").off('keydown.dsSelector').on('keydown.dsSelector',function(event) {

                    if(event.keyCode==38 || event.keyCode==40 || event.keyCode==13) {
                        event.stopPropagation();
                    } else {
                        return;
                    }

                    if(event.keyCode==38 || event.keyCode==40) {

                        if($scope.displayedGroups &&  $scope.displayedGroups.length>0) {

                            var previous = null;
                            var next = null;
                            var current = null;
                            var first = null;
                            var foundCurrent = false;
                            var last = null;
                            var updateNext = false;

                            for(var k = 0 ; k < $scope.displayedGroups.length ; k++) {
                                var group = $scope.displayedGroups[k];
                                for(var j = 0 ; j < group.savedModels.length ; j++) {
                                    var ds = group.savedModels[j];
                                    if(!ds.usable) {
                                        continue;
                                    }
                                    if(!first) {
                                        first = ds;
                                    }
                                    last = ds;
                                    if(foundCurrent) {
                                        if(updateNext) {
                                            next = ds;
                                            updateNext=false;
                                        }
                                    } else {
                                        previous = current;
                                        current = ds;

                                        if($scope.currentlySelected == ds) {
                                            foundCurrent = true;
                                            updateNext = true;
                                        }
                                    }
                                }
                            }

                            $scope.$apply(function() {
                                if(foundCurrent) {
                                    if(event.keyCode == 40) {
                                        if(next) {
                                            $scope.currentlySelected = next;
                                        } else {
                                            $scope.currentlySelected = first;
                                        }
                                    }
                                    if(event.keyCode == 38) {
                                        if(previous) {
                                            $scope.currentlySelected = previous;
                                        } else {
                                            $scope.currentlySelected = last;
                                        }
                                    }
                                } else {
                                    if(first) {
                                        $scope.currentlySelected = first;
                                    }
                                }

                                if($scope.currentlySelected && !$scope.noLiveUpdate) {
                                    $scope.savedModelSelector = $scope.currentlySelected.smartName || $scope.currentlySelected.smartId;
                                }
                            });
                        }

                    } else if(event.keyCode==13) {
                        if($scope.currentlySelected) {
                            $scope.select($scope.currentlySelected);
                            $scope.$apply();
                        }
                    }

                });
            };

            $scope.togglePopover =function() {
                if (popoverShown) hide();
                else show();
            }
        }
    }
    return ret;
});


//TODO @dssObjects factorize
app.directive('modelEvaluationStoreSelector', function($timeout, ListFilter, $compile) {
    var ret = {
        restrict : 'A',
        transclude: true,
        scope : {
            type:'@',
            availableModelEvaluationStores : '=',
            modelEvaluationStoreSelector : '=',
            transclude : '@',
            popoverPlacement: '@',
            marginTop: '@',
            noLiveUpdate : '@',
            ngDisabled: '=?'
        },
        templateUrl : '/templates/evaluation-store-selector.html',
    };

    ret.compile = function(element, attrs) {
        var popoverTemplate = element.find('.popover').detach();
        return function($scope, element, attrs) {

            var popover = null;
            if ($scope.transclude) $(element).on('click', function(event) {
                if (event && event.target && event.target.hasAttribute('href') || $scope.ngDisabled) return;
                $scope.togglePopover();
            });

            /* List management */
            function update() {
                $scope.displayedModelEvaluationStores = [];
                if (!$scope.availableModelEvaluationStores) return;

                $scope.filtered = $scope.availableModelEvaluationStores;

                // Filter on terms
                $scope.filtered = ListFilter.filter($scope.availableModelEvaluationStores, $scope.filter.query);

                var groups = {}
                for (var i in  $scope.filtered) {
                    var group = "";
                    var sort = "";
                    if ( $scope.filtered[i].localProject) {
                        group =  ($scope.filtered[i].label || $scope.filtered[i].name) [0].toUpperCase();
                        sort = "AAAAAAAA" + group;
                    } else {
                        group = "Project: " +  $scope.filtered[i].projectKey;
                        sort = group;
                    }
                    if (! groups[group]) {
                         groups[group] = {title : group, modelEvaluationStores : [], sort:sort}
                    }
                    groups[group].modelEvaluationStores.push( $scope.filtered[i]);
                }
                $scope.displayedGroups = [];
                for (var g in groups) {
                    groups[g].modelEvaluationStores.sort(function(a,b) { return (a.label || a.name).localeCompare(b.label || b.name)})
                    $scope.displayedGroups.push(groups[g]);
                }
                $scope.displayedGroups.sort(function(a,b) { return a.sort.localeCompare(b.sort)})

                $scope.currentlySelected = null;
                for (var i in $scope.availableModelEvaluationStores) {
                    if (($scope.availableModelEvaluationStores[i].smartName || $scope.availableModelEvaluationStores[i].smartId) == $scope.modelEvaluationStoreSelector) {
                        $scope.currentlySelected = $scope.availableModelEvaluationStores[i];
                    }
                }


            }
            $scope.filter = {
                allProjects : true,
                query : ""
            }
            $scope.$watch("filter", function() {
                update();
            }, true);
            $scope.$watch("availableModelEvaluationStores", function() {
                update();
            }, true);
            update();

            /* Store management */

            $scope.select = function(details) {
                //ngModel.$setViewValue(details.smartName);
                $scope.modelEvaluationStoreSelector = details.smartName || details.smartId;
                hide();
            };

            $scope.itemClicked = function(details) {
                //ngModel.$setViewValue(details.smartName);
                if ((details.smartName || details.smartId) == $scope.modelEvaluationStoreSelector) {
                    $scope.modelEvaluationStoreSelector = null;
                } else {
                    $scope.modelEvaluationStoreSelector = details.smartName || details.smartId;
                }
                hide();
            };

            $scope.$watch("modelEvaluationStoreSelector", function(newValue, oldValue) {
                update();
            });

            /* Popover management */
            var popoverShown = false;
            $(popover).hide();
            var hide = function() {
                popover.hide().detach();
                $("html").unbind("click", hide);
                popoverShown=false;
            };
            var show = function() {
                var mainZone = $(".mainzone", element);
                popoverShown = true;
                if (popover == null) {
                    popover = $compile(popoverTemplate.clone())($scope);
                }
                popover.appendTo("body");

                popover.css("width", attrs.popoverWidth ? attrs.popoverWidth : Math.max(300, mainZone.width() + 20));
                if ($scope.popoverPlacement == 'right') {
                    popover.css("left", mainZone.offset().left - popover.width() + mainZone.width() +4);
                } else {
                    popover.css("left", mainZone.offset().left);
                }
                popover.css("top", mainZone.offset().top + mainZone.height() + ($scope.marginTop ? parseInt($scope.marginTop) : 8));

                if ($scope.popoverPlacement == 'auto') {
                    if (mainZone.offset().top + mainZone.height() + 280 > $(window).height()) {
                        popover.css("top", mainZone.offset().top - 310);
                    }
                }

                popover.show();

                popover.find("input").off('blur.dsSelector').on('blur.dsSelector',function() {
                    popover.find("input").focus();
                });
                popover.find("input").focus();

                popover.off("click.dku-pop-over").on("click.dku-pop-over", function(e) {
                    //e.stopPropagation();
                });
                $(".mainzone", element).off("click.dku-pop-over").on("click.dku-pop-over", function(e) {
                    //e.stopPropagation();
                });
                window.setTimeout(function() { $("html").click(function(event) {
                    if (event && event.target && $.contains(element[0], event.target)) return;
                    hide();
                }); }, 0);

                popover.find("input").off('keydown.dsSelector').on('keydown.dsSelector',function(event) {

                    if(event.keyCode==38 || event.keyCode==40 || event.keyCode==13) {
                        event.stopPropagation();
                    } else {
                        return;
                    }

                    if(event.keyCode==38 || event.keyCode==40) {

                        if($scope.displayedGroups &&  $scope.displayedGroups.length>0) {

                            var previous = null;
                            var next = null;
                            var current = null;
                            var first = null;
                            var foundCurrent = false;
                            var last = null;
                            var updateNext = false;

                            for(var k = 0 ; k < $scope.displayedGroups.length ; k++) {
                                var group = $scope.displayedGroups[k];
                                for(var j = 0 ; j < group.modelEvaluationStores.length ; j++) {
                                    var ds = group.modelEvaluationStores[j];
                                    if(!ds.usable) {
                                        continue;
                                    }
                                    if(!first) {
                                        first = ds;
                                    }
                                    last = ds;
                                    if(foundCurrent) {
                                        if(updateNext) {
                                            next = ds;
                                            updateNext=false;
                                        }
                                    } else {
                                        previous = current;
                                        current = ds;

                                        if($scope.currentlySelected == ds) {
                                            foundCurrent = true;
                                            updateNext = true;
                                        }
                                    }
                                }
                            }

                            $scope.$apply(function() {
                                if(foundCurrent) {
                                    if(event.keyCode == 40) {
                                        if(next) {
                                            $scope.currentlySelected = next;
                                        } else {
                                            $scope.currentlySelected = first;
                                        }
                                    }
                                    if(event.keyCode == 38) {
                                        if(previous) {
                                            $scope.currentlySelected = previous;
                                        } else {
                                            $scope.currentlySelected = last;
                                        }
                                    }
                                } else {
                                    if(first) {
                                        $scope.currentlySelected = first;
                                    }
                                }

                                if($scope.currentlySelected && !$scope.noLiveUpdate) {
                                    $scope.modelEvaluationStoreSelector = $scope.currentlySelected.smartName || $scope.currentlySelected.smartId;
                                }
                            });
                        }

                    } else if(event.keyCode==13) {
                        if($scope.currentlySelected) {
                            $scope.select($scope.currentlySelected);
                            $scope.$apply();
                        }
                    }

                });
            };

            $scope.togglePopover =function() {
                if (popoverShown) hide();
                else show();
            }
        }
    }
    return ret;
});


//TODO @dssObjects factorize
app.directive('folderSelector', function($timeout, ListFilter, $compile) {
    var ret = {
        restrict : 'A',
        transclude: true,
        scope : {
            type:'@',
            availableFolders : '=',
            folderSelector : '=',
            transclude : '@',
            popoverPlacement: '@',
            marginTop: '@',
            noLiveUpdate : '@',
            ngDisabled: '=?'
        },
        templateUrl : '/templates/folder-selector.html',
    };

    ret.compile = function(element, attrs) {
        var popoverTemplate = element.find('.popover').detach();
        return function($scope, element, attrs) {

            var popover = null;
            if ($scope.transclude) $(element).on('click', function(event) {
                if (event && event.target && event.target.hasAttribute('href') || $scope.ngDisabled) return;
                $scope.togglePopover();
            });

            /* List management */
            function update() {
                $scope.displayedFolders = [];
                if (!$scope.availableFolders) return;

                $scope.filtered = $scope.availableFolders;

                // Filter on terms
                $scope.filtered = ListFilter.filter($scope.availableFolders, $scope.filter.query);

                var groups = {}
                for (var i in  $scope.filtered) {
                    var group = "";
                    var sort = "";
                    if ( $scope.filtered[i].localProject) {
                        group =  ($scope.filtered[i].label || $scope.filtered[i].name) [0].toUpperCase();
                        sort = "AAAAAAAA" + group;
                    } else {
                        group = "Project: " +  $scope.filtered[i].projectKey;
                        sort = group;
                    }
                    if (! groups[group]) {
                         groups[group] = {title : group, folders : [], sort:sort}
                    }
                    groups[group].folders.push( $scope.filtered[i]);
                }
                $scope.displayedGroups = [];
                for (var g in groups) {
                    groups[g].folders.sort(function(a,b) { return (a.label || a.name).localeCompare(b.label || b.name)})
                    $scope.displayedGroups.push(groups[g]);
                }
                $scope.displayedGroups.sort(function(a,b) { return a.sort.localeCompare(b.sort)})

                $scope.currentlySelected = null;
                for (var i in $scope.availableFolders) {
                    if (($scope.availableFolders[i].smartName || $scope.availableFolders[i].smartId) == $scope.folderSelector) {
                        $scope.currentlySelected = $scope.availableFolders[i];
                    }
                }


            }
            $scope.filter = {
                allProjects : true,
                query : ""
            }
            $scope.$watch("filter", function() {
                update();
            }, true);
            $scope.$watch("availableFolders", function() {
                update();
            }, true);
            update();

            /* Model management */

            $scope.select = function(details) {
                //ngModel.$setViewValue(details.smartName);
                $scope.folderSelector = details.smartName || details.smartId;
                hide();
            };

            $scope.itemClicked = function(details) {
                //ngModel.$setViewValue(details.smartName);
                if ((details.smartName || details.smartId) == $scope.folderSelector) {
                    $scope.folderSelector = null;
                } else {
                    $scope.folderSelector = details.smartName || details.smartId;
                }
                hide();
            };

            $scope.$watch("folderSelector", function(newValue, oldValue) {
                update();
            });

            /* Popover management */
            var popoverShown = false;
            $(popover).hide();
            var hide = function() {
                popover.hide().detach();
                $("html").unbind("click", hide);
                popoverShown=false;
            };
            var show = function() {
                var mainZone = $(".mainzone", element);
                popoverShown = true;
                if (popover == null) {
                    popover = $compile(popoverTemplate.clone())($scope);
                }
                popover.appendTo("body");

                popover.css("width", attrs.popoverWidth ? attrs.popoverWidth : Math.max(300, mainZone.width() + 20));
                if ($scope.popoverPlacement == 'right') {
                    popover.css("left", mainZone.offset().left - popover.width() + mainZone.width() +4);
                } else {
                    popover.css("left", mainZone.offset().left);
                }
                popover.css("top", mainZone.offset().top + mainZone.height() + ($scope.marginTop ? parseInt($scope.marginTop) : 8));

                if ($scope.popoverPlacement == 'auto') {
                    if (mainZone.offset().top + mainZone.height() + 280 > $(window).height()) {
                        popover.css("top", mainZone.offset().top - 310);
                    }
                }

                popover.show();

                popover.find("input").off('blur.dsSelector').on('blur.dsSelector',function() {
                    popover.find("input").focus();
                });
                popover.find("input").focus();

                popover.off("click.dku-pop-over").on("click.dku-pop-over", function(e) {
                    //e.stopPropagation();
                });
                $(".mainzone", element).off("click.dku-pop-over").on("click.dku-pop-over", function(e) {
                    //e.stopPropagation();
                });
                window.setTimeout(function() { $("html").click(function(event) {
                    if (event && event.target && $.contains(element[0], event.target)) return;
                    hide();
                }); }, 0);

                popover.find("input").off('keydown.dsSelector').on('keydown.dsSelector',function(event) {

                    if(event.keyCode==38 || event.keyCode==40 || event.keyCode==13) {
                        event.stopPropagation();
                    } else {
                        return;
                    }

                    if(event.keyCode==38 || event.keyCode==40) {

                        if($scope.displayedGroups &&  $scope.displayedGroups.length>0) {

                            var previous = null;
                            var next = null;
                            var current = null;
                            var first = null;
                            var foundCurrent = false;
                            var last = null;
                            var updateNext = false;

                            for(var k = 0 ; k < $scope.displayedGroups.length ; k++) {
                                var group = $scope.displayedGroups[k];
                                for(var j = 0 ; j < group.folders.length ; j++) {
                                    var ds = group.folders[j];
                                    if(!ds.usable) {
                                        continue;
                                    }
                                    if(!first) {
                                        first = ds;
                                    }
                                    last = ds;
                                    if(foundCurrent) {
                                        if(updateNext) {
                                            next = ds;
                                            updateNext=false;
                                        }
                                    } else {
                                        previous = current;
                                        current = ds;

                                        if($scope.currentlySelected == ds) {
                                            foundCurrent = true;
                                            updateNext = true;
                                        }
                                    }
                                }
                            }

                            $scope.$apply(function() {
                                if(foundCurrent) {
                                    if(event.keyCode == 40) {
                                        if(next) {
                                            $scope.currentlySelected = next;
                                        } else {
                                            $scope.currentlySelected = first;
                                        }
                                    }
                                    if(event.keyCode == 38) {
                                        if(previous) {
                                            $scope.currentlySelected = previous;
                                        } else {
                                            $scope.currentlySelected = last;
                                        }
                                    }
                                } else {
                                    if(first) {
                                        $scope.currentlySelected = first;
                                    }
                                }

                                if($scope.currentlySelected && !$scope.noLiveUpdate) {
                                    $scope.folderSelector = $scope.currentlySelected.smartName || $scope.currentlySelected.smartId;
                                }
                            });
                        }

                    } else if(event.keyCode==13) {
                        if($scope.currentlySelected) {
                            $scope.select($scope.currentlySelected);
                            $scope.$apply();
                        }
                    }

                });
            };

            $scope.togglePopover =function() {
                if (popoverShown) hide();
                else show();
            }
        }
}
    return ret;
});

//TODO @dssObjects factorize
app.directive('streamingEndpointSelector', function($timeout, ListFilter, $compile, StateUtils) {
    var ret = {
        restrict : 'A',
        transclude: true,
        scope : {
            type:'@',
            availableStreamingEndpoints : '=',
            streamingEndpointSelector : '=',
            transclude : '@',
            popoverPlacement: '@',
            marginTop: '@',
            noLiveUpdate : '@',
            ngDisabled: '=?'
        },
        templateUrl : '/templates/streaming-endpoint-selector.html',
    };

    ret.compile = function(element, attrs) {
        var popoverTemplate = element.find('.popover').detach();
        return function($scope, element, attrs) {
        
            $scope.StateUtils = StateUtils; 
            var popover = null;
            if ($scope.transclude) $(element).on('click', function(event) {
                if (event && event.target && event.target.hasAttribute('href') || $scope.ngDisabled) return;
                $scope.togglePopover();
            });

            /* List management */
            function update() {
                $scope.displayedStreamingEndpoints = [];
                if (!$scope.availableStreamingEndpoints) return;

                $scope.filtered = $scope.availableStreamingEndpoints;

                // Filter on terms
                $scope.filtered = ListFilter.filter($scope.availableStreamingEndpoints, $scope.filter.query);

                var groups = {}
                for (var i in  $scope.filtered) {
                    var group = "";
                    var sort = "";
                    if ( $scope.filtered[i].localProject) {
                        group =  ($scope.filtered[i].label || $scope.filtered[i].name) [0].toUpperCase();
                        sort = "AAAAAAAA" + group;
                    } else {
                        group = "Project: " +  $scope.filtered[i].projectKey;
                        sort = group;
                    }
                    if (! groups[group]) {
                         groups[group] = {title : group, streamingEndpoints : [], sort:sort}
                    }
                    groups[group].streamingEndpoints.push( $scope.filtered[i]);
                }
                $scope.displayedGroups = [];
                for (var g in groups) {
                    groups[g].streamingEndpoints.sort(function(a,b) { return (a.label || a.name).localeCompare(b.label || b.name)})
                    $scope.displayedGroups.push(groups[g]);
                }
                $scope.displayedGroups.sort(function(a,b) { return a.sort.localeCompare(b.sort)})

                $scope.currentlySelected = null;
                for (var i in $scope.availableStreamingEndpoints) {
                    if (($scope.availableStreamingEndpoints[i].smartName || $scope.availableStreamingEndpoints[i].smartId) == $scope.streamingEndpointSelector) {
                        $scope.currentlySelected = $scope.availableStreamingEndpoints[i];
                    }
                }


            }
            $scope.filter = {
                allProjects : true,
                query : ""
            }
            $scope.$watch("filter", function() {
                update();
            }, true);
            $scope.$watch("availableStreamingEndpoints", function() {
                update();
            }, true);
            update();

            /* Model management */

            $scope.select = function(details) {
                //ngModel.$setViewValue(details.smartName);
                $scope.streamingEndpointSelector = details.smartName || details.smartId;
                hide();
            };

            $scope.itemClicked = function(details) {
                //ngModel.$setViewValue(details.smartName);
                if ((details.smartName || details.smartId) == $scope.streamingEndpointSelector) {
                    $scope.streamingEndpointSelector = null;
                } else {
                    $scope.streamingEndpointSelector = details.smartName || details.smartId;
                }
                hide();
            };

            $scope.$watch("streamingEndpointSelector", function(newValue, oldValue) {
                update();
            });

            /* Popover management */
            var popoverShown = false;
            $(popover).hide();
            var hide = function() {
                popover.hide().detach();
                $("html").unbind("click", hide);
                popoverShown=false;
            };
            var show = function() {
                var mainZone = $(".mainzone", element);
                popoverShown = true;
                if (popover == null) {
                    popover = $compile(popoverTemplate.clone())($scope);
                }
                popover.appendTo("body");

                popover.css("width", attrs.popoverWidth ? attrs.popoverWidth : Math.max(300, mainZone.width() + 20));
                if ($scope.popoverPlacement == 'right') {
                    popover.css("left", mainZone.offset().left - popover.width() + mainZone.width() +4);
                } else {
                    popover.css("left", mainZone.offset().left);
                }
                popover.css("top", mainZone.offset().top + mainZone.height() + ($scope.marginTop ? parseInt($scope.marginTop) : 8));

                if ($scope.popoverPlacement == 'auto') {
                    if (mainZone.offset().top + mainZone.height() + 280 > $(window).height()) {
                        popover.css("top", mainZone.offset().top - 310);
                    }
                }

                popover.show();

                popover.find("input").off('blur.dsSelector').on('blur.dsSelector',function() {
                    popover.find("input").focus();
                });
                popover.find("input").focus();

                popover.off("click.dku-pop-over").on("click.dku-pop-over", function(e) {
                    //e.stopPropagation();
                });
                $(".mainzone", element).off("click.dku-pop-over").on("click.dku-pop-over", function(e) {
                    //e.stopPropagation();
                });
                window.setTimeout(function() { $("html").click(function(event) {
                    if (event && event.target && $.contains(element[0], event.target)) return;
                    hide();
                }); }, 0);

                popover.find("input").off('keydown.dsSelector').on('keydown.dsSelector',function(event) {

                    if(event.keyCode==38 || event.keyCode==40 || event.keyCode==13) {
                        event.stopPropagation();
                    } else {
                        return;
                    }

                    if(event.keyCode==38 || event.keyCode==40) {

                        if($scope.displayedGroups &&  $scope.displayedGroups.length>0) {

                            var previous = null;
                            var next = null;
                            var current = null;
                            var first = null;
                            var foundCurrent = false;
                            var last = null;
                            var updateNext = false;

                            for(var k = 0 ; k < $scope.displayedGroups.length ; k++) {
                                var group = $scope.displayedGroups[k];
                                for(var j = 0 ; j < group.streamingEndpoints.length ; j++) {
                                    var ds = group.streamingEndpoints[j];
                                    if(!ds.usable) {
                                        continue;
                                    }
                                    if(!first) {
                                        first = ds;
                                    }
                                    last = ds;
                                    if(foundCurrent) {
                                        if(updateNext) {
                                            next = ds;
                                            updateNext=false;
                                        }
                                    } else {
                                        previous = current;
                                        current = ds;

                                        if($scope.currentlySelected == ds) {
                                            foundCurrent = true;
                                            updateNext = true;
                                        }
                                    }
                                }
                            }

                            $scope.$apply(function() {
                                if(foundCurrent) {
                                    if(event.keyCode == 40) {
                                        if(next) {
                                            $scope.currentlySelected = next;
                                        } else {
                                            $scope.currentlySelected = first;
                                        }
                                    }
                                    if(event.keyCode == 38) {
                                        if(previous) {
                                            $scope.currentlySelected = previous;
                                        } else {
                                            $scope.currentlySelected = last;
                                        }
                                    }
                                } else {
                                    if(first) {
                                        $scope.currentlySelected = first;
                                    }
                                }

                                if($scope.currentlySelected && !$scope.noLiveUpdate) {
                                    $scope.streamingEndpointSelector = $scope.currentlySelected.smartName || $scope.currentlySelected.smartId;
                                }
                            });
                        }

                    } else if(event.keyCode==13) {
                        if($scope.currentlySelected) {
                            $scope.select($scope.currentlySelected);
                            $scope.$apply();
                        }
                    }

                });
            };

            $scope.togglePopover =function() {
                if (popoverShown) hide();
                else show();
            }
        }
    }
    return ret;
});


})();
(function() {
'use strict';

    const app = angular.module('dataiku.directives.scope', ['dataiku.filters', 'dataiku.services', 'ui.keypress']);

    /* Includes a template without creating a new scope.
     * This allows to share some small HTML fragments without any semantic side-effect
     * From SO 12393703
     */
    app.directive('includeNoScope', function($http, $templateCache, $compile, $rootScope) {
        return function(scope, element, attrs) {
            const templatePath = attrs.includeNoScope;
            const replace = attrs.replace;

            function handleResponse(response) {
                const contents = $('<div/>').html(response).contents();
                if (replace) {
                    element.replaceWith(contents);
                } else {
                    element.html(contents);
                }
                $compile(contents)(scope);
                $rootScope.$broadcast("reflow");
            }

            const cachedResponse = $templateCache.get(templatePath);
            if (angular.isDefined(cachedResponse)) {
                if (cachedResponse && typeof cachedResponse.then == 'function') {
                    cachedResponse.then((resp) => handleResponse(resp.data));
                } else if (angular.isArray(cachedResponse)) {
                    handleResponse(cachedResponse[1]);
                } else {
                    handleResponse(cachedResponse);
                }
            } else {
                $http.get(templatePath, {cache: $templateCache}).then((resp) => handleResponse(resp.data));
            }
        };
    });

    /** Applies something when any input below is blurred */
    app.directive('onAnyBlur', function() {
        return {
            link: function(scope, elem, attrs) {
                var action = function() {
                    // Using the setTimeout trick
                    // to make sure to defer the action to the end
                    // of the call queue,
                    // and let the other bound function be executed.
                    //
                    // Especially, we need angular to do its magic and
                    // update its model.
                    window.setTimeout(function() {
                        scope.$apply(attrs.onAnyBlur);


                        // Fix #1222
                        // I have NO idea why 150 works and 10 doesn't
                    }, 150);
                };
                scope.$evalAsync(function() {
                    $(elem).on('blur', 'input[type="text"].submit-on-blur, input[type="date"].submit-on-blur, input[type="time"].submit-on-blur, input[type="datetime-local"].submit-on-blur, textarea.submit-on-blur', action);
                    $(elem).on('change', 'ul.suggest-items, div.submit-on-blur, select.submit-on-blur, input[type="radio"].submit-on-blur, input[type="checkbox"].submit-on-blur, input[type="number"].submit-on-blur', action);
                });
            }
        };
    });


    app.directive('onAnyBlurWatch', function($timeout) {
        return {
            link: function(scope, elem, attrs) {
                var action = function() {
                    window.setTimeout(function() {
                        scope.$apply(attrs.onAnyBlurWatch);
                    }, 150);
                };
                scope.$watch(attrs.watch, function() {
                    $(elem).on('blur', 'input[type="text"], input[type="datetime-local"], textarea', action);
                    $(elem).on('change', 'ul.suggest-items, select, input[type="checkbox"], input[type="number"]', action);
                });
            }
        };
    });

    app.directive("blurModel", function($parse) {
        return {
            restrict : 'A',
            link : function($scope, elt, attrs) {
                function set() {
                    modelSet($scope, elt[0].value);
                    $scope.$apply();
                }
                var modelGet = $parse(attrs.blurModel), modelSet = modelGet.assign;
                $scope.$watch(attrs.blurModel, function(nv, ov) {
                    var modelValue = modelGet($scope);
                    if (modelValue == null) {
                        elt[0].value = "";
                    } else if (modelValue !== elt[0].value) {
                        elt[0].value = modelValue;
                    }
                });

                elt.on("blur", function() {
                    set();
                });
                elt.on("keydown", function(e) {
                    if (e.keyCode == 13) {
                        set();
                    }
                });
            }
        };
    });

    app.directive('onSmartChange', function($timeout) {
        return {
            link: function(scope, element, attrs){
                var stop;
                var go = function() {
                    if (stop){
                        $timeout.cancel(stop);
                    }
                    stop = $timeout(function(){
                        scope.$apply(attrs.onSmartChange);
                    }, attrs.hasOwnProperty("delay") ? parseInt(attrs.delay, 10) : 1000);
                };

                scope.$evalAsync(function() {
                    $(element).on('keyup', 'input:not(.exclude-from-smart-change), textarea:not(.exclude-from-smart-change), select:not(.exclude-from-smart-change)', function(e) {
                        var keyCode = e.keyCode;

                        /* Ignore tab, esc, and navigation/arrow keys */
                        if (keyCode == 9 || keyCode == 27 || (keyCode>= 33 && keyCode <= 40)) {
                            return;
                        } else {
                            go();
                        }
                    });
                    $(element).on('change', 'input:not(.exclude-from-smart-change), textarea:not(.exclude-from-smart-change), select:not(.exclude-from-smart-change)', go);
                });
            }
        };
    });

    app.directive('onAnyChange', function($timeout) {
        return {
            link: function(scope, element, attrs){
                var go = function() {
                    scope.$apply(attrs.onAnyChange);
                };

                $(element).on('keyup', 'input, textarea, select', function(e) {
                    var keyCode = e.keyCode;

                    /* Ignore tab, esc, and navigation/arrow keys */
                    if (keyCode == 9 || keyCode == 27 || (keyCode>= 33 && keyCode <= 40)) {
                        return;
                    } else {
                        go();
                    }
                });
                $(element).on('change', 'input, textarea, select', go);
            }
        };
    });

    app.directive("publishInParent", function() {
        return  {
            retrict : 'ECA',
            link: function(scope, element, attrs) {
                var name = attrs.publishInParent;
                scope.$parent[name] = scope[name];
            }
        };
    });
    app.directive("publishInGrandParent", function() {
        return  {
            retrict : 'ECA',
            link: function(scope, element, attrs) {
                var name = attrs.publishInGrandParent;
                scope.$parent.$parent[name] = scope[name];
            }
        };
    });
    /* Stop laughing */
    app.directive("publishInGrandGrandParent", function() {
        return  {
            retrict : 'ECA',
            link: function(scope, element, attrs) {
                var name = attrs.publishInGrandGrandParent;
                scope.$parent.$parent.$parent[name] = scope[name];
            }
        };
    });

    app.directive('dkuIf', function() {
        return {
            transclude:'element',
            priority:1000,
            terminal:true,
            compile:function (element, attr, linker) {
                return function (scope, iterStartElement, attr) {
                    iterStartElement[0].doNotMove = true;
                    var expression = attr.dkuIf;
                    var lastElement;
                    var lastScope;
                    scope.$watch(expression, function (newValue) {
                        if (lastElement) {
                            lastElement.remove();
                            lastElement = null;
                        }
                        if (lastScope) {
                            lastScope.$destroy();
                            lastScope = null;
                        }
                        if (newValue) {
                            lastScope = scope.$new();
                            linker(lastScope, function (clone) {
                                lastElement = clone;
                                iterStartElement.after(clone);
                            });
                        }
                        // Note: need to be parent() as jquery cannot trigger events on comments
                        // (angular creates a comment node when using transclusion, as ng-repeat does).
                        iterStartElement.parent().trigger("$childrenChanged");
                    });
                };
            }
        };
    });

    app.directive('ngModelOnchange', function() {
        return {
            restrict: 'A',
            priority: -10,
            require: 'ngModel',
            link: function(scope, elm, attr, ngModelCtrl) {
                if (attr.type === 'radio' || attr.type === 'checkbox') return;

                elm.unbind('input').unbind('keydown').unbind('change');
                elm.bind('change', function() {
                    scope.$apply(function() {
                        ngModelCtrl.$setViewValue(elm.val());
                    });
                });
            }
        };
    });

    app.directive('ngModelOnblur', function() {
        return {
            priority: 1,
            restrict: 'A',
            require: 'ngModel',
            link: function(scope, elm, attr, ngModelCtrl) {
                if (attr.type === 'radio' || attr.type === 'checkbox') return;

                elm.off('input keydown change');
                elm.on('blur', function() {
                    scope.$apply(function() {
                        ngModelCtrl.$setViewValue(elm.val());
                    });
                });
            }
        };
    });


    app.directive('addRemove', function(){
        return {
            require: 'ngModel',
            restrict: 'A',
            scope: true,
            link: function(scope, element, attrs, ngModel){
                scope.concat = function(array){
                    if (! ngModel.$viewValue){
                        ngModel.$viewValue = [];
                    }
                    ngModel.$viewValue = ngModel.$viewValue.concat(array);
                    ngModel.$setViewValue(ngModel.$viewValue);
                };
                scope.add = function(value){
                    if (! ngModel.$viewValue){
                        ngModel.$viewValue = [];
                    }
                    ngModel.$viewValue.push(angular.copy(value));
                    ngModel.$setViewValue(ngModel.$viewValue);
                };
                scope.remove = function(index){
                    ngModel.$viewValue.splice(index, 1);
                    ngModel.$setViewValue(ngModel.$viewValue);
                };
            }
        };
    });
})();

(function(){
    'use strict';

    var app = angular.module('dataiku.directives.widgets', ['dataiku.filters', 'dataiku.services', 'ui.keypress', 'dataiku.common.lists']);

    /* "Generic" widgets */

    app.directive("plusIcon", function(){
        return {
            restrict : 'A',
            replace:true,
            template : '<span class="plus-icon">+</span>'
        }
    });
    app.directive("timesIcon", function(){
        return {
            restrict : 'A',
            replace:true,
            template : '<span style="font-size:1.3em; vertical-align: top">&times</span>'
        }
    });

    const addStarComponentBehaviour = ($ctrl, InterestWording) => {
        const toggle = (nextStatus) => {
            $ctrl.onToggle({ nextStatus });
        };

        $ctrl.isStarring = () => $ctrl.status;
        $ctrl.toggleStar = () => toggle(true);
        $ctrl.toggleUnstar = () => toggle(false);

        const { labels, tooltips } = InterestWording;
        $ctrl.labels = { ...labels };
        $ctrl.tooltips = { ...tooltips };
    };

    app.component('starInterest', {
        templateUrl: '/templates/widgets/star-interest.html',
        bindings: {
            status: '<',
            onToggle: '&',
            tooltipPosition: '@?',
        },
        controller: function(InterestWording) {
            const $ctrl = this;
            addStarComponentBehaviour($ctrl, InterestWording);
        },
    });

    app.component('starButton', {
        templateUrl: '/templates/widgets/star-button.html',
        bindings: {
            status: '<',
            onToggle: '&',
            nbStarred: '<',
            onShowUsersWithStar: '&',
            disabled: '<?',
        },
        controller: function(InterestWording) {
            const $ctrl = this;
            addStarComponentBehaviour($ctrl, InterestWording);

            $ctrl.isDisabled = () => !!($ctrl.disabled);
        },
    });

    const addWatchComponentBehaviour = ($ctrl, InterestWording, WatchInterestState) => {
        const toggle = (nextStatus) => {
            $ctrl.onToggle({ nextStatus });
        };

        const { values: { YES, ENO }, isWatching } = WatchInterestState;
        $ctrl.isWatching = () => isWatching($ctrl.status);
        $ctrl.toggleWatch = () => toggle(YES);
        $ctrl.toggleUnwatch = () => toggle(ENO);

        const { labels, tooltips } = InterestWording;
        $ctrl.labels = { ...labels };
        $ctrl.tooltips = { ...tooltips };
    };

    app.component('watchInterest', {
        templateUrl: '/templates/widgets/watch-interest.html',
        bindings: {
            status: '<',
            onToggle: '&',
            tooltipPosition: '@?',
        },
        controller: function(InterestWording, WatchInterestState) {
            const $ctrl = this;
            addWatchComponentBehaviour($ctrl, InterestWording, WatchInterestState);
        },
    });

    app.component('watchButton', {
        templateUrl: '/templates/widgets/watch-button.html',
        bindings: {
            status: '<',
            onToggle: '&',
            nbWatching: '<',
            onShowWatchingUsers: '&',
        },
        controller: function(InterestWording, WatchInterestState) {
            const $ctrl = this;
            addWatchComponentBehaviour($ctrl, InterestWording, WatchInterestState);
        },
    });

    app.directive("apiErrorAlert", function(){
        return {
            restrict : 'A',
            scope: {
                apiErrorAlert : '=',
                closable : '=',
                errorFoldable : '@',
                canBeUnexpected : '=?'
            },
            link : function($scope) {
                if ($scope.canBeUnexpected === undefined) {
                    $scope.canBeUnexpected = true;
                }
                $scope.options = {
                    canBeUnexpected : $scope.canBeUnexpected,
                    closable : $scope.closable,
                    errorFoldable : $scope.errorFoldable
                }
                $scope.open = true;
                $scope.reset = function() {
                    if ($scope.apiErrorAlert) {
                        $scope.apiErrorAlert.httpCode  = null;
                        $scope.apiErrorAlert.errorType = null;
                    }
                }

            },
            templateUrl : '/templates/api-error-alert.html'
        }
    });

    app.directive("sidekickAlert", function() {
        return {
            restrict : "E",
            transclude: true,
            templateUrl : "/templates/sidekick-alert.html"
        }
    });

    app.filter("detailedMessageOrMessage", function(){
        return function(input) {
            if (!input) return "";
            return input.detailedMessage || input.message;
        }
    });

    app.factory("disableElement", function(getBootstrapTooltipPlacement) {
        return function(element, disabled, message, position) {
            if (disabled === true) {
                element.addClass("disabled");
                element.prop("disabled", "disabled");
                element.css("position", "relative");
                element.css("pointer-events", "auto");
                var div = $('<div>').addClass("fh disabled-if-overlay").attr("title", message).appendTo(element);
                div.on('click', function () { return false; });
                if (message && message.length) {
                    div.tooltip({container: "body", placement: getBootstrapTooltipPlacement(position)});
                }
            } else if (disabled === false) {
                element.removeClass("disabled");
                element.css("pointer-events", null);
                element.prop("disabled", null);
                element.find('.disabled-if-overlay').tooltip('destroy').remove();
            }
        }
    });

    app.directive("disabledIfRo", function(disableElement){
        return {
            restrict : 'A',
            link : function(scope, element, attrs) {
                scope.$watch("!canWriteProject()", function(nv) {
                    if (nv === undefined) return;
                    return disableElement(element, nv, "You don't have write permissions for this project");
                });
            }
        }
    });

    app.directive("disabledIfProjectFolderRo", function($rootScope, disableElement, ProjectFolderContext) {
        return {
            restrict : 'A',
            link : function(scope, element, attrs) {
                scope.$watch(function() {
                    return !$rootScope.isDSSAdmin() && !$rootScope.canWriteInProjectFolder();
                }, function(nv) {
                    if (nv === undefined) return;
                    return disableElement(element, nv, "You don't have write contents permissions on this folder");
                });
            }
        }
    });

    app.directive("disabledIf", function(disableElement){
        return {
            restrict : 'A',
            link: function(scope, element, attrs) {
                scope.$watch(attrs.disabledIf, function(nv) {
                    return disableElement(element, nv, attrs.disabledMessage, attrs.disabledPosition);
                });
            }
        }
    });

    /*
        Sets element as disabled if disabledIfMessage is a non-empty string
        and displays that string as the tooltip
    */
    app.directive("disabledIfMessage", function(disableElement){
        return {
            restrict : 'A',
            scope : {
                disabledIfMessage: '='
            },
            link: function(scope, element, attrs) {
                scope.$watch('disabledIfMessage', function(nv) {
                    return disableElement(element, !!nv, scope.disabledIfMessage, attrs.disabledPosition);
                });
            }
        }
    });

    app.directive("disabledBlockIfRo", function(){
        return {
            restrict : 'A',
            link : function(scope, element, attrs) {
                scope.$watch("canWriteProject()", function(nv, ov) {
                    if (nv === false) {
                        element.addClass("disabled-block");
                    } else if( nv === true) {
                        element.removeClass("disabled-block");
                    }
                });
            }
        }
    });

    /* similar to ng-show but uses CSS visibility rather than display property (no movement in the page) */
    app.directive('visibleIf', function() {
        return {
            restrict: 'A',
            link: function(scope, element, attrs) {
                var toggle = function (show){
                    $(element).css('visibility', show ? 'visible': 'hidden');
                };
                toggle(scope.$eval(attrs.visibleIf));
                scope.$watch(attrs.visibleIf, toggle);
            }
        };
    });

    /* API error that displays as an alert block */
    app.directive('blockApiError', function() {
        return {
            templateUrl: '/templates/block-api-error.html',
            replace: false,
            restrict: 'ECA',
            link: function(scope, element) {
              // can be used by children to report their error.
              scope.setError = setErrorInScope.bind(scope);
            }
        };
    });

     app.directive("dssObjectLink", function(StateUtils, SmartId, TAGGABLE_TYPES) {
        return {
            templateUrl : '/templates/widgets/taggable-object-ref.html',
            scope: {
                item: '=',
                moveToTargetProject: '='
            },
            link: function(scope) {
                scope.StateUtils = StateUtils;
                scope.SmartId = SmartId;
                scope.isLinkableDssObject = item => TAGGABLE_TYPES.includes(item.objectType);
                scope.isTensorboardFuture = item => item.objectType === 'WEB_APP' && item.objectId.startsWith('TENSORBOARD_');
            }
        }
    });

    app.directive("tlUser", function($rootScope){
        return {
            template : '<span class="who"> <a href="/profile/{{item.user}}/">{{item.user == rootScope.appConfig.user.login ? \"You\" : (item.details.userDisplayName ? item.details.userDisplayName : item.user)}}</a></span>',
            scope : false,
            link : function($scope) {
                $scope.rootScope= $rootScope;
            }
        }
    });

    app.directive('metadataObjectModal', function($stateParams, DataikuAPI){
        return {
            scope : true,
            link : function($scope, element, attrs) {
                if ($scope.metadataObjectParent.customMeta && $scope.metadataObjectParent.customMeta.kv) {
                    $scope.localObject = angular.copy($scope.metadataObjectParent.customMeta.kv);
                } else {
                    $scope.localObject = { };
                }
                $scope.save = function() {
                    $scope.metadataObjectParent.customMeta = { 'kv' : angular.copy($scope.localObject) };
                    $scope.$emit("metadataObjectUpdated");
                    $scope.dismiss();
                };
            }
        }
    });

     app.directive('metadataObjectLink', function(CreateModalFromTemplate){
        return {
            restrict : 'AE',
            scope : {
                metadataObjectParent : '='
            },
            template: '<div class="metadata-object-link"><pre class="small-pre">{{metadataObjectParent.customMeta.kv | json}}</pre><button title="Object metadata" class="btn btn--secondary" ng-click="openModal()"><i class="icon-superscript" />&nbsp;Edit</button></div>',
            link : function($scope, element, attrs) {
                $scope.openModal = function(){
                    CreateModalFromTemplate("/templates/widgets/metadata-object-modal.html", $scope,
                        null, null);
                }
            }
        }
    });

     app.directive('overrideTableModal', function($stateParams, DataikuAPI){
        return {
            scope : true,
            // compile/pre to execute before listForm's link (for transcope)
            compile : function(){ return { pre: function($scope, element, attrs) {
                $scope.simplifiedObjectToOverride = {};
                $scope.$watch("objectToOverride", function(nv, ov){
                    if (nv) {
                        $scope.simplifiedObjectToOverride = angular.copy($scope.objectToOverride);
                        $.each($scope.simplifiedObjectToOverride, function(k, v) {
                            if (k.indexOf("$") == 0) {
                                delete $scope.simplifiedObjectToOverride[k];
                            }
                        });
                        delete $scope.simplifiedObjectToOverride["overrideTable"];
                        delete $scope.simplifiedObjectToOverride["change"];
                        delete $scope.simplifiedObjectToOverride["versionTag"];
                    }
                }, true);
                if ($scope.overrideTableParent.overrideTable) {
                    $scope.localTable = angular.copy($scope.overrideTableParent.overrideTable);
                } else {
                    $scope.localTable = { "overrides" : []};
                }
                $scope.save = function() {
                    if ($scope.localTable.overrides.length > 0) {
                        $scope.overrideTableParent.overrideTable = angular.copy($scope.localTable)
                    } else {
                        $scope.overrideTableParent.overrideTable = null;
                    }
                    $scope.$emit("overrideTableUpdated");
                    $scope.dismiss();

                };
                $scope.getValue = (function(override) {
                    DataikuAPI.variables.expandExpr($stateParams.projectKey, override.expr).success(function(data){
                        override.$$computedValue = data.id;
                    }).error(setErrorInScope.bind(this));
                }).bind($scope); // bind on parent scope
            } }; }
        }
    });

    app.directive('overrideTableBtnLink', function(CreateModalFromTemplate){
        return {
            scope : {
                overrideTableParent : '=',
                objectToOverride : '='
            },
            template: '<div class="override-table-link"><pre class="small-pre">{{overrideDesc}}</pre><button title="Override variables" class="btn btn--secondary" ng-click="openModal()"><i class="icon-superscript" />&nbsp;Edit</button></div>',
            link : function($scope, element, attrs) {
                $scope.overrideDesc = '';
                $scope.$watch('overrideTableParent.overrideTable', function(nv) {
                    if ( nv == null) return;
                    var desc = '';
                    if ( $scope.overrideTableParent.overrideTable.overrides != null ) {
                        $scope.overrideTableParent.overrideTable.overrides.forEach(function(override) {
                            desc = desc + override.path + " ";
                        });
                    }
                    $scope.overrideDesc = desc;
                }, true);
                $scope.openModal = function(){
                    CreateModalFromTemplate("/templates/widgets/override-table-modal.html", $scope,
                        null, null);
                }
            }
        }
    });
     app.directive('overrideTableLink', function(CreateModalFromTemplate){
        return {
            scope : {
                overrideTableParent : '=',
                objectToOverride : '='
            },
            template: '<a title="Override variables" ng-class="{\'override-table-link\': true, \'overriden\': overrideTableParent.overrideTable.overrides.length}" ng-click="openModal()"><i class="icon-superscript" /></a>',
            link : function($scope, element, attrs) {
                $scope.openModal = function(){
                    CreateModalFromTemplate("/templates/widgets/override-table-modal.html", $scope,
                        null, null);
                }
            }
        }
    });
    app.directive('dkuIndeterminate', function() {
        return {
            restrict: 'A',
            link: function(scope, element, attributes) {
                scope.$watch(attributes.dkuIndeterminate, function(value) {
                    element.prop('indeterminate', !!value);
                });
            }
        };
    });

    app.directive('validFile',function(){
        return {
            require:'ngModel',
            link:function(scope, el, attrs, ngModel) {
                el.bind('change', function() {
                    var val = 'multiple' in attrs ? this.files : this.files[0];
                    scope.$apply(function() {
                        ngModel.$setViewValue(val);
                        ngModel.$render();
                    });
                });
            }
        };
    });


    app.directive('sparkline', function() {
        return {
            scope: {
                sparkline: '='
            },
            link: function(scope, element) {
                const data = scope.sparkline;
                const rect = element[0].parentElement.getBoundingClientRect();
                const x = d3.scale.linear().domain([0, data.length-1]).range([0, rect.width]);
                const y = d3.scale.linear().domain([0, d3.max(data) || 0]).range([rect.height, 4]);
                const line = d3.svg.line().x((d, i) => x(i)).y(d => y(d || 0));

                d3.select(element[0]).html("")
                    .append("svg:svg")
                    .append("svg:path")
                    .attr("d", line(data))
                    .attr("stroke-width", "2px")
                    .attr("stroke", "#add8e6")
                    .attr("fill", "#add8e6")
                    .attr("fill-opacity", .3);
            }
        }
    });

    app.directive('weekDaysPicker', [function(){
        return {
            scope : {
                selection:'=ngModel',
                onChange:'&?',
            },
            template: `<div class="weekdays-picker">
                <span ng-repeat="day in days" ng-click="toggle(day)" ng-class="[{selected: hasSelected(day)}]">{{day[0]}}</span>
            </div>`,
            link : function($scope) {
                $scope.days = [...WEEKDAYS];

                $scope.hasSelected = (day) => {
                    return $scope.selection.includes(day);
                };

                $scope.toggle = (day) => {
                    if($scope.selection.includes(day)) {
                        $scope.selection = $scope.selection.filter(s => s !== day);
                    } else {
                        $scope.selection = [...$scope.selection, day];
                    
                    }
                    if($scope.onChange) {
                        $scope.onChange($scope.selection);
                    }
                };

                $scope.$watch('selection', () => {
                    if(!Array.isArray($scope.selection)) {
                        $scope.selection = [];
                    }
                });
            }
        }
    }]);

    app.directive('inlineDateRangePicker', ['$timeout', function($timeout){
        return {
            scope : {
                from:'=',
                to:'=',
                tz:'=',
                onChange:'&?',
            },
            template: `<fieldset>
                    <div class="fieldLabel">From</div>
                    <input ng-model="from" ng-blur="onFromBlur()" type="date" name="dateFrom" style="width: 106px" />
                    <input ng-model="from" ng-blur="onFromBlur()" type="time" name="timeFrom" step="1" ng-style="timeInputStyle" />
                </fieldset>
                <fieldset>
                    <div class="fieldLabel">To</div>
                    <input ng-model="to" ng-blur="onToBlur()" type="date" name="dateTo" style="width: 106px" />
                    <input ng-model="to" ng-blur="onToBlur()" type="time" name="timeTo" step="1" ng-style="timeInputStyle" />
                </fieldset>
                <fieldset>
                    <div class="fieldLabel">Timezone</div>
                    <select
                        ng-model="tz"
                        ng-options="item as item for item in timezone_ids"
                    />
            </fieldset>`,
            link : function($scope) {
                $scope.timezone_ids = [
                    "UTC", "Africa/Addis_Ababa", "Africa/Harare", "Africa/Lagos",
                    "America/Adak", "America/Argentina/Buenos_Aires", "America/Bogota", "America/Chicago", "America/Costa_Rica",
                    "America/Dawson_Creek", "America/Denver", "America/Guadeloupe", "America/Halifax", "America/Juneau", "America/Lima",
                    "America/Los_Angeles", "America/New_York", "America/Noronha", "America/Santiago", "America/Sao_Paulo", "America/St_Johns",
                    "Asia/Bangkok", "Asia/Calcutta", "Asia/Dhaka", "Asia/Dubai", "Asia/Hong_Kong", "Asia/Jakarta", "Asia/Kabul",
                    "Asia/Karachi", "Asia/Kathmandu", "Asia/Manila", "Asia/Seoul", "Asia/Singapore", "Asia/Tehran", "Asia/Tokyo",
                    "Atlantic/Azores", "Atlantic/Cape_Verde", "Australia/Adelaide", "Australia/Darwin", "Australia/Eucla", "Australia/Lord_Howe", "Australia/Sydney",
                    "Europe/Athens", "Europe/Istanbul", "Europe/Lisbon", "Europe/London", "Europe/Moscow", "Europe/Paris",
                    "Indian/Cocos", "Pacific/Apia", "Pacific/Auckland", "Pacific/Chatham", "Pacific/Enderbury", "Pacific/Gambier", "Pacific/Honolulu",
                    "Pacific/Kiritimati", "Pacific/Marquesas", "Pacific/Niue", "Pacific/Noumea", "Pacific/Pitcairn", "Pacific/Wallis"
                ];

                // Firefox always displays the milliseconds in the time picker, so give more space to the time picker
                $scope.timeInputStyle = { 'width': (navigator.userAgent.includes("Gecko/") ? '144px' : '111px') };

                $scope.$watch("to", (nv, ov) => {
                    if (ov && !nv) {
                        // Trigger an onChange event when user click on the "clear" button
                        // (side-effect: also trigger an event when user enters an invalid date)
                        $scope.onChange();
                    }
                });

                $scope.$watch("from", (nv, ov) => {
                    if (ov && !nv) {
                        // Trigger an onChange event when user click on the "clear" button
                        // (side-effect: also trigger an event when user enters an invalid date)
                        $scope.onChange();
                    }
                });

                $scope.$watch("tz", () => {
                    $scope.onChange();
                });

                $scope.onFromBlur = () => {
                    if ($scope.from && $scope.to) {
                        if ($scope.from.getTime() > $scope.to.getTime()) {
                            $scope.to = new Date($scope.from.getTime());
                        }
                    }
                    $scope.onChange();
                };

                $scope.onToBlur = () => {
                    if ($scope.from && $scope.to) {
                        if ($scope.from.getTime() > $scope.to.getTime()) {
                            $scope.from = new Date($scope.to.getTime());
                        }
                    }
                    $scope.onChange();
                };
            }
        }
    }]);


    app.directive('chartAlphanumFacet', function($stateParams, $timeout, $rootScope, $filter, DataikuAPI, Debounce){
        return {
            templateUrl :'/templates/simple_report/alphanum_facet.html',
            restrict: 'E',
            scope : {
                values:'=',
                uniqueRowCount:'=?',
                onChange:'&?',
                folded:'='
            },

            link : function($scope) {
                $scope.filteredValues = [];

                function reloadValues() {
                    $scope.filteredValues = [];
                    let q = ($scope.query || "").toLowerCase();
                    if($scope.values) {
                        for(let k in $scope.values) {
                            let v = $scope.values[k];
                            if(!v.label) {
                                v.label = '';
                            }
                            if(v.label.toLowerCase().indexOf(q)!=-1) {
                                $scope.filteredValues.push(v);
                            }
                        }
                        $scope.allSelected = true;
                        for(let k in $scope.filteredValues) {
                            let item = $scope.filteredValues[k];
                            $scope.allSelected = $scope.allSelected && item.included;
                        }

                        // only show unique row count when we aren't filtering by query
                        if ($scope.uniqueRowCount) {
                            const unusedCount = $scope.values.length === $scope.filteredValues.length ? $scope.uniqueRowCount - $scope.values.length : 0;

                            if (unusedCount) {
                                $scope.filteredValues.push({
                                    unusedCount: unusedCount
                                });
                            }
                        }
                    }
                }

                $scope.setAll = function(val) {
                    for(let k in $scope.filteredValues) {
                        let item = $scope.filteredValues[k];
                        item.included = val;
                    }
                    $scope.changed();
                };

                $scope.changed = function() {
                    $scope.allSelected = true;
                    for(let k in $scope.filteredValues) {
                        let item = $scope.filteredValues[k];
                        $scope.allSelected = $scope.allSelected && item.included;
                    }
                    $scope.onChange();
                };

                $scope.$watch("query",Debounce().withScope($scope).withDelay(50,200).wrapWatch(function() {
                    reloadValues();
                }));

                $scope.$watch("widgetHeight",function() {
                    $scope.$broadcast("reflow");
                });
                $scope.$watch("folded",function() {
                    $scope.$broadcast("reflow");
                });

                $scope.$watch("values",function(nv) {
                    if(!nv)return;
                    reloadValues();
                    $scope.widgetHeight=Math.min(Math.max(50,22*nv.length),220)+5;
                },false);

            }
        }
    });

    app.directive('executionPlan', function() {
        return {
            restrict: "AE",
            scope: {
                executionPlan: '=ngModel'
            },
            templateUrl: '/templates/widgets/execution-plan.html',
            link: function(scope, element, attrs) {
                //nothing to do for now...
            }
        };
    });

    // SO : http://stackoverflow.com/questions/18368485/angular-js-resizable-div-directive
    app.directive('resizer', function($document,Throttle,$rootScope) {
        return function($scope, $element, $attrs) {

            $element.addClass('content-resizer');

            $element.on('mousedown', function(event) {
                $element.parent().addClass("resizing");
                event.preventDefault();
                $document.on('mousemove', mousemove);
                $document.on('mouseup', mouseup);
            });

            function mousemove(event) {

                if ($attrs.resizer == 'vertical') {
                    // Handle vertical resizer
                    let x = event.pageX;

                    if ($attrs.resizerMax && x > $attrs.resizerMax) {
                        x = parseInt($attrs.resizerMax);
                    }

                    $element.css({
                        left: x + 'px'
                    });

                    $($attrs.resizerLeft).css({
                        width: x + 'px'
                    });
                    $($attrs.resizerRight).css({
                        left: (x + parseInt($attrs.resizerWidth)) + 'px'
                    });

                } else {
                    // Handle horizontal resizer
                    let y = window.innerHeight - event.pageY;

                    $element.css({
                        bottom: y + 'px'
                    });

                    $($attrs.resizerTop).css({
                        bottom: (y + parseInt($attrs.resizerHeight)) + 'px'
                    });
                    $($attrs.resizerBottom).css({
                        height: y + 'px'
                    });
                }
            }

            function mouseup() {
                $document.unbind('mousemove', mousemove);
                $document.unbind('mouseup', mouseup);
                $element.parent().removeClass("resizing");
                $rootScope.$broadcast('reflow');
            }
        };
    });

    app.directive('fatTable', function($compile,$rootScope,Debounce,$http,$templateCache) {

         return {
            restrict : 'A',
            scope : {
                rows:'=',
                as : '@',
                rowIndexAs:'@',
                headers:'=',
                columnWidths : '=',
                headerTemplate:'@',
                cellTemplate:'@',
                printNewLinesAsSymbols:'@',
                rowHeight:'=',
                headerHeight : '=',
                digestChildOnly:'=?'
            },
            link : function(scope, element, attrs) {
                $http.get(scope.cellTemplate, {cache: $templateCache}).then(function(resp) {
                    let cellTemplateHTML = resp.data;
                    $http.get(scope.headerTemplate, {cache: $templateCache}).then(function(resp) {
                        let headerTemplateHTML = resp.data;
                        // We don't use Debounce here because it always triggers a full digest cycle!
                        var digestTimeout = undefined;
                        function debouncedDigestCycle() {
                            if(digestTimeout === undefined) {
                                digestTimeout = setTimeout(function() {
                                    digestTimeout = undefined;
                                    if(scope.digestChildOnly) {
                                        var elmScope = element.scope();
                                        if(elmScope) {
                                            // Partial digestion
                                            elmScope.$digest();
                                        }
                                    } else {
                                        // Full digestion
                                        $rootScope.$digest();
                                    }
                                },10);
                            }
                        }

                        function cleanDOM(div) {
                            // Destroy the cell's __fat_scope__
                            var fs = div.__fat_scope__;
                            if(fs) {
                                fs.$destroy();
                            }
                            div.__fat_scope__ = undefined;
                            // Make sure there is no refs to the scope in JQuery's cache
                            $(div).data('$scope',null);
                        }

                        function buildModel() {
                           var tableData = new fattable.SyncTableModel();
                           tableData.getCellSync = function(i,j) {
                               var arr = scope.rows;
                               if(!arr || !arr.length || i<0 || i>=arr.length) {
                                   return {i:i,j:j,v:undefined,t:'c'};
                               } else {
                                   var row = arr[i];
                                   if(!row || !row.length || j < 0 || j >=row.length) {
                                        return {i:i,j:j,v:undefined,t:'c'};
                                   }
                                   return {i:i,j:j,v:row[j],t:'c'};
                               }
                           };
                           tableData.getHeaderSync = function(i) {
                               var arr = scope.headers;
                               if(!arr || !arr.length || i<0 || i>=arr.length) {
                                   return {i:i,v:undefined,t:'h'};
                               } else {
                                  return {i:i,v:arr[i],t:'h'};
                               }
                           };
                           return tableData;
                        }

                        var livingCells = [];

                        function buildPainter() {
                           var painter = new fattable.Painter();

                           var prepareElement = function(template) {
                              return function(cellDiv, data) {
                                  if(!cellDiv.__fat_scope__) {
                                      var elementScope = element.scope();
                                      if(elementScope) {
                                          cellDiv.__fat_scope__ = elementScope.$new();
                                          $(cellDiv).append($compile(template)(cellDiv.__fat_scope__));
                                      }
                                  }
                                  if(cellDiv.__fat_scope__) {
                                      let v = data.v;
                                      if (scope.printNewLinesAsSymbols && (typeof v === 'string' || v instanceof String)) {
                                          v = v.replace(/(\r\n|\n)/g, "¶");
                                      }
                                      cellDiv.__fat_scope__[attrs.as] = v;
                                      if(attrs.rowIndexAs && data.t == 'c') {
                                            cellDiv.__fat_scope__[attrs.rowIndexAs] = data.i;
                                      }
                                      debouncedDigestCycle();
                                  }
                               };
                           };

                           painter.fillCell = prepareElement(cellTemplateHTML);
                           painter.fillHeader = prepareElement(headerTemplateHTML);

                           painter.fillCellPending = function(cellDiv, data) {
                               cellDiv.textContent = "";
                               cellDiv.className = "pending";
                           };

                           painter.fillHeaderPending = function(cellDiv, data) {
                              cellDiv.textContent = "";
                              cellDiv.className = "pending";
                           };

                           painter.setupCell = function(div) {
                              livingCells.push(div);
                           };

                           painter.setupHeader = painter.setupCell;

                           painter.cleanUpCell = function(div) {
                               livingCells = livingCells.filter(function(x) {
                                   return x!=div;
                               });
                               cleanDOM(div);
                           };

                           painter.cleanUpHeader = painter.cleanUpCell;

                           return painter;
                        }
                        var oldTable;

                        function redraw() {
                            if(oldTable) {
                                oldTable.cleanUp();
                                // bug in fattable : cleanUp() at line 702 is not checking the variable holding the scroll proxy, so
                                // the scroll elements still try to call onScroll (until the next DOM rebuild where they're removed)
                                if (oldTable.scroll != null) {
                                    oldTable.scroll.onScroll = function() {}; // NOSONAR: noop
                                }
                            }
                            const table = fattable({
                                "container": element[0],
                                "model": buildModel(),
                                "nbRows": scope.rows? scope.rows.length:0,
                                "rowHeight": scope.rowHeight,
                                "headerHeight": scope.headerHeight,
                                "painter": buildPainter(),
                                "columnWidths": scope.columnWidths
                            });
                            if(oldTable && oldTable.scroll) {
                                var y = oldTable.scroll.scrollTop;
                                var x = oldTable.scroll.scrollLeft;
                                table.scroll.setScrollXY(x,y);
                            }
                            oldTable = table;
                        }

                       var debouncedRedraw = Debounce().withDelay(50,200).wrap(redraw);
                       scope.$watch('rows', debouncedRedraw, false);
                       scope.$watch('headers', debouncedRedraw, false);
                       $(window).on('resize', debouncedRedraw);

                       element.scope().$on("reflow", debouncedRedraw);

                       scope.$on("$destroy", function () {
                           if(oldTable) {
                                oldTable.cleanUp();
                                oldTable=null;
                           }
                           for(var i = 0 ; i < livingCells.length ; i++) {
                                cleanDOM(livingCells[i]);
                           }
                           livingCells = [];
                           $(window).off("resize", debouncedRedraw);
                       });
                    });
               });
            }
         };
    });

    app.directive('registerModelForForm', function () {
        return {
            scope: {form: '=registerModelForForm'},
            require: 'ngModel',
            controller: function ($element,$scope) {
                var ngModel = $element.controller('ngModel');
                $scope.form.$addControl(ngModel);
            }
        };
    });

    app.directive('fatRepeat', function($compile, $rootScope, $timeout, Debounce, FatTouchableService, FatDraggableService) {

        return {
            transclude:true,
            scope:{
                fatRepeat:'=', // Array
                fatDraggable:'=?', // If items should be draggable
                fatDraggableOnDrop:'=?', // Callback called when drag ends
                as:'@', // Name of each item
                rowHeight:'=', // Height of each row
                colWidth: '=?', // width of each column
                digestChildOnly:'=?', // If true, doesn't trigger a full digest cycle each time a cell updated, but call
                // $digest() on child scope only. It's generally MUCH faster, but you need to make sure
                // that your watches have no side effects on parent scopes.
                initScope: '=?', // item scope init function
                tableModel: '=?', // Custom fattable Model
                inForm:'=?',
                layoutMode: '@?', //one of row, mosaic (or potentially left blank for list mode)
                listPadding: '=?', // padding to be introduced before first and after last item
                fTrackTable: '&', // to allow containers to control the scroll or other aspect of the underlying table
                disableScrollTo: '@', // Disable scrollToLine event
                enableAsync: '=?',
                nbRows: '=?',
                chunkSize: '=?',
                getRowChunk: '=?',
                pageFromData: '=?'
            },
            restrict:'A',
            compile: function(_element,_attrs,transclude) {

                return function(scope, element, attrs) {
                    const HORIZ_SCROLL_H = 1;
                    const VERT_SCROLL_W = 8;


                    element.addClass(scope.layoutMode ? 'fat-row' : 'fat-repeat');
                    if (scope.layoutMode=="row") {
                        $(element).css('height', (parseInt(scope.rowHeight,10) + HORIZ_SCROLL_H).toString() + 'px');
                    }

                    // We don't use Debounce here because it always triggers a full digest cycle!
                    var digestTimeout = undefined;
                    function debouncedDigestCycle() {
                        if(digestTimeout === undefined) {
                            digestTimeout = setTimeout(function() {
                                digestTimeout = undefined;
                                if(scope.digestChildOnly) {
                                    var elmScope = element.scope();
                                    if(elmScope) {
                                        // Partial digestion
                                        elmScope.$digest();
                                    }
                                } else {
                                    // Full digestion
                                    $rootScope.$digest();
                                }
                            },10);
                        }
                    }

                    function cleanDOM(div) {
                        // Destroy the cell's __fat_scope__
                        var fs = div.__fat_scope__;
                        if(fs) {
                            fs.$destroy();
                        }
                        div.__fat_scope__ = undefined;
                        // Make sure there is no refs to the scope in JQuery's cache
                        $(div).data('$scope',null);
                    }

                    function buildModel() {
                        if (scope.tableModel) {
                            return scope.tableModel.call(scope);
                        }
                        if (scope.enableAsync) {
                            const asyncTableData = new fattable.PagedAsyncTableModel();
                            asyncTableData.fetchCellPage = (pageName, cb) => {
                                var promise = scope.getRowChunk(pageName);
                                promise.then(response => {
                                    cb(scope.pageFromData(pageName, response.data));
                                });
                            };
                            asyncTableData.cellPageName = (row, col) => {
                                return Math.trunc(row / Math.max(1, scope.chunkSize));
                            };
                            if (scope.fatRepeat && scope.fatRepeat.length > 0) {
                                var initialPageName = asyncTableData.cellPageName(0, 0);
                                const initialPage = scope.pageFromData(initialPageName, {items: [...scope.fatRepeat]});
                                asyncTableData.pageCache.set(initialPageName, initialPage);
                            }
                            return asyncTableData;
                        }
                        const tableData = new fattable.SyncTableModel();

                        tableData.getCellSync = function(i,j) {
                            const arr = scope.fatRepeat;
                            const idx = i*scope.numColumns + j;
                            if(!arr || idx<0 || idx>=arr.length) {
                                return undefined;
                            }
                            return arr[idx];
                        };
                        return tableData;
                    }

                    var livingCells = [];

                    function buildPainter() {
                        var painter = new fattable.Painter();
                        painter.fillCell = function(cellDiv, data) {
                            cellDiv.className = '';
                            if(!cellDiv.__fat_scope__) {
                                var elementScope = element.scope();
                                if(elementScope) {
                                    cellDiv.__fat_scope__ = elementScope.$new();
                                    transclude(cellDiv.__fat_scope__,function(clone) {
                                        $(cellDiv).append(clone);
                                    });
                                }
                            }
                            if(cellDiv.__fat_scope__) {
                                cellDiv.__fat_scope__[attrs.as] = data;
                                debouncedDigestCycle();
                                if (scope.initScope) {
                                    scope.initScope(cellDiv.__fat_scope__);
                                }
                            }
                        };
                        painter.fillCellPending = function(cellDiv, data) {
                            cellDiv.className = "fat-repeat-pending-row";
                        };
                        painter.setupCell = function(div) {
                            livingCells.push(div);
                        };
                        painter.cleanUpCell = function(div) {
                            livingCells = livingCells.filter(function(x) {
                                return x!=div;
                            });
                            cleanDOM(div);
                        };
                        return painter;
                    }

                    var oldTable;

                    function redraw() {
                        if (oldTable) {
                            oldTable.cleanUp();
                        }
                        let fatRepeatLength = scope.fatRepeat? scope.fatRepeat.length:0;
                        if (scope.layoutMode=="row") {
                            // row mode
                            scope.numColumns = fatRepeatLength;
                            scope.numRows = 1;
                        }
                        else if (scope.layoutMode=="mosaic") {
                            scope.numColumns = Math.floor((element.innerWidth() - VERT_SCROLL_W)/ scope.colWidth);
                            scope.numRows = Math.ceil(fatRepeatLength / scope.numColumns);
                        }
                        else if (scope.enableAsync) {
                            scope.numRows = scope.nbRows;
                            scope.numColumns = 1;
                        } else {
                            scope.numRows = fatRepeatLength;
                            scope.numColumns = 1;
                        }

                        if (scope.listPadding && scope.layoutMode != "row") { // pad the end via a whole row
                            scope.numRows++
                        }

                        let columnWidths = [element.width() - 11];

                        if (['mosaic','row'].includes(scope.layoutMode)) {
                            columnWidths = Array.from({length: scope.numColumns}, (v, i) => scope.colWidth);
                            if (columnWidths.length>0  && scope.layoutMode=="row" && scope.listPadding) {
                                if (typeof scope.listPadding === 'string') scope.listPadding = parseInt(scope.listPadding, 10);
                                columnWidths[columnWidths.length-1] += 2 * scope.listPadding;
                            }
                        }

                        var table = fattable({
                            "container": element[0],
                            "model": buildModel(),
                            "nbRows": scope.numRows,
                            "rowHeight": scope.rowHeight,
                            "headerHeight": 0,
                            "painter": buildPainter(),
                            "columnWidths": columnWidths
                        });

                        if (attrs.fatDraggable !== undefined && typeof scope.fatDraggableOnDrop === 'function') {
                            FatDraggableService.setDraggable({
                                element: table.container,
                                onDrop: scope.fatDraggableOnDrop,
                                axis: 'y',
                                scrollBar: table.scroll,
                                classNamesToIgnore: ['icon-sort-by-attributes', 'sort-indication', 'pull-right']
                            })

                            // We have to set the fat-draggable__item class to an inner child because fattable re-use
                            // the same cell div for different items
                            for (let cellKey in table.cells) {
                                if (!table.cells.hasOwnProperty(cellKey)) continue;
                                let cellDiv = table.cells[cellKey];
                                let cellDivColumnHeader = cellDiv && cellDiv.children && cellDiv.children[0];
                                cellDivColumnHeader && cellDivColumnHeader.classList.add('fat-draggable__item');
                            }
                        }

                        if (isTouchDevice()) {
                            if (oldTable && typeof(scope.unsetTouchable) === "function") {
                                scope.unsetTouchable();
                            }
                            scope.unsetTouchable = FatTouchableService.setTouchable(scope, element, table);
                        }

                        if (oldTable) {
                            var y = oldTable.scroll.scrollTop;
                            var x = oldTable.scroll.scrollLeft;
                            table.scroll.setScrollXY(x,y);
                        }

                        oldTable = table;

                        if (scope.fTrackTable) scope.fTrackTable({table:oldTable});

                        if (scope.layoutMode=="row" && scope.listPadding) {
                            $(element).find('.fattable-viewport').css('padding-left', scope.listPadding);
                        }

                        if (scope.inForm) {
                            _element.find('[ng-model]').each((idx, el) => {
                                scope.inForm.$addControl(angular.element(el).controller('ngModel'));
                            });
                        }
                    }

                    scope.$on('moveScroll', (event, x, y) => {
                        oldTable.scroll.setScrollXY(oldTable.scroll.scrollLeft + x, oldTable.scroll.scrollTop + y);
                    });

                    scope.$watchCollection('fatRepeat', redraw);

                    scope.$on('redrawFatTable', redraw);
                    scope.$on('repaintFatTable', function () { debouncedRedraw(); }); //works better wrapped in a fnc!

                    if (scope.disableScrollTo === undefined) {
                        scope.$on('scrollToLine', function(e, lineNum) {
                            if (oldTable) {
                                let nbRowsVisible = oldTable.h / oldTable.rowHeight; // we need the float value
                                let firstVisibleRow = oldTable.scroll.scrollTop / oldTable.rowHeight; // we need the float value
                                let x = oldTable.scroll.scrollLeft;
                                if (lineNum == -1) {
                                    let y = oldTable.nbRows * oldTable.rowHeight;
                                    oldTable.scroll.setScrollXY(x, y);
                                } else if (lineNum <= firstVisibleRow) {
                                    let y = Math.max(lineNum, 0) * oldTable.rowHeight;
                                    oldTable.scroll.setScrollXY(x,y);
                                } else if (lineNum >= firstVisibleRow + nbRowsVisible - 1) {
                                    let y = (Math.min(lineNum, oldTable.nbRows) + 1) * oldTable.rowHeight - oldTable.h;
                                    oldTable.scroll.setScrollXY(x,y);
                                }
                            }
                        });
                    }

                    var debouncedRedraw = Debounce().withDelay(50,200).wrap(redraw);
                    $(window).on('resize', debouncedRedraw);

                    element.scope().$on("reflow", debouncedRedraw);

                    scope.$on("$destroy", function () {
                        if(oldTable) {
                            oldTable.cleanUp();
                            oldTable=null;
                        }
                        for(var i = 0 ; i < livingCells.length ; i++) {
                            cleanDOM(livingCells[i]);
                        }
                        livingCells = [];
                        $(window).off("resize", debouncedRedraw);
                    });


                };
            }
        };
    });

    app.directive('spinner', function() {
        return {
            template: '<div class="spinnerContainer"></div>',
            replace: true,
            restrict: 'E',
            link: function(scope, element, attrs) {
                var opts = {
                  lines: 6, // The number of lines to draw
                  length: 0, // The length of each line
                  width: 10, // The line thickness
                  radius: 10, // The radius of the inner circle
                  corners: 1, // Corner roundness (0..1)
                  rotate: 0, // The rotation offset
                  color: '#fff', // #rgb or #rrggbb
                  speed: attrs.speed || 1, // Rounds per second
                  trail: 60, // Afterglow percentage
                  shadow: false, // Whether to render a shadow
                  hwaccel: false, // Whether to use hardware acceleration
                  className: 'spinner', // The CSS class to assign to the spinner
                  zIndex: 2e9, // The z-index (defaults to 2000000000)
                  top: 'auto', // Top position relative to parent in px
                  left: 'auto' // Left position relative to parent in px
              };
              var spinner = new Spinner(opts).spin(element[0]);
          }
       };
    });

    app.directive('formTemplate', function(){
        return {
            templateUrl: '/templates/form-template.html',
            replace: true,
            restrict: 'E',
            link: function(scope, element, attrs){
                function initializeDefaultValues() {
                    if (scope.formDefinition) {
                        for (const formDefinitionElement of scope.formDefinition) {
                            if (!formDefinitionElement.params) {
                                continue;
                            }
                            if (!scope.model.hasOwnProperty(formDefinitionElement.name)) {
                                scope.model[formDefinitionElement.name] = {};
                            }
                            for (const param of formDefinitionElement.params) {
                                if (!scope.model[formDefinitionElement.name].hasOwnProperty(param.name) && param.defaultValue) {
                                    scope.model[formDefinitionElement.name][param.name] = param.defaultValue;
                                }
                            }
                        }
                    }
                }

                if (attrs.monitor) {
                    scope.model = {};
                    scope.$watch(attrs.monitor, function(ov, nv) {
                        const model = scope.$eval(attrs.model);
                        if (model && Object.keys(model).length > 0) {
                            scope.model = model;
                        }
                        scope.formDefinition = scope.$eval(attrs.formDefinition);

                        initializeDefaultValues();
                    });
                } else {
                    scope.model = scope.$eval(attrs.model);
                    scope.formDefinition = scope.$eval(attrs.formDefinition);
                }
            }
        };
    });

    app.directive('formTemplateElement', function(){
        return {
            templateUrl: '/templates/form-template-element.html',
            replace: true,
            restrict: 'EA',
            scope: {
                model: '=',
                field: '=',
                onCoreParamsChanged: '&'
            },
            link: function(scope, element, attrs) {
                // noop
            }
        };
    });

    app.directive('forceInteger', function() {
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function(scope, element, attr, ngModel) {
                function fromUser(text) {
                    return text;
                }

                function toUser(text) {
                    return parseInt(text || 0, 10);
                }
                ngModel.$parsers.push(fromUser);
                ngModel.$formatters.push(toUser);
            }
        };
    });

    app.directive('convertSpecialChar', function() {
         return {
            restrict: 'A',
            require: 'ngModel',
            link: function(scope, element, attr, ngModel) {
                function fromUser(text) {
                    const result = convertSpecialChars(text);
                    ngModel.$setValidity('singleChar', 1 === result.length);
                    return result;
                }
                function toUser(text) {
                    // For the moment we do not convert the unicode character into its ASCII representation as it can
                    // be displayed as-is in text inputs.
                    return text == null ? null : text.replace('\t', '\\t');
                }
                ngModel.$parsers.push(fromUser);
                ngModel.$formatters.push(toUser);
            }
        };
    });

    app.directive('convertPercentage', function() {
         return {
            restrict: 'A',
            require: 'ngModel',
            link: function(scope, element, attr, ngModel) {
                // calling round to avoid long decimal tail after floating point math operations e.g. 0.072*100=7.199999999999999
                function round(n){
                    return Math.round(n * 10 ** 12) / 10 ** 12;
                }

                function fromUser(text) {
                    return text == null ? null : round(parseFloat(text) / 100);
                }
                function toUser(text) {
                    return text == null ? null : round(parseFloat(text) * 100);
                }
                ngModel.$parsers.push(fromUser);
                ngModel.$formatters.push(toUser);
            }
        };
    });
    app.directive('forceDouble', function() {
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function(scope, element, attr, ngModel) {
                function fromUser(text) {
                    return text;
                }

                function toUser(text) {
                    // Don't silently replace empty by zero !
                    if(text!=null && text!=undefined && text!=='') {
                        return parseFloat(text);
                    } else return '';
                }
                ngModel.$parsers.push(fromUser);
                ngModel.$formatters.push(toUser);
            }
        };
    });

    // Droparea is a component that handle file drops on it and callbacks the method defined on its drop parameter
    app.directive("droparea", function($filter, $timeout){
        return {
            restrict: 'E',
            template: '<div class="droparea" ng-class="{candrop: candrop}">'+
                '<form class="upload"></form>'+
                '<div ng-transclude class="nested-template-container"></div>' +
            '</div>',
            replace: true,
            transclude: true,
            scope: {
                drop: '&',
                validate: '&',
                //paramaters used by droparea directive to expose to its parent a candrop flag
                isDroppable: '=?',
            },
            link: function(scope, element, attrs){
                scope.multiple = 'multiple' in attrs;
                scope.noUploadOnClick = 'noUploadOnClick' in attrs;
                scope.candrop = false;
                scope.$watch('candrop', function(nv, ov) {
                    scope.isDroppable = scope.candrop;
                })

                // input fallback
                function addFileManually() {
                    var evt = document.createEvent("MouseEvents");
                    evt.initEvent('click', true, true );
                    input[0].dispatchEvent(evt);
                }

                if (!scope.noUploadOnClick)  {
                    element.click(function(e){
                        e.stopPropagation();
                        addFileManually();
                    });
                }

                element.on('click', 'form.upload input', function(e){
                    e.stopPropagation();
                }).on('change', 'form.upload input', function(e){
                    const files = this.files;
                    scope.$apply(function() {
                        scope.drop({'files': files});
                    });
                    createInput();
                });

                var input;
                function createInput(){
                    element.find('form.upload').find('input').remove();
                    input = $('<input type="file" name="file" id="qa_upload_dataset_input-files" multiple />');
                    element.find('form.upload').append(input);
                }
                createInput();

                // drop file
                function applyDragEnterLeave(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    scope.candrop = false;
                    scope.$apply();
                }
                function cancelEnterLeaveTimeout() {
                    if (scope.enterLeaveTimeout) {
                        $timeout.cancel(scope.enterLeaveTimeout);
                    }
                }
                function dragEnterLeave(e) {
                    cancelEnterLeaveTimeout();
                    //debouncing applyDragEnterLeave to prevent flickering when hovering element's children
                    scope.enterLeaveTimeout = $timeout(function() {
                        applyDragEnterLeave(e);
                    }, 100);
                }
                element.bind("dragenter", dragEnterLeave);
                element.bind("dragleave", dragEnterLeave);
                element.bind("dragover", function(e) {
                    cancelEnterLeaveTimeout();
                    e.stopPropagation();
                    e.preventDefault();
                    scope.$apply(function(){
                        var evt = e.originalEvent;
                        if (evt.dataTransfer &&
                            evt.dataTransfer.types &&
                            (
                                (evt.dataTransfer.types.indexOf && evt.dataTransfer.types.indexOf('Files') >= 0) ||
                                (evt.dataTransfer.types.contains && evt.dataTransfer.types.contains('Files'))
                            )
                        ) {
                            // feedback
                            scope.candrop = true;
                            var af = evt.dataTransfer.effectAllowed;
                            evt.dataTransfer.dropEffect = ('move' == af || 'linkMove' == af) ? 'move' : 'copy';
                        }
                    });
                });
                element.bind("drop", function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    scope.$apply(function(){
                        var evt = e.originalEvent;
                        if (evt.dataTransfer &&
                            evt.dataTransfer.types &&
                            (
                                (evt.dataTransfer.types.indexOf && evt.dataTransfer.types.indexOf('Files') >= 0) ||
                                (evt.dataTransfer.types.contains && evt.dataTransfer.types.contains('Files'))
                            ) &&
                            (scope.multiple || evt.dataTransfer.files.length == 1)
                        ){
                            scope.drop({'files': evt.dataTransfer.files});
                            scope.candrop = false;
                        }
                    });
                });
            }
        };
    });

    app.directive('commaSeparatedView', function (){
        return {
            require: 'ngModel',
            link: function(scope, elem, attrs, ngModel) {
                //For DOM -> model transformations
                ngModel.$parsers.push(function(value) {
                    if (value == null || value.length == 0) return [];
                    return value.split(",");
                });

                //For model -> DOM transformation
                ngModel.$formatters.push(function(value) {
                    if (value == undefined) return "";
                    return value.join(",");
                });
            }
        };
    });
    app.directive('jsonArrayView', function (){
        return {
            require: 'ngModel',
            link: function(scope, elem, attrs, ngModel) {
                //For DOM -> model transformations
                ngModel.$parsers.push(function(value) {
                    ngModel.$setValidity('json', true);
                    if (value == null || value.length == 0) return [];
                    try {
                        return JSON.parse(value);
                    } catch (e) {
                         ngModel.$setValidity('json', false);
                         return null;
                    }
                });

                //For model -> DOM transformation
                ngModel.$formatters.push(function(value) {
                    if (value == undefined) return null;
                    return JSON.stringify(value);
                });
            }
        };
    });
    app.directive('jsonArrayPrettyView', function (){
        return {
            require: 'ngModel',
            link: function(scope, elem, attrs, ngModel) {
                //For DOM -> model transformations
                ngModel.$parsers.push(function(value) {
                    ngModel.$setValidity('json', true);
                    if (value == null) return [];
                    try {
                        return JSON.parse(value);
                    } catch (e) {
                         ngModel.$setValidity('json', false);
                         return null;
                    }
                });

                //For model -> DOM transformation
                ngModel.$formatters.push(function(value) {
                    if (value == undefined) return null;
                    return JSON.stringify(value, undefined, 3);
                });
            }
        };
    });

     app.directive('jsonObjectPrettyView', function (Logger){
            return {
                require: 'ngModel',
                link: function(scope, elem, attrs, ngModel) {
                    var el = elem[0];
                    //For DOM -> model transformations
                    ngModel.$parsers.push(function(value) {
                        ngModel.dkuJSONError = null;
                        ngModel.$setValidity('json', true);
                        if (value == null || value.length == 0) return null;
                        try {
                            return JSON.parse(value);
                        } catch (e) {
                             ngModel.$setValidity('json', false);
                             Logger.info("Error while parsong JSON: ", value, e);
                             ngModel.dkuJSONError = e.toString();
                             if ('keepOldIfInvalid' in attrs) {
                                 return ngModel.$modelValue;
                             } else {
                                 return null;
                             }
                        }
                    });

                    //For model -> DOM transformation
                    ngModel.$formatters.push(function(value) {
                        if (value == undefined) return null;
                        var prevSelStart = el.selectionStart;
                        var prevSelEnd = el.selectionEnd;
                        var prevScroll = el.scrollTop;
                        if(el == document.activeElement) {
                            setTimeout(function() {
                                el.setSelectionRange(prevSelStart,prevSelEnd);
                                el.scrollTop = prevScroll;
                            },0);
                        }
                        return JSON.stringify(value,undefined,3);
                    });

                    if (attrs.deepUpdate) {
                        scope.$watch(attrs.ngModel, function(nv, ov) {
                            try {
                                var formatters = ngModel.$formatters, idx = formatters.length;
                                var viewValue = ngModel.$modelValue;
                                while (idx--) {
                                    viewValue = formatters[idx](viewValue);
                                }
                                if (viewValue != null) {
                                    ngModel.$viewValue = viewValue;
                                    ngModel.$render();
                                }
                            } catch (e) {
                                Logger.info("JSON is invalid, not rendering ...")
                            }
                        }, true);
                    }
                }
            };
     });

    app.directive('jsonObjectView', function (){
        return {
            require: 'ngModel',
            link: function(scope, elem, attrs, ngModel) {
                //For DOM -> model transformations
                ngModel.$parsers.push(function(value) {
                    ngModel.$setValidity('json', true);
                    if (value == null || value.length == 0) return null;
                    try {
                        return JSON.parse(value);
                    } catch (e) {
                         ngModel.$setValidity('json', false);
                         return null;
                    }
                });

                //For model -> DOM transformation
                ngModel.$formatters.push(function(value) {
                    if (value == undefined) return null;
                    return JSON.stringify(value);
                });
            }
        };
    });

    app.directive('commaSeparatedIntegerView', function (){
        return {
            require: 'ngModel',
            link: function(scope, elem, attrs, ngModel) {
                //For DOM -> model transformations
                ngModel.$parsers.push(function(value) {
                    if (value == null) return [];
                    var ret = value.split(",").map(function(x) { return parseInt(x, 10); }).filter(function(x) { return !isNaN(x);});
                    return ret;
                });

                //For model -> DOM transformation
                ngModel.$formatters.push(function(value) {
                    if (value == undefined) return "";
                    return value.join(",");
                });
            }
        };
    });

    app.directive('commaSeparatedFloatView', function (){
        return {
            require: 'ngModel',
            link: function(scope, elem, attrs, ngModel) {
                //For DOM -> model transformations
                ngModel.$parsers.push(function(value) {
                    if (value == null) return [];
                    var ret = value.split(",").map(function(x) { return parseFloat(x, 10); }).filter(function(x) { return !isNaN(x);});
                    return ret;
                });

                //For model -> DOM transformation
                ngModel.$formatters.push(function(value) {
                    if (value == undefined) return "";
                    return value.join(",");
                });
            }
        };
    });


    app.directive('customValidation', function (){
        return {
            require: 'ngModel',
            link: function(scope, elem, attrs, ngModel) {
                function apply_validation(value) {
                    ngModel.$setValidity('customValidation', true);
                    let cv = scope.$eval(attrs.customValidation);
                    var valid = cv && cv(value);
                    ngModel.$setValidity('customValidation', valid);
                    return value;
                }

                //For DOM -> model validation
                ngModel.$parsers.push(apply_validation);

                //For model -> DOM validation
                ngModel.$formatters.push(function(value) {
                    apply_validation();
                    return value;
                });
            }
        };
    });

    app.directive('fixedPanes', function($timeout,$rootScope){
        return {
            restrict: 'A',
            link: function(scope, element, attrs){
                scope.showLeftPane = scope.$eval(attrs.showLeftPane) || false;
                scope.showRightPane = scope.$eval(attrs.showRightPane)  || false;

                scope.setShowLeftPane = function(showLeftPane) {
                    if (scope.showLeftPane != showLeftPane) {
                        scope.showLeftPane = showLeftPane;
                        $timeout(function(){
                            scope.$broadcast('resizePane');
                            $rootScope.$broadcast('reflow');
                        }, 250);

                    }
                }
                scope.openLeftPane = function() {
                    scope.setShowLeftPane(true);
                }
                scope.closeLeftPane = function() {
                    scope.setShowLeftPane(false);
                }
                scope.toggleLeftPane = function(){
                    scope.setShowLeftPane(!scope.showLeftPane);
                };


                scope.setShowRightPane = function(showRightPane) {
                    if (scope.showRightPane != showRightPane) {
                        scope.showRightPane = showRightPane;
                        $timeout(function(){
                            scope.$broadcast('resizePane');
                            $rootScope.$broadcast('reflow');
                        }, 250);
                    }
                }
                scope.openRightPane = function() {
                    scope.setShowRightPane(true);
                }
                scope.closeRightPane = function() {
                    scope.setShowRightPane(false);
                }
                scope.toggleRightPane = function(){
                    scope.setShowRightPane(!scope.showRightPane);
                };
            }
        };
    });

    app.directive('watchScroll', function() {
       return {
           restrict : 'A',
            link: function(scope, element, attrs){
                $(element).addClass("watch-scroll");
                function scrollStart() {
                    $(element).addClass("scrolling");
                }
                function scrollEnd() {
                    $(element).removeClass("scrolling");
                }
                var scrolling = false;
                $(element).scroll(function() {
                    if (!scrolling) scrollStart();
                    clearTimeout($.data(this, 'scrollTimer'));
                    $.data(this, 'scrollTimer', setTimeout(function() {
                        scrollEnd();
                    }, 200));
                });
            }
        };
    });

    app.directive('tabs', function($filter, $location, $compile, $timeout, Logger) {
        return {
            restrict: 'E',
            scope: true,
            // replace: true,
            myTemplateNonScrollable: '<div class="tabbable">' +
                '<ul class="nav nav-tabs">' +
                    '<li ng-repeat="pane in panes|filter:{visible:true}" class="{{ pane.position }}" ng-class="{active:pane.selected}" style="{{ paneHeaderStyle }}">' +
                        '<a href="" ng-click="select(pane, noHashUpdate)" class="qa_generic_widget-tab">' +
                        '<span class="title"><i ng-show="pane.icon" class="icon-{{ pane.icon }}"></i><span fw500-width> {{ pane.title }}</span></span>'+
                        '<br ng-if="pane.subtitle"/><span class="subtitle" ng-if="pane.subtitle" ng-bind-html="pane.subtitle"></span>'+
                        '</a>' +
                    '</li>' +
                '</ul>' +
                '<div class="tab-content" ></div>' +
            '</div>',
            myTemplateScrollable: '<div class="tabbable">' +
                '<div class="scroller scroller-left"><i class="icon-chevron-left"></i></div>'+
                '<div class="scroller scroller-right"><i class="icon-chevron-right"></i></div>'+
                '<div class="tabs-scroll-wrapper">'+
                '<ul class="nav nav-tabs tabs-scroll-zone">' +
                    '<li ng-repeat="pane in panes|filter:{visible:true}" class="{{ pane.position }}" ng-class="{active:pane.selected}" style="{{ paneHeaderStyle }}">' +
                        '<a href="" ng-click="select(pane, noHashUpdate)" class="qa_generic_widget-tab"><i ng-show="pane.icon" class="icon-{{ pane.icon }}"></i> {{ pane.title }}</a>' +
                    '</li>' +
                '</ul></div>' +
                '<div class="tab-content" ></div>' +
            '</div>',
            myTemplateNewStyleScrollable: '<div class="tabbable">' +
                '<div class="scroller scroller-left"><i class="icon-chevron-left"></i></div>'+
                '<div class="scroller scroller-right"><i class="icon-chevron-right"></i></div>'+
                '<div class="tabs-scroll-wrapper">'+
                '<ul class="column-header-tabs tabs-scroll-zone">' +
                    '<li ng-repeat="pane in panes|filter:{visible:true}" class="{{ pane.position }} tab" ng-class="{active:pane.selected}" style="{{ paneHeaderStyle }}">' +
                        '<span class="title" ng-click="select(pane, noHashUpdate)" class="qa_generic_widget-tab"><i ng-show="pane.icon" class="icon-{{ pane.icon }}"></i> {{ pane.title }}</span>' +
                    '</li>' +
                '</ul></div>' +
                '<div class="tab-content" ></div>' +
            '</div>',
             myTemplateNewStyle: '<div class="">' +
                '<ul class="column-header-tabs" style="margin: 0">' +
                    '<li ng-repeat="pane in panes|filter:{visible:true}" class="{{ pane.position }} tab" ng-class="{active:pane.selected}" style="{{ paneHeaderStyle }}">' +
                        '<span class="title" ng-click="select(pane, noHashUpdate)" class="qa_generic_widget-tab"><i ng-show="pane.icon" class="icon-{{ pane.icon }}"></i> {{ pane.title }}</span>' +
                    '</li>' +
                '</ul>' +
                '<div class="tab-content" ></div>' +
            '</div>',
            compile: function(tElement, attrs){
                // get the panes of the tabs
                var originalContent = $('<div></div>').html(tElement.contents()).contents();
                var el;
                if (attrs.newStyle && attrs.scrollable) {
                    el = $(this.myTemplateNewStyleScrollable);
                } else if (attrs.newStyle) {
                    el = $(this.myTemplateNewStyle);
                } else if (attrs.scrollable) {
                    el = $(this.myTemplateScrollable);
                } else  {
                    el = $(this.myTemplateNonScrollable);
                }
                if (tElement.hasClass('vertical-flex')) {
                    el.addClass('vertical-flex h100');
                    el.children(':not(.tab-content)').addClass('noflex');
                    el.children('.tab-content').addClass('flex');
                }
                tElement.replaceWith(el);
                el.find('.tab-content').append(originalContent);
                return this.link;
            },
            controller: function($scope, $element, $rootScope) {
                var panes = $scope.panes = [];
                $scope.select = function(pane, force) {
                    if (!pane.selected){
                        angular.forEach(panes, function(p) {
                            p.selected = false;
                        });
                        pane.selected = true;
                        $timeout(function() {
                            pane.displayed = true;
                        });
                        if ($scope.onSelect) {
                            $scope.onSelect(pane);
                        }
                        $scope.$emit('paneSelected', pane);
                        $scope.$broadcast('paneSelected', pane);
                        $rootScope.$broadcast("reflow");

                        if (!force){
                            // TEMPORARY TEMPORARY :
                            // Disable updating of the location hash, because
                            //  it breaks ui-router's interaction with browser history.
                            //   - If you are on state A with no hash, transitionTo(B), then back takes you back to A
                            //   - If you are on state A with no hash, then on state B with hash, transitionTo(C)
                            //      - will propagate the hash so you will actually be on C#hash, which we don't want
                            //      - back button will take you back to A, the B#hash state has disappeared from browser
                            //        history
                            $location.hash(pane.slug, true).replace(true);
                        }
                    }
                };

                this.select = $scope.select;
                this.addPane = function(pane) {
                    panes.push(pane);
                    if (panes.length == 1) {
                        $scope.select(pane, true);
                    }
                };

                $scope.$on('tabSelect', function(e, slug){
                    var pane = $filter('filter')(panes, {'slug':slug});
                    if(pane && pane.length){
                       $scope.select(pane[0]);
                    } else {
                        Logger.warn("Failed to select a pane for slug ", slug, " amongst", panes, " filtered", pane);
                    }
                });
                this.verticalFlex = $element.hasClass('vertical-flex');
            },
            link : function($scope, element, attrs) {
                $scope.noHashUpdate = "noHashUpdate" in attrs;
                if (attrs.scrollable) {

                    var totalWidth = function(){
                        var itemsWidth = 0;
                        $('.tabs-scroll-zone li', element).each(function(){
                            var itemWidth = $(this).outerWidth();
                            itemsWidth+=itemWidth;
                        });
                        return itemsWidth;
                    };
                    var scrollBarWidths = 46; /* 2x23 */

                    var hiddenWidth = function(){
                        return (
                            ($('.tabs-scroll-wrapper', element).outerWidth()) -
                            totalWidth()-getLeftPosi())
                            -
                            scrollBarWidths;
                    };
                    var getLeftPosi = function(){
                        return $('.tabs-scroll-zone').position().left;
                    };

                    $('.scroller-right', element).click(function() {
                        $('.scroller-left', element).show();
                        $('.scroller-right', element).hide();
                        $('.tabs-scroll-zone', element).animate({left:"+="+hiddenWidth()+"px"});
                    });

                    $(".scroller-left", element).click(function(e) {
                        $('.scroller-right', element).show();
                        $('.scroller-left', element).hide();
                        $('.tabs-scroll-zone', element).animate({left:"-="+getLeftPosi()+"px"});
                    });
                    $timeout(function(){
                        if (($('.tabs-scroll-wrapper', element).outerWidth()) < totalWidth()) {
                            $('.scroller-right').show();
                        }
                    }, 0);
                }
                if (attrs.paneHeaderStyle) {
                    $scope.paneHeaderStyle = attrs.paneHeaderStyle;
                } else {
                    $scope.paneHeaderStyle = '';
                }
            }
        };
    });

    app.directive('pane', function($filter, $location, $timeout, $compile, $rootScope) {
        var paneTemplate = $compile('<div class="tab-pane" ng-class="{active: struct.selected}"></div>');
        return {
            require: '^tabs',
            restrict: 'E',
            terminal: true,
            scope: true,
            compile: function(tElement){
                // get the content of the pane
                var transcludeFunction = $compile(tElement.contents());

                return function(scope, element, attrs, tabsCtrl){

                    // replace the pane by the paneTemplate
                    paneTemplate(scope, function(clone){
                        element.replaceWith(clone);
                        element = clone;
                    });

                    // append the content of the pane
                    transcludeFunction(scope, function(clone){
                        element.append(clone);
                    });

                    scope.struct = {
                        title: attrs.title,
                        subtitle: scope.$eval(attrs.subtitle),
                        slug: $filter('slugify')(attrs.title),
                        icon: attrs.icon,
                        visible: angular.isUndefined(attrs.visiblePane)?true:scope.$eval(attrs.visiblePane),
                        position: attrs.position,
                    };

                    element.addClass("tab-" + scope.struct.slug);
                    if (tabsCtrl.verticalFlex) { element.addClass('fh'); }

                    attrs.$observe('title', function(val){
                        // If the title attribute is modified
                        scope.struct.title = val;
                    });
                    scope.$watch(attrs.subtitle, function(nv, ov){
                        // If the title attribute is modified
                        scope.struct.subtitle = nv;
                    });

                    // Removing the title from the element itself, to prevent a tooltip when hovering anywhere over
                    // the content.
                    element.removeAttr('title');
                    // having a pb when combined with ng-repeat
                    $timeout(function(){element.removeAttr('title');}, 10);

                    // register itself
                    tabsCtrl.addPane(scope.struct);
                    if ($location.hash() == scope.struct.slug && scope.struct.visible){
                        tabsCtrl.select(scope.struct);
                    }

                    attrs.$observe('visiblePane', function(value){
                        scope.struct.visible = angular.isUndefined(value)?true:value=="true";
                    });

                    scope.$watch('struct.selected', function(nv, ov){
                        if (nv){
                            if (attrs.noResizeHack == null) {
                                // ugly hack, this will trigger a window resize event, thus refreshing flowchart layout
                                // and CodeMirror-alikes
                                window.dispatchEvent(new Event('resize'));
                            }
                            $rootScope.$broadcast("reflow");
                        }
                    });
                };
            },
        };
    });

    app.directive("detectIframeClicks", function() {
        return {
            scope: false,
            restrict: "A",
            link: function(scope, element, attrs){
                var overIFrame = false;
                element.mouseenter(function() {
                    overIFrame = true;
                });
                element.mouseleave(function() {
                    overIFrame = false;
                });
                $(window).blur(function() {
                    if (overIFrame) {
                        $(document).trigger("click");
                    }
                });
            }
        }
    })

    app.directive('sortTable', function($rootScope){
        return {
            scope: true,
            controller: function($scope, $element, $attrs){
                this.setSort = function(col) {
                    if($scope.sortColumn){
                        $scope.cols[$scope.sortColumn].removeClass('sort-descending').removeClass('sort-ascending');
                    }
                    if ($scope.sortColumn === col) {
                        $scope.sortDescending = !$scope.sortDescending;
                    } else {
                        $scope.sortColumn = col;
                        $scope.sortDescending = false;
                    }
                    this.refresh();
                };

                this.refresh = function(){
                    if($scope.cols[$scope.sortColumn]){
                        if ($scope.sortDescending) {
                            $scope.cols[$scope.sortColumn].addClass("sort-descending");
                        } else {
                            $scope.cols[$scope.sortColumn].addClass("sort-ascending");
                        }
                        if(! $rootScope.$$phase) $scope.$apply();
                    }
                };

                $scope.sortColumn = $attrs.sortColumn;
                $scope.sortDescending = $scope.$eval($attrs.sortDescending) || false;
                if($attrs.sortTable){
                    if ($attrs.sortTable[0] == "-") {
                        $scope.sortDescending = true;
                        $scope.sortColumn = $attrs.sortTable.substring(1);
                    } else {
                        $scope.sortColumn = $attrs.sortTable;
                    }
                }

                $scope.cols = {};
                this.addCol = function(col, element){
                    $scope.cols[col] = element;
                    element.addClass("sortable");
                    if(angular.isUndefined($scope.sortColumn)){
                        this.setSort(col);
                    } else {
                        this.refresh();
                    }
                };
            }
        };
    });

    /* This is an alternative version of sortTable, featuring a two way binding of sortColumn and sortDescending using
        standard angular features rather than playing with attributes.

        Using it, one can easily pass initial sortColumn and sortDescending as variables, and get back all modifications
        performed by the user.

        Note: when this version is used, one should not use sortColumn and sortDescenging as parameters of the orderBy angular pipe.
        Variables passed as parameters should be used.

        Example:

            <table sort-table-dyn
                sort-column="myScope.mySortColumn" sort-descending="myScope.mySortDescending">
                    ...
                <tbody>
                    <tr ng-repeat="item in selection.filteredObjects | orderBy:myScope.mySortColumn:myScope.mySortDescending">

        It is similar to sortTable. However, adding double binding to the former implementation seemed would lead to a code
        a lot less understandable, especially if we want to avoid a refactoring of all current sort-table usages.
    */
    app.directive('sortTableDyn', function($rootScope){
        return {
            scope:{
                sortColumn: '=',
                sortDescending: '='
            },
            controller: function($scope, $element, $attrs){
                this.setSort = function(col) {
                    if ($scope.sortColumn === col) {
                        $scope.sortDescending = !$scope.sortDescending;
                    } else {
                        $scope.sortColumn = col;
                        $scope.sortDescending = false;
                    }
                    this.refresh();
                };

                this.refresh = function(){
                    Object.values($scope.cols).forEach(e => e.removeClass('sort-descending').removeClass('sort-ascending'));
                    if($scope.cols[$scope.sortColumn]){
                        if ($scope.sortDescending) {
                            $scope.cols[$scope.sortColumn].addClass("sort-descending");
                        } else {
                            $scope.cols[$scope.sortColumn].addClass("sort-ascending");
                        }
                        if(! $rootScope.$$phase) $scope.$apply();
                    }
                };


                $scope.cols = {};
                this.addCol = function(col, element){
                    $scope.cols[col] = element;
                    element.addClass("sortable");
                    this.refresh();
                };
            }
        };
    });

    app.directive('sortCol', function(){
        return {
            scope: true,
            require: '^sortTable',
            link: function(scope, element, attrs, sortTableCtrl){
                sortTableCtrl.addCol(attrs.sortCol, element);
                element.on('click', function(){
                    sortTableCtrl.setSort(attrs.sortCol);
                });
            }
        };
    });

    app.directive('sortColDyn', function(){
        return {
            scope: true,
            require: '^sortTableDyn',
            link: function(scope, element, attrs, sortTableCtrl){
                sortTableCtrl.addCol(attrs.sortColDyn, element);
                element.on('click', function(){
                    sortTableCtrl.setSort(attrs.sortColDyn);
                });
            }
        };
    });

    app.directive('daterangepicker', function($rootScope){
        return {
            restrict: 'A',
            template : ' <div class="input-append" style="margin-bottom:0px;"><input type="text" style="opacity:0;'
                 +'position:absolute;top:-3000px;left:-3000px"/>'
                 +'<input type="text" class="theInput" /> ',
            scope: {
                startDate: '=',
                endDate: '=',
                opensDirection:'@',
                opens: '@',
                format: '@',
                timePickerIncrement : '@',
                presetsToEndOfDay : '=',
                fieldWidth : '@',
                singleDatePicker: '=',
                onChange: "=?",
            },
            replace : true,
            link: function(scope, element, attrs){

                var input = element.find('.theInput');
                var picker = undefined;

                if (scope.fieldWidth) {
                    input.width(scope.fieldWidth);
                }

                element.find('input').keydown(function(e){
                    if(e.keyCode==13 && picker) {
                        picker.hide();
                    }
                });

                // Create the date picker if not already done, and only if the format is set
                function init() {
                    if(!picker && scope.format) {
                        var endOfDayDelta = scope.presetsToEndOfDay ? 1 : 0;
                        picker = input.daterangepicker({
                              format:scope.format,
                              timePickerIncrement: scope.timePickerIncrement ? parseInt(scope.timePickerIncrement) : 60,
                              timePicker: scope.format.indexOf('HH')!=-1,
                              opens: attrs.opens || 'right',
                              timePicker12Hour:false,
                              autoApply:true,
                              separator : ' / ',
                              singleDatePicker: !!scope.singleDatePicker,
                              ranges: {
                                 'Today': [moment(), moment().add('days', endOfDayDelta)],
                                 'Yesterday': [moment().subtract('days', 1), moment().subtract('days', 1 - endOfDayDelta)],
                                 'Last 7 Days': [moment().subtract('days', 6), moment().add('days', endOfDayDelta)],
                                 'Last 30 Days': [moment().subtract('days', 29), moment().add('days', endOfDayDelta)],
                                 'This Month': [moment().startOf('month'), moment().endOf('month')],
                                 'Last Month': [moment().subtract('month', 1).startOf('month'), moment().subtract('month', 1).endOf('month')]
                               },
                               locale: {firstDay: 1},
                               opensDirection: attrs.opensDirection || 'down'
                        },changeDate).data('daterangepicker');

                        picker.element.on('hide.daterangepicker', function (ev, picker) {
                            if (picker.element.val().length === 0) {
                                scope.startDate = null;
                                scope.endDate = null;
                                if(!$rootScope.$$phase) {
                                    $rootScope.$digest();
                                }
                            }
                        });

                        // open upwards if no room below and vice versa
                        if (attrs.opensDirection === 'auto') {
                            picker.element.on('show.daterangepicker', function(ev, picker) {
                                const currentDirection = picker.opensDirection;
                                let newDirection = 'down'

                                if (picker.element.offset().top + picker.element.outerHeight() + picker.container.outerHeight() > $(window).height()) {
                                    newDirection = 'up';
                                }

                                // need to close and reopen for change to take effect
                                if (currentDirection !== newDirection) {
                                    picker.opensDirection = newDirection;
                                    picker.hide();
                                    picker.show();
                                }
                            });
                        }
                    }
                    if(picker)
                        return true;

                    return false;
                }

                var insideWatch = false;
                var insideUserCallback = false;

                // Update the scope from the date picker state
                function changeDate() {

                    if(!init() || insideWatch) return;
                    try {
                        insideUserCallback = true;
                        picker.updateFromControl();
                        if(!scope.format) return;
                        scope.startDate = picker.startDate.format(scope.format);
                        scope.endDate = picker.endDate.format(scope.format);
                        if(!$rootScope.$$phase) {
                            $rootScope.$digest();
                        }
                        if (scope.onChange) {
                            scope.onChange();
                        }
                    } finally {
                        insideUserCallback = false;
                    }
                }

                // Update date picker state from scope
                scope.$watch('[startDate,endDate]',function(nv,ov) {
                    if(!init() || insideUserCallback) return;
                    try {
                        insideWatch = true;
                        if (!nv[0] && !nv[1]){
                            picker.element.val("");
                            return;
                        }
                        if(scope.startDate) {
                            picker.setStartDate(moment(scope.startDate,scope.format));
                        }
                        if(scope.endDate) {
                            picker.setEndDate(moment(scope.endDate,scope.format));
                        }
                    } finally {
                        insideWatch = false;
                    }
                },true);

                scope.$watch('format',function(nv, ov) {
                    if(!picker) {
                        init();
                    } else if (nv != ov) {
                        picker.format = nv;
                        picker.timePicker = nv.indexOf('HH')!=-1;
                        picker.timePickerIncrement= scope.timePickerIncrement ? parseInt(scope.timePickerIncrement) : 60;
                        picker.updateInputText();
                        changeDate();
                        picker.updateCalendars();
                    }

                });

                scope.$on('$destroy',function() {
                    if(picker) {
                        picker.remove();
                        picker = undefined;
                    }
                })
            }
        };
    });


    /*
     *   Very similar to dkuHelpPopover, but the template can be inlined
     *   Usage :
     *
     *   <button class="btn btn-small" dku-inline-popover>
     *        <label>
     *            <span class="icon-question">&nbsp;</span>
     *                      Button text
     *        </label>
     *        <content title="Help me">
     *            <h2>Introduction</h2>
     *            <p>Blablabla</p>
     *        </content>
     *   </button>
     *
     */
    app.directive('dkuInlinePopover',function($timeout, $compile, $interpolate) {
        return {
            restrict : 'A',
            scope : true,
            transclude:true,
            template:'',

            compile:function(_element,_attrs,transclude) {
                return function(scope,element,attrs) {
                    transclude(scope.$new(), function(clone) {

                        var contentFilter = clone.filter("content");
                        var buttonText = clone.filter('label').contents();
                        var popoverContent = contentFilter.contents();
                        var title = contentFilter.attr("title") ? $interpolate(contentFilter.attr("title"))(scope) : null;

                        // I'VE NO FUCKING IDEA OF WHY IT WORKS
                        // timeout is the universal fix :D
                        $timeout(function() {element.append(buttonText);});
                        var shown = false;
                        var options = {
                                html: true,
                                content: popoverContent,
                                placement: (attrs.placement in scope) ? scope[attrs.placement]  : (attrs.placement || 'right'),
                                container: attrs.container?attrs.container:undefined,
                                title: title
                        };

                        if (attrs.on === "hover") {
                            options.animation = false;
                            element.popover(options).on("mouseenter", function () {
                                $(this).popover("show");
                                if (attrs.popoverClass) {
                                    $timeout(() => {
                                        const popover = element.data('popover').$tip;
                                        popover.addClass(attrs.popoverClass);
                                    });
                                }
                            }).on("mouseleave", function () {
                                $(this).popover("hide");
                            });
                        } else {  // click
                            element.popover(options);
                            function show() {
                                shown = true;
                                window.setTimeout(function() {
                                    $("html").click(hide);
                                    const popover = element.data('popover').$tip;
                                    if (attrs.clickable) popover.click(stopPropagation);
                                    if (attrs.popoverClass) popover.addClass(attrs.popoverClass);
                                }, 0);
                            }

                            function stopPropagation($event) {
                                $event.stopPropagation();
                            }

                            function hide() {
                                shown = false;
                                element.popover('hide');
                                $("html").unbind("click", hide);
                                const popover = element.data('popover').$tip;
                                popover.unbind('click', stopPropagation);
                                popover.hide();
                            }

                            element.click(function() {
                                if(shown) {
                                    hide();
                                } else {
                                    show();
                                }
                            });
                        }

                        scope.$on("$destroy", function() {
                          element.popover('destroy');
                        });
                    });
                };
            }
        };
    });

    /**
     * Very similar to dkuHelpPopover, but the template is a Markdown string
     *   Usage :
     *
     *   <button class="btn btn-small" dku-md-popover="# Yeah\n* Markdown" title="popover title">
     *        <label>
     *            <span class="icon-question">&nbsp;</span>
     *                      Button text
     *        </label>
     *        <content title="Help me">
     *            <h2>Introduction</h2>
     *            <p>Blablabla</p>
     *        </content>
     *   </button>
     *
     */
    app.directive('dkuMdPopover',function(MarkedSettingService) {
        return {
            restrict : 'A',
            link : function($scope, element, attrs) {
                var shown = false;
                let destroyPopover;


                var hide = function() {
                    $("html").unbind("click", hide);
                    element.popover('hide');
                    shown=false;
                };

                var show = function() {
                    shown = true;
                    //capturing jquery destroy popover function for the current element, otherwise the method is not available anymore on $destroy of the directive (certainly because the elements got already removed from the DOM at that point)
                    destroyPopover = (element.data('popover')['destroy']).bind(element.data('popover'));

                    marked.setOptions(MarkedSettingService.get($scope, attrs));
                    var contentElt = marked(attrs.dkuMdPopover);
                    var ret = $("<div class=\"" + (attrs.popoverClazz||"") + "\"></div>");
                    ret.html(contentElt);
                    element.popover('show');
                    var popover = element.data('popover');
                    $(popover.$tip)
                        .find('.popover-content')
                        .empty().append(ret)
                        .off("click.dku-pop-over")
                        .on("click.dku-pop-over", function(e) {
                            e.stopPropagation();
                        });
                    element.popover('show');
                    window.setTimeout(function() { $("html").click(hide); }, 0);
                };
                var placement = element.data("placement") || "right";
                var options = {
                    html: true,
                    content: "",
                    placement: placement,
                    title: attrs.dkuMdTitle || "Help"
                };
                var container = element.data("container") || "body";
                if (container) {
                    options.container = container;
                }

                element.popover(options);
                element.click(function() {
                    if(shown) {
                        hide();
                    } else {
                        show();
                    }
                });

                $scope.$on('$destroy', function() {
                    if (typeof destroyPopover === "function") {
                        destroyPopover();
                    }
                });
            }
        };
    });

    /*
     * Usage :
     * bl br tl tr
     *
     *   <button class="btn btn-small" dku-inline-popup position="bl">
     *        <label>
     *            <span class="icon-question">&nbsp;</span>
     *                      Button text
     *        </label>
     *        <content title="Help me">
     *            <h2>Introduction</h2>
     *            <p>Blablabla</p>
     *        </content>
     *   </button>
     *
     * The popup content is created lazily. It is then only hidden. It is removed when
     * parent is destroyed
     */
    app.directive('dkuInlinePopup',function($timeout) {
        return {
            restrict : 'A',
            scope : true,
            transclude:true,
            template:'',
            compile:function(_element,_attrs,transclude) {
                return function(scope,element,attrs) {
                    transclude(scope.$new(), function(clone) {
                        var state = { popupElement : null};
                        var shown = false;
                        var buttonText = clone.filter('label').contents();
                        var popupContent = clone.filter('content').contents();
                        var addClazz = clone.filter('content').attr('class').split(/\s+/);


                        $timeout(function() {element.append(buttonText);});

                        var hide = function() {
                            if (state.popupElement) {
                                state.popupElement.hide();
                            }
                            $("html").unbind("click", hide);
                            shown=false;
                        };
                        var show = function() {
                            shown = true;
                            if (state.popupElement ==null) {
                                state.popupElement = $("<div class='dku-inline-popup' />");
                                $.each(addClazz, function(idx, val) { state.popupElement.addClass(val)});
                                state.popupElement.append(popupContent);
                                $("body").append(state.popupElement);
                            }
                            state.popupElement.css("overflow", "scroll");
                            state.popupElement.css("position", "absolute");
                            state.popupElement.css("left", element.offset().left);
                            var windowh = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
                            var etop = element.offset().top + element.outerHeight();
                            state.popupElement.css("top", etop);
                            state.popupElement.css("max-height", windowh - etop);

                            state.popupElement.off("click.dku-pop-over").on("click.dku-pop-over", function(e) {
                                e.stopPropagation();
                            });
                            window.setTimeout(function() { $("html").click(hide) }, 0);

                            state.popupElement.show()
                        };
                        scope.hide = function(){
                            hide();
                        }

                        element.click(function(){
                            if (shown) hide();
                            else show();
                        })
                        scope.$on("$destroy", function() {
                            hide();
                            if (state.popupElement) {
                                state.popupElement.remove();
                                state.popupElement = null;
                            }
                        });
                    });
                };
            }
        };
    });


    app.directive('editableSlider', function($parse, $compile) {
        return {
            restrict : 'A',
            link : function($scope, element, attrs) {
                var tpl = $compile('<div class="ngrs-value-runner">'
                    +'    <div class="ngrs-value ngrs-value-min" style="max-width: 70px;">'
                    +'      <input ng-show="sliderEditManual1" auto-focus="{{sliderEditManual1}}" step="0.1" ng-blur="sliderEditManual1=false;'+attrs.onHandleUp+'()" ng-type="number" next-on-enter blur-model="'+attrs.modelMin+'" ng-disabled="disableEditable" />'
                    +'      <div ng-hide="sliderEditManual1"><a ng-click="sliderEditManual1=true" style="color: inherit; overflow: hidden; text-overflow: ellipsis;" title="{{'+attrs.modelMin+'}}">{{'+attrs.modelMin+'}}</a></div>'
                    +' </div>'
                    +' <div class="ngrs-value ngrs-value-max" style="max-width: 70px;">'
                    +'    <input ng-show="sliderEditManual2" auto-focus="{{sliderEditManual2}}" step="0.1" ng-blur="sliderEditManual2=false;'+attrs.onHandleUp+'()" ng-type="number" next-on-enter blur-model="'+attrs.modelMax+'" ng-disabled="disableEditable" />'
                    +'    <div ng-hide="sliderEditManual2"><a ng-click="sliderEditManual2=true" style="color: inherit; overflow: hidden; text-overflow: ellipsis;" title="{{'+attrs.modelMax+'}}">{{'+attrs.modelMax+'}}</a></div>'
                    +'   </div>'
                    +'</div>');

                $scope.sliderEditManual1 = false;
                $scope.sliderEditManual2 = false;

                $scope.disableEditable = false;
                $scope.disableEditableAsString = attrs.disableEditableAsString;
                if ($scope.disableEditableAsString) {
                    $scope.disableEditable = $scope.$eval($scope.disableEditableAsString);
                    $scope.$watch($scope.disableEditableAsString, function(nv, ov) {
                        $scope.disableEditable = nv;
                    });
                }

                attrs.$set('showValues','false');
                element.append(tpl($scope));
            }
        }
    });

    app.directive('dkuHelpPopover', function($parse, $compile, $http, $timeout, $q, $templateCache) {
        return {
            restrict : 'A',
            scope:true,
            controller: function($scope){
                this.dismissPopover = function() {
                    $scope.dismissPopover();
                }
                this.togglePopover = function() {
                    $scope.togglePopover();
                }
            },
            link : function($scope, element, attrs) {

                // By default, a bootstrap popover is not displayed if it has no title and no content
                // We need to create such popover in some cases!
                function execInPatchedEnv(fn) {
                    var old = $.fn.popover.Constructor.prototype.hasContent;
                    $.fn.popover.Constructor.prototype.hasContent = function() {
                        return true;
                    };
                    try {
                        fn();
                    } finally {
                        $.fn.popover.Constructor.prototype.hasContent = old;
                    }
                }

                var shown = false;
                var getter = $parse(attrs.dkuHelpPopover);
                var templateUrl = getter($scope);

                var hide = function() {
                    $("html").unbind("click", blur);
                    element.popover('hide');
                    shown=false;
                };

                //selector for elements that do not create blur/hide event
                //(all children will block hide event)
                var noBlur = [];
                if (attrs.noBlur) {
                    noBlur = $scope.$eval(attrs.noBlur);
                }
                var blur = function(evt) {
                    var ignore = false;
                    $.each(noBlur, function(idx, selector) {
                        if($(evt.target).is(selector) || $(evt.target).parents(selector).length) {
                            ignore = true;
                        }
                    });
                    ignore || hide();
                }

                $scope.dismissPopover = function(){
                    hide();
                }

                var theTip;

                var show = function() {

                    shown = true;
                    $http.get(templateUrl, {cache: $templateCache}).then(function(response) {

                        var tmplData = $('<div/>').html(response.data).contents();
                        var tmpl = $compile(tmplData);
                        var popover = element.data('popover');
                        var html = tmpl($scope);
                        execInPatchedEnv(function() {
                            element.popover('show');
                            $(popover.$tip)
                                .find('.popover-content')
                                .html(html)
                                .off("click.dku-pop-over")
                                .off("click.dku-pop-over")
                                .off("click",".dropdown-menu")
                                .on("click.dku-pop-over", function(e) {
                                    e.stopPropagation();
                            });
                            theTip = popover.$tip;
                            element.popover('show');

                            if (attrs.noArrow) {
                                $(popover.$tip).find(".arrow").remove();
                                $(popover.$tip).css("top", $(popover.$tip).offset().top-20);
                            }
                            if (attrs.contentClazz) {
                                $(popover.$tip).find('.popover-content').addClass(attrs.contentClazz);
                            }
                            if (attrs.forceTopPositive) {
                                var currentTop = $(popover.$tip).css('top');
                                if (currentTop.charAt(0) === '-') {
                                    $(popover.$tip).css('top', '0px');
                                    // shift arrow accordingly
                                    $(popover.$tip).find('.arrow').css('transform', 'translateY(' + currentTop + ')');
                                }
                            }
                        });
                        window.setTimeout(function() { $("html").click(blur); }, 0);

                    });
                };

                var toggle = function() {
                    if (shown) {
                        hide();
                    }
                    else {
                        show();
                    }
                };

                $scope.togglePopover = function(){
                    return toggle();
                }

                $scope.showPopover = function(){
                    return show();
                }

                $scope.hidePopover = function(){
                    return hide();
                }

                var placement = element.data("placement") || "right";

                var options = {
                    html: true,
                    content: "",
                    placement: placement,
                    title: element.data("title")
                };
                var container = element.data("container");
                if (container) {
                    options.container = container;
                }
                element.popover(options);
                element.click(toggle);
                element[0].showPopover = function() {
                    if (!shown) {
                        show();
                    }
                };

                $scope.$on('$destroy', function() {
                       if(theTip && theTip.remove) {
                            theTip.remove();
                       }
                });

                element[0].hidePopover = function() {
                    if (shown) {
                        hide();
                    }
                };


            }
        };
    });




    app.directive('bzColorPicker', function() {
      var evtFakeDom = $("<div>");
      return {
        restrict: 'E',
        template: "<div class='bz-color-picker' ng-click='toggle($event)'>\
                <div class='iris' style='background-color: {{ color }}'></div>\
                <i class='icon-caret-down'></i>\
                <div class='bz-color-picker-palette'>\
                    <span ng-repeat='colorChoice in colorChoices'>\
                        <div class='color' ng-click='setColor(colorChoice)' style='background-color: {{ colorChoice }}'/>\
                    </span>\
                </div>\
            </div>",
        replace: true,
        scope: {
          color: "=ngModel"
        },
        link: function(scope, element, attrs) {
          var isShown = false;
          var paletteEl = element.find('.bz-color-picker-palette');

          var show = function() {
            if (isShown) return;
            evtFakeDom.trigger("hideAll");
            element.addClass("showPalette");
            isShown = true;
          }

          var hide = function() {
            if (!isShown) return;
            element.removeClass("showPalette");
            isShown = false;
          }

          scope.toggle = function($event) {
            $event.stopPropagation();
            if (isShown) {
              hide();
            }
            else {
              show();
            }
            return false;
          }

          evtFakeDom.on("hideAll", hide);
          $("body").click(function() {
            evtFakeDom.trigger("hideAll");
          })
          scope.$on("$destroy", function(nv, ov) {
            evtFakeDom.off("hideAll", hide);
          });

          scope.setColor = function(color) {
            scope.color = color;
          }

          scope.colorChoices = ["#f06548",
                                "#fdc766",
                                "#7bc9a6",
                                "#64bc93",
                                "#4ec5da",
                                "#548ecb",
                                "#97668f",
                                "#5e2974",
                                "#f6aacb",
                                "#d24773"];
        }
      }
    });

    app.directive('bzGauge', function() {
        return {
            restrict: 'E',
            template: "<div class='bz-gauge'><div class='mercury' style='width: {{ gaugeWidth }}%; background-color: {{ color }};'></div>",
            replace: true,
            scope: {
                color: "=color",
                val: "=val",
                total: "=total"
            },
            link: function(scope, element, attrs) {
                scope.gaugeWidth = (100.* scope.val / scope.total) | 0;
            }
        }
    })

    var debouncer = function(f, delay) {
      var delayer = null;
      return function() {
        if (delayer === null) {
          f();
          delayer = setTimeout(function() {
            delayer = null;
          }, delay)
        }
      }
    }

    app.directive('editableLabel', function() {
      return {
            restrict: 'E',
            template: "<div class='editable-label'><label>{{ val }}</label><input></input></div>",
            replace: true,
            scope: {
                val: '=ngModel',
            },
            link: function(scope, element, attrs) {
                var $label = element.find("label");
                var $input = element.find("input");

                var isEdit = false;

                var enterEdition = function() {
                  isEdit = true;
                  element.addClass("edit");
                  $input.focus();
                  $input.val(scope.val);
                }

                scope.validate = function(val) {
                  var trimmed = val.trim();
                  return (trimmed.length > 0);
                }

                var quitEdition = function() {
                  if (!isEdit) {
                    return;
                  }
                  var candidate = $input.val();
                  if (scope.validate(candidate)) {
                    scope.val = candidate.trim();
                    scope.$apply();
                    element.removeClass("edit");
                  }
                  isEdit = false;
                }

                var toggleEdition = function() {
                  if (isEdit) {
                    quitEdition();
                  }
                  else {
                    enterEdition();
                  }
                }

                toggleEdition = debouncer(toggleEdition, 400);
                $input.blur(toggleEdition);
                $input.change(toggleEdition);
                $label.click(toggleEdition);

            }
        }
    });


    app.directive('editableText', function() {
      return {
            restrict: 'E',
            template: "<div class='editable-text'><div>{{ message() }}</div><textarea></textarea></div>",
            replace: true,
            scope: {
                emptyMessage: '@emptyMessage',
                val: '=ngModel',
            },
            link: function(scope, element, attrs) {
                var $label = element.find("div");
                var $input = element.find("textarea");

                var isEdit = false;

                if (scope.val === undefined) {
                  scope.val = "";
                }
                scope.message = function() {
                  if (scope.val && (scope.val.trim().length > 0)) {
                    return scope.val;
                  }
                  else {
                    return scope.emptyMessage;
                  }
                }

                var enterEdition = function() {
                  isEdit = true;
                  element.addClass("edit");
                  $input.focus();
                  $input.val(scope.val);
                }

                scope.validate = function(val) {
                  var trimmed = val.trim();
                  return (trimmed.length > 0);
                }

                var quitEdition = function() {
                  if (!isEdit) {
                    return;
                  }
                  var candidate = $input.val();
                  if (scope.validate(candidate)) {
                    scope.val = candidate.trim();
                    scope.$apply();
                    element.removeClass("edit");
                  }
                  isEdit = false;
                }

                var toggleEdition = function() {
                  if (isEdit) {
                    quitEdition();
                  }
                  else {
                    enterEdition();
                  }
                }

                toggleEdition = debouncer(toggleEdition, 100);

                $input.blur(toggleEdition);
                $input.change(toggleEdition);
                element.click(toggleEdition);

            }
        }
    });

    app.directive('multiSelect', function(){
        return {
            require: 'ngModel',
            scope: true,
            link: function(scope, element, attrs, ngModel){
                scope.selectedItems = [];
                scope.allToggled = false;
                scope.someToggled = false;

                scope.toggleItem = function(item){
                    if (scope.selectedItems.indexOf(item) < 0) {
                        scope.selectedItems.push(item);
                    } else {
                        scope.selectedItems.splice(scope.selectedItems.indexOf(item), 1);
                    }
                    scope.allToggled = scope.selectedItems.length === ngModel.$viewValue.length;
                    scope.someToggled = scope.selectedItems.length > 0 && !scope.allToggled;

                    item.selected = !item.selected;
                };
                scope.toggleAll = function(){
                    var selected;
                    if(!scope.allToggled){
                        scope.selectedItems = angular.copy(ngModel.$viewValue);
                        selected = true;
                    } else {
                        scope.selectedItems = [];
                        selected = false;
                    }
                    scope.allToggled = scope.selectedItems.length === ngModel.$viewValue.length;
                    scope.someToggled = scope.selectedItems.length > 0 && !scope.allToggled;

                    angular.forEach(ngModel.$viewValue, function(item){
                        item.selected = selected;
                    });
                };
                scope.$on('clearMultiSelect', function(){
                    scope.selectedItems = [];
                    angular.forEach(ngModel.$viewValue, function(item){
                        item.selected = false;
                    });
                    scope.allToggled = false;
                    scope.someToggled = false;
                });
            }
        };
    });


    app.directive('modal', function($window, $timeout){
        // This directive ensure the proper height of the modals
        return {
            restrict: 'C',
            link: function(scope, element, attrs){
                if (attrs.autoSize == "false") return;

                var content = element.find('.modal-body');

                // body height
                content.css('height', 0); //to get the padding height
                var paddingHeight = content.innerHeight();
                content.css('height', '');


                function findOverflown(node){
                    if (node === undefined)
                        return [];
                    var overflownNodes = [];
                    for (var i = node.childNodes.length - 1; i >= 0; i--) {
                        var child = node.childNodes[i];
                        if (child.offsetHeight > 0){
                            var overflowCss = $(child).css('overflow');
                            var overflowYCss = $(child).css('overflow-y');
                            var scrollValues = ['auto', 'scroll'];
                            if (contains(scrollValues, overflowCss) || contains(scrollValues, overflowYCss)) {
                                // Special code mirror cases
                                if(!$(child).hasClass('CodeMirror-hscrollbar') && !$(child).hasClass('CodeMirror-vscrollbar')){
                                    overflownNodes.push(child);
                                }
                            } else {
                                overflownNodes = overflownNodes.concat(findOverflown(child));
                            }
                        }
                    }
                    return overflownNodes;
                }

                var sizeModal = function(){
                    // sometimes the modal-body is not instantiated at load, get it (again) here. If the
                    // modal-body was not there at modal creation time, then padding might be crappy
                    var content = element.find('.modal-body');
                    if (content.hasClass('modal-no-sizing')) return;

                    var oldMinHeight = content.css('minHeight');
                    content.css('height', '');
                    content.css('minHeight', '');
                    // find overflown elements
                    // We maximize the height of overflown content so they'll be the ones with the scrollbar
                    // var overflown = content.find('*').filter(function () {
//                         // select only the overflown content visible (positive height)
//                         return ['auto', 'scroll'].indexOf($(this).css('overflow')) >= 0 && this.offsetHeight > 0;
//                     });
//
                    var overflown = $(findOverflown(content[0]));

                    // remember current scroll position
                    var scrolls = overflown.map(function(){return this.scrollTop;});

                    overflown.css({'maxHeight': 'none', height: 0});
                    // height of non overflown content
                    var nonOverflownHeight = content.innerHeight();

                    overflown.height('');
                    var newHeight;
                    if (element.innerHeight() > $($window).height()) {
                        newHeight = $($window).height() - element.find('.modal-header').innerHeight() - element.find('.modal-footer').innerHeight() - paddingHeight - 10*2;
                    } else {
                        newHeight = content.innerHeight() - paddingHeight;
                    }
                    // preventing borders to be blurry : since modals are going to be centered on the screen, if the
                    // window height ends up being odd, then everything is going to be 1/2 pixel misaligned, and
                    // borders become all blurry messes... So we fix the modal-body height to be even. The rest of
                    // the window height is header+footer, so you have to set their size(s) to obtain a final even height.
                    if ( element.innerHeight() % 2 == 1 ) {
                        var maxHeight = parseInt(content.css('maxHeight'));
                        if ( newHeight + 1 > maxHeight) {
                            content.css('height', newHeight - 1);
                        } else {
                            content.css('height', newHeight + 1);
                        }
                    }

                    if(overflown.length){
                        // dispatch the remaining height between overflown content
                        var heightPerOverflown = (content.innerHeight() - nonOverflownHeight) / overflown.length;
                        if (heightPerOverflown > 0) {
                            overflown.height(heightPerOverflown);
                        }
                        // is the focused element within the modal ?
                        if(! $(document.activeElement).parents(element).length){
                            // focus overflow to allow scroll
                            overflown.attr('tabindex', 0).focus();
                        }
                        overflown.each(function(i){
                            // preserve former scroll
                            $(this).scrollTop(scrolls[i]);
                        });
                    }
                    content.css('minHeight', oldMinHeight);
                };

                // resize when window change
                $($window).on('resize.modal', sizeModal);
                // resize when something change (tab change, form expand...)
                scope.$watch(sizeModal, null);
                // init resize
                sizeModal();


                scope.$on('$destroy', function(){
                    $($window).off('resize.modal');
                });

                // focus first input
                element.find('input').first().focus();
            }
        };
    });

    app.directive('bsTypeahead', function($window){
        return {
            priority: 100,
            link: function(scope,element, attr){
                var typeahead = element.data('typeahead');

                // override show function
                typeahead.show = function () {
                    var pos = $.extend({}, this.$element.offset(), {
                        height: this.$element[0].offsetHeight
                    });

                    $(document.body).append(this.$menu);
                    this.$menu.addClass(attr.class);
                    this.$menu.css({
                        position: 'absolute',
                        top: pos.top + pos.height,
                        left: pos.left,
                        'z-index': 5000
                    }).show();

                    this.shown = true;
                    return this;
                };
            }
        };
    });

    //select diplaying columns of a provided schema together with their types
    app.directive('columnSelect', function($compile){
        return {
            restrict:'E',
            scope: {
                selectedColumn: '=ngModel',
                columns: '=',
                disableTypes: '='
            },
            template: '<select '+
                    ' dku-bs-select="{\'liveSearch\' : true}" '+
                    ' ng-model="uiState.selectedColumn"'+
                    ' class="qa_recipe_split-select-column"'+
                    ' ng-options="column.name as column.name for column in columns"'+
                    ' options-annotations="types" '+
                    ' />',
            link: {
                pre: function(scope, element, attrs) {
                    //compute types in prelink function so that it is available to optionsAnnotations
                    function computeTypes() {
                        scope.types = scope.disableTypes ? [] : scope.columns.map(function(column){ return column.type});
                    }
                    computeTypes();
                    scope.uiState = {selectedColumn: scope.selectedColumn};
                    scope.$watch("columns", computeTypes, true);
                    scope.$watch("uiState.selectedColumn", function(){
                        scope.selectedColumn = scope.uiState.selectedColumn;
                    });
                    scope.$watch("selectedColumn", function(){
                        scope.uiState.selectedColumn = scope.selectedColumn;
                    });
                }
            }
        };
    });

    //select diplaying columns of a provided schema together with their types with provided filter
    app.directive('columnSelectWithFilter', function($compile){
        return {
            restrict:'E',
            scope: {
                selectedColumn: '=ngModel',
                columns: '=',
                disableTypes: '=',
                filterFn: '='
            },
            template: '<select '+
                    ' dku-bs-select="{\'liveSearch\' : true}" '+
                    ' ng-model="uiState.selectedColumn"'+
                    ' class="qa_recipe_split-select-column"'+
                    ' ng-options="column.name as column.name for column in columns | filter: filterFn"'+
                    ' options-annotations="types" '+
                    ' />',
            link: {
                pre: function(scope, element, attrs) {
                    //compute types in prelink function so that it is available to optionsAnnotations
                    function computeTypes() {
                        scope.types = scope.disableTypes ? [] : scope.columns.filter(scope.filterFn).map(function(column){ return column.type});
                    }
                    computeTypes();
                    scope.uiState = {selectedColumn: scope.selectedColumn};
                    scope.$watch("columns", computeTypes, true);
                    scope.$watch("uiState.selectedColumn", function(){
                        scope.selectedColumn = scope.uiState.selectedColumn;
                    });
                    scope.$watch("selectedColumn", function(){
                        scope.uiState.selectedColumn = scope.selectedColumn;
                    });
                }
            }
        };
    });

    app.directive('mlColumnSelectWithType', function() {
        return {
            restrict: 'E',
            scope: {
                perFeature: "=",
                selectedColumn: "=ngModel",
                // authorizedTypes is optional. If not specified, all types are authorized. Otherwise,
                // must be an array of authorized types (e.g ["CATEGORY", "NUMERIC"])
                authorizedTypes: "=",
                // authorizedRoles is optional. If not specified, all roles are authorized. Otherwise,
                // must be an array of authorized roles (e.g ["INPUT", "REJECT"])
                authorizedRoles: "=",
                // alreadyComputedColumns is optional. If specified, must be a Set.
                alreadyComputedColumns: "=",
            },
            template: '<select ng-model="selectedColumn"' +
                      '        dku-bs-select="{\'liveSearch\':true}"' +
                      '        options-annotations="columnsAnnotations">' +
                      '    <option ng-repeat="c in columns"' +
                      '            value="{{c.name}}"' +
                      '            data-content="<div title={{c.name}} class=\'ml-col-select__item\'><div class=\'ml-col-select__icon-wrapper\'>{{c.icon}}</div> {{c.name}}</div>">' +
                      '            {{c.name}}' +
                      '    </option>' +
                      '</select>',
            link: function($scope, element, attrs) {
                function getIconFromType(type) {
                    switch(type) {
                        case "NUMERIC":
                            return "#";
                        case "CATEGORY":
                            return "<span class='icon icon-font'></span>"
                        case "TEXT":
                            return "<span class='icon-italic'></span>"
                        case "VECTOR":
                            return "<span style='font-size: 14px'>[ ]</span>"
                        default:
                            return "";
                    }
                }

                function setUpColumns() {
                    $scope.columns = Object.keys($scope.perFeature)
                        .filter(x => {
                            const isTypeAuthorized = !$scope.authorizedTypes || $scope.authorizedTypes.includes($scope.perFeature[x].type);
                            const isRoleAuthorized = !$scope.authorizedRoles || $scope.authorizedRoles.includes($scope.perFeature[x].role);
                            return isTypeAuthorized && isRoleAuthorized;
                            })
                        .sort()
                        .map(v => {
                            return {
                                name: v,
                                isComputed: ($scope.alreadyComputedColumns && $scope.alreadyComputedColumns.has(v)),
                                icon: getIconFromType($scope.perFeature[v].type)
                            }
                        });

                    $scope.columnsAnnotations = $scope.columns.map(v => v.isComputed ? 'already computed' : '');
                }

                $scope.$watch("perFeature", function(nv) {
                    if (nv !== undefined) {
                        setUpColumns();
                    }
                });

                $scope.$watch("alreadyComputedColumns", function(nv) {
                    if (nv !== undefined) {
                        setUpColumns();
                    }
                });

            }
        }
    });


    app.directive('mappingEditor',function(Debounce, $timeout) {
        return {
            restrict:'E',
            scope: {
                mapping: '=ngModel',
                onChange: '&',
                noChangeOnAdd: '<',
                addLabel: '@',
                validate: '=?',
                withColor: '=?',
                keepInvalid: '=?',
                required: '<',
                typeAhead: '='
            },
            templateUrl : '/templates/shaker/mappingeditor.html',
            compile: () => ({
                pre: function (scope, element, attrs) {
                    const textarea = element.find('textarea');
                    textarea.on('keydown', function (e) {
                        let keyCode = e.keyCode || e.which;
                        //tab key
                        if (keyCode === 9) {
                            e.preventDefault();
                            if (!scope.$$phase) scope.$apply(function () {
                                let tabPosition = textarea[0].selectionStart;
                                scope.bulkMapping = scope.bulkMapping.slice(0, tabPosition) + '\t' + scope.bulkMapping.slice(tabPosition);
                                $timeout(function () {
                                    textarea[0].selectionEnd = tabPosition + 1;
                                });
                            });
                        }
                    });
                    scope.changeMode = function () {
                        if (!scope.showBulk) {
                            scope.bulkMapping = scope.mapping.map(m => (m.from === undefined ? '' : m.from) + '\t' + (m.to === undefined ? '' : m.to)).join('\n');
                        }
                        scope.showBulk = !scope.showBulk;
                    };

                    scope.$watch('bulkMapping', Debounce().withDelay(400, 400).wrap(function (nv, ov) {
                            if (!angular.isUndefined(nv)) {
                                if (!nv.length) {
                                    scope.mapping = [];
                                } else {
                                    scope.mapping = nv.split('\n').map(l => {
                                        //regexp to split into no more than 2 parts (everything to the right of a tab is one piece)
                                        const parts = l.split(/\t(.*)/);
                                        return {from: parts[0], to: parts[1]};
                                    });
                                }
                            }
                        })
                    );
                    if (angular.isUndefined(scope.mapping)) {
                        scope.mapping = [];
                    }
                    if (!scope.addLabel) scope.addLabel = 'Add another';
                    if ('preAdd' in attrs) {
                        scope.preAdd = scope.$parent.$eval(attrs.preAdd);
                    } else {
                        scope.preAdd = Object.keys(scope.mapping).length === 0;
                    }
                    if (scope.onChange) {
                        scope.callback = scope.onChange.bind(scope, {mapping: scope.mapping});
                    }
                }
            })

        };
    });

    /**
     * Simple form form a sampling edition with partitions and no filters.
     * Supports changing dataset on the fly
     * Does not support auto refresh mechanism.
     */
    app.directive("samplingFormWithPartitions", function(DataikuAPI, $stateParams,
                DatasetInfoCache, DatasetUtils, Fn, SamplingData) {
        return {
            scope : {
                selection : '=',
                datasetSmartName : '=',
                backendType : '='
            },
            templateUrl : '/templates/widgets/sampling-form-with-partitions.html',
            link : function($scope) {
                $scope.SamplingData = SamplingData;
                $scope.getPartitionsList = function () {
                    return DataikuAPI.datasets.listPartitions($scope.dataset).error(setErrorInScope.bind($scope))
                        .then(function (ret) {
                            return ret.data;
                        });
                };

                $scope.$watch("datasetSmartName", function(nv, ov) {
                    if (nv) {
                        var loc = DatasetUtils.getLocFromSmart($stateParams.projectKey, $scope.datasetSmartName);
                        var promise = DatasetInfoCache.getSimple(loc.projectKey, loc.name)
                        promise.then(function(data){
                            $scope.dataset = data;
                            if ($scope.dataset.partitioning.dimensions.length == 0){
                                $scope.selection.partitionSelectionMethod = "ALL";
                            }
                            $scope.$broadcast("datasetChange")
                        });
                    }
                });
            }
        }
    });


    /**
     * Simple form for sampling edition with partitions and no filters.
     * Supports changing dataset on the fly
     * Does not support auto refresh mechanism.
     */
    app.directive("partitionedModelForm", function(DataikuAPI, $stateParams,
                                                         DatasetInfoCache, DatasetUtils) {
        return {
            scope : {
                partitionedModel : '=',
                splitPolicy: '=',
                datasetSmartName : '=',
                backendType : '='
            },
            templateUrl : '/templates/widgets/partitioned-model-form.html',
            link : function($scope) {
                $scope.getPartitionsList = function () {
                    return DataikuAPI.datasets.listPartitions($scope.dataset)
                        .error(setErrorInScope.bind($scope))
                        .then(resp => resp.data);
                };

                $scope.partitioningDisabledReason = function () {
                    if (!$scope.dataset) {
                        return "Loading…";
                    } else if ($scope.dataset.partitioning.dimensions.length == 0) {
                        return "input dataset is not partitioned";
                    } else if ($scope.splitPolicy != 'SPLIT_MAIN_DATASET') {
                        return "train/test split policy is not compatible";
                    }
                    return; // not disabled
                };

                $scope.dimensionsList = function() {
                    return $scope.dataset.partitioning.dimensions
                        .map(dim => `<b>${sanitize(dim.name)}</b>`)
                        .join(', ');
                };

                $scope.$watch("datasetSmartName", function(nv) {
                    if (nv) {
                        const loc = DatasetUtils.getLocFromSmart($stateParams.projectKey, $scope.datasetSmartName);
                        DatasetInfoCache.getSimple(loc.projectKey, loc.name).then(function(data){
                            $scope.dataset = data;
                            if ($scope.dataset.partitioning.dimensions.length === 0){
                                $scope.partitionedModel.ssdSelection.partitionSelectionMethod = "ALL";
                            }
                            $scope.$broadcast("datasetChange")
                        });
                    }
                });
            }
        }
    });


    /**
     * Simple form for a sampling edition with no partitions and no filters.
     * Supports changing dataset on the fly
     * Does not support auto refresh mechanism.
     */
    app.directive("samplingFormWithoutPartitions", function(DataikuAPI, $stateParams,
                DatasetInfoCache, DatasetUtils, SamplingData, Fn){
        return {
            scope : {
                selection : '=',
                backendType : '='
            },
            templateUrl : '/templates/widgets/sampling-form-without-partitions.html',
            link : function($scope) {
                $scope.SamplingData = SamplingData;
            }
        }
    });

    /**
     * Simple form for inserting ordering rules for export/sampling
     * which is a list of columns and order (asc or desc)
     */
    app.directive("orderingRulesForm", function() {
        return {
            scope: {
                rules: '='
            },
            templateUrl: '/templates/widgets/ordering-rules-form.html'
        };
    });

    app.directive("ngScopeElement", function () {
        var directiveDefinitionObject = {
            restrict: "A",
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink(scope, iElement, iAttrs, controller) {
                        scope[iAttrs.ngScopeElement] = iElement;
                    }
                };
            }
        };
        return directiveDefinitionObject;
    });


    app.directive('customElementPopup', function($timeout, $compile, $rootScope) {
        // Attrs:
        //   - cep-position = align-left-bottom, align-right-bottom, smart
        //   - cep-width = fit-main (adapt size of popover to size of mainzone)
    return {
        restrict: 'A',
        scope: true, // no isolated scope, we want our user to call us
        compile: function(element, attrs) {
            var closeOthers = attrs.closeOthers !== "false",  // opt-out
                closeOnClick = attrs.closeOnClick === "true", // opt-in
                allowModals = attrs.allowModals === "true", // don't close after modal is opened/closed
                popoverTemplate = element.find('.popover').detach(),
                dismissDeregister = null
            return function($scope, element, attrs) {
                var identifier = {}, popover = null,
                    position = attrs.cepPosition || "align-left-bottom",
                    hidePopoverButton = attrs.hidePopoverButton === "true",
                    startMainZone = $(".mainzone", element),
                    popoverShown = false,
                    onHideCallback = attrs.onHideCallback,
                    onShowCallback = attrs.onShowCallback;

                function isChildOfPopup(target) {
                    return $(target).closest(popover).length > 0;
                }

                function hideIfNoIdentifierOrNotMe(event, evtIdentifier) {
                    const isButtonClicked = $(event.target).closest(element).length > 0;
                    if (isButtonClicked || allowModals && $(event.target).closest('.modal-container, .modal-backdrop').length > 0) {
                        return;
                    }
                    const evtIdChange = (!evtIdentifier || identifier !== evtIdentifier);
                    if (evtIdChange && !isChildOfPopup(event.target) && !(evtIdentifier &&  isChildOfPopup(evtIdentifier))){
                        hide();
                    }
                }
                function hide() {
                    if (popover) {
                        popover.hide().detach();
                    }
                    $timeout(() => {popoverShown = false;});
                    $("html").unbind("click", hideIfNoIdentifierOrNotMe);
                    (startMainZone.length ? startMainZone : $(".mainzone", element)).removeClass('popover-shown');
                    if (onHideCallback && $scope.$eval(onHideCallback) instanceof Function) {
                        $scope.$eval(onHideCallback)();
                    }
                }
                function addPositionOffset(direction, value) {
                    try {
                        var res = value + parseInt(attrs['cepOffset' + direction]);
                        return isNaN(res) ? value : res;
                    } catch(e) {
                        return value;
                    }
                }
                function show() {
                    // clear other sub-popovers
                    $rootScope.$broadcast('dismissSubPopovers');
                    var mainZone = startMainZone.length ? startMainZone : $(".mainzone", element),
                        mzOff = mainZone.offset();
                    popoverShown = true;
                    if (popover === null) {
                        popover = $compile(popoverTemplate.get(0).cloneNode(true))($scope);
                        // here the template is compiled but not resolved
                        // => popover.innerWidth() etc. are incorrect until the next $digest
                    }
                    popover.css('visibility', 'hidden').appendTo("body");

                    window.setTimeout(function() {  // see above
                        switch (position) {
                        case 'align-left-bottom':
                            popover.css({
                                left: addPositionOffset('Left',mzOff.left),
                                top: addPositionOffset('Top',mzOff.top + mainZone.innerHeight())
                            });
                            break;
                        case 'align-right-bottom':
                            popover.css({
                                top: addPositionOffset('Top',mzOff.top + mainZone.innerHeight()),
                                left: addPositionOffset('Left', mzOff.left + mainZone.innerWidth() - popover.innerWidth())
                            });
                            break;
                        case 'smart':
                            var offset = { left: 'auto', right: 'auto', top: 'auto', bottom: 'auto' };
                            if (mzOff.left * 2 < window.innerWidth) {
                                offset.left = mzOff.left;
                            } else {
                                offset.right = window.innerWidth - mzOff.left - mainZone.innerWidth();
                            }
                            if (mzOff.top * 2 < window.innerHeight) {
                                offset.top = mzOff.top + mainZone.height();
                            } else {
                                offset.bottom = window.innerHeight - mzOff.top;
                            }
                            popover.css(offset);
                            break;
                        case 'align-left-top':
                            if (hidePopoverButton) {
                                popover.css({ left: mzOff.left, top: mzOff.top, bottom: 'auto' });
                            } else {
                                popover.css({ left: mzOff.left, bottom: window.innerHeight - mzOff.top, top: 'auto' });
                            }
                            break;
                        case 'align-right':
                            popover.css({ left: mzOff.left+mainZone.outerWidth(), top: mzOff.top, bottom: 'auto' });
                            break;
                        case 'align-right-top':
                            popover.css({ left: mzOff.left + mainZone.innerWidth() - popover.innerWidth(),
                                bottom: window.innerHeight - mzOff.top, top: 'auto' });
                            break;
                        }
                        if (attrs.cepWidth === 'fit-main') {
                            popover.css("width", mainZone.innerWidth());
                        }
                        popover.css('visibility', 'visible');
                    }, 0);

                    popover.show();
                    mainZone.addClass('popover-shown');
                    popover.add(".mainzone", element).off("click.dku-pop-over");
                    popover.on("click.dku-pop-over", function(e) {
                            if (closeOthers) {
                                $("html").triggerHandler('click.cePopup', identifier);
                            }
                        });
                    $(".mainzone", element).on("click.dku-pop-over", function(e) {
                        if (closeOthers) {
                            $("html").triggerHandler('click.cePopup', identifier);
                        }
                    });
                    if (closeOnClick) popover.on("click.dku-pop-over", hide);
                    window.setTimeout(function() {
                        $("html").on('click.cePopup', function (event, evtIdentifier) {
                            hideIfNoIdentifierOrNotMe(event, evtIdentifier);
                        });
                    }, 0);

                    if (dismissDeregister) {
                        dismissDeregister();
                    }
                    dismissDeregister = $rootScope.$on("dismissPopovers", function(){
                        if (!allowModals) {
                            hide();
                            if (dismissDeregister) {
                                dismissDeregister();
                                dismissDeregister = null;
                            }
                        }
                    });

                    if (onShowCallback && $scope.$eval(onShowCallback) instanceof Function) {
                        $scope.$eval(onShowCallback)();
                    }
                }

                $scope.showPopover = show;
                $scope.hidePopover = hide;
                $scope.popoverShown = function() { return popoverShown; };
                $scope.togglePopover = function(event) {
                    if (popoverShown) {
                        hide();
                    }
                    else {
                        if (event) $("html").triggerHandler('click.cePopup', identifier);
                        show();
                    }
                };
            };
        } };
    });

    app.directive("sidebarTabL1Link", function($filter, $timeout){
        return {
            template: '<li class="l1" tab-active="{{tabName}}" full-click><a main-click tab-set="{{tabName}}">{{label}}</a></li>',
            replace: true,

            priority: 100,
            scope : {
                tabName : "@",
                label : "@"
            }
        }
    });
    app.directive("sidebarTabL2Link", function($compile){
        return {
            replace: true,

            priority: 100,
            scope : {
                tabName : "@",
                label : "@",
                disabledLink: "@",
                disableMessage: "@",
                sidekickPulsar: "="
            },
            link : function(scope, element, attrs) {
                scope.$watch(() => attrs.disableLink, () => {
                    let template;
                    if (scope.$eval(attrs.disableLink)) {
                        template = `<li toggle="tooltip" container="body" title="{{disableMessage}}" style="opacity: 0.5">
                        <div class="l2">{{label}}</div>
                    </li>`;
                    } else {
                        template = '<li class="l2" tab-active="{{tabName}}" full-click><div class="padded"><a main-click tab-set="{{tabName}}">{{label}}<span class="mleft8 sidekick-pulsar" ng-if="sidekickPulsar"></a></span></a></div></li>';
                    }
                    element.html(template);
                    $compile(element.contents())(scope);
                });
            }
        }
    });
    app.directive("topLevelTabState", function($filter, $timeout, $rootScope){
        return {
            template: '<a class="tab" ng-class="{\'enabled\' : topNav.tab == tabName}" ui-sref="{{sref}}">{{label}}</a>',
            replace: true,
            scope : {
                tabName : "@",
                sref : "@",
                label: '@'
            },
            link : function($scope) {
                $scope.topNav = $rootScope.topNav;
            }
        }
    });

    var getHeaderHideClass = function(makeSeeThrough) {
        return makeSeeThrough ? 'see-through' : 'non-see-through';
    }

    app.directive("dkuModalHeaderHideBtn", function($filter, $timeout) {
        return {
            template : '<button type="button" class="close see-through"  aria-hidden="true" ng-mouseenter="setSeeThrough(true)" ng-mouseleave="setSeeThrough(false)" >&minus;</button>',
            scope : { modalTitle : "@", modalTotem : "@" },
            replace : true,
            link: function(scope, element) {
                scope.isSeeThrough=false;

                scope.setSeeThrough = function (on) {
                    scope.isSeeThrough = on;
                    var divs = $('div.modal-container, div.modal-backdrop, div.popover');
                    var toAdd = getHeaderHideClass(scope.isSeeThrough);
                    var toRemove = getHeaderHideClass(!scope.isSeeThrough);
                    divs.addClass(toAdd).removeClass(toRemove + " restored");
                }
            }
        }
    });

    app.directive("dkuModalHeader", function($filter, $timeout) {
        return {
            template : '<div class="modal-header no-totem {{modalClass}}"  ng-class="{\'has-tabs\': hasTabs()}">'+
            '  <button type="button" class="close" data-dismiss="{{modalClose && modalClose() ? \'\' : \'modal\'}}" ng-click="close()" aria-hidden="true">&times;</button>'+
            '  <dku-modal-header-hide-btn></dku-modal-header-hide-btn>'+
            '  <div ng-if="hasMenu()" ng-transclude="menu"></div>' +
            '  <h4 ng-transclude="title">{{modalTitle}}</h4>' +
            '  <ul ng-if="hasTabs()" class="modal-tabs" ng-transclude="tabs"></ul>'+
            '</div>',
            scope : { modalTitle: "@", modalClass: "@", modalTabs: "@", modalClose: "&"},
            replace : true,
            transclude: {
                'title': '?dkuModalTitle',
                'tabs': '?dkuModalTabs',
                'menu': '?dkuModalMenu'
            },
            link: function (scope, element, $attrs, $thisCtrl, $transclude) {
                scope.close = function () {
                    if (scope.modalClose && scope.modalClose() instanceof Function) return scope.modalClose()();
                    return false;
                };
                scope.has = function (section) {return $transclude.isSlotFilled(section);}
                scope.hasTabs = function() {return scope.has("tabs")}
                scope.hasMenu = function() {return scope.has("menu")}
            }
        }
    });

    app.directive("dkuModalHeaderWithTotem", function($filter, $timeout) {
        return {
            template : '<div class="modal-header has-border {{modalClass}}" ng-class="{\'has-tabs\': hasTabs()}" >'+
                       '  <div class="modal-totem"> <i class="{{modalTotem}}" /></div>'+
                       '  <button type="button" class="close" data-dismiss="{{modalClose && modalClose() ? \'\' : \'modal\'}}" ng-click="close()" aria-hidden="true">&times;</button>' +
                       '  <dku-modal-header-hide-btn></dku-modal-header-hide-btn>'+
                       '  <h4 ng-transclude="title">{{modalTitle}}</h4>' +
                       '  <ul ng-if="hasTabs()" class="modal-tabs" ng-transclude="tabs"></ul>'+
                       '</div>',
            scope : { modalTitle : "@", modalTotem : "@", modalClass: "@", modalTabs: "@", modalClose: "&" },
            replace : true,
            transclude: {
                'title': '?dkuModalTitle',
                'tabs': '?dkuModalTabs'
            },
            link: function (scope, element, $attrs, $thisCtrl, $transclude) {
                scope.close = function () {
                    if (scope.modalClose && scope.modalClose() instanceof Function) return scope.modalClose()();
                    return false;
                }
                scope.hasTabs = function () {return $transclude.isSlotFilled('tabs');}
            }

        }
    });

    app.directive("dkuModalHeaderMinimum", function($filter, $timeout) {
        return {
            template : '<div class="modal-header no-totem {{modalClass}}">' +
            '  <h4 ng-transclude="title">{{modalTitle}}</h4>' +
            '</div>',
            scope : { modalTitle: "@", modalClass: "@"},
            replace : true,
            transclude: {
                'title': '?dkuModalTitle'
            }
        }
    });



    app.directive('dkuEnter', function() {
        return function(scope, element, attrs) {
            element.bind("keydown keypress", function(event) {
                if(event.which === 13) {
                        scope.$apply(function(){
                                scope.$eval(attrs.dkuEnter, {$event: event});
                        });
                        event.preventDefault();
                }
            });
        };
    });


    app.directive('cancelOnEscape', function() {
        return function(scope, element, attrs) {
            var val = element.val();

            element.bind("focus", function(event) {
                val = element.val();
            });

            element.bind("keydown keypress", function(event) {
                if(event.which === 27) {
                    element.val(val);
                    element.blur();
                    event.preventDefault();
                }
            });
        };
    });

    app.directive('svgTitles', function($sanitize) {
        function go(tooltip, stack, evt) {
            if (stack.length) {
                if (evt) {
                    var pos = {};
                    if (evt.clientX * 2 > window.innerWidth ) {
                        pos.right = (window.innerWidth - evt.clientX) + 'px';
                        pos.left  = 'auto';
                    } else {
                        pos.left  = evt.clientX + 'px';
                        pos.right = 'auto';
                    }
                    if (evt.clientY * 2 > window.innerHeight) {
                        pos.bottom = (window.innerHeight - evt.clientY) + 'px';
                        pos.top    = 'auto';
                    } else {
                        pos.top    = evt.clientY + 'px';
                        pos.bottom = 'auto';
                    }
                    tooltip.style(pos);
                }
                tooltip.html($sanitize(stack[stack.length - 1].getAttribute('data-title')));
                tooltip.style({display: 'block'});
            } else {
                tooltip.style({display: 'none', left: '0', top: '0'});
            }
        }
        return { restrict: 'A', scope: false, controller: function($element) {
            var _elt = $element.get(0),
                elt = _elt.tagName.toLowerCase() === 'svg' ? _elt : _elt.querySelector('svg'),
                svg = d3.select(elt),
                stack = [],
                tooltip = d3.select(document.body.insertBefore(document.createElement('div'), null))
                            .attr('class', 'svg-title-tooltip');
            return {
                update: function() {
                    svg.selectAll('[data-title]')
                    .on('mouseover.svgTitle', function mouseover() {
                        var i = stack.indexOf(this);
                        if (stack.length === 0 || i + 1 !== stack.length) {
                            if (i !== -1) { stack.splice(i, 1); }
                            stack.push(this);
                        }
                        go(tooltip, stack, d3.event);
                    }).on('mouseout.svgTitle', function mouseout() {
                        var i = stack.indexOf(this);
                        if (i !== -1) { stack.splice(i, 1); }
                        go(tooltip, stack, d3.event);
                    });
                },
                delete: function() {
                    tooltip.remove();
                }
            };
        }, link: function(scope, element, attrs, ctrl) {
            ctrl.update();
            scope.$on('$destroy', ctrl.delete);
        } };
    });

    app.directive('dkuBetterTooltip', function($timeout, $compile, $rootScope, $sanitize) {
        // Attrs:
        //   - dbt-placement = "top" / "bottom"
        //   - dbt-title
        var ret = {
            restrict : 'A',
        };
        ret.link = function(scope, element, attrs) {
            var tooltip = null;
            function show(){
                tooltip = $("<div />");
                tooltip.html($sanitize(attrs.dbtTitle));
                tooltip.addClass("dbt-tooltip");
                tooltip.css("pointer-events", "none");
                if (attrs.dbtClazz) {
                    tooltip.addClass(attrs.dbtClazz);
                }
                $("body").append(tooltip); //so we have access to dimensions

                var posLeft = 0;
                var posTop = 0;
                var left = $(element).offset().left;
                var top = $(element).offset().top;
                var placement = attrs.dbtPlacement;
                var appendToBody = attrs.appendToThis == undefined ? true: attrs.appendToBody;
                var rect = $(element).get(0).getBoundingClientRect();
                if (placement == "top") {
                    posLeft = left + rect.width / 2 - tooltip.width()/2;
                    posTop = top - tooltip.height() - 10;
                } else if(placement == "top-right"){
                    posLeft = left + rect.width;
                    posTop = top - tooltip.height() - 10;
                } else if(placement == "top-left"){
                    posLeft = left - tooltip.width() - 10;
                    posTop = top - tooltip.height() - 10;
                } else if(placement == "bottom-left"){
                    posLeft = left - tooltip.width() - 10;
                    posTop = top + rect.height;
                } else if(placement == "bottom-right"){
                    posLeft = left + rect.width;
                    posTop = top + rect.height;
                } else if(placement == "bottom"){
                    posLeft = left + rect.width / 2 - tooltip.width()/2;
                    posTop = top + rect.height;
                } else if(placement == "left"){
                    posLeft = left - tooltip.width() - 10;
                    posTop = top + rect.height / 2 - tooltip.height()/2;
                } else if(placement == "right"){
                    posLeft = left + rect.width;
                    posTop = top + rect.height / 2 - tooltip.height()/2;
                }
                tooltip.css("left", posLeft);
                tooltip.css("top", posTop);
                $("body").append(tooltip);
            }
            function hide(){
                tooltip.remove();
            }
            element.on("mouseover.dbt", show);
            element.on("mouseout.dbt", hide);
        };
        return ret;
    });

    app.directive('svgTooltip', function($timeout, $compile, $rootScope, $sanitize) {

        return {
            scope: false,
            restrict: 'A',
            link: function($scope, element, attrs) {

                var $container = $(attrs.container || 'body').filter(':visible');
                var $tooltip = $('<div class="svg-tooltip ' + (attrs.tooltipClass || '') + '"></div>').appendTo($container);

                $scope.setTooltipContent = function(content) {
                    $tooltip.html($sanitize(content));
                };

                $scope.hideTooltip = function() {
                    $tooltip.css("opacity", 0);
                };

                $scope.showTooltip = function(x, y) {
                    let containerOffset = $container.offset();
                    let elOffset = $(element).offset();
                    $tooltip.css("top", (y + elOffset.top - containerOffset.top + 5) + "px");
                    $tooltip.css("left", (x + elOffset.left - containerOffset.left +  5) + "px");
                    $tooltip.css("opacity", 1);
                };

                $scope.$on("$destroy", function() {
                   $tooltip.remove();
                });
            }
        };
    });


    /**
     * In the new dataset page, each dataset name is a link / pseudo-link to create the dataset.
     * This directive creates the link and handles how if should be shown (according to licence, uiCustomisation)
     * A few links should avoid the licence check. they should have a null type
     */
    app.directive('datasetType', function($rootScope, $state, GlobalProjectActions, $stateParams){
        return {
            restrict : 'A',
            replace : true,
            scope : {
                type : "<",
            },
            template: `<li ng-class="{'dataset-disabled': type.status == 'NOT_LICENSED_EE' || type.status == 'NO_CONNECTION', 'dataset-notlicensed-ce' : type.status == 'NOT_LICENSED_CE'}">
                <a ng-if="type.status == 'NOT_LICENSED_CE'" ng-click="showCERestrictionModal(type.label + ' dataset')">{{type.label}}</a>
                <a ng-if="type.status == 'NOT_LICENSED_EE'" toggle="tooltip" title="This dataset is not authorized by your license">{{type.label}}</a>
                <a ng-if="type.status == 'NO_CONNECTION'" toggle="tooltip" title="{{noConnectionTooltip}}">{{type.label}}</a>
                <a ng-if="type.status == 'SHOW' && type.clickCallback" ng-click="type.clickCallback()">{{type.label}}</a>
                <a ng-if="type.status == 'SHOW' && !type.clickCallback" ui-sref="projects.project.datasets.new_with_type.settings({type:type.type, zoneId:$stateParams.zoneId})">{{type.label}}</a>
            </li>`,
            link : function(scope) {
                scope.appConfig = $rootScope.appConfig;
                scope.showCERestrictionModal = $rootScope.showCERestrictionModal;
                scope.$state = $state;
                scope.$stateParams = $stateParams;
                scope.noConnectionTooltip = scope.type.disabledReason || `This dataset requires a connection that is not available. It may be because no such connection has been created by your administrator or because you don't have sufficient authorization`;
            }
        }
    });

    /**
     * This directive watches the width of the new dataset page, and automatically updates the width of a centered container so that the tiles are always centered and aligned.
     * I used this method because there is no way through css alone to guarantee that the tiles will flow correctly, that the plugin block will be aligned with the main block, and that the top-right links are aligned with the tiles.
     */
    app.directive('newDatasetPageAlignmentManager', function() { // new-dataset-page-alignment-manager
        return {
            restrict: 'A',
            link: function($scope, $element) {
                const tileWidth = 300;
                const resizeObserver = new ResizeObserver((el) => {
                    const elementWidth = el[0].contentRect.width;
                    $element.find('.new-dataset-page__centered-container').css('width', tileWidth * Math.floor(elementWidth / tileWidth));
                });

                resizeObserver.observe($element[0]);
                $scope.$on('$destroy', () => {
                    resizeObserver.disconnect();
                })
            }
        }
    })

    app.filter("singleChecklistState", function(){
        return function(input) {
            var total = 0, done = 0;
            input.items.forEach(function(x) {
                total++;
                if (x.done) done++;
            });
            if (total == 0) return "";
            return "<span>(" + done + "/" + total + " done)</span>";
        }
    });
    /** Emits "checklistEdited" on any change */
    app.directive('objectChecklist', function($rootScope, $state){
        return {
            restrict : 'A',
            scope : {
                "checklist" : "=",
                "itemsOnly" : "=",
                "readOnly" : "="
            },
            templateUrl: "/templates/widgets/checklist.html",
            link : function($scope, element, attrs) {
                $scope.state = {
                    addingItem : false,
                    editingItem : null, // The item being edited
                    editingItemText : null // The new text of the item being edited
                };

                $scope.onItemStateChange = function(){
                    $scope.$emit("checklistEdited", "item-state-change");
                };

                $scope.enterEditItem = function(item, $event){
                    if ($event.target.tagName.toLowerCase() == "a") {
                            return;
                    }
                    // Cancel the other one first
                    if ($scope.state.editingItem) {
                        $scope.cancelEditItem();
                    }

                    item.editingText = true;
                    $scope.state.editingItem = item;
                    $scope.state.editingItemText = item.text;

                    window.setTimeout(function() {
                        $(".checklist-items .edit-zone", element).on("click.checklistEditItem", function(e) {
                            e.stopPropagation();
                        });
                        $("html").on("click.checklistEditItem", function(event){
                            if ($(event.target).hasClass('modal-backdrop') || $(event.target.parentNode).hasClass('modal-header') || $(event.target.parentNode).hasClass('modal-footer')) {
                                return;
                            }
                            $scope.$apply(function(){$scope.cancelEditItem()});
                        })
                    }, 0);
                };

                $scope.validateEditItem = function(){
                    $scope.state.editingItem.text = $scope.state.editingItemText;
                    $scope.cancelEditItem();
                    $scope.$emit("checklistEdited", "validate-edit");
                };

                $scope.cancelEditItem = function(){
                    if ($('.codemirror-editor-modal').is(':visible')) {
                        return;
                    }
                    $scope.state.editingItem.editingText = false;
                    $scope.state.editingItem = null;
                    $scope.state.editingItemText = null;
                    $(".checklist-items .edit-zone", element).off("click.checklistEditItem");
                    $("html").off("click.checklistEditItem");
                };

                $scope.deleteItem = function(item) {
                    $scope.checklist.items.splice($scope.checklist.items.indexOf(item), 1);
                    $scope.$emit("checklistEdited", "delete");
                };

                $scope.enterAddItem = function() {
                    $scope.state.addingItem = true;
                    $scope.state.newItemText = "";
                    window.setTimeout(function() {
                        $(".new-item-zone", element).on("click.checklistAddNewItem", function(e) {
                                e.stopPropagation();
                        });

                        $("html").on("click.checklistAddNewItem", function(event){
                            if ($(event.target).hasClass('modal-backdrop') || $(event.target.parentNode).hasClass('modal-header') || $(event.target.parentNode).hasClass('modal-footer')) {
                                return;
                            }
                            $scope.$apply(function(){$scope.leaveAddItem()});
                        })
                    }, 0);
                };

                $scope.leaveAddItem = function(){
                    if ($('.codemirror-editor-modal').is(':visible')) {
                        return;
                    }
                    $scope.state.addingItem = false;
                    $(".new-item-zone", element).off("click.checklistAddNewItem");
                    $("html").off("click.checklistAddNewItem");
                };

                $scope.addNewItem = function() {
                    if ($scope.state.newItemText.length == 0) return;

                    $scope.checklist.items.push({
                        text : $scope.state.newItemText,
                        createdOn : new Date().getTime(),
                        createdBy : $rootScope.appConfig.login
                    });
                    $scope.$emit("checklistEdited", "add");
                    $scope.state.newItemText = "";
                };

                $scope.$watch("checklist", function(nv){
                    if (nv && nv.$newlyCreated) {
                        $scope.enterAddItem();
                        nv.$newlyCreated = false;
                    }
                });

                $scope.$on("$destroy", function(){
                    // noop
                })

            }
        }
    });


app.directive("sparkOverrideConfig", function($rootScope){
    return { // task = holder of sparkPreparedDFStorageLevel, MLTask or MLLib recipe desc
        scope : { config: '=', task: '=', taskType: '@' },
        templateUrl : '/templates/widgets/spark-override-config.html',
        link : function($scope, elem, attrs) {
            $scope.rootAppConfig = $rootScope.appConfig;
            /* Initialize with first Spark conf */
            $scope.$watch("config", function(nv, ov) {
                if (nv && nv.inheritConf == null) {
                    if ($rootScope.appConfig.sparkExecutionConfigs.length) {
                        nv.inheritConf = $rootScope.appConfig.sparkExecutionConfigs[0];
                    }
                }
            });
        }
    }
})

app.directive("dkuSlider", function($window, $timeout){
    return {
        scope : {
            min : '=',
            max : '=',
            value : '=',
            nbDecimalPlaces : '=?',
            onChange: '&?'
        },
        link: function($scope, elem, attrs) {

            $scope.sliding = false;

            $scope.startSliding = function($event) {
                $scope.computeNewCursorPosition($event);
                $scope.sliding = true;
                $($window).on('mouseup', $scope.stopSliding);
                $($window).on('mousemove', $scope.slideCursor);
            }

            $scope.slideCursor = function($event) {
                $event.preventDefault(); //useful to avoid selecting content on vertical mouse move while sliding
                if ($scope.sliding) {
                    $scope.computeNewCursorPosition($event);
                }
            }

            $scope.stopSliding = function() {
                $scope.sliding = false;
                $($window).off('mouseup', $scope.stopSliding);
                $($window).off('mousemove', $scope.slideCursor);
                $scope.value = $scope.cursorValue;
                if ($scope.onChange) {
                    $scope.onChange();
                }
                $timeout(function(){$scope.value = $scope.cursorValue;});
            }


            $scope.computeNewCursorPosition = function($event) {
                var sliderWidth = $(elem).width() - $(elem).find('.cursor').width() - 1;
                var sliderXPosition = $(elem).offset().left;
                var xPosition = $event.pageX - sliderXPosition;
                if (xPosition < 0) {
                    xPosition = 0;
                }
                if (xPosition > sliderWidth) {
                    xPosition = sliderWidth;
                }
                $(elem).find('.cursor').css('left',xPosition + 'px');
                $scope.computeNewScopeValue(xPosition, sliderWidth);
                $scope.fixExtremityVisibility();
            }

            $scope.roundAccordingToNbDecimalPlaces = function(num) {
                if (typeof($scope.nbDecimalPlaces)==='undefined') {
                    $scope.nbDecimalPlaces = 0;
                }
                return Number(Math.round(num + "e+"+$scope.nbDecimalPlaces) + "e-"+$scope.nbDecimalPlaces);
            }

            $scope.computeNewScopeValue = function(xPosition, sliderWidth) {
                var range = $scope.max - $scope.min;
                $scope.cursorValue = $scope.roundAccordingToNbDecimalPlaces(range*xPosition/sliderWidth + $scope.min);
                $(elem).find('.cursor-value').html($scope.cursorValue);
            }

            $scope.initCursorPosition = function() {
                if (typeof($scope.value)==='undefined') {
                    $scope.value = $scope.roundAccordingToNbDecimalPlaces(($scope.max - $scope.min)/2 + $scope.min);
                }
                $scope.cursorValue = $scope.value;
                var range = $scope.max - $scope.min;
                var xPosition = ($scope.value - $scope.min)*100/range;
                $(elem).find(".cursor").css("left", "auto");
                $(elem).find(".cursor").css("right", "auto");
                if (xPosition<50) {
                    $(elem).find('.cursor').css('left',xPosition + '%');
                } else {
                    $(elem).find('.cursor').css('right',100-xPosition + '%');
                }
                if (xPosition>90) {
                    $(elem).find('.range-max').css('opacity',0);
                }
                if (xPosition<10) {
                    $(elem).find('.range-min').css('opacity',0);
                }
            }

            $timeout(function() {
                $scope.initCursorPosition();
            });

            $scope.$watch("value", function(nv, ov) {
                if (!nv || !ov) return;
                $scope.initCursorPosition();
            });

            $scope.fixExtremityVisibility = function() {
                var cursorValueLeft = $(elem).find('.cursor-value').offset().left;
                var cursorValueRight = $(elem).find('.cursor-value').offset().left + $(elem).find('.cursor-value').width();
                var rangeMinRight = $(elem).find('.range-min').offset().left + $(elem).find('.range-min').width();
                var rangeMaxLeft = $(elem).find('.range-max').offset().left;
                var confortableGap = 5;
                if (rangeMinRight + confortableGap > cursorValueLeft) {
                    $(elem).find('.range-min').stop(true, false).fadeTo(40, 0);
                } else {
                    $(elem).find('.range-min').stop(true, false).fadeTo(40, 1);
                }
                if (rangeMaxLeft - confortableGap < cursorValueRight) {
                    $(elem).find('.range-max').stop(true, false).fadeTo(40, 0);
                } else {
                    $(elem).find('.range-max').stop(true, false).fadeTo(40, 1);
                }
            }

        },
        templateUrl : '/templates/widgets/dku-slider.html'
    }
});


app.directive("dkuArrowSlider",['$timeout', function($timeout) {
    return {
        restrict: "A",

        link: function(scope, elem, attrs) {

          /*
           * Inner variables
           */

            let frameSelector = attrs.frameSelector;
            let sliderSelector = attrs.sliderSelector;
            let slidingElementsSelector = sliderSelector + ' > *:visible';

            let minOffsetLeft = 0;
            let maxOffsetRight = 0;

            let modelListName = attrs.modelListName;

            scope.canSlideRightFlag = false;
            scope.canSlideLeftFlag = false;

          /*
           * Watchers / init
           */

            scope.$watch(modelListName, function(nv, ov) {
                let nvLength = nv ? nv.length : 0;
                let ovLength = ov ? ov.length : 0;
                //$timeout is needed to make sure slideToEnd is called after the currently processing $digest is done,
                //ie once the ng-repeat refresh is done and the new chip has been added
                $timeout(function() {
                    scope.computeNeedSlider();
                    if (scope.needSlider()) {
                        scope.initArrowSlider();
                    }
                    //$timeout to make sure arrow slider initialization is done (otherwise positioning computations may be off)
                    $timeout(function() {
                        if (nvLength < ovLength) {
                            if (!scope.needSlider()) {
                                slideToBegining();
                                removeArrowSliderStyle();
                            } else if (!isLastChipBeyondSliderBottom()) {
                                slideToEnd();
                            }
                        } else if (nvLength > ovLength) {
                            if (scope.needSlider()) {
                                slideToEnd();
                            } else {
                                scope.$broadcast('DKU_ARROW_SLIDER:animation_over');
                            }
                        }
                    }, 0);
                }, 0, false);
            }, true);

            scope.onResize = function() {
                scope.computeNeedSlider();
                if (!scope.needSlider()) {
                    slideToBegining();
                } else {
                    initOffsetsExtremas();
                    if (!isLastChipBeyondSliderBottom()) {
                        slideToEnd();
                    }
                    setCanSlideTags(scope.canSlideLeft(), scope.canSlideRight());
                }
                $timeout(function() {
                    scope.$apply();
                });
            }

            let loop;
            function resizeHandler() {
                clearTimeout(loop);
                loop = setTimeout(scope.onResize, 30);   //so that resize callback is called only once resize is done for good
            }

            $(window).on("resize.dkuArrowSlider", resizeHandler);
            scope.$on("$destroy", function(){
                $(window).off("resize.dkuArrowSlider", resizeHandler);
            });

            scope.$on("slideToId", function(event, frameSelectorAttr, sliderSelectorAttr, targetId) {
                if (frameSelector == frameSelectorAttr && sliderSelector == sliderSelectorAttr) {
                    slideToId(targetId);
                }
            });

            scope.initArrowSlider = function () {
                if (scope.needSlider()) {
                    $(frameSelector).css('position', 'relative');
                    $(sliderSelector).css('position', 'absolute');
                    $(sliderSelector).css('will-change', 'left');
                    $(sliderSelector).css('transition', 'left 150ms ease-out, right 150ms ease-out');
                    if (isNaN($(sliderSelector).css('left').replace('px', ''))) {
                        $(sliderSelector).css('left', '0px');
                        setCanSlideTags(false, true);
                    }
                    initOffsetsExtremas();
                    $timeout(function() {
                        scope.$broadcast("DKU_ARROW_SLIDER:arrow_slider_initialized");
                    });
                }
            };

           function removeArrowSliderStyle() {
                $(frameSelector).removeAttr("style");
                $(sliderSelector).removeAttr("style");
            }

            function initOffsetsExtremas() {
                minOffsetLeft = $(frameSelector).offset().left;
                maxOffsetRight = minOffsetLeft + $(frameSelector).width();
            }

            /*
            * Animation functions
            */

            scope.slideLeft = function() {
                let lastHiddenElement;
                let slidingElement = $(slidingElementsSelector);
                if (!slidingElement) return;
                for (let i = 0; i < slidingElement.length; i++) {
                    let elem = slidingElement[i];
                    if (!isElementVisible(elem)) {
                        lastHiddenElement = elem;
                    } else {
                        //if the element we wanna display is not the last one, make sure user can see there is more to come
                        if (i-1 > 0) {
                            let newSlidingElementLeft = getLeftAsNumber(sliderSelector) + getHiddenWidth(lastHiddenElement) + 20;
                            animatedSlide(newSlidingElementLeft);
                            setCanSlideTags(true, true);
                        } else {
                            slideToBegining();
                        }
                        break;
                    }
                }
            };

            scope.slideRight = function() {
                let lastHiddenElement;
                let slidingElement = $(slidingElementsSelector);
                if (!slidingElement) return;
                for (let i = slidingElement.length - 1; i >= 0; i--) {
                    let elem = slidingElement[i];
                    if (!isElementVisible(elem)) {
                        lastHiddenElement = elem;
                    } else {
                        //if the element we wanna display is not the last one, make sure user can see there is more to come
                        if (i + 1 < slidingElement.length - 1) {
                            let newSlidingElementLeft = getLeftAsNumber(sliderSelector) - getHiddenWidth(lastHiddenElement) - 20;
                            animatedSlide(newSlidingElementLeft);
                            setCanSlideTags(true, true);
                        } else {
                            slideToEnd();
                        }
                        break;
                    }
                }
            };

            function slideToBegining() {
                animatedSlide(0);
                setCanSlideTags(false, true);
            }

            function slideToEnd() {
                let newSlidingElementLeft = - (getTrueSliderWidth() - $(frameSelector).width()) -1 ;
                animatedSlide(newSlidingElementLeft);
                setCanSlideTags(true, false);
            }

            function slideToId(id) {
                let targetElementSelector = sliderSelector + ' > [id="'+ id +'"]:visible';
                if ($(targetElementSelector).length > 0 && !isElementVisible(targetElementSelector)) {
                    let targetElementOffsetLeft = $(targetElementSelector).offset().left;
                    let sliderOffsetLeft = $(sliderSelector).offset().left;

                    let sliderWidth = getTrueSliderWidth();
                    let frameWidth = $(frameSelector).width();

                    let targetElementPosition = targetElementOffsetLeft - sliderOffsetLeft - 20;
                    let widthAfterTargetElement =  sliderWidth - targetElementPosition;

                    if ($(targetElementSelector).is(':first-child')) {
                        slideToBegining();
                    } else if (widthAfterTargetElement > frameWidth) {
                        animatedSlide(-targetElementPosition, true);
                    } else {
                        slideToEnd();
                    }
                } else {
                    scope.$broadcast('DKU_ARROW_SLIDER:animation_over');
                }
            }

            function animatedSlide(newPosition, checkCanSlide) {
                $(sliderSelector).on('transitionend', function() {
                    scope.$broadcast('DKU_ARROW_SLIDER:animation_over');
                    if (checkCanSlide) {
                        setCanSlideTags(scope.canSlideLeft(), scope.canSlideRight());
                    }
                    $(sliderSelector).off('transitionend');
                });
                $(sliderSelector).css('left', newPosition + 'px');
            }

          /*
           * Double Click Handler
           */

            function dblClickHandler(counter, timer, clickFunc, dblClickFunc) {
                return function() {
                    if (counter <= 2) {
                        counter++;
                    }
                    if (counter == 1) {
                        clickFunc();
                        timer = $timeout(function(){
                            counter = 0;
                        }, 150);
                    }
                    if (counter == 2) {
                        dblClickFunc();
                        $timeout.cancel(timer);
                        counter = 0;
                    }
                };
            }

            let leftClickCounter = 0;
            let leftClickTimer;
            scope.slideLeftClickHandler = dblClickHandler(leftClickCounter, leftClickTimer, scope.slideLeft, slideToBegining);

            let rightClickCounter = 0;
            let rightClickTimer;
            scope.slideRightClickHandler = dblClickHandler(rightClickCounter, rightClickTimer, scope.slideRight, slideToEnd);

            /*
             * Checking if sliding is needed / possible functions
             */

            function neededDomElementsExist () {
                return $(sliderSelector).length > 0 && $(slidingElementsSelector).length > 0;
            }

            let isNeedSlider = false;
            scope.computeNeedSlider = function() {
                isNeedSlider =  neededDomElementsExist() && getTrueSliderWidth() > $(frameSelector).width();
            };

            scope.needSlider = function() {
                return isNeedSlider;
            };

            scope.canSlideRight = function() {
                return scope.needSlider() && !isElementVisible($(slidingElementsSelector)[$(slidingElementsSelector).length - 1]);
            };

            scope.canSlideLeft = function() {
                return scope.needSlider() && !isElementVisible($(slidingElementsSelector)[0]);
            };

            function setCanSlideTags(canSlideLeftFlag, canSlideRightFlag) {
                scope.canSlideLeftFlag = canSlideLeftFlag;
                scope.canSlideRightFlag = canSlideRightFlag;
            }

            /*
             * Private visual computing helpers
             */

            function isElementVisible(elem) {
                elem = $(elem);
                if (elem.length > 0) {
                    var elemOffsetLeft = elem.offset().left;
                    var elemOffsetRight = elemOffsetLeft + elem.innerWidth();
                    return !scope.needSlider() || (minOffsetLeft <= elemOffsetLeft && elemOffsetRight <= maxOffsetRight);
                }
            }

            function isLastChipBeyondSliderBottom() {
                var lastEl = $(slidingElementsSelector)[$(slidingElementsSelector).length - 1];
                var lastElRightOffset = $(lastEl).offset().left + $(lastEl).outerWidth();
                return lastElRightOffset >= maxOffsetRight;
            }

            function getTrueSliderWidth() {
                var maxIndex = $(slidingElementsSelector).length - 1;
                return $($(slidingElementsSelector)[maxIndex]).offset().left + $($(slidingElementsSelector)[maxIndex]).outerWidth() - $($(slidingElementsSelector)[0]).offset().left;
            }

            function getHiddenWidth(elem) {
                var elemOffsetLeft = $(elem).offset().left;
                var elemOffsetRight = elemOffsetLeft + $(elem).outerWidth();

                if (elemOffsetLeft < minOffsetLeft) {
                   return  minOffsetLeft - elemOffsetLeft;
                } else if (maxOffsetRight < elemOffsetRight) {
                    return elemOffsetRight - maxOffsetRight;
                }
                return 0;
            }

            function getLeftAsNumber(elem) {
                var left = $(elem).css('left');
                left = left.replace('px', '');
                if (!isNaN(left)) {
                    return parseInt(left);
                }
                return 0;
            }

	  /*
           * Initialisation
           */
            $timeout(function() {
                scope.computeNeedSlider();
                if (scope.needSlider()) {
                    scope.initArrowSlider();
                }
            }, 0);

        }
    };
}]);


app.directive("uiCheckbox", function() {
    return {
        scope: {},
        require: "ngModel",
        restrict: "A",
        replace: "true",
        template: "<button type=\"button\"  ng-class=\"{'chkbox-btn-normal' : true, 'btn' : true, 'checked': checked===true}\">" +
            "<i ng-class=\"{'icon-ok': checked===true}\"></span>" +
            "</button>",
        link: function(scope, elem, attrs, modelCtrl) {
            scope.size = "default";
            // Default Button Styling
            scope.stylebtn = {};
            // Default Checkmark Styling
            scope.styleicon = {"width": "10px", "left": "-1px"};
            // If size is undefined, Checkbox has normal size (Bootstrap 'xs')
            if(attrs.large !== undefined) {
                scope.size = "large";
                scope.stylebtn = {"padding-top": "2px", "padding-bottom": "2px", "height": "30px"};
                scope.styleicon = {"width": "8px", "left": "-5px", "font-size": "17px"};
            }
            if(attrs.larger !== undefined) {
                scope.size = "larger";
                scope.stylebtn = {"padding-top": "2px", "padding-bottom": "2px", "height": "34px"};
                scope.styleicon = {"width": "8px", "left": "-8px", "font-size": "22px"};
            }
            if(attrs.largest !== undefined) {
                scope.size = "largest";
                scope.stylebtn = {"padding-top": "2px", "padding-bottom": "2px", "height": "45px"};
                scope.styleicon = {"width": "11px", "left": "-11px", "font-size": "30px"};
            }

            var trueValue = true;
            var falseValue = false;

            // If defined set true value
            if(attrs.ngTrueValue !== undefined) {
                trueValue = attrs.ngTrueValue;
            }
            // If defined set false value
            if(attrs.ngFalseValue !== undefined) {
                falseValue = attrs.ngFalseValue;
            }

            // Check if name attribute is set and if so add it to the DOM element
            if(scope.name !== undefined) {
                elem.name = scope.name;
            }

            // Update element when model changes
            scope.$watch(function() {
                if(modelCtrl.$modelValue === trueValue || modelCtrl.$modelValue === true) {
                    modelCtrl.$setViewValue(trueValue);
                } else {
                    modelCtrl.$setViewValue(falseValue);
                }
                return modelCtrl.$modelValue;
            }, function(newVal, oldVal) {
                scope.checked = modelCtrl.$modelValue === trueValue;
            }, true);

            // On click swap value and trigger onChange function
            elem.bind("click", function() {
                scope.$apply(function() {
                    if(modelCtrl.$modelValue === falseValue) {
                        modelCtrl.$setViewValue(trueValue);
                    } else {
                        modelCtrl.$setViewValue(falseValue);
                    }
                });
            });
        }
    };
});

const EDITABLE_LIST_ITEM_PREFIX = 'it'; // this is the property name used for items in the editableList* directives

/**
 * This directive is a fork of list-form that implements the new editable lists specifications.
 * 
 * @param {Array}       ngModel                         - The list to bind to display.
 * @param {boolean}     [sortable=false]                - True to make the list sortable. Allows to rearrange list order by drag-and-dropping.
 * @param {Function}    [onAdd]                         - The function called when adding an item.
 * @param {Function}    [onRemove]                      - The function called when removing an item.
 * @param {Function}    [onChange]                      - Callback called on change.
 * @param {boolean}     [noChangeOnAdd=false]           - True to prevent the callback onChange to be called when an item is added.
 * @param {boolean}     [required=false]                - Can the items of the list be empty. Used with the 'editable-list-input' component.
 * @param {Object}      [template]                      - Template of the items in the list. Used when the list items are objects.
 * @param {Function}    [prepare]                       - The function called on list update, to set items default value.
 * @param {Function}    [transcope]                     - Functions/objects to pass to the editableList scope.
 * @param {Array}       [suggests]                      - List of possible values of an item of the list. Can be displayed in a dropdown under a text input for instance.
 * @param {boolean}     [hasDivider=true]               - False to hide the divider line between items.
 * @param {string}      addLabel                        - Text to display in the add button; Optional if disableAdd is true.
 * @param {boolean}     [disableAdd=false]              - True to hide the Add button.
 * @param {boolean}     [disableRemove=false]           - True to hide the Remove buttons.
 * @param {boolean}     [disableCreateOnEnter=false]    - True to prevent creating a new item when pressing Enter in the last focused item of the list. Focus the first item of the list instead.
 * @param {boolean}     [skipToNextFocusable=false]     - True to focus the next focusable item on Enter if the immediate next item can't be focused (e.g. deleted item).
 * @param {boolean}     [fullWidthList=false]           - True to make the list fill the full width available in the container.
 * @param {boolean}     [compareByEquality=false]       - True to match ngModel changes with object equality instead of reference equality.
 */
app.directive('editableList', function($timeout) { return {
    restrict: 'E',
    transclude: true, replace: true,
    templateUrl: '/templates/widgets/editable-list.html',
    require: '?ngModel',
    scope: {
        ngModel: '<',
        sortable: '=',
        onAdd: '<',
        onRemove: '<',
        onChange: '=',
        noChangeOnAdd: '<',
        required: '<',
        template: '=',
        prepare: '=',
        transcope: '=',
        suggests: '=',
        hasDivider: '<',
        addLabel: '@',
        disableAdd: '<',
        disableRemove: '<',
        disableCreateOnEnter: '<',
        skipToNextFocusable: '<',
        fullWidthList: '<',
        compareByEquality: '<'
    },
    compile: function(elt, attrs, transclude) {
        const ITEMS_CLASSNAME = 'editable-list__items';
        const ITEM_CLASSNAME = 'editable-list__item'; 
        const DIVIDER_CLASSNAME = 'editable-list__item--divider';
        const DRAG_ICON_CLASSNAME = 'editable-list__drag-icon';
        const DRAG_ICON_QA_SELECTOR = 'data-qa-editable-list-drag';
        const DELETE_BUTTON_CLASSNAME = 'editable-list__delete';
        const DELETE_BUTTON_QA_SELECTOR = 'data-qa-editable-list-delete';
        const ITEM_TEMPLATE_CLASSNAME = 'editable-list__template'; 
        const EDITING_CLASSNAME = 'editable-list__template--editing';

        var itemsExpr = attrs.ngModel,
            klass = attrs['class'],
            focusableInputs = ['input:not([type=checkbox])', 'textarea', 'select'];

        return function(scope, elt){
            var lis = []; // the LIs

            if (klass) { // report CSS classes
                elt.className += ' ' + klass;
            }

            var insertTranscope = function(into) {
                if (typeof scope.transcope === 'object') {
                    for (var k in scope.transcope) {
                        into[k] = scope.transcope[k];
                    }
                }
            };

            insertTranscope(scope);
            scope.ngModel = [];

            scope.$parent.$watch(itemsExpr, function(v) {
                scope.ngModel = v || [];
            });

            // default hasDivider to true
            if (!angular.isDefined(scope.hasDivider)) {
                scope.hasDivider = true;
            }

            // Utilities
            function parentOf(child, className) {
                while (child && !child.classList.contains(className)) {
                    child = child.parentElement;
                }
                return angular.element(child);
            }

            function templateOf(child) {
                return parentOf(child, ITEM_TEMPLATE_CLASSNAME);
            }

            function liOf(child) {
                return parentOf(child, ITEM_CLASSNAME);
            }

            function indexOf(li) {
                for (var i = 0; i < lis.length; i++) {
                    if (lis[i].element[0] === li) return i;
                }
                // cond always true, prevent error w/ CodePen loop
                if (i || !lis.length) return -1;
            }

            function prepare(it) {
                if (scope.prepare) {
                    scope.prepare(it);
                }
            }

            function template() {
                switch(typeof scope.template) {
                    case 'function': return scope.template();
                    case 'object': return angular.extend({}, scope.template);
                    case 'string' : return scope.template;
                    default: return {};
                }
            }

            function regularEnter(evt) {  // press button, return in textarea...
                return evt.target.tagName.toLowerCase() !== 'input'
                        || evt.target.type === 'button';
            }

            // Remove & update DOM
            scope.remove = function(i) {
                scope.ngModel.splice(i, 1);
                update(scope.ngModel);
                scope.$parent.$apply();
                scope.onRemove && scope.onRemove(i);
            };

            var changing = false;

            function updateSuggests() {
                for (var i = lis.length; i-- > 0;) {
                    lis[i].scope.suggests = scope.suggests;
                }
            }

            function update(items, noChangeOnAdd) {
                var change = !changing && scope.onChange && !noChangeOnAdd;

                changing = true;

                for (var i = lis.length; i-- > 0;) {
                    lis[i].element.remove();
                    lis[i].scope.$destroy();
                    lis.splice(i, 1);
                }

                for (i = items.length - 1; i >= 0; i--) {
                    var childScope = scope.$new(),
                        childLi = angular.element('<li class="' + ITEM_CLASSNAME + (scope.hasDivider ? ' ' + DIVIDER_CLASSNAME : '') + '"></li>'),
                        childDrag = angular.element('<i ' + DRAG_ICON_QA_SELECTOR + ' class="' + DRAG_ICON_CLASSNAME +' icon-reorder"></i>'),
                        childDelete = angular.element('<button type="button" ' + DELETE_BUTTON_QA_SELECTOR + ' class="btn btn--text btn--danger btn--icon ' + DELETE_BUTTON_CLASSNAME + ' " tabindex="-1"> <i class="icon-trash"></i></button>'),
                        childTemplate = angular.element('<div class="' + ITEM_TEMPLATE_CLASSNAME + '"></div>');

                    childScope[EDITABLE_LIST_ITEM_PREFIX] = items[i];
                    childScope.suggests = scope.suggests;
                    prepare(childScope[EDITABLE_LIST_ITEM_PREFIX]);
                    childScope.$index = i;
                    childDelete.click(scope.remove.bind(this, i));

                    scope.sortable && childLi.append(childDrag);
                    childLi.append(childTemplate);
                    !scope.disableRemove && childLi.append(childDelete);

                    transclude(childScope, function(clone) {
                        childTemplate.prepend(clone);
                    });
                    
                    lis.unshift({ element: childLi, scope: childScope });
                    itemsContainerEl.prepend(childLi);
                }

                const children = itemsContainerEl.children();
                const lastChild = children[children.length - 1];
                itemsContainerEl[0].scrollTop = lastChild && lastChild.offsetTop || 0;

                if (change) {
                    scope.onChange(scope.ngModel);
                }
                
                changing = false;
            }
            
            if (scope.onChange) {
                // Use a jQuery event handler, not a DOM one, because we want
                // the .trigger("change") in the bs-typeahead to trigger this
                $(elt[0]).on('change', function(evt) {
                    function doIt(){
                        changing = true;
                        scope.onChange(scope.ngModel);
                        changing = false;
                    }

                    if (!changing) {
                        /* This is the same hack that we did to fix #1222.
                         * When you have a bs-typeahead, you have an non-empty field, then
                         * you chnage data to get a suggestion. Clicking on the suggestion
                         * will exit the input field, triggering a change event.
                         * However, the change event triggers before the click has its own actions:
                         * which is, changing the value of the input and triggering another
                         * "change" and "input" event.
                         * By delaying the taking into account of this, we leave time to the browser
                         * to process the click and to have it repercuted to the Angular model
                         */
                        var uglyBSHack = $(evt.target).attr("bs-typeahead") != null;
                        if (uglyBSHack) {
                            window.setTimeout(doIt, 150);
                        } else {
                            doIt();
                        }
                    }
                });
            }

            scope.$watch('ngModel', update, scope.compareByEquality);
            if (scope.suggests) { scope.$watch('suggests', updateSuggests, true); }

            // Editing row, focus & blur
            var editing = null;

            function edit(li) {
                if (editing === li) return;
                if (editing) editing.removeClass(EDITING_CLASSNAME);
                editing = li;
                if (editing) {
                    editing.addClass(EDITING_CLASSNAME);
                }
            }

            elt[0].addEventListener('focus', function(evt) {
                if (focusableInputs.indexOf(evt.target.tagName.toLowerCase()) >= 0) {
                    edit(templateOf(evt.target));
                    evt.target.select();
                }
            }, true);

            elt[0].addEventListener('blur', function(evt) {
                if (focusableInputs.indexOf(evt.target.tagName.toLowerCase()) >= 0) {
                    edit(null);
                    window.getSelection().removeAllRanges();
                }
            }, true);

            function skipToNextFocusable(next) {
                let nextElement = lis[next].element[0];
                let focusable = nextElement.querySelector(focusableInputs.join(', '));
                while (next > -1 && !focusable) {
                    next = indexOf(nextElement.nextSibling);
                    if (next < 0) {
                        break;
                    }
                    nextElement = lis[next].element[0];
                    focusable = nextElement.querySelector(focusableInputs.join(', '));
                }
                return next;
            }

            elt.on('keydown', function(evt) {
                var next = null;
                switch (evt.keyCode) {
                    case 27:
                        evt.target.blur();
                        return true;
                    case 13:
                         if (regularEnter(evt)) return true;
                         evt.target.blur();
                         next = indexOf(templateOf(evt.target)[0].parentElement.nextSibling);
                         break;
                    default:
                        return true;
                }
                if (scope.skipToNextFocusable && next > -1) {
                    next = skipToNextFocusable(next);
                }
                next = scope.disableCreateOnEnter && next != null && next < 0 ? 0 : next;
                if (next > -1) {
                    const nextElement = lis[next].element[0];
                    const focusable = nextElement.querySelector(focusableInputs.join(', '));
                    if (focusable) focusable.focus();
                } else {
                    scope.add();
                }

                evt.preventDefault();
                evt.stopPropagation();
                return false;
            });

            var itemToAdd = template();

            prepare(itemToAdd);

            var deregWatchPrepare = scope.$watch('prepare', function() {
                if (scope.prepare) {
                    prepare(itemToAdd);
                    deregWatchPrepare();
                }
            });

            const itemsContainerEl = elt.find('.' + ITEMS_CLASSNAME);

            scope.add = function() {
                scope.ngModel.push(itemToAdd);
                itemToAdd = template();
                prepare(itemToAdd);
                scope.hasAddedItem = true;
                update(scope.ngModel, scope.noChangeOnAdd);
                const addedElement = lis[lis.length - 1].element[0];
                $timeout(function() {
                    const focusable = addedElement.querySelector(focusableInputs.join(', '));
                    if (focusable) focusable.focus();
                });
                scope.onAdd && scope.onAdd();
            }

            // Drag / drop
            if (!scope.sortable) return;

            elt.addClass('editablie-list--sortable');

            var dragging = null, draggingIndex = null, draggingOpacityTimeout = null;

            // Only allow dragging on handles
            elt.on('mouseover', function(evt) {
                if (evt.target.classList.contains(DRAG_ICON_CLASSNAME)) {
                    liOf(evt.target).prop('draggable', true);
                }
            });

            elt.on('mouseout', function(evt) {
                if (evt.target.classList.contains(DRAG_ICON_CLASSNAME) && !dragging) {
                    liOf(evt.target).prop('draggable', false);
                }
            });

            // Actual drag/drop code
            elt.on('dragstart', function(evt) {
                (evt.originalEvent || evt).dataTransfer.setData('text/plain', null);
                (evt.originalEvent || evt).dataTransfer.effectAllowed = 'move';
                dragging = liOf(evt.target)[0];
                draggingIndex = indexOf(dragging);
                itemsContainerEl.addClass('dragging');
                evt.target.classList.add('dragging');
                draggingOpacityTimeout = window.setTimeout(function() { 
                    dragging.style.opacity = 0; 
                }, 200); // later to let time for snapshot
            });

            elt.on('dragenter', function(evt) {
                if (!dragging || evt.target === elt[0]) return;
                var li = liOf(evt.target)[0];
                if (!li || li === dragging) return;
                li.classList.add(draggingIndex < indexOf(li) ? 'drag-below' : 'drag-above');
            });

            elt.on('dragleave', function(evt) {
                evt.target.classList.remove('drag-above', 'drag-below');
            });

            elt.on('dragover', function(evt){
                if (!dragging || evt.target === elt[0]) return;
                var li = liOf(evt.target)[0];
                if (!li || li === dragging) return;
                evt.preventDefault();
                (evt.originalEvent || evt).dataTransfer.dropEffect = 'move';
            });

            elt.on('drop', function(evt) {
                if (!dragging) return;
                evt.preventDefault();
                const dropIndex = indexOf(evt.target), dragIndex = draggingIndex;
                const itemsContainer = elt.find('.' + ITEMS_CLASSNAME)[0];
                if (dropIndex > draggingIndex) { // insert after
                    itemsContainer.insertBefore(dragging, evt.target.nextSibling);
                } else { // insert before
                    itemsContainer.insertBefore(dragging, evt.target);
                }
                dragEnd();
                scope.$apply(function() {
                    scope.ngModel.splice(dropIndex, 0, scope.ngModel.splice(dragIndex, 1)[0]);
                    update(scope.ngModel);
                });
            });

            elt.on('dragend', dragEnd);

            function dragEnd() {
                dragging.style.opacity = 1;
                itemsContainerEl.removeClass('dragging');
                dragging.classList.remove('dragging');
                if (draggingOpacityTimeout != null) {
                    window.clearTimeout(draggingOpacityTimeout);
                }
                dragging = null;
                draggingIndex = null;
                draggingOpacityTimeout = null;
                elt.find('.drag-above').removeClass('drag-above');
                elt.find('.drag-below').removeClass('drag-below');
            }
        };
    }
}; });


app.directive('checkCategoryNameUnique', function() {
    return {
        require: 'ngModel',
        scope: false,
        compile: function() {
            return function(scope, elt, attrs, ngModel) {
                const index = scope.$index;

                function checkUnique(nv, ov) {
                    const isUnique = !scope.generalSettings.globalTagsCategories.find((it, idx) => it.name == nv[index].name && idx != index);
                    ngModel.$setValidity('unique', isUnique);
                    return nv;
                }

                scope.$watch('generalSettings.globalTagsCategories', checkUnique, true);
            }
        }
    }

});

app.directive('editableListInput', function ($parse, $timeout) {
    return {
        replace: true,
        require: '?ngModel',
        restrict: 'E',
        scope: {
            ngModel: '=',
            type: '@',
            onChange: '&',
            onKeyUpCallback: '&',
            placeholder: '@',
            required: '<',
            bsTypeahead: '=',
            classes: '@',
            unique: '<',
            trimParam: '<',
            checkWarning: '=', // needs to be a function that evaluates fast, it's not debounced
            disableFormValidation: '<' // if true, this item  being invalid doesn't make the parent form invalid
        },
        templateUrl: '/templates/widgets/editable-list-input.html',
        compile: function() {

            return function(scope, elt, attrs, ngModel) {
                const propertyToCompare = attrs.ngModel.split(EDITABLE_LIST_ITEM_PREFIX + '.')[1];

                var setItemValidity;
                var $elt = $(elt);

                function updateModel(evt) {
                    const localScope = angular.element(evt.target).scope();
                    if (localScope) {
                        $parse(attrs.ngModel).assign(scope.$parent, localScope.ngModel);
                    }
                    if (setItemValidity) {
                        setItemValidity();
                    }
                }

                scope.onKeyUp = function(evt) {
                    updateModel(evt);
                    setTimeout(() => $elt.trigger("keyup"));
                    if (scope.onKeyUpCallback) {
                        scope.onKeyUpCallback();
                    }
                };

                var editableListScope = scope.$parent.$parent;
                scope.parentListItems = editableListScope ? editableListScope.ngModel : [];
                const index = scope.$parent.$index;
                if (editableListScope.editableListForm) {
                    if (scope.disableFormValidation) {
                        editableListScope.editableListForm.$removeControl(ngModel.$$parentForm);
                    } else {
                        editableListScope.editableListForm.$addControl(ngModel.$$parentForm);
                    }
                }

                function checkUnique(nv, ov) {
                    if (!scope.ngModel) {
                        return;
                    }
                    const isUnique = !scope.parentListItems.find((it, idx) => resolveValue(it, propertyToCompare) === scope.ngModel && idx != index);
                    ngModel.$setValidity('unique', isUnique);
                }

                if (scope.unique || scope.required) {
                    setItemValidity = () => {
                        $timeout(() => scope.$parent[EDITABLE_LIST_ITEM_PREFIX].$invalid = ngModel.$$parentForm.$invalid);
                    }
                    setItemValidity();
                }

                //Since we delete and recreate the editableList items on update (add/remove) we loose information on which one have been touched/modified.
                //For validation we need this information to keep displaying the error message when recreated so we store it in the item
                if (scope.required) {
                    //if parentScope contains different editableListInput we need to differentiate $touched
                    scope.touchedId = `$touched.${attrs.ngModel}`;

                    scope.onBlur = function() {
                        scope.$parent[EDITABLE_LIST_ITEM_PREFIX][scope.touchedId] = true;
                    }

                    // if an already saved input is empty/invalid we want to display the error message even if not touched
                    if (!editableListScope.hasAddedItem) {
                        scope.onBlur();
                    }
                }

                if (scope.unique) {
                    scope.$watch('parentListItems', checkUnique, true);
                }

                let changing = false;
                $(elt[0]).on('change', function(evt) {
                    function doIt(){
                        changing = true;
                        updateModel(evt);
                        $elt.trigger("change");
                        changing = false;
                    }

                    if (!changing) {
                        /* This is the same hack that we did to fix #1222.
                         * When you have a bs-typeahead, you have an non-empty field, then
                         * you chnage data to get a suggestion. Clicking on the suggestion
                         * will exit the input field, triggering a change event.
                         * However, the change event triggers before the click has its own actions:
                         * which is, changing the value of the input and triggering another
                         * "change" and "input" event.
                         * By delaying the taking into account of this, we leave time to the browser
                         * to process the click and to have it repercuted to the Angular model
                         */
                        var uglyBSHack = $(evt.target).attr("bs-typeahead") != null;
                        if (uglyBSHack) {
                            window.setTimeout(doIt, 200);
                        } else {
                            doIt();
                        }
                    }
                });
            }
        }
    }
});

app.directive("timeZoneList", function(DataikuAPI){
    return {
        restrict : 'A',
        link : function(scope, element, attrs) {
            DataikuAPI.timezone.list().success(function(data){
                scope.timezone_ids = data.ids;
            }).error(setErrorInScope.bind(this));
        }
    }
});

// Performance-oriented one-way binding
// Raw (unescaped) HTML only, no expression, must be updated explicily
// Must be bound in a map, e.g. {a: "Label", b: "<strong>error</strong>"}
app.directive('fastBind', function() {
    return {
        scope: false,
        priority: -1,
        link: function(scope, element, attrs) {
            var elts = [], keys = [], root = element[0];
            function set(key, map) { this.innerHTML = map[key]; }
            element.find('[fast-bound]').each(function(i){
                elts[i] = this;
                keys[i] = this.getAttribute('fast-bound');
            });
            scope[attrs.fastBind] = function(map) {
                if (!map) {
                    element[0].style.visibility = 'hidden';
                } else {
                    for (let i = elts.length - 1; i>=0; i--) {
                        elts[i].innerHTML = map[keys[i]];
                    }
                    root.style.visibility = 'visible';
                }
            };
        }
    };
});

app.directive("smartLogTail", function(){
    return {
        restrict : 'A',
        replace:true,
        scope : {
            smartLogTail : '=',

        },
        template : '<pre class="smart-log-tail-content">'+
                '<span ng-repeat="line in smartLogTail.lines track by $index" '+
                    'ng-class="{\'text-error\':  smartLogTail.status[$index] == TAIL_STATUS.ERROR,'+
                           '\'text-warning\': smartLogTail.status[$index] == TAIL_STATUS.WARNING,'+
                           '\'text-success\': smartLogTail.status[$index] == TAIL_STATUS.SUCCESS, }">'+
                    '{{line}}'+
                '</span>'+
                '</pre>',
        link : function(scope){
             scope.TAIL_STATUS = {
                DEBUG: 0,
                INFO: 1,
                WARNING: 2,
                ERROR: 3,
                SUCCESS: 4
            };
        }
    }
});

app.directive("automationEditOverlay", function(){
    return {
        replace:true,
        template : '<div ng-cloak ng-if="appConfig.isAutomation" class="automation-edit-overlay"><div class="text"><div class="line1">Automation node</div><div class="line2">Edits will be lost at next bundle import</div></div></div>',
    }
});

app.directive("infoMessagesList", function(){
    return {
        restrict : 'A',
        scope : {
            infoMessagesList : '='
        },
        template : '<ul class="info-messages-list"><li ng-repeat="message in infoMessagesList">'+
                    '<div ng-class="\'message-\' + (message.severity.toLowerCase())">'+
                        '<div ng-if="message.title && message.details">'+
                            '<h4 >{{message.title}}</h4>'+
                            '<span>{{message.details}}</span>'+
                            '<span ng-show="message.line"> (at line {{message.line}})'+
                        '</div>'+
                        '<div ng-if="message.title && !message.details">'+
                            '<span>{{message.title}}</span>'+
                            '<span ng-show="message.line"> (at line {{message.line}})'+
                        '</div>'+

                    '</div>'+
                '</li></ul>',
    }
});

app.directive('masterBreadcrumb', function($rootScope, Breadcrumb) {
    return {
        templateUrl: '/templates/master-breadcrumb.html',
        scope: true,
        link: function($scope, element, attrs) {
            $scope.breadcrumbData = $rootScope.masterBreadcrumbData;
        }
    }
});

app.service("InfoMessagesModal", function($q, CreateModalFromTemplate, ProgressStackMessageBuilder){
    var InfoMessagesModal = {
        /* Shows only if there is a message */
        showIfNeeded : function(parentScope, messages, modalTitle) {

            if (messages.messages.length > 0) {
                CreateModalFromTemplate("/templates/widgets/info-messages-display.html", parentScope, null, function(newScope){
                    newScope.modalTitle = modalTitle;
                    newScope.messages = messages;
                });
            }
        }
    }
    return InfoMessagesModal;
});


app.service("APIErrorModal", function($q, CreateModalFromTemplate, ProgressStackMessageBuilder){
    var InfoMessagesModal = {
        showCB : function showCB(data, status, headers) {
            CreateModalFromTemplate("/templates/widgets/api-error-modal.html", parentScope, null, function(newScope){
                newScope.apiError = getErrorDetails(data, status, headers);
            });
        },
        show : function show(apiError){
            CreateModalFromTemplate("/templates/widgets/api-error-modal.html", parentScope, null, function(newScope){
                newScope.apiError = apiError;
            });
        }
    };
    return InfoMessagesModal;
});

app.directive("refreshCodemirrorOn", function($timeout){
    return {
        link : function($scope, element, attrs) {
            $scope.$watch(attrs.refreshCodemirrorOn, function(nv, ov){
                $timeout(function(){
                    element.find(".CodeMirror").each(function(i, e) {
                        if (e.CodeMirror) e.CodeMirror.refresh();
                    });
                }, 0);
            });
        }
    }
})

app.filter("infoMessageAlertClass", function(){
    return function(input){
        var dict = {
            'ERROR': 'alert-danger',
            'WARNING': 'alert-warning',
            'INFO': 'alert-info'
        };
        return dict[input.severity];
    }
})

app.filter("severityAlertClass", function(){
    return function(input){
        var dict = {
            'ERROR': 'alert-danger',
            'WARNING': 'alert-warning',
            'INFO': 'alert-info'
        };
        return input != null ? dict[input] : 'alert-info';
    }
})

app.directive("infoMessagesRawListWithAlert", function(){
    return {
        templateUrl : '/templates/widgets/info-messages-raw-list-with-alert.html',
        scope : {
            data : '=infoMessagesRawListWithAlert',
            showReduceAction: '='
        }
    }
})

app.directive("infoMessagesRawList", function(){
    return {
        templateUrl : '/templates/widgets/info-messages-raw-list.html',
        scope : {
            data : '=infoMessagesRawList'
        }
    }
})

app.directive("featureLocked", function(){
    return {
        templateUrl : '/templates/widgets/feature-locked.html',
        restrict : 'EA',
        scope : {
            featureName : '='
        }
    }
});

app.directive("qrCode", function(){
    return {
        scope : {
            qrCode : '='
        },
        template : "<div class='qr'></div>",
        link : function($scope, element, attrs) {
            $scope.$watch("qrCode", function(nv, ov) {
                if (nv) {
                    var qrcode = new QRCode(element.find(".qr")[0], {
                        text : $scope.qrCode,
                        width: 128,
                        height: 128,
                        colorDark : "#000000",
                        colorLight : "#ffffff",
                        correctLevel : QRCode.CorrectLevel.H
                    });
                }
            });
        }
    }
});

app.directive("dkuFoldable", function(){
    return {
        scope : true,
        controller : ['$scope', '$attrs', function($scope, $attrs) {
            $scope.foldableOpen = $scope.$eval($attrs.open);
        }],
        link : function($scope, element, attrs){
            $scope.foldableToggle = function(){
                $scope.foldableOpen = !$scope.foldableOpen;
            };
            function setChevronClazz(){
                $scope.foldableChevronClazz = $scope.foldableOpen ? "icon-chevron-up" : "icon-chevron-down";
            }
            $scope.$watch("foldableOpen", setChevronClazz);
            setChevronClazz();
            $scope.$watch(attrs.open, function(nv, ov){
                if (nv != ov) $scope.foldableToggle();
            });
        }
    }
});

app.directive("dkuFoldableRightPanel", function(LocalStorage, STANDARDIZED_SIDE_PANEL_KEY){
    return {
        scope : true,
        require : "dkuFoldable",
        link : function($scope, element, attrs) {
            let objectType = $scope.objectType !== undefined ? $scope.objectType : "defaultObjectType";
            // Strip the LOCAL_ and FOREIGN_ prefix to have the same expanded/collapsed section in the Flow and in the actual object item view (ex: Dataset).
            if (objectType.startsWith("LOCAL_")) {
                objectType = objectType.substring(6);
            } else if (objectType.startsWith("FOREIGN_")) {
                objectType = objectType.substring(8);
            }
            const key = STANDARDIZED_SIDE_PANEL_KEY + '.' + objectType + '.' + attrs.name;
            let localValue = LocalStorage.get(key);
            if(localValue !== undefined){
                $scope.foldableOpen =  localValue;
            }
            $scope.$watch("foldableOpen", function(nv, ov){
                if (nv != ov) {
                    LocalStorage.set(key, nv);
                }
            });
        }
    }
});

/*
 * Add on for dkuFoldable
 */
app.directive("openOnDragEnter", function($timeout) {
    return {
        restrict: 'A',
        link : function($scope, element, attrs) {
            var previousState = null;
            var nesting = 0;

            element.on('dragenter', function(e) {
                if (nesting++ === 0) {
                    previousState = $scope.foldableOpen;
                    $scope.$apply(function() {
                        $scope.foldableOpen = true;
                    });
                }
            });
            element.on('dragleave', function(e) {
                if (--nesting === 0) {
                    $scope.$apply(function() {
                        $scope.foldableOpen = previousState;
                        previousState = null;
                    });
                }
            });
            $(document).on('dragend', function() {
                $timeout(function() { nesting = 0; });
            });
        }
    }
});

app.directive("rightColumnDescriptionTags", function(){
    return {
        scope : {
            object : '='
        },
        templateUrl : '/templates/widgets/right-column-description-tags.html'
    }
});

/*
 * Verry usefull to repeat template passed through transclude in a ng-repeat directive.
 * In the HTML template 'inject' directive call should be at the same level as 'ng-repeat' directive call
 */

app.directive('dkuInject', function(){
  return {
    link: function($scope, $element, $attrs, controller, $transclude) {
      if (!$transclude) {
        throw minErr('ngTransclude')('orphan',
         'Illegal use of ngTransclude directive in the template! ' +
         'No parent directive that requires a transclusion found. ' +
         'Element: {0}',
         startingTag($element));
      }
      var innerScope = $scope.$new();
      $transclude(innerScope, function(clone) {
        $element.empty();
        $element.append(clone);
        $element.on('$destroy', function() {
          innerScope.$destroy();
        });
      });
    }
  };
});

/*
 * Custom carousel : can take any html template and use it to populate the slides (makes use the dkuInject directive to combine transclude and ngRepeat)
 */

app.directive('dkuCarousel', function($timeout){
    return {
        transclude: true,
        templateUrl: '/templates/projects/dku-carousel.html',
        restrict: 'A',
        scope: {
            entries : '=dkuCarousel',
            initialIndex : '=?'
        },
        link: function($scope, element){

            $scope.element = element;

            $scope.index = 0;
            if ($scope.initialIndex) {
                $scope.index = $scope.initialIndex;
            }

            $scope.slideLeft = function() {
                if (!$scope.entries) return;
                var maxIndex = $scope.entries.length - 1;
                var newIndex = $scope.index - 1;
                if (newIndex < 0) {
                    newIndex = maxIndex;
                }
                slide(newIndex, -1);
            };

            $scope.slideRight = function() {
                if (!$scope.entries) return;
                var maxIndex = $scope.entries.length - 1;
                var newIndex = $scope.index + 1;
                if (newIndex > maxIndex) {
                    newIndex = 0;
                }
                slide(newIndex, 1);
            };

            var slide = function (newIndex, direction) {
                var slider = $(element).find('.slider');

                // In order to give the illusion the carousel is wrapping
                var firstSlideClone = $(element).find('.slide:first-child').clone().addClass('clone');
                var lastSlideClone = $(element).find('.slide:last-child').clone().addClass('clone');
                $(slider).prepend(lastSlideClone);
                $(slider).append(firstSlideClone);

                var slides = $(element).find('.slide');
                var domNbSlides = $scope.entries.length + 2;        //since we've juste added to new slides
                var domIndex = $scope.index + 1;    //since we've just preprended a new slide
                var newDomIndex = domIndex + 1 * direction;

                var leftPosition = -1 * domIndex * 100 / domNbSlides;
                var newLeftPosition = -1 * newDomIndex * 100 / domNbSlides;
                var sliderWidth = domNbSlides * 100;
                $(slider).addClass('animating');
                $(slider).css('width', sliderWidth + '%');
                $(slider).css('transform', 'translate(' + leftPosition + '%, 0)');
                $(slides).css('width', 100/domNbSlides + '%');

                $timeout(function() {
                    $(slider).addClass('transition');
                    $(slider).css('transform', 'translate(' + newLeftPosition + '%, 0)');
                }, 0);

                $timeout(function() {
                    $(slider).removeClass('transition');
                    $scope.index = newIndex;
                    $(slider).removeAttr('style');
                    $(slider).removeClass('animating');
                    $(slides).removeAttr('style');
                    firstSlideClone.remove();
                    lastSlideClone.remove();
                }, 200);
            }
        }
    };
});

app.directive('displayAmount', function(DataikuAPI, $stateParams){
    return {
        template: '<span>{{amount}} {{unit}}<span ng-if="amount > 1">s</span></span>',
        restrict: 'AE',
        scope: {
            unit: '=',
            amount: '='
        },
        link: function($scope, element){
            // noop
        }
    };
});


app.directive('editableText', function($timeout){
    return {
        template: '<div class="dku-editable-text">' +
        '<div ng-show="!editing" ng-click="edit()" class="horizontal-flex">' +
        '<div class="flex mx-textellipsis">{{model || placeholder}}</div><div class="noflex"><i class="icon-pencil" /></div>' +
        '</div>' +
        '<input type="text" ng-model="model" placeholder="{{placeholder}}" ng-blur="editing = false" ng-show="editing" blur-on-enter />' +
        '</div>',
        restrict: 'A',
        scope: {
            model: '=editableText',
            placeholder: '='
        },

        link: function($scope, element){
            var input = $(element.find('input'));
            $scope.edit = function() {
                $scope.editing = true;
                $timeout(function() {
                    input.focus();
                });
            };
        }
    };
});


app.directive("objectSaveButton", function(CreateModalFromTemplate) {
    return {
        scope: {
            'save': '=',                    // function((optional)commitMessage)
            'canSave': '=',                 // boolean
            'isDirty': '=',                 // boolean
            'objectId': '=',
            'objectType': '@',
            'canWriteOverride': '=',         // for when you can save without having the write permission on the project (dashboard)
            'dropdownAlignRight': '='
        },
        templateUrl : '/templates/widgets/object-save-button.html',
        link: function($scope) {
            $scope.saveWithCustomCommitMessage = function () {
                CreateModalFromTemplate("/templates/git/commit-message-only-modal.html", $scope, null, function(newScope) {
                    newScope.commitData = {};
                    /* Reload previous message if any */
                    if ($scope.currentSaveCommitMessage) {
                        newScope.commitData.message = $scope.currentSaveCommitMessage;
                    }

                    newScope.commit = function(){
                        newScope.resolveModal(newScope.commitData);
                    };
                }, true).then(function(commitData){
                    $scope.currentSaveCommitMessage = commitData.message;
                    $scope.save(commitData.message);
                });
            };

            $scope.commit = function() {
                CreateModalFromTemplate("/templates/git/commit-object-modal.html", $scope, null, function(newScope) {
                    newScope.object = {
                        objectType : $scope.objectType,
                        objectId : $scope.objectId
                    };
                }, true);
            };
        }
    }
});

app.directive('ngRightClick', function($parse) {
    return function (scope, element, attrs) {
        var fn = $parse(attrs.ngRightClick);
        element.bind('contextmenu', function (event) {
            scope.$apply(function () {
                if (attrs.ngRightClickPreventDefault !== 'false') {
                    event.preventDefault();
                }
                fn(scope, {$event: event});
            });
        });
    };
});

//TODO: use this factory in folder_edit.js instead of openMenu() when the two branchs will be merged together
app.factory("openDkuPopin", function($timeout, $compile) {
    //Args in options: template, isElsewhere, callback, popinPosition = "SMART", onDismiss, doNotCompile, arrow
    return function($scope, $event, options) {
        var opts = angular.extend({popinPosition: 'SMART'}, options);
        var newDOMElt = $(opts.template);

        var newScope = $scope.$new();
        if (!opts.doNotCompile) {
            $compile(newDOMElt)(newScope);
        }

        // By default an arrow is displayed if the popin position strategy is SMART
        if (!angular.isDefined(opts.arrow)) {
            opts.arrow = opts.popinPosition == 'SMART';
        }

        newScope.dismiss = function(skipOnDismiss){
            newScope.$destroy();
            newDOMElt.remove();
            $('body').off('click', hideOnClickElsewhere);
            $('body').off('contextmenu', hideOnClickElsewhere);
            if (typeof(opts.onDismiss) === "function" && !skipOnDismiss) {
                opts.onDismiss(newScope);
            }
        };
        newScope.$on("$destroy", function(){
            newDOMElt.remove();
        });

        var hideOnClickElsewhere = function(e) {
            if(typeof(opts.isElsewhere)==="function" && opts.isElsewhere(newDOMElt, e)) {
                $timeout(newScope.dismiss, 0);
            }
        };

        $timeout(function(){
            newScope.$apply(function() {
                $("body").append(newDOMElt);
                switch (opts.popinPosition) {
                    case "SMART":
                        smartPositionning();
                        break;
                    case "CLICK":
                        clickPositionning();
                        break;
                    default:
                        break;
                }
                newDOMElt.show();
                $('body').click(hideOnClickElsewhere);
                $('body').contextmenu(hideOnClickElsewhere);
                if (typeof(opts.callback) === "function") {
                    opts.callback(newScope);
                }
            });
        });


        // Positions the popin so that it is always aligned with one side of the element
        function smartPositionning() {
            var element_X = $($event.target).offset().left;
            var element_Y = $($event.target).offset().top;
            var element_W = $($event.target).outerWidth(true);
            var element_H = $($event.target).outerHeight(true);
            var popin_W = $(newDOMElt).outerWidth(true);
            var popin_H = $(newDOMElt).outerHeight(true);
            var window_W = window.innerWidth;
            var window_H = window.innerHeight;

            var popin_on_bottom = (element_Y + element_H + popin_H < window_H);
            var popin_aligned_on_right = (element_X + popin_W > window_W);

            var popin_X = (popin_aligned_on_right) ? (element_X + element_W - popin_W) : (element_X);
            var popin_Y = (popin_on_bottom) ? (element_Y + element_H) : (element_Y - popin_H);

            newDOMElt.css("top", popin_Y);
            newDOMElt.css("left", popin_X);

            // Add an arrow linking the popin to the element which triggered it
            if (opts.arrow) {
                var cssClass = "";
                cssClass += (popin_on_bottom) ? 'bottom-' : 'top-';
                cssClass += (popin_aligned_on_right) ? 'left' : 'right';
                newDOMElt.addClass(cssClass);
            }
        }

        // Positions the popin so that its content is displayed at the location of the mouse click
        function clickPositionning() {
            var mouse_X = $event.clientX;
            var mouse_Y = $event.clientY;
            var popin_W = $(newDOMElt).outerWidth(true);
            var popin_H = $(newDOMElt).outerHeight(true);
            var window_W = window.innerWidth;
            var window_H = window.innerHeight;

            var popin_on_bottom = (mouse_Y + popin_H < window_H);
            var popin_on_right = (mouse_X + popin_W < window_W);

            var popin_X = (popin_on_right) ? (mouse_X) : (mouse_X - popin_W);
            var popin_Y = (popin_on_bottom) ? (mouse_Y) : (mouse_Y - popin_H);

            newDOMElt.css("top", popin_Y);
            newDOMElt.css("left", popin_X);

            // Add an arrow linking the popin to the element which triggered it
            if (opts.arrow) {
                var cssClass = "";
                cssClass += (popin_on_bottom) ? 'bottom-' : 'top-';
                cssClass += (popin_on_right) ? 'right' : 'left';
                newDOMElt.addClass(cssClass);
            }
        }

        //returning function to remove popin
        return newScope.dismiss;
    }
});

app.factory('TreeViewSortableService', function() {
    let currentNode;
    return {
        setCurrent: (node) => {currentNode = node;},
        getCurrent: () => currentNode
    };
});

app.directive('treeView', function($stateParams, $timeout, openDkuPopin, TreeViewSortableService) {
    return {
        templateUrl: '/templates/widgets/tree-view-node.html',
        restrict: 'AE',
        scope: {
            nodes: '=treeView',
            rootNodes: '=?',
            depth: '<',
            nodeName: '<',
            onClick: '<',
            onArrowClick: '<',
            iconClass: '<',
            iconTitle: '<',
            rightIconClass: '<',
            rightIconTitle: '<',
            nodeClass: '<',
            showDragHandles: '<',
            scrollToNodeFn: '=?',
            getTaxonomyMassExpandCollapseStateFn: '=?',
            expandAllFn: '=?',
            collapseAllFn: '=?',
            setReduceFn: '=?',
            setUnfoldedNodeIdsFn: '<?',
            getUnfoldedNodeIdsFn: '<?',
            getNodeIdsHavingChildrenFn: '<?',
            getRightClickMenuTemplate: '<?',
            contextMenuFns: '=?',
            showContextMenu: '=?'
        },
        link: function($scope, $el) {
            if (!$scope.nodes) {
                throw new Error("No nodes provided to tree view");
            }


            $scope.depth = $scope.depth || 0;
            $scope.MARGIN_PER_DEPTH = 15;
            $scope.uiState = {};

            $scope.activateSortable = function() {
                const parentNode = ($scope.$parent && $scope.$parent.node || $scope.uiState);
                (TreeViewSortableService.getCurrent() || {}).$sortableEnabled = false;
                parentNode.$sortableEnabled = true;
                $scope.nodes.forEach(n => n.$reduced = true);
                TreeViewSortableService.setCurrent(parentNode);
            };

            // disabled dragstart event in order to disable native browser drag'n'drop and allow mouse up event when drag'n'dropping
            $timeout(() => $el.find('> ul > li > div.tree-view-node > div > span.handle-row').each((idx, el) => { el.ondragstart = () => false }));
            $scope.onSortableStop = function() {
                for (let i = 0; i < $scope.nodes.length; i++) {
                    delete $scope.nodes[i].$tempReduced;
                }
            };
            $scope.onNodeMouseDown = function(node) {
                node.$tempReduced = true;
            };
            $scope.treeViewSortableOptions = {
                axis:'y',
                cursor: 'move',
                cancel: '',
                handle: '.tree-view-drag-handle',
                update: $scope.onSortableStop
            };

            $scope.onNodeClick = function(node, evt) {
                if (!$(evt.originalEvent.explicitOriginalTarget).is('i.icon-reorder')) {
                    $scope.onClick(node);
                }
            };

            $scope.openContextMenu = function (node, $event) {
                if (!$scope.showContextMenu) {
                    return;
                }

                node.$rightClicked = true;

                let template = `<ul class="dropdown-menu" ng-click="popupDismiss()">`;
                switch ($scope.getNodeMassExpandCollapseStateFn(node.id)) { //NOSONAR
                    case "EXPAND_ALL":
                        template += `
                            <li class="dku-border-bottom">
                                <a href="#" ng-click="expandChildren('`+node.id+`')">
                                    <i class="icon-dku-expand-all icon-fixed-width" /> Expand all
                                </a>
                            </li>`;
                        break;
                    case "COLLAPSE_ALL":
                        template += `
                            <li class="dku-border-bottom">
                                <a href="#" ng-click="collapseChildren('`+node.id+`');">
                                    <i class="icon-dku-collapse-all icon-fixed-width" /> Collapse children
                                </a>
                            </li>`;
                        break;
                    default:
                        break;
                }
                template += $scope.getRightClickMenuTemplate(node);

                template += `</ul>`;

                let isElsewhere = function (elt, e) {
                    let result = $(e.target).parents('.dropdown-menu').length == 0;
                    if (result) {
                        delete node.$rightClicked;
                    }
                    return result;
                };

                $scope.popupDismiss = openDkuPopin($scope, $event, {template:template, isElsewhere:isElsewhere, popinPosition:'CLICK'});
            };

            // Return an array containing all the parent nodes and the searched node itself
            function getAncestorsOfNodeId(nodeId, nodes = $scope.rootNodes, ancestors=[]) {
                let n = nodes.find(n => n.id == nodeId);

                if (angular.isDefined(n)) {
                    return ancestors.concat(n);
                } else {
                    for (let i=0; i<nodes.length; i++) {
                        let node = nodes[i];
                        if (node.children && node.children.length > 0) {
                            let r = getAncestorsOfNodeId(nodeId, node.children, ancestors.concat(node));
                            if (r) {
                                return r;
                            }
                        }
                    }
                    return null;
                }
            }

            // Return an array containing all the children nodes and the node itself
            function getDescendantsOfNode(node, descendants=[node]) {
                if (node.children.length > 0) {
                    for (let i=0; i<node.children.length; i++) {
                        let child = node.children[i];
                        let r = getDescendantsOfNode(child, [child]);
                        descendants = descendants.concat(r);
                    }
                }
                return descendants;
            }

            function getNodeFromNodeId(nodeId, nodes = $scope.rootNodes) {
                let n = nodes.find(n => n.id == nodeId);

                if (angular.isDefined(n)) {
                    return n;
                } else {
                    for (let i=0; i<nodes.length; i++) {
                        let node = nodes[i];
                        if (node.children && node.children.length > 0) {
                            let r = getNodeFromNodeId(nodeId, node.children);
                            if (r) {
                                return r;
                            }
                        }
                    }
                    return null;
                }
            }


            /*** Folding & Unfolding functions ***/
            $scope.getTaxonomyMassExpandCollapseStateFn = function() {
                let IDsUnfolded = $scope.getUnfoldedNodeIdsFn();
                let IDsHavingChildren = $scope.getNodeIdsHavingChildrenFn();

                if (IDsHavingChildren.length == 0) {
                    return "";
                } else if (IDsHavingChildren.length > IDsUnfolded.length) {
                    return "EXPAND_ALL";
                } else {
                    return "COLLAPSE_ALL";
                }
            };

            $scope.getNodeMassExpandCollapseStateFn = function(nodeId) {
                let node = getNodeFromNodeId(nodeId);
                if (angular.isDefined(node)) {
                    let descendants = getDescendantsOfNode(node).filter(n => n.id != nodeId);
                    let hasDescendants = descendants.length > 0;
                    let hasCollapsedChildren = !!descendants.find(n => n.$reduced == true && angular.isDefined(n.children) && n.children.length > 0);
                    let hasGrandChildren = !!descendants.find(n => angular.isDefined(n.children) && n.children.length > 0);
                    if (!hasDescendants) {
                        return "";
                    } else if (node.$reduced || hasCollapsedChildren) {
                        return "EXPAND_ALL";
                    } else if (hasGrandChildren) {
                        return "COLLAPSE_ALL";
                    } else {
                        return "";
                    }
                }
            }

            $scope.expandAllFn = function() {
                setReduceMultiple($scope.nodes, false);
            };

            $scope.collapseAllFn = function() {
                setReduceMultiple($scope.nodes, true);
            };

            $scope.expandChildren = function(nodeId) {
                let node = getNodeFromNodeId(nodeId);
                setReduceMultiple([node], false);
            };

            $scope.collapseChildren = function(nodeId) {
                let node = getNodeFromNodeId(nodeId);
                if (angular.isDefined(node.children)) {
                    setReduceMultiple(node.children, true);
                }
            };

            function expandNodes(nodes) {
                setReduceMultiple(nodes, false, false);
            }

            function setReduceMultiple(nodes, fold, recursive = true) {
                if (!angular.isDefined(nodes) || !nodes.length || nodes.length == 0) {
                    return;
                }

                angular.forEach(nodes, function(node) {
                    $scope.setReduceFn(node, fold);

                    if (recursive) {
                        setReduceMultiple(node.children, fold, recursive);
                    }
                });
            }

            $scope.setReduceFn = function(node, reduce) {
                // No need to set the value if it hasn't changed
                if (!angular.isDefined(node) || node.$reduced == reduce) {
                    return;
                }

                if (reduce) {
                    node.$reduced = true;
                } else {
                    delete node.$reduced;
                }

                // Keeping parent aware of this change if he gave us some way to.
                if (typeof($scope.getUnfoldedNodeIdsFn)==="function" && typeof($scope.setUnfoldedNodeIdsFn)==="function") {
                    let unfoldedNodeIds = $scope.getUnfoldedNodeIdsFn();
                    let index = unfoldedNodeIds.indexOf(node.id);

                    if (reduce) {
                        if (index > -1) {
                            unfoldedNodeIds.splice(index, 1);
                        }
                    } else {
                        if (index == -1 && node.children.length > 0) {
                            unfoldedNodeIds.push(node.id);
                        }
                    }
                    $scope.setUnfoldedNodeIdsFn(unfoldedNodeIds);
                }
            }


            /*** Scrolling functions ***/
            $scope.scrollToNodeFn = function(nodeId, duration) {
                let ancestors = getAncestorsOfNodeId(nodeId);

                if (ancestors) {
                    let node = ancestors.pop();
                    expandNodes(ancestors);
                    $timeout(() => $scope.triggerScroll(node, duration));
                }
            };

            $scope.shouldScrollToNode = function(node) {
                return node.$scrollToMe;
            };

            $scope.scrollDuration = function(node) {
                return node.$scrollDuration;
            };

            $scope.triggerScroll = function(node, duration) {
                node.$scrollToMe = true;
                node.$scrollDuration = duration;
            };

            $scope.onScrollTriggered = function(node) {
                node.$scrollToMe = false;
                delete node.$scrollDuration;
            };
        }
    };
});


app.directive("dkuHtmlTooltip", function($timeout, openDkuPopin) {
    return {
        template : '<div ng-mouseover="displayTooltip($event)" ng-mouseleave="removeTooltip()" class="dku-html-tooltip-activation-zone {{triggerClass}}"><div ng-transclude="trigger"></div><div style="display: none;" ng-transclude="content"></div></div>',
        restrict: 'A',
        scope: {
            fromModal: '=?',
            tooltipClass: '@',
            triggerClass: '@',
            position: '@?', // if not present, uses openDkuPopin, otherwises sets the position manually
        },
        transclude: {
            'trigger': 'tooltipTrigger',
            'content': 'tooltipContent'
        },
        link: function($scope, elmnt, attrs) {

            var tooltipDisplayed = false;

            /*
             * _removeTooltip will be returned by openDkuPopin service when popin will actually be displayed.
             * This is b/c openDkuPopin create a new $scope and a DOM element when displaying a popin,
             * and returns a method to destroy this specific scope and remove new DOM element from DOM.
             */
            var _removeTooltip = function() {
                // noop
            };

            $scope.removeTooltip = function() {
                _removeTooltip();
                _removeTooltip = function() {
                    // noop
                };
                tooltipDisplayed = false;
            };

            $scope.displayTooltip = function($event) {
                if (!tooltipDisplayed && (!attrs.dkuHtmlTooltipShow || $scope.$parent.$eval(attrs.dkuHtmlTooltipShow))) {
                    var cssClass = $scope.fromModal ? "dku-html-tooltip from-modal" : "dku-html-tooltip";
                    var content = $(elmnt).find('tooltip-content')[0].innerHTML;
                    var template = `<div class="${cssClass} ${$scope.tooltipClass || ''}">${content}</div>`;
                    var isElsewhere = function (tooltipElement, event) {
                        return $(event.target).parents('.dku-html-tooltip').length == 0 || $(event.target).parents('.dku-html-tooltip')[0] != tooltipElement;
                    };
                    if (
                        ['top', 'bottom', 'left', 'right', 'top-right', 'top-left', 'bottom-right', 'bottom-left'].includes(
                            $scope.position
                        )
                    ) {
                        _removeTooltip = openManuallyPositionedTooltip(template, elmnt, $scope.position);
                    } else {
                        var dkuPopinOptions = {
                            template: template,
                            isElsewhere: isElsewhere,
                            doNotCompile: true
                        };
                        _removeTooltip = openDkuPopin($scope, $event, dkuPopinOptions);
                    }
                    tooltipDisplayed = true;
                }
            };

            /*
             * Opens a tooltip for the element, using the template, at a manually set position
             * (top, bottom, right, left, top-right, top-left, bottom-right, bottom-left)
             * Returns a function that removes the tooltip
             */
            function openManuallyPositionedTooltip(template, element, position) {
                let tooltip = $(template);
                $('body').append(tooltip); //so we have access to dimensions

                let posLeft = 0;
                let posTop = 0;
                // left/top offset of the element
                const left = $(element).offset().left;
                const top = $(element).offset().top;
                // (Outer) width/height of the element
                const outerWidth = $(element).outerWidth();
                const outerHeight = $(element).outerHeight();
                // (Outer) width/heigth of the tooltip
                const tooltipOuterWidth = tooltip.outerWidth();
                const tooltipOuterHeight = tooltip.outerHeight();
                // Margin (= 2 * size of the arrow)
                const margin = 10;

                // We set the tooltip left/top offset according to desired position
                if (position == 'top') {
                    posLeft = left + outerWidth / 2 - tooltipOuterWidth / 2;
                    posTop = top - tooltipOuterHeight - 3 * margin / 2;
                } else if (position == 'top-right') {
                    posLeft = left + outerWidth;
                    posTop = top - tooltipOuterHeight - 3 * margin / 2;
                } else if (position == 'top-left') {
                    posLeft = left - tooltipOuterWidth + margin;
                    posTop = top - tooltipOuterHeight - 3 * margin / 2;
                } else if (position == 'bottom-left') {
                    posLeft = left - tooltipOuterWidth + margin;
                    posTop = top + outerHeight + margin / 2;
                } else if (position == 'bottom-right') {
                    posLeft = left + outerWidth;
                    posTop = top + outerHeight + margin / 2;
                } else if (position == 'bottom') {
                    posLeft = left + outerWidth / 2 - tooltipOuterWidth / 2;
                    posTop = top + outerHeight + margin / 2;
                } else if (position == 'left') {
                    posLeft = left - tooltipOuterWidth - margin / 2;
                    posTop = top - tooltipOuterHeight / 2;
                } else if (position == 'right') {
                    posLeft = left + outerWidth + 3 * margin / 2;
                    posTop = top - tooltipOuterHeight / 2;
                }
                tooltip.css('left', posLeft);
                tooltip.css('top', posTop);
                tooltip.addClass(position); // Adds the arrow at the right position

                $('body').append(tooltip);

                function dismiss() {
                    tooltip.remove();
                }

                return dismiss;
            }
        }
    }
});


app.directive("summaryOfError", function(Dialogs){
    return {
        // No isolated scope because we need to attach modals to the parent
        restrict: 'A',
        scope: true,
        template: '<span style="overflow-y: scroll">\n    <span ng-show="error" class="summary-of-error">\n        <span ng-show="error.title"><strong>{{error.title}}</strong>:</span> \n        <span ng-show="error.detailedMessageHTML" ng-bind-html="error.detailedMessageHTML"/>\n        <span ng-show="!error.detailedMessageHTML">{{error|detailedMessageOrMessage}}</span>\n    </span>\n</span><a style="font-weight: 500; margin-top:10px; font-size: 14px;" ng-click="openMoreInfo()">More info about this error</a>',
        link: function($scope, element, attrs) {

            $scope.$watch(attrs.summaryOfError, function(nv, ov) {
                $scope.error = nv;
            });


            $scope.openMoreInfo = function(){
                 Dialogs.displaySerializedError($scope, $scope.error);
            }
        }
    }
});

    app.directive("errorFixability", function($rootScope, $state){
    return {
        restrict: 'A',
        templateUrl: "/templates/errors/error-fixability.html",
        scope: {
            error : "="
        },
        link: function($scope) {
            $scope.$state = $state;
            $scope.$root = $rootScope;
        }
    }
});

app.directive('barMetrics', function () {
    return {
        scope: {data: '=barMetrics', height:'='},
        template: '<svg class="gpu-bar-metrics"></svg>',
        link: function ($scope, el, attrs) {
            const HEIGHT = $scope.height || 10;

            let svg = d3.select(el[0]).select('svg');
            let defs = svg.append('defs');

            let mainGradient = defs.append('linearGradient')
                .attr('id', 'mainGradient');

            mainGradient.append('stop')
                .attr('class', 'gpu-bar-metrics__stop-left')
                .attr('offset', '0');
            mainGradient.append('stop')
                .attr('class', 'gpu-bar-metrics__stop-right')
                .attr('offset', '1');

            let container = d3.select(el[0]).select('svg').append('g').attr('class', 'container').attr('transform', `translate(0, ${Math.max(HEIGHT/2,10)})`);
            $scope.$watchCollection('data', function (data) {
                if (data) {
                    const PREFIX_WIDTH = el[0].clientWidth / 4;
                    const POSTFIX_WIDTH = el[0].clientWidth / 5;
                    const MAX_BAR_WIDTH = el[0].clientWidth-PREFIX_WIDTH-POSTFIX_WIDTH;
                    const scales = data.map(d => d3.scale.linear().domain([d.min, d.max]).range([0, MAX_BAR_WIDTH]));
                    let g = container.selectAll('g.metric').data($scope.data);
                    let SPACE_BETWEEN = 8;
                    let gEnter = g.enter().append('g').attr('class', 'metric').attr('transform', (d, i) => `translate(0, ${i * (HEIGHT + SPACE_BETWEEN )})`);
                    gEnter.append('rect').attr('x',PREFIX_WIDTH).attr('y',-HEIGHT/2).attr('width', MAX_BAR_WIDTH).attr('height', HEIGHT).classed('gpu-bar-metrics__filled', true);
                    gEnter.append('rect').attr('x',PREFIX_WIDTH).attr('y',-HEIGHT/2).attr('class', 'val-inverted').attr('width', MAX_BAR_WIDTH).attr('height', HEIGHT).attr('fill', '#ececec');
                    gEnter.append('text').attr("alignment-baseline","middle").attr('text-anchor','start').attr('y', 0).attr('height', 50).text(d => d.label).attr('x', 0).attr("font-size", "10px").attr("fill", "grey");

                    gEnter.append('text').attr("alignment-baseline","middle").attr('text-anchor', 'end').attr('class', 'percentage').attr('y', 0).attr('x', el[0].clientWidth).attr("font-size", "10px").attr("fill", "grey");
                    g.select('text.percentage').text(d => `${Math.round(d.value * 100 / d.max)} %`);
                    g.select('rect.val-inverted').transition().attr('width', (d, i) => MAX_BAR_WIDTH - scales[i](d.value)).attr('x', (d, i) => PREFIX_WIDTH + scales[i](d.value));
                }
            });
        }
    }
});

app.directive('gitCheckoutSelect', function (SpinnerService, DataikuAPI) {
    return {
        scope: {
            gitCheckout: '=ngModel',
            gitRepository: '=repository'
        },
        templateUrl: '/templates/widgets/git-checkout-select.html',
        link: function ($scope) {
            $scope.gitCustomCheckout = true;
            $scope.gitLoadedRefsRepo = ''; // The repository where the currently loaded references are from

            $scope.$watch('gitRepository', function(nv) {
                if (nv && nv !== '') {
                    // When you change the input repository, you shouldn't have the old references list
                    $scope.gitCustomCheckout = $scope.gitRepository !== $scope.gitLoadedRefsRepo;
                }
            });

            $scope.listRemoteRefs = function () {
                // If the parent scope can show the error (`block-api-error` directive), it'll be better presented that way
                // Otherwise, we'll display it in that directive
                const errorScope = angular.isFunction($scope.$parent.setError) ? $scope.$parent : $scope;

                if ($scope.gitRepository && $scope.gitRepository !== '') {
                    resetErrorInScope(errorScope);

                    SpinnerService.lockOnPromise(DataikuAPI.git.listRemoteRefs($scope.gitRepository)
                        .then(function(response) {
                            $scope.gitCheckoutRefs = response.data;
                            $scope.gitCustomCheckout = false;
                            $scope.gitLoadedRefsRepo = $scope.gitRepository
                        }, function(err) {
                            $scope.gitCheckoutRefs = [];
                            $scope.gitCustomCheckout = true;
                            $scope.gitLoadedRefsRepo = '';
                            errorScope.setError(err);
                        })
                    )
                }
            };
        }
    }
});

app.directive('gpuOnlineStats', function ($interval, Notification,Logger) {
    return {
        scope: {metrics:"=", selected:"=", selectable:"="},
        transclude: true,
        restrict: 'A',
        template: `<div ng-if="gpuCount" class="gpu-online-stats-wrapper">
                        <div ng-show="gpuStats && gpuResponse.status === 'OK'" ng-repeat="i in range(gpuCount)" class="gpu-online-stats__gpu-block" ng-click="selectable && selected && clickOnGpu(i)" ng-class="{selected:isGPUselected(i),'gpu-online-stats__gpu-block--selectable':selectable }">
                            <i class="icon icon-dku-gpu-card"></i>
                            <div>
                                <div class="gpu-online-stats__title"><span>{{gpuResponse.stats[i].name}} [{{gpuResponse.stats[i].index}}]</span><span class="gpu-online-stats__secondary-title">{{gpuResponse.stats[i].memoryTotal}} MB</span></div>
                                <div bar-metrics="gpuStats[i]" class="gpu-online-stats__gpu-graph" height="6"></div>
                            </div>
                        </div>
                    </div>
                    <div class="alert alert-error" ng-show="gpuResponse.status === 'ERROR'" style="text-align: center">
                        <span>{{gpuResponse.error}}</span>
                    </div>`,
        link: function (scope, element, attrs, ctrl, transclude) {
            if (scope.selected && !(scope.selected instanceof Array)) {
                Logger.error(`gpuOnlineStats directive accepts a Array as a <selected> parameter, but ${scope.selected.constructor.name} was given`)
                scope.selected = null;
            }
            Notification.publishToBackend('gpu-monitoring-start');

            let KEEP_ALIVE_INTERVAL_MS = 2*1000;
            let cancelKeepAlive = $interval(function () {
                Notification.publishToBackend('timeoutable-task-keepalive', {
                    taskId: "gpu-monitoring"
                });
            }, KEEP_ALIVE_INTERVAL_MS);
            scope.range = function (n) {
                return Array.range(n);
            };

            scope.clickOnGpu = i => {
                if (!scope.selected.includes(i)){
                    scope.selected.push(i);
                } else {
                    scope.selected.splice(scope.selected.indexOf(i),1);
                }
            };
            scope.isGPUselected = i => scope.selected && scope.selected.includes(i);

            scope.$on('$destroy', function () {
                $interval.cancel(cancelKeepAlive);
            });
            Notification.registerEvent("gpu-stats-response", function (evt, message) {
                scope.gpuResponse = message.response;
                if (scope.gpuResponse.status === 'OK') {

                    scope.gpuStats = message.response.stats.map(g => [{
                        label: 'Memory',
                        value: g.memoryUsed,
                        min: 0,
                        max: g.memoryTotal
                    }, {
                        label: 'GPU',
                        value: g.utilizationGpu,
                        min: 0,
                        max: 100
                    }].filter(d => d.value !== undefined && (!scope.metrics || scope.metrics.includes(d.label))));
                    scope.gpuCount = scope.gpuStats.length;
                }
            });
        }
    }
});
    app.directive('gpuSelector', function (Notification, $rootScope,DataikuAPI, $stateParams) {
        return {
            scope : {gpuSelector:'=', selectedEnv:'=', name:'@', inContainer:'='},
            controller: function ($scope) {
                let lastGpuStats;
                if (!$scope.gpuSelector.perGPUMemoryFraction){
                    $scope.gpuSelector.perGPUMemoryFraction = 0.7;
                }
                $scope.uiState = {};
                if ($scope.inContainer) {
                    $scope.uiState.numGpus = $scope.gpuSelector.gpuList.length;
                }
                $scope.updateGpuSelectionCheckbox = function () {
                    if ($scope.gpuSelector.gpuList.length >= 0 && $scope.gpuSelector.gpuList.length !== $scope.GPUcount) {
                        for (let i = 0; i < $scope.GPUcount; i++) {
                            !$scope.gpuSelector.gpuList.includes(i) && $scope.gpuSelector.gpuList.push(i);
                        }
                    } else {
                        // clear the array
                        $scope.gpuSelector.gpuList.length = 0;
                    }
                };
                Notification.registerEvent("gpu-stats-response", function (evt, message) {
                    $scope.GPUstatus = message.response.status;
                    if (!$scope.GPUcount) {
                        $scope.GPUcount = message.response.stats.length;
                    }
                    lastGpuStats = message.response.stats;
                });
                $scope.$watch('gpuSelector.useGPU', (nv, ov) => {
                    if (!ov && nv && lastGpuStats) {
                        let mostAvailableGpuIdx = lastGpuStats.sort((a, b) => a.memoryUsed - b.memoryUsed)[0].index;
                        $scope.gpuSelector.gpuList = [mostAvailableGpuIdx];
                    }
                });
                $scope.numGpusChange = function() {
                    if ($scope.uiState.numGpus && $scope.uiState.numGpus > 0) {
                        $scope.gpuSelector.gpuList = Array.range($scope.uiState.numGpus);
                    }
                };
                if (!$rootScope.appConfig.isAutomation) {
                    DataikuAPI.codeenvs.listWithVisualMlPackages($stateParams.projectKey).success(function (data) {
                        let env = data.envs.find(el=>el.envName === $scope.selectedEnv);
                        $scope.envSupportsGpu = env && env.deepLearning.supportsGpu;
                        if (!$scope.envSupportsGpu) {
                            $scope.gpuSelector.useGPU = false;
                        }
                    });
                } else {
                    $scope.envSupportsGpu = true;
                }
            },
            // language=HTML
            template: `
                <div>
                    <h2 class="settings-section-title" style="line-height: 27px;">
                        <label class="dku-toggle" style="margin: 0 5px 0 0">
                            <input type="checkbox"
                                   ng-model="gpuSelector.useGPU"
                                   disabled-if="!envSupportsGpu"
                            >
                            <span/>
                        </label>
                        {{name}}
                    </h2>

                    <form class="dkuform-horizontal">
                        <div class="help-inline" ng-if="!gpuSelector.useGPU && !envSupportsGpu">
                            The selected environment ({{selectedEnv}}) doesn't have the required packages installed to activate training on GPU.
                        </div>
                        <div ng-if="gpuSelector.useGPU">
                            <div ng-if="!inContainer" gpu-online-stats selectable="true" metrics="['GPU','Memory']" on-click="clickOnGpu" selected="gpuSelector.gpuList"></div>
                            <div ng-if="inContainer">
                                <div class="dkuform-horizontal">
                                    <div class="control-group">
                                        <label class="control-label">Number of GPU(s)</label>
                                        <div class="controls">
                                            <input type="number" min="1" step="1" required ng-model="uiState.numGpus" ng-change="numGpusChange()"/>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div ng-show="(GPUstatus === 'OK') || inContainer">
                                <div class="dkuform-horizontal">

                                    <div class="control-group">
                                        <label class="control-label">Memory allocation rate per GPU</label>
                                        <div class="controls">
                                            <input type="number" min="0.1" max="1" step="0.1" required ng-model="gpuSelector.perGPUMemoryFraction"/>
                                        </div>
                                    </div>
                                    <div class="control-group">
                                        <label class="control-label">Allow growth</label>
                                        <div class="controls">
                                            <input type="checkbox" ng-model="gpuSelector.gpuAllowGrowth"/>
                                            <div class="help-inline">Allocate only as much GPU memory as needed. Experimental.</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </form>
                </div>
            `
        }

    });

    /*
        See NPSSurveyState for NPS survey timing logic
    */
    app.component('npsSurvey', {
        templateUrl: '/templates/widgets/nps-survey.html',
        bindings: {
            appConfig: '='
        },
        controller: ['$scope', '$timeout', '$filter', 'DataikuAPI', 'WT1',
            function npsSurveyCtrl($scope, $timeout, $filter, DataikuAPI, WT1) {
                const ctrl = this;
                ctrl.Actions = {
                    NEW: 1,
                    SUBMIT: 2,
                    POSTPONE: 3,
                    OPTOUT: 4
                };
                ctrl.showSurvey = false;
                ctrl.active = false;
                ctrl.finished = false;
                ctrl.scores = Array.from({length: 10}, (_, i) => (i + 1));
                ctrl.response = '';

                ctrl.$onInit = function() {
                    if (this.appConfig && this.appConfig.npsSurveyActive) {
                        ctrl.email = this.appConfig.user && this.appConfig.user.email ? this.appConfig.user.email : ''
                        ctrl.showSurvey = true;
                        $timeout(function() { ctrl.active = true; });
                    }
                };

                ctrl.finish = function(action) {
                    // if user clicks on something after submitting
                    if (ctrl.finished) {
                        return;
                    }

                    DataikuAPI.profile.setNPSSettings(action).success((data) => {
                        let eventParams = {
                            action: action,
                            npsState: data && data.state ? data.state : ''
                        };

                        if (action === 'SUBMIT') {
                            WT1.event('nps-survey', angular.extend(eventParams, {
                                score: ctrl.surveyScore,
                                response: $filter('escapeHtml')(ctrl.response || ''),
                                email: $filter('escapeHtml')(ctrl.email || '')
                            }));
                            ctrl.finished = true;
                            // for animation
                            $timeout(function() {
                                ctrl.active = false;
                                $timeout(function() { ctrl.showSurvey = false; }, 1000);
                            }, 1000);
                        } else {
                            // for animation
                            ctrl.active = false;
                            $timeout(function() { ctrl.showSurvey = false; }, 1000);

                            WT1.event('nps-survey-decline', eventParams);
                        }
                    }).error(setErrorInScope.bind($scope));
                };

                ctrl.selectScore = function(score) {
                    ctrl.surveyScore = score;
                };
            }
        ]
    });


/*
    Tiny directive to handle the display of a sort icon in a table.

    Fields:
      * isSortCol: whether the current col is used for sorting (and the icon should be displayed)
      * ascending: whether the sort is ascending
      * iconOnRight: whether the icon is put on the right of the column name

    Besides, if you want to display a grayer version of the icon when hovering on the column name,
    your must add the .contains-sort-by-column-icon in the container of the column

    Example:
        <div class="my-container contains-sort-by-column-icon">
            <span>My title column</span>
            <sort-by-column-icon isSortCol="isSortCol" ascending="selection.orderReverse" icon-on-right="true"></sort-by-column-icon>
        </div>
*/
app.directive("sortByColumnIcon", function() {
    return {
        scope: {
            isSortCol: "=",
            ascending: "=",
            iconOnRight: "@"
        },
        template: `<div class="sort-by-column-icon__wrapper" ng-class="iconOnright ? 'icon-on-right' : 'icon-on-left'">
                      <i ng-if="!isSortCol" class="icon-sort-by-attributes-alt sort-by-column-icon--display-on-hover"></i>
                      <i ng-if="isSortCol && ascending" class="icon-sort-by-attributes"></i>
                      <i ng-if="isSortCol && !ascending" class="icon-sort-by-attributes-alt"></i>
                   </div>`
    }
});

/*
    Binary Classification Confusion Matrix widget
*/
app.directive("bcConfusionMatrix", function() {
    return {
        templateUrl:"/templates/widgets/bc_confusion_matrix.html",
        scope: {
            modelClasses: "=",
            data: "=",
            displayMode: "=",
            metricsWeighted: "="
        },
        controller: function($scope) {

            $scope.getMaybeWeighted = function(x) {
                if (typeof x !== 'number') {
                    return x; // for when it's percentage
                }
                return $scope.metricsWeighted ? x.toFixed(2) : x.toFixed(0);
            };

            // Signal to Puppeteer that the content of the element has been loaded and is thus available for content extraction
            $scope.puppeteerHook_elementContentLoaded = true;
        }
    }
});

/*
    Multi Classification Confusion Matrix widget
*/
app.directive("mcConfusionMatrix", function() {
    return {
        templateUrl:"/templates/ml/prediction-model/mc_confusion.html",
        scope: {
            modelData: "=",
            displayMode: "="
        },
        controller: 'MultiClassConfusionMatrixController'
    }
});

/**
 * Generic component that displays a d3 brush.
 */
app.directive('rangeBrush', function(Fn) {
    return {
        restrict : 'A',
        templateUrl : '/templates/widgets/range-brush.html',
        scope : {
            range : '=',
            selectedRange : '=',
            onChange : '&',
            onDrillDown : '&',
            snapRanges : '=',
            onInit: '&',
            brushWidth: '@',
            enablePadding: '=?'
        },
        replace : true,
        link : function($scope, element) {
            $scope.enablePadding = angular.isDefined($scope.enablePadding) ? $scope.enablePadding : true;

            const padding = $scope.enablePadding ? 10 : 4; // 4 to be able to display the handles
            const brushHeight = 60;
            const dateLineHeight = 25;
            const triggerHeight = 18;
            const triggerWidth = 0.8 * triggerHeight;
            const handleHeight = 20;
            const handleWidth = 8;
            const separatorHeight = 3;
            const separatorOffset = -2;

            // the svg needs to update when the width changes (different # of ticks, for ex)
            var eventName = 'resize.brush.' + $scope.$id;
            $(window).on(eventName, function() { if ( $scope.range != null ) $scope.refreshRange();});
            $scope.$on('$destroy', function(){$(window).off(eventName)});
            // also add a watch on the width for the cases where the size changes as a result of
            // stuff being shown/hidden
            $scope.$watch(
                function () {return element.width();},
                function (newValue, oldValue) { if ( $scope.range != null ) $scope.refreshRange(); }
            );

            // get the brush : the root of the template
            var brushSvg = d3.select(element[0]);
            // resize
            brushSvg.attr("height", brushHeight);

            // add stuff in the svg (layer in this order: to get the display and click-sensitivity right)
            var xAxisG = brushSvg.append("g").attr("class", "x axis").attr("transform", "translate(0, " + dateLineHeight + ")");
            
            var brushG = brushSvg.append("g").attr("class", "x brush"); // brush (catches mouse events to drag handles and brush extend)
            var triggersG = brushSvg.append("g").attr("class", "x triggers").attr("transform", "translate(0, " + dateLineHeight + ")"); // layer with the triggers, clickable
            var brushInversionG = brushSvg.append("g").attr("class", "x brush-inversion"); // the inverse of the brush (click-through)
            var brushHandlesG = brushSvg.append("g").attr("class", "x brush-handles"); // the brush handles (click-through)
            var brushContentG = brushSvg.append("g").attr("class", "x brush-content"); // where to append stuff (like chart preview)

            const brushContentWidth = $scope.brushWidth - (2 * padding);

            if ($scope.brushWidth) {
                brushSvg.style("width", $scope.brushWidth + 'px');
                brushContentG.attr("transform", "translate(" + padding + ", 0)");
                brushContentG.attr("width", brushContentWidth);
            }

            brushSvg.on('dblclick', function(e) {
                var insideExtent = false;
                if ( xScale != null ) {
                    var pos = d3.mouse(element[0]);
                    var xPos = xScale.invert(pos[0]).getTime();
                    insideExtent = $scope.selectedRange.from < xPos && $scope.selectedRange.to > xPos;
                }
                if (insideExtent && $scope.onDrillDown() != null) {
                    // why can't I pass the first () in the html? dunno...
                    $scope.onDrillDown()($scope.selectedRange.from, $scope.selectedRange.to);
                } else {
                    $scope.selectedRange.from = $scope.range.from;
                    $scope.selectedRange.to = $scope.range.to;
                    $scope.refreshRange();
                    $scope.onChange();
                }
            });

            var xScale = null;

            // update the total range, and then the graph
            $scope.refreshRange = function() {
                if ( $scope.range == null || $scope.selectedRange == null ) {
                    return;
                }
                var width = $(element).innerWidth();
                // the full range we are selecting in
                var axisRange = [new Date($scope.range.from), new Date($scope.range.to)];
                // the selected range
                var extentRange = $scope.selectedRange.from > 0 ? [new Date($scope.selectedRange.from), new Date($scope.selectedRange.to)] : axisRange;
                // make the scale
                xScale = d3.time.scale().domain(axisRange).range([padding, width - padding]);
                // prepare the brush callback
                var brushed = function() {
                    var extent = brush.extent();
                    // If we are simply clicking on the brush (one point interval), go back to previous range.
                    if (extent[1] - extent[0] === 0) { 
                        extent[0] = new Date($scope.selectedRange.from);
                        extent[1] = new Date($scope.selectedRange.to); 
                    }
                    if (d3.event.mode === "move") {
                        if ( $scope.rounding == 'day') {
                            var startDay = d3.time.day.round(extent[0]);
                            var daySpan = Math.round((extent[1] - extent[0]) / (24 * 3600 * 1000));
                            var endDay = d3.time.day.offset(startDay, daySpan);
                            extent = [startDay, endDay];
                        }
                    } else {
                        if ( $scope.rounding == 'day') {
                            extent = extent.map(d3.time.day.round);
                            if (extent[0] >= extent[1] ) {
                                extent[0] = d3.time.day.floor(extent[0]);
                                extent[1] = d3.time.day.ceil(extent[1]);
                            }
                        }
                    }
                    d3.select(this).call(brush.extent(extent));
                    var xS = xScale(extent[0]);
                    var xE = xScale(extent[1]);
                    brushInversionG.selectAll('.s').attr("x", 0).attr("width", xS);
                    brushInversionG.selectAll('.e').attr("x", xE).attr("width", width - xE);
                    brushHandlesG.selectAll(".s").attr("transform", "translate(" + xS + ", 0)");
                    brushHandlesG.selectAll(".e").attr("transform", "translate(" + xE + ", 0)");

                    $scope.selectedRange.from = extent[0].getTime();
                    $scope.selectedRange.to = extent[1].getTime();
                    $scope.onChange();
                };

                // make the brush
                var brush = d3.svg.brush().x(xScale).on("brush", brushed).extent(extentRange);
                // make the axis from the scale
                var xAxis = d3.svg.axis().scale(xScale).tickFormat(Fn.getCustomTimeFormat()).orient("top").tickSize(-(brushHeight - dateLineHeight));
                // and create the svg objects
                var a = xAxisG.call(xAxis);
                var b = brushG.call(brush);
                triggersG.selectAll("*").remove();
                var t = triggersG.selectAll(".trigger").data($scope.snapRanges);

                var xS = xScale(extentRange[0]);
                var xE = xScale(extentRange[1]);

                // draw the triggers
                var triggerPadding = (brushHeight - dateLineHeight - triggerHeight) / 2;
                t.enter().append("path")
                    .classed("trigger", true)
                    .classed("success", function(d) {return d.outcome == 'SUCCESS';})
                    .classed("failed", function(d) {return d.outcome == 'FAILED';})
                    .classed("aborted", function(d) {return d.outcome == 'ABORTED';})
                    .classed("warning", function(d) {return d.outcome == 'WARNING';})
                    .attr("d", function(d) { return "M" + xScale(new Date(d.start)) + "," + triggerPadding + " l"+triggerWidth+","+(triggerHeight/2)+" l-"+triggerWidth+","+(triggerHeight/2)+" z"; })
                    .on("click", function(d){
                        $scope.selectedRange.from = d.start; $scope.selectedRange.to = d.end; $scope.refreshRange(); $scope.onChange();
                    });

                // remove the axis line
                a.selectAll(".domain").remove();

                // style the brush
                b.selectAll("rect").attr("y", 0).attr("height", brushHeight);
                // create the handles the handles
                brushHandlesG.selectAll(".resize").remove();
                brushHandlesG.append("g").classed("resize", true).classed("s", true).attr("transform", "translate(" + xS + ", 0)");
                brushHandlesG.append("g").classed("resize", true).classed("e", true).attr("transform", "translate(" + xE + ", 0)");
                var bh = brushHandlesG.selectAll(".resize");
                bh.append("rect").classed("separator", true).attr("y", 0).attr("height", brushHeight).attr("x", separatorOffset).attr("width", separatorHeight);
                bh.append("rect").classed("handle", true).attr("y", (brushHeight - handleHeight) / 2).attr("height", handleHeight).attr("x", -(handleWidth/2)).attr("width", handleWidth);
                // add the invert of the brush for the overlay outside of the brush
                brushInversionG.selectAll("rect").remove();
                brushInversionG.append("rect").attr("x", 0).attr("width", xS).attr("y", 0).attr("height", brushHeight).classed("s", true);
                brushInversionG.append("rect").attr("x", xE).attr("width", width - xE).attr("y", 0).attr("height", brushHeight).classed("e", true);
            };

            // add event handler to adjust the brush when the selection changes
            $scope.$watch('range', function(nv, ov) {
                if ( nv == null ) return;
                $scope.refreshRange();
            }, true);
            $scope.$watch('snapRanges', function(nv, ov) {
                if ( nv == null ) return;
                $scope.refreshRange();
            }, true);
            $scope.$watch('selectedRange', function(nv, ov) {
                if ( nv == null ) return;
                $scope.refreshRange();
            }, true);
            $scope.$watch('brushWidth', function(nv, ov) {
                brushSvg.style("width", $scope.brushWidth + 'px');
            }, true);

            $scope.onInit && typeof $scope.onInit === 'function' && $scope.onInit({ brushContentG: brushContentG, brushContentHeight: brushHeight, brushContentWidth: brushContentWidth });
        }
    };
});
app.directive('datasetCreatorSelector', function ($parse) {
    return {
        templateUrl: '/templates/widgets/dataset-creator-selector.html',
        require:'^ngModel',
        scope: {
            ngModel: '=',
            managedDatasetOptions: '=',
            newDataset: '=',
            canCreate: '=',
            canSelectForeign: '=',
            markCreatedAsBuilt: '=',
            qa: '@'
        },
        controller: ['$scope', 'DataikuAPI', '$stateParams', 'DatasetUtils', function ($scope, DataikuAPI, $stateParams, DatasetUtils) {
            addDatasetUniquenessCheck($scope, DataikuAPI, $stateParams.projectKey);
            $scope.partitioningOptions = [{id: "NP", label: "Not partitioned"}];
            $scope.io = {"newOutputTypeRadio": "create"};
            $scope.uiState = {mode:'select'};

            $scope.isCreationAllowed = angular.isDefined($scope.canCreate) ? $scope.canCreate : true;

            $scope.getDatasetCreationSettings = function () {
                let datasetCreationSetting = {
                    connectionId: ($scope.newDataset.connectionOption || {}).id,
                    specificSettings: {
                        overrideSQLCatalog: $scope.newDataset.overrideSQLCatalog,
                        overrideSQLSchema: $scope.newDataset.overrideSQLSchema,
                        formatOptionId: $scope.newDataset.formatOptionId,
                    },
                    partitioningOptionId: $scope.newDataset.partitioningOption,
                    inlineDataset: $scope.inlineDataset,
                    zone : $scope.zone,
                    markCreatedAsBuilt: $scope.markCreatedAsBuilt,
                };
                if ($scope.newDataset &&
                    $scope.newDataset.connectionOption &&
                    $scope.newDataset.connectionOption.fsProviderTypes &&
                    $scope.newDataset.connectionOption.fsProviderTypes.length > 1) {
                    datasetCreationSetting['typeOptionId'] = $scope.newDataset.typeOption;
                }
                return datasetCreationSetting;
            };

            $scope.createAndUseNewOutputDataset = function (force) {
                const projectKey = $stateParams.projectKey,
                    datasetName = $scope.newDataset.name,
                    settings = $scope.getDatasetCreationSettings();

                if (force) {
                    doCreateAndUseNewOutputDataset(projectKey, datasetName, settings);
                } else {
                    DataikuAPI.datasets.checkNameSafety(projectKey, datasetName, settings).success(data => {
                        $scope.uiState.backendWarnings = data.messages;
                        if (!data.messages || !data.messages.length) {
                            doCreateAndUseNewOutputDataset(projectKey, datasetName, settings);
                        }
                    }).error(setErrorInScope.bind($scope));
                }
            };

            function doCreateAndUseNewOutputDataset(projectKey, datasetName, settings) {
                DataikuAPI.datasets.newManagedDataset(projectKey, datasetName, settings)
                    .success(dataset => {
                        DatasetUtils.listDatasetsUsabilityForAny($stateParams.projectKey).success((data) => {
                            $scope.uiState.mode = 'select';
                            if (!$scope.canSelectForeign) {
                                data = data.filter(fs => fs.localProject);
                            }
                            $scope.availableDatasets = data;
                            $scope.uiState.model = dataset.name;
                        });
                    }).error(setErrorInScope.bind($scope));
            }

            DatasetUtils.listDatasetsUsabilityForAny($stateParams.projectKey).success((data) => {
                if (!$scope.canSelectForeign) {
                    data = data.filter(fs => fs.localProject);
                }
                $scope.availableDatasets = data;
            });

            DataikuAPI.datasets.getManagedDatasetOptionsNoContext($stateParams.projectKey).success(function (data) {
                $scope.managedDatasetOptions = data;
                if (!$scope.newDataset.connectionOption && data.connections.length) {
                    const fsConnection = data.connections.find(e => {
                        return 'Filesystem' === e.connectionType;
                    });
                    if (fsConnection) {
                        $scope.newDataset.connectionOption = fsConnection;
                    } else {
                        $scope.newDataset.connectionOption = data.connections[0];
                    }
                }
                if (!$scope.newDataset.formatOptionId && $scope.newDataset.connectionOption.formats.length) {
                    $scope.newDataset.formatOptionId = $scope.newDataset.connectionOption.formats[0].id;
                }
                $scope.partitioningOptions = [
                    {"id": "NP", "label": "Not partitioned"},
                ].concat(data.projectPartitionings);

            });
        }],
        link: function (scope, el, attrs, ngModel) {
            scope.uiState = scope.uiState || {};
            scope.uiState.model = $parse(attrs.ngModel)(scope.$parent);
            scope.$watch("uiState.model", (nv, ov) => {
                if (ov === nv) return;
                if (nv === ngModel.$viewValue) return;
                // set the new value in the field and render
                ngModel.$setViewValue(nv);
                ngModel.$render();
            });
            scope.$watch("ngModel", (nv, ov) => {
                if (ov === nv) return;
                if (nv === scope.uiState.model) return;
                scope.uiState.model = ngModel.$viewValue;
            });
        }
    }
})

    /**
     * Display tags list if it fits else only one + the rest inside a popover.
     *
     * @param {Array}   items                   - List of the tags to display
     * @param {Object}  tagsMap                 - Map of all the available tags. Used mainly to get the tag colors
     * @param {Array}   globalTagsCategories    - List of existing global tag categories applying to this object type
     * @param {string}  objectType              - Taggable type of the object on which the tags are applied
     *
     * <responsive-tags-list items="item.tags" tags-map="projectTagsMap" object-type="'OBJECT_TYPE'"></responsive-tags-list>
     *
     * (!) The directive will throw an error if the parent's scope does not contain:
     * - selectTag(): the method that will be called on tag click.
     * - selection.filterQuery: the query that will contain the selected tags.
     */
    app.directive('responsiveTagsList', function ($timeout, Assert) {
        return {
            templateUrl: '/templates/analysis/responsive-tags-list.html',
            scope: {
                items: '<',
                tagsMap: '<',
                globalTagsCategories: '<',
                objectType: '<',
                editable: '=?'
            },
            link: function ($scope, $element) {
                const ELLIPSIS_BUTTON_WIDTH = 45;
                let tagsListObserver;
                let tagsListContainer;
                $scope.canTagsFit = true;

                const parentScope = $scope.$parent;
                if ($scope.objectType === 'PROJECT') {
                    Assert.inScope(parentScope, 'onStartTagEdit');
                } else if ($scope.editable) {
                    Assert.inScope(parentScope, 'selectTag');
                    Assert.inScope(parentScope, 'selection.filterQuery');
                }

                // Bootstrap Popover's generated content sometimes looses AngularJS scope.
                // So we cannot rely on the later and therefore have to handle tag click through window object.
                // See https://github.com/angular/angular.js/issues/1323
                if (!window.globalPopoverTagClickCallback) {
                    const startTagEditCallback = function (event) {
                        const category = $(event.target).attr('data-category');
                        parentScope.onStartTagEdit(event, category);
                    }
                    const selectTagCallback = function (event) {
                        const tag = $(event.target).closest('.responsive-tags-list__tag').attr('data-tag');
                        parentScope.selectTag(parentScope.selection.filterQuery, tag.trim());
                        parentScope.$apply();
                        $scope.$apply();
                    };
                    window.globalPopoverTagClickCallback = $scope.objectType === 'PROJECT' ? startTagEditCallback : selectTagCallback;
                    parentScope.$on('$destroy', () => {
                        delete window.globalPopoverTagClickCallback;
                    });
                }

                function computeFittingTags(tagsList) {
                    const fittingTags = { tags: [], categories: [] };
                    const containerHeight = tagsListContainer.offsetHeight;
                    const containerWidth = tagsListContainer.offsetWidth;

                    for (let index = 0; index < tagsList.length; index++) {
                        const tag = $(tagsList[index])[0];
                        const heightFits = tag.offsetTop + tag.offsetHeight < containerHeight;
                        const isLastLine = tag.offsetTop + 2 * tag.offsetHeight > containerHeight;
                        const widthFits = !isLastLine || tag.offsetLeft + tag.offsetWidth + ELLIPSIS_BUTTON_WIDTH < containerWidth;
                        if (heightFits && widthFits) {
                            if (index < $scope.items.length) {
                                fittingTags.tags.push($scope.items[index]);
                            } else if ($scope.globalTagsCategories && index < $scope.items.length + $scope.globalTagsCategories.length) {
                                fittingTags.categories.push($scope.globalTagsCategories[index - $scope.items.length]);
                            }
                        } else if (!heightFits) {
                            break;
                        }
                    }
                    return fittingTags;
                }

                if (!('IntersectionObserver' in window)) {
                    // Graceful degradation: will simply drop the tags in a scrollable area.
                    $scope.hasFitBeenChecked = true;
                } else {
                    const options = {
                        threshold: [0, 0.5, 1],
                        root: $element[0].parentElement
                    };
                    const intersectionCallback = (entries) => {
                        $scope.canTagsFit = entries[0].intersectionRatio === 1;

                        tagsListContainer = $element[0].parentElement;
                        if (!$scope.canTagsFit && entries[0].intersectionRatio > 0) {
                            $scope.fittingTags = computeFittingTags(entries[0].target.children);
                        }
                        $scope.hasFitBeenChecked = true;
                        $scope.$apply();
                    }
                    tagsListObserver = new IntersectionObserver(intersectionCallback, options);
                    // Wait for template to be injected before checking
                    $timeout(() => {
                        tagsListObserver.observe($element[0].querySelector('#tag-list'));
                    }, 0);
                }

                // Detect element resize
                const resizeObserver = new ResizeObserver(entries => {
                    // display #tag-list to trigger intersectionObserver
                    // and see which tags fit if it overflows
                    $scope.canTagsFit = true;
                    $timeout(() => $scope.$apply());
                });
                resizeObserver.observe($element[0].parentElement);

                $scope.$watch("items.length", () => {
                    // display #tag-list to trigger intersectionObserver
                    // and see which tags fit if it overflows
                    $scope.canTagsFit = true;
                });

                $scope.$on('$destroy', () => {
                    tagsListObserver && tagsListObserver.disconnect();
                    resizeObserver && resizeObserver.disconnect();
                });
            }
        }
    });

    app.directive('codeViewer', function() {
        return {
            restrict: 'AE',
            replace: true,
            templateUrl : '/templates/widgets/code-viewer.html',
            scope : {
                code : '<',
                mimeType : '@'
            },
            controller : function($scope, CodeMirrorSettingService) {
                $scope.codeMirrorSettings = CodeMirrorSettingService.get(
                    $scope.mimeType || 'text/plain', {onLoad: function(cm){
                        cm.setOption("readOnly", true);
                        $scope.codeMirror = cm;
                    }}
                )
            }
        }
    });

    /**
     * Directive for managing a list of steps
     * 
     * Example usage:
     * <div stepper="stepperState.stepInfo" current-step="stepperState.currentStep" disable-steps="!disableSteps" />
     * 
     * stepper (steps): An array of step objects
     * - step object:
     *   - label:       step header
     *   - description: step subtitle
     *   - getError(): function which returns an error message if there is one
     *   - getWarning(): function with returns a warning message if there is one (errors take precedence)
     *   - postAction(): function called right after leaving a step
     * currentStep: variable containing the current step (integer)
     * disableSteps: boolean for disabling step interaction (use a function to disable individual steps)
     */
    app.directive('stepper', function() {
        return {
            restrict: 'A',
            templateUrl: "/templates/widgets/stepper.html",
            scope: {
                steps: '<stepper',
                currentStep: '=',
                disableSteps: '<'
            },
            link : function(scope, element, attrs) {
                let previousStep = scope.currentStep;

                function goToStep() {
                    if (previousStep === scope.currentStep) return;

                    const stepInfo = scope.steps[previousStep];
    
                    // perform actions before leaving previous step
                    if (stepInfo && stepInfo.postAction) {
                        stepInfo.postAction();
                    }

                    previousStep = scope.currentStep;
                }

                scope.stepClicked = function(step) {
                    if (!scope.disableSteps && scope.currentStep !== step) {
                        scope.currentStep = step;
                    }
                }

                scope.$watch('currentStep', goToStep);
            }
        };
    });
    app.directive('stepperStep', function() {
        return {
            restrict: 'A',
            templateUrl: "/templates/widgets/stepper-step.html",
            scope: {
                stepNumber: '<',
                step: '<stepperStep',
                isLastStep: '<',
                isCurrentStep: '<',
                isCompletedStep: '<',
                disableStep: '<'
            },
            link: function(scope, element, attrs) {
                scope.step.getError = scope.step.getError || (() => '');
                scope.step.getWarning = scope.step.getWarning || (() => '');
            }
        };
    });

    /** Discrete progress ring with different sections (can be styled in css).
     * values           Array of values (each value is the number of sections for a given class)
     * maximum          Maximum number of sections
     * centerValue      Value to be shown in the center of the progress ring
     * classes          Array of classes for styling
     * classNotFilled   Class of the remaining sections if maximum > sum of values
     * radius           Radius of the progress ring (in px)
     * strokeWidth      Width of the stroke (in px)
     * maxAngle         Maximum angle of the progress ring (180 = half circle / 360 = full circle) (in deg)
     **/
    app.component('progressRing', {
        templateUrl: '/templates/widgets/progress-ring.html',
        bindings: {
            values: '<',
            maximum: '<',
            centerValue: '<',
            classes: '<',
            classNotFilled: '@',
            radius: '<',
            strokeWidth: '<',
            maxAngle: '<',
        },
        controller: [
            function () {
                const ctrl = this;

                ctrl.$onChanges = function (changes) {
                    reDraw();
                };

                function reDraw() {
                    // Compute width and height of the svg depending on the radius and maxAngle
                    ctrl.svgWidth = ctrl.maxAngle > 180 ? 2 * ctrl.radius : (ctrl.maxAngle / 180) * 2 * ctrl.radius;

                    if (ctrl.maxAngle < 90) {
                        ctrl.svgHeight = (ctrl.maxAngle / 90) * ctrl.radius;
                    } else if (ctrl.maxAngle < 180) {
                        ctrl.svgHeight = ctrl.radius;
                    } else if (ctrl.maxAngle < 270) {
                        ctrl.svgHeight = (ctrl.maxAngle / 90 - 1) * ctrl.radius;
                    } else {
                        ctrl.svgHeight = 2 * ctrl.radius;
                    }
                    ctrl.svgHeight += 2; // To make room for the center value

                    const numberOfSections = ctrl.values.reduce((a, b) => a + b);
                    if (numberOfSections > ctrl.maximum) {
                        // If maximum is smaller than sum of values, use sum of values as maximum
                        ctrl.maximum = numberOfSections;
                    }

                    // 0.5px spacing between "sections"
                    let spacingInDegrees = 0.5 * ctrl.maxAngle / ctrl.radius;
                    // Single "section" size in degrees, taking into account the spacing between each one of them
                    let sectionInDegrees =
                        (ctrl.maxAngle - (ctrl.maximum - 1) * spacingInDegrees) / ctrl.maximum;
                    // If resulting section is smaller than 1px, reduce the spacing between them to half the section size
                    if (sectionInDegrees / 180 * ctrl.radius < 1) {
                        spacingInDegrees = 0.5 * sectionInDegrees;
                        sectionInDegrees = (ctrl.maxAngle - (ctrl.maximum - 1) * spacingInDegrees) / ctrl.maximum;
                    }

                    // Fill sections path data (describe and class)
                    ctrl.paths = [];
                    let sectionNumber = 0;
                    for (const [classValue, nSections] of ctrl.classes.map((c, i) => [c, ctrl.values[i]])) {
                        for (const _ of Array(nSections).keys()) {
                            ctrl.paths.push({
                                describe: describeArc(
                                    ctrl.radius,
                                    ctrl.radius,
                                    ctrl.radius - 2 * ctrl.strokeWidth,
                                    180 - sectionNumber * (spacingInDegrees + sectionInDegrees),
                                    180 - sectionNumber * (spacingInDegrees + sectionInDegrees) - sectionInDegrees
                                ),
                                class: classValue,
                            });
                            sectionNumber++;
                        }
                    }

                    // Fill not filled sections if there are some remaining
                    if (numberOfSections < ctrl.maximum) {
                        for (const _ of Array(ctrl.maximum - numberOfSections)){
                            ctrl.paths.push({
                                describe: describeArc(
                                    ctrl.radius,
                                    ctrl.radius,
                                    ctrl.radius - 2 * ctrl.strokeWidth,
                                    180 - sectionNumber * (spacingInDegrees + sectionInDegrees),
                                    180 - sectionNumber * (spacingInDegrees + sectionInDegrees) - sectionInDegrees
                                ),
                                class: ctrl.classNotFilled,
                            });
                            sectionNumber++;
                        }
                    }
                }

                function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
                    const angleInRadians = (-angleInDegrees * Math.PI) / 180.0;

                    return {
                        x: centerX + radius * Math.cos(angleInRadians),
                        y: centerY + radius * Math.sin(angleInRadians),
                    };
                }

                function describeArc(x, y, radius, startAngle, endAngle) {
                    const start = polarToCartesian(x, y, radius, endAngle);
                    const end = polarToCartesian(x, y, radius, startAngle);

                    const largeArcFlag = Math.abs(endAngle - startAngle) <= 180 ? '0' : '1';

                    const d = ['M', start.x, start.y, 'A', radius, radius, 0, largeArcFlag, 0, end.x, end.y].join(' ');

                    return d;
                }
            },
        ],
    });

    /** Text that can be edited once clicked on
     * textValue        Current text value (two-way bound). Gets set to defaultValue on load if empty.
     * defaultValue     (optional) Default text shown when directive first loads (before editing) if textValue is empty
     *                  If defaultValue is passed in, title color will be grayed out if textValue === defaultValue
     * placeholder      (optional) Placeholder text shown in input field while editing
     * fontSize         (optional) Font size to be used in in both view and edit mode; default value matches style guide 
     **/
    app.directive('editableTextField', function() {
        return {
            restrict: 'E',
            templateUrl: '/templates/widgets/editable-text-field.html',
            scope: {
                textValue: '=ngModel',
                defaultValue: '<?',
                placeholder: '<?',
                fontSize: '<?'
            },
            link: function(scope) {
                scope.item = {};
                scope.placeholder = scope.placeholder || 'New name';

                // Comparator item naming
                scope.startEdit = function(item) {
                    item.$editing = true;
                    item.$textValue = scope.textValue === scope.defaultValue ? '' : scope.textValue;
                };

                scope.cancelEdit = function(item) {
                    item.$editing = false;
                };

                scope.validateEdit = function(item) {
                    scope.textValue = item.$textValue || scope.textValue;
                    item.$editing = false;
                };

                scope.$watch('defaultValue', (nv, ov) => {
                    if (!scope.textValue || scope.textValue === ov) {
                        scope.textValue = nv;
                    }
                });
            }
        }
    });

})();

(function(){
    'use strict';

    const app = angular.module('dataiku.directives.widgets');

    app.directive('browsePath', function($timeout, $filter) {
        return {
            restrict: 'E',
            replace: true,
            templateUrl: '/templates/widgets/browse-path/browse-path.html',
            scope: {
                title: '@',
                path: '=',
                browseFn: '=',
                onBrowseDoneFn: '=?',
                canSelectFn: '=',
                canBrowseFn: '=?',
                selectedItems: '=?',
                isMultiSelect: '=?',
                destinationLabel: '@?',
                displayItemFn: '=?',
                cantWriteContentVerb: '@',
                searchable: '@?',
                itemsAreProjects: '='
            },
            link: function(scope, element, attrs) {
                scope.searchable = attrs.searchable ? scope.$eval(scope.searchable) : true;
                scope.displayItemFn = attrs.displayItemFn !== undefined ? scope.displayItemFn : item => item;
                scope.clickOnItem = function(item, event) {
                    if (!item.directory && scope.canSelectFn(item)) {
                        toggleSelect(item)
                    } else if (item.directory) {
                        if (((event.ctrlKey || event.metaKey) || !scope.canBrowseFn(item)) && scope.canSelectFn(item)) {
                            toggleSelect(item)
                            return;
                        }
                        if (scope.canBrowseFn(item)) {
                            scope.executeBrowse(item.fullPath);
                            return;
                        }
                    }
                }

                // -- selection
                if (typeof scope.selectedItems === "undefined") {
                    scope.selectedItems = [];
                }
                let selectedItemsMap = {};

                scope.isSelected = function(item) {
                    return typeof selectedItemsMap[item.fullPath] !== "undefined";
                }

                function toggleSelect(item) {
                    if (scope.isSelected(item)) {
                        delete selectedItemsMap[item.fullPath];
                    } else {
                        if (!scope.isMultiSelect) {
                            selectedItemsMap = {};
                        }
                        selectedItemsMap[item.fullPath] = item;
                    }
                    scope.selectedItems = Object.values(selectedItemsMap);
                }

                // -- filtering

                scope.filter = {query:""};
                function updateFiltered(){
                    if (scope.pathContent == null) {
                        return;
                    }
                    if (!scope.filter.query) {
                        scope.pathContent.filteredChildren = scope.pathContent.children;
                    } else {
                        scope.pathContent.filteredChildren = $filter("filter")(scope.pathContent.children, {name: scope.filter.query});
                    }
                }

                scope.$watch("filter.query", updateFiltered);

                // -- browsing

                scope.browseError = null;
                scope.firstBrowseDone = false;
                if (scope.path == null) scope.path = "/";
                scope.pathContent = [];
                scope.browsing = false;

                scope.executeBrowse = function(newPath){
                    scope.browseError = null;
                    scope.path = newPath.replace(/^\/+/,'/');
                    scope.browsing = true;
                    scope.browseFn(scope.path).success(function(data){
                        scope.pathContent = data;
                        scope.pathContent.children.sort(function(a,b) {
                            if (a.directory != b.directory)  {
                                return a.directory ? -1 : 1;
                            }
                            return a.name.localeCompare(b.name);
                        });
                        updateFiltered();
                        scope.browsing = false;
                        // Refocus search after filter
                        scope.filter.query = "";
                        scope.selectedItems = [];
                        if (typeof scope.onBrowseDoneFn === "function") {
                            const currentFolder = angular.extend({ canWriteContents: true }, scope.pathContent.pathElts[scope.pathContent.pathElts.length - 1], { pathElts: scope.pathContent.pathElts.map(f => scope.displayItemFn(f)).join('/') });
                            scope.onBrowseDoneFn(currentFolder);
                        }
                        $timeout(function(){
                            element.find(".search-input").focus();
                        }, 0);
                    }).error(function(data, status, error){
                        scope.browsing = false;
                        scope.browseErrorMsg = getErrorDetails(data, status, error).detailedMessage;
                        scope.browseError = getErrorDetails(data, status, error);
                    });
                };

                if (typeof(scope.canBrowseFn) !== "function") (
                    scope.canBrowseFn = function(item) {
                        return true;
                    }
                )

                // postponing it to next digest so that fatRepeat's container does not have its full height
                // (b/c many other elements in the modal will be hidden using ng-show, leaving space to fatRepeat's container once digest is done)
                $timeout(function() {
                    scope.executeBrowse(scope.path);
                    element.find(".search-input").focus();
                }, 0);
            }
        }
    });

    app.directive('browsePathInput', function(DataikuAPI, $timeout, $filter) {
        return {
            restrict: 'E',
            replace: true,
            templateUrl: '/templates/widgets/browse-path/browse-path-input.html',
            scope: {
                title: '@',
                path: '=',
                browseFn: '=',
                onBrowseDoneFn: '=?',
                canSelectFn: '=',
                canBrowseFn: '=?',
                itemsAreProjects: '='
            },
            link: function (scope, element, attrs) {

            }
        }
    });

})();


(function() {
'use strict';

const app = angular.module('dataiku.directives.widgets');

function setArrayValues(array = [], newValues) {
    array.length = 0;
    array.push(...newValues);
    return array;
}


app.directive("autoconfigFormElement", function($stateParams, DataikuAPI, Logger, CodeMirrorSettingService, CustomUISetup) {
    return {
        scope: {
            paramDesc: '=',
            model: '=',
            columnsPerInputRole: '=',
            chart: '=',
            side: '=',
            activeDragDrop: '=',
            validity: '=',
            pluginId: '=',
            componentId: '=',
            disabled: '=',
            viewMode: '=',
            errorScope: '<',
            recipeConfig: '=',
            addReloadCustomChoicesCallback: '<'
        },
        templateUrl: '/templates/widgets/autoconfig/form-element.html',
        link: function($scope, elem, attrs) {
            $scope.model = $scope.model || {};
            if ($scope.paramDesc.type === 'DATASET'){
                $scope.newDataset = {};
            }
            /* Watchers for values that depend on other fields (visibility, dataset columns.. */
            $scope.uiState = {};
            $scope.codeMirrorSettingService = CodeMirrorSettingService;

            if (!$scope.errorScope) {
                Logger.error("errorScope not specified"); // could be an assert, just for debug puposes
            }
            function fetchAccessibleFolders() {
                DataikuAPI.managedfolder.listWithAccessible($stateParams.projectKey).success(function (data) {
                    data.forEach(folder => { folder.foreign = (folder.projectKey != $stateParams.projectKey); });
                    if (!$scope.paramDesc.canSelectForeign) {
                        data = data.filter(folder => !folder.foreign);
                    }
                    $scope.accessibleFolders = data.map(ds => ({
                        ref: ds.foreign ? (ds.projectKey + '.' + ds.id) : ds.id,
                        displayName: ds.name + (ds.foreign ? ('(' + ds.projectKey + ')') : '')
                    }));
                }).error(setErrorInScope.bind($scope.errorScope));
            }

            function fetchFolderFilesRecursively(folderId, pathsList, mappingFunction, basePath='/') {
                DataikuAPI.managedfolder.browse($stateParams.projectKey, folderId, basePath).success(function (data) {
                    data.children && data.children.forEach(file => {
                        if (file.directory === true) {
                            fetchFolderFilesRecursively(folderId, pathsList, mappingFunction, file.fullPath);
                        } else {
                            let matchingPath = mappingFunction(file);
                            if (matchingPath) {
                                pathsList.push(matchingPath);
                            }
                        }
                    })
                }).error(setErrorInScope.bind($scope.errorScope));
            }

            if ($scope.model[$scope.paramDesc.name] === undefined) {
                if ($scope.paramDesc.defaultValue !== undefined) {
                    $scope.model[$scope.paramDesc.name] = $scope.paramDesc.defaultValue;
                } else if ($scope.paramDesc.type == 'INT' || $scope.paramDesc.type == 'DOUBLE') {
                    $scope.model[$scope.paramDesc.name] = 0; //important, otherwise angular UI shows 0 but the model is not set to 0
                }
            }

            // Visibility
            if ($scope.paramDesc.visibilityCondition) {
                $scope.$watch('model', function() {
                    $scope.uiState.$visibility = $scope.$eval($scope.paramDesc.visibilityCondition);
                }, true);
            }

            // Date string must be parsed in Date object
            if ($scope.paramDesc.type === 'DATE') {
                $scope.model[$scope.paramDesc.name] = new Date($scope.model[$scope.paramDesc.name]);
            }

            // Value of the dataset from which to select a column
            function updateAccessibleColumns(datasetRef) {
                if ($scope.viewMode) return;
                if (datasetRef) {
                    let projectKey = $stateParams.projectKey;
                    let datasetName = datasetRef;
                    const dotPos = datasetRef.indexOf('.');
                    if (dotPos > 0) {
                        projectKey = datasetRef.substring(0, dotPos);
                        datasetName = datasetRef.substring(dotPos + 1);
                    }
                    DataikuAPI.datasets.get(projectKey, datasetName, $stateParams.projectKey).success(function(data) {
                        $scope.accessibleDatasetColumns = data.schema.columns.map(col => ({
                            ref: col.name,
                            displayName: col.name,
                            type: col.type
                        }));
                        if ($scope.paramDesc.allowedColumnTypes && $scope.paramDesc.allowedColumnTypes.length) {
                            $scope.accessibleDatasetColumns = $scope.accessibleDatasetColumns.filter(col => $scope.paramDesc.allowedColumnTypes.includes(col.type));
                        }
                        $scope.accessibleDatasetColumnsList = $scope.accessibleDatasetColumns.map(x => x.ref);
                    }).error(setErrorInScope.bind($scope.errorScope));
                } else {
                    $scope.accessibleDatasetColumns = [];
                    $scope.accessibleDatasetColumnsList = [];
                }
            };

            if ($scope.paramDesc.datasetParamName) {
                $scope.$watch('model.' + $scope.paramDesc.datasetParamName, updateAccessibleColumns, true);
            } else if (['DATASET_COLUMN', 'DATASET_COLUMNS'].includes($scope.paramDesc.type)) {
                updateAccessibleColumns($stateParams.datasetName);
            }

            if (['COLUMN', 'COLUMNS'].includes($scope.paramDesc.type)) {
                function updateColumnsInRole() {
                    let columnsInRole = $scope.columnsPerInputRole[$scope.paramDesc.columnRole];
                    if (columnsInRole) {
                        $scope.accessibleColumnsList = columnsInRole.map(col => col.name);
                    } else {
                        Logger.error('No role for plugin column parameter');
                    }
                };
                updateColumnsInRole();
                $scope.$watch("columnsPerInputRole", updateColumnsInRole, true);
            }

            $scope.invalidColumnType = function() {
                let val = $scope.model[$scope.paramDesc.name];
                if (!val) return false;
                let columnsInRole = $scope.columnsPerInputRole[$scope.paramDesc.columnRole];
                if (columnsInRole) {
                    const types = $scope.paramDesc.allowedColumnTypes;
                    if (types && types.length) {
                        const col = columnsInRole.find(c => c.name == val);
                        if (!col) {
                            return false;
                        }
                        return !types.map(t => t.toLowerCase()).includes(col.type);
                    }
                } else {
                    Logger.error('No role for plugin column parameter');
                }
                return false;
            }

            // Value of the api service from which to select a package
            if ($scope.paramDesc.apiServiceParamName) {
                $scope.$watch('model.' + $scope.paramDesc.apiServiceParamName, function(apiService) {
                    if ($scope.viewMode) return;
                    if (apiService) {
                        const projectKey = $stateParams.projectKey;
                        DataikuAPI.lambda.packages.list(projectKey, apiService).success(function (data) {
                            $scope.accessibleAPIServicePackages = data.map(ds => ({ref: ds.id, displayName: ds.id}));
                        }).error(setErrorInScope.bind($scope.errorScope));

                    } else {
                        $scope.accessibleAPIServicePackages = [];
                    }
                }, true);
            }

            /* Field types that only need to be populated with the right API call */
            $scope.$watch('viewMode', function() {
                if ($scope.viewMode) return;
                refreshObjectLists();
            });

            let pluginIdDeregister = null;

            function buildReloadCustomChoicesCallback(customOptionsCallback) {
                return () => retrieveCustomChoices(customOptionsCallback, false);
            }

            function removeObsoleteSelectedItems(options, isMultiselect, model, parameterName) {
                // Fix the model if the selected items are no longer available in the options
                if (options && parameterName) {
                    if (isMultiselect) {
                        let selectedItems = model[parameterName];
                        if (selectedItems && Array.isArray(selectedItems)) {
                            model[parameterName] = selectedItems.filter(item => options.find(e => e.value === item));
                        }
                    } else {
                        const selectedValue = model[parameterName];
                        if (selectedValue && !options.find(e => e.value === selectedValue)) {
                            model[parameterName] = undefined;
                        }

                    }
                }
            }

            function wrapCallbackWithWithSelectedItemsCleanup(customOptionsCallback) {
                return function(options) {
                    removeObsoleteSelectedItems(options, $scope.paramDesc.type === 'MULTISELECT', $scope.model, $scope.paramDesc.name);
                    return customOptionsCallback(options);
                };
            }

            function retrieveCustomChoices(customOptionsCallback, isInitialization=true) {
                const customOptionsCallbackWithSelectedItemsCleanup = wrapCallbackWithWithSelectedItemsCleanup(customOptionsCallback);
                if (isInitialization) {
                    CustomUISetup.setupCallPythonDo($scope, $scope.errorScope, $scope.pluginId, $scope.componentId, $scope.model, $scope.side);
                    if (!$scope.paramDesc.disableAutoReload) {
                        $scope.addReloadCustomChoicesCallback(buildReloadCustomChoicesCallback(customOptionsCallbackWithSelectedItemsCleanup));
                    }
                }
                let doOneCallPythonDo = function() {
                    $scope.callPythonDoOngoing = true;
                    $scope.callPythonDo({ parameterType: $scope.paramDesc.type, parameterName: $scope.paramDesc.name, customChoices: true }).then(
                            data => customOptionsCallbackWithSelectedItemsCleanup(data.choices),
                            () => customOptionsCallbackWithSelectedItemsCleanup([])
                        )
                        .finally(function() {
                            $scope.callPythonDoOngoing = false;
                            if ($scope.enqueueCallPythonDo) {
                                $scope.enqueueCallPythonDo = false;
                                doOneCallPythonDo();
                            }
                        });
                };
                if ($scope.callPythonDoOngoing == true) {
                    $scope.enqueueCallPythonDo = true;
                } else {
                    doOneCallPythonDo();
                }
            }

            function refreshObjectLists() {
                if ($scope.paramDesc.getChoicesFromPython === true) {
                    if ($scope.paramDesc.type === 'MULTISELECT') {
                        $scope.retrieveCustomChoices = retrieveCustomChoices;
                    } else {
                        retrieveCustomChoices(function(options) {
                            $scope.paramDesc.selectChoices = setArrayValues($scope.paramDesc.selectChoices, options);
                        });
                    }
                }

                switch ($scope.paramDesc.type) {
                    case 'PROJECT':
                        DataikuAPI.projects.list().success(function (data) {
                            $scope.accessibleProjects = data.map(proj => ({ref: proj.projectKey, displayName: proj.name}));
                        }).error(setErrorInScope.bind($scope.errorScope));
                        break;

                    case 'DATASETS':
                        if (!$stateParams.projectKey) break;
                        DataikuAPI.datasets.listWithAccessible($stateParams.projectKey).success(function (data) {
                            data.forEach(ds => {ds.foreign = (ds.projectKey != $stateParams.projectKey);});
                            if (!$scope.paramDesc.canSelectForeign) {
                                data = data.filter(ds => !ds.foreign);
                            }
                            $scope.accessibleDatasetsList = data.map(ds => ds.foreign ? (ds.projectKey + '.' + ds.name) : ds.name);
                        }).error(setErrorInScope.bind($scope.errorScope));
                        break;

                    case 'FOLDER':
                    case 'MANAGED_FOLDER':
                        if (!$stateParams.projectKey) break;
                        fetchAccessibleFolders();
                        break;

                    case 'MODEL':
                    case 'SAVED_MODEL':
                        if (!$stateParams.projectKey) break;
                        DataikuAPI.savedmodels.listWithAccessible($stateParams.projectKey).success(function (data) {
                            data.forEach(ds => {ds.foreign = (ds.projectKey != $stateParams.projectKey);});
                            if (!$scope.paramDesc.canSelectForeign) {
                                data = data.filter(model => !model.foreign);
                            }
                            $scope.accessibleModels = data.map(ds => ({
                                ref: ds.foreign ? (ds.projectKey + '.' + ds.id) : ds.id,
                                displayName: ds.name + (ds.foreign ? ('(' + ds.projectKey + ')') : '')
                            }));
                        }).error(setErrorInScope.bind($scope.errorScope));
                        break;

                    case 'SCENARIO':
                        DataikuAPI.scenarios.listAccessible().success(function (data) {
                            data.forEach(ds => {ds.foreign = (ds.projectKey != $stateParams.projectKey);});
                            $scope.accessibleScenarios = data.map(ds => ({
                                ref: ds.foreign ? (ds.projectKey + '.' + ds.id) : ds.id,
                                displayName: ds.name + (ds.foreign ? ('(' + ds.projectKey + ')') : '')
                            }));
                        }).error(setErrorInScope.bind($scope.errorScope));
                        break;

                    case 'API_SERVICE':
                        if (!$stateParams.projectKey) break;
                        DataikuAPI.lambda.services.list($stateParams.projectKey).success(function (data) {
                            $scope.accessibleAPIServices = data.map(ds => ({ref: ds.id, displayName: ds.id}));
                        }).error(setErrorInScope.bind($scope.errorScope));
                        break;

                    case 'BUNDLE':
                        if (!$stateParams.projectKey) break;
                        DataikuAPI.projects.design.listBundles($stateParams.projectKey).success(function (data) {
                            $scope.accessibleBundles = data.bundles.map(ds => ({ref: ds.bundleId, displayName: ds.bundleId}));
                        }).error(setErrorInScope.bind($scope.errorScope));
                        break;

                    case 'VISUAL_ANALYSIS':
                        if (!$stateParams.projectKey) break;
                        DataikuAPI.analysis.listHeads($stateParams.projectKey).success(function (data) {
                            $scope.accessibleVisualAnalyses = data.map(ds => ({ref: ds.id, displayName: ds.name}));
                        }).error(setErrorInScope.bind($scope.errorScope));
                        break;

                    case 'PRESET':
                    case 'PRESETS':
                        // pluginId is set afterwards
                        pluginIdDeregister = $scope.$watch("pluginId", function() {
                            if (!$scope.pluginId) return;
                            pluginIdDeregister();

                            DataikuAPI.plugins.listAccessiblePresets($scope.pluginId, $stateParams.projectKey, $scope.paramDesc.parameterSetId).success(function (data) {
                                $scope.inlineParams = data.inlineParams;
                                $scope.inlinePluginParams = data.inlinePluginParams;
                                $scope.accessiblePresets = [];
                                $scope.accessiblePresets.push({name:"NONE", label:"None", usable:true, description:null});
                                if (data.definableInline) {
                                    $scope.accessiblePresets.push({
                                        name:"INLINE",
                                        label:"Manually defined", usable:true,
                                        description: "Define values for these parameters"
                                    });
                                }
                                data.presets.forEach(function(p) {
                                    $scope.accessiblePresets.push({name:"PRESET " + p.name, label:p.name, usable:p.usable, description:p.description});
                                });
                                $scope.accessibleParameterSetDescriptions = $scope.accessiblePresets.map(function(p) {return p.description || '<em>No description</em>';});
                            }).error(setErrorInScope.bind($scope.errorScope));
                        });

                        if ($scope.paramDesc.type == 'PRESETS') {
                            $scope.model[$scope.paramDesc.name] = $scope.model[$scope.paramDesc.name] || [];
                            $scope.addPreset = function() {
                                $scope.model[$scope.paramDesc.name].push({ mode: "NONE"});
                            };
                        }
                        break;

                    // Non project related:
                    case 'CLUSTER':
                        DataikuAPI.admin.clusters.listAccessible().success(function (data) {
                            $scope.accessibleClusters = data.map(c => ({ref: c.id, displayName: c.name}));
                            $scope.accessibleClusterIds = data.map(c => c.id);
                        }).error(setErrorInScope.bind($scope.errorScope));
                        break;

                    case 'CODE_ENV':
                        $scope.accessibleCodeEnvs = [];
                        DataikuAPI.codeenvs.list('PYTHON').success(function (data) {
                            const codeEnvs = data.map(codeEnv => ({ref: codeEnv.envName, displayName: codeEnv.envName}));
                            $scope.accessibleCodeEnvs = $scope.accessibleCodeEnvs.concat(codeEnvs);
                        }).error(setErrorInScope.bind($scope.errorScope));
                        DataikuAPI.codeenvs.list('R').success(function (data) {
                            const codeEnvs = data.map(codeEnv => ({ref: codeEnv.envName, displayName: codeEnv.envName}));
                            $scope.accessibleCodeEnvs = $scope.accessibleCodeEnvs.concat(codeEnvs);
                        }).error(setErrorInScope.bind($scope.errorScope));
                        break;

                    case 'CONNECTION':
                    case 'CONNECTIONS':
                        DataikuAPI.connections.getNames('all').success(function(data) {
                            $scope.accessibleConnectionsList = data;
                        }).error(setErrorInScope.bind($scope.errorScope));
                        break;

                    case 'PLUGIN':
                        DataikuAPI.plugins.list(false).success(function (data) {
                            $scope.accessiblePlugins = data.plugins.filter(plugin => plugin.installed).map(plugin => {
                                return {
                                    id: plugin.id,
                                    label: plugin.installedDesc.desc.meta.label || plugin.id
                                };
                            });
                        }).error(setErrorInScope.bind($scope.errorScope));
                        break;

                    case 'OBJECT_LIST':
                        $scope.model[$scope.paramDesc.name] = $scope.model[$scope.paramDesc.name] || [];
                        $scope.addObject = function() {
                            $scope.model[$scope.paramDesc.name].push({});
                        };
                        break;

                    case 'CREDENTIAL_REQUEST':
                        if ($scope.paramDesc.credentialRequestSettings.type === 'OAUTH2') {
                            // Set usePkce to true by default
                            $scope.model[$scope.paramDesc.name] = $scope.model[$scope.paramDesc.name] || { usePkce: true };
                        }
                }
            }
            $scope.dimensionList = [];
            $scope.acceptCallback = function(column) {
                if (column && (column.column == "__COUNT__" || column.column == null && column['function'] == "COUNT")) {
                    return {accept:false, message:'Only dataset columns are accepted'};
                } else {
                    return {accept:true};
                }
            };
            var initChartStuff = function() {
                var p = 'model.' + $scope.paramDesc.name;
                $scope.$watch(p, function(nv, ov) {
                    if (nv == null && ov != null) {
                        $scope.dimensionList.splice(0, $scope.dimensionList.length);
                    } else if ($scope.model[$scope.paramDesc.name] == null) {
                        return;
                    } else if ($scope.dimensionList.length == 0 || $scope.dimensionList[0].column != $scope.model[$scope.paramDesc.name]) {
                        $scope.dimensionList.splice(0, $scope.dimensionList.length);
                        var n = $scope.model[$scope.paramDesc.name];
                        $scope.dimensionList.push({column:n, type:'ALPHANUM', label:n});
                    }
                });
                $scope.$watch('dimensionList', function(nv, ov) {
                    if (ov != null && nv != null && ov.length > 0 && nv.length == 0) {
                        $scope.model[$scope.paramDesc.name] = null;
                    } else if ($scope.dimensionList.length == 0) {
                        return;
                    } else if ($scope.dimensionList[0].column != $scope.model[$scope.paramDesc.name]) {
                        $scope.model[$scope.paramDesc.name] = $scope.dimensionList[0].column;
                    }
                }, true);
            };

            var chartDeregister = $scope.$watch("chart", function() {
                if ($scope.chart) {
                    initChartStuff();
                    chartDeregister();
                }
            });

            $scope.onDragEnd = function() {
                // Unhide the moved element, as ng-repeat will reuse it
                if($scope.activeDragDrop.draggedElementToHide) $scope.activeDragDrop.draggedElementToHide.show();
                clear($scope.activeDragDrop);
                $(".chart-configuration-wrapper").removeClass("drag-active");
            };
        }
    }
});

app.directive("autoconfigPresetElement", function($stateParams, DataikuAPI){
    return {
        scope: {
            paramDesc: '=',
            model: '=',
            pluginId: '=',
            componentId: '=',
            disabled: '=',
            inlineParams: '=',
            inlinePluginParams: '=',
            accessibleParameterSetDescriptions: '=',
            accessiblePresets: '=',
            errorScope: '<',
            qa: '@'
        },
        templateUrl: '/templates/widgets/autoconfig/preset-element.html',
        link: function($scope, elem, attrs) {
            $scope.$preset = {choice:"NONE"};
            let currentValue = $scope.model;
            if (currentValue) {
                if (currentValue.mode == "NONE") {
                    $scope.$preset.choice = "NONE";
                } else if (currentValue.mode == "INLINE") {
                    $scope.$preset.choice = "INLINE";
                } else {
                    $scope.$preset.choice = "PRESET " + currentValue.name;
                }
            }

            $scope.$watch("accessiblePresets", function() {
                if (!$scope.model || !$scope.accessiblePresets || !$scope.paramDesc) {
                    return;
                }
                if ($scope.paramDesc.mandatory) {
                    const realPresets = $scope.accessiblePresets.filter(ap => ap.name.startsWith("PRESET"))
                    const definableInline = $scope.accessiblePresets.filter(ap => ap.name.startsWith("INLINE")).length > 0;

                    if ($scope.model && $scope.model.mode == 'NONE' && realPresets.length > 0) {
                        $scope.$preset.choice = realPresets[0].name;
                    } else if ($scope.model && $scope.model.mode == 'NONE' && definableInline) {
                        $scope.$preset.choice = "INLINE";
                    }
                }
            });

            $scope.$watch("$preset.choice", function() {
                if ($scope.$preset.choice == null) return;
                $scope.model = $scope.model || {};
                if ($scope.$preset.choice == 'NONE' && $scope.model.mode != 'NONE') {
                    Object.keys($scope.model).forEach(function(k) {delete $scope.model[k];});
                    $scope.model.mode = 'NONE';
                } else if ($scope.$preset.choice == 'INLINE' && $scope.model.mode != 'INLINE') {
                    Object.keys($scope.model).forEach(function(k) {delete $scope.model[k];});
                    $scope.model.mode = 'INLINE';
                    $scope.model.inlinedConfig = {};
                    $scope.model.inlinedPluginConfig = {};
                } else if ($scope.$preset.choice.startsWith('PRESET') && ($scope.model.mode != 'PRESET' || $scope.model.name != $scope.$preset.choice.substring('PRESET '.length))) {
                    Object.keys($scope.model).forEach(function(k) {delete $scope.model[k];});
                    $scope.model.mode = 'PRESET';
                    $scope.model.name = $scope.$preset.choice.substring('PRESET '.length);
                }
            });
        }
    }
});

app.directive("autoconfigObjectListElement", function(){
    return {
        scope: {
            model: '=',
            pluginId: '=',
            disabled: '=',
            params: '=',
            errorScope: '<'
        },
        templateUrl: '/templates/widgets/autoconfig/object-list-element.html',
        link: function($scope, elem, attrs) {
            $scope.model = $scope.model || {};
        }
    }
});

app.filter('formatParamDescValue', function($sce, $filter) {
    const formatKeyValueList = function(value) {
        let ret = '<table><tbody>';
        for (let i = 0; i < value.length; i++) {
            ret += '<tr><td>' + $filter('encodeHTML')(value[i].from) + '</td><td>&nbsp;&nbsp;&nbsp;→&nbsp;&nbsp;&nbsp;</td><td>' + $filter('encodeHTML')(value[i].to) + '</td></tr>';
        }
        ret += '</tbody></table>';
        return ret;
    };
    const formatMap = function(value) {
        let ret = '<table><tbody>';
        for (let key in value) {
            if (!value.hasOwnProperty(key)) continue;
            ret += '<tr><td>' + $filter('encodeHTML')(key) + '</td><td>&nbsp;&nbsp;&nbsp;→&nbsp;&nbsp;&nbsp;</td><td>' + $filter('encodeHTML')(value[key]) + '</td></tr>';
        }
        ret += '</tbody></table>';
        return ret;
    };
    return function(value, paramDesc) {
        const valueOrDefault = value === undefined ? paramDesc.defaultValue : value;
        if (valueOrDefault === undefined) return 'N/A';
        let ret;
        switch (paramDesc.type) {
        case 'BOOLEAN':
            if (typeof valueOrDefault != 'boolean') return 'N/A';
            return valueOrDefault ? 'Yes' : 'No';
        case 'SEPARATOR':
            return '';
        case 'PASSWORD':
            return '***';
        case 'SELECT':
            const opt = paramDesc.selectChoices.find(opt => opt.value == valueOrDefault);
            if (!opt) return 'N/A';
            ret = '<span';
            if (opt.color) {
                ret += ' style="color: ' + opt.color + ';"'
            }
            ret += '>';
            if (opt.icon) {
                ret += '<i class="' + opt.icon + '"></i>&nbsp;';
            }
            ret += $filter('encodeHTML')(opt.label || opt.value) + '</span>';
            return $sce.trustAsHtml(ret);
        case 'KEY_VALUE_LIST':
            if (!Array.isArray(valueOrDefault)) return 'N/A';
            return $sce.trustAsHtml(formatKeyValueList(valueOrDefault));
        case 'MAP':
            if (typeof valueOrDefault != 'object') return 'N/A';
            return $sce.trustAsHtml(formatMap(valueOrDefault));
        case 'ARRAY':
            if (!Array.isArray(valueOrDefault)) return 'N/A';
            ret = '';
            for (let i = 0; i < valueOrDefault.length; i++) {
                if (i > 0) ret += '<br />';
                if (typeof valueOrDefault[i] == 'boolean') {
                    ret += valueOrDefault[i] ? 'Yes' : 'No';
                } else if (typeof valueOrDefault[i] == 'number') {
                    ret += $filter('encodeHTML')(valueOrDefault[i]);
                } else if (typeof valueOrDefault[i] == 'string') {
                    ret += '<span style="white-space: pre-wrap;">' + $filter('encodeHTML')(valueOrDefault[i]) + '</span>';
                } else if (typeof valueOrDefault[i] == 'object') {
                    if (Object.keys(valueOrDefault[i]).length == 2 && valueOrDefault[i].hasOwnProperty('from') && valueOrDefault[i].hasOwnProperty('to')) {
                        ret += formatKeyValueList(valueOrDefault[i]);
                    } else {
                        ret += formatMap(valueOrDefault[i]);
                    }
                }
            }
            return $sce.trustAsHtml(ret);
        case 'OBJECT_LIST':
            if (!Array.isArray(valueOrDefault)) return 'N/A';
            ret = '';
            for (let i = 0; i < valueOrDefault.length; i++) {
                if (i > 0) ret += '<br />';
                ret += $filter('encodeHTML')(valueOrDefault[i]);
            }
            return $sce.trustAsHtml(ret);
        case 'COLUMNS':
        case 'DATASETS':
        case 'DATASET_COLUMNS':
        case 'CONNECTIONS':
            if (!Array.isArray(valueOrDefault)) return 'N/A';
            return $sce.trustAsHtml(valueOrDefault.map($filter('encodeHTML')).join('<br />'));
        case 'TEXTAREA':
            return $sce.trustAsHtml('<span style="white-space: pre-wrap;">' + $filter('encodeHTML')(valueOrDefault) + '</span>');
        case 'STRING':
        case 'INT':
        case 'DOUBLE':
        case 'DATASET_COLUMN':
        case 'CONNECTION':
        case 'FOLDER':
        case 'MANAGED_FOLDER':
        case 'MODEL':
        case 'SAVED_MODEL':
        case 'SCENARIO':
        case 'API_SERVICE':
        case 'API_SERVICE_VERSION':
        case 'BUNDLE':
        case 'VISUAL_ANALYSIS':
        case 'CLUSTER':
        case 'DATASET':
        case 'PROJECT':
        case 'COLUMN':
        case 'PLUGIN':
            return $sce.trustAsHtml($filter('encodeHTML')(valueOrDefault));
        default:
            return $sce.trustAsHtml($filter('encodeHTML')(JSON.stringify(valueOrDefault)));
        }
    };
});

app.directive("autoconfigMapToMappingEditor", function($parse){
    return {
        scope : false,
        link : function($scope, elem, attrs) {
            let obj = $scope.$eval(attrs.autoconfigMapToMappingEditor);
            $scope.tempMap = []; // for MAP parameters: the representation as an array of key-value pairs
            if (obj != null) {
                angular.forEach(obj, function(value, key) {
                    $scope.tempMap.push({'from' : key, 'to': value});
                  }, $scope.tempMap);
            }
            $scope.$watch("tempMap", function(nv, ov) {
                if ( nv == null || obj == null ) return;
                Object.keys(obj).forEach(function(key) {delete obj[key]});
                $scope.tempMap.forEach(function(pair) {
                    if ( pair.from != null && pair.from.length > 0) {
                        obj[pair.from] = pair.to || "";
                    }
                });
                $parse(attrs.autoconfigMapToMappingEditor).assign($scope, obj);
            }, true);
        }
    }
});

app.directive("autoconfigArrayToMappingEditor", function(){
    return {
        scope : false,
        link : function($scope, elem, attrs) {
            let obj = $scope.$eval(attrs.autoconfigArrayToMappingEditor);
            $scope.tempArray = []; // for ARRAY parameters
            if (obj != null) {
                obj.forEach(function(e) {
                    $scope.tempArray.push({value:e});
                });
            }
            $scope.$watch("tempArray", function(nv, ov) {
                if ( nv == null || obj == null ) return;
                obj.splice(0, obj.length);
                $scope.tempArray.forEach(function(e) {
                    obj.push(e.value);
                });
            }, true);
        }
    }
});

app.directive('autoconfigFormArrayElementArray',function() {
    return {
        restrict:'A',
        scope: {
            elements: '=ngModel',
            onChange: '&',
            addLabel: '@',
            disabled: '=',
            qa: '@'
        },
        templateUrl : '/templates/widgets/autoconfig/form-array-element-array.html',
        compile: function() { return { pre: function(scope,element,attrs) {
            if(angular.isUndefined(scope.elements)){
                scope.elements = [];
            }
            if (!scope.addLabel) scope.addLabel = 'Add another';
            if ('preAdd' in attrs) {
                scope.preAdd = scope.$parent.$eval(attrs.preAdd);
            } else {
                scope.preAdd = Object.keys(scope.elements).length === 0;
            }
            if (scope.onChange) {
                scope.callback = scope.onChange.bind(scope, scope.elements);
            }
            scope.paramDesc = {};
            scope.prepareIt = function(it) {
                // noop
            };
            scope.templateIt = function() {
                return {value:null};
            };
            scope.validateIt = function(it) {
                if ( scope.contentDesc.type == 'STRING' || scope.contentDesc.type == 'TEXTAREA' ) {
                    return true;
                } else if (scope.contentDesc.type == 'MAP' || scope.contentDesc.type == 'KEY_VALUE_LIST' || scope.contentDesc.type == 'ARRAY' ) {
                    return true;
                } else if ( scope.contentDesc.type == 'INT' ) {
                    return true;
                } else if ( scope.contentDesc.type == 'DOUBLE' ) {
                    return true;
                } else if ( scope.contentDesc.type == 'BOOLEAN' ) {
                    return true;
                } else {
                    return false;
                }
            };
            scope.contentDesc = {};
        }, post : function(scope,element,attrs) {
            let guessType = function(value) {
                if ( value == null ) {
                    return 'STRING';
                } else {
                    let t = typeof value;
                    if ( t == 'number' ) {
                        if ( value % 1 == 0 ) {
                            return 'INT';
                        } else {
                            return 'DOUBLE';
                        }
                    } else if ( t == 'object' ) {
                        if ( value.constructor == Array ) {
                            return 'ARRAY';
                        } else {
                            return 'MAP';
                        }
                    } else if ( t == 'string' ) {
                        return 'STRING';
                    } else if ( t == 'boolean' ) {
                        return 'BOOLEAN';
                    } else {
                        return 'UNKNOWN';
                    }
                }
            };

            let types = [];
            if ( scope.elements ) {
                scope.elements.forEach(function(e) {
                    let type = guessType(e.value);
                    if ( types.indexOf(type) < 0 ) {
                        types.push(type);
                    }
                });
                if ( types.length == 0 ) {
                    scope.contentDesc.type = 'STRING';
                } else if ( types.length == 1 ) {
                    scope.contentDesc.type = types[0];
                } else if ( types.length == 2 ) {
                    if (( types[0] == 'INT' && types[1] == 'DOUBLE' ) || ( types[1] == 'INT' && types[0] == 'DOUBLE' )) {
                        scope.contentDesc.type = 'DOUBLE';
                    } else { // Array of mixed types, not editing
                        scope.contentDesc.type = 'UNKNOWN';
                    }
                } else {  // Array of mixed types, not editing
                    scope.contentDesc.type = 'UNKNOWN';
                }
            } else {
                scope.contentDesc.type = 'STRING';
            }
        }
        }; }

    };
});

app.directive('autoconfigFormArrayElement',function() {
    return {
        restrict:'A',
        scope: {
            it: '=ngModel',
            paramDesc: '=',
            disabled: '='
        },
        templateUrl: '/templates/widgets/autoconfig/form-array-element.html',
        link: function(scope,element,attrs) {
            let updateValueForType = function(type) {
                let value = scope.it.value;
                let reinit = false;
                if ( value == null ) {
                    reinit = true;
                } else {
                    let t = typeof value;
                    if ( type == 'MAP' ) {
                        reinit = t != 'object' || value.constructor == Array;
                    } else if ( type == 'ARRAY' ) {
                            reinit = t != 'object' || value.constructor != Array;
                    } else if ( type == 'INT' || type == 'DOUBLE' ) {
                        reinit = t != 'number';
                    } else if ( type == 'BOOLEAN' ) {
                        reinit = t != 'boolean';
                    } else if ( type == 'STRING' || type == 'TEXTAREA' ) {
                        reinit = t != 'string';
                    }
                }
                if ( reinit ) {
                    if ( type == 'MAP' ) {
                        scope.it.value = {};
                    } else if ( type == 'ARRAY' || type == 'KEY_VALUE_LIST' ) {
                        scope.it.value = [];
                    } else if ( type == 'INT' || type == 'DOUBLE' ) {
                        scope.it.value = 0;
                    } else if ( type == 'BOOLEAN' ) {
                        scope.it.value = false;
                    } else if ( type == 'STRING' || type == 'TEXTAREA' ) {
                        scope.it.value = '';
                    } else {
                        scope.it.value = null;
                    }
                }
            };
            scope.$watch('paramDesc.type', function(nv, ov) {
                if ( ov == nv ) return;
                updateValueForType(scope.paramDesc.type);
            });
        }
    };
});

/**
 * Built on top of Suggestions directive.
 * It is different of gsField in many ways :
 *  - It accepts any type of inputs (while gsField is for numeric values only).
 *  - It does not validate a tag when clicking space.
 *  - It allows free inputs ie text not from the suggestions list.
 *  - It can takes the list of suggestions as parameters
 * @param {array} [tags] - The list of selected suggestions displayed as tags in the input.
 * @param {array} [options] - Optional list of suggestions. Used for static choices.
 * @param {function} [retrieveOptions] - Optional function, taking a callback as a parameter. Said callback takes the
 *        list of suggestions as its parameter. Used for custom choices, should be mutually exclusive with options.
 * @param {string} [placeholder] - Optional placeholder of the suggestions list.
 * @param {boolean} [allowDubs] - True to select a suggestion more than once.
 * @param {boolean} [allowFree] - True to be able to select text not in the suggestions.
 * @param {boolean} [number] - True to force tags to be numerical.
 * @param {boolean} [selectOnBlur] - True to validate the current input on blur. Only in free input mode.
 *
 * @example
 *      <div ng-model="likedMovies" type="text" multiselect-field options="moviesList" allow-free></div>
*/
app.directive('multiselectField', function($compile, $timeout, $q){
    return {
        restrict:'A',
        scope: {
            inputValue: '=ngModel',
            retrieveOptions: '=',
            options: '<',
            placeholder: '@',
        },
        link: function(scope, element, attrs) {

            let className = 'multiselect-field';
            element.html($compile(
                '<div class="' + className + '" ng-click="setFocus($event)" ng-class="{focus: hasFocus()}" ng-disabled="changesDisabled">' +
                    '<div class="tag" ng-class="{active: tagIndex == $index}" ng-click="selectTag($event, $index)" ng-repeat="tag in tags track by $index" scroll-to-me="{{tagIndex == $index}}">{{ tag }}' +
                    '<i class="icon-remove" ng-click="unselectSuggestion($event, $index)"></i></div>' +
                    '<div ng-model="newTag" suggestions="getSuggestions()" allow-no-suggestions show-suggestions-on-focus filter-suggestions-on-type floating-suggestions="false" suggestion-blur="inputBlur" callback="selectSuggestion(value, event)" placeholder="{{ placeholder }}" ng-disabled="changesDisabled"></div>' +
                    '<input type="text" class="fake" style="position:absolute; left:-1000px; right:-1000px; z-index: -1" ng-disabled="changesDisabled"/>' +
                '</div>')(scope));

            // stash in a field for sub-elements
            scope.changesDisabled = false;
            attrs.$observe("disabled", function() {
                scope.changesDisabled = "disabled" in attrs && attrs.disabled !== false;
            });

            scope.tagIndex = undefined;
            let input = element.find('.suggestions input');
            scope.newTag = '';

            scope.hasFocus = function() {
                return document.activeElement === input[0] || input.is(":focus") || element.find(".fake").is(":focus");
            };

            scope.syncInput = function () {
                input.value = scope.inputValue;
            }

            scope.selectTag = function(e, index) {
                e.stopPropagation();
                scope.tagIndex = index;
            };

            scope.inputBlur = function(e) {
                if (e) {
                    e.stopPropagation();
                    if (attrs.allowFree !== undefined && attrs.selectOnBlur !== undefined && scope.addTag()) {
                        e.preventDefault();
                    }
                }
            }

            scope.selectSuggestion = function(value, e) {
                if (scope.changesDisabled) return;
                if (!value) { return }
                const tagLabel = value.label || value;
                const tagIndex = value && scope.tags.indexOf(tagLabel);
                if (tagIndex >= 0 && !attrs.allowDubs) {
                    scope.unselectSuggestion(e, tagIndex);
                } else {
                    scope.newTag = value;
                    e.stopPropagation();
                    if (scope.addTag()) {
                        if (scope.suggestionsList) {
                            scope.suggestionsList.map(suggestion => {
                                if (suggestion.label === value.label) {
                                    suggestion.selected = true;
                                }
                            });
                        }
                        e.preventDefault();
                        scope.$broadcast('showSuggestions');
                    }
                }
            };

            scope.addTag = function() {
                if (scope.changesDisabled) return;
                var added = false;
                if (scope.newTag) {
                    // If the input is not part of the suggestions, add the tag only if free input is allowed.
                    if (scope.suggestionsList.indexOf(scope.newTag) === -1 && (attrs.allowFree === undefined)) {
                        return;
                    }

                    let tagLabel = scope.newTag.label || scope.newTag;

                    if (attrs.number !== undefined) {
                        if (isNaN(tagLabel)) {
                            return;
                        } else {
                            tagLabel = parseFloat(tagLabel);
                        }
                    }

                    if (attrs.allowDubs === 'true' || scope.tags.indexOf(tagLabel) === -1) {
                        // add tag
                        scope.tags.push(tagLabel);

                        // Get the corresponding value and add it to the model
                        const matchingOption = scope.options.find(option => {
                            return (option.label === tagLabel)
                        });

                        const matchingValue = matchingOption && matchingOption.value;

                        if (matchingValue) {
                            scope.inputValue.push(matchingValue);
                            scope.syncInput();
                        } else if (attrs.allowFree !== undefined) {
                            // If no suggestions, the input value already contains the proper information.
                            if (scope.suggestionsList.length > 0) {
                                scope.inputValue.push(tagLabel);
                                scope.syncInput();
                            } else {
                                input.value = '';
                            }
                        }

                        added = true;
                    } else {
                        return;
                    }

                    scope.newTag = '';

                    if(!scope.$root.$$phase) scope.$apply();
                    $timeout(function(){ scope.$broadcast('showSuggestions') });
                }
                return added;
            };

            scope.unselectSuggestion = function(e, index) {
                if (e) { e.originalEvent.stopPropagation() }
                if (scope.changesDisabled) return;

                if (index === null || index === undefined) {
                    index = scope.tagIndex;
                }
                let removedTag = scope.deleteTag(e, index);
                if (removedTag) {
                    if (scope.suggestionsList) {
                        scope.suggestionsList.map(suggestion => {
                            if (suggestion.label === removedTag) {
                                suggestion.selected = false;
                            }
                        });
                    }
                    e.preventDefault();
                    scope.$broadcast('showSuggestions');
                }
            };

            scope.deleteTag = function(e, index) {
                if (scope.changesDisabled) return;

                if (index !== undefined) {

                    let tagValue, tagLabel;
                    if (attrs.allowFree === undefined) {
                        let matchingOption = scope.options.filter(option => {
                            return option.label === scope.tags[index];
                        })[0];
                        tagValue = matchingOption.value;
                        tagLabel = matchingOption.label
                    } else {
                        tagValue = scope.tags[index].label || scope.tags[index];
                        tagLabel = scope.tags[index].label || scope.tags[index];
                    }

                    scope.inputValue = scope.inputValue.filter(value => {
                        return value !== tagValue;
                    });

                    scope.syncInput();
                    scope.tags.splice(index, 1);

                    if(scope.tags.length) {
                        // set tagIndex to former tag
                        scope.tagIndex = Math.max(index - 1, 0);
                    } else {
                        // otherwise set focus to input, but only if this was from a backspace deletion
                        if (!e) { input.focus() }
                    }

                    return tagLabel;
                }
            };

            scope.$watch('tagIndex', function() {
                if (!angular.isUndefined(scope.tagIndex)){
                    input.blur();
                    element.find(".fake").focus();
                }
            });

            input.on('focus', function() {
                scope.tagIndex = undefined;
            });

            scope.setFocus = function(e) {
                input.focus();
                e.stopPropagation();
            };

            scope.$on("$destroy", function() {
                $(element).off("keydown.tags");
            });

            $(element).on('keydown.tags', function(e) {
                if (scope.hasFocus()) {
                    if (e.keyCode == 37) { // left arrow
                        if (!angular.isUndefined(scope.tagIndex)) {
                            scope.tagIndex = Math.max(scope.tagIndex - 1, 0);
                            scope.$apply();
                        } else {
                            if(scope.newTag.length === 0){
                                scope.tagIndex = scope.tags.length - 1;
                                scope.$apply();
                            }
                        }
                    } else if (e.keyCode == 39) { // right arrow
                        if (!angular.isUndefined(scope.tagIndex)) {
                            scope.tagIndex = scope.tagIndex + 1;
                            if(scope.tagIndex >= scope.tags.length) {
                                scope.tagIndex = undefined;
                                input.focus();
                            }
                            scope.$apply();
                        }
                    } else if (e.keyCode == 8) { // delete
                        if (angular.isUndefined(scope.tagIndex)) {
                            if (scope.newTag.length === 0){
                                scope.tagIndex = scope.tags.length - 1;
                                scope.$apply();
                            }
                        } else {
                            e.preventDefault();
                            scope.unselectSuggestion(e);
                            scope.$apply();
                        }
                    } else if (e.keyCode == 13) { // Enter: If we added a tag, don't let the "enter" key trigger a form submit
                        e.stopPropagation();
                        if (!scope.newTag || scope.newTag.length === 0) { return }
                        if (scope.selectSuggestion(scope.newTag, e)) {
                            e.preventDefault();
                        }
                    }
                }
            });

            scope.inputValue = scope.inputValue || [];

            function finishOptionsInit() {
                scope.suggestionsList = setArrayValues(scope.suggestionsList, []);
                scope.tags = setArrayValues(scope.tags, []);
                scope.options.forEach(option => {
                    if (option.selected) {
                        if (!scope.inputValue.includes(option.value)) {
                            scope.inputValue.push(option.value);
                        }
                    }

                    const isInInput = scope.inputValue.includes(option.value);

                    if (isInInput) {
                        scope.tags.push(option.label);
                    }

                    scope.suggestionsList.push({
                        label: option.label,
                        selected: (option.selected === true) || isInInput
                    });
                });

                scope.syncInput();
            }

            // From the provided options, get the labels to fill the suggestions and the tags, and compute the selected values.
            if (scope.retrieveOptions) {
                scope.tags = [];
                scope.suggestionsList = [];

                scope.retrieveOptions(function(options) {
                    scope.options = setArrayValues(scope.options, options);
                    finishOptionsInit();
                });

            } else if (scope.options) {
                scope.tags = [];
                scope.suggestionsList = [];
                finishOptionsInit();

            } else if (attrs.allowFree !== undefined) {
                if (scope.inputValue) {
                    scope.tags = scope.inputValue;
                }
                scope.options = [];
                scope.suggestionsList = [];
                scope.syncInput();

            } else {
                scope.tags = [];
                scope.options = [];
                scope.suggestionsList = [];
                scope.syncInput();
            }

            scope.getSuggestions = function() {
                let deferred = $q.defer();
                deferred.resolve(scope.suggestionsList);
                return deferred.promise;
            };

            scope.$watch('tags', function(nv, ov) {
                // Sometimes someone rebinds the ngModel to null, in our case the API...
                if (nv === null || nv === undefined) {
                    scope.tags = [];
                }
            });

            scope.$watch('inputValue', function(nv) {
                // Update tags when ngModel (inputValue) changes
                if (nv !== null && attrs.allowFree !== undefined) {
                    scope.tags = scope.inputValue;
                }
            });
        }
    };
});

})();

(function(){
'use strict';

var app = angular.module('dataiku.widgets.futures', ['dataiku.services']);

/**
 * A simple helper to watch a future state.
 *
 *  - Does not auto-abort the future when going out of scope !
 *
 * call with FutureWatcher.watchJobId(jobId)
 */
app.service("FutureWatcher", function($q, DataikuAPI){

    function enrichPromise(deferred) {
        deferred.promise.success = function(fn) {
            deferred.promise.then(function(data) {
                fn(data.data, data.status, data.headers);
            });
            return deferred.promise;
        };

        deferred.promise.error = function(fn) {
            deferred.promise.then(null, function(data) {
                fn(data.data, data.status, data.headers);
            });
            return deferred.promise;
        };

        deferred.promise.update = function(fn) {
            deferred.promise.then(null, null,function(data) {
                fn(data.data, data.status, data.headers);
            });
            return deferred.promise;
        };
    }

    var FutureWatcher = {
        watchJobId : function(jobId) {
            var hasWaitedFor = 0;
            var delayBetweenCalls = 500;
            var deferred = $q.defer();
            enrichPromise(deferred);

            function refresh(){
                DataikuAPI.futures.getUpdate(jobId).success(function(data,status,headers) {
                    hasWaitedFor += delayBetweenCalls;
                    var kwargs = {data:data, status:status, headers:headers};
                    if (data.hasResult || data.unknown) {
                        deferred.resolve(kwargs);
                    } else {
                        if (hasWaitedFor > 300000) { // 5min
                            delayBetweenCalls = 10000;
                        } else if (hasWaitedFor > 120000) { // 2min
                            delayBetweenCalls = 3000;
                        } else if (hasWaitedFor > 30000) { // 30s
                            delayBetweenCalls = 1000;
                        }
                        deferred.notify(kwargs);
                        window.setTimeout(refresh, delayBetweenCalls);
                    }
                }).error(function(data, status, headers){
                    var kwargs = {data:data, status:status, headers:headers};
                    deferred.reject(kwargs);
                });
            }

            refresh();

            return deferred.promise;
        },
        watchPeekJobId : function(jobId) {
            var hasWaitedFor = 0;
            var delayBetweenCalls = 500;
            var deferred = $q.defer();
            enrichPromise(deferred);

            function refresh(){
                DataikuAPI.futures.peekUpdate(jobId).success(function(data,status,headers) {
                    hasWaitedFor += delayBetweenCalls;
                    var kwargs = {data:data, status:status, headers:headers};
                    if (data.hasResult || data.unknown) {
                        deferred.resolve(kwargs);
                    } else {
                        if (hasWaitedFor > 300000) { // 5min
                            delayBetweenCalls = 10000;
                        } else if (hasWaitedFor > 120000) { // 2min
                            delayBetweenCalls = 3000;
                        } else if (hasWaitedFor > 30000) { // 30s
                            delayBetweenCalls = 1000;
                        }
                        deferred.notify(kwargs);
                        window.setTimeout(refresh, delayBetweenCalls);
                    }
                }).error(function(data, status, headers){
                    var kwargs = {data:data, status:status, headers:headers};
                    deferred.reject(kwargs);
                });
            }
            refresh();
            return deferred.promise;
        }
    }
    return FutureWatcher;
});

app.service("FutureProgressModal", function(FutureWatcher, $q, CreateModalFromTemplate, ProgressStackMessageBuilder, DataikuAPI, $timeout){
    var FutureProgressModal = {
        // Returns a promise that resolves when the future is done but never rejects
        show : function(parentScope, initialResponse, modalTitle, afterCompileCallback, backdrop, keyboard, useDkuLoader) {

            var deferred = $q.defer();
            if ( initialResponse.hasResult ) {
                // Keep the last log if any
                if (angular.isObject(initialResponse.result) && initialResponse.log) {
                    initialResponse.result.futureLog = initialResponse.log;
                }
                deferred.resolve(initialResponse.result);
            } else {
                parentScope.useDkuLoader = useDkuLoader;
                CreateModalFromTemplate("/templates/widgets/future-progress-modal.html", parentScope, null, function(newScope) {
                    newScope.onFailure = function() {};
                    if (afterCompileCallback) {
                        afterCompileCallback(newScope);
                    }
                    newScope.futureResponse = initialResponse;
                    newScope.modalTitle = modalTitle;
                    newScope.percentage = 0;

                    newScope.abort = function () {
                        DataikuAPI.futures.abort(initialResponse.jobId).error(setErrorInScope.bind(newScope));
                    };
                    
                    FutureWatcher.watchJobId(initialResponse.jobId)
                    .success(function(data) {
                        newScope.finalResponse = data;
                        newScope.futureResponse = null;
                        newScope.dismiss();
                        if (angular.isObject(data.result) && data.log) {
                            data.result.futureLog = data.log;
                        }
                        deferred.resolve(data.result);
                    }).update(function(data){
                        newScope.percentage =  ProgressStackMessageBuilder.getPercentage(data.progress);
                        newScope.futureResponse = data;
                        newScope.stateLabels = ProgressStackMessageBuilder.build(newScope.futureResponse.progress, true);
                    }).error(function(data, status, headers) {
                        console.info(data)
                        // Remove the future response to remove progress bar / state
                        newScope.futureResponse = null;
                        // Keep the failure log
                        newScope.failureLog = data.logTail;
                        deferred.reject({data: data, status: status, headers: headers});
                        setErrorInScope.bind(newScope)(data, status, headers);
                    });
                }, undefined, backdrop, keyboard);
            }

            return deferred.promise;
        },

        /* Shows the modal only if the job is still running.
         * Does not take the job from the future service
         * The modal disappears automatically if the job succeeds.
         * Returns a promise that resolves when the future succeeds
         */
        showPeekOnlyIfRunning : function(parentScope, jobId, modalTitle){
            var newScope = parentScope.$new();
            var shown = false;
            var theModalScope = null;

            var deferred = $q.defer();

            function showIfNeeded(){
                if (!shown) {
                    shown = true;
                    CreateModalFromTemplate("/templates/widgets/future-progress-modal.html", newScope, null, function(modalScope){
                        theModalScope = modalScope;
                        modalScope.modalTitle = modalTitle;

                        newScope.abort = function() {
                            DataikuAPI.futures.abort(jobId)
                                .success(modalScope.dismiss)
                                .error(setErrorInScope.bind(modalScope));
                        };
                    });
                }
            }

            FutureWatcher.watchPeekJobId(jobId)
            .success(function(data) {
                newScope.futureResponse = null;
                if (theModalScope) theModalScope.dismiss();
                deferred.resolve();
            }).update(function(data){
                if (data.alive == false) {
                    if (theModalScope) theModalScope.dismiss();
                    deferred.resolve();
                } else {
                    showIfNeeded();
                    newScope.percentage =  ProgressStackMessageBuilder.getPercentage(data.progress);
                    newScope.futureResponse = data;
                    newScope.stateLabels = ProgressStackMessageBuilder.build(newScope.futureResponse.progress, true);
                }
            }).error(function(data, status, headers) {
                newScope.futureResponse = null;
                setErrorInScope.bind(newScope)(data, status, headers);
                deferred.reject({data: data, status: status, headers: headers});
            });

            return deferred.promise;
        },
        
        reopenableModal : function(parentScope, initialResponse, modalTitle) {
            var handle = {shown:false};
            var deferred = $q.defer();
            if ( initialResponse.hasResult ) {
                deferred.resolve(initialResponse.result);
            } else {
                var hooks = {};
                handle.open = function() {
                    if (handle.shown) return;
                    handle.shown = true;
                    CreateModalFromTemplate("/templates/widgets/future-progress-modal.html", parentScope, null, function(newScope){
                        if (hooks.isDone) {
                            // too slow to open
                            $timeout(function() {newScope.dismiss();}); // because dismiss() isn't even in the scope at this point
                            return;
                        }
                        newScope.futureResponse = initialResponse;
                        newScope.modalTitle = modalTitle;
                        newScope.percentage = 0;
                        
                        newScope.abort = function() {
                            DataikuAPI.futures.abort(initialResponse.jobId).error(setErrorInScope.bind(newScope));
                        }
                        // react to changes in the future state
                        hooks.update = function(data) {
                            newScope.percentage =  ProgressStackMessageBuilder.getPercentage(data.progress);
                            newScope.futureResponse = data;
                            newScope.stateLabels = ProgressStackMessageBuilder.build(newScope.futureResponse.progress, true);
                        };
                        hooks.success = function(data) {
                            newScope.finalResponse = data;
                            newScope.futureResponse = null;
                            newScope.dismiss();
                        };
                        hooks.error = function(data, status, headers) {
                            newScope.futureResponse = null;
                            setErrorInScope.bind(newScope)(data, status, headers);
                        };
                        newScope.$on("$destroy", function() {
                            // stop listening on the changes to the future
                            delete hooks.success;
                            delete hooks.update;
                            delete hooks.error;
                            handle.shown = false;
                        });
                    });
                };
                FutureWatcher.watchJobId(initialResponse.jobId)
                .success(function(data) {
                    hooks.isDone = true;
                    if (hooks.success) {
                        hooks.success(data);
                    }
                    deferred.resolve(data.result);
                }).update(function(data){
                    if (hooks.update) {
                        hooks.update(data);
                    }
                }).error(function(data, status, headers) {
                    hooks.isDone = true;
                    if (hooks.error) {
                        hooks.error(data, status, headers);
                    }
                    deferred.reject({data: data, status: status, headers: headers});
                });
            }
            handle.promise = deferred.promise; 
            return handle;
        }
    }
    return FutureProgressModal;
});



})();

(function(){
'use strict';

var app = angular.module('dataiku.widgets.integrations', ['dataiku.services']);


app.directive("integrationChannelSelector", function($state, $stateParams, $rootScope, DataikuAPI, CreateModalFromTemplate, ScenarioIntegrations){
    return {
        scope : {
            integrationType : '=',
            model : '=',
            field : '@',
            scenarioIntegrationType : '=',
            channel: '=?bind'
        },
        templateUrl : '/templates/widgets/integration-channel-selector.html',
        link : function($scope, element, attrs) {
            function setChannel(channelId) {
                $scope.channel = channelId && $scope.availableChannels && $scope.availableChannels.filter(ch => ch.id == channelId)[0];
            }

            $scope.$watch('integrationType', function(nv) {
                if (nv) {
                    $scope.isDSSAdmin = $rootScope.isDSSAdmin;
                    $scope.adminChannelsPath = $state.href('admin.general.notifications') + '#messaging-channels';
                    $scope.wl = $rootScope.wl;
                    $scope.availableChannels = null;
                    $scope.getIntegrationTypeLabel = ScenarioIntegrations.getLabelByType;
                    DataikuAPI.integrations.listChannelsForIntegrationType($scope.integrationType).success(function(data){
                        $scope.availableChannels = data.map(function(x) {
                            x["label"] = x.id + " (" + x.type + ")";
                            return x;
                        });
                        setChannel($scope.model[$scope.field]);
                    }).error(setErrorInScope.bind($scope));
                }
            });

            $scope.$watch('model[field]', channelId => setChannel(channelId));

            $scope.$watch('channel', (newChannel, oldChannel) => {
                // Re-instanciate previous channel state when it is emptied (happens on save step)
                if (!newChannel && oldChannel) $scope.channel = oldChannel;
            });
        }
    }
});

})();

(function(){
'use strict';

    const app = angular.module('dataiku.widgets.drawers', ['dataiku.filters', 'dataiku.services']);


    app.directive('topbarDrawer', function($timeout) {
        return {
            scope: true,
            link: function(scope, element, attrs) {
                scope.shown = false;
                $(element).hide();

                function hideIfClickElsewhere (event) {
                    if (event.target) {
                        var e = event.target;
                        // go back up to find a bootstrap-select or absence of <body> (that would indicate we're after a bootstrap-select closed itself)
                        var i = 0;
                        while (e) {
                            if (e.classList && e.classList.indexOf && e.classList.indexOf("bootstrap-select") >= 0) return;
                            if (e.tagName.toLowerCase() == 'body') break;
                            e = e.parentElement;
                        }
                        if (e == null) return;
                    }
                    if (!element.get(0).contains(event.target) && !event.target.classList.contains("dropdown-menu")) {
                        hide();
                    }
                }

                function hide () {
                    element.hide();
                    $("html").unbind("click", hideIfClickElsewhere);
                    scope.shown = false;
                }

                function show () {
                    scope.shown = true;
                    $(element).show();
                    window.setTimeout(function() { $("html").click(hideIfClickElsewhere);}, 0);
                }

                scope.toggle = function() {
                    if (scope.shown) hide(); else show();
                };

                scope.$on('$stateChangeSuccess', hide);
            }
        };
    });

    app.directive('adminDrawer', function($rootScope, $filter, DataikuAPI) {
        return {
            restrict: 'A',
            templateUrl : '/templates/widgets/topbar_drawers/admin-drawer.html',
            link : function(scope, element, attrs) {

                $rootScope.toggleAdminDrawer = function() {
                    scope.toggle();
                    if (scope.shown) {
                        //
                    }
                };
            }
        };
    });

    app.directive('helpDrawer', function($rootScope, $filter, DataikuAPI, CoachmarksService) {
        return {
            restrict: 'A',
            templateUrl : '/templates/widgets/topbar_drawers/help-drawer.html',
            link : function(scope, element, attrs) {

                $rootScope.toggleHelpDrawer = function() {
                    scope.toggle();
                    if (scope.shown) {
                        //
                    }
                };


        	    /* ********** UI ************ */

            	scope.closeMenu = function(){
            		ContextualMenu.prototype.closeAny();
            	}

            	scope.globallyEnableCoachmarks = function() {
                    CoachmarksService.enableAllSeries();
                    scope.currentSerieStatus.enabled = true;
                };

                scope.globallyDisableCoachmarks = function() {
                    CoachmarksService.disableAllSeries();
                    scope.currentSerieStatus.enabled = false;
                };

                scope.switchCurrentCoachmarkDisplay = function() {
                    var currentSerieId = CoachmarksService.getCurrentSerieId();
                    if (currentSerieId) {
                        if (CoachmarksService.isSerieDisabled(currentSerieId)) {
                            CoachmarksService.enableSerie(currentSerieId);
                        } else {
                            CoachmarksService.disableSerie(currentSerieId);
                        }
                    }
                };

                scope.getCurrentSerieId = function() {
                    return CoachmarksService.getCurrentSerieId();
                }

                scope.isCoachmarksHardDisabled = function() {
                    return CoachmarksService.isCoachmarksHardDisabled();
                }
                
                scope.$watch(() => CoachmarksService.getCurrentSerieId(), (nv, ov) => {
                    scope.currentSerieStatus = {
                        enabled : CoachmarksService.getCurrentSerieId() && !CoachmarksService.isSerieDisabled(CoachmarksService.getCurrentSerieId())
                    }
                })
            }
        };
    });

    app.directive('userDrawer', function($rootScope, $filter, DataikuAPI) {
        return {
            restrict: 'A',
            templateUrl : '/templates/widgets/topbar_drawers/user-drawer.html',
            link : function(scope, element, attrs) {
                scope.context = "drawer";
                var acknowledged = false;

                function getNotifications () {
                    DataikuAPI.notifications.get().success(update).error(setErrorInScope.bind(scope));
                }

                function ack () {
                    if (!scope.shown || !scope.pnotifications || acknowledged || !scope.pnotifications.totalUnread) {
                        return;
                    }
                    DataikuAPI.notifications.ack(scope.pnotifications.timestamp).error(setErrorInScope.bind(scope));
                    acknowledged = true;
                }

                function humanReadableObjectType (objectType) {
                    if (!objectType) return;
                    switch(objectType) {
                    case "MANAGED_FOLDER":
                        return "folder";
                    case "SAVED_MODEL":
                        return "model";
                    case "MODEL_EVALUATION_STORE":
                        return "evaluation store";
                    case "LAMBDA_SERVICE":
                        return "API service";
                    default:
                        return objectType.toLowerCase().replace('_', ' ');
                    }
                }

                function update (data) {
                    scope.timelineReady = true;
                    scope.pnotifications = data;
                    if (!data || !data.notifications) {
                        return;
                    }

                    //add a "day" attribute to all the menu elements to show grouping by day
                    $.each(data.notifications, function(idx, elt) {
                        elt.day = $filter('friendlyDate')(elt.timestamp);
                        if (elt.evt.objectType) {
                            elt.evt.humanReadableObjectType = humanReadableObjectType(elt.evt.objectType);
                        }
                        if (elt.evt.item) {
                            elt.evt.item.humanReadableObjectType = humanReadableObjectType(elt.evt.item.objectType);
                        }
                    });


                    var orderedItems = $filter('orderBy')(data.notifications, '-timestamp');
                    orderedItems = orderedItems.slice(0, maxItems);

                    /* Insert days separators */
                    scope.orderedItemsWithDays = [];
                    orderedItems.forEach(function(x, i) {
                        if (i === 0) {
                            scope.orderedItemsWithDays.push({isSeparator: true, day : x.day});
                            scope.orderedItemsWithDays.push(x);
                        } else if (x.day === orderedItems[i-1].day) {
                            scope.orderedItemsWithDays.push(x);
                        } else {
                            scope.orderedItemsWithDays.push({isSeparator: true, day : x.day});
                            scope.orderedItemsWithDays.push(x);
                        }
                    });

                    acknowledged = false;

                    ack();
                }

                $rootScope.toggleUserDrawer = function() {
                    scope.toggle();
                    if (scope.shown) {
                        maxItems = 15;
                        scope.timelineReady = false;
                        getNotifications();
                    }
                };

                var maxItems = 15;
                scope.scroll = function() {
                    if (!scope.shown || !scope.pnotifications || !scope.pnotifications.notifications) return;
                    maxItems += 5;
                    update(scope.pnotifications);
                };
            }
        };
    });

    app.directive('activityDrawer', function($rootScope, DataikuAPI, ActiveProjectKey) {
        return {
            restrict: 'A',
            templateUrl : '/templates/widgets/topbar_drawers/activity-drawer.html',
            link : function(scope) {
                scope.runnings = [];

                function isScenarioFuture(future) {
                    try {
                        return future.payload.action == 'run_scenario';
                    } catch (e) {}
                    return false;
                }

                scope.getActivityInfo = function() {
                    DataikuAPI.running.listPersonal().success(function(data) {
                        var runnings = [];
                        //scenario have normal futures, but we put them in another tab
                        data.futures.filter(function(f){return isScenarioFuture(f);}).forEach(function(o){
                            o.$runningType = 'scenario';
                            o.$id = o.scenarioId;
                            runnings.push(o);
                        });
                        data.futures.filter(function(f){return !isScenarioFuture(f);}).forEach(function(o){
                            o.$runningType = 'future';
                            o.$id = o.jobId;
                            runnings.push(o);
                        });
                        data.jobs.forEach(function(o){
                            o.$runningType = 'job';
                            o.$id = o.jobId;
                            runnings.push(o);
                        });
                        data.notebooks.forEach(function(o){
                            o.$runningType = 'notebook';
                            o.$id = o.name;
                            runnings.push(o)
                        });
                        scope.runnings = runnings;
                    }).error(setErrorInScope.bind(scope));
                };

                scope.getConnectedUsers = function() {
                    DataikuAPI.security.listConnectedUsers(ActiveProjectKey.get())
                        .success(connectedUsers => scope.connectedUsers = connectedUsers.filter(u => u.login !== scope.appConfig.user.login))
                        .error(setErrorInScope.bind(scope));
                }

                scope.Math = window.Math; // for the display of the running time

                // TODO : auto refresher but beware of huge calls
                // var refresher;
                // scope.$on('$destroy', function(){
                //     $interval.cancel(refresher);
                // });

                // scope.$watch('shown', function(nv){
                //     if (nv) { refresher = $interval(scope.getActivityInfo,5000) }
                //     else { $interval.cancel(refresher) };
                // })

                scope.refreshActivityDrawer = () => {
                    scope.getConnectedUsers();
                    scope.getActivityInfo();
                };

                $rootScope.toggleActivityDrawer = function() {
                    scope.toggle();
                    if (scope.shown) {
                        scope.refreshActivityDrawer();
                    }
                };
            }
        };
    });

    app.directive('conflictIcon',function($rootScope, $timeout, ConflictDetector) {
        return {
            restrict: 'A',
            transclude: true,
            templateUrl : '/templates/widgets/conflict-icon.html',
            link : function(scope, element) {

                var updateWarningState = function() {
                    scope.warn = false;
                    for(var k in scope.conflicts) {
                        if(scope.conflicts[k].warn) {
                            scope.warn = true;
                        }
                    }
                    if(scope.warn) {
                        element.addClass('warn');
                        if (scope.needToDisplayWarningPopUp) {
                            // First time there is a conflict on this page, we want to display the popup to let the user know
                            $timeout(function() {
                                var popoverIcon = element.find('>span');
                                if(popoverIcon && popoverIcon[0] && popoverIcon[0].showPopover) {
                                    popoverIcon[0].showPopover();
                                }
                            });

                            // Set the needToDisplayWarningPopUp variable to false, so we don't spam the user
                            scope.needToDisplayWarningPopUp = false;
                        }
                    } else {
                        // No more conflict
                        element.removeClass('warn');
                        scope.needToDisplayWarningPopUp = true;
                    }
                }
                $rootScope.$watch('appConfig.login',function(nv) {
                    scope.currentUserLogin = nv;
                });
                $rootScope.$on('conflict-list-changed',function() {
                    scope.conflicts = ConflictDetector.listConflicts();
                    updateWarningState();
                });
                scope.conflicts = ConflictDetector.listConflicts();
                scope.needToDisplayWarningPopUp = true;
                updateWarningState();
            }
        };

    });

    app.directive('futureMainTarget', function($filter) {
        return {
            scope: false,
            link: function($scope, element, attrs) {
                $scope.icon = null;
                var updateIcon = function() {
                    var future = $scope.$eval(attrs.futureMainTarget);
                    if (future && future.payload) {
                        // special cases first
                        if (future.payload.action == 'run_sql') {
                            $scope.icon = 'icon-code_sql_recipe';
                        } else if (future.payload.action == 'export') {
                            $scope.icon = 'icon-download';
                        } else if (future.payload.targets.length > 0) {
                            var main = future.payload.targets[0];
                            $scope.icon = $filter('typeToIcon')(main.objectType);
                        }
                    }
                };
                $scope.$watch(attrs.futureMainTarget, updateIcon);
            }
        };
    });
    app.directive('futureMainPayload', function($filter) {
        return {
            scope: false,
            link: function($scope, element, attrs) {
                $scope.futurePayload = null;
                $scope.futureDisplayName = null;
                var updatePayload = function() {
                    var future = $scope.$eval(attrs.futureMainPayload);
                    if (future && future.payload) {
                        if (future.payload.action == 'remote') {
                            $scope.futurePayload = future.payload.extras.remotePayload;
                            $scope.futureDisplayName = future.payload.extras.remotePayload.displayName;
                        } else {
                            $scope.futurePayload = future.payload;
                            $scope.futureDisplayName = future.jobDisplayName;
                        }
                    }
                };
                $scope.$watch(attrs.futureMainPayload, updatePayload);
            }
        };
    });
    app.directive('futureProgressBar', function(ProgressStackMessageBuilder) {
        return {
            scope: false,
            link: function($scope, element, attrs) {
                $scope.bar = {};
                var updateBar = function() {
                    var progress = $scope.$eval(attrs.futureProgressBar);
                    if (progress && progress.states && progress.states.length > 0) {
                        $scope.bar.percentage = ProgressStackMessageBuilder.getPercentage(progress);
                        $scope.bar.perpetual = false;
                    } else {
                        $scope.bar.perpetual = true;
                    }
                };
                $scope.$watch(attrs.futureProgressBar, updateBar, true);
            }
        };
    });

    app.directive('futureAbortConfirmation', function() {
        return {
            restrict: 'AE',
            scope : {
                future:'=futureAbortConfirmation',
                abortFn: '&',
                abortMsg: '=',
                abortTitle: '='
            },
            templateUrl: "/templates/widgets/topbar_drawers/future-abort-confirmation.html",
            link : function($scope, element, attrs) {
            }
        }
    });

    app.directive('activityFutureDisplay', function(DataikuAPI, StateUtils) {
        return {
            restrict: 'AE',
            scope : {
                future:'=activityFutureDisplay',
                refreshList:'=',
                inAdmin:'='
            },
            templateUrl: "/templates/widgets/topbar_drawers/activity-future-display.html",
            link : function($scope, element, attrs) {
                $scope.StateUtils = StateUtils;
                $scope.abortFuture = function(jobId) {
                    DataikuAPI.futures.abort(jobId).success(function(data) {
                        $scope.refreshList();
                    }).error(setErrorInScope.bind($scope));
                };
            }
        }
    });

    app.directive('activityScenarioDisplay', function(DataikuAPI, StateUtils) {
        return {
            restrict: 'AE',
            scope : {
                scenario:'=activityScenarioDisplay',
                refreshList:'=',
                inAdmin:'='
            },
            templateUrl: "/templates/widgets/topbar_drawers/activity-scenario-display.html",
            link : function($scope, element, attrs) {
                $scope.StateUtils = StateUtils;
                $scope.abortFuture = function(jobId) {
                    DataikuAPI.futures.abort(jobId).success(function(data) {
                        $scope.refreshList();
                    }).error(setErrorInScope.bind($scope));
                };
            }
        }
    });

    app.directive('activityClusterKernelDisplay', function(DataikuAPI, StateUtils) {
        return {
            restrict: 'AE',
            scope : {
                clusterKernel:'=activityClusterKernelDisplay',
                refreshList:'=',
                inAdmin:'='
            },
            templateUrl: "/templates/widgets/topbar_drawers/activity-cluster-kernel-display.html",
            link : function($scope, element, attrs) {
                $scope.StateUtils = StateUtils;
                $scope.abortKernel = function(clusterKernel) {
                    clusterKernel.aborted = true;
                    DataikuAPI.admin.clusters.abortKernel(clusterKernel.prefix, clusterKernel.kernelId).success(function(data) {
                        $scope.refreshList();
                    }).error(setErrorInScope.bind($scope));
                };
            }
        }
    });

    app.directive('activityNotebookDisplay', function(DataikuAPI, StateUtils) {
        return {
            restrict: 'AE',
            scope : {
                notebook:'=activityNotebookDisplay',
                refreshList:'=',
                inAdmin:'='
            },
            templateUrl: "/templates/widgets/topbar_drawers/activity-notebook-display.html",
            link : function($scope, element, attrs) {
                $scope.StateUtils = StateUtils;
                $scope.abortNotebook = function(jobId) {
                    DataikuAPI.jupyterNotebooks.unload(jobId).success(function(data) {
                        $scope.refreshList();
                    }).error(setErrorInScope.bind($scope));
                };
            }
        }
    });

    app.directive('activityJobDisplay', function(DataikuAPI, StateUtils) {
        return {
            restrict: 'AE',
            scope : {
                job:'=activityJobDisplay',
                refreshList:'=',
                inAdmin:'='
            },
            templateUrl: "/templates/widgets/topbar_drawers/activity-job-display.html",
            link : function($scope, element, attrs) {
                $scope.StateUtils = StateUtils;
                $scope.abortJob = function(projectKey, jobId) {
                    DataikuAPI.flow.jobs.abort(projectKey, jobId).success(function(data) {
                        $scope.refreshList();
                    }).error(setErrorInScope.bind($scope));
                };
            }
        }
    });


})();

(function() {
'use strict';

const app = angular.module('dataiku.directives.widgets');


app.directive('visualRecipe', function($rootScope, $timeout, $parse) {
    return {
        restrict: 'A',
        scope: true,
        link : function(scope, element, attrs) {
            var lastJobRunningState;
            scope.$watch("startedJob", function(){
                var jobRunningState = scope.isJobRunningOrStarting();
                if (!lastJobRunningState && jobRunningState) {
                    if (scope.uiState && scope.uiState.currentStep != 'output') {
                        scope.uiState.currentStep = 'output';
                    }
                }
                lastJobRunningState = jobRunningState;
            }, true);
        }
    };
});


app.factory("RecipeStatusHelper", function() {
    function dedup(list) {
        var ret = [];
        $.each(list, function(idx, el) {
            if (el && ret.indexOf(el) < 0) {
                ret.push(el);
            }
        })
        return ret;
    }

    var svc = {
        getStepMessages : function(stepName, recipeStatus) {
            if (!recipeStatus || !recipeStatus[stepName]) {
                return;
            }
            var status = recipeStatus[stepName];
            return status.messages;
        },
        getStepStatus : function(stepName, recipeStatus) {
            if (!recipeStatus || !recipeStatus[stepName]) {
                return;
            }
            return recipeStatus[stepName];
        },
        getStepErrors : function(stepName, recipeStatus) {
            return svc.getErrors(svc.getStepMessages(stepName, recipeStatus));
        },
        getStepWarnings : function(stepName, recipeStatus) {
            return svc.getWarnings(svc.getStepMessages(stepName, recipeStatus));
        },
        getStepConfirmations : function(stepName, recipeStatus) {
            return svc.getConfirmations(svc.getStepMessages(stepName, recipeStatus));
        },
        getStepStatusClass : function(stepName, recipeStatus) {
            return svc.getStatusClass(svc.getStepStatus(stepName, recipeStatus));
        },
        getErrors : function(statusMessages) {
            if (statusMessages) {
                return dedup(statusMessages.filter(function(x) { return x.severity == "ERROR"}));
            }
        },
        getWarnings : function(statusMessages) {
            if (statusMessages) {
                return dedup(statusMessages.filter(function(x) { return x.severity == "WARNING"}));
            }
        },
        getConfirmations : function(statusMessages) {
            if (statusMessages) {
                return dedup(statusMessages.filter(function(x) { return x.severity == "INFO"}));
            }
        },
        getStatusClass : function(status) {
            if (!status) {
                return "";
            }
            if (status.error) {
                return "invalid-step"
            }
            if (status.warning) {
                return "step-with-warnings"
            }
            return "valid-step"
        }
    };
    return svc;
});

/*
Pipline elements indincating the steps of a recipe step
- the parent scope must have a 'uiState.currentStep' variable
- the parent scope should have a recipeStatus variable and a updateRecipeStatusLater function
*/
app.directive('recipeStep', function($timeout, RecipeStatusHelper) {
    return {
        restrict: 'EA',
        templateUrl: "/templates/recipes/visual-recipes-fragments/visual-recipe-step.html",
        scope: true,
        link : function(scope, element, attrs) {
            scope.stepName = attrs.recipeStep;
            scope.stepLabel = attrs.stepLabel;

            scope.changeStep = function(stepName) {
                if (stepName && scope.$parent.uiState.currentStep != stepName) {
                    scope.$parent.uiState.currentStep = stepName;
                    if (scope.updateRecipeStatusLater) {
                        scope.updateRecipeStatusLater();
                    }
                    $timeout(function() {
                        scope.$parent.$broadcast('redrawFatTable');
                    });
                }
            };

            scope.getStepStatusClass = function(stepName) {
                return RecipeStatusHelper.getStepStatusClass(stepName, scope.recipeStatus);
            };

            scope.getStepErrors = function(stepName) {
                return RecipeStatusHelper.getStepErrors(stepName, scope.recipeStatus);
            };

            scope.getStepWarnings = function(stepName) {
                return RecipeStatusHelper.getStepWarnings(stepName, scope.recipeStatus);
            };

            scope.getStepConfirmations = function(stepName) {
                return RecipeStatusHelper.getStepConfirmations(stepName, scope.recipeStatus);
            };
        }
    };
});


/*
Widget for output columns computed with formulas (DSS or SQL)
*/
app.directive('computedColumnEditor', function($rootScope, $timeout, $parse, CodeMirrorSettingService) {
    return {
        restrict: 'EA',
        scope: true,
        link : function(scope, element, attrs) {
            //finish codemirror setup when the UI is ready
            $timeout(function(){
                $('.CodeMirror', element).each(function(idx, el) {
                    var cm = el.CodeMirror;
                    cm.on("blur", function(){
                        scope.blur();
                    });
                    cm.refresh();
                });
            });

            scope.blur = function() {
                $timeout(function() {
                    if ($('*', element).is(":focus")) {
                        return;
                    }
                    scope.hooks.updateRecipeStatus();
                });
            };

            var columns;
            if(attrs.columns) {
                //columns attribute shouls be a function!
                columns = $parse(attrs.columns);
            }

            scope.dssEditorOptions = {
                mode:'text/grel',
                theme:'elegant',
                indentUnit: 4,
                variables: columns,
                lineNumbers : false,
                lineWrapping : true,
                autofocus: true,
                onLoad: function(cm) {
                    cm.on("keyup", function(cm, evt) {
                        /* Ignore tab, esc, and navigation/arrow keys */
                        if (evt.keyCode == 9 || evt.keyCode == 27 || (evt.keyCode>= 33 && evt.keyCode <= 40)) {
                            return;
                        } else {
                            var options = {
                                columns: columns,
                                completeSingle: false
                            }
                            CodeMirror.commands.autocomplete(cm, null, options);
                        }
                    });
                }
            };

            scope.sqlEditorOptions = CodeMirrorSettingService.get('text/x-sql');
            scope.sqlEditorOptions.autofocus = true;
        }
    };
});


app.directive("visualRecipesErrorsPopover", function($window) {
    return {
        scope : true,
        link : function(scope, element, attrs) {
            var popover = $(element).find(".popover");
            popover.detach();
            var shown = false;
            var hide = function() {
                popover.hide();
                shown = false;
                element.removeClass('open');
                popover.detach();
            };
            var show = function() {
                shown = true;
                $("body").append(popover);
                popover.show();
                popover.css("top", $window.Math.min($(element).offset().top, $($window).height() - popover.height()));
                element.addClass('open');
            }

            scope.errors = null;
            scope.warnings = null;

            scope.onenter = function() {
                if (!($.isEmptyObject(scope.errors) && $.isEmptyObject(scope.warnings) && $.isEmptyObject(scope.confirmations))) {
                    show();
                }
            }
            scope.onleave = function() {
                hide();
            }


            var updateErrorsAndWarnings = function() {
                scope.errors = scope.getStepErrors(scope.stepName);
                scope.warnings = scope.getStepWarnings(scope.stepName);
                scope.confirmations = scope.getStepConfirmations(scope.stepName);
            }

            var lastStatus = null;
            scope.$watch("recipeStatus", function(recipeStatus){
                if (!recipeStatus || angular.equals(recipeStatus[scope.stepName], lastStatus)) return;
                lastStatus = recipeStatus;
                updateErrorsAndWarnings();
            }, true);

        }
    }
});

})();
(function(){
    'use strict';

    var app = angular.module('dataiku.directives.snippetEditor', ['dataiku.filters', 'dataiku.services', 'ui.keypress', 'dataiku.common.lists']);

	app.directive('codeSnippetEditorSwitch', function() {
		return {
			scope: {
				codeSamplesSelectorVisible: '='
			},
			controller : function($scope, $timeout) {
				//showing and hiding the codeSnippetEditorSampleSelector
	        	$scope.switchCodeSamplesSelectorVisibility = function() {
	        		$scope.codeSamplesSelectorVisible = ! $scope.codeSamplesSelectorVisible;

	        		$timeout(function(){
	        			$($('.sample-search input:visible')[0]).focus();
	            	});
	        	}
			},
			templateUrl : '/templates/widgets/code-snippet-editor-switch.html'
		}
	});


	app.directive('codeSnippetSampleSelector', function() {
		return {
			restrict: 'E',
			replace: true,
			templateUrl : '/templates/widgets/code-snippet-sample-selector.html',
			scope : {
				insertCodeFunc : '=',
				codeSamplesSelectorVisible : '=',
				sampleType : '=',
				categories : '=',
				saveCategory : '=',
				insertButtonLabel : '=?'
			},
			controller : function($scope, $timeout, DataikuAPI, ListFilter, WT1) {
				//Preparing parameters for nested directive

				//--resolveCodeForPreviewFunc: code sample previewing
				$scope.resolveCodeForPreviewFunc = function(variation) {
			    	return variation.code;
			    };

	        	//-- reloadSampleListFunc: method used to reload the code sample list
	        	$scope.reloadSampleListFunc = function() {
	            	DataikuAPI.flow.snippets.getSnippets($scope.sampleType, $scope.categories).success(function(data) {
	            		$scope.recipeSamples = data;
	                }).error(setErrorInScope.bind($scope));
	        	}

	        	//--recipeSamples: code samples list to populate the code sample selector in the first place
	        	$scope.reloadSampleListFunc();

	        	//-- insertCodeOnEnterKeyFunc: insert displayed sample's when enter key is pressed
	        	$scope.insertCodeOnEnterKeyFunc = function(sample) {
	        		if (typeof(sample)!=='undefined' && typeof(sample.variations)!=='undefined' && sample.variations.length>0) {
	        			var hasCodeToInsert = false;
	        			for (var i = 0; i<sample.variations.length; i++) {
	        				if (typeof(sample.variations[i])!=='undefined' && typeof(sample.variations[i].code)!=='undefined' && sample.variations[i].code!='') {
	        					hasCodeToInsert = true;
	        					break;
	        				}
	        			}
	        			if (hasCodeToInsert) {
	        				$scope.insertCodeFunc(sample);
	        				WT1.event("insert-snippet", {sampleType : $scope.sampleType, saveCategory : $scope.saveCategory, id : sample.id});
							return true;
	        			}
					}
	        		return false;
	        	}

	        	//Filtering
	        	$scope.recipeSamples = [];
	        	$scope.filteredRecipeSamples = [];

	        }
		}
	});

	app.directive('codeSnippetEditor', function($rootScope) {
		return {
			restrict: 'AE',
			replace: true,
			templateUrl : '/templates/widgets/code-snippet-editor.html',
			transclude: true,
			scope : {
				//CM parameters
				code : '=',
				editorOptions : '=?',
				//Loading samples parameters
	            sampleType : '=',
	            categories : '=',
	            saveCategory : '=',
	            //Previewing and inserting samples parameters
	            resolveCodeForPreviewFunc : '=?',
	            resolveCodeForInsertionFunc : '=?',
	            displayed : '='
	        },
	        controller : function($scope, $element, $timeout, DataikuAPI, ListFilter, WT1, CodeMirrorSettingService) {
	        	//Checking editorOptions parameters
	        	if (typeof($scope.editorOptions)==='undefined') {
                    $scope.editorOptions = CodeMirrorSettingService.get('text/x-python', {onLoad: function(cm) {$scope.codeMirror = cm;}});
	        	} else if (typeof($scope.editorOptions.onLoad)!=='function') {
	        		$scope.editorOptions.onLoad = function (cm) {
	        			 $scope.codeMirror = cm;
	        		}
	        	} else {
	        		var passedOnloadFunc = $scope.editorOptions.onLoad;
	        		$scope.editorOptions.onLoad = function(cm) {
	        			passedOnloadFunc(cm);
	        			$scope.codeMirror = cm;
	        		}
	        	}

	        	//Preparing parameters for nested directive

	        	//--insertCodeFunc: method used to insert code sample into code mirror instance
	        	var insertCode = function (codeToInsert) {
	        		//timeout to make sure of an angular safe apply
	        		$timeout(function() {
	        			$scope.codeMirror.replaceSelection(codeToInsert + '\n\n', "around");
	        		});

	                $scope.codeMirror.focus();
	            }

	        	if (typeof($scope.resolveCodeForInsertionFunc)==='function') {
	            	$scope.insertCodeFunc = function (sample) {
	            		var code = $scope.resolveCodeForInsertionFunc(sample);
	            		insertCode(code);
	            	}
	            } else {
	            	 $scope.insertCodeFunc = function(sample) {
	            		 var code = sample.code;
	            		 insertCode(code);
	                 }
	            }

	        	//-- insertCodeOnEnterKeyFunc: insert displayed sample's first variation when enter key is pressed
	        	$scope.insertCodeOnEnterKeyFunc = function(sample) {
	        		if (typeof(sample.variations)!=='undefined'
					&& sample.variations.length>0
					&& typeof(sample.variations[0])!='undefined'
					&& typeof(sample.variations[0].code)!='undefined'
					&& sample.variations[0].code != "") {
						$scope.insertCodeFunc(sample.variations[0]);
						WT1.event("insert-snippet", {sampleType : $scope.sampleType, saveCategory : $scope.saveCategory, id : sample.id});
						return true;
					}
	        		return false;
	        	}

	        	//-- reloadSampleListFunc: method used to reload the code sample list
	        	$scope.reloadSampleListFunc = function() {
	        		$scope.recipeSamples = [];
	        		DataikuAPI.flow.snippets.getSnippets($scope.sampleType, $scope.categories).success(function(data) {
	            		$scope.recipeSamples = data;
	                }).error(setErrorInScope.bind($scope));
	        	}

	        	//--recipeSamples: code samples list to populate the code sample selector in the first place
	        	$scope.reloadSampleListFunc();

	        	//--filtering: query bar
	        	$scope.recipeSamples = [];
	        	$scope.filteredRecipeSamples = [];

	        	//--filtering: tag filter
	        	$scope.snippetTags = [];
	    		$scope.snippetTagsMap = {};

	        	//Wrapping parameters needed by the view for scope issue
	        	$scope.editorParams = $scope;

		        // UI state for codeSamplesSelectorVisible
		        $scope.codeSamplesSelectorVisible = false;

	        	// attribute to listen on so that we can refresh the codemirror when
	        	// display is toggled between 'none' and 'visible' (for custom python model)
	        	$scope.$watch("displayed", function() {
	        		$element.find('.CodeMirror').each(function(i, el){
	        			if (el.CodeMirror != undefined) {
	        	        	setTimeout(function() {el.CodeMirror.refresh();}, 0);
	        	        }
	        		});
	        	}, true);
	        }
		}
	});

	/*
	 * ------------------------- READING -------------------------
	 */

	app.directive('codeSnippetEditorSampleList', function($timeout, $window, Logger) {
		return {
			link : function($scope, element) {

				$scope.displayedSample = {};

				/*
				 * display and hide sample preview
				 */
				$scope.isSampleDisplayedFunc = function(sample) {
					return typeof($scope.displayedSample)!=='undefined' && sample.id == $scope.displayedSample.id;
				}

				$scope.isAnySampleDisplayed = function() {
					return typeof($scope.displayedSample)!=='undefined' && typeof($scope.displayedSample.id)!=='undefined';
				}

				$scope.displaySampleFunc = function(displayedSample) {
					$scope.displayedSample = displayedSample;
				}

				$scope.hideSampleFunc = function() {
					$scope.displayedSample = {};
				}

				$scope.hideSampleOrCloseSelector = function() {
					if ($scope.isAnySampleDisplayed()) {
						$scope.hideSampleFunc();
					} else {
						$scope.codeSamplesSelectorVisible = false;
					}
				}

				$scope.hideSampleAndCloseSelector = function() {
					$scope.hideSampleFunc();
					$scope.codeSamplesSelectorVisible = false;
				}

				$scope.$watch('displayedSample', function(nv, ov) {
					if (ov.id !== nv.id) {
						if (typeof(nv.id)!=='undefined') {
							displaySample();
						}
					}
				}, true);

				$scope.$watch('filteredRecipeSamples', function(nv) {
					if ($scope.isAnySampleDisplayed()) {
						var displayedSampleStillInList = false;
						for (var i in nv) {
							var currentSample = nv[i];
							if (currentSample.id == $scope.displayedSample.id) {
								displayedSampleStillInList = true;
								break;
							}
						}
						if (!displayedSampleStillInList) {
							$scope.hideSampleFunc();
						}
					}
				}, true);

				var displaySample = function() {
					$timeout(function(){
	            		if(element.find(".sample-details .CodeMirror").length == 0) {
	            			var textAreas = element.find("textarea");
	            			for (var i=0; i<textAreas.length; i++) {
	            				Logger.info("Create a CodeMirror with lang ", $(textAreas[i]).data().codeMirrorLanguage);
	            				CodeMirror.fromTextArea(textAreas[i], createEditorOptions($(textAreas[i]).data().codeMirrorLanguage));
	            			}
	            		} else {
	            			var codeMirrors = element.find('.CodeMirror');
	            			for (var i=0; i<codeMirrors.length; i++) {
	            				codeMirrors[i].CodeMirror.refresh();
	            			}
	            		}
	            		//give focus back to the search query bar so keyboard navigation keeps on working
	            		$($('.sample-search input:visible')[0]).focus();
	            	});
				}

				//-- codeMirror editor option used to display code sample
	            var createEditorOptions = function(language){
	                var options = {
	                    readOnly : true,
	                    lineWrapping: true
	                };
	                if (typeof(language)!=='undefined') {
	                	options.mode = computeCodeMirrorMode(language);
	                }
	                return options;
	            };


				/*
				 * click listeners
				 */

				var isPartOfCodeSnippetEditor = function(node){
					return $(node).closest('.code-sample-selector, .create-sample-modal').length > 0;
            	}

				$scope.addClickListener = function() {
					angular.element($window).on('click', function(e) {
						if (!isPartOfCodeSnippetEditor(e.target)) {
            				$scope.hideSampleOrCloseSelector();
            				$scope.$apply();
            			}
            		});
            		$scope.$on('$destroy', function(){
            			$scope.removeClickListener();
            		});
				}

				$scope.removeClickListener = function() {
        			angular.element($window).off('click');
				}

				$scope.$watch('codeSamplesSelectorVisible', function(nv, ov) {
					if (nv) {
						$timeout($scope.addClickListener);
					} else {
						$timeout($scope.removeClickListener);
					}
				});

				/*
				 * keyboard navigation
				 */

				$scope.displayPreviousSample = function() {
					if (typeof($scope.displayedSample.id)!=='undefined') {
						var sampleToDisplay = {};
						var previousSample = {};
						for (var i=0; i<$scope.filteredRecipeSamples.length; i++) {
							var currentSample = $scope.filteredRecipeSamples[i];
							if (currentSample.id === $scope.displayedSample.id) {
								if (i==0) {
									sampleToDisplay = $scope.filteredRecipeSamples[$scope.filteredRecipeSamples.length-1];
								} else {
									sampleToDisplay = previousSample;
								}
								break;
							} else {
								previousSample = currentSample;
							}
						}
						if (typeof(sampleToDisplay.id)!=='undefined') {
							$scope.displaySampleFunc(sampleToDisplay);
						}
					}
				}

				$scope.displayNextSample = function() {
					var sampleToDisplay = {};
					if (typeof($scope.displayedSample.id)!=='undefined') {
						for (var i=0; i<$scope.filteredRecipeSamples.length; i++) {
							var currentSample = $scope.filteredRecipeSamples[i];
							if (currentSample.id === $scope.displayedSample.id) {
								if (i<$scope.filteredRecipeSamples.length-1) {
									sampleToDisplay = $scope.filteredRecipeSamples[i+1];
								} else {
									sampleToDisplay = $scope.filteredRecipeSamples[0];
								}
								break;
							}
						}
					} else {
						sampleToDisplay = $scope.filteredRecipeSamples[0];
					}
					if (typeof(sampleToDisplay.id)!=='undefined') {
						$scope.displaySampleFunc(sampleToDisplay);
					}
				}

				/*
				 * keyboard sample insert
				 */

				$scope.insertSampleShortcut = function() {
					if ($scope.isAnySampleDisplayed()) {
						var codeInserted = $scope.insertCodeOnEnterKeyFunc($scope.displayedSample);
						if (codeInserted) {
							$scope.hideSampleAndCloseSelector();
						}
					}
				}
			}
		}
	});

	app.directive("codeSnippetEditorInsertableSample", function($window, WT1) {
	    return {
	    	transclude: true,
	        scope : {
	        	resolveCodeForPreviewFunc : '=',
	            insertCodeFunc : '=',
	            reloadSampleListFunc : '=',

	            displaySampleFunc : '=',
	            hideSampleFunc : '=',
	            isSampleDisplayedFunc : '=',

	            sample : '=',
	            sampleType : '=',
	            saveCategory : '=',
	            mode : '=',
            	insertButtonLabel : '=?'
	        },
	        link : function($scope, element, attrs) {

	            //hiding and showing sample preview and documentation
	            $scope.showSample = function() {
	            	$scope.displaySampleFunc($scope.sample);
	            }
	            $scope.hideSample = function() {
	            	$scope.hideSampleFunc();
	            }

	            //inserting code into editor
	            $scope.insert = function (sample) {
	            	$scope.insertCodeFunc(sample);
	                $scope.hideSample();
	                $scope.$parent.$parent.codeSamplesSelectorVisible = false;
	                WT1.event("insert-snippet", {sampleType : $scope.sampleType, saveCategory : $scope.saveCategory, id : sample.id});
	            }

	            $scope.useMultiLanguageInsert = function() {
	                return $scope.sampleType === 'webapp_standard' || $scope.sampleType === 'webapp_shiny'
	            }

	            //--resolveCodeForPreviewFunc
	        	if (typeof($scope.resolveCodeForPreviewFunc)==='undefined') {
	        		$scope.resolveCodeForPreviewFunc = function(variation) {
				    	return variation.code;
				    };
	        	}
	        },
			templateUrl : '/templates/widgets/code-snippet-editor-insertable-sample.html'
	    }
	});

	/*
	 *  ------------------------- CREATION / EDITION / DELETION -------------------------
	 */

	app.directive('codeSnippetEditorCreateEditModalButton', function(Assert, CreateModalFromTemplate) {
		return {
			scope: {
				sampleType: '=',
				category: '=',
	            sample: '=',
	            template: '=',
	            controller: '=',
	            reloadSampleListFunc: '=',
	            hideSampleFunc:'=',
	            forceMode: '='
			},
			controller: function($scope) {
				Assert.inScope($scope, 'category');
				$scope.MODES = {
					CREATE : 'CREATE',
					EDIT : 'EDIT',
					CREATE_FROM : 'CREATE_FROM'
				};

				if (typeof($scope.sample)==='undefined') {
					$scope.mode = $scope.MODES.CREATE;
				} else if (typeof($scope.forceMode)!=='undefined' && ($scope.forceMode === $scope.MODES.CREATE || $scope.forceMode === $scope.MODES.EDIT || $scope.forceMode === $scope.MODES.CREATE_FROM)) {
					$scope.mode = $scope.forceMode;
				} else if ($scope.sample.origin === 'CUSTOM') {
					$scope.mode = $scope.MODES.EDIT;
				} else {
					$scope.mode = $scope.MODES.CREATE_FROM;
				}

				$scope.displayPopover = function() {
					 CreateModalFromTemplate($scope.template, $scope, $scope.controller, function(newScope) {
						newScope.sampleType = $scope.sampleType;
						newScope.category  = $scope.category;
						newScope.reloadSampleListFunc = $scope.reloadSampleListFunc;
						newScope.mode = $scope.mode;
						if ($scope.mode === $scope.MODES.EDIT || $scope.mode === $scope.MODES.CREATE_FROM) {
							newScope.sample = {};
							angular.copy($scope.sample, newScope.sample);
							if ($scope.mode === $scope.MODES.CREATE_FROM) {
								delete newScope.sample.id;
							}
						}
						//not beautiful : next line is to prevent window click listener to close the code sample preview pannel
						angular.element('.create-sample-form, .modal-backdrop').on('click', function(e) {
							e.stopPropagation();
						});
		            }).then(function() {
		            	$scope.hideSampleFunc();
		            });
				}
			},
			templateUrl : '/templates/widgets/code-snippet-editor-creation-button.html'
		}
	});

	app.controller('CreateEditSampleController', function($scope, Assert, DataikuAPI, ActivityIndicator, $timeout, WT1, CodeMirrorSettingService) {
		Assert.inScope($scope, 'category');

		$scope.multiLanguageSnippet = $scope.sampleType == 'webapp_standard' || $scope.sampleType == 'webapp_shiny';

		if ($scope.mode == 'CREATE') {
			$scope.sample = {
        		variations : [{}],
        		tags : [{name:'custom', color : '#17BECF'}],
        		isShared : true,
        		libraries : []
	        };

			if ($scope.sampleType == 'webapp_standard') {
				$scope.sample.variations = [
				     {
				    	 id:'js',
				    	 title:'Javascript'
				     },
				     {
				    	 id:'html',
				    	 title:'HTML'
				     },
				     {
				    	 id:'css',
				    	 title:'CSS'
				     },
				     {
				    	 id:'py',
				    	 title:'Python'
				     }
				];
			} else if ($scope.sampleType == 'webapp_shiny') {
				$scope.sample.variations = [
				     {
				    	 id:'ui',
				    	 title:'ui'
				     },
				     {
				    	 id:'server',
				    	 title:'server'
				     }
				];
			}
	    }

		$scope.modalTabState = { active : 'code'};

		if ($scope.mode === 'CREATE_FROM') {
			$scope.sample.isShared = true;
		}
		if (typeof($scope.sample.tags)==='undefined') {
			$scope.sample.tags = [];
		}

		$scope.getEditorOptions = function(variation) {
			if (variation && variation.id) {
				return CodeMirrorSettingService.get(computeCodeMirrorMode(variation.id));
			} else {
                return CodeMirrorSettingService.get(computeCodeMirrorMode($scope.sampleType));
			}
		}

	    $scope.addVariation = function() {
	    	var newVariation = {};
	    	$scope.sample.variations.push(newVariation);
	    }

	    $scope.deleteVariation = function(index) {
	    	$scope.sample.variations.splice(index, 1);
	    }

	    $scope.toggleLib = function (lib) {
	    	var idx = $scope.sample.libraries.indexOf(lib);
	    	if (idx==-1) {
	    		$scope.sample.libraries.push(lib);
	    	} else {
	    		$scope.sample.libraries.splice(idx, 1);
	    	}
	    }

	    $scope.hasLib = function (lib) {
	    	return $scope.sample.libraries.indexOf(lib) != -1;
	    }

	    $scope.saveSample = function() {
	    	DataikuAPI.flow.snippets.saveSnippet(JSON.stringify($scope.sample), $scope.sampleType, $scope.category).success(function(data) {
	    		$scope.reloadSampleListFunc();
	    		ActivityIndicator.success("Sample saved!");
	    		$scope.dismiss();
                WT1.event("save-snippet", {sampleType : $scope.sampleType, saveCategory : $scope.saveCategory, id : $scope.sample.id});
	        }).error(setErrorInScope.bind($scope));
	    }
	});

	app.directive('codeSnippetEditorTagManager', function(TaggingService) {
		return {
			scope : {
				sample: '='
			},
			controller: function($scope, $timeout) {

				$scope.isCreatingTag = false;
				$scope.newTag = {};

				$scope.deleteTag = function(tag) {
					for (var i = 0; i<$scope.sample.tags.length; i++) {
						if ($scope.sample.tags[i].name === tag.name) {
							$scope.sample.tags.splice(i, 1);
							break;
						}
					}
				}

				$scope.displayNewTagForm = function() {
					$scope.isCreatingTag = true;
					$scope.newTag = {};
					$timeout(function(){
						$($('.create-sample-zone input')[0]).focus();
					}, 15);
				}

				$scope.hideNewTagForm = function() {
					$scope.isCreatingTag = false;
					$scope.newTag = {};
				}

				$scope.isDuplicatedTag = false;

				$scope.checkDuplicatedTag = function() {
					$scope.isDuplicatedTag = false;
					for (var i = 0; i<$scope.sample.tags.length; i++) {
						if ($scope.sample.tags[i].name === $scope.newTag.name) {
							$scope.isDuplicatedTag = true;
							break;
						}
					}
				}

				$scope.onBlur = function() {
					if (typeof($scope.newTag.name)!=='undefined' && $scope.newTag.name.length!=0 && !$scope.isDuplicatedTag) {
						$scope.createTag();
					}
					$scope.hideNewTagForm();
				}

				$scope.onKeyPressed = function(event) {
					$scope.checkDuplicatedTag();
					if (event.keyCode === 13 && typeof($scope.newTag.name)!=='undefined' && $scope.newTag.name.length!=0 && !$scope.isDuplicatedTag) {
						$scope.createTag();
					} else if (event.keyCode === 8 && (typeof($scope.newTag.name)==='undefined' || $scope.newTag.name.length==0)) {
						$scope.hideNewTagForm();
					}
				}

				$scope.createTag = function() {
					$scope.newTag.color = TaggingService.getDefaultColor($scope.newTag.name);
					$scope.sample.tags.push($scope.newTag);

					$scope.newTag = {};
				}

			},
			templateUrl : '/templates/widgets/code-snippet-editor-tag-manager.html'
		};
	});

	app.directive('codeSnippetEditorDeleteSampleButton', function() {
		return {
			controller : function($scope, DataikuAPI, ActivityIndicator, $rootScope, WT1) {

				$scope.deleteSample = function() {
					DataikuAPI.flow.snippets.deleteSnippet($scope.sample.id, $scope.sampleType).success(function(data) {
			       		$scope.reloadSampleListFunc();
			       		ActivityIndicator.success("Sample deleted !");
                        WT1.event("delete-snippet", {sampleType : $scope.sampleType, saveCategory : $scope.saveCategory, id : $scope.sample.id});
		            }).error(setErrorInScope.bind($rootScope));	//not amazing to give it to rootscope but no elegant way was found to give it to the parent scope of all those nested directives..
		        }

			}
		}
	});

	/*
	 *  ------------------------- FILTERING -------------------------
	 */

	app.directive('codeSnippetEditorQueryBar', function() {
		return {
			controller : function($scope, ListFilter) {

				$scope.query = {q : ""};
				$scope.selectedTags = [];

				//--computing snippetTags and snippetTagsMap by parsing recipeSamples
				var computeTagsList = function () {
					$scope.snippetTags = [];
					$scope.snippetTagsMap = {};
					for (var i = 0; i < $scope.recipeSamples.length; i++) {
	        			var currentSnippet = $scope.recipeSamples[i];
	        			if (typeof(currentSnippet.tags) !== 'undefined' ) {
	        				for (var j = 0; j < currentSnippet.tags.length; j++ ) {
	            				var currentTag = currentSnippet.tags[j];
	            				if (currentTag && typeof($scope.snippetTagsMap[currentTag.name]) === 'undefined') {
	            					$scope.snippetTagsMap[currentTag.name] = currentTag;
	            					$scope.snippetTags.push(currentTag);
	            				}
	            			}
	        			}
	        		}
					// If some tags were deleted we must take them of the selectedTags list
					$scope.selectedTags = [];
				}

				//--filtering samples based on query and selected tags
	        	var updateFiltered = function(){
	        		$scope.filteredRecipeSamples = [];
	                var filteredRecipeSamplesByQuery = ListFilter.filter($scope.recipeSamples, $scope.query.q);
	                for (var j = 0; j<filteredRecipeSamplesByQuery.length; j++) {
	                	var currentSample = filteredRecipeSamplesByQuery[j];
	                	if ($scope.selectedTags.length > 0 && typeof(currentSample.tags)!=='undefined') {
	                		var commonTags = computeIntersection(currentSample.tags, $scope.selectedTags);
	                		if (commonTags.length == $scope.selectedTags.length) {
	                			$scope.filteredRecipeSamples.push(currentSample);
	                		}
	                	} else if ($scope.selectedTags.length == 0) {
	                		$scope.filteredRecipeSamples.push(currentSample);
	                	}
	                }
	            }

	        	//--util to compute intersection bewteen two lists of tags
	        	var computeIntersection = function(tagList1, tagList2) {
	        		var tagMap = {};
	        		var intersection = [];
	        		for (var i in tagList1) {
	        			if (!tagList1[i]) continue;
	        			tagMap[tagList1[i].name] = true;
	        		}
	        		for (var j in tagList2) {
	        			if (!tagList2[j]) continue;
	        			if (tagMap[tagList2[j].name]) {
	        				intersection.push(tagList2[j]);
	        			}
	        		}
	        		return intersection;
	        	}

	        	$scope.switchTag = function(tag) {
	        		var index = $scope.selectedTags.indexOf(tag);
	        		if (index<0) {
	        			$scope.selectedTags.push(tag);
	        		} else {
	        			$scope.selectedTags.splice(index, 1);
	        		}
	        		updateFiltered();
	        	}

	        	$scope.showTagList = false;
	        	$scope.toggleTagList = function() {
	        		$scope.showTagList = !$scope.showTagList;
	        	}

	            //--watching query in order to refilter whenever it changes
	            $scope.$watch("query.q", updateFiltered);
	            $scope.$watch("recipeSamples", function() {
	            	computeTagsList();
	            	updateFiltered();
	            }, true);
			},
			templateUrl : '/templates/widgets/code-snippet-editor-query-bar.html'
		}
	});

})();
(function(){
    'use strict';
    var app = angular.module('dataiku.directives.styling', ['dataiku.filters', 'dataiku.services', 'ui.keypress']);

    app.directive('autoFocus', function($timeout){
        return {
            restrict: 'A',
            link: function(scope, element, attr){
                attr.$observe('autoFocus', function(){
                    if ((attr.autoFocus === "true") || (attr.autoFocus === true) || (attr.autoFocus===undefined)) {
                        $timeout(function(){element.focus();}, 0);
                    }
                });
            }
        };
    });

    app.directive('remainingHeight', function($timeout, $rootScope, Logger) {
        return {
            scope: true,
            link: function(scope, element) {
                Logger.warn("Used deprecated remainingHeight on", element);
                var resize = function(){
                    scope.remainingHeight = $(window).height() - element.offset().top
                        - parseInt($(element).css('padding-top')) - parseInt($(element).css('padding-bottom'));
                    if(!$rootScope.$$phase) scope.$apply();
                };

                $(window).on('resize', resize);
                $timeout(resize, 0);
                //$timeout(resize, 3000);

                scope.$on('reflow',function() { resize(); }); // Force remainingHeight recomputation
                scope.$on('$destroy', function() {
                    $(window).off('resize', resize);
                });
            }
        };
    });

    app.directive('remainingHeightNoScope', function($timeout, $rootScope, Logger) {
        return {
            link: function(scope, element) {
                Logger.warn("Used deprecated remainingHeightNoScope")
                var resize = function(){
                    scope.remainingHeight = $(window).height() - element.offset().top;
                    if(!$rootScope.$$phase) scope.$apply();
                };
                $(window).on('resize', resize);
                $timeout(resize, 0);
                scope.$on('$destroy', function() {
                    $(window).off('resize', resize);
                });
            }
        };
    });

    app.directive('scrollableToBottom', function() {
        return {
            template : '<div remaining-height style="overflow: auto; max-height: {{remainingHeight}}px;" ng-transclude></div>',
            transclude : true
        };
    });

    app.directive('scrollToMe', function($timeout){
        return {
            scope: {
                onScrollTriggered: '&',
                scrollToMeDuration: '<?'
            },
            link: function(scope, element, attrs){

                attrs.$observe('scrollToMe', function() {
                    if(attrs.scrollToMe === 'true') {
                        if (attrs.scrollAlign === 'center') {
                            $timeout(function() {
                                element[0].scrollIntoView({
                                    behavior: 'auto',
                                    block: 'center',
                                    inline: 'center'
                                });
                            });
                        } else {
                            /*
                            *  Checking for vertical scroll and doing it if possible 
                            */
                            var $scrollParent = element.parents().filter(function() {
                              return (/(auto|scroll)/).test(($.css(this, 'overflow')) + ($.css(this, 'overflow-y')));
                            }).eq(0);
                            if (!isNaN($scrollParent.length) && $scrollParent.length > 0) {
                                // only if not already visible
                                var offsetWithinScroll = $(element[0]).offset().top - $($scrollParent[0]).offset().top;
    
                                if (offsetWithinScroll < 0){ // Element is above parent
                                    $scrollParent.clearQueue();
                                    $scrollParent.animate({
                                        scrollTop: $scrollParent.scrollTop() + offsetWithinScroll,
                                    }, scope.scrollToMeDuration);
                                } else if (offsetWithinScroll + element.outerHeight() > $scrollParent.innerHeight()) { // element is under parent
                                    $scrollParent.clearQueue();
                                    $scrollParent.animate({
                                        scrollTop: $scrollParent.scrollTop() + Math.min(offsetWithinScroll, offsetWithinScroll + element.outerHeight() - $scrollParent.innerHeight()),
                                    }, scope.scrollToMeDuration);
                                }
                            }
    
                            /*
                             * Then checking for horizontal scroll and doing it if possible
                             */
                            var $scrollParent = element.parents().filter(function() {
                              return (/(auto|scroll)/).test($.css(this, 'overflow-x'));
                            }).eq(0);
                            if (!isNaN($scrollParent.length) && $scrollParent.length > 0) {
                                // only if not already visible
                                var offsetWithinScroll = element[0].offsetLeft - $scrollParent[0].offsetLeft;
    
                                if (offsetWithinScroll < $scrollParent.scrollLeft()){
                                    // left
                                    $scrollParent.clearQueue();
                                    $scrollParent.animate({
                                        scrollLeft:offsetWithinScroll,
                                    }, scope.scrollToMeDuration);
                                }
                                if((offsetWithinScroll + element.outerWidth()) > ($scrollParent.scrollLeft() + $scrollParent.width())){
                                    // right
                                    $scrollParent.clearQueue();
                                    $scrollParent.animate({
                                        scrollLeft:offsetWithinScroll - $scrollParent.innerWidth() + element.outerWidth(),
                                    }, scope.scrollToMeDuration);
                                }
                            }
                        }

                        scope.onScrollTriggered();
                    }
                });
            }
        };
    });

})();

(function() {
'use strict';

const app = angular.module('dataiku.directives.bootstrap', ['dataiku.filters']);


app.factory("getBootstrapTooltipPlacement", function() {
    return function(force_position) {
        if (!force_position || force_position.indexOf('tooltip-')==-1) {
            return function(tip, element) {
                var overflowParent = $(element).overflowParent()
                var overflowParentOffset = $(overflowParent).offset()

                var offset = $(element).offset();
                var top = offset.top + $(element).height() * 0.5 - overflowParentOffset.top;
                var left = offset.left + $(element).width() * 0.5 - overflowParentOffset.left;

                var height = $(overflowParent).outerHeight();
                var width = $(overflowParent).outerWidth();

                if (left < width * 0.33) {return 'right'}
                else if (left > width * 0.66) {return 'left'}
                else if (top < height * 0.5) {return 'bottom'}
                else if (top >= height * 0.5) {return 'top'}
                else {return 'bottom'}

            }
        } else {
            return force_position.replace("tooltip-","");
        }
    }
});


app.directive("toggle", function(getBootstrapTooltipPlacement) {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            switch (attrs.toggle) {
                case "tooltip-bottom":
                case "tooltip-top":
                case "tooltip-left":
                case "tooltip-right":
                case "tooltip":
                    var params = {
                        placement: attrs.placement ? attrs.placement : getBootstrapTooltipPlacement(attrs.toggle),
                        animation: attrs.animation ? scope.$eval(attrs.animation) : false,
                    };
                    if (attrs.container) params.container = attrs.container;
                    if (attrs.trigger) params.trigger = attrs.trigger;
                    element.tooltip(params);
                    // Remove other tooltips on hover out
                    element.hover(function() { $(this).tooltip('show'); }, function() {
                        $('.tooltip').not(element.next()).remove();
                    });
                    attrs.$observe('title', function() {
                        element.attr('data-original-title', attrs.title);
                        element.attr('title', '');
                    })
                    break;
                case "popover":
                    var content = scope.$eval(attrs.content)
                    var closePopover = function() {
                        element.popover('destroy');
                    }
                    var openPopover = function() {
                        var opts = {
                            placement: getBootstrapTooltipPlacement(),
                            container: attrs.container || 'body',
                            html: true,
                            trigger: 'manual',
                            content: content,
                            title: '<a class="close"><i class="icon-remove"></i></a> ' + attrs.title
                        }
                        element.popover(opts);
                        element.popover('show');
                        element.data('popover').$tip.find('.popover-title > .close').click(closePopover);
                        /* Don't close the popover when clicking on it */
                        element.data('popover').$tip.click(function(e) {
                            e.stopPropagation();
                        });
                    }
                    var justOpened = false;
                    $(element).click(function(e) {
                        if (element.data('popover')) {
                            closePopover()
                        } else {
                            openPopover()
                            justOpened = true;
                        }
                    });
                    $(document).on('click', function(e) {
                        if (!justOpened && element.data('popover')) {
                            closePopover();
                        }
                        justOpened = false;

                    });
                    break;
                case "dropdown":
                    $(element).click(function() {
                        var overflowParent = element.overflowParent()
                        var overflowParentOffset = $(overflowParent).offset()
                        var height = $(overflowParent).outerHeight();
                        var width = $(overflowParent).outerWidth();

                        var offset = $(element).offset();

                        var vert = 0.5 * height - (offset.top - overflowParentOffset.top);
                        var horiz = 0.5 * width - (offset.left - overflowParentOffset.left);

                        if (vert > 0) {
                            element.closest('.dropup,.dropdown').removeClass('dropup').addClass('dropdown')
                        } else {
                            element.closest('.dropup,.dropdown').removeClass('dropdown').addClass('dropup')
                        }

                        if (horiz > 0) {
                            element.closest('.dropup,.dropdown').find('.dropdown-menu').removeClass('pull-right')
                        } else {
                            element.closest('.dropup,.dropdown').find('.dropdown-menu').addClass('pull-right')
                        }
                    })
                    break;
            }
        }
    }
});

/**
 * On text overflow detection, this directive displays a tooltip on hover containing the original text and formats the text with an ellipsis.
 *
 * Note: The element on which this directive is applied must already have the correct target width.
 * Overflow detection happens when the width of the text is larger than the width of the container element.
 *
 * @param {string}      textTooltip           - The text to display
 * @param {string}      tooltipDirection      - Position of tooltip (default: tooltip-right; other possible values: tooltip, tooltip-top, tooltip-bottom, tooltip-left)
 * @param {string}      textOverflowClass     - CSS class to be applied to text (if overflow)
 * @param {boolean}     observeResize         - True (default) to re-detect overflow when the element is resized or text changes. Consider using false for static content (may improve performance)
 * @param {boolean}     allowHtml             - The text to display contains HTML
 */
app.directive("showTooltipOnTextOverflow", function ($compile, $timeout, $filter, $sanitize) {
    const template = `
        <div class="{{ getTooltipClass() }}"
             ng-show="textTooltip"
             ng-bind-html="getHtmlContent()"
             title="{{ getTooltipTitle() }}"
             toggle="{{ getTooltipDirection() }}"
             container="body"
        >
        </div>`;

    const stripHtml = (unsafeHtml) => {
        // DOMParser evaluates in another HTMLDocument with scripting disabled.
        const doc = new DOMParser().parseFromString(unsafeHtml, 'text/html');
        return doc.body.innerText || "";
    };

    return {
        restrict: 'A',
        scope: {
            textTooltip: '<',
            allowHtml: '<',
            tooltipDirection: '<?',
            textOverflowClass: '@',
            observeResize: '<?'
        },
        template: template,
        controller: ($scope) => {
            // At the very beginning, initialize the template with as much
            // width as possible. Then, if the content is cropped with an
            // ellipsis, show a tooltip with the whole content.
            $scope.withEllipse = false;

            $scope.getTooltipClass = () => {
                if ($scope.withEllipse) {
                    return $scope.textOverflowClass || "ellipsed";
                }

                // We need this when the template is initialized so that it is
                // later possible to determine if the content is cropped (with
                // an ellipsis). See IntersectionObserver usages below.
                return "width-fit-content";
            };

            $scope.getTooltipTitle = () => {
                if (!$scope.withEllipse) {
                    // The content fits entirely, no need to show the tooltip.
                    return "";
                }

                if ($scope.allowHtml) {
                    return stripHtml($scope.textTooltip);
                }

                return $scope.textTooltip;
            };

            $scope.getTooltipDirection = () => {
                return $scope.tooltipDirection || 'tooltip-right';
            };

            // Set the tooltip content, depending on whether it supports
            // html or plain text.
            $scope.getHtmlContent = () => {
                if ($scope.allowHtml) {
                    return $scope.textTooltip;
                }

                return sanitize($scope.textTooltip);
            };
        },
        link: (scope, element) => {
            if (!('IntersectionObserver' in window)) {
                return;
            }

            // Use better names to refer to the html elements.
            const directiveTargetElement = element[0];
            if (!angular.isObject(directiveTargetElement)) {
                return;
            }

            const thisElement = directiveTargetElement.lastChild;
            directiveTargetElement.classList.add("ellipsed");

            // Object to detect when the tooltip overflows its container element.
            let intersectObserver = null;

            // Object to detect when the container element is resized.
            let resizeObserver = null;

            const onIntersectChange = (intersections) => {
                const anyIntersection = intersections
                    .some((it) => it.intersectionRatio > 0 && it.intersectionRatio < 1);

                if (anyIntersection) {
                    // We know that the content overflows its container, no need
                    // to monitor it anymore.
                    intersectObserver.disconnect();

                    // This handler can be called outside of AngularJS cycles,
                    // so we notify it that something has changed.
                    scope.$applyAsync(() => {
                        scope.withEllipse = true;
                    });
                }
            }

            intersectObserver = new IntersectionObserver(onIntersectChange, {
                root: directiveTargetElement,
                rootMargin: '2px', // Tolerance margin.
                threshold: 1,
            });

            const connectObservers = () => {
                intersectObserver.observe(thisElement);

                if (resizeObserver != null) {
                    resizeObserver.observe(directiveTargetElement);
                }
            };

            const disconnectObservers = () => {
                intersectObserver.disconnect();

                if (resizeObserver != null) {
                    resizeObserver.disconnect();
                }
            };

            // Reset to initial template and re-observe
            const resetToInitialRender = () => {
                disconnectObservers();

                // This handler can be called outside of AngularJS cycles,
                // so we notify it that something has changed.
                scope.$applyAsync(() => {
                    scope.withEllipse = false;
                });

                connectObservers();
            };

            // Detect when the container element is resized.
            const observeResize = angular.isDefined(scope.observeResize) ?
                scope.observeResize : true;

            if (observeResize) {
                // Computing the width of the element can be expensive, so we set elWidth to 0 for the
                // first resizing check. Then we will rely on the width provided by the resizeObserver.
                scope.elWidth = 0;

                resizeObserver = new ResizeObserver(entries => {
                    entries.forEach(entry => {
                        if (entry.contentRect.width > scope.elWidth) {
                            // We use setTimeout to change observed element out of the loop to prevent error
                            // in safari : "ResizeObserver loop completed with undelivered notifications"
                            setTimeout(() => resetToInitialRender());
                        }

                        scope.elWidth = entry.contentRect.width;
                    });
                });
            }

            scope.$watch('textTooltip', (newVal, oldVal) => {
                if (newVal !== oldVal) {
                    resetToInitialRender();
                }
            });

            scope.$on('$destroy', () => {
                disconnectObservers();
                $('.tooltip').remove();
            });

            // Set the tooltip content and start monitoring for resize
            // and / or intersection events.
            resetToInitialRender();
        }
    }
});

// Initialy taken from angular-strap but with some fixes (ng options parser accepts filters + fix the dropdown opening problem)
if (/\bdisable_dku_fancy=true\b/.test(document.cookie)) {
    // Selenium: disable this directive + don't hide the <select> inputs
    console.warn("Disabling dkuBsSelect"); /*@console*/ // NOSONAR: OK to use console.
    $(function() {
        document.body.classList.add('disable-dku-fancy');
    });
} else {
app.directive('dkuBsSelect', function($timeout) {
    var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w\d]*)|(?:\(\s*([\$\w][\$\w\d]*)\s*,\s*([\$\w][\$\w\d]*)\s*\)))\s+in\s+(.*)$/;

    return {
        restrict: 'A',
        require: '?ngModel',
        link: function(scope, element, attrs, controller) {
            element.css('visibility', 'hidden');
            var magicContainer = $('<div></div>');
            element.magicContainer = magicContainer;
            $('body').append(magicContainer);
            var lastDisabled;
            var refresh = function(newValue, oldValue) {
                if (magicContainer) {
                    scope.$applyAsync(function() {
                        // data-content is cached in jQuery's .data('content') and .selectpicker('refresh') won't pick up the new content if we don't refresh that (https://github.com/silviomoreto/bootstrap-select/issues/298)
                        element.find('option[data-content]').each(function() {
                            var $this = $(this);
                            $this.data('content', $this.attr('data-content'));
                        });

                        element.selectpicker('refresh');
                    }, 0);
                }
            };
            var refreshIfChanged = function(newValue, oldValue) {
                if (!angular.equals(newValue, oldValue)) {
                    refresh(newValue, oldValue);
                }
            };

            const refreshStyle = function(newValue, oldValue) {
                if (!angular.equals(newValue, oldValue)) {
                    element.selectpicker('updateStyle', newValue);
                }
            };

            scope.$on('selectPickerRefresh', refresh);

            // Hide the empty element
            var fixupEmptyOption = function() {
                var disabled = $('option', element).map(function(idx, op) {
                    return $(op).attr('disabled') == "disabled"
                }).get();
                if (lastDisabled == null) {
                    lastDisabled = disabled;
                } else if (lastDisabled.join() != disabled.join()) {
                    refresh();
                    lastDisabled = disabled;
                }
                scope.$evalAsync(function() {
                    magicContainer.find('ul>li>a>span[class=text]:empty').parent().parent().css('display', 'none');
                });
            };

            function addWatches() {
                var options = $.extend({
                    container: magicContainer,
                    style: 'dku-select-button btn--secondary'
                }, scope.$eval(attrs.dkuBsSelect) || {});
                
                element.selectpicker(options);
                element.selectpicker('updateStyle', scope.$eval(attrs.dkuStyle))
                if (options.titlePrefix) {
                    element.next().find('>button>span:first-child').attr('title-prefix', options.titlePrefix);
                }
                element.next().find('>button').click(fixupEmptyOption);
                if (options.pullRight) {
                    element.parent().find("div.dropdown-menu").addClass("pull-right");
                }
                if (options.customDropdownAttrs) {
                    for (var attr in options.customDropdownAttrs) {
                        element.parent().find("div.dropdown-menu").attr(attr, options.customDropdownAttrs[attr]);
                    }
                }
                scope.$watch(attrs.dkuStyle, refreshStyle);

                // If we have a controller (i.e. ngModelController) then wire it up
                if (controller) {
                    // Watch for changes to the model value
                    scope.$watch(attrs.ngModel, refresh);

                    // Update the select menu when another model change
                    // It's supposed to be used whenever the ng-options is too complicated to parse
                    if (attrs.watchModel) {
                        scope.$watch(attrs.watchModel, refreshIfChanged, true);
                        scope.$watchCollection(attrs.watchModel, refreshIfChanged);
                    } else {
                        // Watch for changes to the options
                        // We try to detect the underlying model variable using regexps
                        // It is not robust
                        if (attrs.ngOptions) {
                            var match = attrs.ngOptions.match(NG_OPTIONS_REGEXP);

                            if (match && match[7]) {
                                var variable = match[7].split('|')[0];
                                if(variable) {
                                    scope.$watch(variable, refreshIfChanged, true);
                                }
                            }
                        }
                        if (attrs.ngDisabled) {
                            scope.$watch(attrs.ngDisabled, refreshIfChanged);
                        }
                    }
                }
            }

            // if the attributes asynchronousLoad is set, watches are added without 
            // waiting for the rendering to finish 
            if (attrs.asynchronousLoad) {
                addWatches()
            } else {
                $timeout(addWatches);
            }

            scope.$on('$destroy', function() {
                element.selectpicker('destroy');
                if (magicContainer) {
                    magicContainer.remove();
                    magicContainer = null;
                    element.magicContainer = null;
                }
            });
        }
    };
});
}

// this select menu is actually a dkuBsSelect with a replacement for the dropdown menu element
app.directive('optionsDescriptions', function($timeout, Logger, $sanitize) {

    var delayed = function(f,x){return function(){$timeout(f,x)}};

    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            var lastOriginalDropDownHTML; // save dropdown menu state to manage updates
            var content;

            var clicked  = function(i) {
                $($('ul.dropdown-menu>li>a', element.magicContainer)[i]).trigger('click');
            };
            
            // Check if first item is a header
            const isHeader = firstItem => $('.text', firstItem).text() == "";

            // Get class from orginal dropdown lines and set it to current description lines
            const setOriginalLinesClass = () => { 
                const items = $('ul.dropdown-menu>li', element.magicContainer); // Lines of original dropdown
                const newLines = attrs.layout == "list"? $("li", content) : $('tr', content);
                let headerOffset = isHeader(items[0]) ? 1 : 0;

                for (let i = headerOffset; i < items.length; i++) {
                    $(newLines[i - headerOffset]).toggleClass('selected', $(items[i]).is('.selected'));
                    $(newLines[i - headerOffset]).toggleClass('hide', $(items[i]).is('.hide'));
                }
                // Show empty results line from original dropdown if it exists
                $('li.no-results', content).removeClass('hide'); 
            }

            var setPopup = function() {
                $("div.dropdown-menu.open", element.magicContainer).css("overflow-y", "scroll");
                var originalDropDownHTML = $('div.dropdown-menu', element.magicContainer).html();

                if (originalDropDownHTML != lastOriginalDropDownHTML) { // update the menu if any change was made in the original dropdown menu
                    var items = $('ul.dropdown-menu>li', element.magicContainer); // the labels of the original popup have class "text"
                    var disabled =  $('option', element).map(function(idx, op){return $(op).attr('disabled') == "disabled"}).get();
                    const hasHeader = isHeader(items[0]);

                    // Enable use of searchbox from original dropdown if it exists
                    const searchbox = $(element.magicContainer).find('input'); 
                    if (items.length == 1 && hasHeader) { // List is empty (there is only a placeholder header)
                        searchbox && searchbox.hide(); 
                    } else {
                        searchbox && searchbox.show() && searchbox.on('input propertychange', setOriginalLinesClass);
                    }
                    

                    if (content) {
                        content.remove();
                    }
                    if (items.length > 0) {
                        var descriptions = scope.$eval(attrs.optionsDescriptions)
                        if (!descriptions) {
                            Logger.error("No description provided for the select options");
                        }

                        if (attrs.layout == "list") {
                            content = $('<ul class="dku-bs-select-options-descriptions-listlayout">');

                            // Items descriptions begin after header if present
                            let headerOffset = hasHeader ? 1 : 0;

                            for (var i = headerOffset; i < items.length; i++) {
                                var label = $('.text', items[i]).text();
                                if (label && label.length) {
                                    var line = $('<li>').click((function(n){return function(){clicked(n)}; })(i));
                                    if (disabled[i]) {
                                        line.addClass('disabled');
                                    }
                                    line.html('<div class="main-label">'+sanitize(label)+'</div><div class="description">'+$sanitize(descriptions[i - headerOffset])+'</div>');
                                    content.append(line);
                                }
                            }
                        } else {
                            content = $('<table class="dku-bs-select-options-descriptions-tablelayout">');
                            for (var i = 0; i < items.length; i++) {
                                var label = $('.text', items[i]).text();
                                if (label && label.length) {
                                    var line = $('<tr>').click((function(n){return function(){clicked(n)}; })(i));
                                    if (disabled[i]) {
                                        line.addClass('disabled');
                                    }
                                    line.html('<td class="main-label"><div>'+sanitize(label)+'</div></td><td class="description">'+$sanitize(descriptions[i])+'</td>');
                                    content.append(line);
                                }
                            }
                        }
                    } else {
                        content = $('<div>').text('No available options');
                    }
                    $('div.dropdown-menu', element.magicContainer).append(content);
                    setOriginalLinesClass();
                    lastOriginalDropDownHTML = originalDropDownHTML;
                }
            };

            setTimeout(function() {
                element.next().find('>button').click(delayed(setPopup, 0));
                $(element.magicContainer).addClass('select-with-descriptions');
            }, 500);

            scope.$on('$destroy',function() {
                content = null;
            });
        }
    }
});


app.directive('optionsAnnotations', function($timeout, Logger) {

    var delayed = function(f,x){return function(){$timeout(f,x)}};

    return {
        restrict: 'A',
        require: ['select', 'ngModel'],
        link: function(scope, element, attrs) {
            var annotations;
            var updateAnnotations = function() {
                annotations = scope.$eval(attrs.optionsAnnotations);
                setPopup();
            };

            var annotate = function(elt, annotation) {
                if ($('.annotation', elt).length == 0) {
                    elt.append('<span class="annotation">'+(annotation||'')+'<span>');
                } else {
                    $('.annotation', elt).text(annotation||'');
                }
            };

            // var annotateAfter = function(elt, annotation) {
            //   var parent = elt.parent();
            //   if ($('.annotation', parent).length == 0) {
            //     elt.after('<span class="annotation"><span>');
            //   }
            //   $('.annotation', parent).text(annotation);
            // }

            var initMainLableAnnotation = function() {
                var options = $('option', element);
                var selectedValue = $(element).find(":selected").text();
                var mainLabel = element.next().find('>button>span:first-child'); //element indicating selected item

                //TODO perform options annotation in one or two DOM changes

                // when the select is first loaded, we don't know, from the selected value, which option is selected
                // if only one option has a value corresponding to the selected value, we can determine which one is selected
                var guess;
                options.each(function(idx, item) {
                    if ($(item).text() == selectedValue) {
                guess = (guess === void 0 || guess == annotations[idx]) ? annotations[idx] : null; //null if several items have the same value as the selected one but different annotations
                }
                });
                // if (guess != null) {
                //   annotateAfter(mainLabel, guess);
                // }

                //update mainLabel annotation
                // scope.$watch('selectedColumn', function(nv,ov) {
                //   var selectedIndex = $('option', element).get().indexOf($(element).find(":selected").get(0));
                //   annotateAfter(mainLabel, annotations[selectedIndex]);
                // });
            };

            var setPopup = function() {
                var items = $('ul.dropdown-menu>li:visible', element.magicContainer); // the labels of the original popup have class "text", select picker creates invisible items, don't know why
                if (items.length > 0) {// TODO check if update is needed
                    if (!annotations) {
                        Logger.error("No description provided for the select options");
                    }
                    items.each(function(idx, item) {
                        annotate($('a', item), annotations[idx]);
                    });
                }
            };

            updateAnnotations();
            scope.$watch(attrs.optionsAnnotations, updateAnnotations, true);

            setTimeout(function() {
                element.next().find('>button').click(delayed(setPopup));
                $(element.magicContainer).addClass('select-with-annotations');
                $(element).next().addClass('select-with-annotations');
                initMainLableAnnotation();
            }, 500);
        }
    }
});


app.directive('sortOrderButton', function(LocalStorage) {
    function get(orderName, def) {
        if (orderName === undefined || orderName === null) return def;
        return (LocalStorage.get("dssOrders") || {})[orderName];
    }
    function set(orderName, value) {
        if (orderName === undefined || orderName === null) return;
        //TODO cleanup mechanism
        var orders = LocalStorage.get("dssOrders") || {};
        orders[orderName] = value;
        LocalStorage.set("dssOrders", orders);
    }

    return {
        scope : {'val':'=value','rememberChoice':'=', 'disabled':'&'},
        restrict:'E',
        template: '<span style="display: inline-block;vertical-align:middle;font-size:0;">'
        +'<button class="{{buttonClass}}" onfocus="this.blur();" ng-click="change(!val)" ng-disabled="disabled()">'
        +'<i class="icon-sort-by-attributes" ng-show="!val" title="Ascending order"/>'
        +'<i class="icon-sort-by-attributes-alt" ng-show="val" title="Descending order"/>'
        +'</button>'
        +'</span>',

        link: function (scope, element, attrs) {
            var options = $.extend({
                buttonClass: 'btn btn--secondary'
            }, scope.$eval(attrs.sobOpt) || {});
            scope.buttonClass = options.buttonClass;
            scope.val = !!get(scope.rememberChoice, scope.val);
            scope.change = function(v) {
                scope.val = v;
                set(scope.rememberChoice, scope.val);
            };

            if (options.hasOwnProperty('disabledValue')) {
                scope.$watch(scope.disabled, function() {
                    if (scope.disabled()) {
                        scope.change(options.disabledValue);
                    }
                })
            }
        }
    };
});


app.directive('sortDropdown', function () {
    return {
        require: "?ngModel",
        link: function (scope, element, attrs,ngModel) {

            var rememberChoice = function() { return scope.$eval(attrs.rememberChoice); };

            if(rememberChoice()) {
                var cookieKey = 'sort_choice_'+rememberChoice();
                var lastChoice = getCookie(cookieKey);
                if(lastChoice != null) {
                    ngModel.$setViewValue(lastChoice);
                }
            }

            // Watch for any changes from outside the directive and refresh
            scope.$watch(attrs.ngModel, function () {

                if(rememberChoice()) {
                    var expires = 60*24*365;
                    var cookieKey = 'sort_choice_'+rememberChoice();
                    setCookie(cookieKey,ngModel.$viewValue,expires);
                }
            });
        }
    };
});

app.directive("progressBarWithThreshold", function() {
    return {
        scope : {
            success : '@',
            warning: '@',
            error : '@',
            neutral : '@',
            allowEmpty : '=',
            title: '@',
            active : '=',
            properOrder: '=',
            threshold: '@'
        },
        restrict : "ECA",
        template: '<div style="position: relative;">' +
            '<progress-bar class="progress-validity padbot0" success="{{success || 0}}" ' +
            'warning="{{warning || 0}}" error="{{error || 0}}" title="{{title}}" ng-attr-neutral="{{neutral || 0}}"></progress-bar>' +
            '<div class="progress-bar-with-threshold__threshold" style="left: calc({{threshold}}% - 8px)/* need to subtract half of component width */"></div>' +
            '</div>'
    }
});

app.directive("progressBar", function() {
    return {
        scope : {
            success : '@',
            warning: '@',
            error : '@',
            neutral : '@',
            allowEmpty : '=',
            title: '@',
            active : '=',
            properOrder: '='
        },
        restrict : "ECA",
        template: '<div class="progress mbot4" rel="tooltip" '+
        ' title="{{title}}" ng-class="{active: active}">' +
        '<div class="bar bar-info" ng-show="neutral >0" style="width:{{ humanized_neutral }}%"></div>' +

        '<div class="bar bar-success" ng-show="success >0" style="width:{{ humanized_success }}%"></div>' +
        '<div class="bar bar-warning" ng-if="properOrder" ng-show="warning > 0" style="width:{{ humanized_warning }}%"></div>' +
        '<div class="bar bar-danger" ng-show="error > 0" style="width:{{ humanized_error }}%"></div>' +
        '<div class="bar bar-warning" ng-if="!properOrder" ng-show="warning > 0" style="width:{{ humanized_warning }}%"></div>' +
        '</div>',
        link : function(scope, element, attrs) {
            var HUMAN_THRESHOLD = 5;
            scope.$watch(function(){return scope.success+scope.error+scope.warning+scope.neutral}, function(newValue, oldValue) {

                var error = isNaN(scope.error) ? 0 : parseFloat(scope.error);
                var warning = isNaN(scope.warning) ? 0 : parseFloat(scope.warning);
                var success = isNaN(scope.success) ? 0 : parseFloat(scope.success);
                var neutral = isNaN(scope.neutral) ? 0 : parseFloat(scope.neutral);

                scope.humanized_error = error > 0 ? Math.max(HUMAN_THRESHOLD, error): error
                scope.humanized_warning = warning > 0 ? Math.max(HUMAN_THRESHOLD, warning): warning;
                scope.humanized_success = success > 0 ? Math.max(HUMAN_THRESHOLD, success) : success;
                scope.humanized_neutral = neutral > 0 ? Math.max(HUMAN_THRESHOLD, neutral) : neutral;

                if (!scope.allowEmpty) {
                    var norm = (scope.humanized_success + scope.humanized_error + scope.humanized_warning + scope.humanized_neutral) / 100.;
                    scope.humanized_warning /= norm;
                    scope.humanized_success /= norm;
                    scope.humanized_error /= norm;
                    scope.humanized_neutral /= norm;
                }
            });
        }
    }
});


app.directive("exactSimpleProgressBar", function(){
    return {
        scope : {
            info : '=',
            success : '=',
            warning : '=',
            error : '='
        },
        template : '<div style="margin-bottom:4px" class="progress">'
            +'<div class="bar bar-info" ng-show="info>0" style="width:{{info*100}}%"></div>'
            +'<div class="bar bar-success" ng-show="success>0" style="width:{{success*100}}%"></div>'
            +'<div class="bar bar-warning" ng-show="warning>0" style="width:{{warning*100}}%"></div>'
            +'<div class="bar bar-error" ng-show="error>0" style="width:{{error*100}}%"></div>'
            +'</div>'

    }
});

})();

function gentleTruncate(str, len) {
    /**
     * Truncate a string to make sure it takes at most
     * n characters.
     * Whenever possible truncates on special chars.
     *
     * If str is not a string, returns str unchanged.
     */
    if ((typeof str != "string") || (str.length <= len)) {
        return str;
    }

    var cutOn = /[ ,\.,;\-\\\"\n\?\!\|]/g
    var truncated = str.substring(0, len-1);
    var lastSeparatorIdx = regexLastIndexOf(cutOn, truncated);

    // we don't want to cut more too much.
    if (lastSeparatorIdx > len / 2) {
        truncated = str.substring(0, lastSeparatorIdx);
    }
    return truncated + '…';
}

var now = new Date().getTime();
var NOW_REFRESH_INTERVAL = 1000 * 5; // 5 Seconds

setInterval(function(){
    now = new Date().getTime();
}, NOW_REFRESH_INTERVAL);

function friendlyDuration(diffInSeconds) {
    var sec = Math.floor((diffInSeconds >= 60 ? diffInSeconds % 60 : diffInSeconds));
    var min = Math.floor((diffInSeconds = (diffInSeconds / 60)) >= 60 ? diffInSeconds % 60 : diffInSeconds);
    var hrs = Math.floor((diffInSeconds = (diffInSeconds / 60)) >= 24 ? diffInSeconds % 24 : diffInSeconds);
    var days =Math.floor( (diffInSeconds = (diffInSeconds / 24)) >= 30 ? diffInSeconds % 30 : diffInSeconds);
    var months = Math.floor( (diffInSeconds = (diffInSeconds / 30)) >= 12 ? diffInSeconds % 12 : diffInSeconds);
    var years= Math.floor( (diffInSeconds = (diffInSeconds / 12)));
    var sb = "";
    if (years > 0) {
        if (years == 1) {
            sb += ("1 year");
        } else {
            sb += (years + " years");
        }
        if (years <= 6 && months > 0) {
            if (months == 1) {
                sb += (" and one month");
            } else {
                sb += (" and " + months + " months");
            }
        }
    } else if (months > 0) {
        if (months == 1) {
            sb += ("one month");
        } else {
            sb += (months + " months");
        }
        if (months <= 6 && days > 0) {
            if (days == 1) {
                sb += (" and a day");
            } else {
                sb += (" and " + days + " days");
            }
        }
    } else if (days > 0) {
        if (days == 1) {
            sb += ("one day");
        } else {
            sb += (days + " days");
        }
        if (days <= 3 && hrs > 0) {
            if (hrs == 1) {
                sb += (" and one hour");
            } else {
                sb += (" and " + hrs + " hours");
            }
        }
    } else if (hrs > 0) {
        if (hrs == 1) {
            sb += ("one hour");
        } else {
            sb += (hrs + " hours");
        }
        if (min > 1) {
            sb += (" and " + min + " minutes");
        }
    } else if (min > 0) {
        if (min == 1) {
            sb += ("one minute");
        } else {
            sb += (min + " minutes");
        }
        if (sec > 1) {
            sb += (" and " + sec + " seconds");
        }
    } else {
        if (sec <= 1) {
            sb += ("about a second");
        } else {
            sb += ("about " + sec + " seconds");
        }
    }
    return sb;
}

function durationHHMMSS(diffInSeconds) {
    var sec = Math.floor((diffInSeconds >= 60 ? diffInSeconds % 60 : diffInSeconds));
    var min = Math.floor((diffInSeconds = (diffInSeconds / 60)) >= 60 ? diffInSeconds % 60 : diffInSeconds);
    var hours = Math.floor( diffInSeconds / 60);
    var sb = "";
    if (hours > 0) {
        sb += (hours + "h ");
    }
    if (min > 0) {
        sb += (min + "m ");
    }
    sb += (sec + "s");
    return sb;
}

function durationHHMM(diffInSeconds) {
    var min = Math.floor((diffInSeconds = (diffInSeconds / 60)) >= 60 ? diffInSeconds % 60 : diffInSeconds);
    var hours = Math.floor( diffInSeconds / 60);
    var sb = "";
    if (hours > 0) {
        sb += (hours + "h ");
    }
    if (min > 0) {
        sb += (min + "m ");
    }
    return sb;
}

function durationHHMMSSPadded(diffInSeconds) {
    if (diffInSeconds == 0) diffInSeconds = 1;
    var sec = Math.floor((diffInSeconds >= 60 ? diffInSeconds % 60 : diffInSeconds));
    var min = Math.floor((diffInSeconds = (diffInSeconds / 60)) >= 60 ? diffInSeconds % 60 : diffInSeconds);
    var hours = Math.floor( diffInSeconds / 60);

    function pad(number) {
        if (number < 10) return "0" + number;
        else return number;
    }
    return pad(hours) + "h" + pad(min) + "m" + pad(sec) + "s";
}


function friendlyDurationShort(seconds, ref, noSeconds) {
    var sec    = Math.floor(seconds >= 60 ? seconds % 60 : seconds),
        min    = Math.floor((seconds = (seconds / 60)) >= 60 ? seconds % 60 : seconds),
        hours  = Math.floor((seconds = (seconds / 60)) >= 24 ? seconds % 24 : seconds),
        days   = Math.floor((seconds = (seconds / 24)) >= 30 ? seconds % 30 : seconds),
        months = Math.floor((seconds = (seconds / 30)) >= 12 ? seconds % 12 : seconds),
        years  = Math.floor((seconds = (seconds / 12))),
        sb = "";

    if (years > 0) {
        sb = (years + " year" + (years > 1 ? "s" :""));
    } else if (months > 0) {
        sb = (months + " month" + (months > 1 ? "s" :""));
    } else if (days > 0) {
        sb = (days + " day" + (days > 1 ? "s" :""));
    } else if (hours > 0) {
        sb = (hours + " hour" + (hours > 1 ? "s" : ""));
    } else if (min > 0) {
        sb = (min + " minute" + (min > 1 ? "s" : ""));
    } else if(!noSeconds && sec > 0) {
        sb = (sec + " second" + (sec > 1 ? "s" : ""));
    }

    switch (ref) {
        case 'ago':   return sb ? sb + " ago"   : "just now";
        case 'in':    return sb ? "in " + sb    : "immediately";
        default:      return sb ? sb            : "< 1 " + (noSeconds ? "minute" : "second");
    }
}

function dateDayDiff(date1, date2) {
    var d1 = new Date(date1);
    var d2 = new Date(date2);
    d1.setHours(0);
    d1.setMinutes(0);
    d1.setSeconds(0);
    d1.setMilliseconds(0);
    d2.setHours(0);
    d2.setMinutes(0);
    d2.setSeconds(0);
    d2.setMilliseconds(0);
    var dayLength = 24*60*60*1000;
    return Math.floor(d1.getTime()/dayLength) - Math.floor(d2.getTime()/dayLength);
}
function dateMinuteDiff(date1, date2) {
    var d1 = new Date(date1);
    var d2 = new Date(date2);
    d1.setSeconds(0);
    d1.setMilliseconds(0);
    d2.setSeconds(0);
    d2.setMilliseconds(0);
    var msToMin = 60*1000;
    return Math.floor(d1.getTime()/msToMin) - Math.floor(d2.getTime()/msToMin);
}


(function() {

'use strict';

var app = angular.module('dataiku.filters', []);

const CONVERSION_FIELD_ICON = 'icon';
const CONVERSION_FIELD_NAME = 'name';
const CONVERSION_FIELD_OTHER_NAME = 'otherName';
const CONVERSION_FIELD_LANGUAGE = 'language';
function buildTypeDefinition(icon, name = undefined, otherName = undefined) {
    return {[CONVERSION_FIELD_ICON]: icon, [CONVERSION_FIELD_NAME]: name, [CONVERSION_FIELD_OTHER_NAME]: otherName || name};
}
function buildTypeDefinitionWithIconAndLanguage(icon, language) {
    return {[CONVERSION_FIELD_ICON]: icon, [CONVERSION_FIELD_LANGUAGE]: language};
}

const FS_PROVIDER_TYPES = {
    'filesystem': buildTypeDefinition('icon-server_file_system_1', "Server's Filesystem"),
    'hdfs': buildTypeDefinition('icon-HDFS', 'Hadoop HDFS'),
    'ftp': buildTypeDefinition('icon-uncached_FTP', 'FTP'),
    'sftp': buildTypeDefinition('icon-dataset-ssh', 'SFTP'),
    'scp': buildTypeDefinition('icon-dataset-ssh', 'SCP'),
    'azure': buildTypeDefinition('icon-azure-storage', 'Azure Blob Storage'),
    'gcs': buildTypeDefinition('icon-google-cloud-storage', 'Google Cloud Storage'),
    's3': buildTypeDefinition('icon-amazon_s3', 'Amazon S3'),
    'url': buildTypeDefinition(undefined, 'HTTP or FTP URL'),
};
const COMMON_TYPES = Object.assign({}, FS_PROVIDER_TYPES, {
    'hiveserver2': buildTypeDefinition('icon-dku-hive', 'Hive'),
    'uploadedfiles': buildTypeDefinition('icon-upload', 'Uploaded Files'),
    'mongodb': buildTypeDefinition('icon-mongo_db', 'MongoDB'),
    'dynamodb': buildTypeDefinition('icon-dynamoDB', 'DynamoDB'),
    'mysql': buildTypeDefinition('icon-mySQL', 'MySQL'),
    'cassandra': buildTypeDefinition('icon-cassandra_1', 'Cassandra'),
    'postgresql': buildTypeDefinition('icon-postgreSQL', 'PostgreSQL'),
    'vertica': buildTypeDefinition('icon-HP_vertica', 'Vertica'),
    'redshift': buildTypeDefinition('icon-amazon_redshift', 'Amazon Redshift'),
    'greenplum': buildTypeDefinition('icon-greenplum', 'Greenplum'),
    'teradata': buildTypeDefinition('icon-teradata', 'Teradata'),
    'oracle': buildTypeDefinition('icon-oracle', 'Oracle'),
    'athena': buildTypeDefinition('icon-athena', 'Athena'),
    'sqlserver': buildTypeDefinition('icon-sqlserver', 'MS SQL Server'),
    'synapse': buildTypeDefinition('icon-dku-azure-synapse', 'Azure Synapse'),
    'netezza': buildTypeDefinition('icon-netezza', 'IBM Netezza'),
    'saphana': buildTypeDefinition('icon-sap-hana', 'SAP Hana'),
    'bigquery': buildTypeDefinition('icon-google-bigquery', 'Google BigQuery'),
    'snowflake': buildTypeDefinition('icon-snowflake', 'Snowflake'),
    'jdbc': buildTypeDefinition('icon-other_sql', 'SQL database (JDBC)', 'Other SQL databases'),
    'elasticsearch': buildTypeDefinition('icon-elasticsearch', 'ElasticSearch'),
    'twitter': buildTypeDefinition('icon-twitter', 'Twitter'),
    'kafka': buildTypeDefinition('icon-kafka', 'Kafka'),
    'sqs': buildTypeDefinition('icon-sqs', 'SQS'),
    'httpsse': buildTypeDefinition('icon-httpsse', 'HTTP Server Sent Events')
});
const DATASET_TYPES = Object.assign({}, COMMON_TYPES, {
    'cachedhttp': buildTypeDefinition('icon-FTP-HTTP-SSH', 'HTTP (with cache)'),
    'filesinfolder': buildTypeDefinition('icon-box', 'Files in Folder'),
    'http': buildTypeDefinition('icon-FTP-HTTP-SSH', 'HTTP'),
    'inline': buildTypeDefinition('icon-inline', 'Editable'),
    'jobsdb': buildTypeDefinition('icon-bar-chart', 'Metrics'),
    'statsdb': buildTypeDefinition('icon-tasks', 'Internal stats'),
    'remotefiles': buildTypeDefinition('icon-FTP-HTTP-SSH'),

});
const STREAMING_ENDPOINT_TYPES = {
    'kafka': buildTypeDefinition('icon-double-angle-right'),
    'httpsse': buildTypeDefinition('icon-double-angle-right'),
    'sqs': buildTypeDefinition('icon-double-angle-right')
};

const CONNECTION_TYPES = Object.assign({}, COMMON_TYPES,{
    'ec2': buildTypeDefinition('icon-amazon_s3', 'Amazon S3'),
    'ssh': buildTypeDefinition('icon-FTP-HTTP-SSH', 'SCP/SFTP'),
});
const RECIPE_TYPES = {
    'clustering_cluster': buildTypeDefinition('icon-clustering_recipe'),
    'clustering_scoring': buildTypeDefinition('icon-score_recipe'),
    'clustering_training': buildTypeDefinition('icon-train_recipe'),
    'distinct': buildTypeDefinition('icon-visual_prep_distinct_recipe'),
    'download': buildTypeDefinition('icon-visual_download_recipe'),
    'evaluation': buildTypeDefinition('icon-evaluation_recipe'),
    'standalone_evaluation': buildTypeDefinition('icon-standalone_evaluation_recipe'),
    'export': buildTypeDefinition('icon-visual_export_recipe'),
    'grouping': buildTypeDefinition('icon-visual_prep_group_recipe'),
    'hive': buildTypeDefinitionWithIconAndLanguage('icon-code_hive_recipe', 'text/x-hivesql'),
    'impala': buildTypeDefinitionWithIconAndLanguage('icon-code_impala_recipe', 'text/x-hivesql'),
    'ipython': buildTypeDefinition('icon-python'),
    'join': buildTypeDefinition('icon-visual_prep_join_recipe'),
    'fuzzyjoin': buildTypeDefinition('icon-visual_prep_fuzzyjoin_recipe'),
    'merge_folder': buildTypeDefinition('icon-visual_prep_merge_folder_recipe'),
    'julia' : buildTypeDefinitionWithIconAndLanguage('icon-code_julia_recipe','text/x-julia'),
    'pig': buildTypeDefinitionWithIconAndLanguage('icon-code_pig_recipe', 'text/x-dkupig'),
    'pivot': buildTypeDefinition('icon-visual_prep_pivot_recipe'),
    'prediction_scoring': buildTypeDefinition('icon-score_recipe'),
    'prediction_training': buildTypeDefinition('icon-train_recipe'),
    'pyspark': buildTypeDefinitionWithIconAndLanguage('icon-code_pyspark_recipe', 'text/x-python'),
    'python': buildTypeDefinitionWithIconAndLanguage('icon-code_python_recipe', 'text/x-python'),
    'r': buildTypeDefinitionWithIconAndLanguage('icon-code_r_recipe', 'text/x-rsrc'),
    'recipe': buildTypeDefinition('icon-circle'),
    'sampling': buildTypeDefinition('icon-visual_prep_filter-sample_recipe'),
    'shaker': buildTypeDefinition('icon-visual_prep_cleanse_recipe'),
    'shell': buildTypeDefinitionWithIconAndLanguage('icon-code_shell_recipe', 'text/x-sh'),
    'sort': buildTypeDefinition('icon-visual_prep_sort_recipe'),
    'spark_scala': buildTypeDefinitionWithIconAndLanguage('icon-code_spark_scala_recipe', 'text/x-scala'),
    'spark_sql_query': buildTypeDefinitionWithIconAndLanguage('icon-code_sparksql_recipe', 'text/x-sql2'),
    'sparkr': buildTypeDefinitionWithIconAndLanguage('icon-code_sparkr_recipe', 'text/x-rsrc'),
    'split': buildTypeDefinition('icon-visual_prep_split_recipe'),
    'sql': buildTypeDefinition('icon-sql'),
    'sql_query': buildTypeDefinitionWithIconAndLanguage('icon-code_sql_recipe', 'text/x-sql2'),
    'sql_script': buildTypeDefinitionWithIconAndLanguage('icon-code_sql_recipe', 'text/x-sql2'),
    'sync': buildTypeDefinition('icon-visual_prep_sync_recipe'),
    'topn': buildTypeDefinition('icon-visual_prep_topn_recipe'),
    'update': buildTypeDefinition('icon-visual_push_to_editable_recipe'),
    'vstack': buildTypeDefinition('icon-visual_prep_vstack_recipe'),
    'window': buildTypeDefinition('icon-visual_prep_window_recipe'),
    'csync': buildTypeDefinition('icon-continuous_sync_recipe'),
    'ksql': buildTypeDefinitionWithIconAndLanguage('icon-continuous_ksql_recipe', 'text/x-sql'),
    'cpython': buildTypeDefinitionWithIconAndLanguage('icon-continuous_python_recipe', 'text/x-python'),
    'streaming_spark_scala': buildTypeDefinitionWithIconAndLanguage('icon-continuous_spark_scala_recipe', 'text/x-scala')
};
const ML_TYPES = {
    'prediction': buildTypeDefinition('icon-beaker'),
    'regression': buildTypeDefinition('icon-machine_learning_regression'),
    'clustering': buildTypeDefinition('icon-machine_learning_clustering'),
};
const OTHER_TAGGABLE_OBJECTS_TYPES = {
    'analysis': buildTypeDefinition('icon-dku-nav_analysis'),
    'managed_folder': buildTypeDefinition('icon-folder-open'),
    'saved_model': buildTypeDefinition('icon-machine_learning_regression'),
    'model_evaluation_store': buildTypeDefinition('icon-model-evaluation-store'),
    'statistics_worksheet': buildTypeDefinition('icon-dku-statistics'),
    'scenario': buildTypeDefinition('icon-list'),
    'article': buildTypeDefinition('icon-dku-wiki'),
    'lambda_service': buildTypeDefinition('icon-cloud'),
    'flow_zone': buildTypeDefinition('icon-zone'),
    'taggable_object': buildTypeDefinition('icon-puzzle-piece'), //Generic (used for heterogeneous groups of taggable objects)
};
const NON_TAGGABLE_OBJECTS_TYPES = {
    'column': buildTypeDefinition('icon-list icon-rotate-90'),
    'meaning': buildTypeDefinition('icon-tags'),
    'discussion': buildTypeDefinition('icon-comments'),
};
const WEBAPPS_TYPES = {
    'web_app': buildTypeDefinition('icon-code'),
    'bokeh': buildTypeDefinition('icon-bokeh'),
    'dash': buildTypeDefinition('icon-dash'),
    'shiny': buildTypeDefinition('icon-code_r_recipe'),
    'standard': buildTypeDefinition('icon-code'),
};
const DASHBOARDS_OR_INSIGHTS_TYPES = {
    'insight': buildTypeDefinition('icon-dku-nav_dashboard'),
    'dashboard': buildTypeDefinition('icon-dku-dashboard'),
    'html': buildTypeDefinition('icon-code'),
    'image': buildTypeDefinition('icon-picture'),
    'text': buildTypeDefinition('icon-font'),
    'static_file': buildTypeDefinition('icon-file-alt'),
    'iframe': buildTypeDefinition('icon-link'),
    'bokeh_export': buildTypeDefinition('icon-bokeh'),
    'dash_export': buildTypeDefinition('icon-dash'),
    'static_chart': buildTypeDefinition('icon-bar-chart'),
    'discussions': buildTypeDefinition('icon-comments-alt'),
};
const OTHER_TYPES = {
    'project': buildTypeDefinition('icon-dkubird'),
    'report': buildTypeDefinition('icon-DKU_rmd'),
    'new': buildTypeDefinition('icon-plus'),
    'help': buildTypeDefinition('icon-question-sign'),
};
const NOTEBOOKS_TYPES = {
    'notebook': buildTypeDefinition('icon-dku-nav_notebook'),
    'sql_notebook': buildTypeDefinition('icon-sql'),
    'jupyter_notebook': buildTypeDefinition('icon-dku-nav_notebook'),
};
const ALL_TYPES = Object.assign( {},
    COMMON_TYPES, DATASET_TYPES, STREAMING_ENDPOINT_TYPES, CONNECTION_TYPES, RECIPE_TYPES, ML_TYPES, OTHER_TAGGABLE_OBJECTS_TYPES,
    NON_TAGGABLE_OBJECTS_TYPES, WEBAPPS_TYPES, DASHBOARDS_OR_INSIGHTS_TYPES, OTHER_TYPES, NOTEBOOKS_TYPES
);

function typeProcessor(type, types, conversionField, Logger, defaultValueFunction) {
    if(!type) {
        return '';
    }
    const existingType = types[type.toLowerCase()];
    const result = existingType && existingType[conversionField];
    if (result !== undefined) {
        return result;
    }
    return defaultValueFunction(type, conversionField, Logger);
}

function defaultValueForDataset(PluginsService) {
    return function (originalKey, conversionField, Logger) {
        const key = originalKey.toLowerCase();
        if (key.startsWith("custom") || key.startsWith("fsprovider_")) {
            if (CONVERSION_FIELD_ICON === conversionField) {
                return PluginsService.getDatasetIcon(originalKey);
            } else {
                return PluginsService.getDatasetLabel(originalKey);
            }
        }
        return defaultValue(key, conversionField, Logger);
    };
}

function defaultValueForRecipe(PluginsService) {
    return function (originalKey, conversionField, Logger) {
        const key = originalKey.toLowerCase();
        if (key.startsWith('custom')) {
            if (CONVERSION_FIELD_ICON === conversionField) {
                return PluginsService.getRecipeIcon(originalKey);
            }
        } else if (key.startsWith("app_")) {
            for (let ar of window.dkuAppConfig.appRecipes) {
                if (ar.recipeType == originalKey) {
                    return ar.icon;
                }
            }
        }
        return defaultValue(key, conversionField, Logger);
    };
}

function defaultValueForWebApp(WebAppsService) {
    return function(originalKey, conversionField, Logger) {
        if (conversionField === CONVERSION_FIELD_ICON) {
            return WebAppsService.getWebAppIcon(originalKey) || 'icon-code';
        } else if (conversionField === CONVERSION_FIELD_NAME) {
            return WebAppsService.getWebAppTypeName(originalKey) || type;
        } else {
            return defaultValue(originalKey.toLowerCase(), conversionField, Logger);
        }
    };
}

function defaultValue(key, conversionField, Logger) {
    const defaultPrefix = CONVERSION_FIELD_ICON === conversionField ? 'icon-' : '';
    const result = defaultPrefix + key.toLowerCase();
    if (Logger !== undefined) {
        Logger.error("Unknown type: " + key + ".Returning default value: " + result);
    }
    return result;
}


app.filter('slugify', function(){
    return function(input){
        if (input===undefined) {return '';}
        return input.replace(/\s+/g,'-').replace(/[^a-zA-Z0-9\-]/g,'').replace(/\-+/g,'-').toLowerCase();
    };
});


app.filter('join', function(){
    return function(input){
        return input.join(",");
    };
});


app.filter('capitalize', function(){
    return function(input){
        if(input && input.length>0) {
            return input.charAt(0).toUpperCase() + input.slice(1);
        } else {
            return '';
        }
    };
});


app.filter('pluralize', function() {
    /**
     * Pluralize an item name.
     * @param {number}            num         - The quantity of the item
     * @param {string}            singular    - The singular form of the item name (only used when num is worth 1)
     * @param {string}            plural      - The plural form of the item name
     * @param {d3 formatter}      [format]    - Optional d3.js formatter for num
     * @param {boolean | string}  [no]        - Optional indicator of the filter behavior when num is worth 0:
     *                                        If false (default), use '0 ' + plural
     *                                        If true, use 'no ' + plural
     *                                        If a string, use it
     */
    return function(num, singular, plural, format, no) {
        if (no && num == 0) return no === true ? 'no ' + plural : no;
        return (format ? d3.format(format)(num) : num) + " " + (num === 1 ? singular : plural);
    }
});


app.filter('plurify', function() {
    return function(singular, num, plural) {
        plural = typeof(plural) !== "undefined" ? plural : singular + 's';
        return num == 1 ? singular : plural; // in english zero uses plural mode (crazy guys)
    };
});

app.filter('breakify', function (LoggerProvider) {
    return function (text, breakOnRegex) {
        try {
            const re = new RegExp(breakOnRegex, 'g');
            const indices = [];
            let m;
            do {
                m = re.exec(text);
                if (m) {
                    indices.push(m.index + m[0].length);
                }
            } while (m);
            indices.reverse().forEach(pos => {
                if (text) {
                    text = [text.slice(0, pos), '<wbr>', text.slice(pos)].join('');
                }
            });
            return text;
        } catch(err) {
            LoggerProvider.getLogger('DisplayFilters').error("Error ", err);
            return text;
        }
    };
});

app.filter('uncamel', function (LoggerProvider) {
    return function (text) {
        try {
            return text.replace(/[A-Z]/g, function(l) { return ' ' + l.toLowerCase(); })
        } catch(err) {
            LoggerProvider.getLogger('DisplayFilters').error("Error ", err);
            return text;
        }
    };
});

app.filter('objectSize', function() {
    return function(object) {
        if (!object) return 0;
        return Object.keys(object).length;
    };
});


app.filter('listSlice', function(){
    return function(input, from, to) {
        if (!input || input.length <= from) {
            return [];
        }
        return input.slice(from, to);
    }
});


// `[n] | range`        => 0 .. (n-1)
// `[from, to] | range` => from .. to (inclusive)
app.filter('range', function() {
    return function(input) {
        switch (input.length) {
            case  1:
                if (input[0] <= 0) return [];
                input = [0, input[0] - 1]; break;
            case  2:
                if (input[1] < input[0]) return [];
                break;
            default: return input;
        }
        var len = input[1] - input[0] + 1,
            result = new Array(len);
        for (var i = 0; i < len; i++) {
            result[i] = i + input[0];
        }
        return result;
    };
});


app.filter('gentleTruncate', function () {
    return function (text, length, end) {

        if (isNaN(length))
            length = 10;

        return gentleTruncate(text, length);

    };
});


app.filter('onlyNumbers', function(){
    return function(text){
        if (!text) { return ''; }
        return text.replace(/[^0-9]/g, '');
    };
});


app.filter('ordinal', function(){
    return function(number){
        return number < 14 && number > 10 ? 'th' : ['th','st','nd','rd','th','th','th','th','th','th'][number % 10];
    };
});


app.filter('ordinalWithNumber', function(){
    return function(number){
        return number + (number < 14 && number > 10 ? 'th' : ['th','st','nd','rd','th','th','th','th','th','th'][number % 10]);
    };
});

// ratio to % w/ fixed precision & optional non-breaking space
// special cases: '<1%' and '>99%' when <.01 but >0 (for precision == 2, '<0.01%'...)
app.filter('smartPercentage', function() {
    return function(ratio, precision, spaces) {
        precision = Math.max(+(precision || 0), 0);
        var tens = Math.pow(10, precision),
            min = 1 / tens / 100, // e.g. precision = 2 =>  0.01
            max = 1 - min,        //                    => 99.99
            out = [];
        if (ratio < 1 && ratio > max) {
            ratio = max;
            out.push('>');
        } else if (ratio > 0 && ratio < min) {
            ratio = min;
            out.push('<');
        }
        out.push((Math.round(ratio * 100 * tens) / tens).toFixed(precision), '%');
        return out.join(spaces ? '\u00A0' : '');
    }
});


app.filter('processorByType', function(){
    return function(processors, type){
        if (processors) {
            for (var i = 0; i < processors.processors.length; i++) {
                if (processors.processors[i].type == type) {
                    return processors.processors[i];
                }
            }
        }
        throw Error("Unknown processor " +type);
    }
});


app.filter('cleanFacetValue', function() {
    return function(input) {
        if (input == "___dku_no_value___") {
            return "<em>No value</em>";
        } else {
            return input;
        }
    };
});


app.filter('chartLabelValue', function() {
    return function(input) {
        if (input == "___dku_no_value___") {
            return "No value";
        } else {
            return input;
        }
    };
});


app.filter("prettyjson", function(){
    return function(input) {
         return JSON.stringify(input,undefined,3);
    }
});


app.filter("jsonOrString", function(){
    return function(input) {
        if (typeof input == "string") {
            return input;
        }
        else {
            return JSON.stringify(input);
        }    
    }
});


app.filter('friendlyTime', function() {
    return function(input) {
        var diffInSeconds = parseInt(input, 10) / 1000;
        return friendlyDuration(diffInSeconds);
    };
});


app.filter('friendlyTimeDeltaForward', function() {
    const filter =  function(input) {
        var diffInSeconds = (parseInt(input, 10) - now) / 1000;
        return "in " + friendlyDuration(diffInSeconds);
    };
    filter.$stateful= true;
    return filter;
});


app.filter('friendlyTimeDelta', function() {
    const filter = input => {
        var diffInSeconds = (now - parseInt(input, 10)) / 1000;
        return friendlyDuration(diffInSeconds) + ' ago';
    };
    filter.$stateful = true;
    return filter;
});


app.filter('friendlyTimeDeltaShort', function() {
    const filter = function(input) {
        var diffInSeconds = (now - parseInt(input, 10)) / 1000;
        return friendlyDurationShort(diffInSeconds, 'ago', true);
    };
    filter.$stateful = true;
    return filter;
});

app.filter('friendlyTimeDeltaHHMMSS', function() {
    const filter = function(input) {
        var diffInSeconds = Math.max(0, (now - parseInt(input, 10)) / 1000);
        return durationHHMMSS(diffInSeconds);
    };
    filter.$stateful= true;
    return filter;
});

app.filter('friendlyDuration', function(){
    return function (input) { return friendlyDuration(parseInt(input, 10) / 1000); };
});


app.filter('friendlyDurationShort', function() {
    return function(input, ref, noSeconds) {
        return friendlyDurationShort(parseInt(input, 10) / 1000, ref, noSeconds);
    };
});


app.filter('friendlyDurationSec', function() {
    return function(input) {
        return friendlyDuration(parseInt(input, 10));
    };
});


app.filter('durationHHMMSS', function() {
    return function(input) {
        return durationHHMMSS(parseInt(input, 10)/1000);
    };
});


app.filter('durationHHMMSSPadded', function() {
    return function(input) {
        return durationHHMMSSPadded(parseInt(input, 10)/1000);
    };
});


app.filter('yesNo', function(){
    return function(input) {
        if (input) return "Yes";
        else return "No";
    }
});

app.filter('friendlyDate', function($filter) {
    return function(time, format) {
        format = format || 'EEEE, d MMMM';
        var today = new Date();
        var date = new Date(time);
        if(dateDayDiff(date, today)===0){
            return 'Today'
        } else if(dateDayDiff(date, today)===-1){
            return 'Yesterday'
        } else if(dateDayDiff(date, today)===1){
            return 'Tomorrow'
        } else {
            return $filter('date')(date, format);
        }

    };
});


app.filter('friendlyDateRange', function($filter) {
    const day = $filter('friendlyDate');
    const time = date => $filter('date')(date, 'HH:mm');
    function duration(date1, date2, options) {
        if (options && options.noDuration || !date2){
            return '';
        }
        let delta = (new Date(date2) - new Date(date1));
        return ' (duration: ' + $filter('durationHHMMSS')(delta) + ')';
    }

    function unavailableEndDate(date) {
        return day(date) + ', started at ' +  time(date);
    }
    function sameMinute(date1, date2, options) {
        return day(date1) + ' ' +  time(date1) + duration(date1, date2, options);
    }
    function sameDay(date1, date2, options) {
        return day(date1) + ', ' +  time(date1) + ' to ' + time(date2) + duration(date1, date2, options);
    }
    function differentDays(date1, date2, options) {
        return 'From ' + day(date1) + ' ' +  time(date1)+ ' to ' + day(date2) + ' ' +  time(date2) + duration(date1, date2, options);
    }

    return function(date1, date2, options) {
        options = options || {};
        if (!date2) {
            return unavailableEndDate(date1);
        } else if (dateMinuteDiff(date1, date2) == 0) {
            return sameMinute(date1, date2, options);
        } else if (dateDayDiff(date1, date2) == 0) {
            return sameDay(date1, date2, options);
        } else {
            return differentDays(date1, date2, options);
        }
    };
});


app.filter('friendlyDateTime', function($filter) {
    var sameDay = function (date1, date2) {
        return date1.getFullYear() === date2.getFullYear() &&
               date1.getMonth() === date2.getMonth() &&
               date1.getDate() === date2.getDate();
    }
    return function(time, format) {
        var today = new Date(),
            yesterday = new Date(),
            tomorrow = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        tomorrow.setDate(tomorrow.getDate() + 1);

        var date = new Date(time);
        var datePart;
        if(sameDay(date, today)){
            datePart = 'Today'
        } else if(sameDay(date, yesterday)){
            datePart = 'Yesterday'
        } else if(sameDay(date, tomorrow)){
            datePart = 'Tomorrow'
        } else {
            if (!format) {
                const nth = function(d) {
                  if (d > 3 && d < 21) return 'th';
                  switch (d % 10) {
                    case 1:  return "st";
                    case 2:  return "nd";
                    case 3:  return "rd";
                    default: return "th";
                  }
                }
                var day = $filter('date')(date, 'd');
                // 'EEEE, MMMM dth, yyyy' but I cannot put the "th" part into the filter because every the "2nd" with ends up like "2n2"
                datePart = $filter('date')(date, 'EEEE, MMMM ') + day + nth(parseInt(day)) + $filter('date')(date, ', yyyy');
            } else {
                datePart = $filter('date')(date, format);
            }
        }
        return datePart + ' at ' + $filter('date')(date, 'HH:mm')
    };
});


app.filter('utcDate', function() {
    return function(time, format) {
        format = format || 'EEEE, d MMMM';
        return moment.utc(time).format(format);
    };
});


app.filter('recipeTypeToName', function(RecipeDescService) {
    return RecipeDescService.getRecipeTypeName;
});

app.filter('datasetTypeToName', function(LoggerProvider, PluginsService) {
    return function(type) {
        return typeProcessor(type, DATASET_TYPES, CONVERSION_FIELD_NAME, LoggerProvider.getLogger('DisplayFilters'),
            defaultValueForDataset(PluginsService));
    };
});


app.filter('pluginIdToName', function(LoggerProvider, PluginsService) {
    return function(pluginId) {
        if(!pluginId) {
            return '';
        }
        let desc = PluginsService.getPluginDesc(pluginId);
        if (desc) {
            return desc.label;
        }
        return pluginId;
    };
});


app.filter("niceProfileName", function(){
    var dict = {
        "DATA_SCIENTIST": "Data scientist",
        "DATA_ANALYST": "Data analyst",
        "READER" : "Reader",
        "DESIGNER" : "Designer",
        "VISUAL_DESIGNER": "Visual Designer",
        "PLATFORM_ADMIN": "Platform admin",
        "EXPLORER": "Explorer"
    };
    return function(input) {
        return dict[input] || input;
    };
});

app.filter('itemToColor', function(typeToColorFilter) {
    return function(item) {
        return typeToColorFilter(item.type);
    };
});


app.filter('typeToColor', function($filter) {
    const supportedTypes = [
        "project",
        "dataset",
        "streaming_endpoint",
        "recipe",
        "analysis",
        "notebook",
        "scenario",
        "saved_model",
        "model_evaluation_store",
        "managed_folder",
        "web_app",
        "report",
        "dashboard",
        "insight",
        "article"];
    function getStandardType(type) {
        if (!type) return;
        if (type.endsWith("_NOTEBOOK")) {
            return "notebook";
        }
        return type.toLowerCase();
    }
    return function(type) {
        if (!type) return "";
        const recipeColor = $filter('recipeTypeToColor')(type);
        if (recipeColor) {
            return recipeColor;
        }

        const stdType = getStandardType(type);
        if (supportedTypes.indexOf(stdType) >= 0) {
            return "universe-color " + stdType;
        }
        return "";
    };
});


app.filter('insightTypeToIcon', function(DashboardUtils) {
    return function(type) {
        function defaultValueForInsight(key, conversionField, Logger) {
            return (DashboardUtils.getInsightHandler(type) || {}).icon;
        }
        return typeProcessor(type, DASHBOARDS_OR_INSIGHTS_TYPES, CONVERSION_FIELD_ICON, undefined, defaultValueForInsight);
    };
});


app.filter('insightTypeToColor', function(DashboardUtils) {
    return function(type, noBackground) {
        var color;
        switch(type) {
            case 'text':
            case 'iframe':
            case 'image':
                color = 'comments';
                break;
            default:
                color = (DashboardUtils.getInsightHandler(type) || {}).color;
                break;
        }

        if (!noBackground) return 'universe-background insight-icon ' + color;
        else return color;
    };
});


app.filter('insightTypeToDisplayableName', function(DashboardUtils) {
    return function(type) {
        var handler = DashboardUtils.getInsightHandler(type);
        if (!handler || !handler.name) return type;
        return handler.name;
    };
});

app.filter('webappTypeToIcon', function(WebAppsService) {
    return function(type) {
        return typeProcessor(type, WEBAPPS_TYPES, CONVERSION_FIELD_ICON, undefined,
            defaultValueForWebApp(WebAppsService));
    };
});

app.filter('webappTypeToColor', function(WebAppsService) {
    return function(type) {
        if (WebAppsService.getBaseType(type) == type) {
            return 'notebook'; //native webapp => code color
        } else {
            return 'flow';
        }
    };
});

app.filter('webappTypeToName', function(WebAppsService) {
    return function(type) {
        return typeProcessor(type, WEBAPPS_TYPES, CONVERSION_FIELD_NAME, undefined,
            defaultValueForWebApp(WebAppsService));
    };
});

function connectionTypeToName(connectionType, forDetailView) {
    const conversionField = forDetailView ? CONVERSION_FIELD_NAME : CONVERSION_FIELD_OTHER_NAME;
    return typeProcessor(connectionType, CONNECTION_TYPES, conversionField, undefined, defaultValue);
}

app.filter('connectionTypeToNameForList', function() {
    return function(connectionType) {
        return connectionTypeToName(connectionType, false);
    };
});
app.filter('connectionTypeToNameForItem', function() {
    return function(connectionType) {
        return connectionTypeToName(connectionType, true);
    };
});

app.filter("connectionTypeToIcon", function(LoggerProvider){
     return function(type) {
         return typeProcessor(type, CONNECTION_TYPES, CONVERSION_FIELD_ICON,
             LoggerProvider.getLogger('connectionTypeToIcon'), defaultValue);
     };
});

app.filter('datasetTypeToIcon', function(PluginsService, LoggerProvider) {
    return function(type) {
       return typeProcessor(type, DATASET_TYPES, CONVERSION_FIELD_ICON,
           LoggerProvider.getLogger('datasetTypeToIcon'), defaultValueForDataset(PluginsService));
    };
});

app.filter('recipeTypeToColorClass', function(recipeTypeToIconFilter, PluginsService, RecipeDescService, LoggerProvider) {
    const customRecipeColors = ["red", "pink", "purple", "blue", "green", "sky", "yellow", "orange", "brown", "grey"];

    return function(type) {
        if (!type) {
            return "recipe-custom";
        }
        if (!RecipeDescService.isRecipeType(type)) {
            return;
        }

        const loadedDesc = PluginsService.getRecipeLoadedDesc(type);
        if (loadedDesc) {
            let colorClass = 'recipe-custom';

            if (loadedDesc && loadedDesc.desc && loadedDesc.desc.meta) {
                const iconColor = loadedDesc.desc.meta.iconColor;

                if (customRecipeColors.indexOf(iconColor) > -1) {
                    colorClass = colorClass + "-" + iconColor;
                }
            }
            return colorClass;
        }

        const icon = recipeTypeToIconFilter(type);
        return icon ? "recipe-" + icon.split('_')[0].split('icon-')[1] : "";
    }
});

app.filter('recipeTypeToColor', function(recipeTypeToIconFilter, PluginsService, RecipeDescService, LoggerProvider, $filter) {
    return function(type) {
        if (!type) {
            return "universe-color recipe-custom";
        }
        const colorClass = $filter("recipeTypeToColorClass")(type);
        if (!colorClass) {
            return;
        }
        return "universe-color " + colorClass;
    }
});
app.filter('recipeTypeToIcon', function(PluginsService) {
    return function(input) {
        return typeProcessor(input, RECIPE_TYPES, CONVERSION_FIELD_ICON, undefined,
            defaultValueForRecipe(PluginsService));
    };
});


app.filter('modelTypeToIcon', function(PluginsService) {
    return function(input) {
        return typeProcessor(input, ML_TYPES, CONVERSION_FIELD_ICON, undefined,
            defaultValueForRecipe(PluginsService));
    };
});

app.filter("recipeTypeToLanguage", function() {
    return function(recipeType) {
        function defaultToUndefined(key, conversionField, Logger) {
            return undefined;
        }
        return typeProcessor(recipeType, RECIPE_TYPES, CONVERSION_FIELD_LANGUAGE, undefined, defaultToUndefined);
    }
});

app.filter('typeToIcon', function(PluginsService) {
    return function (input) {
        return typeProcessor(input, ALL_TYPES, CONVERSION_FIELD_ICON, undefined,
            defaultValueForDataset(PluginsService));
    }
});

app.filter('subTypeToIcon', function($filter) {
    var subtypeFilters = {
        'INSIGHT':            $filter('insightTypeToIcon'),
        'DATASET':            $filter('datasetTypeToIcon'),
        'RECIPE':             $filter('recipeTypeToIcon'),
        'WEB_APP':            $filter('webappTypeToIcon'),
        'STREAMING_ENDPOINT': $filter('datasetTypeToIcon'),
    };
    return function(subtype, type) {
        if (subtype && subtypeFilters[type.toUpperCase()]) {
            return subtypeFilters[type.toUpperCase()](subtype);
        } else {
            return $filter('typeToIcon')(type);
        }
    };
});


app.filter('subTypeToColor', function($filter) {
    var subtypeFilters = {
        'INSIGHT': $filter('insightTypeToColor'),
        'RECIPE': $filter('recipeTypeToColor')
    };
    return function(subtype, type) {
        if (subtype && subtypeFilters[type.toUpperCase()]) {
            return subtypeFilters[type.toUpperCase()](subtype);
        } else {
            return $filter('typeToColor')(type);
        }
    };
});


app.filter('mlTaskTypeToIcon', function() {
    return function(taskType, predictionType) {
        if (!taskType || !predictionType) {
            return;
        }
        if (taskType.toLowerCase() == 'clustering') {
            return "icon-clustering";
        }
        return "icon-prediction-"+predictionType.toLowerCase();
    };
});


app.filter('backendTypeToIcon', function() {
    return function(backendType) {
        if (!backendType) return;
        return "icon-ml icon-ml-"+backendType.toLowerCase();
    };
});

// Boldify a pattern in the input.
//
// Note:
// - Input is plain text (and not HTML, because it will be escaped)
// - Output is HTML (sanitized, ready for display)
app.filter('boldify', function(){
    function preg_quote( str ) {
        return (str+'').replace(/([\\\.\+\*\?\[\^\]\$\(\)\{\}\=\!\<\>\|\:])/g, "\\$1");
    }

    return function(input, replacements) {
        if (!replacements || replacements.length == 0 || !input) return sanitize(input);
        // Implementation notes:
        // - It is not possible to escape HTML entities and then boldify the pattern: this may produce invalid HTML if the pattern matches)
        // - It is not possible to boldify the pattern and then escape HTML entities: the boldification will be escaped
        // => Strategy is to split the string into tokens. Tokens are sanitized individually, and then enclosed in <b>...</b> if they match the pattern.

        var regex = new RegExp(replacements.map(function(e){
            if (e instanceof RegExp) {
                return "(?:"+e.source+")";
            } else {
                return "(?:"+preg_quote(e)+")";
            }
        }).join("|"), "gi");

        const highlightedSections = [];
        const rawTokenBoundaries = [0, input.length];

        input.replace(regex, function(val, pos) {
            highlightedSections.push([pos, pos + val.length]);
            rawTokenBoundaries.push(pos);
            rawTokenBoundaries.push(pos + val.length);
        });

        const tokenBoundaries = _.chain(rawTokenBoundaries).uniq().sortBy().value();

        let output = '';
        for(let i = 1; i < tokenBoundaries.length; i++) {
            const tokStartPos = tokenBoundaries[i-1];
            const tokEndPos = tokenBoundaries[i];
            let tokHighlighted = false;

            for(let j = 0; j < highlightedSections.length; j++) {
                const hlStartPos = highlightedSections[j][0];
                const hlEndPos = highlightedSections[j][1];

                if(hlStartPos < tokEndPos && tokStartPos < hlEndPos) {
                    tokHighlighted = true;
                    break;
                }
            }

            const token = input.substring(tokStartPos, tokEndPos);

            if(tokHighlighted) output += '<b>';
            output += sanitize(token);
            if(tokHighlighted) output += '</b>';
        }

        return output;
    }
});

app.filter('connectionNameFormatter', function () {
    const virtualConnectionRegex = "^@virtual\\((.+)\\):(connection:)?(.+)$";

    return function (input) {
        if (!input) return input;
        const match = input.match(virtualConnectionRegex);
        return match ? `Hive (${match[3]})` : input;
    }
});

app.filter('niceType', function($filter) {
    return function(input) {
        return typeProcessor(input, DATASET_TYPES, CONVERSION_FIELD_NAME, undefined,
            $filter('connectionTypeToNameForItem'))
    };
});


app.filter('nicePrecision', function() {
    return function(val, p) {
        if (val == undefined || val != val || val == null || !val.toFixed)
            return undefined;
        if (Math.abs(val) < Math.pow(10, p)) {
            if (Math.round(val) == val) {
                /* Don't add stuff to integers */
                return val.toFixed(0);
            } else {
                return val.toPrecision(p);
            }
        } else {
            return val.toFixed(0);
        }
    };
});

app.filter('ifEmpty', function() {
    return (value, defaultValue) => value == null ? defaultValue : value;
});

app.filter('niceConst', function() {
    return function(input) {
        if (!input || !input.length) { return ''; }
        input = input.replace(/[\s_]+|([a-z])(?=[A-Z])/g, '$1 ').trim();
        var nice = input.charAt(0).toUpperCase() + input.substr(1).toLowerCase();
        if (nice == 'Lambda service') {
            nice = 'API service';
        }
        if (nice == 'Sql notebook') {
            nice = 'SQL notebook';
        }
        return nice;
    }
});


app.filter('niceMLBackendType', function(LoggerProvider) {
    var niceNames = {
        'PY_MEMORY': 'Python (in memory)',
        'MLLIB': 'Spark MLLib',
        'H2O': 'Sparkling Water (H2O)',
        'VERTICA': 'Vertica Advanced Analytics'
    };

    var Logger = LoggerProvider.getLogger('DisplayFilters');

    return function(input) {
        if (!niceNames[input]) {
            Logger.warn("ML backend has no display name: "+input);
            return input;
        } else {
            return niceNames[input];
        }
    }
});


// input | replace:search_str:replacement
// input | replace:search_regexp:flags:replacement
app.filter('replace', function() {
    return function(input, regexp, flags, replace) {
        if (typeof replace === 'undefined') {
            replace = flags;
        } else {
            regexp = new RegExp(regexp, flags);
        }
        return regexp ? input.replace(regexp, replace) : input;
    }
});


app.filter('startAt', function() {
    return function(input, first) {
        first = parseInt(first, 10);
        var out = [], i;
        if (first >= input.length) {
            return out;
        }
        for (var i = first; i<input.length; i++) {
            out.push(input[i]);
        }
        return out;
    };
});


app.filter('shakerStepIcon', function(ShakerProcessorsUtils) {
    return function(step) {
        return ShakerProcessorsUtils.getStepIcon(step.type, step.params);
    };
});


app.filter('shakerStepDescription', function(ShakerProcessorsUtils) {
    return function(step) {
        return ShakerProcessorsUtils.getStepDescription(step.type, step.params);
    };
});


app.filter('objToParamsList', function(){
    return function(obj) {
        var arr = [];
        $.each(obj, function(key, val){
            arr.push(key + ": " + val);
        });
        return arr.join(', ');
    }
});


app.filter('filesize', function(){
    return function(size){
        if (size >= 1024*1024*1024) {
            return Math.round(size / 1024 / 1024 / 1024 * 100)/100 + ' GB';
        } else if (size >= 1024*1024){
            return Math.round(size / 1024 / 1024*100)/100 + ' MB';
        } else {
            return Math.round(size / 1024 *100)/100 + ' KB';
        }
    };
});


app.filter('fileSizeOrNA', function(){
    return function(size){
        if (size < 0) {
            return "N/A";
        } else if (size >= 1024*1024*1024) {
            return Math.round(size / 1024 / 1024 / 1024 * 100)/100 + ' GB';
        } else if (size >= 1024*1024){
            return Math.round(size / 1024 / 1024*100)/100 + ' MB';
        } else {
            return Math.round(size / 1024 *100)/100 + ' KB';
        }
    };
});


app.filter('fileSizeInMB', function(){
    return function(size){
        if (size < 0) {
            return "N/A";
        } else {
            return Math.round(size / 1024 / 1024*100)/100 + ' MB';
        }
    };
});


app.filter("displayMeasure", function() {
    return function(measure) {
        if (measure.function == 'SUM') {
            return 'Sum of ' + measure.column.name;
        } else if (measure.function == 'AVG') {
            return 'Average of ' + measure.column.name;
        } else {
            return "I have no idea what this is about " + measure.column;
        }
    };
});


app.filter("percentage", function() {
    return function(val) {
        return Math.round(val * 100) + '%';
    };
});


app.filter('toKVArray', function(){
    return function(dict) {
        if (dict){
            return $.map(dict, function(v, k){
                return {k:k, v:v};
            });
        } else {
            return [];
        }
    };
});


function objectToArray(dict, saveKey) {
    if (dict) {
        return $.map(dict, function (v, k) {
            if (saveKey) {
                v['_key'] = k;
            }
            return v;
        });
    }
    return [];
}

app.filter('toArray', function(){
    return (dict) => objectToArray(dict);
});

app.filter('toArrayWithKey', function () {
    return (dict) => objectToArray(dict, true);
});


app.filter('datasetPartition', function() {
    return function(val) {
        if (val.partition && val.partition != 'NP') {
            return val.dataset + " (" + val.partition + ")";
        } else {
            return val.dataset;
        }
    };
});


app.filter('breakText', function(){
    return function(text, breakon){
        var bo = breakon || '_';
        return text.replace(new RegExp(bo, 'g'), bo + '&#8203;');
    };
});


app.filter('truncateText', function(){
   return function(text, val){
        if (val == null) val = 30;
       return text.substring(0, val);
   };
});

app.filter('subString', function(){
    return function(text, start, end){
        if (start > end) {
            let s = start;
            start = end;
            end = s;
        }
        return text.substring(start, end);
    };
 });

app.filter('sanitize', function() {
    return function(x) {
        return sanitize(x);
    };
});

app.filter("stripHtml", function($sanitize) {
    return (htmlString) => $("<div>").html($sanitize(htmlString)).text();
})

app.filter('escape', function() {
   return function(x) {
       return escape(x);
   };
});


app.filter('escapeHtml', function() {
    var chars = /[<>&'"]/g,
        esc = (function(_) { return this[_]; }).bind({
            '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;', "'": '&apos;' });
    return function(s) { return s.replace(chars, esc); };
});


app.filter('unescapeHtml', function() {
    var chars = /&(lt|gt|amp|quot|apos|#(\d+)|#x([0-9a-fA-F]+));?/g,
        esc = (function(_, code, dec, hex) {
            if (code in this) return this[code];
            if (dec || hex) return String.fromCharCode(parseInt(dec || hex, dec ? 10 : 16));
            return _;
        }).bind({ lt: '<', gt: '>', amp: '&', quot: '"', apos: "'" });
    return function(s) { return s.replace(chars, esc); };
});


app.filter('meaningLabel', function($rootScope) {
    return function(input) {
        return $rootScope.appConfig.meanings.labelsMap[input] || input;
    };
});


app.filter('buildPartitionsDesc', function() {
    return function(input) {
        if (input.useExplicit) {
            return input.explicit;
        } else if (input.start) {
            if (input.start == input.end) {
                return input.start;
            } else {
                return input.start + " / " +input.end;
            }
        } else {
            return input;
        }
    };
});


// Similar to linky for doesn't detect emails
app.filter('parseUrlFilter', function() {
    var urlPattern = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;

    return function(text, target) {
        if(!target) {
            target = '_blank';
        }
        if(text) {
            return text.replace(urlPattern,'<a href="$1" target="'+target+'">$1</a>');
        }
        else {
            return '';
        }
    };
});


app.filter('dynamicFormat', function($filter) {
	  return function(value, filterName) {
	    return $filter(filterName)(value);
	  };
});


app.factory('$localeDurations', [function () {
    return {
        'one': {
            year: '{} year',
            month: '{} month',
            week: '{} week',
            day: '{} day',
            hour: '{} hour',
            minute: '{} minute',
            second: '{} second'
        },
        'other': {
            year: '{} years',
            month: '{} months',
            week: '{} weeks',
            day: '{} days',
            hour: '{} hours',
            minute: '{} minutes',
            second: '{} seconds'
        }
    };
}]);


app.filter('duration', ['$locale', '$localeDurations', function ($locale, $localeDurations) {
    return function duration(value, unit, precision) {
        var unit_names = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second'],
            units = {
                year: 86400*365.25,
                month: 86400*31,
                week: 86400*7,
                day: 86400,
                hour: 3600,
                minute: 60,
                second: 1
            },
            words = [],
            max_units = unit_names.length;


        precision = parseInt(precision, 10) || units[precision || 'second'] || 1;
        value = (parseInt(value, 10) || 0) * (units[unit || 'second'] || 1);

        if (value >= precision) {
            value = Math.round(value / precision) * precision;
        } else {
            max_units = 1;
        }

        var i, n;
        for (i = 0, n = unit_names.length; i < n && value !== 0; i++) {
            var unit_name = unit_names[i],
                unit_value = Math.floor(value / units[unit_name]);

            if (unit_value !== 0) {
                words.push(($localeDurations[unit_value] || $localeDurations[$locale.pluralCat(unit_value)] || {unit_name: ('{} ' + unit_name)})[unit_name].replace('{}', unit_value));
                if (--max_units === 0) break;
            }

            value = value % units[unit_name];
        }

        if (words.length){
            return words.join(" ");
        }
        return '0s';
    };
}]);

app.filter('fsProviderDisplayName', function() {
    return function(value) {
        return typeProcessor(value, FS_PROVIDER_TYPES, CONVERSION_FIELD_NAME, undefined, defaultValue);
    };
});

app.filter('cleanConnectionName', function() {
    return function(input) {
        if (input && input.startsWith("@virtual(impala-jdbc):")) {
            return "Impala builtin";
        } else {
            return input;
        }
    };
});

app.filter('uniqueStrings', function() {
    return function(x) {
        if (!x) return x;
        var uniqueValues = [];
        x.forEach(function(v) {
           if (uniqueValues.indexOf(v) < 0) {
               uniqueValues.push(v);
           }
        });
        return uniqueValues;
    };
 });

app.filter('encodeHTML', function() {
    return rawStr => String(rawStr).replace(/[\u00A0-\u9999<>\&]/gim, i => '&#'+i.charCodeAt(0)+';');
});

app.filter('map2Object', function() {
    return function(input) {
      var output = {};
      input.forEach((value, key) => output[key] = value);
      return output;
    };
});

app.filter("bundleProjectContent", function() {
    const bundleContentConfigMap = {
        datasets: 'Datasets',
        recipes: 'Recipes',
        savedModels: 'Saved models',
        modelEvaluationStores: 'Evaluation stores',
        managedFolders: 'Managed folders',
        scenarios: 'Scenarios',
        analysis: 'Analyses',
        jupyterNotebooks: 'Jupyter notebooks',
        sqlNotebooks: 'SQL notebooks',
        insights: 'Insights',
        dashboards: 'Dashboards'
    }
    return input => bundleContentConfigMap[input];
});

})();

(function() {
'use strict';

const app = angular.module('dataiku.markdown', ['dataiku.taggableobjects']);


app.service('Markdown', function($stateParams, $filter, TAGGABLE_TYPES, StateUtils, SmartId, Logger, WT1, ActiveProjectKey) {

/**
 * adapted from marked - a markdown parser
 * Copyright (c) 2011-2013, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */


// Usage report {string: int} corresponding to occurrences of various functionalities
let dkuLastMarkdownUsageReport;

function reportUsage(key) {
    dkuLastMarkdownUsageReport[key] = (dkuLastMarkdownUsageReport[key] || 0) + 1;
}

/**
 * Block-Level Grammar
 */

var block = {
    newline: /^\n+/,
    code: /^( {4}[^\n]+\n*)+/,
    fences: noop,
    hr: /^( *[-*_]){3,} *(?:\n+|$)/,
    heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
    nptable: noop,
    lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
    blockquote: /^( *>[^\n]+(\n[^\n]+)*\n*)+/,
    list: /^( *)(bull) [\s\S]+?(?:hr|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
    html: /^ *(?:comment|closed|closing) *(?:\n{2,}|\s*$)/,
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
    table: noop,
    paragraph: /^((?:[^\n]+?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
    text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
    (/bull/g, block.bullet)
    ();

block.list = replace(block.list)
    (/bull/g, block.bullet)
    ('hr', /\n+(?=(?: *[-*_]){3,} *(?:\n+|$))/)
();

block._tag = '(?!(?:'
    + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
    + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
    + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

block.html = replace(block.html)
    ('comment', /<!--[\s\S]*?-->/)
    ('closed', /<(tag)[\s\S]+?<\/\1>/)
    ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
    (/tag/g, block._tag)
    ();

block.paragraph = replace(block.paragraph)
    ('hr', block.hr)
    ('heading', block.heading)
    ('lheading', block.lheading)
    ('blockquote', block.blockquote)
    ('tag', '<' + block._tag)
    ('def', block.def)
    ();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

block.dku = {
    paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
    text: /^[^\n]+/
};

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
    fences: /^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/,
    paragraph: /^/
});

block.gfm.paragraph = replace(block.paragraph)
('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|'
)();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
    nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
    table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

 function Lexer(options) {
    this.tokens = [];
    this.tokens.links = {};
    this.options = options || marked.defaults;
    this.rules = block.normal;

    if (this.options.gfm) {
        if (this.options.tables) {
            this.rules = block.tables;
        } else {
            this.rules = block.gfm;
        }
    }

    if (this.options.noMarkdown) {
        this.rules = block.dku;
    }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
    var lexer = new Lexer(options);
    dkuLastMarkdownUsageReport = {
        payloadLength: src.length
    };
    return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
    src = src
        .replace(/\r\n|\r/g, '\n')
        .replace(/\t/g, '    ')
        .replace(/\u00a0/g, ' ')
        .replace(/\u2424/g, '\n');

    return this.token(src, true);
};

/**
 * Lexing
 */

 Lexer.prototype.token = function(src, top) {
    var src = src.replace(/^ +$/gm, '')
        , next
        , loose
        , cap
        , bull
        , b
        , item
        , space
        , i
        , l;

    while (src) {
        // newline
        if (this.rules.newline && (cap = this.rules.newline.exec(src))) {
            src = src.substring(cap[0].length);
            if (cap[0].length > 1) {
                this.tokens.push({
                    type: 'space'
                });
            }
        }

        // code
        if (this.rules.code && (cap = this.rules.code.exec(src))) {
            src = src.substring(cap[0].length);
            cap = cap[0].replace(/^ {4}/gm, '');
            this.tokens.push({
                type: 'code',
                text: !this.options.pedantic
                ? cap.replace(/\n+$/, '')
                : cap
            });

            reportUsage('code');
            continue;
        }

        // fences (gfm)
        if (this.rules.fences && (cap = this.rules.fences.exec(src))) {
            src = src.substring(cap[0].length);
            this.tokens.push({
                type: 'code',
                lang: cap[2],
                text: cap[3]
            });
            continue;
        }

        // heading
        if (this.rules.heading && (cap = this.rules.heading.exec(src))) {
            src = src.substring(cap[0].length);
            this.tokens.push({
                type: 'heading',
                depth: cap[1].length,
                text: cap[2]
            });

            reportUsage('heading' + cap[1].length);
            continue;
        }

        // table no leading pipe (gfm)
        if (top && (this.rules.nptable && (cap = this.rules.nptable.exec(src)))) {
            src = src.substring(cap[0].length);

            item = {
                type: 'table',
                header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
                align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
                cells: cap[3].replace(/\n$/, '').split('\n')
            };

            for (i = 0; i < item.align.length; i++) {
                if (/^ *-+: *$/.test(item.align[i])) {
                    item.align[i] = 'right';
                } else if (/^ *:-+: *$/.test(item.align[i])) {
                    item.align[i] = 'center';
                } else if (/^ *:-+ *$/.test(item.align[i])) {
                    item.align[i] = 'left';
                } else {
                    item.align[i] = null;
                }
            }

            for (i = 0; i < item.cells.length; i++) {
                item.cells[i] = item.cells[i].split(/ *\| */);
            }

            this.tokens.push(item);

            reportUsage('table');
            continue;
        }

        // lheading
        if (this.rules.lheading && (cap = this.rules.lheading.exec(src))) {
            src = src.substring(cap[0].length);
            this.tokens.push({
                type: 'heading',
                depth: cap[2] === '=' ? 1 : 2,
                text: cap[1]
            });
            continue;
        }

        // hr
        if (this.rules.hr && (cap = this.rules.hr.exec(src))) {
            src = src.substring(cap[0].length);
            this.tokens.push({
                type: 'hr'
            });
            continue;
        }

        // blockquote
        if (this.rules.blockquote && (cap = this.rules.blockquote.exec(src))) {
            src = src.substring(cap[0].length);

            this.tokens.push({
                type: 'blockquote_start'
            });

            cap = cap[0].replace(/^ *> ?/gm, '');

            // Pass `top` to keep the current
            // "toplevel" state. This is exactly
            // how markdown.pl works.
            this.token(cap, top);

            this.tokens.push({
                type: 'blockquote_end'
            });

            reportUsage('quote');
            continue;
        }

        // list
        if (this.rules.list && (cap = this.rules.list.exec(src))) {
            src = src.substring(cap[0].length);
            bull = cap[2];

            this.tokens.push({
                type: 'list_start',
                ordered: bull.length > 1
            });

            // Get each top-level item.
            cap = cap[0].match(this.rules.item);

            next = false;
            l = cap.length;
            i = 0;

            for (; i < l; i++) {
                item = cap[i];

                // Remove the list item's bullet
                // so it is seen as the next token.
                space = item.length;
                item = item.replace(/^ *([*+-]|\d+\.) +/, '');

                // Outdent whatever the
                // list item contains. Hacky.
                if (~item.indexOf('\n ')) {
                    space -= item.length;
                    item = !this.options.pedantic
                    ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
                    : item.replace(/^ {1,4}/gm, '');
                }

                // Determine whether the next list item belongs here.
                // Backpedal if it does not belong in this list.
                if (this.options.smartLists && i !== l - 1) {
                    b = block.bullet.exec(cap[i + 1])[0];
                    if (bull !== b && !(bull.length > 1 && b.length > 1)) {
                        src = cap.slice(i + 1).join('\n') + src;
                        i = l - 1;
                    }
                }

                // Determine whether item is loose or not.
                // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
                // for discount behavior.
                loose = next || /\n\n(?!\s*$)/.test(item);
                if (i !== l - 1) {
                    next = item.charAt(item.length - 1) === '\n';
                    if (!loose) loose = next;
                }

                this.tokens.push({
                  type: loose
                  ? 'loose_item_start'
                  : 'list_item_start'
              });

                // Recurse.
                this.token(item, false);

                this.tokens.push({
                  type: 'list_item_end'
              });
            }

            this.tokens.push({
                type: 'list_end'
            });

            reportUsage('list');
            continue;
        }

        // html
        if (this.rules.html && (cap = this.rules.html.exec(src))) {
            src = src.substring(cap[0].length);
            this.tokens.push({
                type: this.options.sanitize ? 'paragraph' : 'html',
                pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
                text: cap[0]
            });

            reportUsage('html');
            if (cap[0].toLowerCase().includes('<img ')) {
                reportUsage('html_image');
            }
            if (cap[0].toLowerCase().includes('<a ')) {
                reportUsage('html_link');
            }
            continue;
        }

        // def
        if (top && (this.rules.def && (cap = this.rules.def.exec(src)))) {
            src = src.substring(cap[0].length);
            this.tokens.links[cap[1].toLowerCase()] = {
                href: cap[2],
                title: cap[3]
            };
            continue;
        }

        // table (gfm)
        if (top && (this.rules.table && (cap = this.rules.table.exec(src)))) {
            src = src.substring(cap[0].length);

            item = {
                type: 'table',
                header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
                align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
                cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
            };

            for (i = 0; i < item.align.length; i++) {
                if (/^ *-+: *$/.test(item.align[i])) {
                    item.align[i] = 'right';
                } else if (/^ *:-+: *$/.test(item.align[i])) {
                    item.align[i] = 'center';
                } else if (/^ *:-+ *$/.test(item.align[i])) {
                    item.align[i] = 'left';
                } else {
                    item.align[i] = null;
                }
            }

            for (i = 0; i < item.cells.length; i++) {
                item.cells[i] = item.cells[i]
                .replace(/^ *\| *| *\| *$/g, '')
                .split(/ *\| */);
            }

            this.tokens.push(item);

            reportUsage('table');
            continue;
        }

        // top-level paragraph
        if (top && (this.rules.paragraph && (cap = this.rules.paragraph.exec(src)))) {
            src = src.substring(cap[0].length);
            this.tokens.push({
                type: 'paragraph',
                text: cap[1].charAt(cap[1].length - 1) === '\n'
                ? cap[1].slice(0, -1)
                : cap[1]
            });
            continue;
        }

        // text
        if (this.rules.text && (cap = this.rules.text.exec(src))) {
            // Top-level should never reach here.
            src = src.substring(cap[0].length);
            this.tokens.push({
                type: 'text',
                text: cap[0]
            });
            continue;
        }

        if (src) {
            throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
        }
    }

    return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
    escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
    autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
    url: noop,
    tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
    link: /^!?\[(inside)\]\(href\)/,
    uploadLink: /^\[(inside)\]{(fileName)}\(href\)/,
    reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
    nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
    strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
    em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
    code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
    br: /^ {2,}\n(?!\s*$)/,
    del: noop,
    emoji: noop,
    anchor: noop,
    text: /^[\s\S]+?(?=[\\<!\[_*`$]| {2,}\n|$)/,
    mathInline: noop
};

inline._inside = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
inline._fileName = /(?:{[^}]*}|[^{}]|}(?=[^{]*}))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = replace(inline.link)
    ('inside', inline._inside)
    ('href', inline._href)
    ();

inline.uploadLink = replace(inline.uploadLink)
    ('inside', inline._inside)
    ('fileName', inline._fileName)
    ('href', inline._href)
    ();

inline.reflink = replace(inline.reflink)
    ('inside', inline._inside)
    ();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

const taggableTypes = new RegExp(TAGGABLE_TYPES.join('|'));
inline.dku = {
    autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
    article: /^\[\[([A-Za-z0-9._]+\.)?([^\.\/]+)\]\]/,
    emoji: /^:([A-Za-z0-9_\-\+]+?):/,
    anchor: /^\{=([^\}]+)\}/,
    mention: /^\@([a-zA-Z0-9@.+_-]{3,80})/,
    taggableObjectRef: /^(type):(id)/i,
    taggableObjectRefWithDisplayName: /^!?\[(inside)\]\((type):(id)\)/i,
    localTag: /^tag:([A-Za-z0-9:_]+)/,
    br: replace(inline.br)('{2,}', '*')(),
    mathInline: /^\$`([^`]*)`\$/
};

inline.dku.taggableObjectRef = replace(inline.dku.taggableObjectRef)
    ('type', taggableTypes)
    ('id', /[A-Za-z0-9._]+/) // too strict for notebooks, but since they allow any character they'll mess up the parsing anyway
    ();
inline.dku.taggableObjectRef = new RegExp(inline.dku.taggableObjectRef, 'i');

inline.dku.taggableObjectRefWithDisplayName = replace(inline.dku.taggableObjectRefWithDisplayName)
    ('inside', inline._inside)
    ('type', taggableTypes)
    ('id', /(\\.|[^)])+/) // since it can be a notebook name, anything goes. Except the ')' which marks the end of the construct
    ();
inline.dku.taggableObjectRefWithDisplayName = new RegExp(inline.dku.taggableObjectRefWithDisplayName, 'i');

inline.dku.article = new RegExp(inline.dku.article, 'i');

inline.dku.mathInline = new RegExp(inline.dku.mathInline, 'i');

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, inline.dku, {
    escape: replace(inline.escape)('])', '~|])')(),
    url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
    del: /^~~(?=\S)([\s\S]*?\S)~~/,

    text: replace(inline.text)
    (']|', ':~]|')
    ('|', '|https?://|')
    ('|', '|tag:|')
    ('|', '|dataset:|')
    ('|', '|@|')
    ()
});

inline.dku.text = inline.gfm.text;

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
    br: replace(inline.br)('{2,}', '*')(),
    text: replace(inline.gfm.text)('{2,}', '*')()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
    this.options = options || marked.defaults;
    this.links = links;
    this.rules = inline.normal;
    this.renderer = this.options.renderer || new Renderer;
    this.renderer.options = this.options;

    if (!this.links) {
        throw new Error('Tokens array requires a `links` property.');
    }

    if (this.options.gfm) {
        if (this.options.breaks) {
            this.rules = inline.breaks;
        } else {
            this.rules = inline.gfm;
        }
    } else if (this.options.pedantic) {
        this.rules = inline.pedantic;
    }
    if (this.options.noMarkdown) {
        this.rules = inline.dku;
    }

    this.emojiTemplate = getEmojiTemplate(options);
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
    var inline = new InlineLexer(links, options);
    return inline.output(src);
};

/**
 * Lexing/Compiling
 */
InlineLexer.prototype.getTarget = function() {
    return this.options.targetBlank ? ' target="_blank"'  : '';
}

InlineLexer.prototype.output = function(src) {
    var out = ''
        , link
        , text
        , href
        , cap
        , tagColor;

    while (src) {
        // escape
        if (this.rules.escape && (cap = this.rules.escape.exec(src))) {
            src = src.substring(cap[0].length);
            out += cap[1];
            continue;
        }

        // autolink
        if (this.rules.autolink && (cap = this.rules.autolink.exec(src))) {
            src = src.substring(cap[0].length);
            if (cap[2] === '@') {
                text = cap[1].charAt(6) === ':'
                    ? this.mangle(cap[1].substring(7))
                    : this.mangle(cap[1]);
                href = this.mangle('mailto:') + text;
            } else {
                text = escape(cap[1]);
                href = text;
            }
            out += this.renderer.link(href, null, text);
            continue;
        }

        // url (gfm)
        if (this.rules.url && (cap = this.rules.url.exec(src))) {
            src = src.substring(cap[0].length);
            text = escape(cap[1]);
            href = text;
            out += this.renderer.link(href, null, text);
            continue;
        }

        // tag
        if (this.rules.tag && (cap = this.rules.tag.exec(src))) {
            src = src.substring(cap[0].length);
            out += this.options.sanitize
                ? escape(cap[0])
                : cap[0];
            continue;
        }

        const baseProjectKey = this.options.projectKey || ActiveProjectKey.get();

        // local project tag (dku)
        if (this.rules.localTag && (cap = this.rules.localTag.exec(src))) {
            src = src.substring(cap[0].length);

            const tag = cap[1];
            const projectKey = baseProjectKey + '*';
            const query = `tag:${tag}%20projectKey:${projectKey}`;
            const href = '/catalog/search/q='+query;
            const color = $filter('tagToColor')(tag);
            const title = "Tag: "+tag;
            out += `<span class="tags"><a class="tag" href="${href}" style="background-color:${color}" ${this.getTarget()} title="${title}">${tag}</a></span>`;

            reportUsage('tag');
            continue;
        }

        // article (dku)
        if (this.rules.article && (cap = this.rules.article.exec(src))) {
            src = src.substring(cap[0].length);

            let pkey = cap[1] ? cap[1].slice(0, -1) : baseProjectKey;
            let id = cap[2];

            const taggableType = 'ARTICLE';
            const icon = $filter('typeToIcon')(taggableType);
            const color = $filter('typeToColor')(taggableType);
            const href = StateUtils.href.dssObject(taggableType, id, pkey, {moveToTargetProject: true});

            let title = "Article ";
            let idSafe = String(id).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            let linkText;
            if (pkey != baseProjectKey) {
                title += idSafe + " from project " + pkey;
                linkText = pkey + "." + idSafe;
            } else {
                title += idSafe;
                linkText = idSafe;
            }

            out += `<a href="${href}" title="${title}" ${this.getTarget()} style="text-decoration:none"><i class="inline-taggable-object-icon ${icon} ${color}" /> ${linkText}</a>`;

            reportUsage('ARTICLE_simple_syntax');
            continue;
        }

        // dku (has to be before link)
        if (this.rules.taggableObjectRefWithDisplayName && (cap = this.rules.taggableObjectRefWithDisplayName.exec(src))) {
            src = src.substring(cap[0].length);

            const displayName = sanitize(cap[1].replace(/\\(.)/g, '$1'));
            const taggableType = cap[2].toUpperCase();
            const smartId = cap[3].replace(/\\(.)/g, '$1');
            const href = StateUtils.href.dssObject(taggableType, smartId, baseProjectKey, {moveToTargetProject: true});
            const icon = $filter('typeToIcon')(taggableType);
            const color = $filter('typeToColor')(taggableType);
            let title = $filter('niceTaggableType')(taggableType)+': ';
            if (smartId.includes('.')) {
                const ref = SmartId.resolve(smartId, baseProjectKey);
                title += ref.id +" from project "+ref.projectKey;
            } else {
                title += smartId;
            }

            out += `<a href="${href}" title="${title}" ${this.getTarget()} style="text-decoration:none"><i class="inline-taggable-object-icon ${icon} ${color}" /> ${displayName}</a>`;

            reportUsage(taggableType);
            continue;
        }

        // link
        if (this.rules.link && (cap = this.rules.link.exec(src))) {
            src = src.substring(cap[0].length);
            out += this.outputLink(cap, {
                title: cap[1],
                href: cap[2]
            });

            //report usage done in outputLink
            continue;
        }

        // uploadLink
        if (this.rules.uploadLink && (cap = this.rules.uploadLink.exec(src))) {
            src = src.substring(cap[0].length);
            out += this.outputFileLink(cap[1], cap[2], cap[3]);

            //report usage done in outputLink
            continue;
        }

        // reflink, nolink
        if ((this.rules.reflink && (cap = this.rules.reflink.exec(src))) || (this.rules.nolink && (cap = this.rules.nolink.exec(src)))) {
            src = src.substring(cap[0].length);
            link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
            link = this.links[link.toLowerCase()];
            if (!link || !link.href) {
                out += cap[0].charAt(0);
                src = cap[0].substring(1) + src;
                continue;
            }
            out += this.outputLink(cap, link);

            //report usage done in outputLink
            continue;
        }

        // strong
        if (this.rules.strong && (cap = this.rules.strong.exec(src))) {
            src = src.substring(cap[0].length);
            out += this.renderer.strong(this.output(cap[2] || cap[1]));

            reportUsage('strong');
            continue;
        }

        // math inline
        if (this.options.math && this.rules.mathInline && (cap = this.rules.mathInline.exec(src))) {
            src = src.substring(cap[0].length);
            out += this.renderer.mathInline(cap[1] || "");
            reportUsage('mathInline');
            continue;
        }

        // em
        if (this.rules.em && (cap = this.rules.em.exec(src))) {
            src = src.substring(cap[0].length);
            out += this.renderer.em(this.output(cap[2] || cap[1]));

            reportUsage('em');
            continue;
        }

        // code
        if (this.rules.code && (cap = this.rules.code.exec(src))) {
            src = src.substring(cap[0].length);
            out += this.renderer.codespan(escape(cap[2], true));

            reportUsage('code');
            continue;
        }

        // br
        if (this.rules.br && (cap = this.rules.br.exec(src))) {
            src = src.substring(cap[0].length);
            out += this.renderer.br();
            continue;
        }

        // del (gfm)
        if (this.rules.del && (cap = this.rules.del.exec(src))) {
            src = src.substring(cap[0].length);
            out += this.renderer.del(this.output(cap[1]));
            continue;
        }

        // emoji (gfm)
        if (this.rules.emoji && (cap = this.rules.emoji.exec(src))) {
            src = src.substring(cap[0].length);
            out += this.emoji(cap[1]);

            reportUsage('emoji');
            continue;
        }

        // dku anchor
        if (this.rules.anchor && (cap = this.rules.anchor.exec(src))) {
            src = src.substring(cap[0].length);
            out += this.anchor(cap[1]);

            reportUsage('anchor');
            continue;
        }

        // dku
        if (this.rules.taggableObjectRef && (cap = this.rules.taggableObjectRef.exec(src))) {
            src = src.substring(cap[0].length);

            const taggableType = cap[1].toUpperCase();
            const smartId = cap[2];
            const href = StateUtils.href.dssObject(taggableType, smartId, baseProjectKey, {moveToTargetProject: true});
            const icon = $filter('typeToIcon')(taggableType);
            const color = $filter('typeToColor')(taggableType);
            let title = $filter('niceTaggableType')(taggableType)+': ';
            if (smartId.includes('.')) {
                const ref = SmartId.resolve(smartId, baseProjectKey);
                title += ref.id +" from project "+ref.projectKey;
            } else {
                title += smartId;
            }


            out += `<a href="${href}" title="${title}" ${this.getTarget()} style="text-decoration:none"><i class="inline-taggable-object-icon ${icon} ${color}" /> ${smartId}</a>`;

            reportUsage(taggableType);
            continue;
        }

        // dku
        if (this.rules.mention && (cap = this.rules.mention.exec(src))) {
            src = src.substring(cap[0].length);

            const login = cap[1];
            const title = "User: "+login;
            out += `<a href="/profile/${login}/" title="${title}">@${login}</a>`;

            reportUsage('userMention');
            continue;
        }

        // text
        if (this.rules.text && (cap = this.rules.text.exec(src))) {
            src = src.substring(cap[0].length);
            out += escape(this.smartypants(cap[0]));
            continue;
        }

        if (src) {
            throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
        }
    }

    return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
    let href = escape(link.href);
    const title = link.title ? escape(link.title) : null;

    if (cap[0].charAt(0) === '!') {
        reportUsage('image_md');
        return this.renderer.image(href, title, escape(cap[1]));
    } else if (href.includes('/') || (href.match(/(\.)/g) || []).length > 1) {
        reportUsage('link_md');
        return this.renderer.link(href, title, this.output(cap[1]));
    } else if (href.startsWith('#')) {
        reportUsage('anchor_md');
        return this.renderer.link(location.pathname + href, title, this.output(cap[1]));
    } else {
        // Links without `/` and less than two `.` should reference smartIds
         return this.outputFileLink(title, title, href);
    }
};

InlineLexer.prototype.outputFileLink = function (displayName, fileName, href) {
    href = getUploadURL(fileName, href, this.options.projectKey);
    displayName = String(displayName).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    reportUsage('link_to_uploaded_file');
    return `<a href="${href}" title="Click to download" style="text-decoration:none" target="_blank"><i class="icon-download"></i> ${displayName}</a> `;
};

/**
 * Emoji Transformations
 */

function emojiDefaultTemplate(emoji) {
    return '<img src="'
    + '/graphics/emojis/'
    + encodeURIComponent(emoji)
    + '.png"'
    + ' alt=":'
    + escape(emoji)
    + ':"'
    + ' title=":'
    + escape(emoji)
    + ':"'
    + ' class="emoji" align="absmiddle" height="20" width="20">';
}

function getEmojiTemplate(options) {
    if (options.emoji) {
        if (typeof options.emoji === 'function') {
            return options.emoji;
        }
        if (typeof options.emoji === 'string') {
            var emojiSplit = options.emoji.split(/\{emoji\}/g);
            return emoji => emojiSplit.join(emoji);
        }
    }
    return emojiDefaultTemplate;
}

InlineLexer.prototype.emojiTemplate = emojiDefaultTemplate;
InlineLexer.prototype.emoji = function (name) {
    if (!this.options.emoji) {
        return ':' + name + ':';
    }
    return this.emojiTemplate(name);
};
InlineLexer.prototype.anchor = function(name) {
    const anchorName = name.toLowerCase().replace(/[^\w]+/g, '-');
    return '<span class="dku-normal-anchor">'
        + '<a name="'
        + anchorName
        + '"></a>'
        + name
        + Renderer.prototype.link.call(this, location.pathname + '#' + anchorName, anchorName, '<i class="icon-link"></i>')
        + '</span>';
};
InlineLexer.prototype.mention = function (name) {
    return '@' + name;
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
    if (!this.options.smartypants) return text;
    return text
        // em-dashes
        .replace(/--/g, '\u2014')
        // opening singles
        .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
        // closing singles & apostrophes
        .replace(/'/g, '\u2019')
        // opening doubles
        .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
        // closing doubles
        .replace(/"/g, '\u201d')
        // ellipses
        .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
    var out = ''
        , l = text.length
        , i = 0
        , ch;

    for (; i < l; i++) {
        ch = text.charCodeAt(i);
        if (Math.random() > 0.5) {
            ch = 'x' + ch.toString(16);
        }
        out += '&#' + ch + ';';
    }

    return out;
};

/**
 * Renderer
 */

function Renderer(options) {
    this.options = options || {};
}

Renderer.prototype.code = function(code, lang, escaped) {
    if (this.options.highlight) {
        const out = this.options.highlight(code, lang);
        if (out != null && out !== code) {
            escaped = true;
            code = out;
        }
    }

    if (!lang) {
        return '<pre><code>'
            + (escaped ? code : escape(code, true))
            + '</code></pre>';
    }

    if (lang === 'math') {
        return '\n<p class="dss-mathjax-block">$math-block\n'
            + code
            + '\n$math-block</p>\n'
    }

    return '<pre><code class="'
        + this.options.langPrefix
        + escape(lang, true)
        + '">'
        + (escaped ? code : escape(code, true))
        + '\n</code></pre>\n';
};

/**
 * Mathjax renderers just prepare the formulae for subsequent processing by MathJax
 * The pre-processing of the $math tags is necessary to prevent the symbols in LaTex formulae being
 * processed by markdown
 */
Renderer.prototype.mathInline = function(formula) {
    return '<span class="dss-mathjax-inline">$math-inline ' + formula + ' $math-inline</span>';
};

Renderer.prototype.blockquote = function(quote) {
    return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
    return html;
};

Renderer.prototype.heading = function(text, level, raw) {
    const baseAnchorName = raw.toLowerCase().replace(/[^\w]+/g, '-');
    if (!this.anchorMap.hasOwnProperty(baseAnchorName)) {
        this.anchorMap[baseAnchorName] = 1;
    } else {
        this.anchorMap[baseAnchorName]++;
    }
    const anchorName = baseAnchorName + '-' + this.anchorMap[baseAnchorName];
    return '<h'
        + level
        + ' id="'
        + this.options.headerPrefix
        + anchorName
        + '" class="dku-header-anchor"><a name="'
        + anchorName
        + '"></a>'
        + text
        + ((this.options.enableAnchors) ? Renderer.prototype.link.call(this, location.pathname + '#' + anchorName, anchorName, '<i class="icon-link"></i>') : '')
        + '</h'
        + level
        + '>\n';
};

Renderer.prototype.hr = function() {
    return '<hr style="break-after:page">\n';
};

Renderer.prototype.list = function(body, ordered) {
        var type = ordered ? 'ol' : 'ul';
        return '<' + type + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
    return '<li>' + text + '</li>\n';
};

Renderer.prototype.paragraph = function(text) {
    return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
    return '<table>\n'
        + '<thead>\n'
        + header
        + '</thead>\n'
        + '<tbody>\n'
        + body
        + '</tbody>\n'
        + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
    return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
    var type = flags.header ? 'th' : 'td';
    var tag = flags.align
        ? '<' + type + ' style="text-align:' + flags.align + '">'
        : '<' + type + '>';
    return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
    return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
    return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
    return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
    return '<br>';
};

Renderer.prototype.del = function(text) {
    return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
    if (this.options.sanitize) {
        try {
            var prot = decodeURIComponent(unescape(href))
                .replace(/[^\w:]/g, '')
                .toLowerCase();
        } catch (e) {
            return '';
        }
        if (prot.indexOf('javascript:') === 0) {
            return '';
        }
    }
    var out = '<a href="' + href + '"';
    if (title) {
        out += ' title="' + title + '"';
    }
    if (this.options.targetBlank) {
        out += ' target="_blank"';
    } else {
        // otherwise we force the target to _self in order force-scroll to the same anchor when already in URL
        // if url is ...#anchor1 and ...#anchor1 link is click, it will only scroll to the anchor if target is _self
        out += ' target="_self"';
    }
    out += '>' + text + '</a>';
    return out;
};

function getUploadURL(filename, uploadId, contextProject) {
    try {
        const ref = SmartId.resolve(uploadId, contextProject);
        let sanitizedFilename = filename.replace(/(((\.)+)?\/)/g, "_"); // remove all slashes and dots located before slashes
        return `/dip/api/projects/wikis/get-uploaded-file/${sanitizedFilename}?projectKey=${ref.projectKey}&uploadId=${ref.id}`;
    } catch (e) {
        console.error('Failed to resolve uploadId'); // NOSONAR: OK to use console.
        return '';
    }
}

Renderer.prototype.image = function(href, title, text) {
    if (href && !href.includes('/')) { // only an attachment id will not contain a slash
        href = getUploadURL(text, href, this.options.projectKey);
    }
    var out = '<img src="' + href + '" alt="' + text + '"';
    if (title) {
        out += ' title="' + title + '"';
    }
    out += '>';
    return out;
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
    this.anchorMap = {};
    this.tokens = [];
    this.token = null;
    this.options = options || marked.defaults;
    this.options.renderer = this.options.renderer || new Renderer;
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.renderer.anchorMap = this.anchorMap;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options, renderer) {
    var parser = new Parser(options, renderer);
    return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
    this.inline = new InlineLexer(src.links, this.options, this.renderer);
    this.tokens = src.reverse();

    var out = '';
    while (this.next()) {
        out += this.tok();
    }

    return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
    return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
    return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
    var body = this.token.text;

    while (this.peek().type === 'text') {
        body += '\n' + this.next().text;
    }

    return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
    switch (this.token.type) {
        case 'space': {
            return '';
        }
        case 'hr': {
            return this.renderer.hr();
        }
        case 'heading': {
            return this.renderer.heading(
              this.inline.output(this.token.text),
              this.token.depth,
              this.token.text);
        }
        case 'code': {
            return this.renderer.code(this.token.text,
              this.token.lang,
              this.token.escaped);
        }

        case 'table': {
            var header = ''
                , body = ''
                , i
                , row
                , cell
                , flags
                , j;

            // header
            cell = '';
            for (i = 0; i < this.token.header.length; i++) {
                flags = { header: true, align: this.token.align[i] };
                cell += this.renderer.tablecell(
                    this.inline.output(this.token.header[i]),
                    {header: true, align: this.token.align[i]}
                    );
            }
            header += this.renderer.tablerow(cell);

            for (i = 0; i < this.token.cells.length; i++) {
                row = this.token.cells[i];

                cell = '';
                for (j = 0; j < row.length; j++) {
                    cell += this.renderer.tablecell(
                        this.inline.output(row[j]),
                        { header: false, align: this.token.align[j] }
                    );
                }

                body += this.renderer.tablerow(cell);
            }
            return this.renderer.table(header, body);
        }
        case 'blockquote_start': {
            var body = '';

            while (this.next().type !== 'blockquote_end') {
                body += this.tok();
            }

            return this.renderer.blockquote(body);
        }
        case 'list_start': {
            var body = ''
            , ordered = this.token.ordered;

            while (this.next().type !== 'list_end') {
                  body += this.tok();
            }

            return this.renderer.list(body, ordered);
        }
        case 'list_item_start': {
            var body = '';

            while (this.next().type !== 'list_item_end') {
                body += this.token.type === 'text'
                    ? this.parseText()
                    : this.tok();
            }

            return this.renderer.listitem(body);
        }
        case 'loose_item_start': {
            var body = '';

            while (this.next().type !== 'list_item_end') {
                body += this.tok();
            }

            return this.renderer.listitem(body);
        }
        case 'html': {
            var html = !this.token.pre && !this.options.pedantic
                ? this.inline.output(this.token.text)
                : this.token.text;
            return this.renderer.html(html);
        }
        case 'paragraph': {
            return this.renderer.paragraph(this.inline.output(this.token.text));
        }
        case 'text': {
            return this.renderer.paragraph(this.parseText());
        }
    }
};

/**
 * Helpers
 */

 function escape(html, encode) {
    return html
        .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

function unescape(html) {
    return html.replace(/&([#\w]+);/g, function(_, n) {
        n = n.toLowerCase();
        if (n === 'colon') return ':';
        if (n.charAt(0) === '#') {
            return n.charAt(1) === 'x'
                ? String.fromCharCode(parseInt(n.substring(2), 16))
                : String.fromCharCode(+n.substring(1));
        }
        return '';
    });
}

function replace(regex, opt) {
    regex = regex.source;
    opt = opt || '';
    return function self(name, val) {
        if (!name) return new RegExp(regex, opt);
        val = val.source || val;
        val = val.replace(/(^|[^\[])\^/g, '$1');
        regex = regex.replace(name, val);
        return self;
    };
}

function noop() {}
noop.exec = noop;

function merge(obj) {
    var i = 1
    , target
    , key;

    for (; i < arguments.length; i++) {
        target = arguments[i];
        for (key in target) {
            if (Object.prototype.hasOwnProperty.call(target, key)) {
                obj[key] = target[key];
            }
        }
    }

    return obj;
}


/**
 * Marked
 */
function marked(src, opt, callback) {
    if (callback || typeof opt === 'function') {
        if (!callback) {
            callback = opt;
            opt = null;
        }

        opt = merge({}, marked.defaults, opt || {});

        var highlight = opt.highlight
            , tokens
            , pending
            , i = 0;

        try {
            tokens = Lexer.lex(src, opt);
        } catch (e) {
            return callback(e);
        }
        pending = tokens.length;

        var done = function() {
            var out, err;

            try {
                out = Parser.parse(tokens, opt);
            } catch (e) {
                err = e;
            }

            opt.highlight = highlight;

            return err
                ? callback(err)
                : callback(dkuLastMarkdownUsageReport, out);
        };


        if (!highlight || highlight.length < 3) {
            return done();
        }

        delete opt.highlight;

        if (!pending) return done();

        for (; i < tokens.length; i++) {
            (function(token) {
                if (token.type !== 'code') {
                    return --pending || done();
                }
                return highlight(token.text, token.lang, function(err, code) {
                    if (code == null || code === token.text) {
                        return --pending || done();
                    }
                    token.text = code;
                    token.escaped = true;
                    --pending || done();
                });
            })(tokens[i]);
        }
        return;
    }
    try {
        if (opt) opt = merge({}, marked.defaults, opt);
        return Parser.parse(Lexer.lex(src, opt), opt);
    } catch (e) {
        if ((opt || marked.defaults).silent) {
            return '<p>An error occurred:</p><pre>'
                + escape(e.message + '', true)
                + '</pre>';
        }
        throw e;
    }
}

/**
 * Options
 */

 marked.options =
 marked.setOptions = function(opt) {
    merge(marked.defaults, opt);
    return marked;
};

marked.defaults = {
    gfm: true,
    emoji: false,
    tables: true,
    breaks: false,
    pedantic: false,
    sanitize: false,
    smartLists: false,
    silent: false,
    highlight: null,
    langPrefix: 'lang-',
    smartypants: false,
    headerPrefix: '',
    enableAnchors: false,
    renderer: new Renderer,
    $scope : null,
    math: true
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

window.marked = marked;

});


app.service('MarkedSettingService', function(CachedAPICalls) {
    let emojisTable;
    CachedAPICalls.emojisTable.then(function(data) {
        emojisTable = data;
    });
    this.get = function(scope, attrs) {
        return {
            $scope: scope,
            emoji: function (emoji) {
                return emoji in emojisTable ? emojisTable[emoji] : (':'+emoji+':');
            },
            noMarkdown: !!attrs.noMarkdown,
            targetBlank: scope.$eval(attrs.targetBlank),
            pedantic: true,
            projectKey: attrs.projectKey,
            math: !attrs.noMath,
            enableAnchors: scope.$eval(attrs.enableAnchors)
        }
    };
});

app.service('MathJaxService', function($timeout, $stateParams, LoggerProvider) {
    const svc = this;
    svc.isLoaded = false;

    function ensureScriptsLoaded() {
        if (svc.isLoaded) {
            return;
        }
        svc.isLoaded = true;

        let script = document.createElement("script");
        script.type = "text/javascript";
        script.src = "bower_components/mathjax/es5/tex-chtml.js";

        window.MathJax = {
            tex: {
                inlineMath: [['$math-inline', '$math-inline']],
                displayMath: [['$math-block', '$math-block']]
            },
            options: {
                renderActions: {
                    addMenu: [0, '', '']
                }
            },
            startup: {}
        };

        document.getElementsByTagName("head")[0].appendChild(script);

    }

    svc.typesetElement = function(element, htmlTxt) {
        if (htmlTxt.indexOf("$math-") === -1) {
            return;
        }
        ensureScriptsLoaded();

        if (MathJax.startup.promise) {
            MathJax.startup.promise = MathJax.startup.promise
                .then(() => {
                    return MathJax.typesetPromise(element)
                })
                .catch((err) => {
                    Logger.error('MathJax typeset failed',  err)
                });
        }
    }
});


app.directive('fromMarkdown', function($dkuSanitize, CachedAPICalls, MarkedSettingService, MathJaxService) {
    return {
        restrict: 'A',
        link: function (scope, element, attrs) {
            scope.$watch(attrs.fromMarkdown, function (newVal) {
                CachedAPICalls.emojisTable.then(function(emojisTable) {
                    let htmlified = "";
                    marked.setOptions(MarkedSettingService.get(scope, attrs));
                    if (newVal) {
                        if (attrs.wordsLimit) {
                            let words = newVal.split(' ');
                            if (words.length > attrs.wordsLimit) {
                                newVal= words.slice(0, attrs.wordsLimit).join(' ');
                                newVal += '...'; 
                            }
                        }
                        htmlified = marked(newVal, {projectKey: attrs.projectKey});
                        element.html(newVal ? $dkuSanitize(htmlified) : '');
                    } else if (attrs.ifEmpty) {
                        element.html($("<span class=\"empty\" />").html(attrs.ifEmpty));
                    } else {
                        element.html("");
                    }
                    if (attrs.mdCallback) {
                        const callback = scope.$eval(attrs.mdCallback);
                        if (typeof callback == 'function') {
                            callback();
                        }
                    }

                    if (marked.defaults.math){
                        MathJaxService.typesetElement(element, htmlified)
                    }
                });
            });
        }
    };
});


app.directive('autocompletableTextarea', function(DataikuAPI, $timeout, $rootScope, $stateParams, $compile, CachedAPICalls, TAGGABLE_TYPES, Debounce, SmartId, CreateModalFromTemplate) {
    return {
        scope: false,
        link: {
            pre: function($scope, element, attrs) {
                let cm = null;
                $scope.uiState = $scope.uiState || {};
                $scope.uiState.users = null;
                $scope.uiState.emojis = null;

                const MAX_HINT_LENGTH = 100;

                CachedAPICalls.emojisTable.then(function(data) {
                    $scope.uiState.emojis = data;
                });
                DataikuAPI.security.listUsers($stateParams.projectKey).noSpinner()
                .success(function(data) {
                    $scope.uiState.users = data;
                })
                .error(setErrorInScope.bind($scope));

                function getEmojiHint(editor, emojis, curToken, cursor) {
                    const emojiStartPos = curToken.string.lastIndexOf(':');
                    const susbstr = curToken.string.substring(emojiStartPos);
                    let completions = [];
                    angular.forEach(emojis, function(code, name) {
                        const emoji = ':'+name+': ';
                        if (emoji.includes(susbstr) && emoji.length > susbstr.length) {
                            completions.push({code, name, emoji});
                        }
                    });
                    completions.splice(MAX_HINT_LENGTH);
                    completions = completions.map(function(emoji) {
                        return {text:(emoji.emoji + ' '), className:'emoji-dropdown-option', render:function(elt, data, cur) {
                            const div = document.createElement("div");
                            const span1 = document.createElement("span");
                            span1.className = "emoji";
                            span1.textContent = String.fromCodePoint(parseInt(emoji.code.replace("&#x", "").replace(";", ""), 16));
                            const span2 = document.createElement("span");
                            span2.className = "display-name";
                            span2.textContent = emoji.emoji;
                            div.appendChild(span1);
                            div.appendChild(span2);
                            elt.append(div);
                        }};
                    });
                    return {
                        list: completions,
                        from: {
                            line: cursor.line,
                            ch: curToken.start + emojiStartPos
                        },
                        to: {
                            line: cursor.line,
                            ch: curToken.end
                        }
                    };
                }

                function getMentionHint(editor, users, curToken, cursor) {
                    const mentionStartPos = curToken.string.lastIndexOf('@');
                    const mentionStart = curToken.string.substring(mentionStartPos).toLowerCase();
                    let completions = users.filter(function(user) {
                        const mentionLogin = '@' + user.login.toLowerCase();
                        const mentionName = '@' + user.displayName.toLowerCase();
                        return (mentionLogin.startsWith(mentionStart) && mentionLogin.length > mentionStart.length) ||
                        (mentionName.startsWith(mentionStart) && mentionName.length > mentionStart.length);
                    });
                    completions.splice(MAX_HINT_LENGTH);
                    completions = completions.map(function(user) {
                        return {text:'@'+user.login+' ', className:'mention-dropdown-option', render:function(elt, data, cur) {
                            const newScope = $scope.$new();
                            user.mentionLogin = '@' + user.login;
                            newScope.user = user;
                            const subElt = $compile('<div><span class="avatar20" user-picture="user.login" size="20" ></span><span class="display-name" ng-bind="user.displayName"></span><span class="mention" ng-bind="user.mentionLogin"></span></div>')(newScope);
                            subElt.appendTo(elt);
                        }};
                    });

                    return {
                        list: completions,
                        from: {
                            line: cursor.line,
                            ch: curToken.start + mentionStartPos
                        },
                        to: {
                            line: cursor.line,
                            ch: curToken.end
                        }
                    };
                }

                function shouldShowMentionHint(curToken) {
                    if (!$scope.uiState.users) return;
                    return curToken.string && curToken.string.startsWith('@');
                }

                function shouldShowTaggableObjectHint(curToken) {
                    for (const type of TAGGABLE_TYPES) {
                        if (curToken.string && curToken.string.toLowerCase().includes(type.toLowerCase()+':')) {
                            return true;
                        }
                    }
                    return false;
                }

                function shouldShowEmojiHint(curToken) {
                    if (!$scope.uiState.emojis) return;
                    return curToken.string && curToken.string.startsWith(':');
                }

                function anyHint(editor, options) {
                    const cursor = editor.getCursor();
                    const curToken = editor.getTokenAt(cursor);

                    if (shouldShowMentionHint(curToken)) {
                        return getMentionHint(editor, $scope.uiState.users, curToken, cursor);
                    } else if (shouldShowTaggableObjectHint(curToken)) {
                    // no autocomplete for taggable objects for now
                } else if (shouldShowEmojiHint(curToken)) {
                    return getEmojiHint(editor, $scope.uiState.emojis, curToken, cursor);
                }
                return {
                    list: [],
                    from: {
                        line: cursor.line,
                        ch: curToken.start
                    },
                    to: {
                        line: cursor.line,
                        ch: curToken.end
                    }
                };
            }

            function openAutoComplete() {
                if ($('.CodeMirror-hints').size() > 0) {
                        return; // menu already shown
                    }
                    CodeMirror.showHint(cm, anyHint, {completeSingle: false, completeOnSingleClick: true});
                }

                function setupAutocompletion(editor) {
                    cm = editor;
                    if ($scope.$eval(attrs.resizable) != false) {
                        const x = $(cm.getWrapperElement());
                        x.resizable({maxWidth : x.innerWidth()});
                        // TODO @markdown change maxWidth when the window is resized
                    }

                    // plug in autocompletion
                    cm.on('keyup', function(editor, event) {
                        const cursor = editor.getCursor();
                        const curToken = editor.getTokenAt(cursor);
                        if (curToken.string && (curToken.string == '@' || curToken.string == ':')) {
                            openAutoComplete(); // will load users if needed
                        }
                    });
                }

                function setupEditorActions(editor) {
                    cm = editor;
                    let editInCodeMirror = function(editionFn) {
                        if (editionFn) {
                            editionFn(editor);
                            editor.focus();
                        }
                    };
                    $scope.editorActions = {};
                    editor.editorActions = $scope.editorActions;
                    $scope.editorActions.replaceInEditor = function(fn, insertInside=false, method='around') {
                        const prevString = editor.getSelection();
                        const prevSelection = editor.getCursor();
                        const remplacement = fn(prevString);
                        editor.replaceSelection(remplacement, method);
                        if (insertInside && !prevString.length) {
                            prevSelection.ch += remplacement.length / 2;
                            editor.setCursor(prevSelection);
                        }
                        editor.focus();
                    };
                    $scope.editorActions.handleInEditor = function(fn) {
                        fn(editor);
                        editor.focus();
                    };
                    // the item is is based on an attachment item (smartID based + details enriched object)
                    $scope.editorActions.insertReference = function(item, insertInside=false, method='around') {
                        $scope.editorActions.replaceInEditor(function(prevString, useFullId = false) {
                            const tt = item.taggableType.toLowerCase();
                            const obj = SmartId.resolve(item.smartId, $stateParams.projectKey);
                            let label = (tt != 'project' && obj.projectKey != $stateParams.projectKey) ? (obj.projectKey + '.') : '';
                            label += (item.details && item.details.objectDisplayName) || obj.id;
                            return `[${prevString || label.replace(/\]/g, '\\]').replace(/\[/g, '\\[')}](${tt}:${item.smartId.replace(/\)/g, '\\)')})`;
                        }, insertInside, method);
                    };
                    $scope.editorActions.bold = function() {
                        $scope.editorActions.replaceInEditor(function(prevString) {
                            const alreadyMode1 = prevString.slice(0, 2) === '**' && prevString.slice(-2) === '**';
                            const alreadyMode2 = prevString.slice(0, 3) === ' **' && prevString.slice(-3) === '** ';
                            if (alreadyMode2) {
                                return prevString.slice(3, -3);
                            } else if (alreadyMode1) {
                                return prevString.slice(2, -2);
                            } else {
                                return ' **' + prevString + '** ';
                            }
                        }, true);
                    };
                    $scope.editorActions.italic = function() {
                        $scope.editorActions.replaceInEditor(function(prevString) {
                            const alreadyMode1 = prevString.slice(0, 1) === '_' && prevString.slice(-1) === '_';
                            const alreadyMode2 = prevString.slice(0, 2) === ' _' && prevString.slice(-2) === '_ ';
                            if (alreadyMode2) {
                                return prevString.slice(2, -2);
                            } else if (alreadyMode1) {
                                return prevString.slice(1, -1);
                            } else {
                                return ' _' + prevString + '_ ';
                            }
                        }, true);
                    };
                    $scope.editorActions.headline = function() {
                        $scope.editorActions.handleInEditor(cm => {
                            const doc = cm.getDoc();
                            const cursorStart = doc.getCursor(true);
                            const cursorEnd = doc.getCursor(false);
                            for (let lineNb = cursorStart.line; lineNb <= cursorEnd.line; lineNb++) {
                                const line = doc.getLine(lineNb);
                                const pos = {
                                    line: lineNb,
                                    ch: 0
                                };
                                doc.replaceRange('#' + (line.match(/^#+ /) ? '' : ' '), pos);
                            }
                        });
                    };
                    $scope.editorActions.quote = function() {
                        $scope.editorActions.handleInEditor(cm => {
                            const doc = cm.getDoc();
                            const cursorStart = doc.getCursor(true);
                            const cursorEnd = doc.getCursor(false);
                            for (let lineNb = cursorStart.line; lineNb <= cursorEnd.line; lineNb++) {
                                const pos = {
                                    line: lineNb,
                                    ch: 0
                                };
                                doc.replaceRange('> ', pos);
                            }
                        });
                    };
                    $scope.editorActions.code = function() {
                        $scope.editorActions.replaceInEditor(function(prevString) {
                            const already = prevString.slice(0, 3) === '```' && prevString.slice(-3) === '```';
                            return already ? prevString.slice(3, -3) : '```' + prevString + '```';
                        }, true);
                    };
                    $scope.editorActions.list = function() {
                        $scope.editorActions.handleInEditor(cm => {
                            const doc = cm.getDoc();
                            const cursorStart = doc.getCursor(true);
                            const cursorEnd = doc.getCursor(false);
                            for (let lineNb = cursorStart.line; lineNb <= cursorEnd.line; lineNb++) {
                                const line = doc.getLine(lineNb);
                                const pos = {
                                    line: lineNb,
                                    ch: line.search(/\S|$/)
                                };
                                doc.replaceRange(' - ', pos);
                            }
                        });
                    };
                    $scope.editorActions.listOl = function() {
                        $scope.editorActions.handleInEditor(cm => {
                            const doc = cm.getDoc();
                            const cursorStart = doc.getCursor(true);
                            const cursorEnd = doc.getCursor(false);
                            for (let lineNb = cursorStart.line; lineNb <= cursorEnd.line; lineNb++) {
                                const line = doc.getLine(lineNb);
                                const pos = {
                                    line: lineNb,
                                    ch: line.search(/\S|$/)
                                };
                                doc.replaceRange(' ' + (1 + lineNb - cursorStart.line) + '. ', pos);
                            }
                        });
                    };
                    $scope.editorActions.linkOrPicture = function(isPicture) {
                        CreateModalFromTemplate("/templates/markdown/add-editor-link-picture-modal.html", angular.extend($scope, {isPicture: isPicture, cm: editor}));
                    };
                    $scope.editorActions.dssObject = function() {
                        CreateModalFromTemplate("/templates/markdown/add-editor-dss-object-modal.html", angular.extend($scope, {cm: editor}));
                    };
                }

                function setupTooltipToolbar(editor) {
                    cm = editor;
                    const template = '<div class="dku-codemirror-tooltip-toolbar" include-no-scope="/templates/markdown/autocompletable-textarea-toolbar.html"></div>';
                    const toolbarNode = $compile(template)(angular.extend($scope, {tooltipsOnSide: true})).get(0);
                    const debounceFn = Debounce().withScope($scope).withDelay(100, 100).wrap((headRange) => editor.addWidget(headRange, toolbarNode, false));
                    editor.on('beforeSelectionChange', function(editor, evt) {
                        if (toolbarNode && toolbarNode.parentNode) {
                            toolbarNode.parentNode.removeChild(toolbarNode);
                        }
                        if (!evt.ranges.length) {
                            return;
                        }
                        const range = evt.ranges[0];
                        if (range.empty()) {
                            return;
                        }
                        // compute the difference between the cursor position and the right and bottom border, to apply a negative margin on the toolbar to make it always appears
                        const editorWidth = cm.getWrapperElement().offsetWidth;
                        const editorHeight = cm.getWrapperElement().offsetHeight;
                        const toolbarWidth = 300;
                        const toolbarHeight = 26;
                        const localCoords = editor.cursorCoords(range.head, 'local');
                        // compute nagative left margin to prevent overflow at the right side of the editor
                        toolbarNode.style['margin-left'] = '-' + Math.max(0, localCoords.left - (editorWidth - toolbarWidth)) + 'px';
                        // put the toolbar above the cursor when it overflows at the bottom side of the editor and there is space on top of the cursor
                        toolbarNode.style['margin-top'] = (localCoords.top + editor.defaultTextHeight() >= (editorHeight - toolbarHeight) && localCoords.top > toolbarHeight) ? '-42px' : '0';
                        // resize the editor height if the toolbar overflows at the bottom of the editor and there is no space on the top of the cursor
                        if (localCoords.top + editor.defaultTextHeight() >= (editorHeight - toolbarHeight) && localCoords.top <= toolbarHeight) {
                            cm.setSize(editorWidth, editorHeight + toolbarHeight);
                        }
                        debounceFn(range.head);
                    });
                }

                $scope.clearTextarea = function() {
                    $timeout(function() {cm.setValue('');}); // otherwise ugly things with codemirror and angular's digest happen
                };

                $scope.editorOptions = {
                    mode: attrs.noMarkdown ? 'text' : 'text/x-markdown',
                    indentUnit: 2,
                    lineNumbers : false,
                    lineWrapping : true,
                    foldGutter : false,
                    matchBrackets: true,
                    height: 'dynamic',
                    minHeight: '100px',
                    autofocus: true,
                    onLoad: function(editor) {
                        cm = editor;
                        setupAutocompletion(editor);
                        setupEditorActions(editor);
                        if (!attrs.hasOwnProperty('noTooltipToolbar')) {
                            setupTooltipToolbar(editor);
                        }
                    },
                    extraKeys: { // note : no need for ctrl/meta-enter handling here, it's done with a ui-keydown in the template
                    "Tab": "indentMore",
                    "Shift-Tab": "indentLess",
                    "Ctrl-Space": openAutoComplete
                }
            };
            if (attrs.options) {
                angular.extend($scope.editorOptions, $scope.$eval(attrs.options));
            }
        }
    }
};
});

app.controller('AddEditorLinkPictureModalController', function($scope) {
    if (!$scope.cm) {
        throw new Error('CodeMirror object is not in scope');
    }
    const s = $scope.cm.getSelection();
    const isUrl = s.match(/^[a-zA-Z]+:\/\//);
    $scope.new = {
        label: isUrl ? '' : s,
        url: isUrl ? s : ''
    };

    $scope.add = function() {
        $scope.editorActions.replaceInEditor(function(prevString) {
            return ($scope.isPicture ? '!' : '') + '[' + $scope.new.label.replace(/(\[|\])/g, '\\$1').replace() + '](' + $scope.new.url + ')';
        });
        $scope.resolveModal();
    };
});


app.controller('AddEditorDSSObjectModalController', function($scope, $stateParams, DataikuAPI, TAGGABLE_TYPES, SmartId) {
    if (!$scope.cm) {
        throw new Error('CodeMirror object is not in scope');
    }
    $scope.taggableTypes = TAGGABLE_TYPES;

    $scope.newReference = {
        projectKey: $stateParams.projectKey
    };

    $scope.uiState = {
        selectedObject: {},
        selectedProject: {}
    };

    $scope.$watch('newReference.projectKey', function(nv) {
        if (!nv) return;
        DataikuAPI.taggableObjects.listAccessibleObjects(nv).then(function(resp) {
            const objList = resp.data;
            $scope.taggableTypesWithNoItems = TAGGABLE_TYPES.filter(t => t != 'PROJECT' && !objList.find(obj => obj.type == t));
        });
    });

    $scope.addReference = function() {
        $scope.editorActions.replaceInEditor(function(prevString) {
            const tt = $scope.newReference.taggableType.toLowerCase();
            if (tt == 'project') {
                $scope.newReference.id = $scope.newReference.projectKey;
            }
            const objSmartId = SmartId.fromTor($scope.newReference);
            let label = (tt != 'project' && $scope.newReference.projectKey != $stateParams.projectKey) ? ($scope.newReference.projectKey + '.') : '';
            label += (tt == 'project' ? $scope.uiState.selectedProject.name : $scope.uiState.selectedObject.label) || $scope.newReference.id;
            return `[${prevString || label.replace(/\]/g, '\\]').replace(/\[/g, '\\[')}](${tt}:${objSmartId.replace(/\)/g, '\\)')})`;
        });
        $scope.resolveModal();
    };
});

})();

/*!
 * bootstrap-select v1.5.4
 * http://silviomoreto.github.io/bootstrap-select/
 *
 * Copyright 2013 bootstrap-select
 * Licensed under the MIT license
 */

!function($) {

    'use strict';

    $.expr[':'].icontains = function(obj, index, meta) {
        return $(obj).text().toUpperCase().indexOf(meta[3].toUpperCase()) >= 0;
    };

    var liHeightCached,
        headerHeightCached,
        searchHeightCached,
        actionsHeightCached,
        selectClone,
        menuClone;

    var Selectpicker = function(element, options, e) {
        if (e) {
            e.stopPropagation();
            e.preventDefault();
        }
        this.$element = $(element);
        this.$newElement = null;
        this.$button = null;
        this.$menu = null;
        this.$lis = null;
        this.deregistrations = null;

        //Merge defaults, options and data-attributes to make our options
        this.options = $.extend({}, $.fn.selectpicker.defaults, this.$element.data(), typeof options == 'object' && options);

        //If we have no title yet, check the attribute 'title' (this is missed by jq as its not a data-attribute
        if (this.options.title === null) {
            this.options.title = this.$element.attr('title');
        }

        //Expose public methods
        this.val = Selectpicker.prototype.val;
        this.render = Selectpicker.prototype.render;
        this.refresh = Selectpicker.prototype.refresh;
        this.setStyle = Selectpicker.prototype.setStyle;
        this.selectAll = Selectpicker.prototype.selectAll;
        this.deselectAll = Selectpicker.prototype.deselectAll;
        this.init();
    };

    Selectpicker.prototype = {

        constructor: Selectpicker,

        init: function() {
            var that = this,
                id = this.$element.attr('id');

            this.multiple = this.$element.prop('multiple');
            this.autofocus = this.$element.prop('autofocus');
            this.$newElement = this.createView();
            this.$element.after(this.$newElement);
            this.$menu = this.$newElement.find('> .dropdown-menu');
            this.$button = this.$newElement.find('> button');
            this.$searchbox = this.$newElement.find('input');
            this.deregistrations = [];

            if (id !== undefined) {
                this.$button.attr('data-id', id);
                $('label[for="' + id + '"]').click(function(e) {
                    e.preventDefault();
                    that.$button.focus();
                });
            }

            this.checkDisabled();
            this.clickListener();
            if (this.options.liveSearch) this.liveSearchListener();
            this.render();
            this.liHeight();
            this.setStyle();
            this.setWidth();
            if (this.options.container) this.selectPosition();
            this.$menu.data('this', this);
            this.$newElement.data('this', this);
        },

        createDropdown: function() {
            //If we are multiple, then add the show-tick class by default
            var multiple = this.multiple ? ' show-tick' : '';
            var inputGroup = this.$element.parent().hasClass('input-group') ? ' input-group-btn' : '';
            var autofocus = this.autofocus ? ' autofocus' : '';
            var header = this.options.header ? '<div class="popover-title"><button type="button" class="close" aria-hidden="true">&times;</button>' + this.options.header + '</div>' : '';
            var searchbox = this.options.liveSearch ? '<div class="bootstrap-select-searchbox"><input type="text" placeholder="Filter..." class="input-block-level form-control" /></div>' : '';
            var actionsbox = this.options.actionsBox ? '<div class="bs-actionsbox">' +
                                '<div class="btn-group btn-block">' +
                                    '<button class="actions-btn bs-select-all btn btn--secondary">' +
                                        'Select All' +
                                    '</button>' +
                                    '<button class="actions-btn bs-deselect-all btn btn--secondary">' +
                                        'Deselect All' +
                                    '</button>' +
                                  '</div>' +
                            '</div>' : '';
            var drop =
                '<div class="btn-group bootstrap-select' + multiple + inputGroup + '">' +
                    '<button type="button" class="btn dropdown-toggle selectpicker" data-toggle="dropdown"'+ autofocus +'>' +
                        '<span class="filter-option pull-left"></span>&nbsp;' +
                        '<span class="caret"></span>' +
                    '</button>' +
                    '<div class="dropdown-menu open">' +
                        header +
                        searchbox +
                        actionsbox +
                        '<ul class="dropdown-menu inner selectpicker" role="menu">' +
                        '</ul>' +
                    '</div>' +
                '</div>';

            return $(drop);
        },

        createView: function() {
            var $drop = this.createDropdown();
            var $li = this.createLi();
            $drop.find('ul').append($li);
            return $drop;
        },

        reloadLi: function() {
            //Remove all children.
            this.destroyLi();
            //Re build
            var $li = this.createLi();
            this.$menu.find('ul').append( $li );
        },

        destroyLi: function() {
            this.$menu.find('li').remove();
        },

        createLi: function() {
            var that = this,
                _liA = [],
                _liHtml = '';

            let hooks = [];
            if (that.$element.length > 0 && that.$element[0].hasAttribute("headless-browser-hooks")) {
                try {
                    hooks = JSON.parse(that.$element[0].getAttribute("headless-browser-hooks"));
                } catch (e) {
                    // Nothing to do here, let's wait for the attribute to be populated and parsable
                }
            }

            this.$element.find('option').each(function() {
                var $this = $(this);

                //Get the class and text for the option
                var optionClass = $this.attr('class') || '';
                var inline = $this.attr('style') || '';
                var text =  $this.data('content') ? $this.data('content') : $this.html();
                var subtext = $this.data('subtext') !== undefined ? '<small class="muted text-muted">' + $this.data('subtext') + '</small>' : '';
                var icon = $this.data('icon') !== undefined ? '<i class="' + that.options.iconBase + ' ' + $this.data('icon') + '"></i> ' : '';
                if (icon !== '' && ($this.is(':disabled') || $this.parent().is(':disabled'))) {
                    icon = '<span>'+icon+'</span>';
                }

                if (!$this.data('content')) {
                    // Handle headless browser hooks (custom Dataiku code)
                    let hook = "";
                    if (Array.isArray(hooks) && hooks.length > 0) {
                        hook = 'puppeteer-hook="' + hooks.shift() + '"';
                    }
                    //Prepend any icon and append any subtext to the main text.
                    text = icon + '<span class="text" ' + hook + '>' + text + subtext + '</span>';
                }

                if (that.options.hideDisabled && ($this.is(':disabled') || $this.parent().is(':disabled'))) {
                    _liA.push('<a style="min-height: 0; padding: 0"></a>');
                } else if ($this.parent().is('optgroup') && $this.data('divider') !== true) {
                    var label = sanitize($this.parent().attr('label'));
                    if ($this.index() === 0) {
                        //Get the opt group label
                        var labelSubtext = $this.parent().data('subtext') !== undefined ? '<small class="muted text-muted">'+$this.parent().data('subtext')+'</small>' : '';
                        var labelIcon = $this.parent().data('icon') ? '<i class="'+$this.parent().data('icon')+'"></i> ' : '';
                        label = labelIcon + '<span class="text">' + label + labelSubtext + '</span>';

                        if ($this[0].index !== 0) {
                            _liA.push(
                                '<div class="div-contain"><div class="divider"></div></div>'+
                                '<dt>'+label+'</dt>'+
                                that.createA(text, 'opt ' + optionClass, inline )
                                );
                        } else {
                            _liA.push(
                                '<dt>'+label+'</dt>'+
                                that.createA(text, 'opt ' + optionClass, inline ));
                        }
                    } else {
                         _liA.push(that.createA(text, 'opt ' + optionClass, inline ) + '<span style="display: none;" class="invisible-group-name">' + label + '</span>'); // adding this invisible span so that items can be searched by group
                    }
                } else if ($this.data('divider') === true) {
                    _liA.push('<div class="div-contain"><div class="divider"></div></div>');
                } else if ($(this).data('hidden') === true) {
                    _liA.push('<a></a>');
                } else {
                    _liA.push(that.createA(text, optionClass, inline ));
                }
            });

            $.each(_liA, function(i, item) {
                var hide = item === '<a></a>' ? 'class="hide is-hidden"' : '';
                _liHtml += '<li rel="' + i + '"' + hide + '>' + item + '</li>';
            });

            //If we are not multiple, and we dont have a selected item, and we dont have a title, select the first element so something is set in the button
            if (!this.multiple && this.$element.find('option:selected').length===0 && !this.options.title) {
                this.$element.find('option').eq(0).prop('selected', true).attr('selected', 'selected');
            }

            return $(_liHtml);
        },

        createA: function(text, classes, inline) {
            return '<a tabindex="0" class="'+classes+'" style="'+inline+'">' +
                 text +
                 '<i class="' + this.options.iconBase + ' ' + this.options.tickIcon + ' icon-ok check-mark"></i>' +
                 '</a>';
        },

        render: function(updateLi) {
            var that = this;

            //Update the LI to match the SELECT
            if (updateLi !== false) {
                this.$element.find('option').each(function(index) {
                   that.setDisabled(index, this.disabled || this.parentNode.disabled);
                   that.setSelected(index, this.selected);
                });
            }

            this.tabIndex();

            var selectedItems = this.$element.find('option:selected').map(function() {
                var $this = $(this);
                var icon = $this.data('icon') && that.options.showIcon ? '<i class="' + that.options.iconBase + ' ' + $this.data('icon') + '"></i> ' : '';
                var subtext;
                if (that.options.showSubtext && $this.attr('data-subtext') && !that.multiple) {
                    subtext = ' <small class="muted text-muted">'+$this.data('subtext') +'</small>';
                } else {
                    subtext = '';
                }
                if ($this.data('content') && that.options.showContent) {
                    return $this.data('content');
                } else if ($this.attr('title') !== undefined) {
                    return $this.attr('title');
                } else {
                    return icon + $this.html() + subtext;
                }
            }).toArray();

            //Fixes issue in IE10 occurring when no default option is selected and at least one option is disabled
            //Convert all the values into a comma delimited string
            var title = !this.multiple ? selectedItems[0] : selectedItems.join(this.options.multipleSeparator);

            //If this is multi select, and the selectText type is count, the show 1 of 2 selected etc..
            if (this.multiple && this.options.selectedTextFormat.indexOf('count') > -1) {
                var max = this.options.selectedTextFormat.split('>');
                var notDisabled = this.options.hideDisabled ? ':not([disabled])' : '';
                if ( (max.length>1 && selectedItems.length > max[1]) || (max.length==1 && selectedItems.length>=2)) {
                    title = this.options.countSelectedText.replace('{0}', selectedItems.length).replace('{1}', this.$element.find('option:not([data-divider="true"]):not([data-hidden="true"])'+notDisabled).length);
                }
             }

            this.options.title = this.$element.attr('title');

            //If we dont have a title, then use the default, or if nothing is set at all, use the not selected text
            if (!title) {
                title = this.options.title !== undefined ? this.options.title : this.options.noneSelectedText;
            }

            this.$button.attr('title', $.trim($("<div/>").html(title).text()).replace(/\s\s+/g, ' '));
            this.$newElement.find('.filter-option').html(title);
        },

        setStyle: function(style, status) {
            if (this.$element.attr('class')) {
                this.$newElement.addClass(this.$element.attr('class').replace(/selectpicker|mobile-device/gi, ''));
            }

            var buttonClass = style ? style : this.options.style;

            if (status == 'add') {
                this.$button.addClass(buttonClass);
            } else if (status == 'remove') {
                this.$button.removeClass(buttonClass);
            } else {
                this.$button.removeClass(this.options.style);
                this.$button.addClass(buttonClass);
            }
        },
        setButtonStyle: function(style) {
            this.$button.css(style);
        },
        setCaretStyle: function(style) {
            this.$button.find('.caret').css('border-top-color', style.color);
        },
        liHeight: function() {
            function getLiHeight(){
                if (!liHeightCached) {
                    liHeightCached = menuClone.find('li > a').outerHeight();
                }
                return liHeightCached;
            }
            function getHeaderHeight(){
                if (!headerHeightCached) {
                    headerHeightCached = menuClone.find('.popover-title').outerHeight();
                }
                return headerHeightCached;
            }
            function getSearchHeight(){
                if (!searchHeightCached) {
                    searchHeightCached = menuClone.find('.bootstrap-select-searchbox').outerHeight();
                }
                return searchHeightCached;
            }
            function getActionsHeight(){
                if (!actionsHeightCached) {
                    actionsHeightCached = menuClone.find('.bs-actionsbox').outerHeight();
                }
                return actionsHeightCached;
            }

            if (this.options.size === false) return;

            selectClone = selectClone || this.$menu.parent().clone().find('> .dropdown-toggle').prop('autofocus', false).prop('id', 'dku-bs-select-clone').end().css({position: 'fixed', left: -10000});
            menuClone = menuClone || selectClone.addClass('open').find('> .dropdown-menu');
            liHeight = getLiHeight();
            headerHeight = this.options.header ? getHeaderHeight() : 0;
            searchHeight = this.options.liveSearch ? getSearchHeight() : 0;
            actionsHeight = this.options.actionsBox ? getActionsHeight() : 0;

            var liHeight = 24,
                headerHeight = 0,
                searchHeight = this.options.liveSearch ? 38 : 0,
                actionsHeight = this.options.actionsBox ? 34 : 0;

            this.$newElement
                .data('liHeight', liHeight)
                .data('headerHeight', headerHeight)
                .data('searchHeight', searchHeight)
                .data('actionsHeight', actionsHeight);
        },

        setSize: function() {
            var that = this,
                menu = this.$menu,
                menuInner = menu.find('.inner'),
                selectHeight = this.$newElement.outerHeight(),
                liHeight = this.$newElement.data('liHeight'),
                headerHeight = this.$newElement.data('headerHeight'),
                searchHeight = this.$newElement.data('searchHeight'),
                actionsHeight = this.$newElement.data('actionsHeight'),
                divHeight = menu.find('li .divider').outerHeight(true),
                menuPadding = parseInt(menu.css('padding-top')) +
                              parseInt(menu.css('padding-bottom')) +
                              parseInt(menu.css('border-top-width')) +
                              parseInt(menu.css('border-bottom-width')),
                notDisabled = this.options.hideDisabled ? ':not(.disabled)' : '',
                $window = $(window),
                menuExtras = menuPadding + parseInt(menu.css('margin-top')) + parseInt(menu.css('margin-bottom')) + 2,
                menuHeight,
                selectOffsetTop,
                selectOffsetBot,
                posVert = function() {
                    selectOffsetTop = that.$newElement.offset().top - $window.scrollTop();
                    selectOffsetBot = $window.height() - selectOffsetTop - selectHeight;
                };
                posVert();
                if (this.options.header) menu.css('padding-top', 0);

            if (this.options.size == 'auto') {
                var getSize = function() {
                    var minHeight,
                        lisVis = that.$lis.not('.hide');

                    posVert();
                    menuHeight = selectOffsetBot - menuExtras;

                    if (that.options.dropupAuto) {
                        that.$newElement.toggleClass('dropup', (selectOffsetTop > selectOffsetBot) && ((menuHeight - menuExtras) < menu.height()));
                    }
                    if (that.$newElement.hasClass('dropup')) {
                        menuHeight = selectOffsetTop - menuExtras;
                    }

                    if ((lisVis.length + lisVis.find('dt').length) > 3) {
                        minHeight = liHeight*3 + menuExtras - 2;
                    } else {
                        minHeight = 0;
                    }

                    menu.css({'max-height' : menuHeight + 'px', 'overflow' : 'hidden', 'min-height' : minHeight + headerHeight + searchHeight + actionsHeight + 'px'});
                    menuInner.css({'max-height' : menuHeight - headerHeight - searchHeight - actionsHeight - menuPadding + 'px', 'overflow-y' : 'auto', 'min-height' : Math.max(minHeight - menuPadding, 0) + 'px'});
                };
                getSize();
                this.$searchbox.off('input.getSize propertychange.getSize').on('input.getSize propertychange.getSize', getSize);
                $(window).off('resize.getSize').on('resize.getSize', getSize);
                $(window).off('scroll.getSize').on('scroll.getSize', getSize);
            } else if (this.options.size && this.options.size != 'auto' && menu.find('li'+notDisabled).length > this.options.size) {
                var optIndex = menu.find('li'+notDisabled+' > *').filter(':not(.div-contain)').slice(0,this.options.size).last().parent().index();
                var divLength = menu.find('li').slice(0,optIndex + 1).find('.div-contain').length;
                menuHeight = liHeight*this.options.size + divLength*divHeight + menuPadding;
                if (that.options.dropupAuto) {
                    this.$newElement.toggleClass('dropup', (selectOffsetTop > selectOffsetBot) && (menuHeight < menu.height()));
                }
                menu.css({'max-height' : menuHeight + headerHeight + searchHeight + actionsHeight + 'px', 'overflow' : 'hidden'});
                menuInner.css({'max-height' : menuHeight - menuPadding + 'px', 'overflow-y' : 'auto'});
            }
        },

        setWidth: function() {
            if (this.options.width == 'auto') {
                const minWidth = 50;
                this.$menu.css('min-width', '50px');
                // Get correct width if element hidden
                var selectClone = this.$newElement.clone().appendTo('body');
                var ulWidth = selectClone.find('> .dropdown-menu').css('width');
                var btnWidth = selectClone.css('width', 'auto').find('> button').css('width');
                selectClone.remove();

                // Set width to whatever's larger, button title or longest option.
                this.$newElement.css('width', Math.max(minWidth, Math.max(parseInt(ulWidth), parseInt(btnWidth))) + 'px');
            } else if (this.options.width == 'fit') {
                // Remove inline min-width so width can be changed from 'auto'
                this.$menu.css('min-width', '');
                this.$newElement.css('width', '').addClass('fit-width');
            } else if (this.options.width) {
                // Remove inline min-width so width can be changed from 'auto'
                this.$menu.css('min-width', '');
                this.$newElement.css('width', this.options.width);
            } else {
                // Remove inline min-width/width so width can be changed
                this.$menu.css('min-width', '');
                this.$newElement.css('width', '');
            }
            // Remove fit-width class if width is changed programmatically
            if (this.$newElement.hasClass('fit-width') && this.options.width !== 'fit') {
                this.$newElement.removeClass('fit-width');
            }
        },

        selectPosition: function() {
            var that = this,
                drop = '<div />',
                $drop = $(drop),
                pos,
                actualHeight,
                getPlacement = function($element) {
                    $drop.addClass($element.attr('class').replace(/form-control/gi, '')).toggleClass('dropup', $element.hasClass('dropup'));
                    pos = $element.offset();
                    var overflow = $drop.find('>:first-child').width()+pos.left-$(window).width()+10; // 10px right margin
                    actualHeight = $element.hasClass('dropup') ? 0 : $element[0].offsetHeight;
                    $drop.css({'visibility':'visible','top' : pos.top + actualHeight, 'left' : Math.min(pos.left,pos.left-overflow), 'width' : $element[0].offsetWidth, 'position' : 'absolute'});

            };
            this.$newElement.on('click', function() {
                if (that.isDisabled()) {
                    return;
                }
                var elm = this;

                // Wait for content size to be available before computing placement
                setTimeout(function() {
                    getPlacement($(elm));
                });

                // Safe placement
                $drop.css({visibility:'hidden',top:0,left:0,width:0,height:0,position:'absolute'});

                $drop.appendTo(that.options.container);
                $drop.toggleClass('open', !$(this).hasClass('open'));
                $drop.append(that.$menu);

            });

            var windowScrollResizeCallback = function() {
                getPlacement(that.$newElement);
            };

            $(window).resize(windowScrollResizeCallback);
            $(window).on('scroll',windowScrollResizeCallback);

            var htmlClickCallback = function(e) {
                if ($(e.target).closest(that.$newElement).length < 1) {
                    $drop.removeClass('open');
                }
            }
            $('html').on('click',htmlClickCallback);

            this.deregistrations.push(function() {
                $(window).unbind('resize',windowScrollResizeCallback);
                $(window).unbind('scroll',windowScrollResizeCallback);
                $('html').unbind('click',htmlClickCallback);
            });
        },

        mobile: function() {
            this.$element.addClass('mobile-device').appendTo(this.$newElement);
            if (this.options.container) this.$menu.hide();
        },

        refresh: function() {
            this.$lis = null;
            this.reloadLi();
            this.render();
            this.setWidth();
            this.setStyle();
            this.checkDisabled();
            this.liHeight();
        },

        update: function() {
            this.reloadLi();
            this.setWidth();
            this.setStyle();
            this.checkDisabled();
            this.liHeight();
        },

        updateStyle: function(style = {}) {
            this.setButtonStyle(style);
            this.setCaretStyle(style);
        },

        setSelected: function(index, selected) {
            if (this.$lis == null) this.$lis = this.$menu.find('li');
            $(this.$lis[index]).toggleClass('selected', selected);
        },

        setDisabled: function(index, disabled) {
            if (this.$lis == null) this.$lis = this.$menu.find('li');
            if (disabled) {
                $(this.$lis[index]).addClass('disabled').find('a').attr('href', '#').attr('tabindex', -1);
            } else {
                $(this.$lis[index]).removeClass('disabled').find('a').removeAttr('href').attr('tabindex', 0);
            }
        },

        isDisabled: function() {
            return this.$element.is(':disabled');
        },

        checkDisabled: function() {
            var that = this;

            if (this.isDisabled()) {
                this.$button.addClass('disabled').attr('tabindex', -1);
            } else {
                if (this.$button.hasClass('disabled')) {
                    this.$button.removeClass('disabled');
                }

                if (this.$button.attr('tabindex') == -1) {
                    if (!this.$element.data('tabindex')) this.$button.removeAttr('tabindex');
                }
            }

            this.$button.click(function() {
                return !that.isDisabled();
            });
        },

        tabIndex: function() {
            if (this.$element.is('[tabindex]')) {
                this.$element.data('tabindex', this.$element.attr('tabindex'));
                this.$button.attr('tabindex', this.$element.data('tabindex'));
            }
        },

        clickListener: function() {
            var that = this;
            var touchStartCallback =function(e) {
                e.stopPropagation();
            };
            $('body').on('touchstart.dropdown', '.dropdown-menu', touchStartCallback);

            this.deregistrations.push(function() {
                $('body').unbind('touchstart.dropdown',touchStartCallback);
            });

            this.$newElement.on('click', function() {
                that.setSize();
                if (!that.options.liveSearch && !that.multiple) {
                    setTimeout(function() {
                        that.$menu.find('.selected a').focus();
                    }, 10);
                }
            });

            this.$menu.on('click', 'li a', function(e) {
                if (!that.multiple) {
                    e.stopPropagation();
                    $(that.$menu).trigger('click', that.$element);
                }

                var clickedIndex = $(this).parent().index(),
                    prevValue = that.$element.val(),
                    prevIndex = that.$element.prop('selectedIndex');

                //Dont close on multi choice menu
                if (that.multiple) {
                    e.stopPropagation();
                }

                e.preventDefault();

                //Dont run if we have been disabled
                if (!that.isDisabled() && !$(this).parent().hasClass('disabled')) {
                    var $options = that.$element.find('option'),
                        $option = $options.eq(clickedIndex),
                        state = $option.prop('selected'),
                        $optgroup = $option.parent('optgroup'),
                        maxOptions = that.options.maxOptions,
                        maxOptionsGrp = $optgroup.data('maxOptions') || false;

                    //Deselect all others if not multi select box
                    if (!that.multiple) {
                        $options.prop('selected', false);
                        $option.prop('selected', true);
                        that.$menu.find('.selected').removeClass('selected');
                        that.setSelected(clickedIndex, true);
                    }
                    //Else toggle the one we have chosen if we are multi select.
                    else {
                        $option.prop('selected', !state);
                        that.setSelected(clickedIndex, !state);

                        if ((maxOptions !== false) || (maxOptionsGrp !== false)) {
                            var maxReached = maxOptions < $options.filter(':selected').length,
                                maxReachedGrp = maxOptionsGrp < $optgroup.find('option:selected').length,
                                maxOptionsArr = that.options.maxOptionsText,
                                maxTxt = maxOptionsArr[0].replace('{n}', maxOptions),
                                maxTxtGrp = maxOptionsArr[1].replace('{n}', maxOptionsGrp),
                                $notify = $('<div class="notify"></div>');

                            if ((maxOptions && maxReached) || (maxOptionsGrp && maxReachedGrp)) {
                                // If {var} is set in array, replace it
                                if (maxOptionsArr[2]) {
                                    maxTxt = maxTxt.replace('{var}', maxOptionsArr[2][maxOptions > 1 ? 0 : 1]);
                                    maxTxtGrp = maxTxtGrp.replace('{var}', maxOptionsArr[2][maxOptionsGrp > 1 ? 0 : 1]);
                                }

                                $option.prop('selected', false);

                                that.$menu.append($notify);

                                if (maxOptions && maxReached) {
                                    $notify.append($('<div>' + maxTxt + '</div>'));
                                    that.$element.trigger('maxReached.bs.select');
                                }

                                if (maxOptionsGrp && maxReachedGrp) {
                                    $notify.append($('<div>' + maxTxtGrp + '</div>'));
                                    that.$element.trigger('maxReachedGrp.bs.select');
                                }

                                setTimeout(function() {
                                    that.setSelected(clickedIndex, false);
                                }, 10);

                                $notify.delay(750).fadeOut(300, function() { $(this).remove(); });
                            }
                        }
                    }

                    if (!that.multiple) {
                        that.$button.focus();
                    } else if (that.options.liveSearch) {
                        that.$searchbox.focus();
                    }

                    // Trigger select 'change'
                    if ((prevValue != that.$element.val() && that.multiple) || (prevIndex != that.$element.prop('selectedIndex') && !that.multiple)) {
                        that.$element.change();
                    }
                }
            });

            this.$menu.on('click', 'li.disabled a, li dt, li .div-contain, .popover-title, .popover-title :not(.close)', function(e) {
                if (e.target == this) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!that.options.liveSearch) {
                        that.$button.focus();
                    } else {
                        that.$searchbox.focus();
                    }
                }
            });

            this.$menu.on('click', '.popover-title .close', function() {
                that.$button.focus();
            });

            this.$searchbox.on('click', function(e) {
                e.stopPropagation();
            });


            this.$menu.on('click', '.actions-btn', function(e) {
                if (that.options.liveSearch) {
                    that.$searchbox.focus();
                } else {
                    that.$button.focus();
                }

                e.preventDefault();
                e.stopPropagation();

                if ($(this).is('.bs-select-all')) {
                    that.selectAll();
                } else {
                    that.deselectAll();
                }
                that.$element.change();
            });

            this.$element.change(function() {
                that.render(false);
            });
        },

        liveSearchListener: function() {
            var that = this,
                no_results = $('<li class="no-results"></li>');

            this.$newElement.on('click.dropdown.data-api', function() {
                that.$menu.find('.active').removeClass('active');
                if (!!that.$searchbox.val()) {
                    that.$searchbox.val('');
                    that.$lis.not('.is-hidden').removeClass('hide');
                    if (!!no_results.parent().length) no_results.remove();
                }
                if (!that.multiple) that.$menu.find('.selected').addClass('active');
                setTimeout(function() {
                    that.$searchbox.focus();
                }, 10);
            });

            this.$searchbox.on('input propertychange', function() {
                if (that.$searchbox.val()) {

                    // Filter connections by name and type
                    var searchValLower = that.$searchbox.val().toLowerCase();
                    that.$lis.not('.is-hidden').removeClass('hide').each(function() {
                        if(!$(this).text().toLowerCase().includes(searchValLower)) {
                            $(this).addClass('hide');
                        }
                    });

                    if (!that.$menu.find('li').filter(':visible:not(.no-results)').length) {
                        if (!!no_results.parent().length) no_results.remove();
                        no_results.html(that.options.noneResultsText + ' "'+ sanitize(that.$searchbox.val()) + '"').show();
                        that.$menu.find('li').last().after(no_results);
                    } else if (!!no_results.parent().length) {
                        no_results.remove();
                    }

                } else {
                    that.$lis.not('.is-hidden').removeClass('hide');
                    if (!!no_results.parent().length) no_results.remove();
                }

                that.$menu.find('li.active').removeClass('active');
                that.$menu.find('li').filter(':visible:not(.divider)').eq(0).addClass('active').find('a').focus();
                $(this).focus();
            });

            this.$menu.on('mouseenter', 'a', function(e) {
              that.$menu.find('.active').removeClass('active');
              $(e.currentTarget).parent().not('.disabled').addClass('active');
            });

            this.$menu.on('mouseleave', 'a', function() {
              that.$menu.find('.active').removeClass('active');
            });
        },

        val: function(value) {

            if (value !== undefined) {
                this.$element.val( value );

                this.$element.change();
                return this.$element;
            } else {
                return this.$element.val();
            }
        },

        selectAll: function() {
            if (this.$lis == null) this.$lis = this.$menu.find('li');
            this.$element.find('option:enabled').prop('selected', true);
            $(this.$lis).filter(':not(.disabled)').addClass('selected');
            this.render(false);
        },

        deselectAll: function() {
            if (this.$lis == null) this.$lis = this.$menu.find('li');
            this.$element.find('option:enabled').prop('selected', false);
            $(this.$lis).filter(':not(.disabled)').removeClass('selected');
            this.render(false);
        },

        keydown: function(e) {
            e.stopPropagation();
            var $this,
                $items,
                $parent,
                index,
                next,
                first,
                last,
                prev,
                nextPrev,
                that,
                prevIndex,
                isActive,
                keyCodeMap = {
                    32:' ', 48:'0', 49:'1', 50:'2', 51:'3', 52:'4', 53:'5', 54:'6', 55:'7', 56:'8', 57:'9', 59:';',
                    65:'a', 66:'b', 67:'c', 68:'d', 69:'e', 70:'f', 71:'g', 72:'h', 73:'i', 74:'j', 75:'k', 76:'l',
                    77:'m', 78:'n', 79:'o', 80:'p', 81:'q', 82:'r', 83:'s', 84:'t', 85:'u', 86:'v', 87:'w', 88:'x',
                    89:'y', 90:'z', 96:'0', 97:'1', 98:'2', 99:'3', 100:'4', 101:'5', 102:'6', 103:'7', 104:'8', 105:'9'
                };

            $this = $(this);

            $parent = $this.parent();

            if ($this.is('input')) $parent = $this.parent().parent();

            that = $parent.data('this');

            if (that.options.liveSearch) $parent = $this.parent().parent();

            if (that.options.container) $parent = that.$menu;

            $items = $('[role=menu] li:not(.divider) a', $parent);

            isActive = that.$menu.parent().hasClass('open');

            if (!isActive && /([0-9]|[A-z])/.test(String.fromCharCode(e.keyCode))) {
                if (!that.options.container) {
                    that.setSize();
                    that.$menu.parent().addClass('open');
                    isActive = that.$menu.parent().hasClass('open');
                } else {
                    that.$newElement.trigger('click');
                }
                that.$searchbox.focus();
            }

            if (that.options.liveSearch) {
                if (/(^9$|27)/.test(e.keyCode) && isActive && that.$menu.find('.active').length === 0) {
                    e.preventDefault();
                    that.$menu.parent().removeClass('open');
                    that.$button.focus();
                }
                $items = $('[role=menu] li:not(.divider):visible', $parent);
                if (!$this.val() && !/(38|40)/.test(e.keyCode)) {
                    if ($items.filter('.active').length === 0) {
                        $items = that.$newElement.find('li').filter(':icontains(' + keyCodeMap[e.keyCode] + ')');
                    }
                }
            }

            if (!$items.length) return;

            if (/(38|40)/.test(e.keyCode)) {

                index = $items.index($items.filter(':focus'));
                first = $items.parent(':not(.disabled):visible').first().index();
                last = $items.parent(':not(.disabled):visible').last().index();
                next = $items.eq(index).parent().nextAll(':not(.disabled):visible').eq(0).index();
                prev = $items.eq(index).parent().prevAll(':not(.disabled):visible').eq(0).index();
                nextPrev = $items.eq(next).parent().prevAll(':not(.disabled):visible').eq(0).index();

                if (that.options.liveSearch) {
                    $items.each(function(i) {
                        if ($(this).is(':not(.disabled)')) {
                            $(this).data('index', i);
                        }
                    });
                    index = $items.index($items.filter('.active'));
                    first = $items.filter(':not(.disabled):visible').first().data('index');
                    last = $items.filter(':not(.disabled):visible').last().data('index');
                    next = $items.eq(index).nextAll(':not(.disabled):visible').eq(0).data('index');
                    prev = $items.eq(index).prevAll(':not(.disabled):visible').eq(0).data('index');
                    nextPrev = $items.eq(next).prevAll(':not(.disabled):visible').eq(0).data('index');
                }

                prevIndex = $this.data('prevIndex');

                if (e.keyCode == 38) {
                    if (that.options.liveSearch) index -= 1;
                    if (index != nextPrev && index > prev) index = prev;
                    if (index < first) index = first;
                    if (index == prevIndex) index = last;
                }

                if (e.keyCode == 40) {
                    if (that.options.liveSearch) index += 1;
                    if (index == -1) index = 0;
                    if (index != nextPrev && index < next) index = next;
                    if (index > last) index = last;
                    if (index == prevIndex) index = first;
                }

                $this.data('prevIndex', index);

                if (!that.options.liveSearch) {
                    $items.eq(index).focus();
                } else {
                    e.preventDefault();
                    if (!$this.is('.dropdown-toggle')) {
                        $items.removeClass('active');
                        $items.eq(index).addClass('active').find('a').focus();
                        $this.focus();
                    }
                }

            } else if (!$this.is('input')) {

                var keyIndex = [],
                    count,
                    prevKey;

                $items.each(function() {
                    if ($(this).parent().is(':not(.disabled)')) {
                        if ($.trim($(this).text().toLowerCase()).substring(0,1) == keyCodeMap[e.keyCode]) {
                            keyIndex.push($(this).parent().index());
                        }
                    }
                });

                count = $(document).data('keycount');
                count++;
                $(document).data('keycount',count);

                prevKey = $.trim($(':focus').text().toLowerCase()).substring(0,1);

                if (prevKey != keyCodeMap[e.keyCode]) {
                    count = 1;
                    $(document).data('keycount', count);
                } else if (count >= keyIndex.length) {
                    $(document).data('keycount', 0);
                    if (count > keyIndex.length) count = 1;
                }

                $items.eq(keyIndex[count - 1]).focus();
            }

            // Select focused option if "Enter", "Spacebar", "Tab" are pressed inside the menu.
            if (/(13|32|^9$)/.test(e.keyCode) && isActive) {
                if (!/(32)/.test(e.keyCode)) e.preventDefault();
                if (!that.options.liveSearch) {
                    $(':focus').click();
                } else if (!/(32)/.test(e.keyCode)) {
                    that.$menu.find('.active a').click();
                    $this.focus();
                }
                $(document).data('keycount',0);
            }

            if ((/(^9$|27)/.test(e.keyCode) && isActive && (that.multiple || that.options.liveSearch)) || (/(27)/.test(e.keyCode) && !isActive)) {
                that.$menu.parent().removeClass('open');
                that.$button.focus();
            }

        },

        hide: function() {
            this.$newElement.hide();
        },

        show: function() {
            this.$newElement.show();
        },

        destroy: function() {
            for(var i = 0 ; i<this.deregistrations.length ; i++){
                this.deregistrations[i]();
            }
            this.deregistrations = [];
            this.$newElement.remove();
            this.$element.remove();
        }
    };
    $.fn.selectpicker = function(option, event) {
       //get the args of the outer function..
       var args = arguments;
       var value;
       var chain = this.each(function() {
            if ($(this).is('select')) {
                var $this = $(this),
                    data = $this.data('selectpicker'),
                    options = typeof option == 'object' && option;

                if (!data) {
                    $this.data('selectpicker', (data = new Selectpicker(this, options, event)));
                } else if (options) {
                    for(var i in options) {
                       data.options[i] = options[i];
                    }
                }

                if (typeof option == 'string') {
                    //Copy the value of option, as once we shift the arguments
                    //it also shifts the value of option.
                    var property = option;
                    if (data[property] instanceof Function) {
                        [].shift.apply(args);
                        value = data[property].apply(data, args);
                    } else {
                        value = data.options[property];
                    }
                }
            }
        });

        if (value !== undefined) {
            return value;
        } else {
            return chain;
        }
    };

    $.fn.selectpicker.defaults = {
        style: 'btn-default',
        size: 'auto',
        title: null,
        selectedTextFormat : 'values',
        noneSelectedText : 'Nothing selected',
        noneResultsText : 'No results match',
        countSelectedText: '{0} of {1} selected',
        maxOptionsText: ['Limit reached ({n} {var} max)', 'Group limit reached ({n} {var} max)', ['items','item']],
        width: false,
        container: false,
        hideDisabled: false,
        showSubtext: false,
        showIcon: true,
        showContent: true,
        dropupAuto: true,
        header: false,
        liveSearch: false,
        actionsBox: false,
        multipleSeparator: ', ',
        iconBase: 'glyphicon',
        tickIcon: 'glyphicon-ok',
        maxOptions: false
    };

    $(document)
        .data('keycount', 0)
        .on('keydown', '.bootstrap-select [data-toggle=dropdown], .bootstrap-select [role=menu], .bootstrap-select-searchbox input', Selectpicker.prototype.keydown)
        .on('focusin.modal', '.bootstrap-select [data-toggle=dropdown], .bootstrap-select [role=menu], .bootstrap-select-searchbox input', function (e) { e.stopPropagation(); });

}(window.jQuery);

(function(){
    "use strict";
    var app = angular.module('platypus.utils', []);

    app.directive("yesNo", function(){
        return {
            scope : {
                yesNo : '='
      },
            template : '<span ng-show="yesNo == true" class="text-success">Yes</span>'+
                        '<span ng-show="yesNo == false" class="text-error">No</span>'
        }
    });
    app.directive("yesNoPartial", function(){
        return {
            scope : {
                yesNoPartial : '='
            },
            link : function($scope) {
                $scope.$watch("yesNoPartial", function(){
                    const input = $scope.yesNoPartial;
                    if (input.every(_ => _)) $scope.response = 2;
                    else if (input.some(_ => _))$scope.response = 1;
                    else $scope.response = 0;
                });
            },
            template : '<span ng-show="response == 2" class="text-success">Yes</span>'+
             '<span ng-show="response == 1" class="text-warning">Partial</span>'+
             '<span ng-show="response == 0" class="text-error">No</span>'
        }
    });

    app.directive('debug', function(){
        return {
            restrict: 'E',
            template: '<div title="data" class="debug" json-formater="debugData"></div>',
            scope: {
                data: '='
            },
            link: function(scope, element) {
                scope.debugData = [];
                var callback = function() {
                      if (scope.debugData.length === 0){
                          scope.$apply(scope.debugData = scope.data);
                      } else {
                          scope.$apply(scope.debugData = []);
                      }
                };
                $(document).bind('debugRefresh',callback);

                scope.$on('$destroy',function(){
                    $(document).unbind('debugRefresh',callback);
                });
            }
        };
    });
    $(window).on('load', function(){
        $(document.body).on('keypress', function(e){
            if (e.charCode == 68 && e.altKey && e.shiftKey && !$(e.target).is('input, select, textarea') && $(e.target).attr('contenteditable') !== 'true') { //command + D
                $(document.body).toggleClass('showDebug');
                $(document).trigger('debugRefresh');
            }
        });
    });

    app.directive('connectionType', function($rootScope, $state){
        return {
            restrict : 'A',
            replace : true,
            scope : {
                "type" : "@",
                "title" : "@"
            },
            template: `<div class="connection-type" disabled-if="appConfig.licensedFeatures.allowedConnectionTypes.indexOf(type) < 0" disabled-message="This connection type is not authorized by your license">
                            <div class="connection-type__inner" style="height: 100%;">
                                <div ng-click="click(type)" class="connection-type__icon-text-wrapper">
                                    <i class="{{type | connectionTypeToIcon}}" style="font-size: 30px;"></i>
                                    <div style="padding-top: 10px; height: 40px">{{type | connectionTypeToNameForList}}</div>
                                </div>
                            </div>
                        </div>`,
            link : function(scope, element, attrs) {
                scope.click = function (type) {
                    if ($rootScope.appConfig.licensedFeatures.allowedConnectionTypes.indexOf(type) >= 0) {
                       $state.go('admin.connections.new',  {type:type})
                    }
                };
                scope.appConfig = $rootScope.appConfig;
                scope.$state = $state;
            }
        }
    });

    app.directive('jsonFormater', function(Logger){
        return {
            restrict: 'A',
            scope: {
                "data": '=jsonFormater'
            },
            link: function(scope, element, attrs){
                scope.$watch('data', function(nv, ov){
                    element.html('');
                    if (nv !== null && nv !== undefined) {
                        json2HTML(nv, element[0]);
                    }
                });

                function json2HTML(json, element){
                    // Doing everything with vanilla JS to keep the fastest rendering possible
                    // instantiating $() takes a long time
                    // using setAttribue & createTextNode has the side effect of escaping HTML
                    var group = document.createElement('div');
                    group.className = 'group';
                    var list = document.createElement('ul');
                    var temp;
                    if(!(json instanceof HTMLElement) && $.isArray(json)){
                        list.className = 'array';
                        temp = document.createElement('div');
                        temp.className = 'bracket start';
                        temp.innerHTML = '[';
                        group.appendChild(temp);
                        group.appendChild(list);
                        temp = document.createElement('div');
                        temp.className = 'bracket end';
                        temp.innerHTML = ']';
                        group.appendChild(temp);
                    } else if (!(json instanceof HTMLElement) && typeof(json) == 'object' && json !== null){
                        list.className = 'object';
                        temp = document.createElement('div');
                        temp.className = 'bracket start';
                        temp.innerHTML = '{';
                        group.appendChild(temp);
                        group.appendChild(list);
                        temp = document.createElement('div');
                        temp.className = 'bracket end';
                        temp.innerHTML = '}';
                        group.appendChild(temp);
                    } else {
                        Logger.error('JSON must either be Object or Array :', json, element);
                    }
                    element.appendChild(group);

                    if (json) {
                        var last_comma;
                        $.each(json, function(key, value){
                            var item = document.createElement('li');
                            list.appendChild(item);

                            if(!(json instanceof HTMLElement) && typeof(json) == 'object' &&  !$.isArray(json)){
                                // prefix with the key value if its a dict
                                item.innerHTML = '<span class="key">"' + sanitize(key) + '":</span>';
                            }

                            if (value instanceof HTMLElement) {
                                // special case for DOM elements to avoid infinite loops
                                var valueWrapper = document.createElement('span');
                                var attributes = '';
                                angular.forEach(value.attributes, function(elt){
                                   attributes += ' ' + elt.nodeName + '="' + elt.nodeValue + '"';
                                });
                                valueWrapper.appendChild(document.createTextNode('<' + value.tagName.toLowerCase() + attributes + '>...</' + value.tagName.toLowerCase() + '>'));
                                valueWrapper.className = valueWrapper.className + ' ' + 'html';
                                item.appendChild(valueWrapper);

                            } else if($.isArray(value)) {
                                if(value.length){
                                    json2HTML(value, item);
                                } else {
                                    // empty array speedup
                                    item.innerHTML = item.innerHTML + '<div class="group"><div class="bracket start">[</div><div class="bracket end">]</div></div>';
                                }
                            } else if (value !== null && typeof(value) == 'object'){
                                json2HTML(value, item);
                            } else {
                                var valueWrapper = document.createElement('span');
                                valueWrapper.className = 'value';
                                if (typeof(value) == 'string'){
                                    // innerText to avoid xss
                                    valueWrapper.innerText = value;
                                } else if (typeof(value) == 'boolean'){
                                    valueWrapper.innerHTML = value ? 'true': 'false';
                                } else if (value === null){
                                    valueWrapper.innerHTML = 'null';
                                    valueWrapper.className = valueWrapper.className + ' ' + 'null';
                                } else if (value === undefined){
                                    valueWrapper.innerHTML = 'undefined';
                                    valueWrapper.className = valueWrapper.className + ' ' + 'undefined';
                                } else {
                                    valueWrapper.innerHTML = value;
                                }
                                valueWrapper.className = valueWrapper.className + ' ' + typeof(value);
                                item.appendChild(valueWrapper);
                            }

                            last_comma = document.createElement('span');
                            last_comma.innerHTML = ',';
                            last_comma.className = 'comma';
                            item.appendChild(last_comma);
                        });
                        if (last_comma){
                            last_comma.remove();
                        }
                    } else {
                        var li = document.createElement('li');
                        var span = document.createElement('span');
                        span.className = 'value';
                        span.innerHTML = 'null';
                        li.appendChild(span);
                        list.appendChild(li);
                    }
                }

                element.on('click', '.group', function(e){
                    e.stopPropagation();
                    $(this).removeClass('folded');
                });
                element.on('click', '.bracket', function(e){
                    e.stopPropagation();
                    $(this).closest('.group').toggleClass('folded');
                });
                element.on('click', '.key', function(e){
                    e.stopPropagation();
                    $(this).next('.group').toggleClass('folded');
                });
                element.on('mouseenter', '.key', function(e){
                    element.find('.hovered').removeClass('hovered');
                    $(this).next('.group').addClass('hovered');
                });
                element.on('mouseleave', function(e){
                    element.find('.hovered').removeClass('hovered');
                });
            }
        };
    });

    app.directive('suggestions', function($timeout, $compile){
    /**
     * Suggestions directive that will transclude a result layout.
     * @param {object} ngModel - The model to bind to.
     * @param {function} suggestions - The function to query to get suggestions, it will be queried with a 'q' parameter, it should return a promise.
     * @param {function} [suggestionsBlur] - Callback called on blur.
     * @param {function} callback - The function to trigger once a choice has been made. If not set, the ng-model is set.
     * @param {string} [placeholder] - An optional placeholder for the input.
     * @param {boolean} [floatingSuggestions=true] - False to have the suggestions in full width under the input instead of following the input.
     * @param {boolean} [filterSuggestionsOnType=false] - True to filter suggestions list according to input value.
    */
        return {
            restrict: 'A',
            transclude: true,
            template: '<div class="suggestions">' +
                '<input type="text" autocomplete="false" ng-model="ngModel" placeholder="{{ placeholder }}" scroll-to-me="{{scrollToMe}}" ng-blur="suggestionBlur($event)" ng-disabled="suggestionDisabled"/>' +
            '</div>',
            replace: true,
            scope: {
                ngModel: '=',
                suggestions: '&',
                suggestionBlur: '=?',
                callback: '&',
                placeholder: '@',
                forbiddenSuggestions: '=?',
                floatingSuggestions: '=?'
            },
            link: function(scope, element, attrs){
                // stash in a field for sub-elements
                scope.suggestionDisabled = false;
                attrs.$observe("disabled", function() {
                    scope.suggestionDisabled = "disabled" in attrs && attrs.disabled !== false;
                });

                scope.items = [];
                scope.hasFocus = false;
                scope.placeholder = attrs.placeholder;
                var input = element.find('input');
                let className = 'items suggestions-list';
                (scope.floatingSuggestions == false) && (className += ' suggestions-list--fixed');
                const parentElement = input[0].parentElement.parentElement;

                let suggestionsTemplate = '<ul class="' + className + '" ng-class="{focus: hasFocus, visible: items.length }" ng-disabled="suggestionDisabled">' +
				'    <li ng-repeat="item in items track by $index" ng-class="{active: $index == itemsIndex, selected: item.selected}" ng-click="setSuggestion($event)" ng-disabled="suggestionDisabled"><span ng-bind-html="(item.label || item) | sanitize"></span></li>' +
                '</ul>';

                let filterableSuggestionsTemplate = '<ul class="' + className + '" ng-class="{focus: hasFocus, visible: items.length }" ng-disabled="suggestionDisabled">' +
				'    <li ng-repeat="item in items | filter:ngModel as filteredItems track by $index" ng-class="{active: $index == itemsIndex, selected: item.selected}" ng-click="setSuggestion($event)" ng-disabled="suggestionDisabled"><span ng-bind-html="(item.label || item) | sanitize"></span></li>' +
                '</ul>';

                var ul;
                if (attrs.filterSuggestionsOnType === undefined) {
                    ul = $compile(suggestionsTemplate)(scope);
                } else {
                    ul = $compile(filterableSuggestionsTemplate)(scope);
                }

                $('body').append(ul);

                scope.itemsIndex = -1;

                var resizeInput = function(){
                    let span = $('<span class="itemPlaceholder"></span>');
                    let inputValue = input.val();
                    let placeholderLength = (attrs.placeholder && attrs.placeholder.length > 0) ? attrs.placeholder.length : 0;
                    element.append(span);
                    span.html(sanitize(inputValue));
                    // When the input is created and has a placecholder, prevent cropping it
                    if (inputValue.length === 0 && placeholderLength > 0) {
                        input.size(placeholderLength);
                        input.width(placeholderLength * 6);
                    } else {
                        input.width(Math.max(span.width() + 20, 50));
                    }
                    span.remove();
                };

                resizeInput();

                scope.safeApply = function(fn) {
                  var phase = this.$root.$$phase;
                  if(phase == '$apply' || phase == '$digest')
                    this.$eval(fn);
                  else
                    this.$apply(fn);
                };

                input.on('focus', function(){
                    scope.hasFocus = true;
                    resizeInput();
                    if (attrs.showSuggestionsOnFocus !== undefined) {
                        showSuggestions();
                    }
                });

                input.on('blur', function() {
                    resizeInput();
                });

                ul.on('mouseenter', ' > li', function(e){
                    scope.itemsIndex = ul.find(' > li').index(this);
                    scope.$apply();
                });
                element.find('input').on('keydown', function(e){
                    // up arrows
                    if (e.keyCode == 38){
                        scope.itemsIndex = Math.max(scope.itemsIndex - 1, -1);
                        scope.$apply();
                    }
                    // down arrows
                    if (e.keyCode == 40){
                        scope.itemsIndex = Math.min(scope.itemsIndex + 1, scope.items.length - 1);
                        scope.$apply();
                    }

                    // ensure it is visible
                    if ((e.keyCode == 38 || e.keyCode == 40) && scope.itemsIndex >= 0){
                        var current_li = ul.find(' > li').eq(scope.itemsIndex);
                        var offset = current_li.position().top;
                        var step = current_li.height();

                        if (offset < step) {
                            ul.scrollTop(Math.max(ul.scrollTop() - step, 0));
                        } else if (offset > ul.height() - step) {
                            ul.scrollTop(ul.scrollTop() + step);
                        }
                        e.preventDefault();
                    }

                    // enter
                    if (e.keyCode == 13){
                        scope.setSuggestion(e);
                        scope.$apply();
                    }
                });

                element.find('input').on('keyup', function(e){
                    resizeInput();
                });
                scope.setSuggestion = function(event){
                    if (scope.itemsIndex >= 0) {

                        const item = attrs.filterSuggestionsOnType === undefined ? scope.items[scope.itemsIndex] : scope.filteredItems[scope.itemsIndex];
                        if (attrs.callback) {
                            scope.callback({ value: item, event: event });
                        } else {
                            scope.ngModel = item;
                        }
                    } else if (attrs.allowNoSuggestions !== undefined) {
                        if (attrs.callback) {
                            scope.callback({ value: input[0].value, event: event });
                        }
                    }
                    // deselect everything
                    $timeout(function(){scope.itemsIndex = -1;}, 0);
                };

                var showSuggestions = function(nv) {
                    scope.suggestions({q:nv}).then(function(response){
                        scope.items = response;

                        if (scope.forbiddenSuggestions) {
                            scope.forbiddenSuggestions.forEach(function(e) {
                                var index = scope.items.indexOf(e)
                                if (index > -1) {
                                    scope.items.splice(index,1);
                                }
                            })
                        }

                        if (scope.items.length) {

                            if (scope.floatingSuggestions !== false) {
                                var offset = input.offset();
                                var height = input.outerHeight();
                                ul.css(
                                    {
                                        position: 'absolute',
                                        left: offset.left,
                                        top: offset.top + height
                                    }
                                );
                            } else {
                                let parentDimensions = parentElement.getBoundingClientRect();
                                ul.css(
                                    {
                                        position: 'absolute',
                                        left: parentDimensions.left,
                                        top: parentDimensions.top + parentDimensions.height,
                                        width: parentDimensions.width
                                    }
                                )
                            }
                        }
                    });
                };
                scope.$on('showSuggestions', showSuggestions);
                scope.$watch('ngModel', function(nv, ov){
                    if (nv !== ov){
                        if (nv){
                            showSuggestions(nv);
                        } else {
                            scope.items = [];
                        }
                        scope.itemsIndex = -1;
                    }
                });

                var resetOnEventElsewhere = function(ev) {
                	var el = ev.target;
                	if (!ul.get(0).contains(el)) {
                		scope.items = [];
                		scope.$apply();
                	}
                };

                // Using $timeout so that this code get executed after the current digest cycle.
                // Otherwise the $(element).parents() won't go further than the parent directive's element
                // b/c this parent directive's element is not in the DOM yet
                $timeout(function() {
                    $(element).parents().scroll(resetOnEventElsewhere);
                    scope.scrollToMe = !attrs.hasOwnProperty('noScrollToMe');
                }, 0);

                $('html').click(resetOnEventElsewhere);

                scope.$on('$destroy', function() {
                	element.parents().unbind('scroll', resetOnEventElsewhere);
                	$('html').unbind('click', resetOnEventElsewhere);
                	ul.remove();
                })

            }
        };
    });

    app.directive('tags', function($rootScope){
        return {
            template: `<div class="tags" >
                    <div ng-repeat="tag in tags" class="tag" style="background-color:{{ tagColor(tag) }}" >
                        <span ui-global-tag="tag" object-type="objectType"/>
                    </div>
                    <div ng-if="tags.length === 0 && !emptyText" class="help-text"><i plus-icon /> add tags </div>
                    <div ng-if="tags.length === 0 && emptyText" class="help-text">{{emptyText}}</div>
                </div>`,
            scope: {
                tags: '=tags',
                objectType: '=?',
                emptyText: '@?'
            },
            link: function(scope, element, attrs){
                if ($rootScope.activeProjectTagColor) {
                     scope.tagColor = $rootScope.activeProjectTagColor;
                } else {
                    scope.tagColor = function(){
                        return "#999";
                    }
                }
                if ($rootScope.activeGlobalTagsCategory) {
                     scope.getGlobalTagCategory = $rootScope.activeGlobalTagsCategory;
                } else {
                    scope.getGlobalTagCategory = function(){
                        return null;
                    }
                }
            }
        };
    });

    /**
    * Display tags with global tag category ui if it applies.
    *
    * <span ui-global-tag="TAG_TITLE" object-type="OBJECT_TYPE"/>
    */
    app.directive('uiGlobalTag', function($rootScope, TaggingService){
        return {
            template: `<span ng-if="globalTagCategory" class="global-tag-category-label mright4">{{globalTagCategory}}</span>{{tagTitle}}`,
            scope: {
                tag: '=uiGlobalTag',
                objectType: '=?'
            },
            link: function(scope, element, attrs) {

                scope.$watch('tag', function(nv, ov){
                    if (nv !== null && nv !== undefined) {
                        scope.globalTagCategory = TaggingService.getGlobalTagCategory(nv, scope.objectType);
                        scope.tagTitle = nv;
                        if (scope.globalTagCategory) {
                            var regexp = new RegExp(`${scope.globalTagCategory.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}:(.+)`,"g");
                            scope.tagTitle = scope.tag.split(regexp)[1];
                        }
                        const tagElement = element.parent();
                        const tagBackgroundColor = tagElement[0].style.backgroundColor;
                        if (tagBackgroundColor && typeof d3 !== 'undefined') {
                            const tagBgColorRGB = d3.rgb(tagBackgroundColor);
                            $(element).css("color", tagBgColorRGB.r*0.299 + tagBgColorRGB.g*0.587 + tagBgColorRGB.b*0.114 >= 186 ? "#333" : "#FFF");
                        }
                    }
                });
            }
        }
    });

    app.directive('draggable', function($parse) {
        // <div draggable="OBJECT" [draggable-mode="move"]>...</div>
        return {
            link: function(scope, element, attrs) {
                var el = element[0];

                el.draggable = true;

                el.addEventListener('dragstart', function(e) {
                    e.dataTransfer.effectAllowed = attrs.draggableMode || 'copy';
                    e.dataTransfer.setData('json', JSON.stringify(scope.$eval(attrs.draggable)));
                    // FIXME highlight droppable
                    this.classList.add('drag');
                    return false;
                },false);

                el.addEventListener('dragend', function(e) {
                    if (e.dataTransfer.dropEffect === 'move' && attrs.draggableRemove) {
                        // The element has been moved and should be removed from here
                        $parse(attrs.draggableRemove)(scope.$parent || scope);
                    }
                    this.classList.remove('drag');
                    return false;
                },false);
            }
        };
    });

    // From http://rogeralsing.com/2013/08/26/angularjs-directive-to-check-that-passwords-match-followup/
    app.directive('passwordMatch', [function () {
            return {
                restrict: 'A',
                scope:true,
                require: 'ngModel',
                link: function (scope, elem , attrs,control) {
                    var checker = function () {

                        //get the value of the first password
                        var e1 = scope.$eval(attrs.ngModel);

                        //get the value of the other password
                        var e2 = scope.$eval(attrs.passwordMatch);
                        return e1 == e2;
                    };
                    scope.$watch(checker, function (n) {

                       //set the form control to valid if both
                       //passwords are the same, else invalid
                       control.$setValidity("unique", n);
                });
            }
         };
    }]);

    app.directive('copyClipboardButton', function($timeout, ClipboardUtils) {
        return {
            template: '<a class="link-std" ng-click="copyClipboard()"><i class="icon-copy"/></a>',
            scope: {
                copyClipboardButton: '<'
            },
            link: function(scope, element, attrs) {
                scope.copyClipboard = function() {
                    ClipboardUtils.copyToClipboard(scope.copyClipboardButton);
                };
            }
        };
    });

    // Note : this zone capture the focus on click
    // Once focused, all keyboards event are forwarded to an hidden input
    // (it prevents keyboard capture !!)
    app.directive('copyPasteZone',function($timeout) {
        return {
            scope : {
                copyFrom:'&',
                pasteTo:'&'
            },
            link: function(scope, element, attrs) {
                var fakeInput = $('<textarea style="position:absolute;top:-20000px; left:-20000px;">');
                $('body').append(fakeInput);

                element.bind('click',function(e) {
                    var prevActiveElement = document.activeElement;
                    $timeout(function() {
                        // Some heuristics to avoid taking the focus unnecessarily. It's avoided if:
                        // - The focused element has changed after clicking
                        if(prevActiveElement == document.activeElement
                        // - The focused element has been clicked on
                        && document.activeElement != e.target
                        // - The focused element is a child of the copy paste zone
                        && $(e.target).has(document.activeElement).length==0
                        // - The clicked element is inside a button or a link
                        && $(e.target).parents('a, button').length==0
                        // - The clicked element is a button or a link
                        && ['a','button','input','textarea'].indexOf(e.target.tagName.toLowerCase())==-1) {
                            fakeInput.focus();
                        }
                    },0);
                });
                scope.$on('$destroy',function() {
                    fakeInput.remove();
                });

                function copyOrCut(cut) {
                    scope.$apply(function(){
                        var contentToWrite = scope.copyFrom({cut:cut});
                        fakeInput.val(contentToWrite?contentToWrite:'');
                        fakeInput.select();
                        fakeInput.focus();
                    });
                }

                fakeInput.on('beforecopy',function(e) {
                    copyOrCut(false);
                });

                fakeInput.on('beforecut',function(e) {
                    copyOrCut(true);
                });

                fakeInput.bind('paste',function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    scope.$apply(function() {
                        var originalEvent = e.originalEvent;
                        var data = originalEvent.clipboardData.getData('text/plain');
                        scope.pasteTo({data:data});
                    });
                });
            }
        };
    });

    /**
     * Copied from https://github.com/angular-ui/ui-utils/pull/152
     *
     * Executes an event after an 'intended hover'.
     * The delay can be optionally specified
     * Example
     * <div ui-hoverintent="menu.open = true" ui-hoverintent-delay="1000" ui-hoverintent-resetonclick></div>
     *
     * @param {function} uiHoverintent - The event handler function.
     * @param {int} [uiHoverintentDelay=500] - The intent delay in ms
     * @param {boolean} [uiHoverintentResetonclick] - Reset the intent delay timer, when the element is clicked
     */
    app.directive('uiHoverintent', ['$timeout', function($timeout){
        return {
            restrict: 'A',
            link: function(scope, element, attributes){

                var hoverIntentPromise;

                element.bind('mouseenter', triggerDelayedEvent);
                element.bind('mouseleave', cancelDelayedEvent);
                element.bind('$destroy', cancelDelayedEvent);
                if(attributes.hasOwnProperty('uiHoverintentResetonclick')){
                    element.bind('click', triggerDelayedEvent);
                }

                /**
                 * Triggers the eventHandler after the specified delay, or the default delay.
                 * Cancels the existing pending trigger (if any).
                 */
                function triggerDelayedEvent(event){
                    cancelDelayedEvent();

                    var delay = scope.$eval(attributes.uiHoverintentDelay);
                    if(delay === undefined){
                        delay = 500;
                    }

                    hoverIntentPromise = $timeout(function(){
                        scope.$eval(attributes.uiHoverintent, { $event: event });
                    }, delay);
                }

                /**
                 * Cancels the triggering the event.
                 */
                function cancelDelayedEvent(){
                    $timeout.cancel(hoverIntentPromise);
                }
            }
        };
    }]);

    app.directive("ngInject", function($injector) {
        return {
            scope: false,
            priority: 100,
            link: function($scope, element, attrs) {
                $scope[attrs.ngInject] = $injector.get(attrs.ngInject);
            }
        }
    });

    app.directive("dkuFor", function($injector) {
        return {
            scope : {
                dkuFor : '@'
            },
            link: function($scope, element, attrs) {
                element.click(function() {
                    $($scope.dkuFor).click();
                    return false;
                });
            }
        }
    });

    // Make the item always take up the width it has when its font-weight is 500
    // Useful to avoid weird shifting when tabs become active
    app.directive("fw500Width", function() {
        return {
            scope: false,
            link: function($scope, $element) {
                $element.addClass("dku-fw500-width");
                $element.attr("text-content", $element.text());
            }
        }
    });

    app.directive("dkuFadeIn", function($timeout) {
        return {
            scope: false,
            link: function($scope, $element, attrs) {
                $element.addClass("dku-fade-in");
                $timeout(function() {
                    $element.addClass("dku-fade-in-start");
                    if (attrs.fadeAll !== undefined) {
                        $element.addClass('dku-fade-all-in-start');
                    }
                });
            }
        }
    });

    app.directive('onScroll', function() {
        return {
            scope: {
                onScroll: '='
            },
            link: function($scope, $element) {
                const handler = $element.bind('scroll', function(evt) {
                    if (!$scope.onScroll) return;
                    $scope.onScroll(evt);
                });
                $scope.$on('$destroy', function() {
                    $element.unbind('scroll', handler);
                });
            }
        };
    });

    app.directive('pasteRegion', function(ClipboardUtils) {
        return {
            scope: {
                copyCallback: '&',
                pasteCallback: '&'
            },
            link: function($scope, element, attrs) {
                const copyCallback = $scope.copyCallback();
                const pasteCallback = $scope.pasteCallback();

                element.on('keydown', (event) => {
                    if (event.currentTarget === event.target) {
                        if(event.ctrlKey || event.metaKey) {
                            // ctrl + c
                            if (event.which === 67) {
                                copyCallback(event);
                                $scope.$apply();
                            // ctrl + v
                            } else if (event.which === 86) {
                                ClipboardUtils.pasteFromClipboard(event, pasteCallback);
                                $scope.$apply();
                            }
                        }
                    }
                });
            }
        };
    })

})();

(function(){
    "use strict";
    var app = angular.module('dataiku.ml.hyperparameters', ['platypus.utils']);

    /**
     * Controls for numeric grid search (range and explicit)
     * @param {string} label - The control label
     * @param {string} strategy - the current global strategy used. Can be any of 'GRID', 'BAYESIAN', RANDOM';
     * @param {string} helpInline - optional inline help
     * @param {boolean} required - optional add css class "required" to the directive
     * @param {boolean} decimal - optional to allow decimal values
     * @param {decimal} min - optional min value to check
     * @param {decimal} max - optional max value to check
    */
    app.directive('mlHpNumerical', function($compile, $timeout, $rootScope, $q){
        return {
            restrict: 'E',
            scope: {
                model: '=ngModel',
                placeholder: '@',
            },
            templateUrl: 'templates/ml/ml-hp-numerical.html',
            link: function(scope, element, attrs){

                function getValueOrUndefined(val) {
                    return angular.isUndefined(val) ? undefined : val;
                }

                scope.strategy = attrs.strategy;
                scope.helpInline = attrs.helpInline;
                scope.label = attrs.label;
                scope.required = !!getValueOrUndefined(attrs.required);
                scope.decimal = attrs.hasOwnProperty('decimal');
                scope.min = getValueOrUndefined(scope.model.limit.min);
                scope.max = getValueOrUndefined(scope.model.limit.max);

                scope.getCurrentMode = function() {
                    if (attrs.strategy == 'GRID') {
                        return scope.model.gridMode;
                    } else {
                        return scope.model.randomMode; // all other modes (random, bayesian, ...)
                    }
                };

                scope.isInvalidMinMax = function() {
                    if (angular.isUndefined(scope.model.range)) {
                        return false;
                    }

                    const min = scope.model.range.min;
                    const max = scope.model.range.max;

                    if (angular.isUndefined(min) || angular.isUndefined(max)) {
                        return false;
                    }

                    return min >= max;
                };

                scope.isInvalidValuesCount = function() {
                    const { min, max, nbValues } = scope.model.range;
                    const isNbValuesDecimal = nbValues % 1 !== 0;

                    if (nbValues < 2 || isNbValuesDecimal) {
                        return true;
                    }

                    return scope.decimal ? false : nbValues > max - min + 1;
                };

                scope.changeMode = function(targetMode) {
                    function switchMode(mode) {
                        if (mode == 'EXPLICIT') {
                            return 'RANGE';
                        } else {
                            return 'EXPLICIT';
                        }
                    }

                    if (scope.getCurrentMode() != targetMode) {
                        return;
                    }

                    if (attrs.strategy == 'GRID') {
                        scope.model.gridMode = switchMode(scope.model.gridMode);
                    } else {
                        scope.model.randomMode = switchMode(scope.model.randomMode); // all other strategies (random, bayesian, ...)
                    }
                };
            }
        };
    });

    /**
     * Built on top of Suggestions directive to display numeric suggestions (for grid search).
     * @param {array} tags - The list of selected suggestions displayed as tags in the input.
     * @param {string} placeholder - Optional placeholder of the input.
    */
    app.directive('gsField', function($compile, $timeout, $rootScope, $q){
        return {
            restrict:'A',
            scope: {
                tags: '=ngModel',
                placeholder: '@',
            },
            templateUrl: 'templates/ml/gs-field.html',
            link: function(scope, element, attrs){

                var allowedMultiples = [2,5,10,100];
                var allowedAdditives = [1,2,5,10,20,30,50,100];

                scope.getClassName = function() {
                    var className = 'gsField';

                    if (attrs.notGrid !== undefined) {
                        className += ' gsField--not-grid';
                    }
                    return className;
                };

                function filterSuggestedGS(ls) {
                    return ls.filter(function(o){
                        return scope.tags.indexOf(o) === -1 && o > 0;
                    });
                }

                var getSuggestedGS = function() {
                    if (scope.tags.length > 0) {
                        var a = Math.min(scope.tags[scope.tags.length-1],scope.tags[scope.tags.length-2] || 1),
                            b = Math.max(scope.tags[scope.tags.length-1],scope.tags[scope.tags.length-2] || 1),
                            rev = scope.tags[scope.tags.length-1] < (scope.tags[scope.tags.length-2] || 1),
                            m;
                        if (a<0 || b<0) {
                            return filterSuggestedGS([scope.placeholder || 1])
                        }

                        for (m=0;m<allowedMultiples.length;m++) {
                            var muldif = Math.log(b/a) / Math.log(allowedMultiples[m]);
                            muldif = Math.round(muldif * 1000) / 1000;
                            if (isInteger(muldif)) {
                                if (!rev) {
                                    return filterSuggestedGS([b*allowedMultiples[m], a/allowedMultiples[m]])
                                }
                                else {
                                    return filterSuggestedGS([a/allowedMultiples[m], b*allowedMultiples[m]])
                                }
                            }
                        }

                        for (m=allowedAdditives.length;m>=0;m--) {
                            if ((b-a) % allowedAdditives[m] === 0 && a % allowedAdditives[m] === 0) {
                                if (!rev) {
                                    return filterSuggestedGS([b+allowedAdditives[m], a-allowedAdditives[m]])
                                }
                                else {
                                    return filterSuggestedGS([a-allowedAdditives[m], b+allowedAdditives[m]])
                                }
                            }
                        }

                        return filterSuggestedGS([scope.placeholder || 1])
                    } else {
                        return filterSuggestedGS([scope.placeholder || 1])
                    }
                }

                scope.suggestGS = function(q) {
                    if (attrs.notGrid !== undefined) {
                        return;
                    }

                    var deferred = $q.defer();
                    deferred.resolve(getSuggestedGS());
                    return deferred.promise;
                };

                scope.tagIndex = undefined;
                var input = element.find('.suggestions input');
                scope.hasFocus = function(){
                    return input.is(":focus") || element.find(".fake").is(":focus");
                };
                scope.newTag = '';

                scope.addSuggestion = function(value, e){
                    scope.newTag = value;
                    e.stopPropagation();
                    if (scope.addTag()) {
                        e.preventDefault();
                    }
                };

                scope.selectTag = function(e, idx){
                    e.stopPropagation();
                    scope.tagIndex = idx;
                };

                scope.deleteTag = function(e, idx){
                    if (e){ e.originalEvent.stopPropagation() }

                    var index = idx;
                    if (index === null || index === undefined) {
                        index = scope.tagIndex;
                    }

                    if(! angular.isUndefined(index)){
                        scope.tags.splice(index, 1);
                        $timeout(function(){ scope.$broadcast('showSuggestions') });
                        if(scope.tags.length) {
                            // set tagIndex to former tag
                            scope.tagIndex = Math.max(index - 1, 0);
                        } else {
                            // otherwise set focus to input, but only if this was from a backspace deletion
                            if (!e) { input.focus() }
                        }
                    }
                };

                function isInRange(val) {
                    let inRange = true;
                    if (!angular.isUndefined(attrs.min)) {
                        inRange = inRange && val >= attrs.min;
                    }
                    if (!angular.isUndefined(attrs.max)) {
                        inRange = inRange && val <= attrs.max;
                    }

                    return inRange;
                }

                scope.addTag = function(){
                    var added = false;
                    if(scope.newTag && !isNaN(scope.newTag)){
                        scope.newTag = parseFloat(scope.newTag);

                        const inRange = isInRange(scope.newTag);
                        if (inRange && (attrs.allowDubs || scope.tags.indexOf(scope.newTag) === -1)){
                            // add tag
                            scope.tags.push(scope.newTag);
                            added = true;
                        }
                        // empty field
                        scope.newTag = '';

                        if(! scope.$root.$$phase) scope.$apply();
                        $timeout(function(){ scope.$broadcast('showSuggestions') });
                    }
                    return added;
                };

                scope.$watch('tagIndex', function(){
                    if (!angular.isUndefined(scope.tagIndex)){
                        input.blur();
                        element.find(".fake").focus();
                    }
                });

                input.on('focus', function(){
                    scope.tagIndex = undefined;
                });

                scope.setFocus = function(e){
                    input.focus();
                    e.stopPropagation();
                };

                scope.$on("$destroy", function(){
                    $(element).off("keydown.tags");
                });
                scope.inputBlur = function(e) {
                    if (e) {
                        e.stopPropagation();
                        if (scope.addTag()) {
                            e.preventDefault();
                        }
                    }
                }
                $(element).on('keydown.tags', function(e){
                    if(scope.hasFocus()){
                        if (e.keyCode == 37){ // left arrow
                            if(!angular.isUndefined(scope.tagIndex)){
                                scope.tagIndex = Math.max(scope.tagIndex - 1, 0);
                                scope.$apply();
                            } else {
                                if(scope.newTag.length === 0){
                                    scope.tagIndex = scope.tags.length - 1;
                                    scope.$apply();
                                }
                            }
                        } else if (e.keyCode == 39){ // right arrow
                            if(!angular.isUndefined(scope.tagIndex)){
                                scope.tagIndex = scope.tagIndex + 1;
                                if(scope.tagIndex >= scope.tags.length){
                                    scope.tagIndex = undefined;
                                    input.focus();
                                }
                                scope.$apply();
                            }
                        } else if (e.keyCode == 8){ // delete
                            if(angular.isUndefined(scope.tagIndex)){
                                if(scope.newTag.length === 0){
                                    scope.tagIndex = scope.tags.length - 1;
                                    scope.$apply();
                                }
                            } else {
                                e.preventDefault();
                                scope.deleteTag();
                                scope.$apply();
                            }
                        } else if (e.keyCode == 13 || e.keyCode == 32){ // enter & space : If we added a tag, don't let the "enter" key trigger a form submit
                            e.stopPropagation();
                            e.preventDefault();
                            if (!scope.newTag) {
                                scope.newTag = getSuggestedGS()[0];
                            }
                           scope.addTag();
                        }
                    }
                });

                scope.tags = scope.tags || [];

                scope.$watch('tags', function(nv, ov) {
                    // Sometimes someone rebinds the ngModel to null, in our case the API...
                    if (nv === null || nv === undefined) {
                        scope.tags = [];
                    }
                });
            }
        };
    });
})();
(function() {
'use strict';

const app = angular.module('dataiku.logger', []);


// This is an "instantiable" => it is NOT a singleton !
// DIContext contains some details related to the service who requested the logger instance.
app.instantiable('Logger', function(DIContext, LoggerProvider) {
    const fullname = getSimpleFullname(DIContext);
    return LoggerProvider.getLogger(fullname);
});


app.service('LoggerProvider',function($log, Notification, $injector) {
    const svc = this;

    function handleLog(type, namespace) {
        return function(...loggedObjects) {
            const timestamp = moment().utc().valueOf();
            const formattedDate = moment().format('HH:mm:ss.SSS');
            const formattedType = type.toUpperCase();

            // Print in console
            let prefix = '['+ formattedDate + ']';
            if(namespace) {
                prefix += ' [' + namespace + ']';
            }
            prefix += ' -';

            if (type == "debug" && loggedObjects && loggedObjects.length == 1) {
                $log.info("%c" + prefix + " " + loggedObjects[0], "color: #777");
            } else {
                const args = [prefix, ...loggedObjects];
                $log[type].apply($log, args);
            }

            if($injector.has('WebSocketService')) {
                if($injector.get("WebSocketService").isAvailable()) {
                    const stringifiedLoggedObjects = [];
                    // Websocket connection fails if the message is too big, so we truncate - #3821
                    // To work around the fact that might it be UTF8, we limit messages to 63K / 3
                    const MAX_LENGTH = 64000/3;
                    let remainingLen = MAX_LENGTH;

                    angular.forEach(loggedObjects,function(obj) {
                        let ret = '';
                        if(!obj) {
                            ret = ''+obj;
                        } else {
                            if(typeof obj == 'object') {
                                try {
                                    ret = JSON.stringify(obj);
                                } catch(e) {
                                    ret = ''+obj;
                                }
                            } else {
                                 ret = ''+obj;
                            }
                        }
                        if (ret.length > remainingLen) {
                            ret = "TRUNCATED: " + ret.substring(0, remainingLen);
                            console.warn("Truncated log message on Websocket (too long)"); /*@console*/ // NOSONAR: OK to use console.
                        }
                        remainingLen -= ret.length;
                        stringifiedLoggedObjects.push(ret)
                    });
                    try {
                        Notification.publishToBackend('log-event', {
                            messages: stringifiedLoggedObjects,
                            timestamp: timestamp,
                            type: formattedType,
                            namespace: namespace
                        });
                    } catch (e2) {
                        console.warn("Failed to send log event to backend", e2); /*@console*/ // NOSONAR: OK to use console.
                    }
                }
            }
        };
    };

    svc.getLogger = function(namespace) {
        return {
            log: handleLog("log", namespace),
            warn: handleLog("warn", namespace),
            debug: handleLog("debug", namespace),
            info: handleLog("info", namespace),
            error: handleLog("error", namespace)
        };
    };
});


/*
Instantialble assert:
    - throws an error if the condition is not met
    - opens the debugger if the console is open
    - prefixes the error message with the component
    - enriches the error with the component full name and adds a "js-assert" orign

This is useful in particular to easily track errors reported to Rollbar
*/
app.instantiable('Assert', function(DIContext, AssertProvider) {
    const namespace = getSimpleFullname(DIContext);
    return AssertProvider.getChecker(namespace);
});


app.service('AssertProvider',function() {
    const svc = this;

    function _fail(namespace, message) {
        debugger // NOSONAR (opens the debugger if the console is open)
        const prefix = namespace ? `[${namespace}] ` : '';
        throw new Error('[Assert]' + prefix + message);
    }

    function fail(namespace) {
        return function(message) {
            _fail(namespace, message);
        };
    }

    function trueish(namespace) {
        return function(condition, message) {
            if (!condition) {
                _fail(namespace, message);
            }
        };
    }

    function inScope(namespace) {
        return function(scope, attribute) {
            if (!resolveValue(scope, attribute)) {
                _fail(namespace, attribute + ' is not in scope');
            }
        };
    }

    svc.getChecker = function(namespace) {
        return {
            trueish: trueish(namespace),
            inScope: inScope(namespace),
            fail: fail(namespace)
        };
    };
});


// Utils for prefixing based on the angular component
function getSimpleModuleName(DIContext) {
    let sname = DIContext.serviceName;
    if (sname) {
        sname = sname.replace("dataiku.", "d.")
            .replace(".services", ".s")
            .replace(".directive", ".dir")
            .replace(".controllers", ".ctrl")
            .replace(".recipes", ".r")
            .replace(".savedmodels", ".sm")
            .replace(".managedfolder", ".mf")
            ;
    }
    return sname;
}

function getSimpleObjectName(DIContext) {
    let oname = DIContext.objectName;
    if (oname) {
        oname = oname.replace("APIXHRService", "API")
            .replace("Controller", "Ctrl");
    }
    return oname;
}

function getSimpleFullname(DIContext) {
    const sname = getSimpleModuleName(DIContext);
    const oname = getSimpleObjectName(DIContext);
    const fullname = sname + (sname ? '.' : '') + oname;
    return fullname;
}


const EXPECTED_EXCEPTIONS=[
    "Possibly unhandled rejection: dismissed modal"
];

app.factory('$exceptionHandler', function(Logger, ErrorReporting) {
    return function(exception, cause) {
        /* Swallow "expected exceptions", such as the one we do not catch when dismissing a modal */
        if (EXPECTED_EXCEPTIONS.includes(exception)) {
            return;
        }
        /* A string was thrown, so at least, use it as a message */
        if (exception !== undefined && exception.message === undefined) {
            console.warn("Got weird exception", exception, printStackTrace()); /*@console*/ // NOSONAR: OK to use console.
            exception = {
                stack: "no stack - string thrown ?",
                message: exception
            }
        }

        /* Send to console and frontend log */
        if (exception === undefined) {
            Logger.error("Caught undefined exception", printStackTrace());
        } else {

            const typename = ({}).toString.call(exception);
            /* Firefox specific error */
            if (typename == "[object Exception]") {
                console.info("Changing Firefox exception", exception); /*@console*/ // NOSONAR: OK to use console.
                let newMessage = exception.message ? exception.message : "No message";
                newMessage += " - FF modified";
                if (exception.name) newMessage += " - Name=" + exception.name;
                if (exception.result) newMessage += " - result=" + exception.result;

                let newException = new Error(newMessage);
                newException.stack = exception.stack;
                exception = newException;
            }

            Logger.error("Caught exception: " + exception,
                "\nStack: ", exception.stack,
                '\nCaused by : ', cause,
                '\nMessage :', exception.message);
        }
        /* Send to Rollbar (and WT1) */
        ErrorReporting.reportJSException(exception, cause);
    };
});


app.factory("ErrorReporting", function() {
    // Must not depend on rootScope else circular dependency

    function apiErrorToRollbarStackInfo(apiError) {
        return {
            name: apiError.errorType,
            message: apiError.message,
            stack: apiError.stackTrace == null ? null : apiError.stackTrace.map(function(x) {
                return {
                    "url": x.file,
                    "line": x.line,
                    "func": x.function
                }
            })
        };
    }

    function reportAPIError(apiError, customData) {
        /* We do that in several steps:
         *   - API error to Rollbar Stack info
         *   - Then rollbar payload from this stack info
         *   - Then we patch the payload exception with the original RSI
         *
         * This is to work around the fact that the Rollbar code in _buildPayload
         * always does some parsing on the message and transforms
         * "Dataset not found: foo" into foo.
         *
         * So we basically redo the buildPayload/enqueuePayload dance
         */
        if (window.devInstance) {
            return;
        }

        const stackInfo = apiErrorToRollbarStackInfo(apiError);
        const payload = Rollbar._buildPayload(new Date(), "error", null, stackInfo, customData);
        const callerArgs = ["error", null, stackInfo, customData];

        if (payload.data.body.trace && payload.data.body.trace.exception) {
            payload.data.body.trace.exception["class"] = apiError.errorType;
            payload.data.body.trace.exception["message"] = apiError.message;
        }
        Rollbar._enqueuePayload(payload, false, callerArgs);
    }

    function apiErrorToError(apiError) {
        const rollbarFakeErr = new Error();
        rollbarFakeErr._savedStackTrace = apiErrorToRollbarStackInfo(apiError);
        return rollbarFakeErr;
    }

    const svc = {
        reportJSException: function(exception, cause) {
            if (window.devInstance) {
                console.info("Dev instance, not reporting JS error"); /*@console*/ // NOSONAR: OK to use console.
                return;
            }
            if (window.dkuAppConfig && !window.dkuAppConfig.udr) {
                console.info("Reporting is disabled, not reporting JS error"); /*@console*/ // NOSONAR: OK to use console.
                return;
            }
            console.info("Reporting JS exception", exception); /* @console */ // NOSONAR: OK to use console.

            try {
                const customData = {
                    errorOrigin: "js-error"
                }
                if (cause) {
                    customData.causedBy = cause;
                }
                Rollbar.error(exception, customData);
            } catch (e) {
                console.warn("Rollbar failure", e); /*@console*/ // NOSONAR: OK to use console.
            }
            try {
                const params = {
                    type: "js-error",
                    message: exception.message,
                    stack: exception.stack
                };
                _wt1Q.push(["trackEvent", params]);
            } catch (e) {
                console.info("WT1 failure", e); /*@console*/ // NOSONAR: OK to use console.
            }
        },
        reportReflectedEvent: function(event) {
            if (window.devInstance) {
                console.info("Dev instance, not reporting reflected event"); /*@console*/ // NOSONAR: OK to use console.
                return;
            }
            if (window.dkuAppConfig && !window.dkuAppConfig.udr) {
                console.info("Reporting is disabled, not reporting reflected event"); /*@console*/ // NOSONAR: OK to use console.
                return;
            }
            try {
                // const customData = {
                //     errorOrigin: "reflected-event"
                // }
                if (event.exception) {
                    reportAPIError(event.exception, event.customData);
                } else {
                    Rollbar.error(event.message, event.customData);
                }
            } catch (e) {
                console.warn("Rollbar failure", e); /*@console*/ // NOSONAR: OK to use console.
            }
        },
        reportBackendAPIError: function(apiError) {
            if (window.devInstance) {
                console.info("Dev instance, not reporting API error"); /*@console*/ // NOSONAR: OK to use console.
                return;
            }
            if (window.dkuAppConfig && !window.dkuAppConfig.udr) {
                console.info("Reporting is disabled, not reporting API error"); /*@console*/ // NOSONAR: OK to use console.
                return;
            }
            if (apiError.httpCode == 0) {
                console.info("HTTP status 0 (network error), not reporting it", apiError); /*@console */ // NOSONAR: OK to use console.
                return;
            }
            if (apiError.httpCode == 502) {
                console.info("HTTP Gateway Error, not reporting it", apiError); /*@console */ // NOSONAR: OK to use console.
                return;
            }
            try {
                const customData = {
                    errorOrigin: "internal-api-error",
                    httpCode: apiError.httpCode
                };
                reportAPIError(apiError, customData);
            } catch (e) {
                console.warn("Rollbar failure", e); /*@console*/ // NOSONAR: OK to use console.
            }

            /* Report to WT1 */
            try {
                const params = {
                    type: "api-error",
                    httpCode: this.fatalAPIError.httpCode,
                    errorType: this.fatalAPIError.errorType,
                    message: this.fatalAPIError.message,
                    stack: this.fatalAPIError.details
                }
                _wt1Q.push(["trackEvent", params]);
            } catch (e) {
            }
        },
        configure: function() {
            if (window.devInstance) {
                window.DKUErrorReporting = svc;
                return;
            }

            const appConfig = window.dkuAppConfig;
            const dssVersion = appConfig.version && appConfig.version.product_version ? appConfig.version.product_version : "0.0.0-unknown";
            const payload = {
                person: {
                    id: appConfig.dipInstanceId,
                },
                client: {
                    javascript: {
                        source_map_enabled: true,
                        code_version: dssVersion
                    }
                },
                dssVersion: dssVersion,
                code_version: dssVersion
            };
            if (appConfig.licenseKind) {
                payload.dssLicenseKind = appConfig.licenseKind;
            } else {
                console.warn("No license kind in", appConfig); /* @console */ // NOSONAR: OK to use console.
            }
            if (appConfig.distrib) {
                payload.bkdDistrib = appConfig.distrib;
                payload.bkdDistribVersion = appConfig.distribVersion;
            }
            if (appConfig.registrationChannel) {
                payload.regChannel = appConfig.registrationChannel;
            }

            if (appConfig.login) {
                payload.dssUser = appConfig.login.dkuHashCode();
            }

            let env;
            if (window.devInstance || dssVersion.includes("doesnotmatter") || dssVersion.includes("dev")) {
                env = "dev-instance";
            } else if (dssVersion.includes("on-demand") || dssVersion.includes("daily")) {
                env = "test";
            } else if (dssVersion.includes("alpha") || dssVersion.includes("beta") || dssVersion.includes("rc")) {
                env = "pre-release";
            } else {
                env = "production";
            }

            if (window.dkuAppConfig && window.dkuAppConfig.udr) {
                console.info("Loading Rollbar code"); /*@console*/ // NOSONAR: OK to use console.
                var _rollbarConfig = {
                    accessToken: "9193daa4de9e4aa38aac29a46e7c0c86",
                    captureUncaught: true
                };
                !function(r){function o(e){if(t[e])return t[e].exports;var n=t[e]={exports:{},id:e,loaded:!1};return r[e].call(n.exports,n,n.exports,o),n.loaded=!0,n.exports}var t={};return o.m=r,o.c=t,o.p="",o(0)}([function(r,o,t){"use strict";var e=t(1).Rollbar,n=t(2);_rollbarConfig.rollbarJsUrl=_rollbarConfig.rollbarJsUrl||"https://d37gvrvc0wt4s1.cloudfront.net/js/v1.8/rollbar.min.js";var a=e.init(window,_rollbarConfig),i=n(a,_rollbarConfig);a.loadFull(window,document,!_rollbarConfig.async,_rollbarConfig,i)},function(r,o){"use strict";function t(r){return function(){try{return r.apply(this,arguments)}catch(o){try{console.error("[Rollbar]: Internal error",o)}catch(t){}}}}function e(r,o,t){window._rollbarWrappedError&&(t[4]||(t[4]=window._rollbarWrappedError),t[5]||(t[5]=window._rollbarWrappedError._rollbarContext),window._rollbarWrappedError=null),r.uncaughtError.apply(r,t),o&&o.apply(window,t)}function n(r){var o=function(){var o=Array.prototype.slice.call(arguments,0);e(r,r._rollbarOldOnError,o)};return o.belongsToShim=!0,o}function a(r){this.shimId=++s,this.notifier=null,this.parentShim=r,this._rollbarOldOnError=null}function i(r){var o=a;return t(function(){if(this.notifier)return this.notifier[r].apply(this.notifier,arguments);var t=this,e="scope"===r;e&&(t=new o(this));var n=Array.prototype.slice.call(arguments,0),a={shim:t,method:r,args:n,ts:new Date};return window._rollbarShimQueue.push(a),e?t:void 0})}function l(r,o){if(o.hasOwnProperty&&o.hasOwnProperty("addEventListener")){var t=o.addEventListener;o.addEventListener=function(o,e,n){t.call(this,o,r.wrap(e),n)};var e=o.removeEventListener;o.removeEventListener=function(r,o,t){e.call(this,r,o&&o._wrapped?o._wrapped:o,t)}}}var s=0;a.init=function(r,o){var e=o.globalAlias||"Rollbar";if("object"==typeof r[e])return r[e];r._rollbarShimQueue=[],r._rollbarWrappedError=null,o=o||{};var i=new a;return t(function(){if(i.configure(o),o.captureUncaught){i._rollbarOldOnError=r.onerror,r.onerror=n(i);var t,a,s="EventTarget,Window,Node,ApplicationCache,AudioTrackList,ChannelMergerNode,CryptoOperation,EventSource,FileReader,HTMLUnknownElement,IDBDatabase,IDBRequest,IDBTransaction,KeyOperation,MediaController,MessagePort,ModalWindow,Notification,SVGElementInstance,Screen,TextTrack,TextTrackCue,TextTrackList,WebSocket,WebSocketWorker,Worker,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload".split(",");for(t=0;t<s.length;++t)a=s[t],r[a]&&r[a].prototype&&l(i,r[a].prototype)}return r[e]=i,i})()},a.prototype.loadFull=function(r,o,e,n,a){var i=function(){var o;if(void 0===r._rollbarPayloadQueue){var t,e,n,i;for(o=new Error("rollbar.js did not load");t=r._rollbarShimQueue.shift();)for(n=t.args,i=0;i<n.length;++i)if(e=n[i],"function"==typeof e){e(o);break}}"function"==typeof a&&a(o)},l=!1,s=o.createElement("script"),u=o.getElementsByTagName("script")[0],p=u.parentNode;s.crossOrigin="",s.src=n.rollbarJsUrl,s.async=!e,s.onload=s.onreadystatechange=t(function(){if(!(l||this.readyState&&"loaded"!==this.readyState&&"complete"!==this.readyState)){s.onload=s.onreadystatechange=null;try{p.removeChild(s)}catch(r){}l=!0,i()}}),p.insertBefore(s,u)},a.prototype.wrap=function(r,o){try{var t;if(t="function"==typeof o?o:function(){return o||{}},"function"!=typeof r)return r;if(r._isWrap)return r;if(!r._wrapped){r._wrapped=function(){try{return r.apply(this,arguments)}catch(o){throw o._rollbarContext=t()||{},o._rollbarContext._wrappedSource=r.toString(),window._rollbarWrappedError=o,o}},r._wrapped._isWrap=!0;for(var e in r)r.hasOwnProperty(e)&&(r._wrapped[e]=r[e])}return r._wrapped}catch(n){return r}};for(var u="log,debug,info,warn,warning,error,critical,global,configure,scope,uncaughtError".split(","),p=0;p<u.length;++p)a.prototype[u[p]]=i(u[p]);r.exports={Rollbar:a,_rollbarWindowOnError:e}},function(r,o){"use strict";r.exports=function(r,o){return function(t){if(!t&&!window._rollbarInitialized){var e=window.RollbarNotifier,n=o||{},a=n.globalAlias||"Rollbar",i=window.Rollbar.init(n,r);i._processShimQueue(window._rollbarShimQueue||[]),window[a]=i,window._rollbarInitialized=!0,e.processPayloads()}}}}]); // NOSONAR

                payload.environment = env;
                console.info("Configuring Rollbar: ", payload); /*@console*/ // NOSONAR: OK to use console.
                Rollbar.configure({
                    ignoredMessages: [
                        "NS_ERROR_NOT_CONNECTED:",
                        "ResizeObserver loop limit exceeded",
                        "ResizeObserver loop completed with undelivered notifications."
                    ],
                    payload: payload,
                    transform: function(payload) {
                        if (!payload || !payload.data || !payload.data.body || !payload.data.body.trace || !payload.data.body.trace.frames) return;
                        if (!payload.data.body.trace.extra || !payload.data.body.trace.extra.errorOrigin || payload.data.body.trace.extra.errorOrigin == "js-error") {
                            payload.data.body.trace.frames.forEach(function(frame) {
                                if (!frame.filename || typeof frame.filename != "string") return;
                                frame.filename = frame.filename.replace(urlWithProtocolAndHost(), "http://localhost:8082");
                            });
                        }
                    }
                });
            } else {
                console.info("Not loading Rollbar, error reporting disabled"); /*@console*/ // NOSONAR: OK to use console.
            }

            window.DKUErrorReporting = svc;
        }
    };
    return svc;
});

/*
WT1 is the service we use to send back usage statistics to Dataiku
*/
app.factory("WT1", function($rootScope, Logger) {
    let enabled = true;
    let configured = false;
    let unconfiguredCommands = [];

    window._wt1Q = [];

    // DSS Load identifier
    const DL_ID = (Math.random().toString(36)+'00000000000000000').slice(2, 12);

    return {
        configure: function() {
            const appConfig = $rootScope.appConfig;
            if (angular.isDefined(appConfig.dipInstanceId)) {
                _wt1Q.push(["setVisitorParam", "dipInstanceId", appConfig.dipInstanceId]);
            }
            if (appConfig.licenseKind) {
                _wt1Q.push(["setVisitorParam", "dssLicenseKind", appConfig.licenseKind]);
            } else {
                Logger.warn("No license kind in", appConfig);
            }
            if (appConfig.distrib) {
                _wt1Q.push(["setVisitorParam", "bkdDistrib", appConfig.distrib]);
                _wt1Q.push(["setVisitorParam", "bkdDistribVersion", appConfig.distribVersion]);
            }
            if (appConfig.registrationChannel) {
                _wt1Q.push(["setVisitorParam", "regChannel", appConfig.registrationChannel]);
            }
            _wt1Q.push(["setVisitorParam", "isAutomation", appConfig.isAutomation]);
            _wt1Q.push(["setVisitorParam", "dssVersion", appConfig.version && appConfig.version.product_version ? appConfig.version.product_version : "unknown"]);
            if (appConfig.login) {
                _wt1Q.push(["setSessionParam", "dssUser", appConfig.login.dkuHashCode()]);
                _wt1Q.push(["setVisitorParam", "vdssUser", appConfig.login.dkuHashCode()]);
            }
            if (!appConfig.udr || window.devInstance) {
                enabled = false;
            }
            configured = true;
            if (enabled) {
                for (const cmdIdx in unconfiguredCommands) {
                    _wt1Q.push(unconfiguredCommands[cmdIdx]);
                }
                /* Actually load track.js */
                (function() {
                    const script = document.createElement('script');
                    script.src = "//tracker.dataiku.com/js/track.js";
                    script.type = 'text/javascript';
                    script.async = "true";
                    const script0 = document.getElementsByTagName("script")[0];
                    script0.parentNode.insertBefore(script, script0);
                })();
            }
            // for non-angular stuff :/
            window.WT1SVC = this;
        },
        event: function(type, params) {
            if (window.devInstance) {
                const formattedDate = moment().format('HH:mm:ss.SSS');
                const prefix = '[' + formattedDate + ']';
                console.debug(prefix + " WT1: " + type, params); /*@console*/ // NOSONAR: OK to use console.
            }
            if (!enabled) {
                return;
            }
            if (angular.isUndefined(params)) {
                params = {};
            }
            params.type = type;
            if ($rootScope && $rootScope.appConfig && $rootScope.appConfig.login) {
                params.edssUser = $rootScope.appConfig.login.dkuHashCode();
            }

            if ($rootScope && $rootScope.appConfig && $rootScope.appConfig.hashedUserEmail) {
                params.hashedUserEmail = $rootScope.appConfig.hashedUserEmail;
            }
            if ($rootScope && $rootScope.appConfig && $rootScope.appConfig.userProfile) {
                params.userProfile = $rootScope.appConfig.userProfile.profile;
            }
            params.dlid = DL_ID;
            if (!configured) {
                // While it's not configured, we enqueue events
                // so that the session and visitor params are set
                // BEFORE we track the first state change event
                unconfiguredCommands.push(["trackEvent", params])
            } else {
                _wt1Q.push(["trackEvent", params]);
            }
        },
        setVisitorParam: function(key, value) {
            _wt1Q.push(["setVisitorParam", key, value]);
        },
        delVisitorParam: function(key) {
            _wt1Q.push(["delVisitorParam", key]);
        },
        setSessionParam: function(key, value) {
            _wt1Q.push(["setSessionParam", key, value]);
        },
        delSessionaram: function(key) {
            _wt1Q.push(["delSessionParam", key]);
        },
    };
});


app.directive("wt1ClickId", function(WT1) {
    return {
        restrict: 'A',
        link: function ($scope, element, attrs) {
            element.bind('click', function() {
                WT1.event("clicked-item", {"item-id": attrs.wt1ClickId});
            });
        }
    };
});
app.directive("wt1ClickEvent", function(WT1) {
    return {
        restrict: 'A',
        link: function ($scope, element, attrs) {
            element.bind('click', function() {
                WT1.event(attrs.wt1ClickEvent);
            });
        }
    };
});


app.factory("BackendReportsService", function($rootScope, $timeout, DataikuAPI, WT1, Logger, ErrorReporting) {
    $timeout(function() {
        if ($rootScope.appConfig && $rootScope.appConfig.loggedIn && $rootScope.appConfig.udr && !window.devInstance) {
            DataikuAPI.usage.popNextReport().success(function(data) {
                if (data.reportPublicId) {
                    Logger.info("sending report", data.reportType);
                    /* Something to send */
                    WT1SVC.event("v3-report", {
                        "reportType": data.reportType,
                        "reportId": data.reportPublicId,
                        "reportData": JSON.stringify(data.reportData)
                    });
                } else {
                    Logger.info("No report available");
                }
            });
        }

        if ($rootScope.appConfig && $rootScope.appConfig.loggedIn && $rootScope.appConfig.admin && $rootScope.appConfig.udr) {
            DataikuAPI.usage.popReflectedEvents().success(function(data) {
                data.events.forEach(function(evt) {
                    Logger.info("Reflecting event", evt);
                    if (evt.rollbarIt) {
                        ErrorReporting.reportReflectedEvent(evt);
                    }
                    WT1SVC.event("reflected-event", {
                        "reflectedEventData": JSON.stringify(evt)
                    });
                });
            });
        }

    }, 10000);
    return {
        //TODO this is actually not a service, it has no functionnality...
    };
});

})();



/// =================== Global ===================

window.WT1SVC = {
    event: function() {} // temporary before load
};

window.DKUErrorReporting = {
    reportBackendAPIError: function() {} // temporary before load
};


function setErrorInScope(data, status, headers, config, statusText, xhrStatus) {
    // Explicitely ignore JS errors by re-throwing
    // Allow using the function in catch() blocks like: .catch(setErrorInScope.bind($scope)) while having a clear stack trace
    // Whereas using .error(setErrorInScope.bind($scope)) expects `data` to be an http response
    if (data instanceof Error) {
        throw data;
    }

    if (status === undefined && headers === undefined) {
        status = data.status;
        headers = data.headers;
        data = data.data;
    }
    /* Put in bound scope */
    this.fatalAPIError = getErrorDetails(data, status, headers, statusText);
    this.fatalAPIError.html = getErrorHTMLFromDetails(this.fatalAPIError);

    /* Report to Rollbar */
    window.APIErrorLogger.error("API error", this.fatalAPIError);
    DKUErrorReporting.reportBackendAPIError(this.fatalAPIError);
}

function setErrorInScope2(payload) {
    setErrorInScope.call(this, JSON.parse(payload.response || '{}'), payload.status, h => payload.getResponseHeader(h));
}

function resetErrorInScope(scope) {
    if (scope.fatalAPIError) {
        scope.fatalAPIError.httpCode = null;
        scope.fatalAPIError.errorType = null;
    }
}

/* API error struct : {code, httpCode, message, details} */
function getErrorDetails(data, status, headers, statusText) {
    /* Network / HTTP error */
    if (data == null && status == -1) {
        return {
            httpCode: status,
            message: "Network error: " + (statusText === undefined ? "" : statusText),
            errorType: "XHRNetworkError"
        };
    }
    if (status == 413) {
        return {
            httpCode: status,
            message: data && data.message || 'No message',
            details: data && data.details || 'No details',
            errorType: "HTTPError413"
        };
    }

    if (data && data.$customMessage) {
        return {
            httpCode: status,
            code: 0,
            message: data.message || "Unknown error",
            details: data.details,
            errorType: data.errorType || "unknown"
        };
    }

    const ctype = headers("Content-type");
    if (ctype && ctype.startsWith("application/json") && data && data.errorType) {
        const apiError = data;
        apiError.httpCode = status;
        return apiError;
    } else {
        let errorType = "unknown";
        if (status == 502) {
            errorType = "Gateway error";
        }
        return {
            httpCode: status,
            code: 0,
            message: 'Unknown error',
            details: data && data.details || 'No details',
            errorType: errorType
        };
    }
}

function getErrorHTMLFromDetails(apiError) {
    let html = "<strong>Error " + apiError.code +": "+apiError.message +"</strong>";
    if (apiError.details) {
        html += "<pre>" + apiError.details +"</pre>";
    }
    return html;
}

function getErrorHTML(data, status, headers, statusText) {
    const apiError = getErrorDetails(data, status, headers, statusText);
    return getErrorHTMLFromDetails(apiError);
}

(function() {
'use strict';

const app = angular.module('ui.keypress',[]);
// forked from https://github.com/angular-ui/ui-utils


app.factory("KeyHandlingUtils", function($parse){
    var keysByCode = {
        8: 'backspace',
        9: 'tab',
        13: 'enter',
        27: 'esc',
        32: 'space',
        33: 'pageup',
        34: 'pagedown',
        35: 'end',
        36: 'home',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down',
        45: 'insert',
        46: 'delete'
    };
    var alpha = 'abcdefghijklmnopqrstuvwxyz';
    for(var i=alpha.length-1; i >=0; i--){
        keysByCode[i+65] = alpha[i];
    }

    var svc = {
        keysByCode : keysByCode,

        prepareCombinations : function(params){
            var combinations = [];
            angular.forEach(params, function (v, k) {
                var combination, expression;
                expression = $parse(v);
                angular.forEach(k.split(' '), function(variation) {
                    combination = {
                        expression: expression,
                        keys: {}
                    };
                    angular.forEach(variation.split('-'), function (value) {
                        combination.keys[value] = true;
                    });
                    combinations.push(combination);
                });
            });
            return combinations
        },

        isTriggered : function(event, combination) {
            var metaPressed = !!(event.metaKey && !event.ctrlKey);
            var altPressed = !!event.altKey;
            var ctrlPressed = !!event.ctrlKey;
            var shiftPressed = !!event.shiftKey;
            var keyCode = event.keyCode;

            // normalize keycodes
            if (!shiftPressed && keyCode >= 97 && keyCode <= 122) {
                keyCode = keyCode - 32;
            }
            var mainKeyPressed = combination.keys[keysByCode[keyCode]] || (keyCode && combination.keys[keyCode.toString()]);


            var metaRequired = !!combination.keys.meta;
            var altRequired = !!combination.keys.alt;
            var ctrlRequired = !!combination.keys.ctrl;
            var shiftRequired = !!combination.keys.shift;
            var ret =
                    mainKeyPressed &&
                    ( metaRequired === metaPressed ) &&
                    ( altRequired === altPressed ) &&
                    ( ctrlRequired === ctrlPressed ) &&
                    ( shiftRequired === shiftPressed )
            return ret;
        }

    }
    return svc;
});


app.directive("dkuLocalKeypress", function(KeyHandlingUtils, Logger){
 return {
        link: function (scope, elm, attrs) {
            var params = scope.$eval(attrs.dkuLocalKeypress);
            var combinations = KeyHandlingUtils.prepareCombinations(params);

            var cb = function(event) {
                combinations.forEach(function(comb) {
                    if (KeyHandlingUtils.isTriggered(event, comb)) {
                        Logger.info("Trigger", comb);
                        scope.$apply(function () {
                            comb.expression(scope, { '$event': event });
                        });
                        event.stopPropagation();
                        event.preventDefault();
                    };
                });
            }
            elm.on("keydown.dkuKeyPressDirective", cb);
            scope.$on('$destroy', function() {
                elm.off('keydown.dkuKeyPressDirective"', cb);
            });
        }
    };
});


app.factory('keypressHelper', ['$parse', 'KeyHandlingUtils', function keypress($parse, KeyHandlingUtils){
    var capitaliseFirstLetter = function (string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    };

    return function(mode, scope, elm, attrs, prefix, ignoreUpDown, inactiveWhenModal) {
        var params, combinations = [];
        params = scope.$eval(attrs[prefix+capitaliseFirstLetter(mode)]);

        // Prepare combinations for simple checking
        angular.forEach(params, function (v, k) {
            var combination, expression;
            expression = $parse(v);
            angular.forEach(k.split(' '), function(variation) {
                combination = {
                    expression: expression,
                    keys: {}
                };
                angular.forEach(variation.split('-'), function (value) {
                    combination.keys[value] = true;
                });
                combinations.push(combination);
            });
        });

        var callbackOnKeypress = function (event) {
        	if ( inactiveWhenModal ) {
            	if ($(document).find(".modal, .in").length > 0) {
            		// there is an open modal, let it handle the keypress
            		return;
            	}
        	}
            if (ignoreUpDown){
                if(['input','select'].indexOf(event.target.tagName.toLowerCase())!=-1) {
                    if(event.keyCode == 38 || event.keyCode == 40) {
                        return;
                    }
                }
            }
            // No need to do that inside the cycle
            var metaPressed = !!(event.metaKey && !event.ctrlKey);
            var altPressed = !!event.altKey;
            var ctrlPressed = !!event.ctrlKey;
            var shiftPressed = !!event.shiftKey;
            var keyCode = event.keyCode;
            if (keyCode === undefined) return; // seems to be common

            // normalize keycodes
            if (mode === 'keypress' && !shiftPressed && keyCode >= 97 && keyCode <= 122) {
                keyCode = keyCode - 32;
            }

            // Iterate over prepared combinations
            angular.forEach(combinations, function (combination) {
                var mainKeyPressed = combination.keys[KeyHandlingUtils.keysByCode[keyCode]] || combination.keys[keyCode.toString()];

                var metaRequired = !!combination.keys.meta;
                var altRequired = !!combination.keys.alt;
                var ctrlRequired = !!combination.keys.ctrl;
                var shiftRequired = !!combination.keys.shift;

                if (
                    mainKeyPressed &&
                    ( metaRequired === metaPressed ) &&
                    ( altRequired === altPressed ) &&
                    ( ctrlRequired === ctrlPressed ) &&
                    ( shiftRequired === shiftPressed )
                ) {
                    if (prefix == 'global'){
                        event.preventDefault();
                    }

                    // Run the function
                    scope.$apply(function () {
                        combination.expression(scope, { '$event': event });
                    });
                }
            });
        };

        // Check only matching of pressed keys one of the conditions
        elm.on(mode+'.keypressDirective', callbackOnKeypress);

        // This will unbind itself once the scope is destroyed
        scope.$on('$destroy', function() {
            elm.off('.keypressDirective', callbackOnKeypress);
        });
    };
}]);

/**
 * Bind one or more handlers to particular keys or their combination
 * @param hash {mixed} keyBindings Can be an object or string where keybinding expression of keys or keys combinations and AngularJS Exspressions are set. Object syntax: "{ keys1: expression1 [, keys2: expression2 [ , ... ]]}". String syntax: ""expression1 on keys1 [ and expression2 on keys2 [ and ... ]]"". Expression is an AngularJS Expression, and key(s) are dash-separated combinations of keys and modifiers (one or many, if any. Order does not matter). Supported modifiers are 'ctrl', 'shift', 'alt' and key can be used either via its keyCode (13 for Return) or name. Named keys are 'backspace', 'tab', 'enter', 'esc', 'space', 'pageup', 'pagedown', 'end', 'home', 'left', 'up', 'right', 'down', 'insert', 'delete'.
 * @example <input ui-keypress="{enter:'x = 1', 'ctrl-shift-space':'foo()', 'shift-13':'bar()'}" /> <input ui-keypress="foo = 2 on ctrl-13 and bar('hello') on shift-esc" />
 **/
app.directive('uiKeydown', ['keypressHelper', function(keypressHelper){
    return {
        link: function (scope, elm, attrs) {
            keypressHelper('keydown', scope, elm, attrs, 'ui');
        }
    };
}]);


app.directive('ui2Keydown', ['keypressHelper', function(keypressHelper){
    return {
        link: function (scope, elm, attrs) {
            keypressHelper('keydown', scope, elm, attrs, 'ui2', true);
        }
    };
}]);


app.directive('uiKeypress', ['keypressHelper', function(keypressHelper){
    return {
        link: function (scope, elm, attrs) {
            keypressHelper('keypress', scope, elm, attrs, 'ui');
        }
    };
}]);


app.directive('uiKeyup', ['keypressHelper', function(keypressHelper){
    return {
        link: function (scope, elm, attrs) {
            keypressHelper('keyup', scope, elm, attrs, 'ui');
        }
    };
}]);


app.directive('globalKeydown', ['keypressHelper', function(keypressHelper){
    return {
        link: function (scope, elm, attrs) {
            keypressHelper('keydown', scope, $(document), attrs, 'global');
        }
    };
}]);


app.directive('listenKeydown', ['keypressHelper', function(keypressHelper){
    return {
        link: function (scope, elm, attrs) {
            keypressHelper('keydown', scope, $(document), attrs, 'listen');
        }
    };
}]);

})();
(function() {
'use strict';


const app = angular.module('dataiku.common.nav');


    app.directive("navigatorObject", function(Navigator) {
        return {
            scope: true,
            restrict: 'A',
            controller: function($scope, $controller) {
                $controller('TaggableObjectPageMassActionsCallbacks', {$scope: $scope});
            },
            link: function(scope, element, attrs) {
                scope.Navigator = Navigator;

                Mousetrap.bind('shift+a', function() {
                    if (scope.datasetHooks && typeof scope.datasetHooks.userIsWriting == 'function' && scope.datasetHooks.userIsWriting()) {return;}
                    if (scope.isProjectAnalystRO() && (!attrs.navigatorDisabled || scope.$eval(attrs.navigatorDisabled))) {
                        Navigator.toggleForTopNav();
                    }
                });

                scope.$on('$destroy', function() {
                    Navigator.hide();
                    Mousetrap.unbind('shift+a');
                });
            }
        }
    });

    app.factory("Navigator", function ($rootScope, $stateParams, CreateCustomElementFromTemplate, DataikuAPI, $filter, Fn, $q) {
        var navScope, removeListener;

        // Dirty hack to hide the underneath right panel when the navigator's right panel is displayed [CH40012]
        // would be better to actually replace the navigator panel by the new right panel but let's leave that for Right Panel V2
        let toggleUnderneathRightPanelIfAny = (hide) => {
            let rightPanels = document.getElementsByClassName("right-panel");
            if (rightPanels && rightPanels.length > 0) {
                rightPanels[0].style.opacity = hide ? 0 : 1;
            }
        };

        var nav = {
            show: function (projectKey, objectType, objectId) {
                navScope = true; // Initialize navScope now to keep further calls to toggleForTopNav() from calling show() again, creating several navigator elements and scopes

                DataikuAPI.flow.recipes.getGraph(projectKey, null, false, false).success(function (data) {
                    toggleUnderneathRightPanelIfAny(true);
                    CreateCustomElementFromTemplate("/templates/navigator.html", $rootScope, "NavigatorController", function(newScope) {
                        navScope = newScope;
                        newScope.flow = data.serializedFilteredGraph.serializedGraph;
                        newScope.focus = {projectKey: projectKey, objectType: objectType, objectId: objectId};
                        newScope.init();
                    }, function(newEl) {
                        newEl.appendTo($('body'));
                    });
                }).noSpinner();
                Mousetrap.bind('esc', nav.hide);
                removeListener = $rootScope.$on("$stateChangeStart", nav.hide);
            },

            hide: function () {
                if (navScope && navScope.dismiss) {
                    toggleUnderneathRightPanelIfAny(false);
                    navScope.dismiss();
                    navScope = null;
                    Mousetrap.unbind('esc');
                }

                if (removeListener) removeListener();
            },

            toggleForTopNav: function () {
                if (navScope) return nav.hide();
                else return nav.show($stateParams.projectKey, $rootScope.topNav.item.type, $rootScope.topNav.item.id);
            },

            showForTopNav: function () {
                return nav.show($stateParams.projectKey, $rootScope.topNav.item.type, [$stateParams.sourceProjectKey,$rootScope.topNav.item.id].filter(Boolean).join("."));
            }
        };

        return nav;
    });


    app.controller("NavigatorController", function ($scope, DataikuAPI, $filter, getFlowNodeIcon, RecipesUtils, Navigator, QuickView) {
        $scope.Navigator = Navigator;

        $scope.getNodeColor = function (flowNode, focus) {
            if (!flowNode) {
                if (!focus) return;
                return focus.objectType.toLowerCase();
            }
            switch (flowNode.nodeType) {
                case 'RECIPE':
                    return $filter('recipeTypeToColor')(flowNode.recipeType);
                case 'LOCAL_DATASET':
                    return 'dataset';
                case 'LOCAL_SAVEDMODEL':
                    return 'saved-model';
                case 'LOCAL_MODELEVALUATIONSTORE':
                    return 'model-evaluation-store';
                case 'LOCAL_MANAGED_FOLDER':
                    return 'dataset';
                case 'LOCAL_STREAMING_ENDPOINT':
                    return 'black';
                default:
                    return 'black';
            }
        };

        $scope.getNodeIcon = function(flowNode, focus) {
            if (!flowNode) {
                if (!focus) return;
                return $filter('typeToIcon')(focus.objectType);
            }
            return getFlowNodeIcon(flowNode, false);
        };

        $scope.$on("change-context-focus", function (evt, target) {
            $scope.focus = target;
            updateContext();
        });

        $scope.selected = {};

        $scope.QuickView = QuickView;
        /*$scope.hoverIntentCallback = {
            show: function(projectKey, objectType, objectId) {
                $scope.selected.object = false;
                $scope.selected.type = objectType;
                $scope.selected.projectKey = projectKey;
                $scope.selected.objectId = objectId;
            },
            showObject: function(objectData, objectType) {
                $scope.selected.object = true;
                $scope.selected.item = {};
                $scope.selected.item[objectType.toLowerCase()] = objectData;
                $scope.selected.type = objectType;
            },
            hide: function() {
                $scope.selected.item = null;
                $scope.selected.objectId = null;
            }
        };*/

        var curToken = 0;
        var updateContext = function () {
            var reqToken = ++curToken;
            DataikuAPI.flow.getObjectContext($scope.focus.projectKey, $scope.focus.objectType, $scope.focus.objectId).success(function (data) {
                if (reqToken != curToken) return; // drop if not the most recent call
                $scope.context = data;
                if ($scope.focus.objectType == "RECIPE") {
                    RecipesUtils.parseScriptIfNeeded(data.nodes[data.focusNodeId]);
                }
            });
        };

        $scope.$watch("context", function (nv) {
            if (nv != null) {
                $scope.object = ($scope.context.nodes || {})[$scope.context.focusNodeId];
                $scope.node = ($scope.flow.nodes || {})[$scope.context.focusNodeId];
            }
        });

        $scope.$parent.init = updateContext;

        $scope.$on("$destroy", QuickView.hide);
    });

    app.directive("navigatorFlow", function (Fn, $filter, Navigator, StateUtils, $stateParams, getFlowNodeIcon, objectTypeFromNodeFlowType) {
        return {
            scope: {
                context: '=',
                flow: '='
            },
            restrict: 'A',
            link: function ($scope, element, attrs) {

                function endAll(transition, callback) {
                    if (transition.size() === 0) {
                        callback()
                    }
                    var n = 0;
                    transition
                        .each(function () {
                            ++n;
                        })
                        .each("end", function () {
                            if (!--n) callback.apply(this, arguments);
                        });
                }

                function translate(x, y) {
                    return 'translate(' + parseInt(x) + ',' + parseInt(y) + ')';
                }

                function parseTranslate(translate) {
                    if (!translate) return [0, 0];
                    var split = translate.split(',');
                    return [parseInt(split[0].split('(')[1]), parseInt(split[1])];
                }

                function flowNodeFromContextNode(id, contextNode) {
                    if (id.startsWith('insight_')) {
                        return {nodeType: 'INSIGHT', insightType: contextNode.insight.type, description: contextNode.insight.name, name: contextNode.insight.id, id: id};
                    } else if (id.startsWith('jupyterNotebook_')) {
                        return {nodeType: 'JUPYTER_NOTEBOOK', description: contextNode.notebook.name, name: contextNode.notebook.name, id: id};
                    }
                }

                var svg = d3.select(element[0]);

                var lineG = svg.append('g').attr('class', 'lines');
                var compG = svg.append('g').attr('class', 'computables');
                var runG = svg.append('g').attr('class', 'runnables');
                var compEls, runEls;

                var datasetInfos, recipeInfos, nodes, contextNodes, selectedNode;
                var runnables, computables, lines, drawing, flowLink;
                var centerNode, topNode;

                function draw() {
                    drawing = true;
                    if ($scope.flow.nodes) nodes = $scope.flow.nodes;
                    if ($scope.context.nodes) contextNodes = $scope.context.nodes;

                    var showFlowLink = true;
                    var height = $(svg[0][0]).height(),
                        width = $(svg[0][0]).width();

                    var blockSize = 72;
                    var margin = 0.3;

                    for (var node in nodes) {
                        delete nodes[node].left;
                        delete nodes[node].center;
                        delete nodes[node].drawn;
                    }

                    topNode = null;
                    centerNode = nodes[$scope.context.focusNodeId];
                    var objectData = contextNodes[$scope.context.focusNodeId];

                    runnables = [], computables = [], lines = [];

                    if (!centerNode) { // If the focus is on a non-flow item, we display it as topNode
                        if ($scope.context.focusNodeId.startsWith('insight')) {
                            computables.push(topNode = flowNodeFromContextNode($scope.context.focusNodeId, contextNodes[$scope.context.focusNodeId]));
                            topNode.center = true;
                            topNode.top = true;

                            centerNode = nodes[$scope.context.centerNodeId];

                            if (!centerNode) { // If the centerNode is a non-flow item as well
                                centerNode = flowNodeFromContextNode($scope.context.centerNodeId, contextNodes[$scope.context.centerNodeId]);
                                centerNode.center = true;
                                centerNode.top = false;
                                centerNode.predecessors = [];
                                centerNode.successors = [];
                                showFlowLink = false;
                            }

                            centerNode.clickable = true;
                            selectedNode = topNode;
                        } else if ($scope.context.focusNodeId.startsWith('analysis')) {
                            centerNode = nodes[objectData.datasetNodeId];
                            computables.push(topNode = {nodeType: 'ANALYSIS', description: objectData.analysis.name, center: true, top: true});
                            centerNode.clickable = true;
                            selectedNode = topNode;
                        } else if ($scope.context.focusNodeId.startsWith('jupyterNotebook')) {
                            if (objectData.datasetNodeId) {
                                centerNode = nodes[objectData.datasetNodeId];
                                computables.push(topNode = {nodeType: 'JUPYTER_NOTEBOOK', description: objectData.notebook.name, center: true, top: true});
                                centerNode.clickable = true;
                                selectedNode = topNode;
                            } else if (objectData.recipeNodeId) {
                                centerNode = nodes[objectData.recipeNodeId];
                                computables.push(topNode = {nodeType: 'JUPYTER_NOTEBOOK', description: objectData.notebook.name, center: true, top: true});
                                centerNode.clickable = true;
                                selectedNode = topNode;
                            } else {
                                showFlowLink = false;
                                centerNode = {nodeType: 'JUPYTER_NOTEBOOK', description: objectData.notebook.name, center: true, clickable: false, successors: [], predecessors: []};
                                computables.push(centerNode);
                                selectedNode = centerNode;
                            }
                        } else if ($scope.context.focusNodeId.startsWith('sqlNotebook')) {
                            if (objectData.datasetNodeId) {
                                centerNode = nodes[objectData.datasetNodeId];
                                computables.push(topNode = {nodeType: 'SQL_NOTEBOOK', description: objectData.notebook.name, center: true, top: true});
                                centerNode.clickable = true;
                                selectedNode = topNode;
                            } else {
                                showFlowLink = false;
                                centerNode = {nodeType: 'SQL_NOTEBOOK', description: objectData.notebook.name, center: true, clickable: false, successors: [], predecessors: []};
                                computables.push(centerNode);
                                selectedNode = centerNode;
                            }
                        }
//                    } else if (centerNode.datasetType == 'JobsDB') { // If the focus is on a metric dataset
//                        topNode = centerNode;
//                        topNode.center = true;
//                        topNode.top = true;
//                        topNode.metrics = true;
//                        computables.push(topNode);
//                        centerNode = nodes[objectData.datasetNodeId];
//                        centerNode.clickable = true;
//                        selectedNode = topNode;
                    } else {
                        centerNode.clickable = false;
                        selectedNode = centerNode;
                    }

                    var sides = [
                        {group: 'successors', left: 0, computables: 0, height: 0},
                        {group: 'predecessors', left: 1, computables: 0, height: 0}
                    ];

                    centerNode.center = true;
                    centerNode.drawn = true;
                    centerNode.runnableIdx = null;

                    var implicitRecipes = [];
                    if (centerNode.nodeType == 'RECIPE') {
                        runnables.push(centerNode);
                        sides.forEach(function (side) {
                            centerNode[side.group].forEach(function (id) {
                                nodes[id].left = side.left;
                                nodes[id].drawn = true;
                                nodes[id].idx = side.computables++;
                                nodes[id].runnableIdx = 0;
                                computables.push(nodes[id]);
                                lines.push([centerNode.id, id, false]);
                            });
                        });
                    } else {
                        computables.push(centerNode);
                        sides.forEach(function (side) {
                            centerNode[side.group].forEach(function (id, i) {
                                if (nodes[id].nodeType == 'RECIPE') {
                                    nodes[id].left = side.left;
                                    nodes[id].drawn = true;
                                    nodes[id].up = (i < centerNode[side.group].length / 2);
                                    runnables.push(nodes[id]);
                                    lines.push([id, centerNode.id, false]);
                                } else {
                                    var implicitRecipe = {id:'implicitRecipe_' + implicitRecipes.length, recipeType: 'aa', successors:[], predecessors:[]};
                                    implicitRecipes.push(implicitRecipe)
                                    implicitRecipe[side.group == 'successors' ? 'successors' : 'predecessors'] = [id];
                                    implicitRecipe.left = side.left;
                                    implicitRecipe.drawn = false;
                                    implicitRecipe.up = (i < centerNode[side.group].length / 2);
                                    runnables.push(implicitRecipe);
                                    lines.push([implicitRecipe.id, centerNode.id, true]);
                                }
                            });
                        });

                        runnables.forEach(function (runnable, i) {
                            runnable[sides[runnable.left].group].forEach(function (id) {
                                nodes[id].left = runnable.left;
                                nodes[id].drawn = true;
                                nodes[id].runnableIdx = i;
                                sides.forEach(function (side) {
                                    if (nodes[id].left == side.left) {
                                        nodes[id].idx = side.computables++;
                                    }
                                });
                                computables.push(nodes[id]);
                                lines.push([runnable.id, id, runnable.id.startsWith('implicitRecipe')]);
                            });
                        });
                    }

                    // Reduce the block size until both sides fit
                    sides.forEach(function (side) {
                        if (side.computables > 0) {
                            side.height = side.computables * blockSize + (side.computables - 1) * margin * blockSize;
                            while (side.height > 0.8 * $(element[0]).height()) {
                                blockSize--;
                                side.height = side.computables * blockSize + (side.computables - 1) * margin * blockSize;
                            }
                        }
                    });

                    sides.forEach(function (side) {
                        if (side.computables > 0) side.height = side.computables * blockSize + (side.computables - 1) * margin * blockSize;
                    });


                    var size = function (d) {
                        if (d.center) return 72;
                        else return blockSize;
                    };
                    var compTrY = function (d) {
                        return (height - sides[d.left].height) / 2 + d.idx * size(d) * (1 + margin);
                    };

                    var formats = {
                        foreignObject: function (sel) {
                            return sel.attr('x', function (d) {
                                return size(d) * 15 / 72;
                            })
                                .attr('y', function (d) {
                                    return size(d) * 16 / 72;
                                })
                                .attr('width', function (d) {
                                    return size(d) * 42 / 72;
                                })
                                .attr('height', function (d) {
                                    return size(d) * 42 / 72;
                                })
                                .style('font-size', function (d) {
                                    if (['LOCAL_SAVEDMODEL', 'FOREIGN_SAVEDMODEL', 'LOCAL_MODELEVALUATIONSTORE', 'FOREIGN_MODELEVALUATIONSTORE', 'LOCAL_MANAGED_FOLDER', 'FOREIGN_MANAGED_FOLDER'].indexOf(d.nodeType) > -1) {
                                        return size(d) + 'px';
                                    }
                                    return size(d) * 42 / 72 + 'px';
                                });
                        },

                        partitionedRect: function(sel, offset) {
                            return sel
                                .attr('x', (d) => {
                                    const onTop = d.nodeType === 'LOCAL_SAVEDMODEL' || d.nodeType === 'FOREIGN_SAVEDMODEL';
                                    return onTop ? 0 : offset;
                                })
                                .attr('y', offset)
                                .attr('width', size)
                                .attr('height', size)
                                .attr('class', 'fill node__rectangle--partitioned partitioning-indicator');
                        },

                        rescaleRect: function(sel) {
                            return sel
                                .attr('width', size)
                                .attr('height', size)
                                .attr('rx', function(d) {
                                    if (d.nodeType == 'INSIGHT') {
                                        return size(d)/8;
                                    }
                                });
                        },

                        rect: function (sel) {
                            return sel
                                .attr('width', size)
                                .attr('height', size)
                                .attr('class', function(d) {
                                    if (d.nodeType == 'INSIGHT') {
                                        return 'universe-fill ' + $filter('insightTypeToColor')(d.insightType);
                                    }
                                    if (d.partitioned) {
                                        const baseClasses = 'fill node__rectangle--partitioned ';
                                        if (d.nodeType == 'LOCAL_DATASET' || d.nodeType == 'FOREIGN_DATASET') {
                                            return baseClasses + 'main-dataset-rectangle';
                                        } else {
                                            return baseClasses + 'node__rectangle--blank';
                                        }
                                    }
                                })
                                .attr('rx', function(d) {
                                    if (d.nodeType == 'INSIGHT') {
                                        return size(d)/8;
                                    }
                                });
                        },

                        circle: function(sel) {
                            return sel
                                .attr('r', function (d) {
                                    return size(d) * 21 / 72;
                                })
                                .attr('cx', function (d) {
                                    return size(d) * 36 / 72;
                                })
                                .attr('cy', function (d) {
                                    return size(d) * 37 / 72;
                                });
                        },

                        iconsBg: function(sel) {
                            // A little hacky, append a white background with the correct shape behind managed folders & saved models transparent icons
                            var folders = sel.filter(function(d) {
                                return d.nodeType == 'LOCAL_MANAGED_FOLDER' || d.nodeType == 'FOREIGN_MANAGED_FOLDER';
                            });
                            if (folders.size()) {
                                var paths = folders.selectAll('path.bg-path').data([
                                    'M49.57,37.61L53.21,42h34l5.69-15.5-65.16-23L17.62,31H39C43.84,31,46.94,34.19,49.57,37.61Z',
                                    'M3.13,38.56V92.47c0,2.39,2.6,4.4,5.69,4.4H91.19c3.08,0,5.69-2,5.69-4.4V49.54c0-2.39-2.6-4.41-5.69-4.41H52.47a1.56,1.56,0,0,1-1.21-.57l-4.14-5c-2.51-3.26-4.83-5.4-8.12-5.4H8.81C5.73,34.15,3.13,36.17,3.13,38.56Z'
                                ]);
                                paths.enter().append('path').attr('class', 'bg-path')
                                    .attr('d', Fn.SELF)
                                    .attr('fill', 'white');
                                paths.attr('transform', function(d) { return 'scale(' + size(d)/100 + ')'; })

                            }
                            var models = sel.filter(function(d) {
                                return d.nodeType == 'LOCAL_SAVEDMODEL' || d.nodeType == 'FOREIGN_SAVEDMODEL';
                            });
                            if (models.size()) {
                                var paths = models.selectAll('path.bg-path').data([
                                    'M50,0L100,50L50,100L0,50z'
                                ]);
                                paths.enter().append('path').attr('class', 'bg-path')
                                    .attr('d', Fn.SELF)
                                    .attr('fill', 'white');
                                paths.attr('transform', function(d) { return 'scale(' + size(d)/100 + ')'; })
                            }
                            return sel;
                        },

                        compEl: function (sel) {
                            return sel.attr('transform', function (d, i) {
                                if (d.top) return translate((width - size(d)) / 2, 50);
                                if (d.center) return translate((width - size(d)) / 2, (height - size(d)) / 2);
                                return translate((width - size(d)) / 2 + (d.left ? -300 : 300), (height - sides[d.left].height) / 2 + d.idx * size(d) * (1 + margin));
                            }).attr('data-size', size);
                        },

                        runEl: function (sel) {
                            return sel.attr('transform', function (d, i) {
                                if (d.center) return translate((width - size(d)) / 2, (height - size(d)) / 2);

                                var childrenComps = computables.filter(function (c) {
                                    return c.runnableIdx === i;
                                });
                                var y = childrenComps.length == 0 ? (height - size(d)) / 2 : (compTrY(childrenComps[0]) + compTrY(childrenComps[childrenComps.length - 1])) / 2;
                                return translate((width - size(d)) / 2 + (d.left ? -200 : 200), y);
                            }).attr('data-size', size).style("display", function(d) {return d.drawn ? 'inline-block' : 'none'});
                        },

                        compTick: function (sel) {
                            return sel
                                .style("display", "none")
                                .filter(function (d) {
                                    return !d.center &&
                                        ((d.left && d.predecessors && d.predecessors.length)
                                        || (!d.left && d.successors && d.successors.length))
                                })
                                .style("display", null)
                                .attr('x1', function (d) {
                                    return d.left ? 0 : blockSize;
                                })
                                .attr('x2', function (d) {
                                    return d.left ? -15 : blockSize + 15;
                                })
                                .attr('y1', blockSize / 2)
                                .attr('y2', blockSize / 2 + 0.001)
                                .attr('stroke', function (d) {
                                    return d.left ? 'url(#grad-left-right)' : 'url(#grad-right-left)'
                                });
                        },

                        runTick: function (sel) {
                            return sel
                                .style("display", "none")
                                .filter(function (d) {
                                    return !d.center &&
                                        ((!d.left && d.predecessors && d.predecessors.length > 1)
                                        || (d.left && d.successors && d.successors.length > 1))
                                })
                                .style("display", null)
                                .style("stroke-width", "1.1px") //TODO @navigator css
                                .attr('x1', blockSize / 2)
                                .attr('x2', function (d) {
                                    return blockSize / 2 + (d.left ? blockSize / 2 : -blockSize / 2);
                                })
                                .attr('y1', blockSize / 2)
                                .attr('y2', function (d) {
                                    return blockSize / 2 + (d.up ? -blockSize / 2 : blockSize / 2);
                                })
                                .attr('stroke', function (d) {
                                    return !d.left ? 'url(#grad-left-right)' : 'url(#grad-right-left)'
                                });
                        }
                    };

                    compEls = compG.selectAll('g').data(computables, Fn.prop('id'));
                    runEls = runG.selectAll('g').data(runnables, Fn.prop('id'));
                    lines = lineG.selectAll('line.line').data(lines, function (d) {
                        return d[0] + ' ---> ' + d[1];
                    });

                    // 1. Remove exiting elements
                    compEls.exit().remove();
                    runEls.exit().remove();
                    lines.exit().remove();
                    if (datasetInfos) datasetInfos.remove();
                    if (recipeInfos) recipeInfos.remove();
                    if (flowLink) flowLink.remove();
                    svg.selectAll('line.dotted').remove();

                    // 2. Update existing elements
                    compEls.select('line.tick').style('display', 'none');
                    runEls.select('line.tick').style('display', 'none');
                    compEls.call(formats.iconsBg).transition().call(formats.compEl).call(endAll, enter);
                    compEls.select('rect').transition().call(formats.rescaleRect);
                    compEls.selectAll('rect.dataset-rectangle').transition().call(formats.rescaleRect);    // catch all 3 rectangles in case of a partitioned dataset.

                    compEls.select('foreignObject').transition().call(formats.foreignObject);

                    runEls.transition().call(formats.runEl);
                    runEls.select('circle').transition().call(formats.circle);
                    runEls.select('foreignObject').transition().call(formats.foreignObject);

                    runEls.order();
                    compEls.order();

                    // Update lines with a custom tween so that they stay connected to the centers of the 2 items during the transition
                    svg.selectAll('line.line').transition().tween("line", function (d) {
                        var run = runEls.filter(function (r) {
                            return r.id == d[0];
                        });
                        var comp = compEls.filter(function (c) {
                            return c.id == d[1]
                        });
                        return function () {
                            var runT = parseTranslate(run.attr('transform'));
                            var compT = parseTranslate(comp.attr('transform'));
                            var runS = run.attr('data-size');
                            var compS = comp.attr('data-size');
                            d3.select(this)
                                .attr('x1', runT[0] + runS / 2)
                                .attr('y1', runT[1] + runS / 2)
                                .attr('x2', compT[0] + compS / 2)
                                .attr('y2', compT[1] + compS / 2)
                                .attr('stroke', '#333');
                        }
                    });


                    function enter() {
                        // Create computables
                        var enteringCompEls = compEls.enter().append('g').attr('data-type', Fn.prop('nodeType')).call(formats.compEl).call(formats.iconsBg)
                            .on('click', function (d) {

                                if (d.center) {
                                    if (d.dblclick) {
                                        fakeClickOnLink(StateUtils.href.node(d), d3.event);
                                        Navigator.hide();
                                    }
                                    d.dblclick = true;
                                    setTimeout(function() { d.dblclick = false; }, 400);
                                }
                                d3.event.stopPropagation();

                                if (d.center && !d.clickable) return null;

                                // The objects start moving right away after the first click
                                // To make it easier to double click, any click on the svg works
                                svg.on('click.dblclick', function() {
                                    fakeClickOnLink(StateUtils.href.node(d), d3.event);
                                });
                                setTimeout(function() { svg.on('click.dblclick', null); }, 400);

                                return focusOnNode(d);
                            });


                        enteringCompEls.filter((d) => d.partitioned).append('rect').call(formats.partitionedRect, -10);
                        enteringCompEls.filter((d) => d.partitioned).append('rect').call(formats.partitionedRect, -5);

                        enteringCompEls.append('rect').call(formats.rect);

                        enteringCompEls.append('svg:foreignObject').call(formats.foreignObject)
                            .attr('class', 'nav-nodeicon').style('text-align', 'center')
                            .append('xhtml:div').append('xhtml:i').attr('class', function (d) {
                                if (d.nodeType == 'INSIGHT') {
                                    return $filter('insightTypeToIcon')(d.insightType);
                                }
                                return getFlowNodeIcon(d, true);
                        });

                        // Add tick
                        enteringCompEls.append('line').attr('class', 'tick');

                        // Create computables legend
                        datasetInfos = compEls
                            .append('svg:foreignObject').attr('class', 'dataset-info')
                            .attr('x', function (d) {
                                if (d.center) return -130;
                                else if (d.left) return (blockSize - width) / 2 + 300;
                                else return blockSize;
                            })
                            .attr('y', function (d, i) {
                                if (d.center) return size(d);
                                else return 0;
                            })
                            .attr('height', blockSize)
                            .attr('width', function (d) {
                                if (d.center) return 260 + size(d);
                                else return (width / 2 - 300 - 0.5 * blockSize);
                            })
                            .append('xhtml:div').classed('left', Fn.prop('left')).classed('center', Fn.prop('center'))
                            .style('height', blockSize + 'px')
                            .style('width', function (d) {
                                if (d.center) return 260 + size(d) + 'px';
                                else return (width / 2 - 300 - 0.5 * blockSize) + 'px';
                            });

                        datasetInfos.append('xhtml:h6').append('span').text(Fn.prop('description'));

                        var iconGroup = function (type, icon) {
                            return function (sel) {
                                var div = sel.append('xhtml:span').attr('class', 'count ' + type).style('display', 'none');
                                div.append('xhtml:i').attr('class', 'universe-color ' + type + ' ' + icon);
                                div.append('xhtml:span');
                                return sel;
                            }
                        };

                        datasetInfos.append('div').attr('class', 'counts').append('span').each(function (d) {
                            var p = d3.select(this);
                            switch (d.nodeType) {
                                case "LOCAL_DATASET":
                                case "FOREIGN_DATASET":
                                    p.call(iconGroup('analysis', 'icon-dku-nav_analysis'));
                                    p.call(iconGroup('chart', 'icon-dku-nav_dashboard'));
                                    p.call(iconGroup('notebook', 'icon-dku-nav_notebook'));
                                    break;
                                case "LOCAL_SAVEDMODEL":
                                    break;

                            }
                        });

                        enteringCompEls.filter('g[data-type="LOCAL_SAVEDMODEL"]').selectAll('rect')
                            .attr('transform', 'rotate(45) scale(0.7071) scale(1.05)');

                        // Create runnables
                        var enteringRunEls = runEls.enter().append('g').attr('class', function (d) {
                            return "bzicon recipeicon-" + (d.recipeType.indexOf("CustomCode_") == 0 ? 'custom-code' : (d.recipeType.indexOf("App_") == 0 ? "app" : d.recipeType))
                        }).call(formats.runEl);

                        enteringRunEls.append('line').attr('class', 'tick');

                        enteringRunEls.append('circle').call(formats.circle);
                        enteringRunEls
                            .append('svg:foreignObject').call(formats.foreignObject)
                            .attr('class', 'recipe-icon')
                            .classed("custom-code", function(d) { return d.recipeType.indexOf("CustomCode_") == 0; })
                            .append('xhtml:div')
                            .style('text-align', 'center').append('xhtml:i')
                            .attr('class', function (d) {
                                return $filter('recipeTypeToIcon')(d.recipeType);
                            });

                        enteringRunEls
                            .on('click', function (d) {
                                d3.event.stopPropagation();

                                if (d.center) {
                                    if (d.dblclick) {
                                        fakeClickOnLink(StateUtils.href.node(d), d3.event);
                                        Navigator.hide();
                                    }
                                    d.dblclick = true;
                                    setTimeout(function() { d.dblclick = false; }, 400);
                                }

                                if (d.center && !d.clickable) return null;

                                // The objects start moving right away after the first click
                                // To make it easier to double click, any click on the svg works
                                svg.on('click.dblclick', function() {
                                    fakeClickOnLink(StateUtils.href.node(d), d3.event);
                                });
                                setTimeout(function() { svg.on('click.dblclick', null); }, 400);

                                return focusOnNode(d);
                            });

                        // Create legend for center recipe
                        recipeInfos = runEls.filter(function(d) { return d.center; })
                            .append('svg:foreignObject').attr('class', 'dataset-info')
                            .attr('x', -130)
                            .attr('y', function(d) { return size(d) - 20; })
                            .attr('height', blockSize)
                            .attr('width', function (d) { return 260 + size(d); })
                            .append('xhtml:div').attr("class", "center")
                            .style('height', blockSize + 'px')
                            .style('width', function (d) { return 260 + size(d) + 'px'; });

                        recipeInfos.append('xhtml:h6').append('span').text(Fn.prop('description'));


                        lines.enter().append('line').attr('class', 'line').each(function (d) {
                            var run = runEls.filter(function (r) {
                                return r.id == d[0];
                            });
                            var comp = compEls.filter(function (c) {
                                return c.id == d[1]
                            });
                            var runT = parseTranslate(run.attr('transform'));
                            var compT = parseTranslate(comp.attr('transform'));
                            d3.select(this)
                                .attr('x1', runT[0] + run.attr('data-size') / 2)
                                .attr('y1', runT[1] + run.attr('data-size') / 2)
                                .attr('x2', compT[0] + comp.attr('data-size') / 2)
                                .attr('y2', compT[1] + comp.attr('data-size') / 2)
                                .attr('stroke', '#333')
                                .attr('stroke-dasharray', d[2] ? 4 : null);
                        });

                        if (topNode) {
                            svg.append('line').attr('class', 'vertical')
                                .attr('class', 'dotted')
                                .attr('x1', width/2)
                                .attr('x2', width/2)
                                .attr('y1', (height - 72) / 2 - 20)
                                .attr('y2', topNode.metrics ? 190 : 165)
                                .attr('stroke', '#AAA')
                                .attr('stroke-dasharray', 4);
                        }

                        if (showFlowLink) {
                            svg.append('line').attr('class', 'vertical')
                                .attr('class', 'dotted')
                                .attr('x1', width/2)
                                .attr('x2', width/2)
                                .attr('y1', centerNode.nodeType === 'RECIPE' ? (height/2) + 60 : height/2 + 110)
                                .attr('y2', height-70)
                                .attr('stroke', '#AAA')
                                .attr('stroke-dasharray', 4);

                            const contextProjectKey = $scope.context && $scope.context.projectKey ? $scope.context.projectKey : centerNode.projectKey;
                            flowLink = svg.append("foreignObject")
                                .attr("class", "flowLink")
                                .attr("x", width/2 - 50)
                                .attr("width", 100)
                                .attr("height", 30)
                                .attr("y", height - 50)
                                .append("xhtml:a")
                                    .attr("class", "btn btn--secondary")
                                    .attr("href", StateUtils.href.flowLink(centerNode, contextProjectKey))
                                    .text("View in flow");
                        }

                        compEls.selectAll('line.tick').call(formats.compTick);
                        runEls.selectAll('line.tick').call(formats.runTick);

                        writeCounts();
                        updateSelection();

                        drawing = false;
                    }
                }

                /* Keyboard navigation */
                var middle = function (arr) {
                    return arr[Math.floor((arr.length - 1) / 2)];
                };

                var mousetrap = new Mousetrap;

                mousetrap.bind('left', function () {
                    if (drawing) return;
                    if (selectedNode.top) return;
                    if (!selectedNode.center && selectedNode.left && !selectedNode.recipeType) return focusOnNode(selectedNode);

                    var els = selectedNode.predecessors.map(function (id) {
                        return nodes[id];
                    }).filter(function (n) {
                        return n.drawn;
                    });
                    if (!els.length) {
                        if (selectedNode.center) return false;
                        return focusOnNode(selectedNode);
                    }

                    selectedNode = middle(els);
                    updateSelection();
                    return false;
                });

                mousetrap.bind('right', function () {
                    if (drawing) return;
                    if (selectedNode.top) return;
                    if (!selectedNode.center && !selectedNode.left && !selectedNode.recipeType) return focusOnNode(selectedNode);

                    var els = selectedNode.successors.map(function (id) {
                        return nodes[id];
                    }).filter(function (n) {
                        return n.drawn;
                    });
                    if (!els.length) {
                        if (selectedNode.center) return false;
                        return focusOnNode(selectedNode);
                    }

                    selectedNode = middle(els);
                    updateSelection();
                    return false;
                });

                mousetrap.bind('up', function () {
                    if (drawing) return;
                    if (selectedNode.center) {
                        if (!selectedNode.top) {
                            if (topNode) selectedNode = topNode;
                            else return;
                        }
                    } else {
                        var siblings;
                        if (selectedNode.nodeType === 'RECIPE') {
                            siblings = runnables;
                        } else {
                            siblings = computables;
                        }

                        siblings = siblings.filter(function (s) {
                            return s.left == selectedNode.left && !s.center;
                        });
                        var idx = siblings.indexOf(selectedNode);

                        if (idx == 0) return false;
                        selectedNode = siblings[idx - 1];

                    }

                    updateSelection();
                    return false;
                });

                mousetrap.bind('down', function () {
                    if (drawing) return;
                    if (selectedNode.center) {
                        if (selectedNode.top) {
                            selectedNode = centerNode;
                        } else {

                        }
                    } else {
                        var siblings;
                        if (selectedNode.nodeType === 'RECIPE') {
                            siblings = runnables;
                        } else {
                            siblings = computables;
                        }

                        siblings = siblings.filter(function (s) {
                            return s.left == selectedNode.left && !s.center;
                        });
                        var idx = siblings.indexOf(selectedNode);

                        if (idx == siblings.length - 1) return false;
                        selectedNode = siblings[idx + 1];
                    }
                    updateSelection();
                    return false;
                });

                mousetrap.bind('enter', function (e) {
                    fakeClickOnLink(StateUtils.href.node(selectedNode), e);
                    Navigator.hide();
                    return false;
                });

                mousetrap.bind('space', function (e) {
                    if (selectedNode.center && !selectedNode.clickable) return false;
                    return focusOnNode(selectedNode);
                });

                element.on("$destroy", function () {
                    mousetrap.reset();
                });
                $scope.$on("$destroy", function () {
                    mousetrap.reset();
                });

                // TODO sucks
                var updateCount = function (type, attr) {
                    var span = compEls.select('span.count.' + type);
                    span.select('span')
                        .text(function (d) {
                            if (!$scope.context.nodes[d.id]) {
                                return null;
                            } else if (!$scope.context.nodes[d.id].hasOwnProperty(attr)) {
                                return $scope.context.nodes[d.id][attr.substr(3).toLowerCase()].length; // TODO mucho sucks!!
                            }
                            return $scope.context.nodes[d.id][attr];
                        });
                    span.style('display', function (d) {
                        if (d.center || !$scope.context.nodes[d.id]) return null;
                        return $scope.context.nodes[d.id][attr] ? null : 'none';
                    });
                };

                var updateSelection = function () {
                    compEls.classed('selected', function (d) {
                        return d === selectedNode;
                    });
                    runEls.classed('selected', function (d) {
                        return d === selectedNode;
                    });
                };

                function writeCounts() {
                    if (!$scope.context || !$scope.context.nodes) return;
                    updateCount('analysis', 'numAnalyses');
                    updateCount('chart', 'numCharts');
                    updateCount('notebook', 'numNotebooks');
                    d3.select('body').style('test', 'test');
                }

                var focusOnNode = function(node) {
                    $scope.context = {focusNodeId: node.id};
                    $scope.$apply();
                    $scope.$emit("change-context-focus", {
                        projectKey: $stateParams.projectKey || node.projectKey,
                        objectType: objectTypeFromNodeFlowType(node.nodeType),
                        objectId: node.nodeType == 'FOREIGN_DATASET' ? node.description : node.name
                    });
                    return false;
                };

                d3.select(window).on("resize.navigator", draw);
                $scope.$on('$destroy', function() {
                    d3.select(window).on("resize.navigator", null);
                });

                $scope.$watch("context", function (nv, ov) {
                    if (!nv || !nv.focusNodeId) return;
                    if (!ov || nv.focusNodeId != ov.focusNodeId) draw();
                    else writeCounts();
                });
            }
        }
    });

    // TODO FlowUtils?
    app.factory("getFlowNodeIcon", function ($filter) {
        return function (node, inFlow) {
            if (!node) return;
            switch (node.nodeType) {
                case 'RECIPE':
                    return $filter('recipeTypeToIcon')(node.recipeType);
                case 'LOCAL_DATASET':
                case 'FOREIGN_DATASET':
                    return $filter('datasetTypeToIcon')(node.datasetType);
                case 'LOCAL_SAVEDMODEL':
                case 'FOREIGN_SAVEDMODEL':
                    return node.smType == 'CLUSTERING' ? 'icon-machine_learning_clustering' : 'icon-machine_learning_regression';
                case 'LOCAL_MODELEVALUATIONSTORE':
                case 'FOREIGN_MODELEVALUATIONSTORE':
                    return "icon-model-evaluation-store";
                case 'LOCAL_MANAGED_FOLDER':
                case 'FOREIGN_MANAGED_FOLDER':
                    return inFlow ? 'icon-flow_dataset_folder' : 'icon-flow_dataset_folder';
                case 'LOCAL_STREAMING_ENDPOINT':
                    return $filter('datasetTypeToIcon')(node.streamingEndpointType);
                    
                // extra nodes in navigator
                case 'ANALYSIS':
                    return 'icon-dku-nav_analysis';
                case 'JUPYTER_NOTEBOOK':
                case 'SQL_NOTEBOOK':
                    return 'icon-dku-nav_notebook';
            }
        }
    });

    // TODO FlowUtils?
    app.factory("objectTypeFromNodeFlowType", function() {
        var types = {
            "LOCAL_SAVEDMODEL": "SAVED_MODEL",
            "FOREIGN_SAVEDMODEL": "SAVED_MODEL",
            "LOCAL_MODELEVALUATIONSTORE": "MODEL_EVALUATION_STORE",
            "FOREIGN_MODELEVALUATIONSTORE": "MODEL_EVALUATION_STORE",
            "LOCAL_DATASET": "DATASET",
            "FOREIGN_DATASET": "DATASET",
            "LOCAL_MANAGED_FOLDER": "MANAGED_FOLDER",
            "FOREIGN_MANAGED_FOLDER": "MANAGED_FOLDER",
            "LOCAL_STREAMING_ENDPOINT": "STREAMING_ENDPOINT",
            "RECIPE": "RECIPE"
        };

        return function(nodeFlowType) {
            return types[nodeFlowType] || nodeFlowType;
        }
    });
})();
(function() {
'use strict';

let app = angular.module('dataiku.controllers');

const tileTypes =  {
    myItem: "my-item",
    project: "project",
    app: "app",
    dashboard: "dashboard",
    promotedWiki: "promoted-wiki",
    skeleton: "skeleton",
    projectFolders: "project-folders",
};

const exportedTiles = [
    { heading: "Projects", type: tileTypes.project },
    { heading: "Applications", type: tileTypes.app },
    { heading: "Project Folders", type: tileTypes.projectFolders },
    { heading: "Dashboards", type: tileTypes.dashboard },
    { heading: "Wikis", type: tileTypes.promotedWiki },
    // Always add new tiles at the end
];

// Export some tiles to the settings
app.constant("EXPORTED_TILES", exportedTiles);

const personalHomeRefreshEvents = {
    project: 'project-home-list-refresh',
    app: 'app-home-list-refresh',
    starred: 'starred-home-list-refresh',
    dashboard: 'dashboard-home-list-refresh',
    promotedWiki: 'promoted-wiki-home-list-refresh',
    projectFolders: 'project-folders-home-list-refresh',
};

app.service('PersonalHomeService', function($rootScope, DataikuAPI, Logger, HistoryService, DKUConstants) {
    const svc = this;
    const noSpinner = true;

    /* subscribe-style wrapper for notifications
     *
     */
    let subscribe = (function() {
        let unregisterMap = {};

        /**
         * Return an ID for a specific callerScope and eventName combination.
         * @param callerScope
         * @param eventName
         */
        function getSubscriptionId(callerScope, eventName) {
            return callerScope.$id + "_" + eventName;
        };

        /**
         * If an unregister function was registered to a specific callerScope and eventName combination, it is executed
         * before being removed from unregisterMap.
         * @param callerScope
         * @param eventName
         */
        function unregisterIfAny(callerScope, eventName) {
            let subscriptionId = getSubscriptionId(callerScope, eventName);
            let unregister = unregisterMap[subscriptionId];
            if (typeof(unregister) === "function") {
                unregister();
            }
            delete unregisterMap[subscriptionId];
        };

        /**
         * Map callerScope and eventName to an unregister function.
         * If an unregister function was already mapped to that combination, it is executed before being replaced by the new function.
         * @param callerScope
         * @param eventName
         * @param unregister
         */
        function setUnregisterFn(callerScope, eventName, unregister) {
            let subscriptionId = getSubscriptionId(callerScope, eventName);
            unregisterIfAny(callerScope, eventName);
            unregisterMap[subscriptionId] = unregister;
            callerScope.$on('$destroy', () => {
                unregisterIfAny(callerScope, eventName);
            });
        }

        /**
         * Add a listener to rootScope to execute a callback function (passed in parameter) for a specific event (passed in parameter).
         * If the same scope (passed in parameter) registers another callback to the same event,
         * we make sure the previous callback is removed from rootScope's callback stack for this specific event.
         * @param callerScope: scope asking to register a callback
         * @param eventName: event that will trigger the callback
         * @param callback: callback executed when the event is triggered
         */
        let subscribe = function(callerScope, eventName, callback) {
            let unregister = $rootScope.$on(eventName, callback);
            setUnregisterFn(callerScope, eventName, unregister);
        }

        return subscribe;
    })();

    function notify(eventName, data, errorLoading) {
        $rootScope.$emit(eventName, {data: data, errorLoading: errorLoading});
    }

    /* data used to populate tile lists is held separately, allowing
    * some cross populations:
    *  - starred data into projects, dashboards, recently used
    *  - project titles into other items
    *  - recently used dates into other items
    */
     const defaultloadedItems = {
        recentlyUsed: {
            byType: [], // ie dashboards, myitems, projects
            map: {}
        },
        starred: {
            byType: [],
            map: {},
        },
        projects: {
            list: [],
            map: {},
        },
        apps: {
            list: [],
            map: {},
        },
        dashboards: {
            list: [],
            map: {}
        },
        promotedWikis: {
            list: [],
            map: {}
        },
        projectFolders: {
            list: [],
            map: {}
        },
    };

    let loadedItems = {};

    svc.clearData = function() {
        angular.copy(defaultloadedItems, loadedItems);
    };

    /**
     * Recently used items are an extract of the local HistoryService. Depending on the type of item
     * we are interested in when it was last view or when it was last edited
     */
    /*NOSONAR function trackItemByViewDate(item) {
        return ['DASHBOARD', 'REPORT', 'PROJECT' ].includes(item.type)
    }*/

    function getRowForItemType(type, isPromotedWiki) {
        switch (type) {
            case 'PROJECT':
                return tileTypes.project;
            case 'APP':
                return tileTypes.app;
            case 'DASHBOARD':
                return tileTypes.dashboard;
            case 'ARTICLE':
                return isPromotedWiki ? tileTypes.promotedWiki : tileTypes.myItem;
            default:
                return tileTypes.myItem;
        }
    }

    function initByTypeLists(listsRoot) {
        listsRoot.isLoaded = false;
        Object.keys(tileTypes).forEach(element => {
            listsRoot.byType[tileTypes[element]] = []
        });
        listsRoot.map = {};
    }


    function taggableItemKey(interest) {
        return interest.projectKey + ':' + interest.type + ':' + interest.id;
    }

    /** Enrich other lists with data from newlty populated lists
     *  Specifically, we want to add project names into the list of starred items,
     *  and the starred/watched data into projects, dashboards and recently used items
     *
     * @param lists = the lists to be enriched
     * @param f = the function to enrich an item, typically using the .map of the source objects
     *
     */
    function enrichLists(lists, f) {
        let enriched = false;
        lists.forEach(list => {
            if (!list) return;
            angular.forEach(list, item => {
                enriched |= f(item)
            });
        });
        return enriched;
    }

    /**
     *  enrichMapFromRecentlyUsedItems - enrich a list of projects, starred items or dashboards with info
     *  from the recentlyused list - specifically the usage datetime
     * @param listType - one of tileTypes enum
     * @param map - a map of items (projects, dashboards etc) in the loadedItems structure
     * @param fKey - a function get the key into the map from a recently used item
     */
    function enrichMapFromRecentlyUsedItems(listType, map, fKey) {
        if (!loadedItems.recentlyUsed.byType.hasOwnProperty(listType)) return;

        loadedItems.recentlyUsed.byType[listType].forEach(item => {
            const key = fKey(item);
            if (map.hasOwnProperty(key)) {
                enrichItemFromRecentlyUsed(map[key], item);
            } else {
                // looks like invalid History item that no longer exists
                HistoryService.notifyRemoved(item);
                item.isDeleted = true;
            }
        });
    }

    function findItemViaMap(sourceItem, map) {
        const key = sourceItem.mapKey || taggableItemKey(sourceItem);
        if (!map.hasOwnProperty(key)) return;
        return map[key];
    }

    function enrichItemFromStarred(otherItem, starredItem) {
        if (!starredItem) starredItem = findItemViaMap(otherItem, loadedItems.starred.map);
        if (!starredItem) return;

        otherItem.starred = starredItem.starred;
        otherItem.watching = starredItem.watching;
    }

    function enrichItemFromRecentlyUsed(otherItem, ruListItem) {
        if (!ruListItem) ruListItem = findItemViaMap(otherItem, loadedItems.recentlyUsed.map);
        if (!ruListItem) return;

        otherItem.myItemsDate = ruListItem.myItemsDate;
        otherItem.isRecentlyUsed = true;
    }

    function enrichItemFromProject(item) {
        let isEnriched = false;
        if (loadedItems.projects.list.length==0) return false; // projects not loaded yet (or simply none)

        if (loadedItems.projects.map.hasOwnProperty(item.projectKey)) {
            const project = loadedItems.projects.map[item.projectKey];


            if (project.name != item.projectName) {
                item.projectName = project.name;
                isEnriched = true;
            }

            if (item.isRecentlyUsed && item.type == "PROJECT" && !item.lastCommit) {
                item.lastCommit = project.lastCommit;
                isEnriched = true;
            }

            if (isEnriched && item.isRecentlyUsed) {
                HistoryService.recordEnrichment(item);
            }

        } else if (item.isRecentlyUsed) {
            // project should exist, assume deleted project - looks like invalid History item that no longer exists
            HistoryService.notifyRemoved(item);
            item.isDeleted = true;
            isEnriched = true;
            loadedItems.recentlyUsed.isStale = true;
        }
        return isEnriched;
    }

    function enrichItemFromPromotedWiki(item) {
        if (loadedItems.promotedWikis.list.length==0) return; // wikis not loaded yet (or simply none)

        if (item.type=="ARTICLE") {
            const key = promotedWikiKey(item.projectKey, item.id);
            if (loadedItems.promotedWikis.map.hasOwnProperty(key)) {
                const wiki = loadedItems.promotedWikis.map[key];
                let isEnriched = false;

                if (wiki.homeArticle.object.id == item.id && !item.isPromotedWiki) {
                    item.isPromotedWiki = true;
                    isEnriched = true;
                }

                if (isEnriched && item.isRecentlyUsed) {
                    HistoryService.recordEnrichment(item);
                }

                if (item.isRecentlyUsed) loadedItems.recentlyUsed.isStale = true;
            }
            return item;
        }
    }

    /* end enrichment functions */

    /**
     * recentlyUsedAlignProperties
     * Tidy up the items from the HistoryService so their properties match with all the other
     * tile data items used.
     * @param item - item from the HistoryService
     * @returns 'aligned' item
     */
    function recentlyUsedAlignProperties(item) {
        const LOADING_PLACEHOLDER = "Loading...";
        //NOSONAR const isTrackByView = trackItemByViewDate(item);

        item.isRecentlyUsed = true;
        item.myItemsDate = item.lastViewed; //NOSONAR isTrackByView ?  item.lastViewed : item.lastUpdated;

        if (!item.projectName) item.projectName = LOADING_PLACEHOLDER;
        item.catalogItemType = item.type.toLowerCase();

        if (!item.displayName && item.id) item.displayName = item.id;
        item.displayName = item.displayName.replace(/_/g, " ");

        switch (item.type) {

            case "DATASET":
                item.datasetType = item.type_raw = item.subtype; // datasetType used by right-column controllers, type_raw is used by the CatalogItemService
                break;

            case "STREAMING_ENDPOINT":
                item.streamingType = item.type_raw = item.data.type;
                break;

            case "RECIPE":
                item.recipeType = item.type_raw = item.subtype;
                break;

            case "INSIGHT":
                item.name = item.displayName;
                item.insightType = item.type_raw = item.subtype;
                break;

            case "MANAGED_FOLDER":
                if (!item.description) item.description = item.displayName;
                item.type_raw = item.type;
                break;

            case "PROJECT":
                item.name = item.data.name || item.projectName;
                item.objectImgHash = item.data.objectImgHash;
                item.defaultImgColor = item.data.defaultImgColor;
                item.shortDesc = item.data.shortDesc;
                item.description = item.data.description;
                item.projectStatus = item.data.projectStatus;
                item.type_raw = item.type;
                break;

            case "APP":
                item.type_raw = item.type;
                break;

            case "DASHBOARD":
                item.type_raw = item.type;
                item.pages = item.data.pages;
                break;

            case "ARTICLE":
                item.type_raw = item.type;
                item.name = item.id;
                break;

            case "JOB":
                item.type_raw = undefined; //ignore these items
                break;

            case "CONTINUOUS_ACTIVITY":
                item.id = item.data.name;
                break;

            default:
                if (item.type.indexOf("NOTEBOOK") >= 0) {
                    item.catalogItemType = "notebook";
                    if (!item.type_raw) item.type_raw = item.type;
                }
                else {
                    item.type_raw = item.type;
                }
        }

        if (item.type_raw) {
            item.tileType = getRowForItemType(item.type, item.isPromotedWiki);
            if (!item.name && item.id) item.name = item.id;
            enrichItemFromProject(item);
        }

        return item;
    }

    /**
     * getRecentlyUsedItems
     * Gets the recently-used item history for the user from the HistoryService.  This holds the
     * data in localstorage. Unlike the other data 'gets' this is synchronous and fast.
     * We split the data into three lists suitable for the row tile rows: my-items, projects and dashboards.
     * It's not really critical to do this, but simplifies the controller a little.
     *
     * @returns {{byType: Array, map: {}}|recentlyUsed|{byType, map}}
     */
    svc.getRecentlyUsedItems = function(forceReload) {
        if (!forceReload && loadedItems.recentlyUsed.isLoaded) return loadedItems.recentlyUsed;

        initByTypeLists(loadedItems.recentlyUsed);
        const ruItems = loadedItems.recentlyUsed;

        HistoryService.getRecentlyViewedItems(undefined, undefined, undefined, true).forEach( (item) => {
            try {
                if (!item.hasOwnProperty("projectKey")) return; // unclear where these come from, but irritating!

                item = recentlyUsedAlignProperties(item);

                // Don't load archived projects from recently-used
                if (item.type_raw == "PROJECT" && item.projectStatus == DKUConstants.ARCHIVED_PROJECT_STATUS) {
                    return;
                }

                if (item.type_raw && !ruItems.map.hasOwnProperty(item.key)) { //missing subtype can lead to missing type_raw; ignore these items //skip duplicates
                    ruItems.byType[item.tileType].push(item);
                    ruItems.map[item.key] = item;
                }
            } catch (e) {
                Logger.error(e);
            }
        });

        Object.keys(ruItems.byType).forEach(function (key) {
            ruItems.byType[key] = ruItems.byType[key].filter(item => !item.isDeleted && item.myItemsDate>0);
            ruItems.byType[key].sort((a,b) => b.myItemsDate - a.myItemsDate)
        });

        ruItems.isLoaded = true;
        return ruItems;
    };

    svc.discardRecentlyusedItem = function (item) {
        HistoryService.notifyRemoved(item);
        svc.getRecentlyUsedItems(true);
        refreshMyItemsList();
    };

    /*************************
     *
     * Stared item ('Interests') data processing
     *
     */

    /**
     * interestAlignProperties
     *
     * Tidy up an starred interest item so that it has a set of properties consistent data retrieved from
     * other sources such as Catalog.
     *
     * @param interest - the original format data for one starred interest as returnd by the REST API
     * @returns interest data with properties aligned to usage by the personal home page
     */

    function interestAlignProperties(interest) {

        interest.catalogItemType = interest.objectType.toLowerCase();
        interest.displayName = interest.details.objectDisplayName ? interest.details.objectDisplayName.replace(/_/g, " ") : interest.objectId;
        if (!interest.name) interest.name = interest.details.objectDisplayName || interest.objectId;

        interest.lastModifiedOn  = interest.modifiedDate;
        interest.type = interest.objectType;
        interest.id = interest.objectId;
        interest.tileType = getRowForItemType(interest.type);

        if (interest.type=="DATASET")  {
            interest.datasetType = interest.details.datasetType; //used by right-column controllers
            interest.type_raw = interest.datasetType;  //type_raw is used by the CatalogItemService
        } else if (interest.type=="STREAMING_ENDPOINT")  {
            interest.streamingType = interest.details.streamingType;
            interest.type_raw = interest.streamingType;  //type_raw is used by the CatalogItemService
        } else if(interest.type=="RECIPE") {
            interest.recipeType = interest.details.recipeType;
            interest.type_raw = interest.recipeType;

        } else if (interest.type=="INSIGHT")  {
            interest.name = interest.details.objectDisplayName;
            interest.insightType = interest.details.insightType;
            interest.type_raw = interest.insightType;

        } else if (interest.type.indexOf("NOTEBOOK") >=0) {
            interest.catalogItemType = "notebook";
            if (!interest.type_raw) interest.type_raw = interest.type;

        } else if (interest.type == "MANAGED_FOLDER") {
            if (!interest.description) interest.description = interest.displayName;
        }

        interest.mapKey = taggableItemKey(interest);
        enrichItemFromProject(interest);

        return interest;
    }

    /**
     * buildMyItemsList
     * Join the recently used data (excluding projects and dashboards)
     * with the starred data. This is the myItems row data
     *
     * @returns list of items to populate the myItems row
     */
    function buildMyItemsList() {
        const MAX_RECENTLY_USED_IN_MY_ITEMS = 10;

        let starredMyItems = loadedItems.starred.byType[tileTypes.myItem];
        if (!starredMyItems) starredMyItems = [];

        const totalStarred = starredMyItems.length;

        //list is combination of recentlyUsed and starred items
        const ruItems = loadedItems.recentlyUsed.byType[tileTypes.myItem];
        const list = ruItems.slice(0, totalStarred==0 ? undefined : MAX_RECENTLY_USED_IN_MY_ITEMS).filter(item => !item.isDeleted && item.myItemsDate>0 && !item.isPromotedWiki);

        starredMyItems.forEach(item => {
            if (ruItems.map(item => item.key).indexOf(item.mapKey) == -1) list.push(item);
        });
        list.forEach((item, idx) => item.ordinal = idx); //add key for 'recently-used' sort order
        return list;
    }

    /**
     * updateListsDependingOnStarredData
     * if we have already receieved the projects/dashboards then we need enrich those list and re-sort,
     * since starred items get priority over non-starred.
     * The revised list will then need to be displayed, so notify the watchers.
     */
    function updateListsDependingOnStarredData() {
        enrichLists([loadedItems.recentlyUsed.map, loadedItems.projects.map, loadedItems.dashboards.map], enrichItemFromStarred);
        sortDashboardItems();
        sortProjectItems();

        if (loadedItems.dashboards.list.length>0) notify(personalHomeRefreshEvents.dashboard, loadedItems.dashboards.list);
        if (loadedItems.projects.list.length>0) notify(personalHomeRefreshEvents.project, loadedItems.projects.list);
    }

    function refreshMyItemsList() {
        loadedItems.recentlyUsed.isStale = false;
        notify(personalHomeRefreshEvents.starred, buildMyItemsList());
    }

    /**
     * getStarredItems
     * Get the users 'interests' data - both starred and watches.  The REST API does not provide a way to get just the
     * starred items and adding it is non-trivial. Currently considered by CS to not be worth effort since watches rarely used.
     *
     * @param callback - the onRowDataRefreshed function in the controller to repopulate the tile lists
     * @param callerScope -  the scope of the caller.
     * @returns a promise to complete when the data is received and processed.  Not used currently by controller, which now
     *          uses the subscribe/notify mechanism only, since this deals with refreshes, dependong on the order data is received
     */
    svc.getStarredItems = function(callback, callerScope) {
        const INTERESTS_PAGE_SIZE = 100; //only get 100 stars max.  Seems reasonable?
        const INTERESTS_OFFSET = 0;

        subscribe(callerScope, personalHomeRefreshEvents.starred, callback);

        return DataikuAPI.interests.getUserInterests($rootScope.appConfig.login, INTERESTS_OFFSET, INTERESTS_PAGE_SIZE, undefined, true, noSpinner).then((data) => {

            initByTypeLists(loadedItems.starred);

            data.data.interests.forEach(function(interest) {
                if (!interest.starred) return;

                interest = interestAlignProperties(interest);
                loadedItems.starred.byType[interest.tileType].push(interest);
                loadedItems.starred.map[taggableItemKey(interest)] = interest;
            });

            updateListsDependingOnStarredData();

            notify(personalHomeRefreshEvents.starred, buildMyItemsList());

        }, () => setErrorInScope.bind(callerScope));
    };


    /***************************
     *
     * Dashboard data processing
     *
     */

    /**
     * dashboardAlignProperties
     *
     * Tidy up the dashboard items from the Catalog so their properties match with all the other
     * tile data items used, and the needs of the dashboard tiles e.g. miniatureBoxes
     *
     * @param dashboard - returned from the Catalog
     * @returns 'aligned' item
     */
    function dashboardAlignProperties (dashboard) {
        dashboard.tileType = tileTypes.dashboard;
        dashboard.type = "DASHBOARD";
        dashboard.displayName = dashboard.name;
        dashboard.catalogItemType = 'dashboard';
        dashboard.mapKey = taggableItemKey(dashboard);

        const tiles = [];
        if (dashboard.miniatureBoxes) {
            const boxLayouts = JSON.parse(dashboard.miniatureBoxes);
            boxLayouts.boxes.forEach((box, i) => {
                tiles.push({'box': box, insightType: boxLayouts.insightTypes[i]});
            });
        }
        dashboard.pages = [{'grid': {'tiles': tiles}}];
    }

    /**
     * sortDashboardItems
     * Order: recently used; starred; most recently modified (by anyone)
     */
    function sortDashboardItems() {

        loadedItems.dashboards.list.sort((a,b) => {
            //recently used at the front
            if (a.isRecentlyUsed != b.isRecentlyUsed) return a.isRecentlyUsed ? -1 : 1;
            if (a.isRecentlyUsed) return b.myItemsDate - a.myItemsDate ;

            //starred status ahead of non-starred
            if (a.starred != b.starred) return a.starred ? -1 : 1;

            return b.lastModifiedOn - a.lastModifiedOn;
        });
    }

    /**
     * getDashboardItems
     * Retrieve the dashboard items from the Catalog.
     *
     * @param callback - callback function for the notification
     * @param callerScope - scope of the caller
     * @returns promise to complete then the data is processed.  Not used by the controller, which now uses notifications.
     */
    svc.getDashboardItems = function(callback, callerScope) {
        subscribe(callerScope, personalHomeRefreshEvents.dashboard, callback);

        return DataikuAPI.catalog.listDashboards().then((data) => {
            loadedItems.dashboards.list = [];
            loadedItems.dashboards.map = {};

            const dashboardHits = data.data.hits.hits;
            const list = loadedItems.dashboards.list;
            const map = loadedItems.dashboards.map;

            angular.forEach(dashboardHits, function(dashboardHit) {
                const dashboard = dashboardHit._source;
                dashboardAlignProperties(dashboard);
                enrichItemFromStarred(dashboard);
                list.push(dashboard);
                map[dashboard.mapKey] = dashboard;
            });

            enrichMapFromRecentlyUsedItems(tileTypes.dashboard, loadedItems.dashboards.map, item => item.key);
            sortDashboardItems();

            notify(personalHomeRefreshEvents.dashboard, loadedItems.dashboards.list);

        }, () => {
            notify(personalHomeRefreshEvents.dashboard, [], true);
            setErrorInScope.bind(callerScope)}
        );
    };

    /***************************
     *
     * Projects data processing
     */

    /**
     * projectAlignProperties
     *
     * Tidy up the project items so their properties match with all the other
     * tile data items used
     *
     * @param project item
     * @returns 'aligned' item
     */
    function projectAlignProperties(project) {
        project.tileType = tileTypes.project;
        project.type = "PROJECT";
        project.id = project.projectKey;
        project.mapKey = taggableItemKey(project);
    }

    /**
     * sortProjectItems
     * Order:
     * - recently used;
     * - starred; projects
     * - updated  by the user (user update time order);
     * - projects not update by the user (time last updated order)
     */
    function sortProjectItems () {

        const compareCommitObjTimes = function (a, b, prop) {
            const aObj = a[prop];
            const bObj = b[prop];

            if (aObj && !bObj) return -1;
            if (!aObj && bObj) return 1;

            if (aObj && bObj) {
                return aObj.time==bObj.time ? 0 : (aObj.time > bObj.time ? -1 : 1);
            }
            return undefined;
        };

        loadedItems.projects.list.sort((a,b) => {
            //recently used status
            if (a.isRecentlyUsed != b.isRecentlyUsed) return a.isRecentlyUsed ? -1 : 1;
            if (a.isRecentlyUsed) return b.myItemsDate - a.myItemsDate ;

            //starred status
            if (a.starred != b.starred) return a.starred ? -1 : 1;

            // last update times - by current user else generally
            let result = compareCommitObjTimes(a, b, "lastCommitForUser");
            if (result!= undefined) return result;

            result = compareCommitObjTimes(a, b, "lastCommit");
            if (result!= undefined) return result;

            // backstop in case we don't have sensible data
            return a.name == b.name ? 0 : (a.name < b.name ? -1 : 1);

        });
    }

    /**
     * getProjectItems
     * Get list of projects
     * @param callback - callback function for the notification
     * @param callerScope - scope of the caller
     * @returns promise to complete then the data is processed.  Not used by the controller, which now uses notifications.
     */
    svc.getProjectItems = function(callback, callerScope) {
        if (callback) subscribe(callerScope, personalHomeRefreshEvents.project, callback);

        return DataikuAPI.projects.listExtended(true, noSpinner).then(function(data) {
            loadedItems.projects.list = [];
            loadedItems.projects.map = {};

            const projects = data.data;
            const list = loadedItems.projects.list;
            const map = loadedItems.projects.map;

            projects.forEach(function(project) {
                projectAlignProperties(project);
                enrichItemFromStarred(project);
                list.push(project);
                map[project.id] = project;
            });

            enrichMapFromRecentlyUsedItems(tileTypes.project, loadedItems.projects.map, item => item.projectKey);
            sortProjectItems();

            // Don't show archived projects on personal home page
            loadedItems.projects.list = loadedItems.projects.list.filter(p => p.projectStatus !=  DKUConstants.ARCHIVED_PROJECT_STATUS);

            // enrich the other lists with project data
            const isEnriched = enrichLists([loadedItems.recentlyUsed.map, loadedItems.starred.map], enrichItemFromProject);
            if (isEnriched || loadedItems.recentlyUsed.isStale) refreshMyItemsList();

            notify(personalHomeRefreshEvents.project, loadedItems.projects.list);
        }, () => setErrorInScope.bind(callerScope));
    };

   /***************************
     *
     * Apps data processing
     */

    /**
     * appAlignProperties
     *
     * Tidy up the project items so their properties match with all the other
     * tile data items used
     *
     * @param project item
     * @returns 'aligned' item
     */
    function appAlignProperties(app) {
        app.tileType = tileTypes.app;
        app.type = "APP";
        app.id = app.appId;
        app.disableStar = true;
        app.mapKey = taggableItemKey(app);
    }

    /**
     * sortAppItems
     * Order:
     * - recently used;
     * - starred; projects
     * - updated  by the user (user update time order);
     * - projects not update by the user (time last updated order)
     */
    function sortAppItems () {

        loadedItems.apps.list.sort((a,b) => {
            // backstop in case we don't have sensible data
            let al = (a.label || a.id).toLowerCase()
            let bl = (b.label || b.id).toLowerCase()
            return al == bl ? 0 : (al < bl ? -1 : 1);
        });
    }

    /**
     * getAppItems
     * Get list of apps
     * @param callback - callback function for the notification
     * @param callerScope - scope of the caller
     * @returns promise to complete then the data is processed.  Not used by the controller, which now uses notifications.
     */
    svc.getAppItems = function(callback, callerScope) {
        if (callback) subscribe(callerScope, personalHomeRefreshEvents.app, callback);

        return DataikuAPI.apps.listTemplates(noSpinner).then(function(data) {
            loadedItems.apps.list = [];
            loadedItems.apps.map = {};

            const apps = data.data.items;
            const list = loadedItems.apps.list;
            const map = loadedItems.apps.map;
            apps.forEach(function(app) {
                appAlignProperties(app);
                list.push(app);
                map[app.appId] = app;
            });

            sortAppItems();

            notify(personalHomeRefreshEvents.app, loadedItems.apps.list);
        }, () => setErrorInScope.bind(callerScope));
    };


        /**
     * getProjectItems
     * Get list of projects
     * @param callback - callback function for the notification
     * @param callerScope - scope of the caller
     * @returns promise to complete then the data is processed.  Not used by the controller, which now uses notifications.
     */
    svc.getProjectFolderItems = (callback, callerScope) => {
        if (callback) {
            subscribe(callerScope, personalHomeRefreshEvents.projectFolders, callback);
        }
        return DataikuAPI.projectFolders.listExtended(noSpinner).then(data => {
            loadedItems.projectFolders.list = data.data.map(e => {
                const mergedItems = e.projects.map(p => Object.assign({ itemType: 'project' }, p)).concat(e.folder.children.map(f => Object.assign({ itemType: 'folder' }, f)));
                const filteredItems = mergedItems.slice(0, mergedItems.length > 6 ? 5 : 6);
                let path = '';
                let parent = e.folder.parent;
                do {
                    path = (!parent.name && !parent.parent ? 'Projects' : parent.name) + (path == '' ? '' : ' > ') + path;
                    parent = parent.parent;
                } while (parent);
                return Object.assign({path: path}, e.folder, { tileType: tileTypes.projectFolders,  type: "PROJECT_FOLDERS", filteredItems: filteredItems, nbExtraItems: mergedItems.length - filteredItems.length, disableStar: true, nbFolders: e.folder.children.length, nbProjects: e.projects.length});
            });
            loadedItems.projectFolders.map = {};

            notify(personalHomeRefreshEvents.projectFolders, loadedItems.projectFolders.list);
        }, () => setErrorInScope.bind(callerScope));
    };


    /***************************
     *
     * Promoted wiki data processing
     */


    function getPromotedWikiDate(promotedWiki) {
        if (promotedWiki.homeArticle &&  promotedWiki.homeArticle.object) return promotedWiki.homeArticle.object.creationTag.lastModifiedOn;
        return 0;
    }

    /**
     * promotedWikiAlignProperties
     *
     * Tidy up the promoted wiki items so their properties match with all the other
     * tile data items used
     *
     * @param promotedWiki item
     * @returns 'aligned' item
     */
    function promotedWikiAlignProperties(promotedWiki) {
        promotedWiki.tileType = tileTypes.promotedWiki;
        promotedWiki.type = "ARTICLE"; //Well, OK, it's not, but that's where you want to redirect
        setWikiDisplayNameAndId(promotedWiki);
        promotedWiki.mapKey = taggableItemKey(promotedWiki);
        promotedWiki.disableStar = true;
        promotedWiki.myItemsDate = getPromotedWikiDate(promotedWiki);
        promotedWiki.catalogItemType = promotedWiki.type.toLowerCase();
        promotedWiki.name = promotedWiki.displayName;
    }

    /**
     * setWikiDisplayNameAndId
     *
     * Set the diplayName and the id of the wiki. Check if the wiki has at least one article.
     * 
     *
     * @param promotedWiki item
     */
    function setWikiDisplayNameAndId(promotedWiki) {
        if (promotedWiki.homeArticle) {
            promotedWiki.id = promotedWikiKey(promotedWiki.projectKey, promotedWiki.homeArticle.object.id);
            promotedWiki.displayName = promotedWiki.homeArticle.object.id;
        } else {
            promotedWiki.id = promotedWiki.projectKey;
            promotedWiki.displayName = promotedWiki.projectKey
        }
    }

    /**
     * sortPromotedWikiItems
     * Order: recently used; then in the myItemsdate.
     * This is  the recently-used date where available, or the lastModifiedBy
     * in the promoted wiki record.
     *
     */
    function sortPromotedWikiItems() {

        loadedItems.promotedWikis.list.sort((a,b) => {
            //recently used at the front
            if (a.isRecentlyUsed != b.isRecentlyUsed) return a.isRecentlyUsed ? -1 : 1;
            return a.myItemsDate - b.myItemsDate;
        });
    }

    function promotedWikiKey(projectKey, articleId) {
        return projectKey + ":" + articleId;
    }
    /**
     * getPromotedWikiItems
     * Get list of projects
     * @param callback - callback function for the notification
     * @param callerScope - scope of the caller
     * @returns promise to complete then the data is processed.  Not used by the controller, which now uses notifications.
     */
    svc.getPromotedWikiItems = function(callback, callerScope) {
        if (callback) subscribe(callerScope, personalHomeRefreshEvents.promotedWiki, callback);

        return DataikuAPI.projects.listPromotedWikis(true, noSpinner).then(function(data) {
            loadedItems.promotedWikis.list = [];
            loadedItems.promotedWikis.map = {};

            const wikis = data.data.wikis;
            const list = loadedItems.promotedWikis.list;
            const map = loadedItems.promotedWikis.map;

            wikis.forEach(function(wiki) {
                promotedWikiAlignProperties(wiki);
                list.push(wiki);
                map[wiki.id] = wiki;
            });

            enrichMapFromRecentlyUsedItems(tileTypes.promotedWiki, loadedItems.promotedWikis.map, item => promotedWikiKey(item.projectKey, item.id));
            sortPromotedWikiItems();

            // enrich the other lists with promoted wiki data
            enrichLists([loadedItems.recentlyUsed.map], enrichItemFromPromotedWiki);

            if (loadedItems.recentlyUsed.isStale) refreshMyItemsList(); // needed when enrichment detects stale ru item data

            notify(personalHomeRefreshEvents.promotedWiki, loadedItems.promotedWikis.list);
        }, () => setErrorInScope.bind(callerScope));
    };



});

app.controller('PersonalHomeController', function($scope, $state, $rootScope, $timeout, WT1, TopNav, CreateModalFromTemplate, Fn, DKUConstants, TaggingService, HomePageContextService, PersonalHomeService, DataikuAPI, HomeBehavior, Throttle) {

    const throttle = Throttle().withScope($scope).withDelay(200);
    // Root allows us to detect the need for a login without first redirecting to home
    if ($state.current.name == "root") {
        $state.go('home');
        return;
    }

    // Automation node as Deployer
    if  ($rootScope.appConfig.isAutomation && !$rootScope.appConfig.projectsModuleEnabled) {
        $state.go('deployer');
        return;
    }

    /*
     * UI Models
     */

    const MAX_RECENTLY_USED_PER_ROW = 8;

    const dataLoadStates = {
        none: 0,
        partial: 1, //standalone mode
        full: 2
    };

    const tileDisplayModes = {
        oneRowOfTiles : "null",
        rowsOfTiles: "row",
        rectangleOfTiles: "mosaic",
        listOfText: "list"
      };

    const infoPaneModes = {
        initial : 'initial',
        expanded : 'expanded',
        compressed : 'compressed'
    };

    const rowTypes = {
        myItems: "my-items",
        projects: "projects",
        apps: "apps",
        dashboards: "dashboards",
        promotedWikis: "wikis",
        projectFolders: "project-folders",
    };

    const tileRowIds = {
        myItems: 0,
        myProjects: 1,
        myApps: 2,
        projectFolders: 3,
        myDashboards: 4,
        myPromotedWikis: 5,
    };

    const defaultSharedUiState = {
        shared : {
            searchFilter: "",
            gettingStartedTabIdx: 0,
            infoPaneMode: infoPaneModes.initial,
            infoPaneModeComplete: infoPaneModes.initial
        }
    };

    const defaultUiStateForRoute = {
        showTileRow: 0,
        tileDisplayMode: tileDisplayModes.rowsOfTiles
    };

    const displayModeByRouteName = {
        "home" : tileDisplayModes.rowsOfTiles,
        "home.expandedlist" : tileDisplayModes.listOfText,
        "home.expandedmosaic": tileDisplayModes.rectangleOfTiles,
        "wikis.list" : tileDisplayModes.listOfText, //standalone mode
        "wikis": tileDisplayModes.rectangleOfTiles //standalone mode
    };

    $scope.uiState = angular.extend ({} , defaultSharedUiState, defaultUiStateForRoute);
    let dataLoadState = dataLoadStates.none;

    /*
     * Info pane
     */

    /**
     * Add or remove an overlay between "getting started with DSS" panel and the rest of the screen to prevent tiles / list
     * items from being clicked when this panel is expanded
     * @param isDisable
     */
    let toggleOverlay = function(isDisable) {
        $('.pane-top-glass.full-screen').css('display', isDisable ? 'block' : 'none');
    };

    $scope.$on('lock-overlay', (event, isLock) => {
        toggleOverlay(isLock);
    });

    $scope.clickOnOverlay = function(event) {
        $scope.toggleInfoPane(event, false);
        $scope.$broadcast("overlay-clicked");
    }

    /**
     * Change inforPane size according to uiState.shared.infoPaneMode
     * @param to
     */
    let refreshInfoPaneSize = function () {
        const modes = infoPaneModes;
        const mode = $scope.uiState.shared.infoPaneMode;
        $rootScope.$broadcast('dismissPopovers');

        $('.pane-bottom').removeClass(modes.initial + " " + modes.expanded + " " + modes.compressed)
            .addClass(mode)
            .one("transitionend", () => toggleOverlay(mode==infoPaneModes.expanded));

        $scope.uiState.shared.infoPaneModeComplete = mode;
    };

    let isGrowInfoPaneEnabled = true; //will be disabled when user is dragging row to scroll them horizontally
    $scope.$on('onDragScrollAction', function(event, args) {
        isGrowInfoPaneEnabled = !args.isDragging;
    });

    /**
     * Grow or compress the info pane, depending on the value of isGrow.
     * If isGrow is undefined, infoPane will be reversed.
     * @param e: the event that triggered this function
     * @params: isGrow
     */
    $scope.toggleInfoPane = function(e, isGrow) {
        if (!isGrowInfoPaneEnabled) return;

        const ui = $scope.uiState;
        if (isGrow == undefined) isGrow = (ui.shared.infoPaneMode == 'compressed');

        const newMode = isGrow ? infoPaneModes.expanded: infoPaneModes.compressed;
        if (ui.shared.infoPaneMode==newMode) return;

        ui.shared.infoPaneMode = newMode;
        refreshInfoPaneSize();

        if (!!isGrow && ui.activeRoute.tileDisplayMode==tileDisplayModes.oneRowOfTiles) ui.activeRoute.tileDisplayMode = tileDisplayModes.rowsOfTiles;
        e.stopPropagation();
        $timeout(saveUiState, 600);
    };

    $scope.isInfoPaneVisible = function (){
        return $scope.uiState.shared.infoPaneModeComplete != infoPaneModes.compressed;
    };

    /*
     * Utils
     */

    /**
     * Scroll personal home page to i in pixels
     * @param i
     */
    let scrollPaneTopTo = function(i) {
        $('.pane-top').scrollTop(i);
    };

    $scope.isThemed = function () {
        return !!$rootScope.appConfig.theme;
    };

    /*
     * Switching view mode (rows, mosaic, list)
     */

    /**
     * Return 'my-items', 'projects', 'dashboards', 'wikis', or 'home',
     * depending on what state of the personal home page we are.
     * @returns {string}
     */
    function getStateRoute() {
        return $state.params && $state.params.row ? $state.params.row : 'home';
    }

    function isArrivingFromHomePages(fromState) {
        return ['ProjectsListController', 'PersonalHomeController', 'ProjectFolderController', 'AppsListController'].includes(fromState.controller);
    }

    /**
     * Configure uiState depending on the current route
     * @param fromState
     */
    function setUIState(fromState) {
        const route = getStateRoute();
        $scope.uiState = HomePageContextService.getFullCtx(fromState);
        $scope.uiState.activeRoute = $scope.uiState[route];

        if (!$scope.uiState.shared || !$scope.uiState.shared.hasOwnProperty("infoPaneMode")) {
            angular.extend($scope.uiState, defaultSharedUiState);
        }
        if (!$scope.uiState[route] || !$scope.uiState[route].hasOwnProperty("tileDisplayMode")) {
            if (!$scope.uiState.hasOwnProperty(route)) $scope.uiState[route] = {};
            angular.extend($scope.uiState[route], defaultUiStateForRoute);
        }

        $scope.uiState.activeRoute = $scope.uiState[route];
        $scope.uiState.activeRoute.tileDisplayMode = displayModeByRouteName[$state.current.name];
        $rootScope.topNav.homeSearchFilter = (fromState && isArrivingFromHomePages(fromState))  ? $scope.uiState.shared.searchFilter : "";
    //    $timeout (_ => {
    //        let y = $rootScope.topNav.homeSearchFilter; $rootScope.topNav.homeSearchFilter+="x"; $rootScope.topNav.homeSearchFilter=y
    //    }, 2000);

        let rowType = $state.params.row ? $state.params.row : tileDisplayModes.rowsOfTiles;
        $scope.uiState.activeRoute.showTileRow = $scope.tileRows.findIndex(e => e.rowType == rowType);
    }

    function ensureDataLoaded() {
        if (!$scope.isStandaloneMode() &&  dataLoadState != dataLoadStates.full) loadData();
    }

    /**
     * Update the whole view to match with the current route
     * @param fromState
     */
    function updateView(fromState) {
        ensureDataLoaded();
        setUIState(fromState);
        refreshInfoPaneSize();
        scrollPaneTopTo(0);
    }

    $scope.$on('$stateChangeSuccess', (e, toState, toParams, fromState) => {
        updateView(fromState)
        if ($scope.appConfig.userSettings.home.behavior === HomeBehavior.LAST)
            HomePageContextService.setLastVisitedState(toState.name, toParams);
    });

    function saveUiState() {
        HomePageContextService.saveRouteCtx(getStateRoute(), $scope.uiState.activeRoute, $scope.uiState.shared);
    }

    $scope.$on('$stateChangeStart', () => {
        saveUiState();
    });

    $scope.$watch('$root.topNav.homeSearchFilter', function() {
        $scope.uiState.shared.searchFilter = $rootScope.topNav.homeSearchFilter;
    });

    /*
     * Loading and displaying data
     */

    /**
     * Standalone mode is for wiki listing - or any other jump to an expandlisted
     * We don't load all the data, just what is needed, and the UI is adjusted
     */
    $scope.isStandaloneMode = function() {
        return $state.params.standalone;
    }

    /**
     * Fill row passed in parameter (rowSet) with recently used item of the class passed in parameter (tileType)
     * @param tileType: type of items to fill row with
     * @param rowSet: row to fill
     */
    function fillRowWithRecentlyUsed(tileType, rowSet) {
        let list = PersonalHomeService.getRecentlyUsedItems().byType[tileType].slice(0, MAX_RECENTLY_USED_PER_ROW);
        list.forEach((o) => rowSet.push(o));

        rowSet.push({tileType: tileTypes.skeleton, forTileType: tileType, disableStar: true});
    }

    /**
     * Callback used when data are retrieved to fill a row (or a mosaic, or a list), whatever its type (my-items, projects, dashboards, wikis)
     * @param event
     * @param args
     */
    function onRowDataRefresh(event, args) {
        const list = args.data;

        let rowId;
        switch (event.name) {
            case personalHomeRefreshEvents.project:
                rowId = tileRowIds.myProjects;
                break;
            case personalHomeRefreshEvents.app:
                rowId = tileRowIds.myApps;
                break;
            case personalHomeRefreshEvents.dashboard:
                rowId = tileRowIds.myDashboards;
                break;
            case personalHomeRefreshEvents.promotedWiki:
                rowId = tileRowIds.myPromotedWikis;
                break;
            case personalHomeRefreshEvents.projectFolders:
                rowId = tileRowIds.projectFolders;
                break;
            default:
                rowId = tileRowIds.myItems;
                break;
        }

        if (!args.errorLoading) {
            if ($scope.tileRows[rowId].checkExistence) {
                DataikuAPI.taggableObjects.checkDeletedObjects($scope.tileRows[rowId].rowSet).success(function(data){
                    let toUnStar=[];
                    data.forEach( (o) => {
                        if (o.id && o.projectKey && o.type) {
                            toUnStar.push({id: o.id, projectKey:o.projectKey, type: o.type });
                        }
                        PersonalHomeService.discardRecentlyusedItem(o);
                    });
                    if (toUnStar.length > 0) {
                        DataikuAPI.interests.star(toUnStar, false);
                    }
                });
            }
            $scope.tileRows[rowId].rowSet = list;
            $scope.tileRows[rowId].fullyPopulated = true;
        }

        $scope.tileRows[rowId].errorLoading = args.errorLoading;
    }

    /**
     * Fill the tileRow passed in parameter (row) with data (from server and from local storage for recently used items)
     * @param row : tileRow to fill
     * @param isStandaloneListing : if true, recently used itemps won't be added
     */
    function loadDataForTileRow(row, isStandaloneListing) {
        const rowSet = [];
        row.rowSet = rowSet;

        PersonalHomeService[row.fGetData](onRowDataRefresh, $scope);
        if (!isStandaloneListing) fillRowWithRecentlyUsed(row.tileType, rowSet);
    }

    $scope.reloadData = row => {
        if (row !== undefined) {
            throttle.exec(() => {
                loadDataForTileRow(row, true);
            })
        }
    }

    /**
     * Returns tileRow matching the current route
     */
    $scope.getCurrentTileRow = function() {
        return $scope.tileRows[$scope.uiState.activeRoute.showTileRow];
    }

    function loadData() {
        const isStandalone = $scope.isStandaloneMode();
        if (isStandalone) {
            loadDataForTileRow(tileRowMap[$state.params.row], isStandalone);
            dataLoadState = dataLoadStates.partial;
        }
        else {
            $scope.tileRows.filter(row => row.visible === true).forEach(row => loadDataForTileRow(row, isStandalone));
            dataLoadState = dataLoadStates.full;
        }
    }

    /**
     * Main start-up
     *
     */
    $scope.tileRows = [
        {rowSet: [], heading: "My items", rowType:rowTypes.myItems, scrollInterval: 300, expandUrl: undefined, tileWidth: 280, tileHeight: 90, itemPlural: 'items',
            tileType: tileTypes.myItem, fGetData: 'getStarredItems', checkExistence: true,
            sortOptions: {
            sortBy: [{ value: 'name', label: 'Name' },{ value: 'type', label: 'Type' }, { value : 'ordinal', label : 'Recently used' }],
            default: 'ordinal'},
            emptyStateShort: 'Your favorite and last-used items will appear here', starrable: true},

        {rowSet: [], heading: "Projects", rowType:rowTypes.projects, scrollInterval: 300, expandUrl: 'project-list', tileWidth: 280, tileHeight: 160, itemPlural: 'projects',
            tileType: tileTypes.project, fGetData: 'getProjectItems',
            emptyStateLong:['No projects have been shared with you.'], starrable: true},

        {rowSet: [], heading: "Applications", rowType:rowTypes.apps, scrollInterval: 300, expandUrl: 'apps.list', tileWidth: 160, tileHeight: 200, itemPlural: 'apps',
            tileType: tileTypes.app, fGetData: 'getAppItems',
            emptyStateLong:['No applications have been shared with you.'], starrable: false},

        {rowSet: [], heading: "Project Folders", rowType:rowTypes.projectFolders, scrollInterval: 300, expandUrl: 'project-list', tileWidth: 280, tileHeight: 130, itemPlural: 'project folders',
            tileType: tileTypes.projectFolders, fGetData: 'getProjectFolderItems',
            emptyStateLong: ['No Project Folders have been created.'], starrable: false},

        {rowSet: [], heading: "Dashboards", rowType:rowTypes.dashboards, scrollInterval: 300, expandUrl: undefined, tileWidth: 280, tileHeight: 160, itemPlural: 'dashboards',
            tileType: tileTypes.dashboard, fGetData: 'getDashboardItems',
            sortOptions: {
            sortBy :[ { value: 'name', label: 'Name' }, { value : '-lastModifiedOn', label : 'Last modified' }],
            default: 'name'
            },
            emptyStateLong:['No dashboards have been shared with you.', 'Dashboards share elements of a data project with users.'],
            loadError: 'A full list of dashboards is not currently available.  Please try again later.' , starrable: true},

        {rowSet: [], heading: "Wikis", rowType:rowTypes.promotedWikis, scrollInterval: 300, expandUrl: undefined,
            tileWidth: 280, tileHeight: 80, tileWidthMosaic: 384, tileHeightMosaic: 216, itemPlural: 'wikis', standaloneTitle: 'wikis',
            tileType: tileTypes.promotedWiki, fGetData: 'getPromotedWikiItems',
            sortOptions: {
                sortBy :[ { value: 'name', label: 'Name' }, { value : '-lastModifiedOn', label : 'Last modified' }],
                default: 'name'
            },
            emptyStateLong:['No wikis have been shared with you.', 'Go to the settings screen for a project to share its wiki'], starrable: false}
    ];

    let tileRowMap = {};
    let shiftIndex = 0;

    $scope.tileRows.forEach((row, index) => {
        const found = ($scope.appConfig.userSettings.home.rows || []).find(r => r.tileType === row.tileType);
        const foundIndex = ($scope.appConfig.userSettings.home.rows || []).findIndex(r => r.tileType === row.tileType);
        let newIndex;
        if (found === undefined) {
            newIndex = index;
            shiftIndex++;
        } else {
            newIndex = shiftIndex + foundIndex
        }
        Object.assign(row, {position: newIndex, visible: !found || found.visible});
        tileRowMap[row.rowType] = row;
    });

    TopNav.setLocation(TopNav.DSS_HOME, $scope.isStandaloneMode() ? tileRowMap[$state.params.row].standaloneTitle : false);

    PersonalHomeService.clearData();

    loadData();
    updateView();
    $timeout(() => refreshInfoPaneSize(), 100);

});

}());

(function() {
    'use strict';

    const app = angular.module('dataiku.personal-home.directives', ['dataiku.filters']);

    app.service('HomePageContextService', function($timeout, $stateParams, localStorageService) {
        const svc = this;
        const ctxKey = "dssHomePage";

        function saveCtx(ctx) {
            ctx.timestamp = new Date();
            localStorageService.set(ctxKey, ctx);
        }

        function getCtx() {
            let ctx = localStorageService.get(ctxKey);
            if (!ctx) ctx = {};
            if (!ctx.hasOwnProperty("shared")) ctx.shared = {};
            return ctx;
        }

        svc.saveRouteCtx = function(routeName, routeCtx, sharedCtx) {
            const ctx = getCtx();

            angular.copy(sharedCtx, ctx.shared);

            if (ctx[routeName]==undefined) ctx[routeName] = {};
            angular.copy(routeCtx, ctx[routeName]);

            return saveCtx(ctx);
        };

        svc.getRouteCtx = function(routeName, fromState) {
            const fullCtx = getCtx();
            const routeCtx = {shared: fullCtx.shared};
            return angular.extend(routeCtx , fullCtx[routeName]);
        };

        svc.getFullCtx = function(fromState) {
            return getCtx();
        };

        svc.getSharedCtx = function () {
            return getCtx().shared;
        };

        svc.saveSharedCtx = function(sharedCtx) {
            const ctx = getCtx();

            angular.copy(sharedCtx, ctx.shared);
            return saveCtx(ctx);
        }

        svc.setLastVisitedState = (name, toParams) => {
            const ctx = getCtx();
            ctx.lastVistedState = { name, params: toParams };
            saveCtx(ctx);
        };

        svc.getLastVisitedState = () => getCtx().lastVistedState;
    });

    app.directive('searchBar', function() {
      return {
        restrict: 'E',
        scope: {
          projects: '='
        },
        replace: true,
        template: `<div class="search-bar" >
              <div class="icon-search" />
              <input type="text" />
            </div>`,
        link: function(scope, $e, attrs) { }
      };
    });

    app.component('newProjectBtn', {
        bindings: {
            asTiles: '@'
        },
        templateUrl: '/templates/personal-home/new-project-btn.html',
        controller:  function newProjectBtnCtrl($scope, $rootScope, $state, $stateParams, $timeout, PersonalHomeService, CreateModalFromTemplate) {
                const ctrl = this;

                const pluginsById = $rootScope.appConfig.loadedPlugins.reduce(function (map, obj) {
                    map[obj.id] = obj;
                    return map;
                }, {});
                
                ctrl.projectCreationMacros = []

                $rootScope.appConfig.customRunnables.forEach(function(runnable) {
                    if (!runnable.desc.macroRoles) return;

                    const plugin = pluginsById[runnable.ownerPluginId];
                    if (!plugin) return; // plugin might have been deleted

                    runnable.desc.macroRoles.forEach(function(macroRole) {
                        if (macroRole.type != 'PROJECT_CREATOR') return;
                        
                        ctrl.projectCreationMacros.push({
                            label: runnable.desc.meta.label || runnable.id,
                            description: runnable.desc.meta.description || "",
                            icon: runnable.desc.meta.icon || plugin.icon,
                            runnable: runnable
                        });
                    });
                });

                ctrl.getPermissions = function(){
                    return $rootScope.appConfig.globalPermissions;
                }

                ctrl.newProject = function () {
                    CreateModalFromTemplate("/templates/projects/new-project.html", $scope, "NewProjectController");
                };

                ctrl.newProjectFromMacro = function(runnable) {
                     CreateModalFromTemplate('/templates/macros/runnable-modal.html', $scope, null, function(newScope) {
                        newScope.runnable = runnable;
                        newScope.mode = "PROJECT_CREATION";
                    });
                }

                ctrl.newTutorial = function () {
                    CreateModalFromTemplate("/templates/projects/tutorials-samples.html", $scope, "NewTutorialProjectController", function (newScope) {
                        newScope.attachDownloadTo = $scope;
                        newScope.uiState = {
                            currentType: 'TUTORIAL'
                        };
                    });
                };

                ctrl.newSample = function () {
                    CreateModalFromTemplate("/templates/projects/tutorials-samples.html", $scope, "NewTutorialProjectController", function (newScope) {
                        newScope.attachDownloadTo = $scope;
                        newScope.uiState = {
                            currentType: 'SAMPLE'
                        };
                    });
                };

                ctrl.importProject = function () {
                    CreateModalFromTemplate("/templates/projects/import-project.html", $scope, "ImportProjectController");
                };

                ctrl.newAutomationProject = function() {
                    CreateModalFromTemplate("/templates/bundles/automation/new-automation-project.html", $scope, null);
                };

                ctrl.isAutomationNode = function () {
                    return $rootScope.appConfig && $rootScope.appConfig.isAutomation;
                }

            }
    });

    app.component('newFolderBtn', {
        bindings: {
            asTiles: '@',
            listContentFn: '&',
        },
        templateUrl: '/templates/personal-home/new-folder-btn.html',
        controller: ['$scope', 'CreateModalFromTemplate',
            function ($scope, CreateModalFromTemplate) {
                const ctrl = this;
                ctrl.listContentFn = ctrl.listContentFn === undefined ? () => { } : ctrl.listContentFn; // NOSONAR empty function required to avoid crash
                ctrl.displayCreateProjectFolderModal = () => {
                    CreateModalFromTemplate("/templates/projects-list/modals/create-project-folder-modal.html", $scope, "CreateProjectFolderModalController", newScope => {
                        newScope.listContentFn = ctrl.listContentFn;
                    });
            };
        }]
    });

    app.controller("CreateProjectFolderModalController", ($scope, $rootScope, $controller, DataikuAPI, ProjectFolderContext) => {
        $controller("NameFolderCommonController", { $scope });

        let providedItemCount = 0;

        function moveItemCount() {
            if (providedItemCount == 0) {
                providedItemCount = $scope.projectKeys ? $scope.projectKeys.length : 0;
                providedItemCount += $scope.folderPaths ? $scope.folderPaths.length : 0;
            }
            return providedItemCount;
        }

        $scope.moveItemCountText = function () {
            if (moveItemCount() == 1)
                return "1 item";
            else
                return providedItemCount + " items";
        };

        $scope.newFolder = {content: []};

        $scope.canSelect = () => true;

        $scope.canBrowse = () => false;

        $scope.canConfirm = () => $scope.isNameValid($scope.newFolderForm.name, $scope.parentPath, false);

        $scope.confirm = () => {
            const promise = DataikuAPI.projectFolders.create(ProjectFolderContext.getCurrentProjectFolderId(), $scope.newFolder.name);
            promise.success(() => {
                    $scope.listContentFn();
                    $rootScope.$emit('reloadGraph');
                    $scope.dismiss();
                })
                .error(setErrorInScope.bind($scope));
        };
    });
    app.component('gettingStartedTablist', {
        bindings: {
            tabItemList: '=',
            selectedTabIdx: '='
        },
        templateUrl: '/templates/personal-home/getting-started/tab-list.html',
        controller: [function ctlrGettingStartedTablist() {
            const ctrl = this;

            ctrl.$onInit = function () {
            };

            ctrl.selectTab = function (e, idx) {
                ctrl.selectedTabIdx = idx;
                e.stopPropagation();
            }
        }]
    });

    app.component('gettingStartedWikiArticle', {
        bindings: {
            articleId: '<',
            projectKey: '<',
            isVisible: '<'
        },
        templateUrl:'/templates/personal-home/getting-started/wiki-article.html',
        controller: ['$scope', 'WikiUtilsService', 'DataikuAPI', '$timeout', 'SmartId', 'StateUtils', '$state', function ctlrGettingStartedWikiArticle(scope, WikiUtilsService, DataikuAPI, $timeout, SmartId, StateUtils, $state) {
            const ctrl = this;

            ctrl.$onInit = function () {
                scope.uiState = {activeArticleTab: 'view'};
                scope.wikiScope = scope;
                scope.StateUtils = StateUtils; //used via article-attachments.html
             };

            scope.getArticleDisplayMode = function () { //called from deep in the wiki article attachment templates
                return "view";
            }

            scope.getArticleProjectKey = function () { //called from deep in the wiki article attachment templates
                ctrl.projectKey;
            }

            scope.getAttachmentViewTarget = function () {
                return "_blank";
            }

            function getWikiData(delay) {
                if (!ctrl.isVisible || !ctrl.projectKey) return;

                $timeout(_ => {
                    if (!scope.wiki || ctrl.projectKey !== scope.wiki.projectKey) {
                        getWiki(ctrl.projectKey).then (_ => getSummary(ctrl.projectKey, ctrl.articleId));
                    } else if (!scope.article
                            || scope.article.id !== ctrl.articleId
                            || scope.article.projectKey !== ctrl.projectKey) {
                            getSummary(ctrl.projectKey, ctrl.articleId);
                    }
                }, delay || 0);
            }

            scope.$watchGroup(['$ctrl.articleId', '$ctrl.projectKey'], function () {
                getWikiData(0);
            }, true);

            scope.$watch("$ctrl.isVisible", function () {
                getWikiData(500);
            }, true);

            scope.wikiLink = function() {
                if (ctrl.articleId) {
                    StateUtils.go.article(ctrl.articleId, ctrl.projectKey);
                } else {
                    $state.go('projects.project.wiki', {projectKey: ctrl.projectKey});
                }
            };

            scope.onSideBarNodeClick = function (node) {
                getSummary(ctrl.projectKey, node.id);
            };

            scope.nodeTreeToDisplay = function () {
                return scope.articleNodeAsArray ? scope.articleNodeAsArray : scope.wiki.taxonomy;
            };

            scope.isShowContentsOutline = function () {
                if (!scope.wiki) return;
                const nodeTree = scope.nodeTreeToDisplay();
                return (nodeTree && nodeTree.length>0 && nodeTree[0].children && nodeTree[0].children.length>0)
            };

            scope.isShowAttachments = function() {
                return (scope.wiki && scope.article && scope.article.attachments && scope.article.attachments.length>0);
            };

            scope.getUploadHref = function(attachment) {
                try {
                    const ref = SmartId.resolve(attachment.smartId, ctrl.projectKey);
                    return `/dip/api/projects/wikis/get-uploaded-file/${attachment.details.objectDisplayName}?projectKey=${ref.projectKey}&uploadId=${ref.id}`;
                } catch (e) {
                    logger.warn('Failed to resolve uploadId');
                    return '';
                }
            };

            function setSummary(data) {
                scope.article = data.object; // We set it in the global wiki scope to be able to use the main toolbar
                scope.articlePayload = data.payload;
                scope.uiState.editedPayload = data.payload;
                scope.uiState.editedLayout = (data.object || {}).layout;

                if(!scope.article) return;

                scope.articleNode = WikiUtilsService.getArticleNodeById(ctrl.articleId, scope.article, scope.wiki.taxonomy);
                scope.articleNodeAsArray = [scope.articleNode]; // used by nodeTreeToDisplay:  if we built array dynamically it will cause a digest loop
            }

            function getSummary(projectKey, articleId) {
                scope.selectedArticleId = articleId;
                return DataikuAPI.wikis.getArticleSummary(projectKey, articleId).then (
                    (data) => setSummary(data.data), function(data, status, headers) {
                    if (status != 404) {
                        setErrorInScope.apply(scope.wikiScope, arguments);
                    } else {
                        scope.articleNotFound = articleId;
                    }});
            }

            function getWiki (projectKey) {
                return DataikuAPI.wikis.getWiki(projectKey)
                    .success(function(wikiSummary) {
                        scope.wiki = wikiSummary.wiki;
                        scope.wikiTimeline = wikiSummary.timeline;
                        scope.articleMapping = wikiSummary.articleMapping;
                        scope.articlesIds = [];

                        scope.emptyWiki = !scope.wiki.taxonomy || !scope.wiki.taxonomy.length;
                        if (scope.emptyWiki) {
                            return;
                        }
                        WikiUtilsService.addArticlesToList(scope.wiki.taxonomy, scope.articlesIds)

                        if (!ctrl.articleId && scope.articlesIds.length>0) ctrl.articleId = scope.articlesIds[0];
                    })
                    .error(setErrorInScope.bind(scope));
            }

        }]
    });

    app.component('gettingStartedPanel', {
        bindings: {
            selectedTabIdx: '=',
            isVisible: '<'
        },
        templateUrl: '/templates/personal-home/getting-started/panel.html',
        controller: ['$scope', '$element', 'DataikuAPI', function ctlrTileRow(scope, $e, DataikuAPI) {
            const ctrl = this;

            ctrl.$onInit = function () {
                scope.tabItemList = [{title: 'Learn DSS'}];
                DataikuAPI.getHomeArticles(true)
                    .success(function(homeArticles) {
                        scope.homeArticles = homeArticles;
                        if (scope.homeArticles.length > 0) {
                            scope.tabItemList = scope.tabItemList.concat(homeArticles.map(article => ({title: article.name})));
                        }
                        else {
                            scope.tabItemList.push({title: 'Add wiki...'});
                            scope.wikiOnboarding = true;
                        }

                    })
                    .error(setErrorInScope.bind(scope));
            };

            ctrl.isAdmin = function () {
                return scope.$parent.isDSSAdmin();
            }
        }]
    });

    app.component('tileRow', {
        bindings: {
            rowDesc: '<',
            displayMode: "@",
            rowIndex: "@",
            fatListPadding: "@",
            settings: "=",
            onReload: "=",
        },
        transclude: true,
        templateUrl: '/templates/personal-home/tile-row.html',
        controller: ['$scope', '$element', '$timeout', 'localStorageService', 'WT1', 'ProjectFolderContext',
            function ctlrTileRow(scope, $e, $timeout, localStorageService, WT1, ProjectFolderContext) {
            const ctrl = this;
            const sortByStarLSKey = "phpSortByStar-" + ctrl.rowDesc.rowType;
            const ROW_V_MARGINS = 16; // adds extra height to space allocated in fat-repeat for a tile, e.g. for dropshadow
            const TILE_H_MARGINS = 32; // adds extra height to space allocated in fat-repeat for a tile, e.g. for dropshadow

            ctrl.$onInit = function () {
                ctrl.isClickable = true;
                ctrl.rowHeight = ctrl.rowDesc.tileHeight + ROW_V_MARGINS; // used to fix the row height before it's populated with tiles
                ctrl.rowTileWidth = ctrl.rowDesc.tileWidth + TILE_H_MARGINS; // used to fix the row height before it's populated with tiles
            };

            ctrl.canCreateProjectsInAnyWay = function() {
                const gp = scope.$parent.appConfig.globalPermissions;
                // No Dataiku Apps here by design
                return gp.mayCreateProjects || gp.mayCreateProjectsFromMacros || gp.mayCreateProjectsFromTemplates;
            }

            ctrl.canCreateProjectsHereInAnyWay = function() {
                return ctrl.canCreateProjectsInAnyWay() && scope.$parent.canWriteInProjectFolder();
            }

            ctrl.canCreateProjectsUsingNiceTiles = function(){
                const gp = scope.$parent.appConfig.globalPermissions;
                // No macros since they don't have nice tiles
                return gp.mayCreateProjects || gp.mayCreateProjectsFromTemplates;
            }

            ctrl.canCreateProjects = ctrl.canCreateProjectsHereInAnyWay;

            scope.$watch("$ctrl.settings.shared.searchFilter", function(nv, ov) {
                scope.selection.filterQuery.userQuery = ctrl.settings.shared.searchFilter;
            }, true);

            ctrl.canClick = function () {return ctrl.isClickable !== false;};

            ctrl.hookTable = function (table) {
                scope.childFatTable = table;
            };

            function scrollbar() {
                if (scope.childFatTable) return scope.childFatTable.scroll;
                return {scrollLeft: 0 , scrollWidth: 100};
            }

            const edgeMargin = 30;
            ctrl.isShowRightScroll = function() {
                const scroll = scrollbar();
                return  scroll.scrollLeft  < scroll.maxScrollHorizontal - edgeMargin;
            };

            ctrl.isShowLeftScroll = function () {
                return  scrollbar().scrollLeft > edgeMargin;
            };
            scope.$on("autoScrollEnd", function() {scope.$apply();});

            ctrl.scrollByTile = function(e, titleCount) {
                e.stopPropagation();
                const deltaPos = titleCount * ctrl.rowDesc.scrollInterval;
                scope.$broadcast("scrollPage", deltaPos);
                $timeout(() => scope.$apply(),100); //force scrollbar arrow update before end of transition
                $(scrollbar().horizontalScrollbar).animate( { scrollLeft: '+=' + deltaPos }, 500, 'swing', () => scope.$apply());// update scrollbar arrows at end of transition
            };

            ctrl.scrollByPage = function(e, pageCount) {
                ctrl.scrollByTile(e, pageCount * 3);
            };

            ctrl.scrollToEndPoint = function(e, isGotoFront) {
                ctrl.scrollByPage(e,  (isGotoFront ? -1 : 1) * 10000);
            };

            ctrl.expandUiSref = function() {
                if (ctrl.rowDesc.expandUrl) return ctrl.rowDesc.expandUrl;

                let displayMode = 'mosaic';
                if (ctrl.settings.hasOwnProperty(ctrl.rowDesc.rowType)) {
                    const dm = ctrl.settings[ctrl.rowDesc.rowType].tileDisplayMode;
                    if (dm) displayMode = dm;
                }

                return "home.expanded" + displayMode + "({ row:'" + ctrl.rowDesc.rowType + "'})";
            };

            ctrl.noItemsText = function() {
                const items = ctrl.rowDesc.itemPlural;
                return `No ${items} found`;
            };

            ctrl.isShowEmpyRowMsg = function () {
                if (ctrl.rowDesc.rowSet.length>0) return false;
                if (ctrl.rowDesc.errorLoading) return true;
                return ctrl.rowDesc.emptyStateLong && (ctrl.rowDesc.rowType!='projects' || ctrl.canCreateProjectsUsingNiceTiles()==false);
            }

            // boolean values are stored as strings in localstorage <:(
            scope.isSortedByStar = localStorageService.get(sortByStarLSKey) === 'true';

            function sortByStar() {
                if (scope.isSortedByStar) {
                    // boolean properties are reverse sorted by orderBy, hence the `!`
                    scope.selection.orderQuery = ['!starred', '$idx'];
                } else {
                    // updateOrderQuery doesn't allow empty-like values so we order by index
                    scope.selection.orderQuery = '$idx';
                }
            }

            ctrl.toggleSortByStar = function () {
                scope.isSortedByStar = !scope.isSortedByStar;
                sortByStar();
                localStorageService.set(sortByStarLSKey, scope.isSortedByStar);
                WT1.event("php-sort-by-star", {type: ctrl.rowDesc.rowType, state: scope.isSortedByStar});
            }

            // Can't be called immediately because 'scope.selection' is not defined (yet)
            $timeout(sortByStar);
      }]
    });

    app.component('tileMosaic', {
        bindings: {
            rowDesc: '<',
            fatListPadding: "@",
            settings: "="
        },
        transclude: true,
        templateUrl: '/templates/personal-home/tile-mosaic.html',
        controller: ['$scope', '$element', function ctrlTileMosaic($scope) {
            const ctrl = this;
            const ROW_V_MARGINS = 32;
            const ROW_H_MARGINS = 32;

            ctrl.$onInit = function () {
                // homeExpandedHeader is a directive with no scope, so we need to pass in the context...
                $scope.heading = ctrl.rowDesc.heading;
                $scope.rowType = ctrl.rowDesc.rowType;
                $scope.displayMode = 'mosaic';
                $scope.settings = ctrl.settings;
                $scope.sortOptions = ctrl.rowDesc.sortOptions;

                ctrl.rowHeight = (ctrl.rowDesc.tileHeightMosaic || ctrl.rowDesc.tileHeight) + ROW_V_MARGINS;
                ctrl.rowWidth = (ctrl.rowDesc.tileWidthMosaic || ctrl.rowDesc.tileWidth) + ROW_H_MARGINS;
            };

            ctrl.noItemsText = function() {
                const items = ctrl.rowDesc.itemPlural;
                return `No ${items} found`;
            };

      }]
    });

    app.directive('homeExpandedHeader', function($state) {
        return {
            restrict: 'E',
            scope: false,
            replace: true,
            templateUrl:'/templates/personal-home/expanded-header.html',
            link: function ($scope) {

                $scope.$watch("settings.shared.searchFilter", function(nv, ov) {
                    if ($scope.selection.filterQuery.userQuery != $scope.settings.shared.searchFilter) $scope.selection.filterQuery.userQuery = $scope.settings.shared.searchFilter;
                }, true);

                $scope.$watch("selection.filterQuery.userQuery", function(nv, ov) {
                    if ($scope.settings.shared.searchFilter != nv) $scope.settings.shared.searchFilter = nv;
                });

                $scope.$watch("selection.orderQuery", function(nv, ov) {
                    if ($scope.settings.activeRoute.sortBy != nv) $scope.settings.activeRoute.sortBy = nv;
                });

                $scope.$watch("selection.orderReversed", function(nv, ov) {
                    if (ov!=nv && $scope.settings.activeRoute.sortRev != nv) $scope.settings.activeRoute.sortRev = nv;
                });

                $scope.changeDisplayMode = function(e, newState) {
                    e.stopPropagation();
                    const filter = $scope.selection.filterQuery.userQuery;

                    $state.go(newState, {row: $scope.rowType, filterBy: filter, standalone: $scope.isStandalone()});
                };

                $scope.isStandalone = function() {
                    return $state.params.standalone;
                }

            }
        }
    });

    app.directive('tileList', function($state, CatalogItemService, $controller, InterestsService, DataikuAPI, ActiveProjectKey) {
        return {
            restrict: 'E',
            scope: {
                listItems: '<',
                rowDesc: '<',
                fatListPadding: "@",
                settings: "="
            },
            replace: true,
            templateUrl: '/templates/personal-home/tile-list.html',
            link: function ($scope) {

                $controller('_TaggableObjectsListPageCommon', {$scope: $scope}); // important for capturing metadata for notebooks and analyses

                $scope.displayMode = 'list';
                $scope.CatalogItemService = CatalogItemService;
                $scope.heading = $scope.rowDesc.heading;
                $scope.sortOptions = $scope.rowDesc.sortOptions;
                $scope.rowType = $scope.rowDesc.rowType;
                $scope.updateActiveProjectKey = true; // used by filteredMultiSelectRows to flag the need to update the ActiveProjectKey service when a list item is selected

                $scope.rightColumnTypeType = function () {
                    if (!$scope.selection || !$scope.selection.selectedObject) return;
                    const item = $scope.selection.selectedObject;
                    if (item.catalogItemType == "notebook") return item.type_raw.toLowerCase();
                    return item.catalogItemType;
                };

                function makeTagObjId(item) {
                    if (!item.id || !item.projectKey || !item.type) return undefined;
                    return {id: item.id, projectKey:item.projectKey, type: item.type} ;
                }

                $scope.starObject = function(star, item) {
                    const idObj = makeTagObjId(item);
                    if (idObj){
                        InterestsService.star($scope, [idObj], star).then(() => {
                            item.starred = star;
                        });
                    }
                };

                $scope.watchObject = function(watch, item) {
                    const idObj = makeTagObjId(item);
                    if (idObj){
                        InterestsService.watch($scope, [idObj], watch).then(() => {
                            item.watching = watch;
                        });
                    }
                };

                // Records whether the current user has write access to the projects.
                const canWriteContentInProject = {};

                DataikuAPI.projects.list()
                    .success((projects) => {
                        projects.forEach((it) => {
                            canWriteContentInProject[it.projectKey] = it.canWriteProjectContent;
                        });
                    })
                    .error(setErrorInScope.bind($scope));

                $scope.canWriteProject = function() {
                    const selectedItemProjectKey = ActiveProjectKey.get();

                    if (!selectedItemProjectKey) {
                        return false;
                    }

                    const canWriteContent = canWriteContentInProject[selectedItemProjectKey];
                    return !!canWriteContent;
                };
            }
        }
    });

    app.component('tile',{
        bindings: {
            object: '<',
            isClickable: '<'
        },
        templateUrl: '/templates/personal-home/tile.html',
        controller: ['$scope', '$element', 'InterestsService', 'PersonalHomeService', 'openDkuPopin', function ctlrTile(scope, el, InterestsService, PersonalHomeService, openDkuPopin) {
            const ctrl = this;

            ctrl.$onInit = function () {
                scope.isClickable = ctrl.isClickable;
            };

            ctrl.starObject = function(star) {
                const o = ctrl.object;
                if (o.id && o.projectKey && o.type){
                    InterestsService.star(scope, [{id: o.id, projectKey:o.projectKey, type: o.type }], star).then(() => {
                        o.starred = star;
                        scope.$emit('refresh-list');
                    });
                }
            };

            ctrl.removeItem = function() {
                PersonalHomeService.discardRecentlyusedItem(ctrl.object);
            }

            ctrl.isShowMenuCaret = function() {
                return ctrl.object.isRecentlyUsed && ctrl.object.tileType=='my-item';
            }

            ctrl.toggleMenu = function($event) {
                if (ctrl.overlayWatcherDereg)  {
                    ctrl.endPopup();
                }
                else {
                    ctrl.openContextMenu($event);
                }
                $event.stopPropagation();
            };

            ctrl.endPopup = function()  {
                if (ctrl.overlayWatcherDereg) ctrl.overlayWatcherDereg();
                if (ctrl.dismissPopUp) ctrl.dismissPopUp(true);

                ctrl.overlayWatcherDereg = undefined;
                ctrl.dismissPopUp = undefined;
                scope.$emit("lock-overlay", false);
            };

            ctrl.startPopup = function() {
                ctrl.overlayWatcherDereg = scope.$on('overlay-clicked', ctrl.endPopup)
                scope.$emit("lock-overlay", true);
            };

            ctrl.openContextMenu = function($event) {
                if (!ctrl.isShowMenuCaret()) return;

                let template = `<ul class="dropdown-menu projects-dropdown-menu">
                    <li class="qa_homepage-tile_delete">
                        <a ng-click="$ctrl.removeItem(); $ctrl.endPopup();"><i class="icon-remove"></i> Remove this item from the list</a>
                    </li>
                </ul>`;

                let isElsewhere = function(elt, e) {
                    return $(e.target).parents('.dropdown-menu').length == 0;
                };

                let dkuPopinOptions = {
                    template: template,
                    isElsewhere: isElsewhere,
                    popinPosition: 'CLICK',
                    onDismiss: ctrl.endPopup
                };
                ctrl.dismissPopUp = openDkuPopin(scope, $event, dkuPopinOptions);
                ctrl.startPopup();
            };


        }]
    });

    app.component('subtileMyItem', {
        bindings: {
            item: '<'
        },
        templateUrl: '/templates/personal-home/subtile/my-item.html',
        controller: ['$scope', '$element', 'CatalogItemService', function ctlrSubtileMyItem(scope, $e, CatalogItemService) {
            const ctrl = this;

            ctrl.$onInit = function () {
                ctrl.CatalogItemService = CatalogItemService;
            };

        }]
    });

    app.component('subtileSkeleton', {
        bindings: {
            skeleton: '<'
        },
        templateUrl: '/templates/personal-home/subtile/skeleton.html'
    });

    app.component('subtileDashboard', {
        bindings: {
            dashboard: '<'
        },
        templateUrl: '/templates/personal-home/subtile/dashboard.html',
        controller: ['$scope', '$element', 'StateUtils', function ctlrSubtileDashboard(scope, $e, StateUtils) {
            const ctrl = this;

            ctrl.viewLink = function () {
                const dbd = ctrl.dashboard;
                return StateUtils.href.dashboard(dbd.id, dbd.projectKey, {name: dbd.name});
            }

        }]
    });

    app.component('subtileProject', {
        bindings: {
            project: '<'
        },
        templateUrl: '/templates/personal-home/subtile/project.html',
        controller: ['$scope', '$element', '$state', 'PersonalHomeService', 'ProjectStatusService', function ctlrSubtileProject(scope, $e, $state, PersonalHomeService, ProjectStatusService) {
            const ctrl = this;

            ctrl.$onInit = function () {
                ctrl.$state = $state;
                ctrl.projectService = ProjectStatusService;
            };

        }]
    });

    app.component('subtileApp', {
        bindings: {
            app: '<'
        },
        templateUrl: '/templates/personal-home/subtile/app.html',
        controller: ['$scope', '$element', '$state', 'PersonalHomeService', 'ProjectStatusService', function ctlrSubtileProject(scope, $e, $state, PersonalHomeService, ProjectStatusService) {
            const ctrl = this;

            ctrl.$onInit = function () {
                ctrl.$state = $state;
            };

        }]
    });

    app.component('subtileProjectFolder', {
        bindings: {
            folder: '<'
        },
        templateUrl: '/templates/personal-home/subtile/project-folder.html',
        controller: ['$scope', '$element', '$state', function ctrlSubtileProjectFolder(scope, $e, $state) {
            const ctrl = this;

            ctrl.$onInit = function () {
                ctrl.$state = $state;
            };
        }]
    });

    app.component('subtilePromotedWiki', {
        bindings: {
            promotedWiki: '<',
            isClickable: '<'
        },
        templateUrl: '/templates/personal-home/subtile/promoted-wiki.html',
        controller: ['$scope', '$element', '$state', 'PersonalHomeService', function ctlrSubtilePromotedWiki(scope, $e, $state, PersonalHomeService) {
            const ctrl = this;

            ctrl.$onInit = function () {
                ctrl.$state = $state;
            };

            ctrl.clickToWiki = function(event) {
                if (ctrl.isClickable && !ctrl.isClickable()) {return false;}
                ctrl.$state.go('projects.project.wiki', {projectKey : ctrl.promotedWiki.projectKey})
            }

        }]
    });
    
    app.directive('dragScroll', function ($document, $window, $parse, $interval, $timeout) {
        return {
            restrict: 'A',
            link: function($scope, $element, $attributes) {
                const DELTA = 5;
                let allowedClickOffset = 5;
                let axis = $attributes.axis || 'x';
                let clientPosIdx = !axis || axis==="x" ? "clientX" : "clientY";
                let moveAttrIdx = !axis || axis==="x" ? "scrollLeft" : "scrollTop";
                let $elUnderMouse;
                let lastPos;
                let startPos;
                let offsetPos = 0; //the currently-set scroll posn

                function startVeloTracker (e) {

                    let veloTrack = {
                            frame: 0,
                            velocity: 0,
                            timestamp: 0,
                            amplitude:0,
                            ticker: undefined,
                            target: 0,
                            timeConstant: 80,
                            endSignalled: false
                        };


                    let autoScroll = function() {
                        if (veloTrack.amplitude) {
                            const elapsed = Date.now() - veloTrack.timestamp;
                            const delta = -veloTrack.amplitude * Math.exp(-elapsed / veloTrack.timeConstant);
                            if (!veloTrack.endSignalled && (delta < 25 && delta > -25)) {
                                veloTrack.endSignalled = true;
                                $scope.$emit("autoScrollEnd");
                            }
                            if (delta > 5 || delta < -5 ) {
                                scroll(veloTrack.target + delta);
                                requestAnimationFrame(autoScroll);
                            } else {
                                scroll(veloTrack.target+delta);
                            }
                        }
                    }

                    let track = function() {
                        let now, elapsed, delta, v;

                        now = Date.now();
                        elapsed = now - veloTrack.timestamp;
                        veloTrack.timestamp = now;
                        delta = offsetPos - veloTrack.frame;
                        veloTrack.frame = offsetPos;

                        v = 1000 * delta / (1 + elapsed);
                        veloTrack.velocity = 0.8 * v + 0.2 * veloTrack.velocity;
                    }

                    let getPos = function(e) {
                        if (e.targetTouches && (e.targetTouches.length >= 1)) { // touch event
                            return e.targetTouches[0][clientPosIdx];
                        }
                        return e[clientPosIdx]; // mouse event
                    }

                    let movePos = function(e) {
                        const currentPos = getPos(e);
                        const delta = lastPos - currentPos;
                        let moved = false;
                        if (delta > DELTA || delta < -DELTA) {
                            scroll(offsetPos + delta);
                            lastPos = currentPos;
                            moved = true;
                        }
                        e.preventDefault();
                        return moved;
                    }

                    let stop = function() {

                        cancelTicker();

                        let vel = veloTrack.velocity;
                        if (vel > 10 || vel < -10) {
                            vel = Math.max(Math.min(vel, 1800), -1800);
                            veloTrack.amplitude = 0.6 * vel;
                            veloTrack.target = Math.round(limitToScrollBounds(offsetPos + veloTrack.amplitude * 0.6));
                            veloTrack.amplitude = veloTrack.target - offsetPos;
                            veloTrack.endSignalled = false;

                            veloTrack.timestamp = Date.now();
                            requestAnimationFrame(autoScroll);
                        }
                    }

                    let cancelTicker = function() {
                        $interval.cancel(veloTrack.ticker);
                    }

                    let start = function(e) {
                        lastPos = startPos = getPos(e);
                        offsetPos = getCurrentScrollPos();
                        veloTrack.velocity = 0;
                        veloTrack.amplitude = 0;
                        veloTrack.frame = offsetPos;
                        veloTrack.timestamp = Date.now();
                        veloTrack.ticker = $interval(track, 25);
                    }
                    start(e);

                    return  {
                        autoScroll: autoScroll,
                        stop: stop,
                        cancelTicker: cancelTicker,
                        movePos: movePos
                    }
                }

                let veloTracker;

                const $scrolledE = $element;

                $scope.$on("scrollPage", function(ev, deltaPos) {
                    if (veloTracker) veloTracker.cancelTicker();
                    offsetPos = limitToScrollBounds(offsetPos + deltaPos);
                    lastPos = offsetPos;
                });

                $element.on('mousedown', onMouseDown);
                $element.on('wheel', onMouseWheel);

                $scope.$on('$destroy', destroy);

                let lastForcedUpdate = Date.now();
                function onMouseWheel(e) {
                    // Prevent futile scroll on Chrome/OSX, which would trigger the Back/Next page event
                    if (e.originalEvent.deltaX < 0 && getCurrentScrollPos()==0) {
                        e.preventDefault();
                    }

                    // forced a refresh of the row to reset the arrow panels at the end of the rows
                    const now = Date.now();
                    if (now - lastForcedUpdate >  500) {
                        $scope.$emit("autoScrollEnd");
                        lastForcedUpdate = now;
                    }
                };

                function setDragListeners () {
                    $timeout(() => {if ($elUnderMouse) $elUnderMouse.addClass("dragme")}, 200);
                    angular.element($window).on('mouseup', onMouseUp);
                    angular.element($window).on('mousemove', onMouseMove);
                }

                function removeDragListeners () {
                    if ($elUnderMouse){
                        $elUnderMouse.removeClass("dragme");
                        $elUnderMouse = undefined;
                    }
                    angular.element($window).off('mouseup', onMouseUp);
                    angular.element($window).off('mousemove', onMouseMove);
                }

                function onMouseDown (e) {
                    if (veloTracker) veloTracker.cancelTicker();

                    $elUnderMouse = angular.element(e.target);

                    setDragListeners();

                    veloTracker = startVeloTracker(e);

                    e.preventDefault();
                    e.stopPropagation();
                }

                function onMouseMove (e) {
                    if (veloTracker) {
                        if (veloTracker.movePos(e)) {
                            suppressClickEvent(e);
                        }
                    }
                }

                function onMouseUp (e) {
                    if (!veloTracker) return;
                    veloTracker.stop();
                    removeDragListeners();
                    reenableClickEvent();
                }

                function calcMaxPos() {
                    if ($scope.childFatTable) {
                        return (axis=='x' ? $scope.childFatTable.scroll.maxScrollHorizontal : $scope.childFatTable.scroll.maxScrollVertical);
                    }
                    else {
                        return (axis=='x' ? $scrolledE[0].scrollWidth - $scrolledE[0].offsetWidth : $scrolledE[0].scrollHeight - $scrolledE[0].offsetHeight);
                    }
                }

                function getCurrentScrollPos() {
                    if ($scope.childFatTable)  {
                        return $scope.childFatTable.scroll[moveAttrIdx];
                    }
                    else {
                        return $scrolledE[0][moveAttrIdx];
                    }
                }

                function limitToScrollBounds(p) {
                    let maxPos = calcMaxPos();
                    const minPos = 0;
                    return (p > maxPos) ? maxPos : (p < minPos) ? minPos : p;
                }

                function scroll(p) {
                    offsetPos = limitToScrollBounds(p);
                    if ($scope.childFatTable)  {
                        $scope.childFatTable.scroll.setScrollXY(offsetPos, 0);
                    }
                    else {
                        $scrolledE[0][moveAttrIdx] = offsetPos;
                    }
                }

                function suppressClickEvent () {
                    // stop the mouse-up event at the end of the drag from triggering a tile-click e.g. opening a project
                    $scope.$ctrl.isClickable = false;
                    $scope.$emit("onDragScrollAction", {isDragging: true});
                }

                function reenableClickEvent() {
                    $timeout(() => {
                        $scope.$ctrl.isClickable = true;
                        $scope.$emit("onDragScrollAction", {isDragging: false});
                    }, 100);
                }

                function destroy () {
                    $element.off('mousedown', onMouseDown);
                    angular.element($window).off('mouseup', onMouseUp);
                    angular.element($window).off('mousemove', onMouseMove);
                    angular.element($window).off('mousewheel', onMouseWheel);
                    angular.element($window).off('touchstart', onMouseWheel);                }

            }
        };
    });
    
})();

(function() {
    'use strict';

    const app = angular.module('dataiku.controllers');

    app.constant("NO_PERMISSION_TOOLTIP_MSG", "No permission have been defined on the folder. Only administrators and users who have access to some projects or folders in this folder will be able to see it. Click to define permissions.");

    app.controller('_ProjectsListBaseBehavior', function ($scope, Fn) {
        $scope.prepareProject = function(project, tagsMap, contributorsMap) {
            // --- Commits
            if (project.totalCommits) {
                project.commits = project.totalCommits.dayTS.data.map((ts, i) => {
                    return { date: new Date(ts), value: project.totalCommits.value.data[i]};
                });
                //if there is less than 8 weeks of data we fill missing days with zeros
                if (project.commits.length < 56) {
                    project.commits = project.commits.concat().sort((a, b) => Fn.CMP(a.date, b.date));
                    const oldestDataDate = project.commits[0].date;
                    const missingDays = 56 - project.commits.length;
                    for (var i = 0; i < missingDays; i++) {
                        const timestamp = oldestDataDate.getTime() - (i + 1) * 24 * 60 * 60 * 1000;
                        project.commits.unshift({date: new Date(timestamp), value: -1});
                    }
                }
            }
        };

        $scope.lockForPopup = () => $scope.isPopupActive = true;

        $scope.unlockAfterPopup = () => $scope.isPopupActive = false;
    });

    app.controller('ProjectsListController', function ($scope, $controller, $state, $rootScope, $timeout, $http, Assert, DataikuAPI, localStorageService, WT1, TopNav, ProjectFolderContext, NO_PERMISSION_TOOLTIP_MSG,
                                               CreateModalFromTemplate, ListFilter, LoggerProvider, Debounce, DKUConstants, TaggingService, HomePageContextService, openDkuPopin, StateUtils, HomeBehavior, Throttle, ActivityIndicator) {

        const Logger = LoggerProvider.getLogger('ProjectsListController');

        $controller('_ProjectsListBaseBehavior', { $scope });

        $scope.ProjectFolderContext = ProjectFolderContext;

        $scope.uiState = {};
        $scope.projectsMap = {};
        $scope.projectsList = [];
        $scope.rowHeight = 192;

        $scope.NO_PERMISSION_TOOLTIP_MSG = NO_PERMISSION_TOOLTIP_MSG;


        TopNav.setLocation(TopNav.DSS_HOME);

        /*
         * Initialize projects list
         */

        $scope.exposedObjInit = function () {
            $scope.tagsList = [];
            $scope.contributorsList = [];

            $scope.nbArchivedProjects = 0;
        };

        $scope.onListSuccess = data => {
            $scope.projectsMap = {};
            const tagsMap = new Map();
            const contributorsMap = new Map();

            data.projects.forEach(p => {
                $scope.projectsMap[p.projectKey] = p;

                // --- Tags
                //populating tagsMap will all descendants projects
                p.tags.forEach(tag => {
                    const entry = tagsMap.get(tag);
                    if (entry !== undefined) {
                        entry.count++;
                    } else {
                        const tagDef = p.tagsFile.tags[tag]
                        const color = (tagDef == undefined || tagDef.color == undefined) ? TaggingService.getDefaultColor(tag) : tagDef.color;
                        tagsMap.set(tag, {count: 1, color: color});
                    }
                });

                p.contributors.forEach(contributor => {
                    if (!contributorsMap.has(contributor.login)) {
                        contributorsMap.set(contributor.login, angular.extend({}, contributor, { sortName: contributor.displayName.toLowerCase() }));
                    }
                })
            });
            const projectsList = data.folder.projectKeys.map(projectKey => $scope.projectsMap[projectKey]).filter(p => p != null);
            projectsList.forEach(project => $scope.prepareProject(project, tagsMap, contributorsMap));
            projectsList.forEach(project => {
                if (project.projectStatus === DKUConstants.ARCHIVED_PROJECT_STATUS) {
                    $scope.nbArchivedProjects++;
                }
            });
            tagsMap.forEach((value, key) => $scope.tagsList.push({ title: key, count: value.count, color: value.color }));
            $scope.tagsList.sort((a, b) => a.title > b.title);
            contributorsMap.forEach((value) => $scope.contributorsList.push(value));
            $scope.contributorsList.sort((a, b) => a.sortName.localeCompare(b.sortName));
            $scope.folders = data.folder.children;
            $scope.projectsList = projectsList;
            const list = treeToList(data.folder, item => item.parent);
            ProjectFolderContext.setProjectFoldersInPath(list.slice(1));
            let path = list.filter(fip => fip.name).map(fip => fip.name).join('>');
            if (path) {
                $state.go('.', {'#': path}, {location: 'replace', notify: false, reload: false});
            }
            $scope.updateDisplayedItems();
        };

        $scope.onDragStart = event => {
            WT1.event("project-list-move-dragndrop", {action: 'start'});
            $scope.draggableInfos = { projects: $scope.selectedProjects.map(p => p.projectKey), folders: $scope.selectedFolders.map(f => f.id) };

            if ($scope.selectedFolders.length === 0 && $scope.selectedProjects.length === 0) {
                $scope.draggableInfos[`${event.currentTarget.dataset.type}s`].push(event.currentTarget.dataset.id);
            }

            const draggingFolders = $scope.folders.filter(f => $scope.draggableInfos.folders.includes(f.id));
            const adminFolders = draggingFolders.filter(f => f.isAdmin);
            // In case you are not admin on the folders or you are dragging something not selected
            if (draggingFolders.length !== adminFolders.length || $scope.draggableInfos[`${event.currentTarget.dataset.type}s`].includes(event.currentTarget.dataset.id) === false) {
                event.preventDefault();
                return false;
            }

            let dragImageTarget = event.currentTarget;
            if (($scope.selectedProjects.length + $scope.selectedFolders.length) > 1) {
                const element = document.querySelector('#drag-preview');
                const newDiv = event.currentTarget.cloneNode(true);
                removeClassFromClassName(newDiv, 'selected');
                newDiv.removeAttribute('data-id');
                newDiv.removeAttribute('data-type');
                const shiftDiv = newDiv.cloneNode(false);
                shiftDiv.style.position = 'absolute';
                shiftDiv.style.top = '6px';
                shiftDiv.style.left = '6px';
                shiftDiv.style.zIndex = '-1';
                element.appendChild(shiftDiv);
                element.appendChild(newDiv);
                dragImageTarget = element;
            }

            event.dataTransfer.setDragImage(dragImageTarget, event.offsetX, event.offsetY);
            event.dataTransfer.setData('object/draggables', JSON.stringify($scope.draggableInfos));

            $scope.DOMDraggableOperation($scope.draggableInfos, div => {
                addClassToClassName(div, 'dragging');
            });
            $scope.isDragging =  true;

            const throttle = Throttle().withScope($scope).withDelay(200);

            event.currentTarget.closest('.fat-repeat').ondragover = event => {
                const target = event.currentTarget;
                throttle.exec(() => {
                    const delta = $scope.rowHeight / 2;
                    const clientRect = target.getBoundingClientRect();
                    if (event.clientY < (clientRect.top + delta)) {
                        $scope.$broadcast('moveScroll', 0, -delta);
                    } else if (event.clientY > (clientRect.bottom - delta))  {
                        $scope.$broadcast('moveScroll', 0, delta);
                    }
                });
            };
        };

        function removeClassFromClassName(element, toRemove) {
            element.className = element.className.split(' ').filter(c => c !== toRemove).join(' ');
        }

        function addClassToClassName(element, toAdd) {
            if (!element.className.includes(toAdd)) {
                element.className = element.className.split(' ').concat([toAdd]).join(' ');
            }
        }

        function cleanupTarget(target) {
            removeClassFromClassName(target, 'droppable');
            removeClassFromClassName(target, 'forbidden');
        }

        $scope.onDragEnd = event => {
            WT1.event("project-list-move-dragndrop", {action: 'end'});
            $scope.DOMDraggableOperation($scope.draggableInfos, div => {
                removeClassFromClassName(div, 'dragging');
            });
            if (($scope.draggableInfos.projects.length + $scope.draggableInfos.folders.length) > 1) {
                const element = document.querySelector('#drag-preview');
                element.removeChild(element.lastChild);
                element.removeChild(element.lastChild);
            }
            $scope.isDragging = false;
            $scope.draggableInfos.projects = [];
            $scope.draggableInfos.folders = [];
            delete $scope.draggableInfos.forbidden;
            event.currentTarget.closest('.fat-repeat').ondragover = null;
        };

        function displayError() {
            if ($scope.draggableInfos.forbidden) {
                ActivityIndicator.error(`You don't have permissions to write in project folder <strong>${$scope.draggableInfos.forbidden.folder.name}</strong>`);
            }
        }
        const fnErrDragover = Debounce().withScope($scope).withDelay(0, 500).wrap(displayError);

        $scope.onDragOver = event => {
            delete $scope.draggableInfos.forbidden;
            if (event.currentTarget.dataset.type === 'folder') {
                if (!$scope.draggableInfos.folders.includes(event.currentTarget.dataset.id)) {
                    const overFolder = $scope.filteredFoldersList.find(f => f.id === event.currentTarget.dataset.id);
                    if (overFolder.canWriteContents === false) {
                        $scope.draggableInfos.forbidden = { folder: overFolder };
                        addClassToClassName(event.currentTarget, 'forbidden');
                        fnErrDragover();
                        return false;
                    }
                    addClassToClassName(event.currentTarget, 'droppable');
                    event.preventDefault();
                }
            }
        };

        $scope.onDragLeave = event => {
            cleanupTarget(event.currentTarget);
        };

        $scope.onDrop = event => {
            event.preventDefault();
            const data = event.dataTransfer.getData('object/draggables');
            const draggableInfos = JSON.parse(data);
            const destination = event.currentTarget.dataset.id;
            const destinationFolder = $scope.folders.find(f => f.id === destination);

            if (draggableInfos.folders.includes(destination) === false) {
                DataikuAPI.projectFolders.moveItems(destination, draggableInfos.folders, draggableInfos.projects, ProjectFolderContext.getCurrentProjectFolderId()).success(() => {
                    WT1.event("project-list-move-dragndrop", {action: 'success'});
                    $scope.listContent().then(() => {
                        ActivityIndicator.success(`Selected content has been successfully moved to <strong>${destinationFolder.name}</strong>`);
                        $scope.unselectAll();
                    });
                }).error(setErrorInScope.bind($scope));
                cleanupTarget(event.currentTarget);
            }
        };

        $scope.DOMDraggableOperation = (draggableInfos, func) => {
            draggableInfos.projects.forEach(p => {
                const div = document.querySelector(`div[data-id="${p}"][data-type="project"]`);
                if (div !== undefined && div !== null) {
                    func(div);
                }
            });

            draggableInfos.folders.forEach(f => {
                const div = document.querySelector(`div[data-id="${f}"][data-type="folder"]`);
                if (div !== undefined && div !== null) {
                    func(div);
                }
            });
        }

        $scope.listContent = (bindError = true) => {
            $scope.exposedObjInit();
            const currentFolderId = ProjectFolderContext.getCurrentProjectFolderId();
            const promise = currentFolderId ? DataikuAPI.projectFolders.listContents(currentFolderId, $scope.lightMode) : DataikuAPI.projectFolders.listRootContents($scope.lightMode);
            promise.success($scope.onListSuccess);
            if (bindError) {
                promise.error(setErrorInScope.bind($scope));
            }
            return promise;
        };

        $scope.clickOnProject = (project, event) => {
            if ($scope.isPopupActive) {
                return true;
            }
            event.preventDefault();
            if (event.ctrlKey || event.metaKey) {
                toggleSelectProject(project);
                window.getSelection().removeAllRanges(); //FF fix for messy text selection
            } else {
                project.effectivePermission == "READER" ? StateUtils.go.pinboard(project.projectKey) : StateUtils.go.project(project.projectKey);
            }
        };

        $scope.goToFirstFilteredProject = function () {
            if ($scope.filteredProjectsList && $scope.filteredProjectsList.length > 0) {
                var project = $scope.filteredProjectsList[0];
                $state.go('projects.project.home.regular', {projectKey: project.projectKey}, {reload: true});
            }
        };

        $scope.getProjectContributorDisplayList = function (contributors, maxDisplayedContributors) {
            if (contributors.length > maxDisplayedContributors) {
                return contributors.slice(0, maxDisplayedContributors - 1);
            }
            return contributors
        };

        $scope.getDefaultTagColor = TaggingService.getTagColor;

        $scope.isArchivedProjectsDisplayed = function () {
            return $scope.query.projectStatus.indexOf(DKUConstants.ARCHIVED_PROJECT_STATUS) > -1;
        };

        function getDisplayedProjectsCount(mode) {
            switch (mode) {
                case 'CURRENT_FOLDER_ONLY':
                    return $scope.filteredProjectsList.filter(p => $scope.projectsList.find(prj => prj.projectKey == p.projectKey)).length;
                case 'SUB_FOLDERS_ONLY':
                    return $scope.filteredProjectsList.filter(p => !$scope.projectsList.find(prj => prj.projectKey == p.projectKey)).length;
                case 'ALL':
                default:
                    return $scope.filteredProjectsList.length;
            }
        };

        function updateDisplayedItemsCounts() {
            $scope.uiState.displayedItemCounts = {
                nbTotalProjects: $scope.isFiltering() ? Object.keys($scope.projectsMap || {}).length : ($scope.projectsList ? $scope.projectsList.length : 0),
                nbTotalProjectsInCurrentFolder: ($scope.projectsList || []).length,
                nbFilteredProjects: getDisplayedProjectsCount('ALL'),
                nbFilteredProjectsInCurrentFolder: getDisplayedProjectsCount('CURRENT_FOLDER_ONLY'),
                nbFilteredProjectsInSubFolders: getDisplayedProjectsCount('SUB_FOLDERS_ONLY'),
                nbFolders: $scope.isFiltering() ? 0 : $scope.foldersList.length,
                nbFilteredFolders: $scope.filteredFoldersList.length
            };
        }

        $scope.isSubItemsRow = function (row) {
            return row.filter(p => p.type == "REAL_PROJECT" && !$scope.projectsList.find(prj => prj.projectKey == p.projectKey)).length > 0;
        };

        $scope.isFolderRow = function (row) {
            return Array.isArray(row) && row.length > 0 && row[0].type == "FOLDER";
        };

        /*
         * Filtering projects
         */

        if ($rootScope.appConfig.loggedIn) {
            Assert.trueish($rootScope.appConfig.userSettings, 'no user settings');
            /*
             * Filtering projects list
             */
            var pmvf = $rootScope.appConfig.userSettings.projectManagerViewFilters;

            $scope.query = pmvf.filter;
            /* 'q' is not saved in pmvf, re-add it */
            $scope.query.q = "";
            $scope.sortBy = pmvf.sort;
        }

        $scope.$on('$stateChangeSuccess', (e, toState, toParams, fromState) => {
            const homeSharedCtx = HomePageContextService.getSharedCtx(); //get from personal home page
            $scope.query.q = homeSharedCtx.searchFilter ? homeSharedCtx.searchFilter : "";
            if ($scope.appConfig.userSettings.home.behavior === HomeBehavior.LAST) {
                HomePageContextService.setLastVisitedState(HomeBehavior.PROJECTS, {});
            }
        });

        $scope.$on('$stateChangeStart', (e, toState, toParams, fromState, fromParams) => {
            const homeSharedCtx = HomePageContextService.getSharedCtx(); //get from personal home page
            homeSharedCtx.searchFilter = $scope.query.q;
            HomePageContextService.saveSharedCtx(homeSharedCtx)
            if ($scope.appConfig.userSettings.home.behavior === HomeBehavior.LAST &&
                toState.name !== fromState.name) {
                    HomePageContextService.setLastVisitedState(fromState.name, fromParams);
            }
        });

        $scope.isFiltering = function () {
            return $scope.query.tags.length > 0 || $scope.query.contributors.length > 0 || $scope.query.projectStatus.length > 0 || $scope.isFullStringQuerying();
        };

        $scope.isFullStringQuerying = function () {
            return typeof($scope.query.q) !== "undefined" && $scope.query.q.length > 0;
        };

        $scope.clearFilters = function () {
            $scope.query.tags = [];
            $scope.query.projectStatus = [];
            $scope.query.contributors = [];
            $scope.query.q = "";
            if ($scope.interestsOptions) {
                $scope.interestsOptions.starredOnly = false;
            }
        };

        /**
          * Flatten a list of folder
          */
        function flattenFolders(folders) {
            let ret = [];
            // loop over the list of folders
            (folders || []).forEach(folder => {
                // concatenate the current parent and the corresponding folders for children
                ret = ret.concat([folder]).concat(flattenFolders(folder.children));
            });
            return ret;
        }

        /**
         * Update the list of items (projects, haikus, news, tips..) displayed to the user
         */
        $scope.updateDisplayedItems = function () {
            $scope.itemsRows = [];
            $scope.filteredProjectsList = filterProjectsList($scope.isFullStringQuerying() ? Array.from(Object.values($scope.projectsMap || {})) : $scope.projectsList, $scope.query);
            $scope.filteredProjectsList = sortProjectsList($scope.filteredProjectsList);
            $scope.foldersList = getDisplayableFolderItems();
            $scope.filteredFoldersList = filterFoldersList($scope.foldersList, $scope.query);
            const flattenFilteredFoldersList = flattenFolders($scope.foldersList).filter(pf => pf.name.toLowerCase().includes($scope.query.q.toLowerCase())).map(getDisplayableFolderItem);
            const folderItemsRows =  getMosaicRows($scope.isFullStringQuerying() ? flattenFilteredFoldersList : $scope.filteredFoldersList);

            // -- For list display
            $scope.itemsList = folderItemsRows.concat($scope.filteredProjectsList);

            // -- For mosaic display
            const localProjects = [];
            const subProjects = [];
            angular.forEach($scope.filteredProjectsList, function(p) {
                if ($scope.projectsList.find(prj => prj.projectKey == p.projectKey)) {
                    localProjects.push(p);
                } else {
                    subProjects.push(p);
                }
            });
            //if not filtering and mosaic mode, adding funny things to current (and therefore only) projects bundle
            if (!$scope.isFiltering() && !ProjectFolderContext.getCurrentProjectFolderId()) {
                addNewsAndHaiku(localProjects);
            }
            const projectRows = getMosaicRows(localProjects).concat(getMosaicRows(subProjects));
            $scope.itemsRows = folderItemsRows.concat(projectRows);

            updateDisplayedItemsCounts();
        };

        /**
         * Returns a list of projects filtered by full text query, tags, users, status, path.
         * Keeps projects that match at least one of the selected attribute for each non-empty filtering category (text query, tags, contributors, status, path)
         * @param projectsList: input list to filter
         * @param query: object wrapping query attributes:
         *      - q: textQuery on which projects list will be filtered (looking through all project's attribute)
         *      - tags: list of tags to filter projects list (inclusive filtering - keep items that match at least one tag)
         *      - contributors: list of contributors to filter projects list (inclusive filtering - keep items that match at least one contributor)
         *      - projectStatus: list of projectStatus to filter projects list (inclusive filtering - keep items that match at least one project status)
         *      - path: path used to filter projects list (project's path needs to be equal to it, or an extension of it in case of full text filtering)
         * @returns {*}
         */
        function filterProjectsList(projectsList, query) {
            // Filtering on full text query
            return ListFilter.filter(projectsList || [], query.q).filter(project => {

                // Keep projects that have at least one of the tags selected in the 'Tags' filter (if there are any)
                if (query.tags && query.tags.length) {
                    if (!project.tags || !query.tags.some(tag => project.tags.includes(tag))) {
                        return;
                    }
                }

                // Keep projects that have at least one of the contributors selected in the 'Users' filter (if there are any)
                if (query.contributors && query.contributors.length) {
                    if (!project.contributors || !project.contributors.some(contributor => query.contributors.includes(contributor.login))) {
                        return;
                    }
                }

                // Keep projects that have at least one of the project status selected in the 'Status' filter (if there are any)
                if (query.projectStatus && query.projectStatus.length) {
                    if (query.projectStatus.indexOf(project.projectStatus) < 0) {
                        return;
                    }
                } else if (project.projectStatus === DKUConstants.ARCHIVED_PROJECT_STATUS) { // Hiding archived projects by default
                    return;
                }

                project.type = "REAL_PROJECT";
                return true;
            });
        }

        /**
         * Returns a list of folders filtered by tags, users, and status.
         * @param foldersList: input list to filter
         * @param query: object wrapping query attributes:
         *      - tags: list of tags to filter folders list (inclusive filtering)
         *      - contributors: list of contributors to filter folders list (inclusive filtering)
         *      - projectStatus: list of projectStatus to filter folders list (inclusive filtering)
         * @returns {*}
         */
        function filterFoldersList(foldersList, query) {
            let filteredFoldersList = foldersList.concat([]);
            filteredFoldersList = $.grep(filteredFoldersList, item => {
                let filteredFoldersList = [];
                if (item.folders !== undefined) {
                    filteredFoldersList = filterFoldersList(item.folders, query);
                }
                let filteredSubProjectsList = filterProjectsList(item.projects, query);
                return $scope.isFiltering() ? (filteredSubProjectsList.length > 0 || filteredFoldersList.length > 0): true;
            });
            return filteredFoldersList;
        }

        $scope.$watch("query", function (nv, ov) {
            $scope.updateDisplayedItems();
            if (!angular.equals(nv.tags, ov.tags)
                || !angular.equals(nv.projectStatus, ov.projectStatus)
                || !angular.equals(nv.contributors, ov.contributors)) {
                Logger.info("Filtering query modified, saving user settings");
                DataikuAPI.profile.setUserSettings($rootScope.appConfig.userSettings).error(setErrorInScope.bind($scope));
            }
        }, true);

        $scope.toggleTag = function (tagTitle) {
            if (tagTitle) {
                var index = $scope.query.tags.indexOf(tagTitle);
                index > -1 ? $scope.query.tags.splice(index, 1) : $scope.query.tags.push(tagTitle);
            }
        };

        /*
         * Sorting projects list
         */

        $scope.sortByModeTitles = Object.freeze({
            name: "Project Name",
            commit: "Last Modified",
            commit_for_user: "Last Modified By Me",
            status: "Status"
        });

        function sortProjectsList(projectsList) {
            if (!$scope.sortBy) {
                return;
            }
            switch ($scope.sortBy.mode) {
                case "name":
                    sortByName(projectsList);
                    break;
                case "status":
                    sortByStatus(projectsList);
                    break;
                case "commit":
                    sortByCommit(projectsList);
                    break;
                case "commit_for_user":
                    sortByCommitForUser(projectsList);
                    break;
            }
            if ($scope.sortBy.isReversedSort) {
                projectsList.reverse();
            }
            return projectsList;
        }

        function sortByName(projectsList) {
            projectsList.sort(function (p1, p2) {
                return alphabeticalSort(p1.name, p2.name);
            });
        }

        function sortByStatus(projectsList) {
            Assert.inScope($rootScope, 'appConfig');
            const projectStatusNames = [];
            $rootScope.appConfig.projectStatusList.forEach(function (s) {
                projectStatusNames.push(s.name);
            })
            projectsList.sort(function (p1, p2) {
                if (p1.projectStatus && p2.projectStatus) {
                    var indexOfStatus1 = projectStatusNames.indexOf(p1.projectStatus);
                    var indexOfStatus2 = projectStatusNames.indexOf(p2.projectStatus);
                    return indexOfStatus1 < indexOfStatus2 ? -1 : indexOfStatus1 == indexOfStatus2 ? alphabeticalSort(p1.name, p2.name) : 1;
                } else if (p1.projectStatus) {
                    return -1;
                } else if (p2.projectStatus) {
                    return 1;
                } else {
                    return alphabeticalSort(p1.name, p2.name);
                }
            });
        }

        function sortByCommit(projectsList) {
            projectsList.sort(function (p1, p2) {
                if (p1.lastCommit && p2.lastCommit) {
                    return p1.lastCommit.time < p2.lastCommit.time ? 1 : p1.lastCommit.time == p2.lastCommit.time ? 0 : -1;
                } else if (p1.lastCommit) {
                    return -1;
                } else if (p2.lastCommit) {
                    return 1;
                } else {
                    return 0;
                }
            });
        }

        function sortByCommitForUser(projectsList) {
            projectsList.sort(function (p1, p2) {
                if (p1.lastCommitForUser && p2.lastCommitForUser) {
                    return p1.lastCommitForUser.time < p2.lastCommitForUser.time ? 1 : p1.lastCommitForUser.time == p2.lastCommitForUser.time ? 0 : -1;
                } else if (p1.lastCommitForUser) {
                    return -1;
                } else if (p2.lastCommitForUser) {
                    return 1;
                } else {
                    return 0;
                }
            });
        }

        $scope.$watch("sortBy", function (nv, ov) {
            Assert.trueish(nv, 'no new sortBy value');
            Assert.trueish(ov, 'no old sortBy value');
            if (!angular.equals(nv, ov)) {
                $scope.updateDisplayedItems();
                Logger.info("Sort mode updated, saving user settings");
                DataikuAPI.profile.setUserSettings($rootScope.appConfig.userSettings).error(setErrorInScope.bind($scope));
            }
        }, true);

        /*
         * Folders
         */
        function getDisplayableFolderItem(folder) {
            const displayableFolder = angular.copy(folder);
            displayableFolder.type = "FOLDER";
            displayableFolder.projects = displayableFolder.projectKeys.map(projectKey => $scope.projectsMap[projectKey]).filter(p => p != null);
            displayableFolder.nbProjects = displayableFolder.projectKeys.length;
            displayableFolder.filteredProjects = filterProjectsList(displayableFolder.projects, angular.extend({}, $scope.query));
            displayableFolder.nbFilteredProjects = displayableFolder.filteredProjects.length;
            displayableFolder.folders = displayableFolder.children.map(f => getDisplayableFolderItem(f));
            displayableFolder.nbFolders = displayableFolder.children.length;
            displayableFolder.filteredFolders = filterFoldersList(displayableFolder.folders, $scope.query);
            displayableFolder.nbFilteredFolders = displayableFolder.filteredFolders.length;
            const mergedItems = displayableFolder.filteredProjects.map(p => Object.assign({ itemType: 'project' }, p)).concat(displayableFolder.filteredFolders.map(f => Object.assign({ itemType: 'folder' }, f)));
            displayableFolder.filteredItems = mergedItems.slice(0, mergedItems.length > 6 ? 5 : 6);
            displayableFolder.nbExtraItems = mergedItems.length - displayableFolder.filteredItems.length;
            return displayableFolder;
        }

        /**
         * Return list of folders in current path as displayable items (empty array if no folder)
         */
        function getDisplayableFolderItems() {
            if (!$scope.folders) {
                return [];
            }
            return $scope.folders.map(f => getDisplayableFolderItem(f));
        }

        $scope.clickOnFolder = (folder, event) => {
            if ($scope.isPopupActive) {
                return false;
            }
            if (event.ctrlKey || event.metaKey) {
                event.preventDefault();
                toggleSelectFolder(folder);
                window.getSelection().removeAllRanges(); //FF fix to stop messy text selection across the page
            }
        };

        $scope.toggleMenu = function(item, $event, fOpen, fIsItemSelected) {
            $event.preventDefault();
            if (!fIsItemSelected(item)) {
                $scope.unselectAll();
            }
            if ($scope.isPopupActive) {
                if ($scope.popupDismiss) {
                    $scope.popupDismiss();
                    $scope.popupDismiss = undefined;
                }
            } else {
                fOpen(item, $event);
            }
            $event.stopPropagation();
        };

        $scope.displayDuplicateProjectModal = function (project) {
            DataikuAPI.projects.getSummary(project.projectKey).then(function(response) {
                $scope.projectSummary = response.data.object;
                CreateModalFromTemplate("/templates/projects/duplicate-project-dialog.html", $scope, "DuplicateProjectController");
            });
        };

        $scope.openProjectMenu = function (project, $event) {
            let template = `<ul class="dropdown-menu projects-dropdown-menu" >
            <li><a ng-click="displayMoveItemsModal(projects, folders)" ng-class="{disabled: foldersNotAllAdmin || projectsNotAllAdmin}">Move to...</a></li>
            <li><a ng-click="displayDuplicateProjectModal(project)" ng-if="folders.length === 0 && projects.length === 1 && appConfig.globalPermissions.mayCreateProjects === true" ng-class="{disabled: !project.isAdmin}">Duplicate...</a></li>
            </ul>`;
            let callback = newScope => {
                newScope.projects = newScope.selectedProjects.length > 0 ? newScope.selectedProjects : [project];
                newScope.folders = $scope.selectedFolders;
                newScope.project = project;
                newScope.currentFolder = $scope.currentFolder;
                newScope.foldersNotAllAdmin = newScope.folders.some(f => f.isAdmin === false);
                newScope.projectsNotAllAdmin = newScope.projects.some(p => p.isAdmin === false);
                newScope.appConfig = $scope.appConfig;
            };
            let isElsewhere = (_, e) => $(e.target).parents('.dropdown-menu').length == 0;
            $scope.lockForPopup();
            let dkuPopinOptions = {
                template: template,
                isElsewhere: isElsewhere,
                popinPosition: 'CLICK',
                callback: callback,
                onDismiss: $scope.unlockAfterPopup
            };
            $scope.popupDismiss = openDkuPopin($scope, $event, dkuPopinOptions);
        };

        $scope.openFolderMenu = (folder, $event) => {
            const template = `<ul class="dropdown-menu folders-dropdown-menu" >
                <li><a ng-click="displayMoveItemsModal(projects, folders)" ng-class="{disabled: foldersNotAllAdmin || projectsNotAllAdmin}">Move to...</a></li>
                <li><a ng-click="displayRenameFolderModal(folder)" ng-if="projects.length === 0 && folders.length === 1" ng-class="{disabled: !folder.isAdmin}">Rename...</a></li>
                <li><a ng-click="displayProjectFolderPermissionsModal(folder)" ng-if="projects.length === 0 && folders.length === 1" ng-class="{disabled: !folder.isAdmin}">Permissions...</a></li>
                <li><a ng-click="displayDeleteProjectFolderModal(folders)" ng-if="projects.length === 0" ng-class="{disabled: foldersNotAllAdmin}">Delete...</a></li>
            </ul>`;
            const callback = newScope => {
                newScope.folders = newScope.selectedFolders.length > 0 ? newScope.selectedFolders : [folder];
                newScope.projects = $scope.selectedProjects;
                newScope.folder = folder;
                newScope.currentFolder = $scope.currentFolder;
                newScope.foldersNotAllAdmin = newScope.folders.some(f => f.isAdmin === false);
                newScope.projectsNotAllAdmin = newScope.projects.some(p => p.isAdmin === false)
            };
            const isElsewhere = (_, e) => $(e.target).parents('.dropdown-menu').length === 0;
            $scope.lockForPopup();
            $scope.popupDismiss = openDkuPopin($scope, $event, {
                template: template,
                isElsewhere: isElsewhere,
                popinPosition: 'CLICK',
                callback: callback,
                onDismiss: $scope.unlockAfterPopup
            });
        };

        $scope.displayMoveItemsModal = (projects, folders) => {
            CreateModalFromTemplate("/templates/projects-list/modals/move-project-items-modal.html", $scope, "MoveItemsModalController", newScope => {
                newScope.movingProjects = projects;
                newScope.movingFolders = folders;
                let currentFolder = ProjectFolderContext.getCurrentProjectFolder();
                let defaultDestinationIsCurrentFolder = folders && folders.length == 1 && currentFolder && currentFolder.id && currentFolder.parent && currentFolder.id == folders[0].id;
                newScope.newFolderId = defaultDestinationIsCurrentFolder ? currentFolder.parent.id : currentFolder.id;
            });
        };

        $scope.displayDeleteProjectFolderModal = folders => {
            CreateModalFromTemplate("/templates/projects-list/modals/delete-project-folder-modal.html", $scope, "DeleteProjectFolderModalController", newScope => {
                const allContainedProjects = folders.map(f => f.projectKeys).flat();
                const allContainedFolders = folders.map(f => f.children).flat();
                newScope.containedProjects = allContainedProjects.map(p => p.projectKey);
                newScope.containedFolders = allContainedFolders;
                let currentFolder = ProjectFolderContext.getCurrentProjectFolder();
                let defaultDestinationIsCurrentFolder = folders && folders.length == 1 && currentFolder && currentFolder.id && currentFolder.parent && currentFolder.id == folders[0].id;
                newScope.newFolderId = defaultDestinationIsCurrentFolder ? currentFolder.parent.id : currentFolder.id;
                newScope.folders = folders;
            });
        };

        $scope.displayRenameFolderModal = folder => {
            CreateModalFromTemplate("/templates/projects-list/modals/rename-project-folder-modal.html", $scope, "RenameProjectFolderModalController", newScope => {
                newScope.folder = folder;
                newScope.newName = folder.name;
            });
        };

        $scope.displayProjectFolderPermissionsModal = folder => {
            CreateModalFromTemplate("/templates/projects-list/modals/project-folder-permissions-modal.html", $scope, "ProjectFolderPermissionsModalController", newScope => {
                newScope.folder = folder;
            });
        };

        // Projects and Folders selection

        $scope.selectedProjects = [];
        $scope.selectedFolders = [];

        $scope.setSelectedItems = (selectedProjects, selectedFolders) => {
            $scope.selectedProjects = selectedProjects ? selectedProjects : [];
            $scope.selectedFolders = selectedFolders ? selectedFolders : [];
            onSelectedItemsChange($scope.selectedProjects, $scope.selectedFolders);
        };

        $scope.unselectAll = function () {
            $scope.setSelectedItems([], []);
        };

        function toggleSelectProject(project) {
            if (!project.isAdmin) {
                ActivityIndicator.error(`You are not admin of project <strong>${project.name}</strong>`);
                return;
            }
            let index = $scope.selectedProjects.findIndex(p => p.projectKey === project.projectKey);
            if (index == -1) {
                $scope.selectedProjects.push(project);
            } else {
                $scope.selectedProjects.splice(index, 1);
            }
        }

        function toggleSelectFolder(folder) {
            if (!folder.isAdmin) {
                ActivityIndicator.error(`You are not admin of project folder <strong>${folder.name}</strong>`);
                return;
            }
            const index = $scope.selectedFolders.findIndex(f => f.id === folder.id);
            if (index === -1) {
                $scope.selectedFolders.push(folder);
            } else {
                $scope.selectedFolders.splice(index, 1);
            }
        }

        let unselectItemsListenerOn = false

        function onSelectedItemsChange(selectedProjects, selectedFolders) {
            if ((selectedProjects.length > 0 || selectedFolders.length > 0) && !unselectItemsListenerOn) {
                $(window).on('click contextmenu', onClickWhileSelectedItems);
                unselectItemsListenerOn = true;
            }
            if (selectedProjects.length == 0 && selectedProjects == 0) {
                $(window).off('click contextmenu', onClickWhileSelectedItems);
                unselectItemsListenerOn = false;
            }
        }

        function onClickWhileSelectedItems(e) {
            let isUpdatingSelectedItems = e.type == 'click' && e.which == 1 && (e.originalEvent.ctrlKey || e.originalEvent.metaKey);
            let isRightClickingOnSelectedItem = (e.type == 'contextmenu' || (e.type == 'click' && e.which == 3)) && $(e.target).closest('.selected').length > 0;
            let isClickingOnContextualMenu = $(e.target).closest('.projects-dropdown-menu, .folders-dropdown-menu').length > 0;
            let isModalDisplaed = $('.move-project-modal').length > 0
            if (!isUpdatingSelectedItems && !isRightClickingOnSelectedItem && !isClickingOnContextualMenu && !isModalDisplaed) {
                safeApply($scope, function () {
                    $scope.unselectAll();
                });
            }
        }

        $scope.$watch("selectedProjects", nv => onSelectedItemsChange(nv, $scope.selectedFolders), true);
        $scope.$watch("selectedFolders", nv => onSelectedItemsChange($scope.selectedFolders, nv), true);

        $scope.isProjectSelected = project => $scope.selectedProjects.findIndex(sp => sp.projectKey === project.projectKey) !== -1;

        $scope.isFolderSelected = folder => $scope.selectedFolders.findIndex(sf => sf.id === folder.id) !== -1;

        /*
         * News & Haikus
         */

        function addNewsAndHaiku(itemsList) {
            // If no query active, add haiku and news
            if (!$scope.isFiltering()) {
                //adding haiku and news
                itemsList.splice(3, 0, {"type": "TIPS"});
                itemsList.splice($scope.haikuPos, 0, {"type": "HAIKU"});
                //itemsList.splice(6, 0, {"type" : "NEWS"});

                if ($scope.appConfig.homeMessages && $scope.appConfig.homeMessages.length > 0) {
                    itemsList.splice(0, 0, {"type": "MESSAGE"});
                }

                if ($scope.kitties) {
                    var targetIndexes = itemsList.map(function (x, i) {
                        return i;
                    });
                    var kittenIndexes = Array.dkuShuffle(targetIndexes).slice(0, $scope.kitties.length);

                    kittenIndexes.forEach(function (targetIdx, kittyIdx) {
                        itemsList.splice(targetIdx, 0,
                            {"type": "IMAGE", "url": $scope.kitties[kittyIdx]}
                        );
                    });
                }
            }
        }

        //News

        const NEWS_URL = "https://ajax.googleapis.com/ajax/services/feed/load?v=1.0&q=http://dataiku.com/feed.xml&callback=JSON_CALLBACK";
        $http.jsonp(NEWS_URL).then(function (object) {
            $scope.news = object.data.responseData;
            localStorageService.set("dataikuNews", object.data.responseData);
        }, function (object) {
            $scope.news = localStorageService.get("dataikuNews");
        });

        const UPDATE_URL = "//downloads.dataiku.com/latest_studio.json"
        $http.get(UPDATE_URL).then(function (object) {
            $scope.latest_version = object.data;
        });

        //Tips
        const TIPS_URL = "https://update.dataiku.com/dss/3.1/tips/tips.json"
        $http.get(TIPS_URL).then(function (object) {
            $scope.tipsObj = object.data;
            localStorageService.set("dataikuTips", object);
        }, function (object) {
            $scope.tipsObj = localStorageService.get("dataikuTips");
        }).then(function () {
            if ($scope.tipsObj && $scope.tipsObj.tips) {
                $scope.randomTipsIndex = Math.floor(Math.random() * ($scope.tipsObj.tips.length - 0.1));
            }
        });

        //Haikus

        $scope.haikuPos = 5;

        Mousetrap.bind("q", function () {
            $scope.haikuPos--;
            if ($scope.haikuPos < 0) $scope.haikuPos = 0;
            $scope.$apply($scope.updateDisplayedItems);
        });
        Mousetrap.bind("d", function () {
            $scope.haikuPos++;
            $scope.$apply($scope.updateDisplayedItems);
        });


        Mousetrap.bind("z", function () {
            if ($scope.haikuPos >= 2) {
                $scope.haikuPos -= 3;
            }
            $scope.$apply($scope.updateDisplayedItems);
        });
        Mousetrap.bind("s", function () {
            $scope.haikuPos += 3;
            $scope.$apply($scope.updateDisplayedItems);
        });

        $scope.haiku = get_haiku_of_the_day();

        /*
         * Display mode
         */
        $scope.displayMode = pmvf && pmvf.display;
        $scope.lightMode = $scope.displayMode && $scope.displayMode.mode === "mosaic";
        $scope.listContent();

        $scope.$watch("displayMode", (nv, ov) => {
            if (nv && !angular.equals(nv, ov)) {
                WT1.event("project-list-display-mode", {displayMode: nv});
                Logger.info("Display mode modified, saving user settings", nv, ov, angular.equals(nv, ov));
                DataikuAPI.profile.setUserSettings($rootScope.appConfig.userSettings).error(setErrorInScope.bind($scope));
                // if projects were previously listed in a light mode but new display mode need full projects info (ie commits info) we reload
                if ($scope.lightMode && $scope.displayMode !== "mosaic") {
                    $scope.lightMode = false;
                    $scope.listContent();
                }
            }
        }, true);

        var debouncedResizeCB = Debounce().withDelay(200, 200).wrap($scope.updateDisplayedItems);

        $(window).on("resize.homePageResize", debouncedResizeCB);
        $scope.$on("$destroy", function () {
            $(window).off("resize.homePageResize", debouncedResizeCB);
        });

        //Items rows for mosaic view
        const getMosaicRows = function (itemsList) {
            /* Compute display characteristics for mosaic mode */
            const tileW = 310;
            const margins = 40;

            let itemsPerRow = 1;
            let ww = window.innerWidth;
            ww -= margins;

            if (ww > tileW) itemsPerRow = Math.floor(ww / tileW);

            const mosaicItemsPerRow = [];
            let i, j;
            for (i = 0, j = itemsList.length; i < j; i += itemsPerRow) {
                mosaicItemsPerRow.push(itemsList.slice(i, i + itemsPerRow));
            }
            return mosaicItemsPerRow;
        };

        $scope.flowLayoutEngineTitles = {
            'dot': "Left - Right",
            'neato': "Radial"
        };

        $scope.listModeTitles = {
            contributions: 'Contributions',
            scenarios: 'Scenarios'
        };

        /*
         * Troll Shortcuts
         */

        Mousetrap.bind("k i t t i e s", function () {
            $scope.kitties = ['https://source.unsplash.com/random/280x160/?kitten',
                              'https://source.unsplash.com/random/280x160/?kitty',
                              'https://source.unsplash.com/random/280x160/?lynx',
                              'https://source.unsplash.com/random/280x160/?lion',
                              'https://source.unsplash.com/random/280x160/?tiger'];
            $scope.$apply($scope.updateDisplayedItems);
        });

        Mousetrap.bind("o h n o e s", function () {
            $(".image-project-image").css("transform-origin", "right bottom");
            $(".image-project-image").css("transition", "1s all");
            $(".image-project-image").css("transform", "perspective(800px) rotateX(90deg)");
            $scope.kitties = [];
            $timeout($scope.updateDisplayedItems, 1000);
        });

        $scope.newAutomationProject = function () {
            CreateModalFromTemplate("/templates/bundles/automation/new-automation-project.html", $scope, null);
        };

        TaggingService.fetchGlobalTags();
    });

    app.service('ProjectFolderContext', function($state, $stateParams) {
        let foldersInPath;
        function getCurrentProjectFolderId() {
            if ($state.current.name != 'project-list') {
                return null;
            } else {
                return $stateParams.folderId || null;
            }
        }
        function setProjectFoldersInPath(fip) {
            foldersInPath = fip;
        }
        function getProjectFoldersInPath() {
            return foldersInPath;
        }
        function getCurrentProjectFolder() {
            return foldersInPath && foldersInPath.length > 0 && foldersInPath[foldersInPath.length - 1];
        }
        return {
            getCurrentProjectFolderId: getCurrentProjectFolderId,
            setProjectFoldersInPath: setProjectFoldersInPath,
            getProjectFoldersInPath: getProjectFoldersInPath,
            getCurrentProjectFolder: getCurrentProjectFolder
        };
    });

    //Just a template wrapper so far.
    app.directive('projectFolder', function(NO_PERMISSION_TOOLTIP_MSG) {
        return {
            templateUrl: '/templates/projects-list/project-folder.html',
            replace: true,
            scope: {
                item: "=",
                isFiltering: "&",
                displayProjectFolderPermissionsModal: "&",
                toggleMenu: '&',
                openFolderMenu: "&",
                isFolderSelected: "&",
                disableMenu: "@?"
            },
            link: (scope, elem, attrs) => {
                scope.NO_PERMISSION_TOOLTIP_MSG = NO_PERMISSION_TOOLTIP_MSG;
                if (attrs.disableMenu === undefined) {
                    scope.disableMenu = false;
                } else if (scope.disableMenu === "") {
                    scope.disableMenu = true;
                }
            }
        }
    });

    app.controller("BrowseProjectsCommonController", ($scope, DataikuAPI, $q, PromiseService) => {
        $scope.currentFolder = {};
        $scope.browseDoneFn = folder => {
            $scope.currentFolder = folder;
        }

        $scope.browse = folderIds =>  {
            return PromiseService.qToHttp($q(resolve => {
                const ids = folderIds.split('/');
                $scope.destination = ids[ids.length - 1];
                DataikuAPI.projectFolders.listContents($scope.destination, true, 1, true).success(data => {
                    const projectsMap = {};
                    data.projects.forEach(p => { projectsMap[p.projectKey] = p; });
                    const projectsList = data.folder.projectKeys.map(projectKey => projectsMap[projectKey]).filter(p => p != null);
                    const folders = data.folder.children.map(f => angular.extend({}, f, { directory: true, fullPath: f.id }))
                    const pathElts = treeToList(data.folder, item => item.parent);

                    resolve({
                        children: folders.concat(projectsList),
                        pathElts: pathElts.map(f => angular.extend({}, f, { toString: () => f.id })),
                        exists: true,
                        directory: true,
                    });
                }).error(setErrorInScope.bind($scope));
            }));
        };
        $scope.getName = item => item.name;
    });

    app.controller("ProjectFolderSettings", ($scope, DataikuAPI) => {
        $scope.getSettings = function(folder) {
            DataikuAPI.projectFolders.getSettings(folder.id).success(settings => {
                $scope.projectFolderSettings = settings;
                $scope.oldProjectFolderSettings = angular.copy(settings);
                $scope.ui = $scope.ui || {};
                $scope.ui.owner = settings.owner;
            }).error(setErrorInScope.bind($scope));
        }
    });

    app.controller("MoveItemsModalController", ($scope, $controller, DataikuAPI, ProjectFolderContext, Dialogs, $state) => {
        $controller("BrowseProjectsCommonController", { $scope });

        $scope.ProjectFolderContext = ProjectFolderContext;

        $scope.canBrowse = item => item.directory && $scope.movingFolders.findIndex(mf => mf.id === item.id) === -1;

        $scope.canSelect = () => false;

        $scope.confirm = () => {
            DataikuAPI.projectFolders.moveItems($scope.destination, $scope.movingFolders.map(f => f.id), $scope.movingProjects.map(p => p.projectKey), ProjectFolderContext.getCurrentProjectFolderId()).success(() => {
                $scope.listContent(false).success(() => {
                    $scope.unselectAll();
                    $scope.dismiss();
                }).error(() =>
                {
                    $scope.unselectAll(); // Necessary to avoid a logged error after redirected
                    const go = $state.go.bind($state, "project-list", { folderId: '' });
                    Dialogs.ack($scope, "Not authorized", "Since you don't have permission on this folder anymore, you will be redirected to root").then(go, go);
                });
            }).error(setErrorInScope.bind($scope));
        };
    });

    app.controller("DeleteProjectFolderModalController", ($scope, $controller, $state, DataikuAPI, ProjectFolderContext) => {
        $controller("BrowseProjectsCommonController", { $scope });

        $scope.canBrowse = item => item.directory && $scope.folders.findIndex(mf => mf.id === item.id) === -1;

        $scope.canSelect = () => false;

        $scope.confirm = () => {
            DataikuAPI.projectFolders.delete($scope.folders.map(f => f.id), $scope.destination ? $scope.destination : $scope.newFolderId).success(() => {
                $scope.dismiss();
                if (($scope.folders || []).length == 1 && $scope.folders[0].id == ProjectFolderContext.getCurrentProjectFolderId()) {
                    $state.go('project-list', { folderId: ($scope.folders[0].parent || {}).id || '' });
                } else {
                    $scope.listContent();
                }
            }).error(setErrorInScope.bind($scope));
        };
    });

    app.controller("RenameProjectFolderModalController", ($scope, $controller, DataikuAPI) => {
        $controller("NameFolderCommonController", { $scope });
        $controller("ProjectFolderSettings", { $scope });

        $scope.$watch("folder", function(nv) {
            if (!nv) return;
            $scope.getSettings(nv);
        });

        $scope.confirm = () => {
            DataikuAPI.projectFolders.setSettings($scope.folder.id, angular.extend($scope.projectFolderSettings, { name: $scope.newName })).success(() => {
                $scope.listContent().then(() => $scope.unselectAll());
                $scope.dismiss();
            }).error(setErrorInScope.bind($scope));
        };
    });

    app.controller("ProjectFolderPermissionsModalController", ($scope, $controller, WT1, DataikuAPI, CreateModalFromTemplate,
        PermissionsService) => {
        $controller("ProjectFolderSettings", { $scope });

        function makeNewPerm(){
            $scope.newPerm = {
                read: true
            }
        }
        makeNewPerm();

        $scope.$watch("folder", function(nv) {
            if (!nv) return;
            DataikuAPI.security.listGroups(false).success(function(allGroups) {
                $scope.allGroups = allGroups;
                DataikuAPI.security.listUsers().success(function(data) {
                    $scope.allUsers = data;

                    $scope.allUsers.sort(function(a, b){
                        if (a.displayName < b.displayName) return -1;
                        if (a.displayName > b.displayName) return 1;
                        return 0;
                    });
                    $scope.getSettings(nv);
                }).error(setErrorInScope.bind($scope));
            }).error(setErrorInScope.bind($scope));
        });


        $scope.addPermission = function() {
            $scope.projectFolderSettings.permissions.push($scope.newPerm);
            makeNewPerm();
        };

        $scope.getEffectiveReaders = function() {
            WT1.event("project-list-folder-effective-reader", {});
            DataikuAPI.projectFolders.getEffectiveReaders($scope.folder.id)
                .success((data) => {
                    const newScope = $scope.$new();
                    newScope.effectiveReaders = data;
                    CreateModalFromTemplate("/templates/projects-list/modals/project-folder-effective-readers-modal.html", newScope, null);
                })
                .error(setErrorInScope.bind($scope));
        };

        $scope.$watch("projectFolderSettings.permissions", function(nv, ov) {
            if (!nv) return;

            $scope.unassignedGroups = PermissionsService.buildUnassignedGroups($scope.projectFolderSettings, $scope.allGroups);

            /* Handle implied permissions */
            $scope.projectFolderSettings.permissions.forEach(function(p) {
                p.$readDisabled = false;
                p.$writeContentsDisabled = false;
                p.$adminDisabled = false;

                if (p.admin) {
                    p.$readDisabled = true;
                    p.$writeContentsDisabled = true;
                }
                if (p.writeContents) {
                    p.$readDisabled = true;
                }
            });

        }, true)

        // Ownership mgmt
        $scope.$watch("ui.owner", function() {
            PermissionsService.transferOwnership($scope, $scope.projectFolderSettings, "project folder", "owner");
        });

        $scope.confirm = () => {
            if (!angular.equals($scope.oldProjectFolderSettings.permissions, $scope.projectFolderSettings.permissions)) {
                const perms = angular.copy($scope.projectFolderSettings.permissions);
                perms.forEach(perm => { delete perm.group; });
                WT1.event("project-list-folder-permissions", { permissions: perms });
            }
            DataikuAPI.projectFolders.setSettings($scope.folder.id, $scope.projectFolderSettings).success(() => {
                $scope.listContent().then(() => $scope.unselectAll());
                $scope.dismiss();
            }).error(setErrorInScope.bind($scope));
        };
    });
}());

(function(){
'use strict';

var app = angular.module('dataiku.integrations.alation', []);

app.factory("AlationCatalogChooserService", function($rootScope, $state, $stateParams){
    var data = {
        chooser: null
    }

    var svc = {
        install: function(){

            var alationURL = $rootScope.appConfig.alationSettings.alationURL;

            var script = document.createElement('script');
            script.src = alationURL + "/integration/catalog_chooser/v1/sdk.js";
            script.type = 'text/javascript';
            script.async = "true";
            var script0 = document.getElementsByTagName("script")[0];
            script0.parentNode.insertBefore(script, script0);
        },

        openChooser: function(){
            if (data.chooser == null) {
                data.chooser = Alation.Catalog.createChooser({
                    embedMethod: Alation.Catalog.ChooserEmbedMethod.MODAL,
                    onSelect: svc.onSelect,
                    onCancel: function(){
                        data.chooser = null;
                    },
                    acceptObjectTypes: [
                        "table"
                    ],
                    acceptDataSourceTypes: [
                        "bigquery",
                        "greenplum",
                        "hive2",
                        "mysql",
                        "netezza",
                        "oracle",
                        "postgresql",
                        "redshift",
                        "sap",
                        "snowflake",
                        "sqlserver",
                        "synapse",
                        "teradata",
                        "vertica"
                    ]
                })
            }

            data.chooser.open();
        },

        onSelect: function(selectedObject) {
            data.chooser.destroy();
            data.chooser = null;
            // $rootScope.alationCatalogSelection = selectedObject;
            $state.go("projects.project.tablesimport", {
                importData : JSON.stringify({
                    workflowType: "ALATION_MCC",
                    alationSelection: selectedObject
                })
            });
        }
    }

    return svc;
});

}());

(function() {
'use strict';

var app = angular.module('dataiku.datasets', []);

app.factory("DatasetCustomFieldsService", function($rootScope, TopNav, DataikuAPI, ActivityIndicator, CreateModalFromTemplate, WT1, SmartId){
    let svc = {};

    svc.customFieldsMap = function() {
        return $rootScope.appConfig.customFieldsMap['DATASET'];
    };

    svc.saveCustomFields = function(dataset, newCustomFields) {
        WT1.event('custom-fields-save', {objectType: 'DATASET'});
        let oldCustomFields = angular.copy(dataset.customFields);
        dataset.customFields = newCustomFields;
        return DataikuAPI.datasets.save(dataset.projectKey, dataset, {summaryOnly:true}).success(function(data) {
                ActivityIndicator.success("Saved");
                $rootScope.$broadcast('customFieldsSaved', TopNav.getItem(), dataset.customFields);
                $rootScope.$broadcast('reloadGraph');
            }).error(function(a, b, c) {
                dataset.customFields = oldCustomFields;
                setErrorInScope.bind($rootScope)(a, b, c);
            });
    };

    svc.canEditCustomFields = function() {
        let item = TopNav.getItem();
        let fullId = SmartId.resolve(item.id);
        return fullId && fullId.projectKey && fullId.id;
    };

    svc.editCustomFields = function() {
        if (!svc.canEditCustomFields()) {
            return;
        }
        let item = TopNav.getItem();
        let fullId = SmartId.resolve(item.id);
        DataikuAPI.datasets.getSummary(fullId.projectKey, fullId.id).success(function(data) {
            let dataset = data.object;
            let modalScope = angular.extend($rootScope, {objectType: 'DATASET', objectName: dataset.name, objectCustomFields: dataset.customFields});
            CreateModalFromTemplate("/templates/taggable-objects/custom-fields-edit-modal.html", modalScope).then(function(customFields) {
                svc.saveCustomFields(dataset, customFields);
            });
        }).error(setErrorInScope.bind($rootScope));
    };

    svc.buildCustomFieldsPreviews = function(customFields) {
        const ret = [];
        const customFieldsMap = $rootScope.appConfig.customFieldsMap['DATASET'];
        for (let i = 0; i < customFieldsMap.length; i++) {
            const selectCFList = (customFieldsMap[i].customFields || []).filter(cf => cf.type == 'SELECT');
            for (let j = 0; j < selectCFList.length; j++) {
                const cfDef = selectCFList[j];
                if (cfDef.iconInDatasetPreview) {
                    const value = (cfDef.selectChoices || []).find(choice => choice.value == (customFields && customFields[cfDef.name] || cfDef.defaultValue));
                    if (value) {
                        ret.push({definition: cfDef, value: value});
                    }
                }
            }
        }
        return ret;
    };

    return svc;
});

})();

(function() {
'use strict';

var app = angular.module('dataiku.datasets.partitioning', []);

app.controller("GeneralEditPartitioningCtrl", function($scope, DataikuAPI) {
    $scope.isPartitioned = function () {
        return $scope.dataset.partitioning != null && $scope.dataset.partitioning.dimensions.length > 0;
    };

    $scope.hasTimeDimension = function () {
        if(! $scope.isPartitioned()){
            return false;
        }
        return $.grep($scope.dataset.partitioning.dimensions, function(item){return item.type == 'time'}).length > 0;
    };

    $scope.activatePartititioning = $scope.dataset.partitioning.dimensions.length > 0;

    $scope.testPartitioning = {};
    $scope.runTestPartitioning = function(){
        DataikuAPI.datasets.testGeneralPartitioning($scope.dataset).success(function(data){
            $scope.testPartitioning = data;
        })
    }
});

app.directive('panePartitioning', function() {
    return {
        restrict: 'A',
        replace: true,
        templateUrl: '/templates/datasets/pane-partitioning.html',
        scope: {
            dataset : '=',
            detectScheme : '=',
            testScheme : '='
        },
        link: function($scope, element, attrs){
            $scope.isPartitioned = function () {
                return $scope.dataset.partitioning != null && $scope.dataset.partitioning.dimensions.length > 0;
            };

            $scope.hasTimeDimension = function () {
                if(! $scope.isPartitioned()){
                    return false;
                }
                return $.grep($scope.dataset.partitioning.dimensions, function(item){return item.type == 'time'}).length > 0;
            };

            $scope.uiState = {
                partitioningActivated: $scope.dataset.partitioning && $scope.dataset.partitioning.dimensions.length > 0
            }


            $scope.$watch('uiState.partitioningActivated', function(nv, ov){
                if(nv !== ov && nv){
                    // run detection
                    $scope.detectScheme().success(function(data){
                        $scope.detectedScheme = data.detectedScheme;
                    }).error(setErrorInScope.bind($scope));
                }
            })

            $scope.detectedScheme = {};

            $scope.$patterns = [];

            $scope.$watch('dataset.partitioning.dimensions', function(nv, ov){
                $scope.$patterns = [];
                angular.forEach(nv, function(dimension){
                   var pattern;
                   dimension.$patterns = [];
                    if(dimension.type == 'value') {
                        pattern = {name: dimension.name + " (%{" + dimension.name + "})", pattern: '%{' + dimension.name + '}'};
                        $scope.$patterns.push(pattern);
                        dimension.$patterns.push(pattern);
                    } else {
                        pattern = {name: 'YEAR (%Y)',pattern: '%Y'};
                        $scope.$patterns.push(pattern);
                        dimension.$patterns.push(pattern);
                        if(dimension.params.period == 'MONTH'){
                            pattern = {name: 'MONTH (%M)', pattern: '%M'};
                            dimension.$patterns.push(pattern);
                            $scope.$patterns.push(pattern);
                        } else if(dimension.params.period == 'DAY'){
                            pattern = {name: 'MONTH (%M)', pattern: '%M'};
                            $scope.$patterns.push(pattern);
                            dimension.$patterns.push(pattern);
                            pattern = {name: 'DAY (%D)', pattern: '%D'};
                            $scope.$patterns.push(pattern);
                            dimension.$patterns.push(pattern);
                        } else if(dimension.params.period == 'HOUR') {
                            pattern = {name: 'MONTH (%M)', pattern: '%M'};
                            dimension.$patterns.push(pattern);
                            $scope.$patterns.push(pattern);
                            pattern = {name: 'DAY (%D)', pattern: '%D'};
                            $scope.$patterns.push(pattern);
                            dimension.$patterns.push(pattern);
                            pattern = {name: 'HOUR (%H)', pattern: '%H'};
                            $scope.$patterns.push(pattern);
                            dimension.$patterns.push(pattern);
                        }
                    }
                })

                // if we delete the last dimension and there is no detection yet, trigger one
                // do not run this test on initialization
                var noFilePathPattern = !$scope.detectedScheme || !$scope.detectedScheme.filePathPattern;
                if((nv == null || nv.length == 0) && nv !== ov && noFilePathPattern){
                    // run detection
                    $scope.detectScheme().success(function(data){
                        $scope.detectedScheme = data.detectedScheme;
                    }).error(setErrorInScope.bind($scope));
                }
                $scope.usedPatterns();
            },true)

            $scope.usedPatterns = function(){
                angular.forEach($scope.$patterns, function(pattern){
                    pattern.used = $scope.dataset.partitioning.filePathPattern && $scope.dataset.partitioning.filePathPattern.indexOf(pattern.pattern) >= 0;
                })
            };

            $scope.hasPatternsToInsert = function (dimension) {
                var hasPatternToInsert=false;
                angular.forEach(dimension.$patterns, function(pattern) {
                   if (!pattern.used) {
                      hasPatternToInsert = true;
                   }
                });
                return hasPatternToInsert;
            }

            $scope.insertPattern = function (pattern) {
              var filePathPattern = $scope.dataset.partitioning.filePathPattern;
               if (filePathPattern) {
                    if (filePathPattern.indexOf("/.*", filePathPattern.length -3) != -1) {
                        $scope.dataset.partitioning.filePathPattern = filePathPattern.substring(0, filePathPattern.length-3) + "/" + pattern.pattern + "/.*";
                    } else {
                        $scope.dataset.partitioning.filePathPattern = $scope.dataset.partitioning.filePathPattern + pattern.pattern;
                    }
               } else {
                    $scope.dataset.partitioning.filePathPattern = pattern.pattern + "/.*";
               }
            }

            $scope.$watch('$patterns', function(nv, ov){
                // remove patterns not used anymore
                angular.forEach(ov, function(pattern){
                    if($.grep(nv, function(p){return p.pattern == pattern.pattern}).length == 0){
                        $scope.dataset.partitioning.filePathPattern = $scope.dataset.partitioning.filePathPattern ? $scope.dataset.partitioning.filePathPattern.replace(pattern.pattern, '') : '';
                    }
                })
            })

            // update patterns usage when filePathPattern is changed
            $scope.$watch('dataset.partitioning.filePathPattern', function(nv, ov){
                $scope.usedPatterns();
            })

            $scope.testPartitioning = {};
            $scope.runTestPartitioning = function(){
                $scope.testScheme().success(function(data){
                    $scope.testPartitioning = data;
                }).error(setErrorInScope.bind($scope));
            }
        }
    };
});

})();

(function() {
'use strict';

var app = angular.module('dataiku.datasets');


// All Row-Oriented DS (including SQL)
app.controller("BaseRowDatasetController", function($scope, LoggerProvider, DataikuAPI, DatasetUtils, WT1, withConsistency) {
    var Logger = LoggerProvider.getLogger('datasets.row');

    $scope.dimensionTypes = [
        { type: 'time',  label: 'Time range' },
        { type: 'value', label: 'Discrete values' }
    ];
    $scope.timeDimensionPeriods = ["YEAR", "MONTH", "DAY", "HOUR"];

    // Consistency methods
    if (!withConsistency) {
        Logger.warn("Consistency not implemented");
        return;
    }
    $scope.setSchemaUserModified = function() {
        $scope.schemaJustModified = true;
        $scope.dataset.schema.userModified = true;
    };

    $scope.discardSchemaChanges = function() {
        // To discard schema changes, we mark the schema as not modified and trigger a new preview.
        // The backend will thus discard our schema changes but keep our comments when applicable.
        Logger.info("Discarding schema changes");
        if ($scope.dataset.schema) {
            $scope.dataset.schema.userModified = false;
        }
        $scope.test(false);
    };

    $scope.checkConsistency = function() {
        Logger.info('Checking consistency');

        $scope.schemaJustModified = false;
        DataikuAPI.datasets.testSchemaConsistency($scope.dataset).success(function (data) {
            Logger.info("Got consistency result", data);
            $scope.consistency = data;
            $scope.consistency.kind = DatasetUtils.getKindForConsistency($scope.dataset);
        }).error(setErrorInScope.bind($scope));
    };

    $scope.discardConsistencyError = function() {
        $scope.consistency = null;
    };

    $scope.overwriteSchema = function(newSchema) {
        WT1.event("dataset-discard-schema-changed", { datasetType: $scope.dataset.type, datasetManaged: $scope.dataset.managed });
        $scope.dataset.schema = angular.copy(newSchema);
        $scope.schemaJustModified = false;
        $scope.consistency = null;
        $scope.checkConsistency();
    };
});


// NoSQL Row-Oriented DS
app.controller("BaseNoSQLRowDatasetController", function($scope, $stateParams, $controller, LoggerProvider, DataikuAPI, Dialogs, withConsistency) {
    $controller("BaseRowDatasetController", {$scope: $scope, withConsistency: withConsistency});

    var Logger = LoggerProvider.getLogger('datasets.row');

    // Finish dataset initialization if needed
    if (! $scope.dataset.schema) {
        $scope.dataset.schema = { columns: [] };
    }

    $scope.$watch('dataset.type', function (nv, ov) {
        DataikuAPI.connections.getNames($scope.dataset.type).success(function (data) {
            $scope.connections = data;
            if (!$scope.dataset.params.connection && data.length) {
                $scope.dataset.params.connection = data[0];
                $scope.test(true);
            }
        }).error(setErrorInScope.bind($scope));
    });

    $scope.inferStorageTypesFromData = function(){
        Dialogs.confirm($scope,
            "Infer storage types from data",
            "This only takes into account a very small sample of data, and could lead to invalid data. "+
            "For safer typing of data, use a prepare recipe.").then(function(){
                $scope.dataset.schema.userModified = false;
                $scope.test(false, true);
        });
    };


    // requires $scope.testAPI and $scope.testCallback
    $scope.test = function (connectionOnly, inferStorageTypes, listTables) {
        $scope.testing = true;
        $scope.testResult = null;
        $scope.schemaJustModified = false;
        if (angular.isUndefined($scope.dataset.params.connection)) {
            Logger.info('Not testable');
            $scope.testing = false;
            $scope.testResult = { connectionOK: false, connectionErrorMsg: "no connection defined" };
            return;
        }
        $scope.testAPI($stateParams.projectKey, $scope.dataset, connectionOnly, inferStorageTypes, listTables)
            .success(function (data) {
                Logger.info('Got test result');
                $scope.testing = false;
                $scope.testResult = data;
                $scope.testCallback(connectionOnly, data);
            })
            .error(function (data) { $scope.testing = false; });
    };

    $scope.onLoadComplete = function() {
        if ($scope.$eval('dataset.params.connection')) {
            $scope.test(true);
        }
    };
});


app.controller("BaseNoSQLRowDatasetControllerWithSingleColumnPartitioning", function($scope, $controller, withConsistency) {
    $controller("BaseNoSQLRowDatasetController", {$scope: $scope, withConsistency: withConsistency});

    $scope.$watch('dataset.params', function (nv, ov) {
        $scope.dataset.partitioning = $scope.dataset.partitioning || {};
        $scope.dataset.partitioning.dimensions = $scope.dataset.partitioning.dimensions || [];
        const dimensions = $scope.dataset.partitioning.dimensions;
        if ($scope.dataset.params.partitioned) {
            if (!dimensions.length) {
                dimensions.push({
                    name: 'time',
                    type: 'value',
                    params: {}
                });
            }
            if (angular.isDefined($scope.dataset.params.partitioningColumn)) {
                dimensions[0].name = $scope.dataset.params.partitioningColumn;
            }
        }
        else {
            $scope.dataset.partitioning.dimensions = [];
            delete $scope.dataset.params.partitioningColumn;
            delete $scope.dataset.params.explicitPartitionsList;
        }
    }, true);

});


app.controller("MongoDBDatasetController", function($scope, $controller, DataikuAPI, DatasetUtils) {
    $controller("BaseNoSQLRowDatasetControllerWithSingleColumnPartitioning", {$scope: $scope, withConsistency: true});

    $scope.testAPI = DataikuAPI.datasets.mongoDB.test;

    $scope.testCallback = function (connectionOnly, data) {
        if (!connectionOnly) {
            $scope.dataset.schema = (data.schemaDetection || {}).newSchema;
            $scope.consistency = { empty : false, result : data.schemaDetection };
            $scope.consistency.kind = DatasetUtils.getKindForConsistency($scope.dataset);

            if (!$scope.dataset.name && !$scope.new_dataset_name_manually_edited) {
                $scope.new_dataset_name = $scope.testResult.suggestedName;
            }
        }
    };

    /* For managed only */
    $scope.createCollection = function() {
        DataikuAPI.datasets.mongoDB.createCollection($scope.dataset).success(function (data) {
            $scope.test(false);
        }).error(setErrorInScope.bind($scope));
    };

    $scope.deleteCollection = function() {
        DataikuAPI.datasets.mongoDB.deleteCollection($scope.dataset).success(function (data) {
            $scope.test(false);
        }).error(setErrorInScope.bind($scope));
    };
});

app.controller("DynamoDBDatasetController", function($scope, $controller, DataikuAPI, DatasetUtils, Dialogs) {
    $controller("BaseNoSQLRowDatasetControllerWithSingleColumnPartitioning", {$scope: $scope, withConsistency: true});


    $scope.testAPI = DataikuAPI.datasets.dynamoDB.test;

    $scope.testCallback = function (connectionOnly, data) {
        if (!connectionOnly) {
            $scope.dataset.schema = (data.schemaDetection || {}).newSchema;
            $scope.consistency = { empty : false, result : data.schemaDetection };
            $scope.consistency.kind = DatasetUtils.getKindForConsistency($scope.dataset);

            if (!$scope.dataset.name && !$scope.new_dataset_name_manually_edited) {
                $scope.new_dataset_name = $scope.testResult.suggestedName;
            }
        }
    };

    $scope.createTable = function() {
        DataikuAPI.datasets.dynamoDB.createTable($scope.dataset).success(function (data) {
            $scope.test(false);
        }).error(setErrorInScope.bind($scope));
    };

    $scope.deleteTable = function() {
        DataikuAPI.datasets.dynamoDB.deleteTable($scope.dataset).success(function (data) {
            $scope.test(false);
        }).error(setErrorInScope.bind($scope));
    };

    $scope.updateIndex = function() {
        $scope.saveDataset().then(function() {
            DataikuAPI.datasets.dynamoDB.updateIndex($scope.dataset).success(function (data) {
                $scope.test(false);
            }).error(setErrorInScope.bind($scope));
        },setErrorInScope.bind($scope));
    };

    $scope.gotoSearchAndImport = function () {
            $scope.uiState.bypassDirtinessCheck = true;
            DataikuAPI.connections.countIndexedAndUnindexed().success(function (data) {
                if (data.indexedConnections > 0) {
                    $state.go('projects.project.catalog.items');
                } else {
                    $state.go("projects.project.catalog.connectionexplorer")
                }

            }).error(setErrorInScope.bind($scope));
    };

    $scope.getAllTables = function(){
                Dialogs.confirmUnsafeHTML($scope, "Really list all tables?",
                    "<p>This will list <strong>all tables in all schemas</strong> of your database.</p>"+
                    "<p> On large entreprise databases, this is likely "+
                    "to be extremely long and to cause your browser to become unresponsive.</p>").then($scope.test.bind(this,false,false,true));
    };

});


app.controller("BaseCassandraDatasetController", function($scope, $controller, DataikuAPI) {
    $controller("BaseNoSQLRowDatasetControllerWithSingleColumnPartitioning", {$scope: $scope, withConsistency: false});

    $scope.overwriteSchemaFromTable = function () {
        $scope.dataset.schema = {
            userModified: false,
            columns: $scope.testResult.tableSchema.columns
        };
        $scope.test(true);
    };

    $scope.testAPI = DataikuAPI.datasets.cassandra.test;

    $scope.testCallback = function (connectionOnly, data) {
        if (! $scope.dataset.managed && (!$scope.dataset.schema || !$scope.dataset.schema.columns || $scope.dataset.schema.columns.length == 0) && $scope.testResult.tableSchema) {
            // Overwrite schema using detected schema, if we have none
            $scope.dataset.schema = {
                userModified: false,
                columns: $scope.testResult.tableSchema.columns
            };
            $scope.testResult.schemaMatchesTable = true;
        }
    };
});


app.controller("ManagedCassandraDatasetController", function($scope, $controller, DataikuAPI, Dialogs) {
    $controller("BaseCassandraDatasetController", {$scope: $scope});

    $scope.createTable = function() {
        DataikuAPI.datasets.cassandra.createTable($scope.dataset)
            .success($scope.test.bind($scope, false))
            .error(setErrorInScope.bind($scope));
    };

    $scope.dropTable = function() {
        Dialogs.confirm($scope,'Drop table','Are you sure you want to drop the Cassandra table?').then(function(){
            DataikuAPI.datasets.cassandra.dropTable($scope.dataset)
                .success($scope.test.bind($scope, false))
                .error(setErrorInScope.bind($scope));
        });
    };
});


app.controller("ExternalCassandraDatasetController", function($scope, $controller) {
    $controller("BaseCassandraDatasetController", {$scope: $scope});
});


app.controller("ElasticSearchDatasetController", function($scope, $controller, DataikuAPI) {
    $controller("BaseNoSQLRowDatasetController", {$scope: $scope, withConsistency: true});

    $scope.$watch('dataset.params', function (nv, ov) {
        if ($scope.testResult && !$scope.testResult.testedConnectionOnly && (nv.index !== ov.index || nv.type !== ov.type)) {
            $scope.testResult.testedConnectionOnly = true;
        }
        /* For ElasticSearch, we have:
         *    - managed = partition-by-alias, only partitioning definition in dataset config
         *    - not-managed = partition-by-column, with "partitioned" and "partitioningColumn"
         *                    in the dataset config
         *
         * In the managed case, we DO NOT do anything to the dataset config.
         */
        $scope.dataset.partitioning = $scope.dataset.partitioning || {};
        if (!$scope.dataset.params.partitioned || !$scope.dataset.partitioning.dimensions) {
            $scope.dataset.partitioning.dimensions = [];
        }
        const dimensions = $scope.dataset.partitioning.dimensions;
        if ($scope.dataset.params.partitioned) {
            if (dimensions.length === 0) {
                dimensions.push({
                    name: 'time',
                    type: 'value',
                    params: {}
                });
            }
            if (angular.isDefined($scope.dataset.params.partitioningColumn)) {
                dimensions[0].name = $scope.dataset.params.partitioningColumn;
            }
        }
    }, true);

    $scope.partitionTemplate = { type: 'value' };
    $scope.checkPartitionDimension = function(it) {
        return it.type && it.name && (it.type !== 'time' || it.params.period);
    };

    $scope.testAPI = function() {
        return DataikuAPI.datasets.elasticsearch.test.apply(null, arguments)
            .success(function(data) {
                if (data.defaultMapping) { // prettify
                    data.defaultMapping = JSON.stringify(JSON.parse(data.defaultMapping), null, '  ');
                }
                return data;
            });
    };
    $scope.testCallback = function (connectionOnly, data) {
        if (!connectionOnly && data.schemaDetection) {
            $scope.dataset.schema = data.schemaDetection.newSchema;
        }
        $scope.documentTypeNeeded = ['ES_LE_2', 'ES_5'].includes($scope.testResult.dialect);
        if ($scope.testResult.version != undefined) { // server unreachable will not return any ES version
            var terms = $scope.testResult.version.split('.');
            if(terms.length >= 2){
                var major = parseInt(terms[0]);
                var minor = parseInt(terms[1]);
                if(major < 6 || (major == 6 && minor <2)) {
                    $scope.indexDocumentTypePattern = new RegExp('^(?!_).+$');
                } else if (major == 6 && minor >= 2) {
                    $scope.indexDocumentTypePattern = new RegExp('^((?!_).+)$|^_doc$');
                }
            } else {
                $scope.indexDocumentTypePattern = new RegExp('^(?!_).+$');
            }
        }
    };

    $scope.$watch('dataset.params.connection', function (){
        //Wait init before watching changes.
        if($scope.testResult){
            $scope.test(true);
        }
    });
    $scope.documentTypeNeeded = false;
});

}());

(function() {
'use strict';

var app = angular.module('dataiku.datasets');

app.controller("BaseSQLDatasetController", function($scope, $stateParams, $controller, DataikuAPI, withConsistency) {
    $controller("BaseRowDatasetController", {$scope: $scope, withConsistency: withConsistency});

    $scope.partitionsList = {};

    $scope.isCatalogAware = function() {
        return $scope.dataset.type && ($scope.dataset.type === 'Snowflake' || $scope.dataset.type === 'BigQuery');
    };

    $scope.isSchemaAware = function() {
        return $scope.dataset.type && $scope.dataset.type != 'MySQL' && $scope.dataset.type != 'hiveserver2';
    };

    $scope.hooks = {};

    $scope.setConnections = function(data) {
        $scope.connections = data;
        if (!$scope.dataset.params.connection && data.length) {
            $scope.dataset.params.connection = data[0];
            $scope.test(false, false);
        }
    };

    $scope.hooks.getConnectionNames = function() {
        DataikuAPI.connections.getNames($scope.dataset.type).success(function (data) {
            $scope.setConnections(data);
        }).error(setErrorInScope.bind($scope));
    };

    $scope.$watch('dataset.type', function() {
        $scope.hooks.getConnectionNames();

        if ($scope.dataset && $scope.dataset.type == "Teradata" && $scope.dataset.params && !$scope.dataset.params.assumedTzForUnknownTz) {
            $scope.dataset.params.assumedTzForUnknownTz = "GMT";
            $scope.dataset.params.assumedDbTzForUnknownTz = "GMT";
        }

    });

    $scope.supportsNativePartitioning = function () {
        return $scope.dataset !== null && $scope.dataset.type == 'Vertica';
    };
    $scope.listPartitions = function () {
        $scope.partitionsList.list = null;
        $scope.partitionsList.error = null;
        DataikuAPI.datasets.externalSQL.listPartitions($stateParams.projectKey, $scope.dataset).success(function (data) {
            $scope.partitionsList.list = data;
            if (data.length > 0 && $scope.dataset.params.previewPartition == null) {
                $scope.dataset.params.previewPartition = data[0];
            }
        }).error(function (data, status, error) {
            var err = getErrorDetails(data, status, error);
            $scope.partitionsList.errorMsg = getErrorDetails(data, status, error).detailedMessage;
            $scope.partitionsList.error = getErrorDetails(data, status, error);
        });
    };

    $scope.uiState = { codeSamplesSelectorVisible: false };

    /* Need to manually refresh code mirror on show.
     * as it will compute various dimensions and set them.
     *
     * Here we do refresh on any change of mode and partitioned,
     * to handle the two possible path to make the hidden codemirror
     * box to appear.
     */
    var refreshCodeMirrors = function() {
        $('.CodeMirror').each(function(i, el){
            if (el.CodeMirror != undefined) {
                setTimeout(function() {el.CodeMirror.refresh();}, 0);
            }
        });
    };
    $scope.isPartitioned = function() {
    	return $scope.dataset && $scope.dataset.partitioning && $scope.dataset.partitioning.dimensions && $scope.dataset.partitioning.dimensions.length > 0;
    };
    $scope.$watch("dataset.params.partitioned + dataset.params.mode", function() {
        if ($scope.isPartitioned()) {
        	refreshCodeMirrors();
        }
    });

    $scope.setPartitioned = function(activate) {
		$scope.dataset.partitioning = $scope.dataset.partitioning || {};
    	if (activate) {
    		$scope.dataset.partitioning.dimensions = $scope.dataset.partitioning.dimensions || [];
    		$scope.dataset.partitioning.dimensions.push({name:'', type:'value', params:{}});
    	} else {
    		$scope.dataset.partitioning.dimensions = [];
    	}
    };

    $scope.removeDimension = function(index) {
        $scope.dataset.partitioning.dimensions.splice(index, 1);
    };

    $scope.addDimension = function() {
        $scope.dataset.partitioning.dimensions.push({
            name : 'dim' + $scope.dataset.partitioning.dimensions.length,
            type : 'value',
            params : {}
        });
    };
});


app.controller("ExternalSQLDatasetController", function($scope, $stateParams, $controller, LoggerProvider, DataikuAPI, DatasetUtils, Dialogs, $state) {
    $controller("BaseSQLDatasetController", {$scope: $scope, withConsistency: true});

    var Logger = LoggerProvider.getLogger('datasets.sql');
    $scope.expandedDatasetParams = {}

    $scope.overwriteSchemaFromTable = function () {
        $scope.dataset.schema = {
            'userModified': false,
            'columns': $scope.testResult.querySchema.columns
        };
    };

    $scope.resetTableSelection = function () {
        if ($scope.testResult) {
            $scope.testResult.tablesList = null;
            $scope.dataset.params.table = null;
            $scope.dataset.params.schema = null;
            $scope.dataset.params.catalog = null;
        }
    };

    $scope.onLoadComplete = function () {
        if (angular.isUndefined($scope.dataset.params.mode)) {
            $scope.dataset.params.mode = 'table';
        }
        if (angular.isUndefined($scope.dataset.params.partitioningType)) {
            $scope.dataset.params.partitioningType = 'custom';
        }
        if (angular.isUndefined($scope.dataset.params.normalizeDoubles)) {
            $scope.dataset.params.normalizeDoubles = true;
        }
        if (angular.isUndefined($scope.dataset.params.readSQLDateColsAsDSSDates)) {
            $scope.dataset.params.readSQLDateColsAsDSSDates = $scope.appConfig.defaultReadSQLDatesAsDSSDates;
        }

        $scope.test(false, false);
    };

    $scope.gotoSearchAndImport = function () {
        $scope.uiState.bypassDirtinessCheck = true;
        DataikuAPI.connections.countIndexedAndUnindexed().success(function (data) {
            if (data.indexedConnections > 0) {
                $state.go('projects.project.catalog.items');
            } else {
                $state.go("projects.project.catalog.connectionexplorer")
            }

        }).error(setErrorInScope.bind($scope));
    };

    $scope.getAllTables = function(){
        Dialogs.confirmUnsafeHTML($scope, "Really list all tables?",
            "<p>This will list <strong>all tables in all schemas</strong> of your database.</p>"+
            "<p> On large entreprise databases, this is likely "+
            "to be extremely long and to cause your browser to become unresponsive.</p>"+
            "<p> To import existing tables, "+
            "it is recommended to use<br /> <a ng-click=\"dismiss(); gotoSearchAndImport()\">"+
            "<strong>New dataset &gt; Search &amp; Import</strong></a>, "+
            "which offers ability to filter, search and mass import</p>").then($scope.test.bind(this, true, false))
    }

    $scope.test = function (listTables, testTableOrQuery) {
        var previousTableList = $scope.testResult == null ? null : $scope.testResult.tablesList;

        $scope.testResult = null;
        $scope.testing = true;
        if (angular.isUndefined($scope.dataset.params.connection)) {
            $scope.testable = false;
            $scope.testing = false;
            return;
        } else {
            $scope.testable = true;
        }
        // Don't test obviously wrong stuff
        //if ($scope.dataset.params.partitioned == "true" && $scope.dataset.params.mode == "table")
        DataikuAPI.datasets.externalSQL.test($stateParams.projectKey, $scope.dataset, 15,
            listTables, testTableOrQuery).success(function (data) {
            Logger.info('Got test result');
            $scope.testing = false;
            $scope.testResult = data;
            if ($scope.testResult.queryOK && $scope.testResult.querySchema) {
                $scope.consistency = { empty : false, result : $scope.testResult.schemaDetection };
                $scope.consistency.kind = DatasetUtils.getKindForConsistency($scope.dataset);
                $scope.dataset.schema = $scope.testResult.schemaDetection.newSchema;
            }
            if ($scope.testResult.preview) {
                $scope.table = $scope.testResult.preview;
            }
            if (listTables) {
                if ($scope.testResult.schemaAware) {
                    if ($scope.testResult.catalogAware) {
                        angular.forEach($scope.testResult.tablesList, function(item) {
                            const qualifiedSchema = item.catalog ? (item.catalog + "." + item.schema) : item.schema;
                            item.qualified = qualifiedSchema + "." + item.table;
                            item.label = item.table + " (" + qualifiedSchema + ")";
                        });
                    } else {
                        angular.forEach($scope.testResult.tablesList, function(item) {
                            item.qualified = item.schema + "." + item.table;
                            item.label = item.table + " (" + item.schema + ")";
                        });
                    }
                } else {
                    angular.forEach($scope.testResult.tablesList, function(item) {
                        item.qualified = item.table;
                        item.label = item.table;
                    })
                }
            } else if (previousTableList) {
                $scope.testResult.tablesList = previousTableList;
            }
            if (!$scope.dataset.name && !$scope.new_dataset_name_manually_edited) {
                $scope.new_dataset_name = $scope.testResult.suggestedName;
            }
        }).error(function (a, b, c) {
            $scope.testing = false;
            setErrorInScope.bind($scope)(a,b,c);
        });
    };

    $scope.$watch("expandedDatasetParams.tableAndSchema", function(nv, ov) {
        if (nv) {
            $scope.dataset.params.table = nv.table;
            $scope.dataset.params.schema = nv.schema;
            $scope.dataset.params.catalog = nv.catalog;
        }
    });

    $scope.$watch("dataset.params", function(nv, ov) {
        if (nv) {
            $scope.expandedDatasetParams.tableAndSchema = {
                table : $scope.dataset.params.table,
                schema : $scope.dataset.params.schema,
                catalog : $scope.dataset.params.catalog
            }
        }
    }, true);

    /* Fixup everything we can ... */
    $scope.$watch('dataset.params', function (nv, ov) {
        if (nv && ov && nv.mode != ov.mode && $scope.testResult) {
            $scope.testResult.testedConnectionOnly = true;
        }
        // We DO NOT run a test each time params change because a test is a COSTLY
        // thing. We NEVER run it on simple model change, and in the specific case
        // of SQL, we even NEVER run it without explicit user action.
    }, true);

});

app.controller("ExternalHiveDatasetController", function($scope, $stateParams, $controller, LoggerProvider, DataikuAPI, DatasetUtils) {
    $controller("ExternalSQLDatasetController", {$scope: $scope});

    $scope.hooks.getConnectionNames = function() {
        DataikuAPI.connections.getHiveNames($stateParams.projectKey).success(function (data) {
            $scope.hiveConnections = data.map(function(db) {return {name:"@virtual(hive-jdbc):"+db, label:db};});
            $scope.setConnections($scope.hiveConnections.map(function(c) {return c.name;}));
        }).error(setErrorInScope.bind($scope));
    };


});


app.controller("ManagedSQLDatasetController", function($scope, $stateParams, $controller, $q, LoggerProvider, DataikuAPI, Dialogs, CreateModalFromTemplate, ActivityIndicator) {
    $controller("BaseSQLDatasetController", {$scope: $scope, withConsistency: true});

    var Logger = LoggerProvider.getLogger('datasets.sql');

    $scope.possibleTableCreationModes = [
        ["auto", "Automatically generate"],
        ["custom", "Manually define"]
    ]

    $scope.possibleSynapseDistribution = [
        ["ROUND_ROBIN", "Round robin"],
        ["HASH", "Hash"],
        ["REPLICATE", "Replicate"]
    ]

    $scope.copyCodeSnippet = function(snippet) {
        var stringToPutIntoClippboard = snippet.code;
        //ugly but necessary
        var textArea = document.createElement("textarea");
        textArea.style.position = 'absolute';
        textArea.style.top = '-1000px';
        textArea.style.left = '-1000px';
        textArea.value = stringToPutIntoClippboard;
        document.body.appendChild(textArea);
        textArea.select();
        try {
            var successful = document.execCommand('copy');
            if (successful) {
                ActivityIndicator.success("Sample copied into cliboard");
            } else {
                ActivityIndicator.error("Your browser does not support automatic copying into clibboard");
            }
        } catch (err) {
            ActivityIndicator.error("Your browser does not support automatic copying into clibboard");
        }
        document.body.removeChild(textArea);
    };

    $scope.revertToAutogeneratedStatement = function(){
        $scope.test(true).then(function() {
            $scope.dataset.params.customCreateStatement = $scope.testResult.autogeneratedCreateStatement;
        });
    };

    $scope.refreshToAutogeneratedStatement = function(){
        $scope.test(true).then(function() { });
    };

    $scope.onLoadComplete = function () {
        if (angular.isUndefined($scope.dataset.params.mode)) {
            $scope.dataset.params.mode = 'table';
        }
        if (angular.isUndefined($scope.dataset.params.partitioningType)) {
            $scope.dataset.params.partitioningType = 'custom';
        }
        if (angular.isUndefined($scope.dataset.params.normalizeDoubles)) {
            $scope.dataset.params.normalizeDoubles = true;
        }
        if (!$scope.dataset.params.tableCreationMode) {
            $scope.dataset.params.tableCreationMode = "auto";
        }

        if (angular.isUndefined($scope.dataset.params.tableDistributionMode)) {
            $scope.dataset.params.tableDistributionMode = 'ROUND_ROBIN';
        }

        // Fire initial test
        // On managed, we more or less guarantee that we only target a table, so it can't be too heavy
        // EXCEPT IN CASE OF PARTITIONING
        $scope.test(false, !$scope.dataset.params.partitioned);
    };

    $scope.dropTable = function () {
        Dialogs.confirm($scope,'Drop table','Are you sure you want to drop the SQL table ?').then(function(){
            DataikuAPI.datasets.managedSQL.dropTable($stateParams.projectKey, $scope.dataset).success(function (data) {
                if(data.length > 0) {
                    // TODO @flow
                    // Some error happened!
                    CreateModalFromTemplate("/templates/datasets/delete-dataset-results.html", $scope, null, function(newScope) {
                    	newScope.results = data;
                    });
                } else {
                    $scope.test(false, true);
                    $scope.checkConsistency();
                }
            }).error(setErrorInScope.bind($scope));
        });
    };

    $scope.createTable = function () {
        DataikuAPI.datasets.managedSQL.createTable($stateParams.projectKey, $scope.dataset).success(function (data) {
            $scope.test(false, true);
        }).error(setErrorInScope.bind($scope));
    };

    $scope.overwriteSchemaFromTable = function () {
        if (!$scope.dataset.schema) {
            $scope.dataset.schema = {};
        }
        $scope.dataset.schema.columns = $scope.testResult.currentTableSchema.columns;
        $scope.test(false, true);
    };

    $scope.filterEligibleBigQueryPartitionColumns = function(columns) {
        return columns.filter(c => (c.type === 'int' || c.type === 'tinyint' || c.type === 'bigint' || c.type === 'smallint' || c.type === 'date'));
    };

    $scope.filterEligibleBigQueryClusteringColumns = function(columns, clusteringIndex) {
        // Remove the columns that have a type that is not compatible with clustering
        let result = columns.filter(c => (c.type === 'string' || c.type === 'date' || c.type === 'boolean'
            || c.type === 'bigint' || c.type === 'int' || c.type === 'smallint' || c.type === 'tinyint'));

        // Remove the column used to partition the table
        result = result.filter(c => (c.name !== $scope.dataset.params.bigQueryPartitioningField));

        // Remove the columns used to cluster the table above.
        for (let i = 0; i < clusteringIndex; i++) {
            if ($scope.dataset.params.bigQueryClusteringColumns && $scope.dataset.params.bigQueryClusteringColumns.length > i) {
                result = result.filter(c => c.name !== $scope.dataset.params.bigQueryClusteringColumns[i].name);
            }
        }
        return result;
    };

    $scope.addBigQueryClusteringColumn = function() {
        if (!$scope.dataset.params.bigQueryClusteringColumns) {
            $scope.dataset.params.bigQueryClusteringColumns = [];
        }
        $scope.dataset.params.bigQueryClusteringColumns.push({name:''});
    };

    $scope.removeBigQueryClusteringColumn = function(index) {
        $scope.dataset.params.bigQueryClusteringColumns.splice(index, 1);
    };

    $scope.$watch("dataset.params.bigQueryPartitioningField", function(nv, ov) {
        if (nv) {
            const partitioningColumn = $scope.dataset.schema.columns.find(c => c.name === nv);
            $scope.dataset.params.bigQueryPartitioningType = (!partitioningColumn || partitioningColumn.type === "date") ? "DATE" : "RANGE";

            // If the new value was selected as a partitioning column, remove it from clustering columns if it was used as a clustering column
            const clusteringColumn = $scope.dataset.params.bigQueryClusteringColumns.find(c => c.name === nv);
            if (clusteringColumn) {
                const index = $scope.dataset.params.bigQueryClusteringColumns.indexOf(clusteringColumn);
                $scope.dataset.params.bigQueryClusteringColumns.splice(index, 1);
            }
        }
    });

    $scope.$watch("dataset.params.bigQueryClusteringColumns", function(nv, ov) {
        if (nv) {
            // Remove any duplicate column that may have been introduced by user.
            // It may happen if user has chosen [col1, col2, col3] as clustering columns and then select col2 in first dropdown.
            const columns = $scope.dataset.params.bigQueryClusteringColumns;
            $scope.dataset.params.bigQueryClusteringColumns = columns.filter((item, index) => {
                if (!item || !item.name) {
                    return true; // Keep empty placeholders
                }
                const firstMatchingColumn = columns.find(c => c.name === item.name);
                return columns.indexOf(firstMatchingColumn) === index;
            });
        }
    }, true);

    $scope.test = function (connectionOnly) {
        var deferred = $q.defer();
        $scope.testResult = null;
        $scope.testing = true;
        DataikuAPI.datasets.managedSQL.test($stateParams.projectKey, $scope.dataset, 15, connectionOnly).success(function (data) {
            Logger.info('Got test result');
            $scope.testing = false;
            $scope.testResult = data;
            if ($scope.testResult.preview) {
                $scope.table = $scope.testResult.preview;
            }
            deferred.resolve();

        }).error(function (a,b,c) {
            $scope.testing = false;
            setErrorInScope.bind($scope)(a,b,c);
            deferred.reject();
        });
        return deferred.promise;
    };

    $scope.$watch("dataset.params.tableCreationMode", function(nv, ov) {
        if (nv == "custom" && ov == "auto" && !$scope.dataset.params.customCreateStatement) {
             $scope.dataset.params.customCreateStatement =$scope.testResult.autogeneratedCreateStatement;
        }
    });

    /* For autocompletion in primary / distribute / sort / ... keys */
    $scope.$watch("dataset.schema", function(nv, ov){
        if (!nv) return;
        $scope.schemaColumnNames = nv.columns.map(x => x.name);
    }, true);

    /* Fixup everything we can ... */
    $scope.$watch('dataset.params', function (nv, ov) {
    }, true);
});

}());

(function() {
'use strict';

const app = angular.module('dataiku.datasets');


app.controller("StreamOrientedDatasetControllerFragment", function($scope, $rootScope, $stateParams, MonoFuture, $q,
                Assert, DataikuAPI, WT1, DatasetsService, Dialogs, DatasetUtils, LoggerProvider,
                FutureProgressModal, CreateModalFromTemplate, PluginConfigUtils) {

    var Logger = LoggerProvider.getLogger('datasets.stream');

    $scope.detectScheme = function() {
        return DataikuAPI.datasets.detectFilePartitioning($scope.dataset);
    };
    $scope.testScheme = function() {
        return DataikuAPI.datasets.testFilePartitioning($scope.dataset);
    };

    $scope.setSchemaUserModified = function() {
        $scope.schemaJustModified = true;
        $scope.dataset.schema.userModified = true;
    };

    $scope.inferStorageTypesFromData = function(){
        Dialogs.confirm($scope,
            "Infer storage types from data",
            "This only takes into account a very small sample of data, and could lead to invalid data. "+
            "For safer typing of data, use a prepare recipe.").then(function(){
                $scope.dataset.schema.userModified = false;
                $scope.preview(true);
        });
    };

    function waitTestDetectFuture(mfWrapped){
        var deferred = $q.defer();
        mfWrapped.success(function(data) {
            $scope.testingFuture = null;
            deferred.resolve(data.result);
        }).update(function(data){
            $scope.testingFuture = data;
        }).error(function (data, status, headers) {
            $scope.testingFuture = null;
            $scope.detectionResults = null;
            $scope.doingPreviewOrDetection = false;
            setErrorInScope.bind($scope)(data, status, headers);
        });
        return deferred.promise;
   }

    $scope.detectFormat = function () {
        //$scope.detectionResults = null;
        $scope.doingPreviewOrDetection = true;
        WT1.event("dataset-detectformat-start", {datasetType : $scope.dataset.type, datasetManaged : $scope.dataset.managed})

        waitTestDetectFuture(MonoFuture($scope).wrap(DataikuAPI.datasets.detect_format)($stateParams.projectKey, $scope.dataset))
            .then(function(dRes){
            Logger.info('Got detection result', dRes, $scope.dataset.params);
            $scope.detectionResults = dRes;
            $scope.doingPreviewOrDetection = false;
            if (!$scope.dataset.name && !$scope.new_dataset_name_manually_edited) {
                $scope.new_dataset_name = $scope.detectionResults.suggestedName;
            }
            if ($scope.detectionResults.connectionOK) {
                $scope.dataset.formatParams = $scope.dataset.formatParams || {};
                if ($scope.detectionResults.empty) {
                    $scope.updateTableFromPreviewResult();
                } else {
                    if ($scope.detectionResults.format) {
                        /* Load the detected format params in the dataset */
                        $scope.dataset.formatType = $scope.detectionResults.format.type;
                        $scope.dataset.formatParams = $scope.detectionResults.format.params || {};
                        $scope.updateTableFromPreviewResult();
                    } else {
                        //  $scope.detectionResults.format = { table : null,
                        //     errorMessage : 'Failed to detect a format, please manually configure',
                        //     metadata : {}
                        // };
                    }
                }
            }
            getDigestTime($scope, function(time) {
                var d = $.isEmptyObject($scope.dataset.formatParams) ? "failed" : JSON.stringify($scope.dataset.formatParams);
                WT1.event("dataset-detectformat-done",
                    {datasetType : $scope.dataset.type, datasetManaged : $scope.dataset.managed, digestTime : time,
                     detectedType : $scope.dataset.formatType, detectedParams :  d});
            });
        });//.error(setErrorInScope.bind($scope));
    };

    $scope.$watch("dataset.formatType", function() {
    	if (!$scope.dataset.formatType) return;
        /* get plugin desc of format if needed*/
        if ($scope.dataset.formatType.startsWith("jformat")) {
            $scope.loadedDesc = $rootScope.appConfig.customJavaFormats.filter(function(x){
                return x.formatterType == $scope.dataset.formatType;
            })[0];
            $scope.pluginId = $scope.loadedDesc ? $scope.loadedDesc.ownerPluginId : null;
        }
        if ($scope.dataset.formatType.startsWith("format")) {
            $scope.loadedDesc = $rootScope.appConfig.customPythonFormats.filter(function(x){
                return x.formatterType == $scope.dataset.formatType;
            })[0];
            $scope.pluginId = $scope.loadedDesc ? $scope.loadedDesc.ownerPluginId : null;
        }

        /* Set default values for custom formats */
        if ($scope.dataset.formatType.startsWith("jformat") || $scope.dataset.formatType.startsWith("format")) {
            $scope.formats[$scope.dataset.formatType].params.some(function(elt) {
                if (elt.type === "autoconfig") {
                    PluginConfigUtils.setDefaultValues(elt.params, $scope.dataset.formatParams.config);
                    return true;
                }
                return false;
            });
        }

    });

    $scope.preview = function (inferStorageTypes) {
        $scope.doingPreviewOrDetection = true;

        if (inferStorageTypes == null) inferStorageTypes = false;

        WT1.event("dataset-preview-start", {datasetType : $scope.dataset.type, datasetManaged : $scope.dataset.managed})
        waitTestDetectFuture(MonoFuture($scope).wrap(DataikuAPI.datasets.preview)($stateParams.projectKey, $scope.dataset, inferStorageTypes))
        .then(function (data) {
            Logger.info('Got preview result', data, $scope.dataset.params);
            $scope.detectionResults = data;
            $scope.doingPreviewOrDetection = false;
            if (!$scope.firstPreviewDone) {
                if (data.connectionOK) {
                    //$scope.goToPreview();
                }
                $scope.firstPreviewDone = true;
            }
            //$scope.testOrDetectPartitioningIfNeeded();
            $scope.updateTableFromPreviewResult();
            getDigestTime($scope, function(time) {
                WT1.event("dataset-preview-done", {
                    datasetType : $scope.dataset.type, datasetManaged : $scope.dataset.managed, digestTime : time,
                    formatType : $scope.dataset.formatType, formatParams : $scope.dataset.formatParams});
            });
        })
    };

    /* Manual change of format type : redo a detection limited to this type*/
    $scope.onFormatTypeChanged = function () {
        clear($scope.dataset.formatParams);

        WT1.event("dataset-detectformat-onetype-start",{
                    datasetType : $scope.dataset.type, datasetManaged : $scope.dataset.managed, formatType : $scope.dataset.formatType});

        $scope.doingPreviewOrDetection = true;
        waitTestDetectFuture(MonoFuture($scope).wrap(DataikuAPI.datasets.detectOneFormat)($stateParams.projectKey, $scope.dataset, $scope.dataset.formatType))
            .then(function(data) {
            $scope.doingPreviewOrDetection = false;
            $scope.detectionResults = data;
            if (!$scope.detectionResults.format) {
                /* Could not detect anything for this format ... */
                clear($scope.dataset.formatParams);
                $scope.detectionResults.format = { table : null,
                    errorMessage : 'Failed to detect suitable parameters for this format, please manually configure',
                    metadata : {}
                };
            } else {
                var fmt = $scope.detectionResults.format;
                Assert.trueish(fmt.type == $scope.dataset.formatType, 'detected format is not the current dataset format');
                // Don't change formatParams, clear and refill
                if ($scope.dataset.formatParams == null) $scope.dataset.formatParams = {}
                mapCopyContent($scope.dataset.formatParams, fmt.params);
            }
            $scope.updateTableFromPreviewResult();

            WT1.event("dataset-detectformat-onetype-done",{
                datasetType : $scope.dataset.type, datasetManaged : $scope.dataset.managed, formatType : $scope.dataset.formatType});
        });
    };

    /* Change of format params : just update preview */
    $scope.onFormatParamsChanged = function () {
        /*  User changed format params, so stop changing them automatically if core params change */
        if ($scope.dataset.formatParams.style == 'excel' && $scope.dataset.formatParams.quoteChar != '"') {
            $scope.dataset.formatParams.quoteChar = '"';
        }
        $scope.redetectFormatOnCoreParamsChanged = false;
        $scope.preview();
    };

    $scope.updateTableFromPreviewResult = function () {
        Assert.inScope($scope, 'detectionResults');
        var dRes = $scope.detectionResults;
        if (!dRes.connectionOK) {
            dRes.format = { table : null, errorMessage : "Connection failed: " + dRes.connectionErrorMessage };
            return;
        }
        $scope.consistency = { empty : dRes.empty };
        $scope.consistency.kind = DatasetUtils.getKindForConsistency($scope.dataset);
        if (dRes.empty) {
            if ($scope.dataset.formatType == null) {
                $scope.dataset.formatType = 'csv';
                $scope.dataset.formatParams = {
                    'separator': '\t',
                    'charset': 'utf8'
                };
            }
        } else {
            Assert.trueish(dRes.format, 'no format detected');
            $scope.consistency.result = dRes.format.schemaDetection;
            if (dRes.format.schemaDetection) {
                $scope.dataset.schema = dRes.format.schemaDetection.newSchema;
            }
            $scope.schemaJustModified = false;
        }
    };

    $scope.clearDataset = function(){
        DatasetsService.clear($scope, $scope.dataset.projectKey, $scope.dataset.name).then(function(){
            $scope.preview();
        });
    };

    $scope.overwriteSchema = function(newSchema) {
        WT1.event("dataset-discard-schema-changed",{
                    datasetType : $scope.dataset.type, datasetManaged : $scope.dataset.managed});
        $scope.dataset.schema =angular.copy(newSchema);
        $scope.schemaJustModified = false;
        $scope.consistency = null;
        // Trigger a new preview
        $scope.preview();
    };

    $scope.discardConsistencyError= function(){
        $scope.consistency = null;
    };

    $scope.schemaIsUserModified = function () {
        return $scope.dataset.schema != null && $scope.dataset.schema.userModified;
    };
    $scope.dataset.formatParams = $scope.dataset.formatParams || {};

    $scope.testSchemaConsistencyOnAllFiles = function(){
        Dialogs.confirm($scope, "Test schema consistency on all files",
            "This operation can be very slow if your dataset has many files").then(function(){
                DataikuAPI.datasets.testSchemaConsistencyOnAllFiles($scope.dataset).success(function(data){
                    FutureProgressModal.show($scope, data, "Checking schema consistency").then(function(result){
                        CreateModalFromTemplate("/templates/datasets/modals/all-files-schema-consistency-modal.html", $scope, null, function(newScope){
                            newScope.result = result;
                        })
                    });
                }).error(setErrorInScope.bind($scope));
        });
    }
});


app.controller("TwitterStreamDatasetController", function($scope, $stateParams, Assert, DataikuAPI, $timeout, WT1) {
    $scope.onLoadComplete = function () {
        Assert.inScope($scope, 'dataset');
        Assert.trueish($scope.dataset.type == "Twitter", 'not a Twitter dataset');

        if (!$scope.dataset.params.keywords) {
            $scope.dataset.params.keywords = [];
        }

        if (!$scope.dataset.formatType) {
            $scope.dataset.formatType = "csv";
        }

        if ($scope.dataset.formatParams == null || Object.keys($scope.dataset.formatParams).length === 0) {
            $scope.dataset.formatParams = {
                "quoteChar": "\"",
                "escapeChar": "\\",
                "style": "unix",
                "charset": "utf8",
                "arrayMapFormat": "json",
                "parseHeaderRow": "false",
                "separator": "\t"
            };
        }
        $scope.dataset.partitioning = {
            "filePathPattern": "%Y/%M/%D/%H/.*",
            "ignoreNonMatchingFile": false,
            "considerMissingRequestedPartitionsAsEmpty": false,
            "dimensions": [
            {
              "name": "date",
              "type": "time",
              "params": {
                "period": "HOUR"
              }
            }
            ]
        };

        if(!$scope.dataset.schema){
            $scope.dataset.schema = {userModified : false};
        }

        if(!$scope.dataset.schema.columns){
            $scope.dataset.schema.columns = [];
        }

        $scope.toggleField = function(field){
            if($scope.containsColumn(field)){ // remove
                $scope.dataset.schema.columns = $scope.dataset.schema.columns.filter(
                    function(e){ return e.name != field; });
            } else {
                $scope.dataset.schema.columns.push({
                    "name": field,
                    "type": "string",
                    "maxLength": 1000
                });
            }
        }

        $scope.containsColumn = function(name){
            for(var c in $scope.dataset.schema.columns){
                if($scope.dataset.schema.columns[c]["name"] == name){
                    return true;
                }
            }
            return false;
        }

        if($scope.dataset.schema.columns.length === 0){
            $scope.dataset.schema.columns.push({
                "name": "id_str",
                "type": "string",
                "maxLength": 1000
            });
            $scope.dataset.schema.columns.push({
                "name": "created_at",
                "type": "string",
                "maxLength": 1000
            });
            $scope.dataset.schema.columns.push({
                "name": "user.screen_name",
                "type": "string",
                "maxLength": 1000
            });
            $scope.dataset.schema.columns.push({
                "name": "text",
                "type": "string",
                "maxLength": 1000
            });
        }

        $scope.keywordItems = $scope.dataset.params.keywords.map(function(f) { return { keyword: f }; });
    }

    $scope.keywordsChanged = function(newKeywords = []) {
        [].splice.apply($scope.dataset.params.keywords,
            [0, $scope.dataset.params.keywords.length].concat(newKeywords.map(function(fi) { return fi.keyword; })));
    };

    $scope.isReady = function(){
        return !angular.isUndefined($scope.dataset.params.keywords) &&
                ($scope.dataset.params.keywords.length !== 0) && ($scope.connectionTwitter) && $scope.dataset.params.path && $scope.dataset.params.path!='/';
    };

    $scope.$watch("new_dataset_name", function(nv, ov) {
        if (nv && nv.length &&
            (($scope.dataset.params.path == "/") || !$scope.dataset.params.path || (ov && $scope.dataset.params.path == ('/'+$stateParams.projectKey + '.' + ov)))) {
            $scope.dataset.params.path =  "/" + $stateParams.projectKey + '.' + nv;
        }
    }, true);

    $scope.isRunning = false;
    $scope.hasData = false;

    $scope.saveHooks.push(function() {
        if($scope.dataset && $scope.dataset.params) {
            var path = $scope.dataset.params.path;
            return path && path!='/';
        }
        return false;
    });

    // isRunning is true if there's a twitter capture of the current dataset
    // hasData is true if at least a tweet has been written

    if (angular.isDefined($scope.dataset.name)) {
        DataikuAPI.datasets.getTwitterStatus($stateParams.projectKey, $scope.dataset.name).success(function(res) {
            $scope.isRunning = res.isStarted;
            $scope.hasData = res.hasData;
        });
    }

    if (angular.isUndefined($scope.dataset.params.path)) {
        $scope.dataset.params.path = '/';
    }

    // If there's an active twitter connection, we retrieve it...
    if (angular.isUndefined($scope.connectionTwitter)) {
        DataikuAPI.connections.getTwitterConfig().success(function(data) {
            $scope.connectionTwitter = data.connection;
        }).error(function(){
            setErrorInScope.bind($scope);
        });
    }

    // ... Otherwise, we see if there's a twitter connection
    if(!$scope.connectionTwitter){
        DataikuAPI.connections.getNames('Twitter').success(function (data) {
            $scope.connectionsTwitter = data;
            if ($scope.connectionsTwitter.length > 0) {
                $scope.connectionTwitterSelection = $scope.connectionsTwitter[0];
            }
            $scope.hasConnectionsTwitter = $scope.connectionsTwitter.length > 0;
        }).error(setErrorInScope.bind($scope));
    }

    $scope.toggleStreaming = function(start){
        DataikuAPI.datasets.controlTwitterStreaming($stateParams.projectKey, $scope.dataset.name, start).success(function() {
            $scope.isRunning = start;
        }).error(function() {
            setErrorInScope.bind($scope);
            DataikuAPI.datasets.getTwitterStatus($stateParams.projectKey, $scope.dataset.name).success(function(res) {
                $scope.isRunning = res.isStarted == "true" ? true : false;
            });
        });
    };

    DataikuAPI.connections.getNames('Filesystem').success(function (data) {
        $scope.connections = data;
        if ($scope.connections.length > 0 && ($scope.dataset.params.connection == null || $scope.dataset.params.connection.length === 0)) {
            for(var i = 0; i < $scope.connections.length; i++){
                if($scope.connections[i] == "filesystem_managed"){
                    $scope.dataset.params.connection = $scope.connections[i];
                } else {
                    $scope.dataset.params.connection = $scope.connections[0];
                }
            }
        }
    }).error(setErrorInScope.bind($scope));
});


/** For the moment, we have one controller for managed fs-like and external ... */
app.controller("ManagedFSLikeDatasetController", function($scope, $controller) {
    $controller("ExternalStreamOrientedDatasetController", {$scope:$scope});
});


app.controller("ExternalStreamOrientedDatasetController", function($scope, $controller, $stateParams, DataikuAPI, $timeout, WT1, CreateModalFromTemplate) {
    $controller("StreamOrientedDatasetControllerFragment", {$scope:$scope});
    $scope.onLoadComplete = function () {
        $scope.uiState.activeTab = 'connection'
        $scope.uiState.autoTestOnFileSelection = true;
        $scope.uiState.listFilesSelectedOnly = false;

        if ($stateParams.datasetName) {
            /* If, when we arrive, the dataset does not have a format yet, then each time the core params
             * change, we'll redo a detection. That allows us to better react to the core params actually
             * targeting different files during the process
             */
            if (angular.isDefined($scope.dataset.formatParams)) {
                $scope.redetectFormatOnCoreParamsChanged = false;
            } else {
                $scope.redetectFormatOnCoreParamsChanged = true;
            }
            /* Fire initial preview-detection */
            //$scope.preview();
        }
    };

    $scope.getFilesListingHeight = function(filesListing) {
        return Math.min(28*filesListing.paths.length, 235);
    }

    $scope.getAlertClassForResultsOnConnectionTab = function(dRes){
        if (!dRes) return "";
        if (!dRes.connectionOK) return "alert-error";
        if (dRes.empty) return "alert-warning";
        if (!dRes.format || !dRes.format.ok) return "alert-error";
        if (dRes.format && dRes.format.ok && dRes.format.schemaDetection && dRes.format.schemaDetection.warningLevel == 'WARN') return "alert-warning";
        return "alert-success";
    }
    $scope.getAlertClassForResultsOnPreviewTab = function(dRes) {
        if (!dRes) return "";
        if (!dRes.connectionOK) return "alert-error";
        if (dRes.empty) return "alert-warning";
        if (!dRes.format || !dRes.format.ok) return "alert-error";
        return "ng-hide"; // Don't display if OK
    }

    $scope.startUpdateFromHive = function() {
        CreateModalFromTemplate("/templates/datasets/fragments/update-from-hive-modal.html", $scope, "UpdateDatasetFromHiveController");
    };

    $scope.detectOrPreview = function(){
        var shouldDetect = ($scope.dataset.formatParams == null || $scope.dataset.formatParams.length === 0 || angular.isUndefined($scope.dataset.formatType) || $scope.redetectFormatOnCoreParamsChanged);

        if (shouldDetect) {
            $scope.detectFormat();
        } else {
            $scope.preview();
        }
    }

    /* Params changed : trigger smart detection-or-preview */
    $scope.onCoreParamsChanged = function(){
        if ($scope.uiState.autoTestOnFileSelection) $scope.detectOrPreview();
    };

    /* Manual force format redetection: drop current data and trigger detection */
    $scope.forceFormatRedetection = function () {
        $scope.dataset.formatType = null;
        clear($scope.dataset.formatParams); // formatParams is watched, never reassign it.
        $scope.detectFormat();
    };

     $scope.listFiles = function(providerType){
        DataikuAPI.fsproviders.listFiles(providerType, $scope.dataset.params, $scope.projectKey || $stateParams.projectKey, $scope.contextVars || {},
            $scope.dataset.params.filesSelectionRules, $scope.uiState.listFilesSelectedOnly).success(function(data){
                $scope.uiState.filesListing = data;
            }).error(setErrorInScope.bind($scope));
    }

    $scope.addExplicitSelect = function(path) {
        path.selected = true;
        $scope.dataset.params.filesSelectionRules.explicitFiles.push(path.path);
        $scope.uiState.filesListing.selectedFiles ++;
        $scope.uiState.filesListing.selectedSize += path.size;
    }

    $scope.addIncludeRule = function(path) {
        path.selected = true;
        var p = path.path;
        if (p.startsWith('/')) p = p.substring(1);
        $scope.dataset.params.filesSelectionRules.includeRules.push({expr:p,mode:'GLOB',matchingMode:'FULL_PATH'});
        $scope.dataset.params.filesSelectionRules.includeRules = [].concat($scope.dataset.params.filesSelectionRules.includeRules); // touch the array to force a refresh of the listForm
        $scope.uiState.filesListing.selectedFiles ++;
        $scope.uiState.filesListing.selectedSize += path.size;
    }

    function updateCreationWarning(){
        let warnings = [];
        $scope.uiState.creationWarning = null;
        if (!$scope.new_dataset_name) return;

        if (["HDFS", "Filesystem", "SCP", "SFTP", "FTP", "S3", "GCS", "Azure"].indexOf($scope.dataset.type) >= 0) {
            if (!$scope.dataset.params || !$scope.dataset.params.path || "/" == $scope.dataset.params.path || "" == $scope.dataset.params.path) {
                warnings.push("Dataset at root of connection. This is atypical. Do you want to create a managed dataset?");
            }
        }

        if ($scope.dataset.type != 'Inline') {
            if (!$scope.dataset.formatType || !$scope.dataset.formatParams) {
                warnings.push("No format configured, dataset won't be usable");
            }
            if (!$scope.dataset.schema || !$scope.dataset.schema.columns || !$scope.dataset.schema.columns.length) {
                warnings.push("No schema set, dataset won't be usable");
            }
        }
        if (warnings.length > 0) {
            $scope.uiState.creationWarning = warnings.join("; ");
        }
    }


    $scope.$watch("dataset", updateCreationWarning, true);
    $scope.$watch("new_dataset_name", updateCreationWarning);

});

app.controller("UpdateDatasetFromHiveController", function($scope, DataikuAPI, $stateParams) {
    var handleHiveImportability = function(data) {
        var messages = data.importability.messages;
        $scope.hiveDataset = data.importability.dataset;
        $scope.hiveSyncOutcome = messages.error ? 'FAILED' : (messages.warning ? 'WARNING' : 'SUCCESS');
        $scope.hiveSyncMessage = '';
        messages.messages.forEach(function(message) {
            $scope.hiveSyncMessage = $scope.hiveSyncMessage + "\n" + (message.details || message.message);
        });
        if ($scope.hiveDataset == null && $scope.hiveSyncOutcome == 'SUCCESS') {
            // mmh. should not be null.
            $scope.hiveSyncOutcome = 'FAILED';
            $scope.hiveSyncMessage = $scope.hiveSyncMessage || "No dataset could be built from table";
        } else {
            $scope.connectionIsSubdirSynchronized = data.connectionIsSubdirSynchronized;
            $scope.schemaIncompatibilities = data.schemaIncompatibilities;
            $scope.connectionIncompatibility = data.connectionIncompatibility;
            $scope.pathIncompatibility = data.pathIncompatibility;
            $scope.partitioningIncompatibility = data.partitioningIncompatibility;
        }
    };

    $scope.hasIncompatibilities = function() {
        return $scope.connectionIsSubdirSynchronized || ($scope.schemaIncompatibilities && $scope.schemaIncompatibilities.length) || $scope.connectionIncompatibility || $scope.pathIncompatibility || $scope.partitioningIncompatibility;
    };

    $scope.checkHiveImportability = function(importability) {
        $scope.hiveCheckInProgress = true;
        DataikuAPI.datasets.checkHiveSync($stateParams.projectKey, $stateParams.datasetName).success(function (data) {
            $scope.hiveCheckInProgress = false;
            handleHiveImportability(data);
        }).error(function(a,b,c) {
            $scope.hiveCheckInProgress = false;
            setErrorInScope.bind($scope)(a,b,c);
        });
    };


    $scope.checkHiveImportability();
});

app.service("FSProviderUtils", function(){

})

app.directive('fsFilesSelection', function(DataikuAPI, $stateParams, WT1, Debounce) {
    return {
        restrict: 'A',
        templateUrl: '/templates/datasets/fragments/fs-files-selection.html',
        scope: {
            params : '='
        },
        link: function($scope, element, attrs) {
            $scope.filesSelectionRulesModes = [['ALL', 'All'],
                                               ['EXPLICIT_SELECT_FILES', 'Explicitly select files'],
                                               ['RULES_ALL_BUT_EXCLUDED', 'All but excluded'],
                                               ['RULES_INCLUDED_ONLY', 'Only included']];
            $scope.filesSelectionRulesModesDesc = ['No filtering',
                                                   'Select individual files from the directory at Path',
                                                   'Any file from the directory at Path that match a rule is ignored ',
                                                   'Only files from the directory at Path that match a rule are taken'];
            if (!$scope.params.filesSelectionRules) {
                $scope.params.filesSelectionRules = {
                    mode: "ALL", includeRules:[], excludeRules:[]
                };
            }
            $scope.prepareNewRule = function(rule) {
                if (!rule.mode) rule.mode = "GLOB";
                if (!rule.matchingMode) rule.matchingMode = "FULL_PATH";
            }
        }
    };
});

app.directive('fsProviderBucketSelector', function(DataikuAPI, $stateParams, WT1, Debounce) {
    return {
        restrict: 'A',
        templateUrl: '/templates/datasets/fs-provider-bucket-selector.html',
        scope: {
            providerType : '=',
            projectKey : '=',
            config : '=',
            contextVars : '=',
            bucketLabel : '=',
            bucketProperty : '='
        },
        link: function($scope, element, attrs) {
            $scope.selectorUiState = {mode:'CUSTOM', fetchingBucketList:false, couldListBuckets: null, bucketsListError: null, buckets: null};

            var fetchConnectionMetadata = function() {
                if ($scope.config == null || $scope.config.connection == null) return;
                DataikuAPI.fsproviders.testConnection($scope.providerType, $scope.config, $scope.projectKey || $stateParams.projectKey, $scope.contextVars || {}, false)
                    .success(function (data) {
                        $scope.connMeta = data;
                    })
                    .error(setErrorInScope.bind($scope));
            };
            fetchConnectionMetadata();
            $scope.$watch("config.connection", fetchConnectionMetadata);
            $scope.$watch('config.' + $scope.bucketProperty, Debounce().withDelay(200, 1000).withScope($scope).wrap(fetchConnectionMetadata));

            $scope.fetchBucketList = function() {
                $scope.selectorUiState.fetchingBucketList = true;
                DataikuAPI.fsproviders.testConnection($scope.providerType, $scope.config, $scope.projectKey || $stateParams.projectKey, $scope.contextVars || {}, true)
                .success(function (data) {
                    $scope.connMeta = data;
                    if (data.buckets) {
                        $scope.selectorUiState.buckets = data.buckets.split(",");
                    } else {
                        $scope.selectorUiState.buckets = null;
                    }
                    $scope.selectorUiState.couldListBuckets = data.couldListBuckets;
                    $scope.selectorUiState.bucketsListError = data.bucketsListError;
                    $scope.selectorUiState.mode = 'SELECT';
                })
                .error(setErrorInScope.bind($scope))
                .finally(function() {$scope.selectorUiState.fetchingBucketList = false;});
            };
        }
    };
});

app.directive('fsProviderSettings', function(DataikuAPI, $stateParams, WT1) {
    return {
        restrict: 'A',
        replace: true,
        templateUrl: '/templates/datasets/fs-provider-settings.html',
        scope: {
            connectionHasMetadata : '=',
            providerType : '=',
            config : '=',
            projectKey : '=',
            contextVars : '=',
            defaultPath : '=',
            pathChangeNeedsConfirm : '=',
            onChange : '&'
        },
        link: function($scope, element, attrs) {
            if ($scope.config.$resetConnection) {
                delete $scope.config.$resetConnection;
                $scope.config.connection = null;
            }

            var initConnectionFieldIfEmpty = function() {
                if ($scope.config == null) return;
                if ($scope.connections == null) return;
                if ($scope.connections.length > 0 && ($scope.config.connection == null || $scope.config.connection.length === 0)) {
                    $scope.config.connection = $scope.connections[0];
                }
            };
            var initPathFieldIfEmpty = function() {
                if ($scope.config == null) return;
                if (angular.isUndefined($scope.config.path)) {
                    $scope.config.path = $scope.defaultPath != null ? $scope.defaultPath : '/';
                }
            };
            $scope.$watch("config", function() {
                if ($scope.config == null) return;
                initPathFieldIfEmpty();
                initConnectionFieldIfEmpty();
            }, true);
            $scope.$watch("providerType", function(nv, ov) {
            	if (nv && ov && nv != ov && $scope.config) {
            		// clear the connection to avoid testing an provider with a connection of the wrong type
        			$scope.config.connection = null;
            	}
                if ($scope.providerType == null) return;
                if ($scope.providerType == 'S3') {
                    $scope.connectionType = 'EC2';
                } else if ($scope.providerType == 'SFTP' || $scope.providerType == 'SCP') {
                    $scope.connectionType = 'SSH';
                } else {
                    $scope.connectionType = $scope.providerType;
                }
                DataikuAPI.connections.getNames($scope.connectionType).success(function (data) {
                    $scope.connections = data;
                    initConnectionFieldIfEmpty();
                }).error(setErrorInScope.bind($scope));
            });

            $scope.browse = function (path) {
                if (path == null)
                    path = $scope.defaultPath != null ? $scope.defaultPath : '/';
                var configAnchoredAtRoot = angular.copy($scope.config);
                // We discard stuff to have a shorter serialized version of our dataset
                configAnchoredAtRoot.path = $scope.defaultPath != null ? $scope.defaultPath : '/';

                WT1.event("fsprovider-fs-browse", {providerType : $scope.providerType, path : path});

                // Ugly workaround. Angular 1.2 unwraps promises (don't understand why)
                // Except if the promise object has a $$v.
                // See https://github.com/angular/angular.js/commit/3a65822023119b71deab5e298c7ef2de204caa13
                // and https://github.com/angular-ui/bootstrap/issues/949
                var promise = DataikuAPI.fsproviders.browse($scope.providerType, configAnchoredAtRoot, $scope.projectKey || $stateParams.projectKey, $scope.contextVars || {}, path);
                promise.$$v = promise;
                return promise;
            };


        }
    };
});

app.controller("FilesystemDatasetController", function() {
	// nothing to add to base behavior
});

app.controller("AzureDatasetController", function() {
	// nothing to add to base behavior
});

app.controller("GCSDatasetController", function() {
	// nothing to add to base behavior
});

app.controller("HDFSDatasetController", function($scope) {
    if (angular.isUndefined($scope.dataset.params.metastoreSynchronizationEnabled)) {
        $scope.dataset.params.metastoreSynchronizationEnabled = false;
    }
});

app.controller("S3DatasetController", function() {
	// nothing to add to base behavior
});

app.controller("FTPDatasetController", function() {
	// nothing to add to base behavior
});

app.controller("SFTPDatasetController", function() {
	// nothing to add to base behavior
});

app.controller("SCPDatasetController", function() {
	// nothing to add to base behavior
});

app.controller("HTTPDatasetController", function($scope, Dialogs, $timeout) {
    if (!$scope.dataset.params || !$scope.dataset.params.sources) {
        $scope.dataset.params = {
            sources: [],
            consider404AsEmpty: true,
            useGlobalProxy: true,
            previewPartition: '',
            partitions: []
        };
    }

    $scope.uiState ={
        urls: ($scope.dataset.params.sources || []).map(function(source) { return source.url; }).join('\n'),
        partitioned: $scope.dataset.partitioning.dimensions ? ($scope.dataset.partitioning.dimensions.length > 0) : false,
        previewPartition: $scope.dataset.params.previewPartition && $scope.dataset.params.previewPartition.length > 0
            ? partitionId2Obj($scope.dataset.params.previewPartition) : {},
        partitionList: $scope.dataset.params.partitions && $scope.dataset.params.partitions.length > 0
            ? $scope.dataset.params.partitions.map(partitionId2Obj) : []
    };
    $scope.hasTimeDimension = function() {
        return $scope.dataset.partitioning.dimensions.some(function(d) { return d.type === 'time'; });
    };
    $scope.$watch('uiState.urls', function(nv) {
        $scope.dataset.params.sources = nv.split(/(?:\r?\n)+/).map(function(url) {
            return { url: url.trim() };
        }).filter(function(_) { return _.url.length > 0; });
    });
    $scope.$watch('uiState.previewPartition', function(nv) {
        if (nv == null) return;
        $scope.dataset.params.previewPartition = partitionObj2Id(nv);
    }, true);
    $scope.$watch('uiState.partitionList', function(nv) {
        $scope.dataset.params.partitions = nv.map(partitionObj2Id);
    }, true);
    $scope.$watch('dataset.partitioning.dimensions', function(nv, ov) {
        if (nv == null) return;
        if (nv.length != ov.length) {
            var oldNames = ov.map(function(d) {return d.name;});
            var newNames = nv.map(function(d) {return d.name;});
            var toAdd = newNames.filter(function(name) {return oldNames.indexOf(name) < 0;});
            var toDel = oldNames.filter(function(name) {return newNames.indexOf(name) < 0;});
            var cleanPartition = function(obj) {
                toAdd.forEach(function(name) {obj[name] = '';});
                toDel.forEach(function(name) {delete obj[name];});
            };
            cleanPartition($scope.uiState.previewPartition);
            $scope.uiState.partitionList.forEach(cleanPartition);
        } else {
            // rename fields in UI partition list
            var cleanPartition = function(obj) {
                for (var i = 0; i < nv.length; i++) {
                    if (nv[i].name !== ov[i].name) {
                        obj[nv[i].name] = obj[ov[i].name];
                        delete obj[ov[i].name];
                    }
                }
            };
            cleanPartition($scope.uiState.previewPartition);
            $scope.uiState.partitionList.forEach(cleanPartition);
        }
    }, true);
    $scope.addPartitionToList = function() {
        $scope.uiState.partitionList.push(partitionId2Obj(''));
        $timeout(function() {
            $('table.table.table-partition-values tr').slice(-1).find('input[type="text"]').first().focus();
        });
    };
    $scope.removePartitionFromList = function(i) {
        if (i >= 0 && i < $scope.uiState.partitionList.length) {
            $scope.uiState.partitionList.splice(i, 1);
        }
    };
    $scope.partitionListPrompt = function() {
        Dialogs.prompt($scope, "Partitions list",
            "Edit partitions list, one partition ID per line, dimensions separated by |",
            $scope.dataset.params.partitions.join('\n'),
            {
                type: 'textarea',
                placeholder: 'dim1_value1|dim2_value1\ndim1_value2|dim2_value2'
            }
        ).then(function(nv) {
            $scope.uiState.partitionList = nv.split(/(?:\r?\n)+/)
                .map(function(_) { return _.trim(); })
                .filter(function(_) { return !!_; })
                .map(partitionId2Obj);
        });
    };

    function partitionId2Obj(id) {
        var parts = (id || '').split('|');
        return $scope.dataset.partitioning.dimensions.reduce(function(obj, dim, i) {
            obj[dim.name] = parts[i] || '';
            return obj;
        }, {});
    }
    function partitionObj2Id(obj) {
        return $scope.dataset.partitioning.dimensions
            .map(function(dim, i) { return obj[dim.name]; })
            .join('|');
    }

    $scope.getDimensionVariable = function(d) {
        if (d.type == 'time') {
            var patterns = ['%Y'];
            if (d.params.period == 'MONTH') {
                patterns.push('%M');
            } else if (d.params.period == 'DAY') {
                patterns.push('%M');
                patterns.push('%D');
            } else if (d.params.period == 'HOUR') {
                patterns.push('%M');
                patterns.push('%D');
                patterns.push('%H');
            }
            return patterns.join(", ");
        } else {
            return '%{' + d.name + '}';
        }
    };
});

app.controller("PluginFSProviderDatasetController", function($scope, $rootScope, $controller, $stateParams, DataikuAPI, $state, TopNav, CreateModalFromTemplate, PluginConfigUtils) {
    // nothing to add to base behavior
});

app.controller("FilesystemProviderController", function() {
	// nothing to add to base behavior
});

app.controller("AzureProviderController", function($scope) {
    $scope.uiState = {
        enterManually : false,
        selectedContainer : $scope.config.container
    };

    $scope.$watch('connMeta', function () {
        if ($scope.connMeta) {
            $scope.containers = null;
            if ($scope.connMeta.containers) {
                $scope.containers = $scope.connMeta.containers.split(',');
                $scope.uiState.selectedContainer = $scope.containers.filter(function(b) {return b == $scope.config.container;})[0];
            }
        }
    });
});

app.controller("GCSProviderController", function($scope) {
    $scope.uiState = {
        enterManually : false,
        selectedBucket : $scope.config.bucket
    };

    $scope.$watch('connMeta', function () {
        if ($scope.connMeta) {
            $scope.buckets = null;
            if ($scope.connMeta.buckets) {
                $scope.buckets = $scope.connMeta.buckets.split(',');
                $scope.uiState.selectedBucket = $scope.buckets.filter(function(b) {return b == $scope.config.bucket;})[0];
            }
        }
    });
});

app.controller("HDFSProviderController", function() {
	// nothing to add to base behavior
});

app.controller("S3ProviderController", function($scope) {
    $scope.uiState = {
        enterManually : false,
        selectedBucket : $scope.config.bucket
    };

    $scope.$watch('connMeta', function () {
        if ($scope.connMeta) {
            $scope.buckets = null;
            if ($scope.connMeta.buckets) {
                $scope.buckets = $scope.connMeta.buckets.split(',');
                $scope.uiState.selectedBucket = $scope.buckets.filter(function(b) {return b == $scope.config.bucket;})[0];
            }
        }
    });
});


app.controller("FTPProviderController", function($scope) {
    if (angular.isUndefined($scope.config.timeout)) {
        $scope.config.timeout = 30000;
    }
});

app.controller("SFTPProviderController", function($scope) {
    if (angular.isUndefined($scope.config.timeout)) {
        $scope.config.timeout = 10000;
    }
});

app.controller("SCPProviderController", function($scope) {
    if (angular.isUndefined($scope.config.timeout)) {
        $scope.config.timeout = 10000;
    }
});

app.controller("PluginFSProviderController", function($scope, $rootScope, $controller, $state, $stateParams, Assert, DataikuAPI, TopNav, CreateModalFromTemplate, PluginConfigUtils) {
    $scope.config.config = $scope.config.config || {};
    $scope.loadedDesc = $rootScope.appConfig.customFSProviders.filter(function(x){
        return x.fsProviderType == $scope.providerType;
    })[0];

    Assert.inScope($scope, 'loadedDesc');

    $scope.desc = $scope.loadedDesc.desc;

    // put default values in place
    PluginConfigUtils.setDefaultValues($scope.desc.params, $scope.config.config);

    $scope.pluginDesc = $rootScope.appConfig.loadedPlugins.filter(function(x){
        return x.id == $scope.loadedDesc.ownerPluginId;
    })[0];
});

app.controller("BaseUploadedFilesController", function($scope, DataikuAPI, WT1, $stateParams, ActivityIndicator) {
    $scope.files = [];

    $scope.downloadingFiles = 0;

    $scope.drop = function (uploaded_files) {
        function handleFiles(uploaded_files) {
            // if its a brand new dataset, instantiate an uploadbox first
            // upload files with progress bar

            for (var i = uploaded_files.length - 1; i >= 0; i--) {
                (function (uploaded_file) {
                    var file = {
                            progress: 0,
                            path: uploaded_file.name,
                            length: uploaded_file.size
                        };
                    $scope.files.push(file);
                    $scope.downloadingFiles++;
                    DataikuAPI.datasets.upload.addFileToDataset($stateParams.projectKey, uploaded_file, $scope.dataset, function (e) {
                        // progress bar
                        if (e.lengthComputable) {
                            $scope.$apply(function () {
                                file.progress = Math.round(e.loaded * 100 / e.total);
                            });
                        }
                    }).then(function (data) {
                        //success
                        var index = $scope.files.indexOf(file);
                        try {
                            data = JSON.parse(data);
                            if (data.wasArchive) {
                                ActivityIndicator.success("Extracted "  + data.files.length + " files from Zip archive");
                            }
                            // replace stub file object by result of upload
                            $scope.files = $scope.files.slice(0, index).concat(data.files).concat($scope.files.slice(index + 1));
                            $scope.files.sort(function (a, b) {
                                return a.path < b.path;
                            });
                        } catch(e){
                            // a lot can go wrong
                            $scope.files = $scope.files.slice(0, index).concat($scope.files.slice(index + 1));
                        }
                        $scope.downloadingFiles--;
                    }, function(payload){
                        // delete faulty file
                        $scope.files.splice($scope.files.indexOf(file), 1);

                        try {
                            setErrorInScope.bind($scope)(JSON.parse(payload.response), payload.status, function(h){return payload.getResponseHeader(h)});
                        } catch(e) {
                            // The payload.response is not JSON
                            setErrorInScope.bind($scope)({$customMessage: true, message: (payload.response || "Unknown error").substring(0, 20000), httpCode: payload.status}, payload.status);
                        }

                        $scope.downloadingFiles--;
                    });
                }(uploaded_files[i]));
            }
        }
        if ($scope.dataset.name == null && !$scope.dataset.params.uploadBoxId) {
            DataikuAPI.datasets.upload.createUploadBox().success(function (data) {
                $scope.dataset.params.uploadBoxId = data.id;
                handleFiles(uploaded_files);
            }).error(setErrorInScope.bind($scope));
        } else {
            handleFiles(uploaded_files);
        }
    };

    $scope.deleteFile = function (file, e) {
        WT1.event("dataset-upload-remove-file");
        e.preventDefault();
        e.stopPropagation();
        DataikuAPI.datasets.upload.removeFile($stateParams.projectKey, $scope.dataset, file.path).success(function(data) {
            $scope.files.splice($scope.files.indexOf(file), 1);
        }).error(setErrorInScope.bind($scope));
    };
});


app.controller("UploadedFilesController", function($scope, $controller, DataikuAPI, $stateParams) {
    $controller("BaseUploadedFilesController", {$scope: $scope});

    // Cannot save if there is no file
    $scope.saveHooks.push(function() {
        return $scope.files && $scope.files.length > 0;
    });

    // Cannot save if downloading
    $scope.saveHooks.push(function() {
        return $scope.downloadingFiles == 0;
    });

    function watchFilesList() {
        // list of uploaded files (with finished upload)
        $scope.$watch(function () {
            return $.grep($scope.files, function (f) {
                return angular.isUndefined(f.progress);
            });
        }, function (nv, ov) {
            if (nv !== ov) {
                $scope.onCoreParamsChanged();
                $scope.dataset.savedFiles = nv;
            }
        }, true);
    };

    // init files
    if ($scope.dataset.name != null) {
        DataikuAPI.datasets.upload.listFiles($stateParams.projectKey, $scope.dataset.name).success(function (data) {
            $scope.files = data;
            watchFilesList();
        }).error(setErrorInScope.bind($scope));
    } else {
        DataikuAPI.datasets.listManagedUploadableConnections($stateParams.projectKey).success(function(data) {
            $scope.uploadableConnections = data.connections;
            $scope.dataset.params.$uploadConnection = $scope.uploadableConnections[0];
        }).error(setErrorInScope.bind($scope));
        // restore files from saved, see #6840
        if ($scope.dataset.savedFiles && $scope.dataset.savedFiles.length) {
            [].push.apply($scope.files, $scope.dataset.savedFiles);
        }
        watchFilesList();
        $scope.$watch("dataset.params.$uploadConnection", function() {
            if (!$scope.dataset.params.$uploadConnection) return;
            $scope.dataset.params.uploadConnection = $scope.dataset.params.$uploadConnection.name;
            $scope.dataset.params.uploadFSProviderType = $scope.dataset.params.$uploadConnection.fsProviderTypes[0];
        });
    }
});

app.controller("FilesInFolderController", function($scope, $controller, DataikuAPI, $stateParams, SmartId) {
    $scope.fileChoice = {};

    // put the prefill in place if there is one
    if ($stateParams.fromOdbSmartId && $scope.dataset && $scope.dataset.params && !$scope.dataset.params.folderSmartId) {
        $scope.dataset.params.folderSmartId = $stateParams.fromOdbSmartId;
        if ($stateParams.fromOdbItemPath && $stateParams.fromOdbItemDirectory == "false") {
            $scope.dataset.params.filesSelectionRules = {mode: "EXPLICIT_SELECT_FILES", includeRules: [], excludeRules: [], explicitFiles: [$stateParams.fromOdbItemPath]}
        } else if ($stateParams.fromOdbItemPath && $stateParams.fromOdbItemDirectory == "true") {
            var globbed = $stateParams.fromOdbItemPath + "/**/*";
            if (globbed.startsWith('/')) globbed = globbed.substring(1)
            $scope.dataset.params.filesSelectionRules = {mode: "RULES_INCLUDED_ONLY", includeRules: [{mode: "GLOB", matchingMode: "FULL_PATH", expr: globbed}], excludeRules: [], explicitFiles: []}
        }
        $scope.dataset.projectKey = $scope.dataset.projectKey || $stateParams.projectKey; // otherwise the folderSmartId is a bit irrelevant
    }

    var refreshManagedFolder = function() {
        if ($scope.managedfolders) {
            $scope.managedfolder = $scope.managedfolders.filter(function(f) {return f.smartId == $scope.dataset.params.folderSmartId;})[0];
        } else {
            $scope.managedfolder = null;
        }
    };

    DataikuAPI.managedfolder.listWithAccessible($stateParams.projectKey).success(function(data) {
        data.forEach(function(ds) {
            ds.foreign = (ds.projectKey != $stateParams.projectKey);
            ds.smartId = SmartId.create(ds.id, ds.projectKey);
        });
        $scope.managedfolders = data;
        refreshManagedFolder();
    }).error(setErrorInScope.bind($scope));

    $scope.usePartitioningFromFolder = function() {
        if (!$scope.managedfolder) return;
        $scope.dataset.partitioning = $scope.managedfolder.partitioning ? angular.copy($scope.managedfolder.partitioning) : {dimensions: []};
    };

    $scope.$watch("dataset.params.folderSmartId", function() {
        refreshManagedFolder();
    });

    $scope.itemPathSelected = function() {
        if ($scope.fileChoice.itemPath) {
            $scope.dataset.params.itemPathPattern = $scope.fileChoice.itemPath;
        }
    };

    if ($stateParams.prefillParams) {
        var prefillParams = JSON.parse($stateParams.prefillParams);
        if (prefillParams.folderSmartId && !$scope.dataset.params.folderSmartId) {
            $scope.dataset.params.folderSmartId = prefillParams.folderSmartId;
        }
        if (prefillParams.itemPathPattern && !$scope.dataset.params.itemPathPattern) {
            $scope.dataset.params.itemPathPattern = prefillParams.itemPathPattern;
        }
        $scope.dataset.projectKey = $scope.dataset.projectKey || $stateParams.projectKey; // otherwise the folderSmartId is a bit irrelevant
    }
});

}());

(function() {
'use strict';

const app = angular.module('dataiku.datasets.custom', []);


app.controller("CustomDatasetController", function($scope, $stateParams, Assert, DataikuAPI, PluginConfigUtils, Logger, DatasetUtils, MonoFuture) {
    Assert.trueish($scope.dataset.type, 'no dataset type');

    $scope.showPreview = true;

    $scope.desc = $scope.types[$scope.dataset.type].customDatasetDesc;

    $scope.loadedDesc = $scope.appConfig.customDatasets.filter(function(x){
        return x.datasetType == $scope.dataset.type;
    })[0];
    $scope.pluginDesc = $scope.appConfig.loadedPlugins.filter(function(x){
        return x.id == $scope.loadedDesc.ownerPluginId;
    })[0];


    // Finish dataset initialization if needed
    if (! $scope.dataset.schema) {
        $scope.dataset.schema = { columns: [] };
    }
    if (!$scope.dataset.params) {
        $scope.dataset.params ={}
    }
    if (!$scope.dataset.params.customConfig) {
        $scope.dataset.params.customConfig = {}
    }
    PluginConfigUtils.setDefaultValues($scope.desc.params, $scope.dataset.params.customConfig);

    $scope.handleTestResult = function(){
        Assert.inScope($scope, 'testResult');

        if ($scope.testResult.schema != null) {
            $scope.dataset.schema = $scope.testResult.schema;
        }
        if ($scope.testResult.codeDefinedPartitioning != null) {
            $scope.dataset.partitioning = $scope.testResult.codeDefinedPartitioning;
        }
        if (!$scope.dataset.name && !$scope.new_dataset_name) {
            $scope.new_dataset_name = $scope.testResult.suggestedName;
        }
    }

    $scope.test = function () {
        $scope.testing = true;
        $scope.testResult = null;

        $scope.testFuture = null;
        MonoFuture($scope).wrap(DataikuAPI.datasets.customDataset.test)($stateParams.projectKey, $scope.dataset, $scope.showPreview).success(function (data) {
            $scope.testFuture = null;
            $scope.testing = false;
            Logger.info("Got test result");
            $scope.testResult = data.result;
            $scope.handleTestResult();
        }).update(function (data) {
            $scope.testFuture = data;
        }).error(function (data, status, headers) {
            $scope.testFuture = null;
            $scope.testing = false;
            setErrorInScope.bind($scope)(data, status, headers);
        });
    };

    $scope.onLoadComplete = function() {
        if ($scope.$eval('dataset.params.connection')) {
            $scope.test(true);
        }
    };

    $scope.toggleShowRequirements = function() {
    	if ( $scope.showRequirements === undefined ) {
    		$scope.showRequirements = false;
    		// first time : fetch requirements from the backend, with the command line to install them
    	    DataikuAPI.datasets.getRequirements($stateParams.projectKey, $scope.dataset.type).success(function(data){
    	    	$scope.requirements = data;
    	    }).error(setErrorInScope.bind($scope));
    	}
    	$scope.showRequirements = !$scope.showRequirements;
    };

    $scope.setSchemaUserModified = function() {
        $scope.schemaJustModified = true;
        $scope.dataset.schema.userModified = true;
    };

    $scope.checkConsistency = function() {
        Logger.info('Checking consistency');

        $scope.schemaJustModified = false;
        DataikuAPI.datasets.testSchemaConsistency($scope.dataset).success(function (data) {
            Logger.info("Got consistency result", data);
            $scope.consistency = data;
            $scope.consistency.kind = DatasetUtils.getKindForConsistency($scope.dataset);
        }).error(setErrorInScope.bind($scope));
    };

});


    app.controller("DatasetFromPluginCreationController", function($scope, $state, $rootScope, $stateParams){
        $scope.datasets = [];
        $scope.otherPluginRecipes = [];

        $scope.$watch("pluginId", function(nv, ov) {
            if (!nv) return;
            $scope.plugin = Array.dkuFindFn($rootScope.appConfig.loadedPlugins, function(n){
                return n.id === $scope.pluginId
            });

            const addDataset = function (plugin, getPluginType) {
                if (plugin.ownerPluginId === $scope.pluginId) {
                    $scope.datasets.push({
                        type: getPluginType(plugin),
                        label: plugin.desc.meta.label,
                        description: plugin.desc.meta.description,
                        icon: plugin.desc.meta.icon || $scope.plugin.icon
                    });
                }
            };

            if ($scope.plugin) {
                $rootScope.appConfig.customFSProviders.forEach(plugin => addDataset(plugin, x => x.fsProviderType));
                $rootScope.appConfig.customDatasets.forEach(plugin => addDataset(plugin, x => x.datasetType));
            }
        });

        $scope.create = function(dataset) {
            $scope.dismiss();
            $state.go('projects.project.datasets.new_with_type.settings', {type:dataset.type, zoneId: $scope.getRelevantZoneId($stateParams.zoneId)});
        };
    });


})();
(function() {
'use strict';

var app = angular.module('dataiku.datasets');


app.controller("BaseEditableDatasetController", function($scope, $stateParams, DatasetUtils, DataikuAPI) {
    DatasetUtils.listDatasetsUsabilityInAndOut($stateParams.projectKey, "sync").then(function(data){
        $scope.availableInputDatasets = data[0].filter(function(ds){
            // remove self
            return ds.name != $stateParams.datasetName || ds.projectKey != $stateParams.projectKey;
        });
    });
    $scope.dataset.managed = true;//Editable datasets are always managed
});


/* Settings controller (also used in new dataset page) */
app.controller("EditableDatasetController", function($scope, $stateParams, $controller, DataikuAPI, LoggerProvider) {
    $controller("BaseEditableDatasetController", {$scope: $scope});
    $controller("BaseUploadedFilesController", {$scope: $scope});
    $controller("ManagedFSLikeDatasetController", {$scope: $scope});

    var Logger = LoggerProvider.getLogger('datasets.editable');

    $scope.dataset.params = $scope.dataset.params || {};
    $scope.dataset.flowOptions = $scope.dataset.flowOptions || {};
    $scope.dataset.params.importProjectKey = $stateParams.projectKey;
    $scope.dataset.flowOptions.rebuildBehavior = $scope.dataset.flowOptions.rebuildBehavior || 'WRITE_PROTECT';
    $scope.dataset.flowOptions.crossProjectBuildBehavior = $scope.dataset.flowOptions.crossProjectBuildBehavior || 'STOP';

    $scope.interactionType = 'editable';
    $scope.uiState.autoTestOnFileSelection = true;

    $scope.test = function () {
        $scope.testing = true;
        $scope.testResult = null;
        DataikuAPI.datasets.editable.test($stateParams.projectKey, angular.toJson($scope.dataset)).then(
        function (data) {
            $scope.testing = false;
            $scope.testResult = data;
            if (!$scope.dataset.name) {
                $scope.new_dataset_name = $scope.testResult.suggestedName;
            }
            if ($scope.testResult.tableSchema && (!$scope.dataset.schema || !$scope.dataset.schema.columns == 0 || !$scope.dataset.schema.columns.length)) {
                // Overwrite schema using detected schema, if we have none
                $scope.dataset.schema = {
                        'userModified': false,
                        'columns': $scope.testResult.tableSchema.columns
                };
                $scope.testResult.schemaMatchesTable = true;
            }
        }, function (data) {
            $scope.testing = false;
        });
    };

    // Cannot save if downloading
    $scope.saveHooks.push(function() {
        return $scope.downloadingFiles == 0;
    });

    $scope.saveHooks.push(function() {
        var params = $scope.dataset.params;
        if(params.importSourceType == 'NONE') {
            return true;
        } else if(params.importSourceType == 'DATASET') {
            return !!params.importDatasetSmartName;
        } else if(params.importSourceType == 'FILE') {
            return $scope.files && $scope.files.length > 0;
        }
        Logger.warn("unknown source type", set.importSourceType);
    });

    $scope.onLoadComplete = function(){
        $scope.test(true);
    };

    // list of uploaded files (with finished upload)
    $scope.$watch(function () {
        return $.grep($scope.files, function (f) {
            return angular.isUndefined(f.progress);
        });
    }, function (nv, ov) {
        if (nv !== ov) {
            $scope.onCoreParamsChanged();
        }
    }, true);

    $scope.dataset.params = $scope.dataset.params || {};
    $scope.dataset.params.importSourceType = 'NONE';
    $scope.editableDataset = true;
});


/* Edit tab controller */
app.controller("DatasetEditController", function($scope, TopNav) {
    TopNav.setLocation(TopNav.TOP_FLOW, "datasets", TopNav.TABS_DATASET, "edit");
    
    var getDatasetFromFullInfo = function() {
        if ($scope.datasetFullInfo) {
            $scope.dataset = $scope.datasetFullInfo.dataset;
        } else {
            $scope.dataset = null;
        }
    };
    
    $scope.$watch("datasetFullInfo", getDatasetFromFullInfo);
    getDatasetFromFullInfo();
});


app.controller("EditableDatasetImportController", function($scope, $rootScope, $stateParams, Dialogs, DataikuAPI, $controller) {
    $controller("BaseEditableDatasetController", {$scope: $scope});
    $controller("BaseUploadedFilesController", {$scope: $scope});

    function doImport() {
        $scope.dismiss();
        DataikuAPI.datasets.editable.import($stateParams.projectKey, $stateParams.datasetName, angular.toJson($scope.dataset))
            .success(
                function(data) {
                    $scope.loadData();
                    $scope.datasetSaved = true;
                }
            ).error(setErrorInScope.bind($rootScope));
    }

    $scope.isValid = function() {
        if ($scope.dataset.params.importSourceType == 'DATASET') {
            return !!$scope.dataset.params.importDatasetSmartName;
        }
        return true;
    };

    $scope.import = function() {
        Dialogs.confirm($scope, "Import data", "This operation cannot be reverted, are you sure you want to continue?").then(function() {
            if (!$scope.datasetSaved && $scope.dataset.params.importMode == 'APPEND') {
                $scope.saveDataset().then(doImport);
            } else {
                doImport();
            }
        });
    };
});


var widgets = angular.module('dataiku.directives.widgets');

widgets.directive("datasetSpreadsheet", function($stateParams, $timeout, CreateModalFromTemplate, DataikuAPI, Dialogs, Debounce, Logger) {
    var min = window.Math.min;
    var max = window.Math.max;

    function filledArray(size, value) {
        return $.map(Array(size), function(){return 1}).map(function(){return value;});//the double map is to be compatible with undefined/null as input and/or output
    }

    function generateUniqueColId(schema) {
        if (!schema || !schema.columns) return null;
        var colNames = schema.columns.map(function(col){return col.name});
        var id = 'new_column',
            i = 0;
        while(colNames.indexOf(id) >= 0) {
            id = 'new_column_'+(++i);
        }
        return id;
    }

    function markDirty(scope) {
        safeApply(scope, function(){
            //We don't analyse changes, any edit operation will mark the dataset as unsaved
            scope.datasetSaved = false;
        });
    }

    function makeContextMenu(scope, readOnly) {
        function columnsSelected(selection) {
            if (!selection) return 0;
            return selection[3] - selection[1] + 1;
        }
        function rowsSelected(selection) {
            if (!selection) return 0;
            return selection[2] - selection[0] + 1;
        }
        var contextMenu =  [
            {
                name: "Edit column",
                callback: function(key, selection) {
                    var visibleIdx = selection.start.col;
                    scope.editCol(visibleIdx);
                },
                disabled: function (x) {
                    if (readOnly) {
                        return true;
                    }
                    var selection = this.getSelected();
                    if (!selection) {
                        return true;
                    }
                    var singleColSelected = selection[1] == selection[3];
                    return selection[1] < 0 || this.countCols() >= this.getSettings().maxCols || !singleColSelected;
                }
            },
            {
                name: "Insert column before",
                callback: function(key, selection) {
                    var visibleIdx = selection.start.col;
                    scope.addCol(visibleIdx);
                },
                disabled: function () {
                    if (readOnly) {
                        return true;
                    }
                    var selection = this.getSelected();
                    return selection === undefined || selection[1] < 0;
                }
            },
            {
                name: function() {
                    var selection = this.getSelected();
                    return "Insert column after";
                },
                callback: function(key, selection) {
                    var visibleIdx = selection.end ? selection.end.col + 1: 0;
                    scope.addCol(visibleIdx);
                },
                disabled: function () {
                    if (readOnly) {
                        return true;
                    }
                    return false;
                }
            },
            {
                name: function(x,y) {
                    var selection = this.getSelected();
                    return "Remove column" + (columnsSelected(selection) > 1 ? 's' : '');
                },
                callback: function(key, selection) {
                    for(var visibleIdx = selection.end.col; visibleIdx >= selection.start.col; visibleIdx--) {
                        scope.removeCol(visibleIdx);
                    }
                },
                disabled: function () {
                    if (readOnly) {
                        return true;
                    }
                    var selection = this.getSelected();
                    return selection === undefined || selection[1] < 0;
                }
            },
            "---------",
            {
                name: function() {
                    var selection = this.getSelected();
                    return "Insert row" + (columnsSelected(selection) > 1 ? 's' : '')+ " above";
                },
                callback: function (key, selection) {
                    var nbRows = rowsSelected(this.getSelected());
                    this.alter("insert_row", selection.start.row, nbRows);
                },
                disabled: function () {
                    if (readOnly) {
                        return true;
                    }
                    var selection = this.getSelected();
                    return selection === undefined || this.getSelected()[0] < 0;
                }
            },
            {
                name: function() {
                    var selection = this.getSelected();
                    return "Insert row" + (columnsSelected(selection) > 1 ? 's' : '')+ " below";
                },
                callback: function (key, selection) {
                    var nbRows = rowsSelected(this.getSelected());
                    this.alter("insert_row", selection.end.row + 1, nbRows);
                },
                disabled: function () {
                    if (readOnly) {
                        return true;
                    }
                var selection = this.getSelected();
                return selection === undefined || this.getSelected()[0] < 0;
                }
            },
            {
                name: function() {
                    var selection = this.getSelected();
                    return "Remove row" + (columnsSelected(selection) > 1 ? 's' : '');
                },
                callback: function (key, selection) {
                    var amount = selection.end.row - selection.start.row + 1;
                    this.alter("remove_row", selection.start.row, amount);
                },
                disabled: function () {
                    if (readOnly) {
                        return true;
                    }
                    var selection = this.getSelected();
                    return selection === undefined || this.getSelected()[0] < 0;
                }
            },
            "---------",
            {
                name: "Mark as unchanged",
                callback: function (key, selection) {
                    var selection = this.getSelected(),
                        data = this.getData(),
                        changes = [];
                    for (var i = min(selection[2], selection[0]); i <= max(selection[2], selection[0]); ++i) {
                        for (var j = min(selection[3], selection[1]); j <= max(selection[3], selection[1]); ++j) {
                            var changedBefore = data[i].changed(j);
                            var stateBefore = data[i].getChangeState(j);
                            data[i].markUnchanged(j);
                            if (changedBefore && !data[i].changed(j)) {
                                changes.push([i, j, data[i].attr(j), data[i].attr(j), stateBefore, data[i].getChangeState(j)]);
                            }
                        }
                    };
                    if (changes.length > 0) {
                        var action = new Handsontable.UndoRedo.ChangeAction(changes);
                        this.undoRedo.done(action);
                        this.render();
                        markDirty(scope);
                    }
                },
                disabled: function () {
                    if (readOnly) {
                        return true;
                    }
                    var selection = this.getSelected(),
                        data = this.getData();
                    if (!selection) {
                        return true;
                    }
                    for (var i = min(selection[2], selection[0]); i <= max(selection[2], selection[0]); ++i) {
                        for (var j = min(selection[3], selection[1]); j <= max(selection[3], selection[1]); ++j) {
                            if (data[i].changed(j) && data[i].originalIdx >= 0) {
                                return false;
                            }
                        }
                    }
                    return true;
                }
            },
            "---------",
            {
                name: "Remove empty rows",
                callback: scope.removeEmptyRows,
                disabled: function () {
                    return readOnly
                }
            }
        ];
        return contextMenu;
    }


    var keysByCode = {
        9: 'tab',
        13: 'enter',
        39: 'right',
        40: 'down'
    };

    return {
        restrict : 'AE',
        link : function(scope, element, attrs) {
            var datasetName = scope.$eval(attrs.dataset) || $stateParams.datasetName || $stateParams.datasetFullName;
            var projectKey = scope.$eval(attrs.projectKey) || $stateParams.projectKey;
            scope.readOnly = !!scope.$eval(attrs.readOnly);
            scope.fixedRowNumber = !!scope.$eval(attrs.fixedRowNumber);

            /*
            Returns the html content for column headers as used by hansontable
             */
            function getColHeaders(schema) {
                return schema.columns.map(function(col, dataIdx){
                    return '<span class="column-name no-select" title="'+sanitize(col.name)+' ('+sanitize(col.type)+')" data-idx="' + dataIdx + '">' + sanitize(col.name) + '</span>' +
                        '<span class="column-type no-select">'+sanitize(col.type)+ '</span>'
                });
            }

            function getColumns(schema) {
                if (scope.readOnly) {
                    return schema.columns.map(function(col) {
                        return {
                            readOnly: scope.readOnly,
                            renderer: function(instance, td, row, visibleCol, prop, value, cellProperties) {
                                Handsontable.renderers.TextRenderer.apply(this, arguments);
                                td.style.backgroundColor = "#fafafa";
                            }
                        };
                    });
                } else {
                    return schema.columns.map(function(col, dataIdx) {
                        return {
                            data: property(dataIdx) ,
                            renderer: function(instance, td, row, visibleCol, prop, value, cellProperties) {
                                Handsontable.renderers.TextRenderer.apply(this, arguments);
                                var rowObj = instance.getSourceDataAtRow(row);
                                var colName = col.name;
                                if(scope.creatingRecipe && scope.creatingRecipe.params && scope.creatingRecipe.params.uniqueKey && scope.creatingRecipe.params.uniqueKey.indexOf(colName) >= 0) {
                                    $(td).addClass('key');
                                }
                                if (rowObj.changed(dataIdx)) {
                                    $(td).addClass('changed');
                                }
                            }
                        };
                    });
                }
            }

            function beforeKeyDown (evt) {
                function mod(a,b) {
                    return (a+b)%b;
                }
                var which = keysByCode[evt.which],
                    selection = handsontable.getSelected();
                if (!selection) {
                    return;
                }
                var lastRowSelected = min(selection[0],selection[2]) == handsontable.countRows() - 1,
                    lastColSelected = min(selection[1],selection[3]) == handsontable.countCols() - 1;
                if (which == 'down' && lastRowSelected) {
                    scope.addRow();
                    evt.stopImmediatePropagation();
                    Logger.debug("keyDown propagation stopped.");
                    return false;
                } else if (which == 'enter') {
                    if (evt.shiftKey) {
                        evt.isImmediatePropagationEnabled = false; // Prevent the handsontable library to handle the event
                        evt.stopImmediatePropagation();
                        Logger.debug("keyDown propagation stopped.");
                        return false;
                    }
                    if (lastRowSelected && handsontable.getActiveEditor().isOpened()) { //on enter when editing a cell of the last row
                        scope.addRow();
                        handsontable.selectCell(
                            handsontable.countRows() - 1,
                            selection[1]
                        );
                    }
                } else if (which == 'tab') {
                    if (lastRowSelected && lastColSelected) {
                        scope.addRow();
                    }
                    var colShift = evt.shiftKey ? -1 : 1,
                        rowShift = 0;
                    if (selection[1] + colShift < 0) {
                        rowShift = -1;
                    } else if (selection[1] + colShift >= handsontable.countCols()) {
                        rowShift = 1;
                    }

                    handsontable.selectCell(
                        max(0, selection[0] + rowShift),
                        mod(selection[1] + colShift, handsontable.countCols())
                    );
                    evt.preventDefault(); // Prevent a weird UI bug to happen
                    evt.isImmediatePropagationEnabled = false; // Prevent the handsontable library to handle the event
                    evt.stopImmediatePropagation();
                    Logger.debug("keyDown propagation stopped.");
                    return false;
                }
            }

            function afterCreateRow(newRowIdx, amount, auto) {
                //select inserted row (keep same selected col if there is one)
                var selection = handsontable.getSelected();
                var colIdx = selection ? selection[1] : 0;
                //called after each row creation => debounce render since it is expensive
                Debounce().withScope(scope).withDelay(50,50).wrap(function() {
                    handsontable.render();
                    handsontable.selectCell(newRowIdx, colIdx); //will also auto-scroll
                });
                afterChange();
            }

            function afterRemoveRow(newRowIdx, amount) {
                //select inserted row (keep same selected col if there is one)
                var selection = handsontable.getSelected();
                var colIdx = selection ? selection[1] : 0;
                handsontable.render();
                handsontable.selectCell(newRowIdx, colIdx); //will also auto-scroll

                afterChange();
            }

            function afterChange (changes, source) {
                if (source != 'loadData') {
                    markDirty(scope);
                }
                $timeout(function(){safeApply(scope)});
            }

            function afterRender() {
                // add double-click events on headers
                $('div[dataset-spreadsheet] .ht_clone_top table.htCore tr th:not(:first-child)').each(function(i, d) {
                    $(d).unbind('dblclick').bind('dblclick', function() {
                        scope.editColIdx($(this).find('.column-name').data('idx'));
                        handsontable.deselectCell();
                    });
                });
            }

            function makeSpreadSheet(data, schema) {
                var contextMenu = makeContextMenu(scope, scope.readOnly);

                //The UI is buggy when the "height" option is undefined
                var options = {
                    data: data,
                    colHeaders: getColHeaders(schema),
                    columns: getColumns(schema),

                    height: $(window).height() - $(container).offset().top
                            - parseInt($(container).css('padding-top')) - parseInt($(container).css('padding-bottom'))
                            - 2,

                    //stretchH: 'all',
                    rowHeaders: true,
                    manualColumnMove: true,
                    manualColumnResize: true,
                    //manualRowResize: true,
                    colWidths: 200,
                    maxRows: 100*1000,

                    contextMenu: contextMenu,

                    afterChange: afterChange,
                    afterCreateRow: afterCreateRow,
                    afterRemoveRow: afterRemoveRow,
                    afterRender: afterRender,

                    beforeKeyDown: beforeKeyDown,

                    dataSchema: Row
                };

                if (scope.readOnly) {
                    options.maxRows = data.length //prevents adding rows with paste
                }

                if (!handsontable || $.isEmptyObject(handsontable)) {
                    handsontable = new Handsontable(container, options);
                    handsontable.render();
                } else {
                    handsontable.updateSettings(options);
                    handsontable.render();
                }

                $(window).on('resize.handsontable', Debounce().withScope(scope).withDelay(200,200).wrap(function() {
                    handsontable.updateSettings({
                        height: $(window).height() - $(container).offset().top
                            - parseInt($(container).css('padding-top')) - parseInt($(container).css('padding-bottom'))
                            - 2,
                        width: $(window).width()
                    });
                }));

                /*
                * make the undo/redo function of handsontable compatible with change tracking
                */
                function propToCol(prop) {
                    return typeof prop == 'function' ? prop.attr : prop;
                }
                handsontable.addHook('beforeChange', function(changes, source) {
                    var rowObj, col, change;
                    if (source != 'loadData' && source != 'undo' && source != 'redo' && source != 'alter') {
                        for (var i = 0; i < changes.length; i++) {
                            change = changes[i];
                            rowObj = handsontable.getData()[change[0]];
                            col = propToCol(change[1]);
                            if (rowObj) {
                                change[4] = rowObj.getChangeState(col);
                            }
                        }
                    }
                });
                handsontable.addHook('afterChange', function(changes, source) {
                    var rowObj, col, change;
                    if (source == 'undo' || source == 'redo') {
                        for (var i = 0; i < changes.length; i++) {
                            change = changes[i];
                            if (change != null && change[1] != null && change[5] != null) {
                                rowObj = handsontable.getData()[change[0]];
                                col = propToCol(change[1]);
                                rowObj.setChangeState(col, change[5]);
                            }
                        }
                        handsontable.render();
                    } else if (source != 'loadData') {
                        for (var i = 0; i < changes.length; i++) {
                            change = changes[i];
                            rowObj = handsontable.getData()[change[0]];
                            col = propToCol(change[1]);
                            change[5] = rowObj.getChangeState(col);
                        }
                    }
                });
                handsontable.addHook('persistentStateSave', function(change, value) {
                    if (change == 'manualColumnPositions') {
                        markDirty(scope);
                    }
                });
            }

            function makeSaveQuery(data) {
                var empty = [];
                var query = {
                    data: data.map(function(row) {
                        if (row.changed() || row.changeFlagsOverwritten) {
                            return row.data;
                        } else {
                            // no change in the row, no need to send to server
                            return empty;
                        }
                    }),
                    schema: schema,
                    versionTag: datasetVersionTag
                };

                var hasNonIdentityRowMapping = false;
                var rowMapping = data.map(function(row, rowIdx) {
                    if (row.originalIdx != rowIdx) {
                        hasNonIdentityRowMapping = true;
                    }
                    return row.originalIdx;
                });
                if (hasNonIdentityRowMapping) { //no need to send an identity mapping
                    query.rowMapping = rowMapping;
                }

                var hasNonIdentityColMapping = false;
                var colMapping = schema.columns.map(function(col) {
                    if (col.originalName != col.name) {
                        hasNonIdentityColMapping = true;
                    }
                    return col.originalName;
                });
                if (hasNonIdentityColMapping) { //no need to send an identity mapping
                    query.colMapping = colMapping;
                }

                if (scope.dataset.params.keepTrackOfChanges) {
                    query.changes = data.map(function(row) {
                        if (row.changeFlagsOverwritten) {
                            return row.data.map(function(_,rowIdx){return row.changed(rowIdx)});
                        } else {
                            // default changedFlags, no need to send to server
                            return empty;
                        }
                    });
                }

                var schemaOrder = handsontable.manualColumnPositions;
                if (!isIdentity(schemaOrder)) {
                    query.schemaOrder = schemaOrder;
                }


                return query;
            }

            function resetDataChanges(data, resp) {
                data.map(function(row, rowIdx){
                    if (row.changeFlags && scope.dataset.params.keepTrackOfChanges) {
                        row.humanModified = row.humanModified || [];
                        for (var i = 0; i < row.changeFlags.length; i++) {
                            if (i < row.humanModified.length) {
                                row.humanModified[i] = row.changeFlags[i] || row.humanModified[i];
                            } else {
                                row.humanModified[i] = row.changeFlags[i];
                            }
                        }
                    }
                    row.originalIdx = rowIdx;
                    delete row.changeFlags;
                    delete row.changeFlagsOverwritten;
                });
                datasetVersionTag = resp.versionTag;
                handsontable.render();
                scope.datasetSaved = true;
            }

            function saveData(data, schema) {
                var formattedData = makeSaveQuery(data);
                var serializedData = angular.toJson(formattedData);
                return DataikuAPI.datasets.editable.save(projectKey, datasetName, serializedData)
                    .success(function(resp) {
                        if (resp && resp.canBeSaved === false) {
                            Logger.error("Dataset cannot be saved", resp);
                        } else {
                            resetDataChanges(data, resp);
                        }
                    })
                    .error(setErrorInScope.bind(scope));
            }

            checkChangesBeforeLeaving(scope, function(){ return scope.dataset.name && !scope.datasetSaved;});

            /* creation is true if the column is being created, false if it is edited */
            function showColumnEditModal(dataIdx, column, creation, onValidate) {
                var newScope = scope.$new();
                newScope.column = column;
                newScope.creation = creation;
                newScope.isValid = function() {
                    if (!column.name || !column.name.length) {
                        return false;
                    }
                    if (creation) {
                        var usedNames = schema.columns.map(function(col){return col.name});
                        return usedNames.indexOf(column.name) < 0;
                    }
                    return true;
                };
                newScope.validate = function(){
                    if (!newScope.isValid()) return;
                    safeApply(scope, onValidate);
                    if (newScope.hasChanged) scope.datasetSaved = false;
                    var modalScope = $(".dku-modal").scope();
                    modalScope.dismiss();
                };
                newScope.removeCol = function() {
                    var displayOrder = handsontable.manualColumnPositions;
                    var visibleIdx = displayOrder.indexOf(dataIdx);
                    scope.removeCol(visibleIdx);
                    scope.datasetSaved = false;
                    var modalScope = $(".dku-modal").scope();
                    modalScope.dismiss();
                };
                newScope.hasChanged = false;
                var init = true;
                newScope.$watch('column', function(nv, ov) {
                    if (init) return init = false;
                    newScope.hasChanged = true;
                }, true);

                CreateModalFromTemplate("/templates/datasets/editable-dataset-column-modal.html", newScope);
            }

            var handsontable = {},
                schema = {},
                datasetVersionTag,
                container = document.getElementById('spreadsheet');

            scope.datasetHooks.userIsWriting = function() {
                if (handsontable.getActiveEditor() == undefined) {return false}
                return handsontable.getActiveEditor()._opened || handsontable.getSelected() != undefined;
            }

            scope.countCols = function() {
                return handsontable.countCols ? handsontable.countCols() : 0;
            };
            scope.countRows = function() {
                return handsontable.countRows ? handsontable.countRows() : 0;
            };
            scope.addRow = function(visibleIdx){
                if (scope.readOnly) {
                    Logger.error("ReadOnly mode: cannot add row.");
                    return;
                }
                visibleIdx = (visibleIdx === undefined) ? handsontable.countRows() + 1 : visibleIdx;
                handsontable.alter("insert_row", visibleIdx);
            };

            scope.showImportModal = function() {
                if (scope.readOnly) {
                    Logger.error("ReadOnly mode.");
                    return;
                }
                var cfg = scope.dataset.params;
                var newScope = scope.$new();
                newScope.currentTab = 'source';
                cfg.importSourceType = 'DATASET';
                cfg.importMode = 'REPLACE';
                CreateModalFromTemplate("/templates/datasets/editable-dataset-import-modal.html", newScope, "EditableDatasetImportController");
            };

            scope.undo = function() {
                handsontable.undo();
            }
            scope.redo = function() {
                handsontable.redo();
            }
            scope.canUndo = function () {
                return handsontable && handsontable.undoRedo && handsontable.undoRedo.isUndoAvailable();
            };
            scope.canRedo = function () {
                return handsontable && handsontable.undoRedo && handsontable.undoRedo.isRedoAvailable();
            };

            scope.datasetSaved = true; // keep track of unsaved changes
            scope.saveDataset = function() {
                return saveData(handsontable.getData(), schema);
            };

            function empty(str) {
                return str == null || str.length == 0;
            }
            function same(str1, str2) {
                //this is an equivalence relation such that null == undefined == "" and usual for other cases
                if (empty(str1) && empty(str2)) {
                    return true;
                }
                return str1 == str2;
            }
            function isTrueish(x) {
                return !!(x && (x == true || x.toLowerCase() == "true") || !!parseFloat(x));
            }
            function isIdentity(arr) {
                for (var i = 0; i < arr.length; i++) {
                    if (arr[i] != i) {
                        return false;
                    }
                }
                return true;
            }


            /*
            * Data model for rows.
            * Attributes:
            *   - data (array)
            *   - originalIdx (int) row number in the data stored in the server (-1 means the row is new, so not on the server)
            *   - changeFlags (array[boolean]) true if the cell was modified *compared to the data on the server* (reset every time the data is loaded or saved). undefined === all false
            *   - humanModified (array[boolean]) true if the cell was ever modified manually
            *   - changeFlagdsOverwritten (boolean) true if at least a cell was forced to be marked as unchanged *in the current session* (reset every time the data is loaded or saved)
            */
            function Row(dataSource, rowIdx, humanModified) {
                //handsontable calls the constructor without "new", so the Row prototype cannot be used on rows created by handsontable
                if (!(this instanceof Row)){
                    return new Row(dataSource, rowIdx);
                }
                var width = schema.columns.length;
                if (Array.isArray(dataSource)) {
                    if (dataSource.length != width) {
                        Logger.warn("Row has invalid size: "+dataSource.length+". Schema has "+width+" columns")
                    }
                    this.data = angular.copy(dataSource);
                } else {
                    this.data = filledArray(schema.columns.length, '');
                }

                // humanModified means that the cell was someday modified. not necessarily during the current session
                if (humanModified) {
                    this.humanModified = humanModified.map(isTrueish);
                }
                this.originalIdx = rowIdx != undefined ? rowIdx : -1; //row index in the original dataset. -1 means new row
            }
            //getter/setter
            Row.prototype.attr = function (attr, val) {
                if (val === undefined) {
                    return this.data[attr];
                }
                if (!same(this.data[attr], val)) {
                    this.data[attr] = val;
                    this.markChanged(attr);
                }
            };
            Row.prototype.createCol = function (dataIdx, content) {
                content = content || {}
                dataIdx = dataIdx === undefined ? this.data.length : dataIdx;
                this.data.splice(dataIdx, 0, content.data || '');
                if (content.changeFlags) {
                    this.changeFlags = this.changeFlags || [];
                    this.changeFlags[dataIdx] = true;
                }
                if (content.humanModified) {
                    this.humanModified = this.humanModified || [];
                    this.humanModified[dataIdx] = true;
                }
            };
            Row.prototype.removeCol = function (dataIdx) {
                var removed = {};
                removed.data = this.data.splice(dataIdx, 1)[0];
                if (this.changeFlags) {
                    removed.changeFlags = this.changeFlags.splice(dataIdx, 1)[0];
                }
                if (this.humanModified) {
                    removed.humanModified = this.humanModified.splice(dataIdx, 1)[0];
                }
                return removed;
            };
            Row.prototype.isEmpty = function () {
                for (var i = 0; i < this.data.length; i++) {
                    if (this.data[i] && this.data[i].length > 0) {
                        return false;
                    }
                }
                return true;
            };
            Row.prototype.changed = function (colIdx) {
                if (colIdx === undefined) {
                    return this.changeFlags && this.changeFlags.indexOf(true) >=0;
                }

                if (this.changeFlags && this.changeFlags[colIdx]) {
                    return true;
                }
                if (this.humanModified && this.humanModified[colIdx]) {
                    return true;
                }
                return false;
            };
            Row.prototype.markUnchanged = function (colIdx) {
                if (!scope.dataset.params.keepTrackOfChanges) {
                    return;
                }
                if (this.originalIdx < 0) {
                    return; //cannot mark newly created row as unchanged
                }
                if (this.changeFlags && this.changeFlags[colIdx]) {
                    this.changeFlags[colIdx] = false;
                    this.changeFlagsOverwritten = true;
                }
                if (this.humanModified && this.humanModified[colIdx]) {
                    this.humanModified[colIdx] = false;
                    this.changeFlagsOverwritten = true;
                }
            };
            Row.prototype.markChanged = function (colIdx) {
                this.changeFlags = this.changeFlags || [];
                this.changeFlags[colIdx] = true;
            };
            Row.prototype.getChangeState = function (colIdx) {
                return [
                    this.changeFlags && this.changeFlags[colIdx] ? true : false,
                    this.humanModified && this.humanModified[colIdx] ? true : false,
                ];
            };
            Row.prototype.setChangeState = function (colIdx, state) {
                if (this.changeFlags && this.changeFlags[colIdx] != state[0]) {
                    this.changeFlags[colIdx] = state[0];
                } else if (!this.changeFlags && state[0]) {
                    this.changeFlags = [];
                    this.changeFlags[colIdx] = state[0];
                }
                if (this.humanModified && this.humanModified[colIdx] != state[1]) {
                    this.humanModified[colIdx] = state[1];
                } else if (!this.humanModified && state[1]) {
                    this.humanModified = [];
                    this.humanModified[colIdx] = state[1];
                }
            };
            function property(attr) {
                var f = function (row, value) {
                    if(!row) return null;
                    return row.attr(attr, value);
                };
                f.attr = attr;
                return f;
            }


            function RemoveColumnAction(visibleIdx, dataIdx, removedData, removedColumn) {
                this.visibleIdx = visibleIdx;
                this.dataIdx = dataIdx;
                this.removedData = removedData;
                this.removedColumn = angular.copy(removedColumn);
            }
            RemoveColumnAction.prototype.undo = function(instance, undoneCallback) {
                doAddCol(this.visibleIdx, this.dataIdx, this.removedColumn, this.removedData);
                if (undoneCallback) {
                    undoneCallback();
                }
                safeApply(scope);
            }
            RemoveColumnAction.prototype.redo = function(instance, redoneCallback) {
                doRemoveCol(this.visibleIdx);
                if (redoneCallback) {
                    redoneCallback();
                }
                safeApply(scope);
            }

            function AddColumnAction(visibleIdx, columnObject) {
                this.visibleIdx = visibleIdx;
                this.columnObject = angular.copy(columnObject);
            }
            AddColumnAction.prototype.undo = function(instance, undoneCallback) {
                doRemoveCol(this.visibleIdx);
                if (undoneCallback) {
                    undoneCallback();
                }
                safeApply(scope);
            }
            AddColumnAction.prototype.redo = function(instance, redoneCallback) {
                doAddCol(this.visibleIdx, angular.copy(this.columnObject));
                if (redoneCallback) {
                    redoneCallback();
                }
                safeApply(scope);
            }

            function EditColumnAction(visibleIdx, columnObjectBefore, columnObjectAfter) {
                this.visibleIdx = visibleIdx;
                this.columnObjectBefore = angular.copy(columnObjectBefore);
                this.columnObjectAfter = angular.copy(columnObjectAfter);
            }
            EditColumnAction.prototype.undo = function(instance, undoneCallback) {
                doEditCol(this.visibleIdx, angular.copy(this.columnObjectBefore));
                if (undoneCallback) {
                    undoneCallback();
                }
                safeApply(scope);
            }
            EditColumnAction.prototype.redo = function(instance, redoneCallback) {
                doEditCol(this.visibleIdx, angular.copy(this.columnObjectAfter));
                if (redoneCallback) {
                    redoneCallback();
                }
                safeApply(scope);
            }

            function doAddCol (visibleIdx, dataIdx, columnObject, content) {
                dataIdx = dataIdx === undefined ? handsontable.countCols() : dataIdx;
                var colId = generateUniqueColId(schema);
                var columnObject = columnObject || {
                    name: colId,
                    type: 'string',

                    dataIdx: dataIdx,
                    originalName: colId
                };
                var onValidate = function() {
                    schema.columns.splice(dataIdx, 0, angular.copy(columnObject));
                    visibleIdx = (visibleIdx === undefined) ? dataIdx : visibleIdx;

                    var displayOrder = angular.copy(handsontable.manualColumnPositions).map(function(otherDataIdx){
                        return otherDataIdx < dataIdx ? otherDataIdx :otherDataIdx + 1;
                    });
                    displayOrder.splice(visibleIdx, 0, dataIdx)

                    handsontable.getData().forEach(function(row, i){
                        row.createCol(dataIdx, content ? content[i] : content);
                    })

                    handsontable.updateSettings({
                        colHeaders: getColHeaders(schema),
                        columns: getColumns(schema)
                    });
                    if (!isIdentity(displayOrder)) {
                        handsontable.manualColumnPositions = displayOrder;
                        handsontable.render();
                    }
                };
                onValidate()
                return new AddColumnAction(visibleIdx, columnObject);
            }


            scope.addCol = function(visibleIdx, columnObject, content) {
                if (scope.readOnly) {
                    Logger.error("ReadOnly mode: cannot add col.");
                    return;
                }
                var action = doAddCol(visibleIdx, columnObject, content);
                handsontable.undoRedo.done(action);
                safeApply(scope);
                markDirty(scope);
            };

            function doRemoveCol (visibleIdx) {
                var displayOrder = angular.copy(handsontable.manualColumnPositions);
                var dataIdx = displayOrder[visibleIdx];
                //Handsontable cannot remove column with object data source or columns option specified, we need to take care of it
                var removedData = [];
                handsontable.getData().forEach(function(row){
                    removedData.push(row.removeCol(dataIdx));
                });
                var removedColumn = schema.columns.splice(dataIdx, 1)[0];

                displayOrder.splice(visibleIdx, 1);
                displayOrder = displayOrder.map(function(otherDataIdx) {
                    return otherDataIdx > dataIdx ? otherDataIdx - 1 : otherDataIdx;
                });

                handsontable.updateSettings({
                    colHeaders: getColHeaders(schema),
                    columns: getColumns(schema)
                });
                if (!isIdentity(displayOrder)) {
                    handsontable.manualColumnPositions = displayOrder;
                    handsontable.render();
                }
                return new RemoveColumnAction(visibleIdx, dataIdx, removedData, removedColumn);
            }

            scope.removeCol = function(visibleIdx) {
                if (scope.readOnly) {
                    Logger.error("ReadOnly mode: cannot remove col.");
                    return;
                }

                var action = doRemoveCol(visibleIdx);
                handsontable.undoRedo.done(action);
                safeApply(scope);
                markDirty(scope);
            };

            function doEditCol(visibleIdx, columnObject) {
                if (angular.equals(columnObject, schema.columns[dataIdx])) {
                    return false;
                }
                var displayOrder = handsontable.manualColumnPositions;
                var dataIdx = displayOrder[visibleIdx];
                schema.columns[dataIdx] = angular.copy(columnObject);
                handsontable.updateSettings({
                    colHeaders: getColHeaders(schema),
                    columns: getColumns(schema)
                });
                if (!isIdentity(displayOrder)) {
                    handsontable.manualColumnPositions = displayOrder;
                    handsontable.render();
                }
                handsontable.render();
                safeApply(scope);
                return true;
            }
            scope.editCol = function(visibleIdx) {
                if (scope.readOnly) {
                    Logger.error("ReadOnly mode: cannot edit col.");
                    return;
                }
                var displayOrder = handsontable.manualColumnPositions;
                scope.editColIdx(displayOrder[visibleIdx]);
            };

            scope.editColIdx = function(dataIdx) {
                var displayOrder = handsontable.manualColumnPositions;
                var visibleIdx = displayOrder.indexOf(dataIdx);
                var column = angular.copy(schema.columns[dataIdx]);
                var onValidate = function() {
                    var columnBefore = schema.columns[dataIdx];
                    if (doEditCol(visibleIdx, column)) {
                        var action = new EditColumnAction(visibleIdx, columnBefore, column);
                        handsontable.undoRedo.done(action);
                    }
                };
                showColumnEditModal(dataIdx, column, false, onValidate);
            };


            scope.loadData = function() {
                DataikuAPI.datasets.editable.getData(projectKey, datasetName)
                .success(function(resp) {
                    resp = resp || {};
                    datasetVersionTag = resp.versionTag || {versionNumber: 0};
                    if (resp.schema && resp.schema.columns && resp.schema.columns.length) {
                        schema = resp.schema;
                    } else {
                        schema = {
                            columns: [
                                { name: 'new_column', type: 'string'}
                            ]
                        };
                    }

                    schema.columns.forEach(function(col, dataIdx){
                        col.originalName = col.name;
                        col.dataIdx = dataIdx;
                    });

                    var data;
                    if (resp.data && resp.data.length > 0 && resp.data[0] && resp.data[0].length > 0) {
                        var nbRows = resp.data.length,
                            nbCols = resp.data[0].length,
                            humanModified = resp.humanModified || [],
                            data = [];
                        for (var i = 0; i < nbRows; ++i) {
                            var row = new Row(resp.data[i], i, humanModified[i]);
                            data.push(row);
                        }
                        scope.datasetSaved = true;
                    } else {
                        //Init data with an empty row if no data was received
                        data = [new Row()];
                        scope.datasetSaved = false;
                    }
                    scope.creatingRecipe = resp.creatingRecipe;
                    makeSpreadSheet(data, schema);
                });
            };

            scope.clearData = function() {
                if (scope.readOnly) {
                    Logger.error("ReadOnly mode: cannot clear.");
                    return;
                }
                handsontable.undoRedo.linkWithNextActions=true;
                handsontable.alter("remove_row", 0, handsontable.countRows());
                scope.addRow();
                scope.datasetSaved = false;
                handsontable.render();
            };

            scope.removeEmptyRows = function() {
                if (scope.readOnly) {
                    Logger.error("ReadOnly mode: cannot clear.");
                    return;
                }
                var data = handsontable.getData();
                var initialLength = data.length;
                for (var i = 1; i <= data.length; i++) {
                    var rowIdx = initialLength - i;
                    if (data[rowIdx].isEmpty()) {
                        handsontable.alter("remove_row", rowIdx, 1);
                    }
                }
            };

            scope.loadData();
        }
    }
});

}());

(function() {
'use strict';

const app = angular.module('dataiku.datasets');


app.controller("MetricsDatasetController", function($scope, $stateParams, $controller, LoggerProvider, DataikuAPI) {
	$controller("BaseRowDatasetController", {$scope: $scope, withConsistency: true});

    const Logger = LoggerProvider.getLogger('datasets.jobsdb');

    if ( !$scope.dataset.params.view ) {
    	$scope.dataset.params.view = 'METRICS_HISTORY';
    }
    if (!$scope.dataset.params.scope) {
        $scope.dataset.params.scope = "SINGLE_OBJECT";
    }

    $scope.viewTypes = [
        {
            name: 'METRICS_HISTORY',
            displayName: 'Metrics history'
        },
        {
            name: 'METRICS_LAST',
            displayName: 'Metrics last values'
        },
        {
            name: 'CHECKS_HISTORY',
            displayName: 'Checks history'
        },
        {
            name: 'CHECKS_LAST',
            displayName: 'Checks last values'
        }
    ];
    $scope.selected = {
        dataset: null,
        managedFolder: null,
        savedModel: null
    };

    function updateSelectedObject() {
    	if (!$scope.datasets || !$scope.managedFolders || !$scope.savedModels || !$scope.dataset.params || !$scope.dataset.params.smartName) {
            return;
        }
        const params = $scope.dataset.params;
    	const fullName = params.smartName.includes('.') ? params.smartName : ($stateParams.projectKey + '.' + params.smartName);
    	$scope.datasets.forEach(function(dataset) {
    		if (fullName == dataset.projectKey + '.' + dataset.name) {
    			$scope.selected.dataset = dataset;
    		}
    	});
    	$scope.managedFolders.forEach(function(mf) {
    		if (fullName == mf.projectKey + '.' + mf.id) {
    			$scope.selected.managedFolder = mf;
    		}
    	});
    	$scope.savedModels.forEach(function(sm) {
    		if (fullName == sm.projectKey + '.' + sm.id) {
    			$scope.selected.savedModel = sm;
    		}
    	});
    };

    DataikuAPI.datasets.listWithAccessible($stateParams.projectKey).success(function(data) {
    	data.forEach(function(ds) {ds.foreign = (ds.projectKey != $stateParams.projectKey);});
        $scope.datasets = data;
        updateSelectedObject();
    }).error(setErrorInScope.bind($scope));

    DataikuAPI.managedfolder.listWithAccessible($stateParams.projectKey).success(function(data) {
    	data.forEach(function(ds) {ds.foreign = (ds.projectKey != $stateParams.projectKey);});
        $scope.managedFolders = data;
        updateSelectedObject();
    }).error(setErrorInScope.bind($scope));

    DataikuAPI.savedmodels.listWithAccessible($stateParams.projectKey).success(function(data) {
    	data.forEach(function(ds) {ds.foreign = (ds.projectKey != $stateParams.projectKey);});
        $scope.savedModels = data;
        updateSelectedObject();
    }).error(setErrorInScope.bind($scope));

    $scope.onLoadComplete = function () {
    	updateSelectedObject();
    };

    $scope.$watch('selected.dataset', function(nv, ov) {
    	if ( nv == null || nv == ov ) return;
    	var ds = $scope.selected.dataset;
    	$scope.selected.managedFolder = null;
    	$scope.selected.savedModel = null;
    	var newSmartName = ($stateParams.projectKey != ds.projectKey ? (ds.projectKey + '.') : '') + ds.name;
    	if (newSmartName != $scope.dataset.params.smartName) {
    	    $scope.dataset.params.smartName = newSmartName;
    	    $scope.dataset.params.partition = null;
    	    $scope.dataset.params.filter = null;
    	}
    });

    $scope.$watch('selected.managedFolder', function(nv, ov) {
    	if ( nv == null || nv == ov ) return;
    	$scope.selected.dataset = null;
    	var mf = $scope.selected.managedFolder;
    	$scope.selected.savedModel = null;
        var newSmartName = ($stateParams.projectKey != mf.projectKey ? (mf.projectKey + '.') : '') + mf.id;
        if (newSmartName != $scope.dataset.params.smartName) {
        	$scope.dataset.params.smartName = newSmartName;
        	$scope.dataset.params.partition = null;
        	$scope.dataset.params.filter = null;
        }
    });

    $scope.$watch('selected.savedModel', function(nv, ov) {
    	if ( nv == null || nv == ov ) return;
    	$scope.selected.dataset = null;
    	$scope.selected.managedFolder = null;
    	var sm = $scope.selected.savedModel;
        var newSmartName = ($stateParams.projectKey != sm.projectKey ? (sm.projectKey + '.') : '') + sm.id;
        if (newSmartName != $scope.dataset.params.smartName) {
        	$scope.dataset.params.smartName = newSmartName;
        	$scope.dataset.params.partition = null;
        	$scope.dataset.params.filter = null;
        }
    });

    $scope.$watch('dataset.params.view', function(nv, ov) {
    	if ( nv == null || nv == ov ) return;
    	$scope.dataset.params.partition = null;
    	$scope.dataset.params.filter = null;
    });
    $scope.$watch('dataset.params.filter', function(nv, ov) {
    	if ( nv == ov ) return;
    	if ( $scope.dataset.params.filter == null ) {
    		$scope.dataset.params.filter = '';
    	}
    });
    $scope.$watch('dataset.params.partition', function(nv, ov) {
    	if ( nv == ov ) return;
    	if ( $scope.dataset.params.partition == null ) {
    		$scope.dataset.params.partition = '';
    	}
    });

    $scope.test = function () {
        $scope.testResult = null;
        $scope.testing = true;
        $scope.testable = true;

        DataikuAPI.datasets.jobsdb.test($stateParams.projectKey, $scope.dataset).success(function (data) {
            Logger.info('Got test result');
            $scope.testing = false;
            $scope.testResult = data;
            if ($scope.testResult.querySchema) {
                $scope.dataset.schema = $scope.testResult.querySchema;
            }
            if (!$scope.dataset.name && !$scope.new_dataset_name_manually_edited) {
                $scope.new_dataset_name = $scope.testResult.suggestedName;
            }
            if ( data.knownPartitions ) {
            	$scope.testResult.knownPartitionsAndEmpty = [{name:"Any", value:""}];
            	data.knownPartitions.forEach(function(p) {$scope.testResult.knownPartitionsAndEmpty.push({name:p, value:p})});
            } else {
            	$scope.testResult.knownPartitionsAndEmpty = null;
            }
            if ( data.knownIds ) {
            	$scope.testResult.knownIdsAndEmpty = [{name:"Any", value:""}];
            	data.knownIds.forEach(function(p) {$scope.testResult.knownIdsAndEmpty.push({name:p, value:p})});
            } else {
            	$scope.testResult.knownIdsAndEmpty = null;
            }
        }).error(function (a, b, c) {
            $scope.testing = false;
            setErrorInScope.bind($scope)(a,b,c);
        });
    };
});


app.controller("StatsDBDatasetController", function($scope, $stateParams, $controller, LoggerProvider, DataikuAPI, Debounce) {
    $controller("BaseRowDatasetController", {$scope: $scope, withConsistency: true});

    var Logger = LoggerProvider.getLogger('datasets.statsdb');

    $scope.viewTypes = [
        {name:'CLUSTER_TASKS', displayName:'Cluster tasks'},
        {name:'COMMITS', displayName:'Commits (internal Git)'},
        {name:'JOBS', displayName:'Jobs'},
        {name:'SCENARIO_RUNS', displayName:'Scenario runs'},
        {name:'FLOW_ACTIONS', displayName:'Object states'}
    ]

    $scope.onLoadComplete = function () {
        if ($scope.dataset.params && !$scope.dataset.params.view){
            $scope.dataset.params.view = "CLUSTER_TASKS";
        }
    };

    $scope.test = function () {
        $scope.testResult = null;
        $scope.testing = true;
        $scope.testable = true;

        DataikuAPI.datasets.statsdb.test($stateParams.projectKey, $scope.dataset).success(function (data) {
            Logger.info('Got test result');
            $scope.testing = false;
            $scope.testResult = data;
            if ($scope.testResult.querySchema) {
                $scope.dataset.schema = $scope.testResult.querySchema;
            }
            if (!$scope.dataset.name && !$scope.new_dataset_name_manually_edited) {
                $scope.new_dataset_name = $scope.testResult.suggestedName;
            }
        }).error(function (a, b, c) {
            $scope.testing = false;
            setErrorInScope.bind($scope)(a,b,c);
        });
    };
});

}());
(function() {
'use strict';

var app = angular.module('dataiku.datasets');

app.controller('BuildDatasetController', function($scope, $state, $stateParams, DataikuAPI, PartitionSelection, JobDefinitionComputer) {
    $scope.computeMode = undefined;
    $scope.buildPartitions = {};

    $scope.isBuildingDataset = false;
    $scope.startJob = function() {
        var jd = JobDefinitionComputer.computeJobDefForSingleDataset($stateParams.projectKey, $scope.computeMode, $scope.dataset, $scope.buildPartitions);
        $scope.isBuildingDataset = true;
        DataikuAPI.flow.jobs.start(jd).success(function(data) {
            $scope.startedJob = data;
            // This is really a ugly hack ... It's used to dismiss the modal
            // when this controller is called from the
            // build-dataset-box.html template
            if ($scope.dismiss) $scope.dismiss();
            if ($scope.jobStartRedirects) {$state.go('projects.project.jobs.job', {projectKey : $stateParams.projectKey, jobId: data.id})}
            else {$scope.$emit("datasetBuildStarted");}
        }).error((data, status, headers) => {
            setErrorInScope.bind($scope)(data, status, headers)
            $scope.isBuildingDataset = false;
        });
    };

     $scope.startJobPreview = function() {
        var jd = JobDefinitionComputer.computeJobDefForSingleDataset($stateParams.projectKey, $scope.computeMode, $scope.dataset, $scope.buildPartitions);
        $scope.isBuildingDataset = true;
        DataikuAPI.flow.jobs.startPreview(jd).success(function(data) {
            $scope.startedJob = data;
            // This is really a ugly hack ... It's used to dismiss the modal
            // when this controller is called from the
            // build-dataset-box.html template
            if ($scope.dismiss) $scope.dismiss();
            $state.go('projects.project.jobs.job', {projectKey : $stateParams.projectKey, jobId: data.id});
        }).error(setErrorInScope.bind($scope)).then(function(){$scope.isBuildingDataset = false;});
    };
});


app.directive('buildModeSelector', function() {
    return {
        restrict:'AE',
        scope: {
            targetType: '=',
            buildMode: '='
        },
        templateUrl: '/templates/datasets/build-mode-selector.html',
        link: function($scope, element, attrs) {

            $scope.$watch('build.mode', function(nv, ov) {
                $scope.buildMode = $scope.build.mode;
            });
            $scope.build = {
                mode: "NON_RECURSIVE_FORCED_BUILD"
            };

            $scope.descriptionDisplayed = { mode : "NON_RECURSIVE_FORCED_BUILD"};

            $scope.chooseNonRecursive = function(){
                $scope.build.mode = "NON_RECURSIVE_FORCED_BUILD";
                $scope.descriptionDisplayed.mode = "NON_RECURSIVE_FORCED_BUILD";
            }
            $scope.chooseRecursive = function(){
                $scope.build.mode = "RECURSIVE_BUILD";
                $scope.descriptionDisplayed.mode = "RECURSIVE_BUILD";
            }

            $scope.buildModes = [
                ["NON_RECURSIVE_FORCED_BUILD", "only this " + $scope.targetType, "DSS will just build this " + $scope.targetType + " even if some required datasets are missing or outdated. This can cause invalid or odd results.", "/static/dataiku/images/BUILD-Only-this-dataset.png"],
                ["RECURSIVE_BUILD", "Smart reconstruction", "Automatically builds datasets that are out-of-date (and their successors). Datasets are out-of-date if their predecessors have changed, or if the recipe building them has changed", "/static/dataiku/images/BUILD-From-outdated-dataset.png"],
                ["RECURSIVE_FORCED_BUILD", "Forced recursive rebuild", "Rebuilds all datasets leading to the selected one, recursively.", "/static/dataiku/images/BUILD-Force-all-upstream.png"],
                ["RECURSIVE_MISSING_ONLY_BUILD", "'Missing' data only", "Only builds datasets (or partitions) that are required but completely missing. Datasets (or partitions) that are present but out-of-date are not rebuilt.", "/static/dataiku/images/BUILD-From-missing-dataset.png"]
            ];

            $scope.recursiveBuildModes = [$scope.buildModes[1], $scope.buildModes[2], $scope.buildModes[3]];
        }
    }
});

app.directive('partitionSelector', function(PartitionSelection) {
    return {
        restrict: 'AE',
        scope: {
            partitioning: '=',
            buildPartitions: '=',
            bemModifier: '=?'
        },
        templateUrl: '/templates/datasets/partition-selector.html',
        link: function ($scope, element, attrs) {
            $scope.$watch('partitioning.dimensions', function(nv, ov){
                $scope.buildPartitions = PartitionSelection.getBuildPartitions($scope.partitioning);
            },true);

            $scope.$watch("buildPartitions", function(nv, ov) {
                if (nv !== ov) {
                    PartitionSelection.saveBuildPartitions($scope.partitioning, $scope.buildPartitions);
                }
            }, true);
        }
    }
});

//Expects in scope: odbId
app.controller('BuildManagedFolderController', function($scope, Assert, DataikuAPI, $state, $stateParams, PartitionSelection, JobDefinitionComputer) {

    $scope.computeMode = undefined;
    $scope.buildPartitions = {};

    $scope.$watch('odbId', function() {
        if (!$scope.odbId) return;
        DataikuAPI.managedfolder.get($stateParams.projectKey, $stateParams.projectKey, $scope.odbId).success(function(data) {
            $scope.odb = data;
        }).error(setErrorInScope.bind($scope));
    });

    $scope.isBuildingDataset = false;
    $scope.startJob = function() {
        Assert.inScope($scope, 'odbId');
        $scope.isBuildingDataset = true;
        DataikuAPI.flow.jobs.start(JobDefinitionComputer.computeJobDefForBox($stateParams.projectKey, $scope.computeMode, $scope.odb, $scope.buildPartitions)).success(function(data) {
            $scope.startedJob = data;
            // This is really a ugly hack ... It's used to dismiss the modal
            // when this controller is called from the
            // build-dataset-box.html template
            if ($scope.dismiss) $scope.dismiss();
        }).error(setErrorInScope.bind($scope)).then(function(){$scope.isBuildingDataset = false;});
    };

     $scope.startJobPreview = function() {
        $scope.isBuildingDataset = true;
        DataikuAPI.flow.jobs.startPreview(JobDefinitionComputer.computeJobDefForBox($stateParams.projectKey, $scope.computeMode, $scope.odb, $scope.buildPartitions)).success(function(data) {
            $scope.startedJob = data;
            // This is really a ugly hack ... It's used to dismiss the modal
            // when this controller is called from the
            // build-dataset-box.html template
            if ($scope.dismiss) $scope.dismiss();
            $state.go('projects.project.jobs.job', {projectKey : $stateParams.projectKey, jobId: data.id});
        }).error(setErrorInScope.bind($scope)).then(function(){$scope.isBuildingDataset = false;});
    };
})

//Expects in scope: mesId
app.controller('BuildModelEvaluationStoreController', function($scope, Assert, DataikuAPI, $state, $stateParams, PartitionSelection, JobDefinitionComputer) {

    $scope.computeMode = undefined;
    $scope.buildPartitions = {};

    $scope.$watch('mesId', function() {
        if (!$scope.mesId) return;
        DataikuAPI.modelevaluationstores.get($stateParams.projectKey, $scope.mesId).success(function(data) {
            $scope.mes = data;
        }).error(setErrorInScope.bind($scope));
    });

    $scope.isBuildingDataset = false;
    $scope.startJob = function() {
        Assert.inScope($scope, 'mesId');
        $scope.isBuildingDataset = true;
        DataikuAPI.flow.jobs.start(JobDefinitionComputer.computeJobDefForModelEvaluationStore($stateParams.projectKey, $scope.computeMode, $scope.mes, $scope.buildPartitions)).success(function(data) {
            $scope.startedJob = data;
            // This is really a ugly hack ... It's used to dismiss the modal
            // when this controller is called from the
            // build-dataset-box.html template
            if ($scope.dismiss) $scope.dismiss();
        }).error(setErrorInScope.bind($scope)).then(function(){$scope.isBuildingDataset = false;});
    };

     $scope.startJobPreview = function() {
        $scope.isBuildingDataset = true;
        DataikuAPI.flow.jobs.startPreview(JobDefinitionComputer.computeJobDefForModelEvaluationStore($stateParams.projectKey, $scope.computeMode, $scope.mes, $scope.buildPartitions)).success(function(data) {
            $scope.startedJob = data;
            // This is really a ugly hack ... It's used to dismiss the modal
            // when this controller is called from the
            // build-dataset-box.html template
            if ($scope.dismiss) $scope.dismiss();
            $state.go('projects.project.jobs.job', {projectKey : $stateParams.projectKey, jobId: data.id});
        }).error(setErrorInScope.bind($scope)).then(function(){$scope.isBuildingDataset = false;});
    };
})


//Expects in scope: modelId
app.controller('BuildSavedModelController', function($scope, Assert, DataikuAPI, $state, $stateParams, PartitionSelection, JobDefinitionComputer) {

    $scope.computeMode = undefined;
    $scope.buildPartitions = {};

    $scope.$watch('modelId', function() {
        if (!$scope.modelId) return;
        DataikuAPI.savedmodels.get($stateParams.projectKey, $scope.modelId).success(function(data) {
            $scope.model = data;
        }).error(setErrorInScope.bind($scope));
    });

    $scope.isBuildingDataset = false;
    $scope.startJob = function() {
        Assert.inScope($scope, 'modelId');
        $scope.isBuildingDataset = true;
        DataikuAPI.flow.jobs.start(JobDefinitionComputer.computeJobDefForSavedModel($stateParams.projectKey, $scope.computeMode, $scope.model, $scope.buildPartitions)).success(function(data) {
            $scope.startedJob = data;
            // This is really a ugly hack ... It's used to dismiss the modal
            // when this controller is called from the
            // build-dataset-box.html template
            if ($scope.dismiss) $scope.dismiss();
        }).error(setErrorInScope.bind($scope)).then(function(){$scope.isBuildingDataset = false;});
    };

     $scope.startJobPreview = function() {
        $scope.isBuildingDataset = true;
        DataikuAPI.flow.jobs.startPreview(JobDefinitionComputer.computeJobDefForSavedModel($stateParams.projectKey, $scope.computeMode, $scope.model, $scope.buildPartitions)).success(function(data) {
            $scope.startedJob = data;
            // This is really a ugly hack ... It's used to dismiss the modal
            // when this controller is called from the
            // build-dataset-box.html template
            if ($scope.dismiss) $scope.dismiss();
            $state.go('projects.project.jobs.job', {projectKey : $stateParams.projectKey, jobId: data.id});
        }).error(setErrorInScope.bind($scope)).then(function(){$scope.isBuildingDataset = false;});
    };
})

//Expects in scope: streamingEndpointId
app.controller('BuildStreamingEndpointController', function($scope, DataikuAPI, $state, $stateParams, JobDefinitionComputer, Assert) {

    $scope.compute = { mode : "NON_RECURSIVE_FORCED_BUILD"};
    $scope.build_partitions = {};

    // $scope.$watch('streamingEndpointId', function() {
    //     if (!$scope.odbId) return;
    //     DataikuAPI.streamingEndpoints.get($stateParams.projectKey, $scope.streamingEndpointId).success(function(data) {
    //         $scope.streamingEndpoint = data;
    //     }).error(setErrorInScope.bind($scope));
    // });

    $scope.buildModes = [
        ["NON_RECURSIVE_FORCED_BUILD", "Build only this streaming endpoint"],
        ["RECURSIVE_BUILD", "Build required datasets and this streaming endpoint"],
        ["RECURSIVE_FORCED_BUILD", "Force-rebuild all dependencies and build the streaming endpoint"],
        ["RECURSIVE_MISSING_ONLY_BUILD", "Build missing dependencies and build the streaming endpoint"]
    ];

    $scope.isBuildingDataset = false;
    $scope.startJob = function() {
        Assert.inScope($scope, 'streamingEndpointId');
        $scope.isBuildingDataset = true;
        DataikuAPI.flow.jobs.start(JobDefinitionComputer.computeJobDefForStreamingEndpoint($stateParams.projectKey, $scope.compute.mode, {id:$scope.streamingEndpointId})).success(function(data) {
            $scope.startedJob = data;
            // This is really a ugly hack ... It's used to dismiss the modal
            // when this controller is called from the
            // build-dataset-box.html template
            if ($scope.dismiss) $scope.dismiss();
        }).error(setErrorInScope.bind($scope)).then(function(){$scope.isBuildingDataset = false;});
    };

     $scope.startJobPreview = function() {
        $scope.isBuildingDataset = true;
        DataikuAPI.flow.jobs.startPreview(JobDefinitionComputer.computeJobDefForStreamingEndpoint($stateParams.projectKey, $scope.compute.mode, {id:$scope.streamingEndpointId})).success(function(data) {
            $scope.startedJob = data;
            // This is really a ugly hack ... It's used to dismiss the modal
            // when this controller is called from the
            // build-dataset-box.html template
            if ($scope.dismiss) $scope.dismiss();
            $state.go('projects.project.jobs.job', {projectKey : $stateParams.projectKey, jobId: data.id});
        }).error(setErrorInScope.bind($scope)).then(function(){$scope.isBuildingDataset = false;});
    };
})

app.controller('BuildDownstreamController', function ($scope, PartitionSelection, JobDefinitionComputer, DataikuAPI, $stateParams, $state, $filter){
    $scope.initModal = function(computables, startingPoint) {
        $scope.startingPoint = startingPoint;
        $scope.computables = computables;
    };

    $scope.buildModes = [
            ["RECURSIVE_BUILD", "Build required dependencies"],
            ["RECURSIVE_FORCED_BUILD", "Force-rebuild all dependencies"],
            ["RECURSIVE_MISSING_ONLY_BUILD", "Build missing dependencies"]
    ];
    $scope.buildMode = "RECURSIVE_BUILD";

    $scope.removeRestore = function(index, isRemove) {
        $scope.computables[index].removed = isRemove;
        $scope.validateForm();
    };

    $scope.isAllDataset = function() {
        return $scope.computables.filter(function(c) {return c.type == 'DATASET';}).length == $scope.computables.length;
    };

    $scope.validateForm = function () {
        $scope.theform.$invalid = $scope.computables.find(i => !i.removed) == undefined;
    };

    function getJobDef() {
        var outputs = $scope.computables.filter(d => !d.removed).map(function(d) {
            if (d.type === 'DATASET') {
                return JobDefinitionComputer.computeOutputForDataset(d.serializedDataset, d.buildPartitions);
            } else if (d.type === 'MANAGED_FOLDER') {
                return JobDefinitionComputer.computeOutputForBox(d.box, d.buildPartitions);
            } else if (d.type === 'SAVED_MODEL') {
                return JobDefinitionComputer.computeOutputForSavedModel(d.model, d.buildPartitions);
            } else {
                return { "targetDataset": d.id, "targetDatasetProjectKey": d.projectKey, "type": d.type };
            }
        });

        return {
            "type": $scope.buildMode,
            "refreshHiveMetastore":true,
            "projectKey": $stateParams.projectKey,
            "outputs": outputs
        };
    }

    $scope.isBuildingDataset = false;
    $scope.startJob = function() {
        $scope.isBuildingDataset = true;
        DataikuAPI.flow.jobs.start(getJobDef()).success(function(startedJob) {
            $scope.$emit("datasetBuildStarted");
            $scope.dismiss();
        }).error(setErrorInScope.bind($scope)).then(function(){$scope.isBuildingDataset = false;});
    };

    $scope.startJobPreview = function() {
        $scope.isBuildingDataset = true;
        DataikuAPI.flow.jobs.startPreview(getJobDef()).success(function(startedJob) {
            $state.go('projects.project.jobs.job', {projectKey : $stateParams.projectKey, jobId: startedJob.id});
            $scope.dismiss();
        }).error(setErrorInScope.bind($scope)).then(function(){$scope.isBuildingDataset = false;});
    };

    $scope.getIcon = function(computable) {
        switch(computable.type) {
            case 'DATASET':            return 'dataset ' + $filter('datasetTypeToIcon')(computable.serializedDataset.type);
            case 'MANAGED_FOLDER':     return 'icon-folder-open';
            case 'SAVED_MODEL':        return 'icon-machine_learning_regression';
        }
    };

    $scope.getPartitioning = function(computable) {
        if (computable.type === 'DATASET') {
            return computable.serializedDataset.partitioning;
        }
        if (computable.type === 'MANAGED_FOLDER') {
            return computable.box.partitioning;
        }
        if (computable.type === 'SAVED_MODEL') {
            return computable.model.partitioning;
        }
    };
});


app.controller('XmlFormatController', function ($scope, DataikuAPI, $state, $stateParams) {
	// record the last field visited that is used to input XPath. The fields
	// have a directive to send a setter on their model to xpathFieldGotFocus().
	// by default, the focus is on the root path element field
	$scope.lastFocusedXpathFieldSetter = function (value) {$scope.dataset.formatParams.rootPath = value;};

	$scope.xpathFieldGotFocus = function (fieldSetter) {
		$scope.lastFocusedXpathFieldSetter = fieldSetter;
	};
});


}());

(function() {
'use strict';

var app = angular.module('dataiku.datasets.status', []);

app.controller("DatasetStatusController", function($scope, DataikuAPI, $stateParams, TopNav, Dialogs, $state, $rootScope, $timeout, CreateModalFromTemplate) {
    TopNav.setLocation(TopNav.TOP_FLOW, "datasets", TopNav.TABS_DATASET, "status");

});

})();
(function () {
    'use strict';

    var app = angular.module('dataiku.controllers');

    app.controller("DatasetsCommon", function ($scope, $stateParams, DataikuAPI, $state, $q, DatasetsService, CreateModalFromTemplate) {

        $scope.createAndPin = function(datasetName) {
            var insight = {
                projectKey: $stateParams.projectKey,
                type: 'dataset_table',
                params: { datasetSmartName: datasetName },
                name: datasetName
            };
            CreateModalFromTemplate("/templates/dashboards/insights/create-and-pin-insight-modal.html", $scope, "CreateAndPinInsightModalController", function(newScope) {
                newScope.init(insight);
            });
        };

        $scope.clearDataset = function(datasetName) {
            DatasetsService.clear($scope, $stateParams.projectKey, datasetName).then(function() {
                $scope.$broadcast('refresh-table');
            });
        };
    });


    app.controller('DatasetsListController', function($scope, $controller, $stateParams, $state, $q,
                          DatasetsService, DataikuAPI, CreateModalFromTemplate, TopNav, ComputablesService, Fn) {

        $controller("DatasetsCommon", {$scope: $scope});
        $controller('_TaggableObjectsListPageCommon', {$scope: $scope});

        TopNav.setLocation(TopNav.TOP_FLOW, "datasets", TopNav.TABS_NONE, null);
        TopNav.setNoItem();

        $scope.showClearData = true;
        $scope.selection = $.extend({
            filterQuery: {
                userQuery: '',
                tags: [],
                interest: {
                    starred: '',
                },
            },
            filterParams: {
                userQueryTargets: ["name","type","tags"],
                propertyRules: {"tag": "tags"}
            },
            orderQuery: "-lastModifiedOn",
            orderReversed: false,
        }, $scope.selection || {});

        $scope.sortBy = [
            { value: 'name', label: 'Name' },
            { value: 'type', label: 'Type' },
            { value: 'status.totalSize', label: 'Size' },
            { value: 'status.records', label: 'Records'},
            { value : '-lastModifiedOn', label : 'Last modified' }
        ];

        $scope.sortCookieKey = 'datasets';
        $scope.maxItems = 20;

        $scope.goToItem = function(item) {
            $scope.$state.go('projects.project.datasets.dataset.explore', {datasetName: item.name, projectKey: $stateParams.projectKey});
        };

        $scope.list = function() {
            return DataikuAPI.datasets.listHeads($stateParams.projectKey, {}, true).success(function (data) {
                $scope.datasets = data;
                $scope.filteredOut = data.filteredOut;
                $scope.listItems = data.items;
                $scope.restoreOriginalSelection();
            }).error(setErrorInScope.bind($scope));
        };

        $scope.$on('projectTagsUpdated', function (e, args) {
             if (args.refreshFlowFilters) $scope.list();
        });
        $scope.list();
    });


    app.controller("NewManagedDatasetController", function ($scope, $state, $stateParams, DataikuAPI, WT1) {
        WT1.event("dataset-new-managed-box");
        addDatasetUniquenessCheck($scope, DataikuAPI, $stateParams.projectKey);

        $scope.newDataset ={
            name : null,
            settings : {
                specificSettings : {},
                zone: $scope.getRelevantZoneId($stateParams.zoneId)
            }
        };

        DataikuAPI.datasets.getManagedDatasetOptionsNoContext($stateParams.projectKey).success(function(data) {
            $scope.managedDatasetOptions = data;
            if (!$scope.newDataset.settings.connection && data.connections.length) {
                $scope.newDataset.settings.connection = data.connections[0];
            }
            $scope.partitioningOptions = [
                {"id" : "NP", "label" : "Not partitioned"},
            ].concat(data.projectPartitionings)

            $scope.newDataset.settings.partitioningOptionId = "NP";
        });

        $scope.$watch("newDataset.settings.connection", function(nv, ov) {
            if (nv && nv.formats && nv.formats.length) {
                $scope.newDataset.settings.specificSettings.formatOptionId = nv.formats[0].id;
            }
            if (nv && nv.fsProviderTypes && nv.fsProviderTypes.length >= 1) {
                $scope.newDataset.settings.typeOptionId = nv.fsProviderTypes[0];
            }
        }, true);

        $scope.create = function () {
            resetErrorInScope($scope);
            $scope.newDataset.settings.connectionId = $scope.newDataset.settings.connection.id;
            DataikuAPI.datasets.newManagedDataset($stateParams.projectKey, $scope.newDataset.name, $scope.newDataset.settings).success(function (data) {
                $state.go('projects.project.datasets.dataset.settings', { datasetName: $scope.newDataset.name });
                $scope.dismiss();
            }).error(setErrorInScope.bind($scope));
        };
    });


    app.controller("DatasetCommonController", function ($controller, $scope, $stateParams, $rootScope, DataikuAPI, TopNav, $state, DatasetsService, CreateModalFromTemplate, DatasetCustomFieldsService) {
        $controller("DatasetsCommon", {$scope: $scope});
        TopNav.setItem(TopNav.ITEM_DATASET, $stateParams.datasetName);

        $scope.datasetHooks = {};

        /* Check if this dataset has preview custom fields */
        function getCurrentDatasetFullInfo() {
            return DataikuAPI.datasets.getFullInfo($stateParams.projectKey, $stateParams.projectKey, $stateParams.datasetName).success(function(data) {
                $scope.datasetFullInfo = data;

                if ($scope.datasetFullInfo.type == "Inline") {
                    $scope.editableDataset = true;
                }

                TopNav.setItem(TopNav.ITEM_DATASET, $stateParams.datasetName, {
                    datasetType : data.type,
                    name : $stateParams.datasetName,
                    creatingRecipe: data.creatingRecipe,
                    creatingContinuousRecipe: data.creatingContinuousRecipe,
                    usedByRecipes: data.recipes,
                    customFields: data.dataset.customFields,
                    customFieldsPreview: DatasetCustomFieldsService.buildCustomFieldsPreviews(data.dataset.customFields)
                });

            }).error(setErrorInScope.bind($scope));
        }
        getCurrentDatasetFullInfo();

        $rootScope.$on('customFieldsSaved', function(event, item, customFields) {
            if (TopNav.sameItem(item, TopNav.getItem())) {
                let newItem = TopNav.getItem();
                newItem.data.customFields = customFields;
                newItem.data.customFieldsPreview = DatasetCustomFieldsService.buildCustomFieldsPreviews(customFields);
            }
        });

        $scope.newAnalysis = function() {
            GlobalProjectActions.smartNewAnalysis($scope, $stateParams.datasetName);
        };

        $scope.buildOpenDataset = function() {
            DataikuAPI.datasets.get($stateParams.projectKey, $stateParams.datasetName, $stateParams.projectKey).success(function(dataset) {
                CreateModalFromTemplate("/templates/datasets/build-dataset-modal.html", $scope, "BuildDatasetController", function(newScope) {
                    newScope.jobStartRedirects = true;
                    newScope.dataset = dataset;
                }, "build-dataset-modal");
            }).error(setErrorInScope.bind($scope));
        };

        Mousetrap.bind("g e", function() {
            $state.go("projects.project.datasets.dataset.explore", {
                projectKey : $stateParams.projectKey,
                datasetName : $stateParams.datasetName
            });
        });
        Mousetrap.bind("g v", function() {
            $state.go("projects.project.datasets.dataset.visualize", {
                projectKey : $stateParams.projectKey,
                datasetName : $stateParams.datasetName
            });
        });

        $scope.$on("$destroy", function() {
            Mousetrap.unbind("g e");
            Mousetrap.unbind("g v");
        });
    });

    app.controller("DatasetNewController", function ($scope, $stateParams, DataikuAPI) {
    });

    app.controller("DatasetSummaryController", function ($scope, $stateParams, Assert, DataikuAPI, TopNav, ActivityIndicator, $q, CreateModalFromTemplate, $state, HistoryService, DatasetCustomFieldsService) {
        $scope.datasetName = $stateParams.datasetName;
        $scope.uiState = {};
        Assert.trueish($stateParams.datasetName, 'no datasetName in stateParams');

        TopNav.setLocation(TopNav.TOP_FLOW, "datasets", TopNav.TABS_DATASET, "summary");

        $scope.refreshTimeline = function() {
            DataikuAPI.timelines.getForObject($stateParams.projectKey, "DATASET", $stateParams.datasetName).success(function(data) {
                $scope.objectTimeline = data;
            }).error(setErrorInScope.bind($scope));
        };

        DataikuAPI.datasets.getSummary($stateParams.projectKey, $stateParams.datasetName).success(function(data) {
            $scope.dataset = data.object;
            $scope.objectInterest = data.interest;
            $scope.objectTimeline = data.timeline;
        }).error(setErrorInScope.bind($scope));

        /* Auto save when summary is modified */
        $scope.$on("objectSummaryEdited", function(){
            DataikuAPI.datasets.save($stateParams.projectKey, $scope.dataset, {summaryOnly:true}).success(function(data) {
                ActivityIndicator.success("Saved");
                $scope.refreshTimeline();
            }).error(setErrorInScope.bind($scope));
        });

        $scope.$on('customFieldsSummaryEdited', function(event, customFields) {
            DatasetCustomFieldsService.saveCustomFields($scope.dataset, customFields);
        });
    });


    app.controller("DatasetSettingsController", function ($scope, $rootScope, $state, $stateParams, $q, $timeout, $controller,
                                                          Assert, TopNav, CachedAPICalls, Dialogs, DataikuAPI, CreateModalFromTemplate, WT1, ActivityIndicator, DatasetUtils, DKUtils, LoggerProvider,
                                                          HistoryService) {
        var Logger = LoggerProvider.getLogger('datasets.settings');

        $scope.uiState = {
            activeTab : "connection"
        };

        $scope.anyPipelineTypeEnabled = function() {
            return $rootScope.projectSummary.sparkPipelinesEnabled || $rootScope.projectSummary.sqlPipelinesEnabled;
        };

        if ($stateParams.datasetName) {
            TopNav.setLocation(TopNav.TOP_FLOW, "datasets", TopNav.TABS_DATASET, "settings");
        } else {
            TopNav.setLocation(TopNav.TOP_FLOW, "datasets", TopNav.TABS_NEW_DATASET, "settings");
            TopNav.setItem(TopNav.ITEM_DATASET, "New dataset", { name: "New dataset", dummy: true,
                newDatasetType : $stateParams.type});
        }

        // Dataset Type specific controllers may set conditions
        // values for the form to be valid.
        // Conditions take a string as key.
        // The form is valid when all the predicates evaluate to true.
        $scope.saveHooks = [];
        $scope.canBeSaved = function() {
            for(var i = 0 ; i < $scope.saveHooks.length ; i++) {
                if(!$scope.saveHooks[i]()) {
                    return false;
                }
            }
            return true;
        };

        $scope.table = null;
        $scope.charsets = null;
        $scope.types = null;
        $scope.formats = null;
        $scope.loading = true;
        $scope.detectionResults = null;
        $scope.dataset_name = '';
        $scope.redetectFormatOnCoreParamsChanged = false;
        $scope.datasetShortStatus = null;

        /* ************************* Core loading and saving
         */
        var promises = [];
        promises.push(CachedAPICalls.datasetTypes);
        promises.push(CachedAPICalls.datasetCommonCharsets);
        promises.push(CachedAPICalls.datasetFormatTypes);
        promises.push(null);

        if ($stateParams.datasetName) {
            $scope.datasetName = $stateParams.datasetName;
            document.dispatchEvent(new CustomEvent("PushAllDatasetPromises"));
            promises.push(DataikuAPI.datasets.get($stateParams.projectKey, $stateParams.datasetName, $stateParams.projectKey));
        } else {
            $scope.dataset = {
                'name': null,
                'projectKey': $stateParams.projectKey,
                'params': {},
                'partitioning': {dimensions:[]},
                'tags':[],
                'schema': {}
            };
            Assert.trueish($stateParams.type, 'no type in stateParams');
            $scope.dataset.type = $stateParams.type;
            // FIXME
            $scope.datasetShortStatus = {};
        }

        $q.all(promises).then(function (values) {
            document.dispatchEvent(new CustomEvent("GotAllDatasetPromises"));
            Logger.info("All promises done, loading UI", values[4]);
            $scope.types = values[0].data;
            $scope.charsets = values[1].data;
            $scope.formats = values[2].data;

            $scope.formatsAsMap = angular.copy($scope.formats);
            for (var fmtIdx in $scope.formatsAsMap) {
                var fmt = $scope.formatsAsMap[fmtIdx];
                var o = {};
                for (var paramIdx in fmt.params) {
                    o[fmt.params[paramIdx].name] = fmt.params[paramIdx];
                }
                $scope.formatsAsMap[fmtIdx] = o;
            }
            if ($stateParams.datasetName) {
                $scope.dataset = values[4].data;
                $scope.dataset_name = $scope.dataset.name;
                $scope.origDataset = angular.copy($scope.dataset);
            } else {
                $scope.origDataset = angular.copy($scope.dataset);
                $scope.firstPreviewDone = true;
                /* No dataset yet -> Always redetect on core params changed */
                $scope.redetectFormatOnCoreParamsChanged = true;
            }

            $scope.datasetKindForConsistency = DatasetUtils.getKindForConsistency($scope.dataset);

            var datasetType = $scope.types[$scope.dataset.type];
            var ctrl = null;
            /* Load the correct additional functions */

            if (datasetType.customDataset) {
                $scope.interactionType = "custom-dataset";
                ctrl = "CustomDatasetController";
            } else if ($scope.dataset.type == "Inline" && $stateParams.datasetName) {
                $scope.interactionType = "editable";
                ctrl = "EditableDatasetController";
            } else if ($scope.dataset.type == "Inline") {
                $scope.interactionType = "managed_fslike";
                ctrl = "EditableDatasetController";
            } else if ($stateParams.datasetName && $scope.types[$scope.dataset.type].sql && $scope.dataset.managed) {
                $scope.interactionType = 'managed_sql';
                ctrl = "ManagedSQLDatasetController";
            } else if ($scope.dataset.type == "MongoDB") {
                $scope.interactionType = "mongodb";
                ctrl = "MongoDBDatasetController";
            } else if ($stateParams.datasetName && $scope.dataset.type == "Cassandra" && $scope.dataset.managed) {
                $scope.interactionType = "managed_cassandra";
                ctrl = "ManagedCassandraDatasetController";
            } else if($scope.dataset.type == "Twitter") {
                $scope.interactionType = 'twitter_stream';
                ctrl = "TwitterStreamDatasetController";
            } else if($scope.dataset.type == "ElasticSearch") {
                $scope.interactionType = 'elasticsearch';
                ctrl = "ElasticSearchDatasetController";
            } else if($scope.dataset.type == "DynamoDB") {
                $scope.interactionType = 'dynamodb';
                ctrl = "DynamoDBDatasetController";
            } else if ($scope.dataset.type == "JobsDB") { // here, otherwise interactionType ends up being managed_fslike
                $scope.interactionType = 'jobsdb';
                ctrl = "MetricsDatasetController";
            } else if ($scope.dataset.type == "StatsDB") { // here, otherwise interactionType ends up being managed_fslike
                $scope.interactionType = 'statsdb';
                ctrl = "StatsDBDatasetController";
            } else if ($stateParams.datasetName && $scope.dataset.managed) {
                $scope.interactionType = 'managed_fslike';
                ctrl = "ManagedFSLikeDatasetController";
            } else if ($scope.dataset.type == "hiveserver2") { // almost sql, but special handling of connections
                $scope.interactionType = 'external_hive';
                ctrl = "ExternalHiveDatasetController";
            } else if ($scope.types[$scope.dataset.type].sql) {
                $scope.interactionType = 'external_sql';
                ctrl = "ExternalSQLDatasetController";
            } else if ($scope.dataset.type == "Cassandra") {
                $scope.interactionType = "external_cassandra";
                ctrl = "ExternalCassandraDatasetController";
            } else {
                $scope.interactionType = 'external_other';
                ctrl =  "ExternalStreamOrientedDatasetController";
            }

            $controller(ctrl, {$scope:$scope});
            $scope.onLoadComplete();
            $scope.loading = false;
            $scope.loadDone = true;
            getDigestTime($scope, function(time) {
                WT1.event("page-dataset-loaded", {digestTime : time, isNew : !$scope.dataset.name});
            });
        }, function (errors) {
            setErrorInScope.bind($scope)(errors.data, errors.status, errors.headers);
        });

        //TODO @flow factorize
        $scope.resynchronizeMetastore = function() {
            Dialogs.confirmPositive($scope,
                'Hive metastore resynchronization',
                'Are you sure you want to resynchronize this dataset to the Hive metastore?')
                .then(function() {
                    ActivityIndicator.waiting('Synchronizing to Hive metastore...');
                    const datasetRef = {
                        type: 'DATASET',
                        projectKey: $stateParams.projectKey,
                        id: $scope.dataset.name
                    };
                    DataikuAPI.datasets.synchronizeOneHiveMetastore(datasetRef, $scope.dataset.params).success(function(data) {
                        if (data.anyMessage && (data.warning || data.error)) {
                            ActivityIndicator.hide();
                            Dialogs.infoMessagesDisplayOnly($scope, "Metastore synchronization", data);
                        } else {
                            // nothing to show
                            ActivityIndicator.success('Hive metastore successfully synchronized');
                        }
                    }).error(function(data, status, headers) {
                        ActivityIndicator.error("Failed to synchronize Hive metastore");
                        setErrorInScope.call($scope,data,status,headers);
                    });
                });
        };

        //TODO @flow factorize
        $scope.resynchronizeDataset = function() {
            ActivityIndicator.waiting('Synchronizing from Hive metastore...');
            WT1.event("update-from-hive");
            DataikuAPI.datasets.updateFromHive($stateParams.projectKey, $scope.dataset.name).success(function(data,status,headers){
                ActivityIndicator.success('Dataset successfully synchronized');
                DataikuAPI.datasets.get($stateParams.projectKey, $stateParams.datasetName, $stateParams.projectKey).success(function(data) {
                    $scope.dataset = data;
                    $scope.dataset_name = $scope.dataset.name;
                    $scope.origDataset = angular.copy($scope.dataset);
                }).error(setErrorInScope.bind($scope));
            }).error(function(data, status, headers) {
                ActivityIndicator.error("Failed to synchronize Hive metastore");
                setErrorInScope.call($scope,data,status,headers);
            });
        };

        $scope.saveDataset = function() {
            if (!$stateParams.datasetName) {
                /* Creation */
                $scope.dataset.name = $scope.new_dataset_name;
                $scope.origDataset = null;
                return DataikuAPI.datasets.create($stateParams.projectKey, $scope.dataset, $stateParams.zoneId).success(function() {
                    $rootScope.$broadcast(dkuEvents.datasetChanged);
                    $state.transitionTo("projects.project.datasets.dataset.explore", {projectKey : $stateParams.projectKey,
                        datasetName : $scope.new_dataset_name});
                }).error(setErrorInScope.bind($scope));

            } else {
                Assert.trueish($scope.dataset.name, 'dataset has no name');

                var saveAfterConflictCheck = function() {
                    return DataikuAPI.datasets.saveWithRecipesFixup($stateParams.projectKey, $scope.dataset, {}, false)
                        .error(setErrorInScope.bind($scope))
                        .then(function(saveResp) {
                            if (saveResp.data.result) {
                                return saveResp.data.result.versionTag;
                            } else {
                                return Dialogs.confirmInfoMessages($scope,
                                    "Dependencies", saveResp.data.messages).then(function(){
                                    return DataikuAPI.datasets.saveWithRecipesFixup($stateParams.projectKey, $scope.dataset, {}, true)
                                        .error(setErrorInScope.bind($scope))
                                        .then(function(forcedSaveResp) {
                                            Assert.trueish(forcedSaveResp.data.result, 'response has no results');
                                            return forcedSaveResp.data.result.versionTag;
                                        });
                                });
                            }
                        }).then(function(newVersionTag) {
                        $rootScope.$broadcast(dkuEvents.datasetChanged);
                        // Reset the modification detector
                        $scope.origDataset = angular.copy($scope.dataset);
                        $scope.dataset.versionTag = newVersionTag;
                        $scope.origDataset.versionTag = newVersionTag;
                    });
                };

                return DataikuAPI.datasets.checkSaveConflict($stateParams.projectKey,$scope.dataset).success(function(conflictResult) {

                    if(!conflictResult.canBeSaved) {
                        return Dialogs.openConflictDialog($scope,conflictResult).then(
                            function(resolutionMethod) {
                                if(resolutionMethod == 'erase') {
                                    return saveAfterConflictCheck();
                                } else if(resolutionMethod == 'ignore') {
                                    return DKUtils.reloadState();
                                }
                            }
                        );
                    } else {
                        return saveAfterConflictCheck();
                    }

                }).error(setErrorInScope.bind($scope));
            }
        };

        $scope.goToPreview = function() {
            $scope.uiState.activeTab = "preview";
            $scope.$broadcast('tabSelect', 'preview');
        };

        $scope.buildDataset = function() {
            CreateModalFromTemplate("/templates/datasets/build-dataset-modal.html", $scope, "BuildDatasetController", null, "build-dataset-modal");
        };

        $scope.datasetIsDirty = function () {
            if (!$scope.dataset)
                return false;

            function cleanDimensionPatterns(input) {
                if (input == null) return null;
                var datasetToCheck = angular.copy(input);
                if (datasetToCheck && datasetToCheck.partitioning && datasetToCheck.partitioning.dimensions) {
                    for (var i = 0; i < datasetToCheck.partitioning.dimensions.length; i++) {
                        delete datasetToCheck.partitioning.dimensions[i].patterns;
                    }
                }
                return datasetToCheck;
            }

            function cleanSavedFiles(input) {
                if (input == null) return null;
                var datasetToCheck = angular.copy(input);
                delete datasetToCheck.savedFiles;
                return datasetToCheck;
            }

            var datasetToCheck = cleanSavedFiles(cleanDimensionPatterns($scope.dataset));
            var origDataset = cleanSavedFiles(cleanDimensionPatterns($scope.origDataset));

            return !angular.equals(datasetToCheck, origDataset) || $scope.dataset && $scope.dataset.name != $scope.dataset_name;
        };

        checkChangesBeforeLeaving($scope, function(){
            if ($scope.uiState.bypassDirtinessCheck) {
                return false;
            }

            var danger = false;
            /* Not yet loaded */
            if (!$scope.dataset) return;
            if ($scope.dataset.name) {
                /* Existing dataset */
                danger = $scope.origDataset && $scope.datasetIsDirty();
            } else {
                /* New dataset, don't do bogus renaming check */
                danger = $scope.origDataset && !angular.equals($scope.dataset, $scope.origDataset);
            }
            return danger;
        });

        $scope.smartWatch = function (expr, apply) {
            var stop;
            $scope.$watch(expr, function (nv, ov) {
                if (stop) {
                    $timeout.cancel(stop);
                }
                stop = $timeout(apply, 1000);
            }, true);
        };

        $scope.renameDataset = function(){
            WT1.event("dataset-rename-open-modal");
            CreateModalFromTemplate("/templates/datasets/rename-dataset-box.html", $scope, null, function(newScope){
                newScope.datasetName = $stateParams.datasetName;
                newScope.uiState = {
                    step : "input"
                }
                newScope.computeImpact = function(){
                    newScope.uiState.step = "do";
                    Assert.inScope(newScope, 'datasetName');
                    Assert.trueish(newScope.uiState.newName, 'dataset has no new name');
                    DataikuAPI.datasets.computeRenamingImpact($stateParams.projectKey, $stateParams.datasetName, newScope.uiState.newName).success(function(data) {
                        newScope.computedImpact = data;
                    }).error(setErrorInScope.bind(newScope));
                }

                newScope.go = function(){
                    WT1.event("dataset-rename", {"type" : $scope.dataset ? $scope.dataset.type : "?"});
                    DataikuAPI.datasets.rename($stateParams.projectKey, $stateParams.datasetName, newScope.uiState.newName).success(function() {
                        HistoryService.notifyRenamed({
                            type: "DATASET",
                            id: $stateParams.datasetName,
                            projectKey: $stateParams.projectKey
                        }, newScope.uiState.newName);
                        newScope.dismiss();
                        $state.transitionTo($state.current, { projectKey : $stateParams.projectKey, datasetName : newScope.uiState.newName });
                    }).error(setErrorInScope.bind(newScope));
                }
            });
        }
        Logger.info("Done loading dataset controller");
    });


    app.controller("DatasetHistoryController", function ($scope, TopNav) {
        TopNav.setLocation(TopNav.TOP_FLOW, "datasets", TopNav.TABS_DATASET, "history");
    });
    
    app.controller("DatasetStatisticsController", function ($scope, TopNav, $state) {
        $scope.$state = $state;
        TopNav.setLocation(TopNav.TOP_FLOW, "datasets", TopNav.TABS_DATASET, "statistics");
    });

    app.controller("DatasetLabController", function ($scope, $controller, $stateParams, $state, $timeout, Assert, DataikuAPI, DatasetUtils, GlobalProjectActions, Fn, $rootScope, StateUtils, CreateModalFromTemplate) {
        $controller('NotebooksCommons', { $scope: $scope });

        var excludedBackends = [];

        function fetchBackends(callback) {
            DataikuAPI.analysis.mlcommon.listBackends($stateParams.projectKey, $scope.datasetSmartName, '')
                .success(data => {
                    $scope.backends = data;
                    for(var i = 0; i < data.length; i++){
                        if (!data[i].available){
                            excludedBackends.push(data[i].type);
                        }
                    }
                    callback();
                }).error(setErrorInScope.bind($scope));
        }

        function generateAnalysisName(policy, targetVariable) {
            if (!policy) {
                return "Analyze " + $scope.datasetSmartName;
            }

            const withDataset = policy.analysis_name.replace("{dataset}", $scope.datasetSmartName);

            if (targetVariable) {
                return withDataset.replace("{target}", targetVariable);
            }
            return withDataset;
        };

        $scope.selectPolicy = function(taskData, policy, targetVariable) {
            taskData.selectedPolicy = policy;
            taskData.analysisName = generateAnalysisName(policy, targetVariable);
            $scope.updateBackend(taskData);
        };

        function selectDefaultPolicy(taskData, mode) {
            $scope.selectPolicy(taskData, taskData.guessPolicies[mode][0], taskData.targetVariable);
        }

        function prepareGuessPolicies(taskData) {
            taskData.guessPolicies.auto.forEach(updateGuessPolicyBackends);
            taskData.guessPolicies.expert.forEach(updateGuessPolicyBackends);
        };

        function updateGuessPolicyBackends(policy) {
            let policyBackends = [];
            let policyBackendsDescriptions = [];

            $scope.backends.forEach(backend => {
                policy.supported_backends.forEach(function (supportedBackend) {
                    if (supportedBackend === backend.type) {
                        let title = backend.displayName;
                        let description = backend.description;
                        if (backend.statusMessage) {
                            title += ' (Unavailable)';
                            description += '<br/><strong>' + backend.statusMessage + '</strong>';
                        }
                        backend.title = title;
                        policyBackends.push(backend);
                        policyBackendsDescriptions.push(description);
                    }
                });
            });

            policy.backends = policyBackends;
            policy.backendDomDescriptions = policyBackendsDescriptions;

            if (!policy.selectedBackend) {
                policy.selectedBackend = { displayName: angular.copy(policy.backends[0]).displayName };
            }
        };

        function displayNewPredictionModal(mode, resetColumn = true) {
            // Force user to re-set the target variable each time the modal is opened.
            // And pick the default policy depending on the prediction mode.
            if (resetColumn) {
                $scope.predictionTaskData.targetVariable = null;
            }
            selectDefaultPolicy($scope.predictionTaskData, mode);

            CreateModalFromTemplate('/templates/datasets/create-prediction-modal.html', $scope, null, (modalScope) => {
                modalScope.taskData = $scope.predictionTaskData;

                if (!$scope.predictionTaskData.targetVariable && $scope.appConfig.userProfile.mayVisualML) {
                    // Trigger click on target input to display the dropdown menu. 
                    // Wait a bit till the modal height is computed so that the dropdown could be properly displayed.
                    $timeout(() => {
                        document.querySelector('#create-prediction-modal .dku-select-button').click();
                    }, 400);
                }
            });
        }

        function prepareNewPredictionModal(column, mode) {  
            const loc = DatasetUtils.getLocFromSmart($stateParams.projectKey, $scope.datasetSmartName);
            const resetTargetVariable = !column;

            if (column) {
                $scope.predictionTaskData.targetVariable = column;
            }

            // Retrieve dataset columns
            DataikuAPI.datasets.get(loc.projectKey, loc.name, $stateParams.projectKey).success(data => {
                $scope.possibleColumns = data.schema.columns.map(it => it.name); 

                // Retrieve the prediction guess policies only if not already done.
                if ($scope.predictionTaskData.guessPolicies) {
                    displayNewPredictionModal(mode, resetTargetVariable);
                } else {
                    DataikuAPI.analysis.pml.listGuessPolicies().success(data => {
                        $scope.predictionTaskData.guessPolicies = data;
                        prepareGuessPolicies($scope.predictionTaskData);

                        $scope.$watch('predictionTaskData.targetVariable', (newValue) => { 
                            $scope.predictionTaskData.analysisName = generateAnalysisName($scope.predictionTaskData.selectedPolicy, newValue); 
                        });

                        displayNewPredictionModal(mode, resetTargetVariable);
                    }).error(setErrorInScope.bind($scope));
                }
            });
        }

        $scope.newPrediction = function(column, datasetSmartName, mode = 'auto') {

            $scope.datasetSmartName = datasetSmartName;

            // Retrieve the available backends only if not already done.
            if ($scope.backends) {
                prepareNewPredictionModal(column, mode);
            } else {
                fetchBackends(prepareNewPredictionModal.bind(this, column, mode));
            }
        };

        $scope.newDeepLearningPrediction = function(datasetSmartName) {
            $scope.newPrediction(undefined, datasetSmartName, 'expert');
        }

        function displayNewClusteringModal(mode) { 
            selectDefaultPolicy($scope.clusteringTaskData, mode);

            CreateModalFromTemplate('/templates/datasets/create-clustering-modal.html', $scope, null, modalScope => {
                modalScope.taskData = $scope.clusteringTaskData;
            });
        }

        function prepareNewClusteringModal(mode = 'auto') {
            // Retrieve the clustering guess policies only if not already done.
            if ($scope.clusteringTaskData.guessPolicies) {
                displayNewClusteringModal(mode);
            } else {
                DataikuAPI.analysis.cml.listGuessPolicies().success(data => {
                    $scope.clusteringTaskData.guessPolicies = data;
                    prepareGuessPolicies($scope.clusteringTaskData);
                    $scope.clusteringTaskData.analysisName = generateAnalysisName($scope.clusteringTaskData.selectedPolicy);
                    displayNewClusteringModal(mode);
                }).error(setErrorInScope.bind($scope));
            }
        }

        $scope.newClustering = function(datasetSmartName, mode) {
            $scope.datasetSmartName = datasetSmartName;

            // Retrieve the available backends only if not already done.
            if ($scope.backends) {
                prepareNewClusteringModal();
            } else {
                fetchBackends(prepareNewClusteringModal.bind(this, mode));
            }
        };

        $scope.newAnalysis = function(datasetSmartName) {
            CreateModalFromTemplate('/templates/analysis/new-analysis-modal.html', $scope, 'NewAnalysisModalController', (modalScope) => {
                modalScope.newAnalysis.datasetSmartName = datasetSmartName;
            });
        }
        
        $scope.predictionTaskData = {};
        $scope.clusteringTaskData = {};

        $scope.updateBackend = function(taskData, policy = taskData.selectedPolicy) {
            const foundBackend = policy.backends.find(backend => (backend.displayName === policy.selectedBackend.displayName));
            if (foundBackend) {
                taskData.backendType = foundBackend.type;
            }
        };

        $scope.canCreateTemplate = function(taskData) {
            return !!taskData.analysisName
                && !!taskData.backendType
                && !!taskData.selectedPolicy;
        };

        $scope.canCreatePredictionTemplate = function(taskData) {
            return !!taskData.targetVariable && $scope.canCreateTemplate(taskData);
        }

        $scope.createPredictionTemplate = function(policyId = $scope.predictionTaskData.selectedPolicy.id) {
            const taskData = $scope.predictionTaskData;

            DataikuAPI.analysis.createPredictionTemplate(
                $stateParams.projectKey,
                $scope.datasetSmartName,
                taskData.analysisName,
                taskData.backendType,
                '',
                taskData.targetVariable,
                policyId
            ).success(data => {
                $scope.dismiss && $scope.dismiss();
                $rootScope.mlTaskJustCreated = true;
                if (policyId === 'DEEP') {
                    $state.go('projects.project.analyses.analysis.ml.predmltask.list.design', { analysisId: data.analysisId, mlTaskId: data.mlTaskId, '#': 'keras-build' });
                } else if (policyId === 'ALGORITHMS' || policyId === 'CUSTOM') {
                    $state.go('projects.project.analyses.analysis.ml.predmltask.list.design', { analysisId: data.analysisId, mlTaskId: data.mlTaskId, '#': 'algorithms' });
                } else {
                    $state.go('projects.project.analyses.analysis.ml.predmltask.list.results', { analysisId: data.analysisId, mlTaskId: data.mlTaskId });
                }
            }).error(setErrorInScope.bind($scope));
        };

        $scope.createClusteringTemplate = function() {
            DataikuAPI.analysis.createClusteringTemplate(
                $stateParams.projectKey,
                $scope.datasetSmartName,
                $scope.clusteringTaskData.analysisName,
                $scope.clusteringTaskData.backendType,
                '',
                $scope.clusteringTaskData.selectedPolicy.id
            ).success(data => {
                $scope.dismiss && $scope.dismiss();
                $rootScope.mlTaskJustCreated = true;
                if ($scope.clusteringTaskData.selectedPolicy.id === 'ALGORITHMS' || $scope.clusteringTaskData.selectedPolicy.id === 'CUSTOM') {
                    $state.go('projects.project.analyses.analysis.ml.clustmltask.list.design', { analysisId: data.analysisId, mlTaskId: data.mlTaskId, '#': 'algorithms' });
                } else {
                    $state.go('projects.project.analyses.analysis.ml.clustmltask.list.results', { analysisId: data.analysisId, mlTaskId: data.mlTaskId });
                }
            }).error(setErrorInScope.bind($scope));
        };

        $scope.getNotebookHref = function (notebook) {
            if (notebook.type == "JUPYTER") {
                return StateUtils.href.jupyterNotebook(notebook.id, notebook.projectKey);
            } else if (notebook.type == "SQL") {
                return StateUtils.href.sqlNotebook(notebook.id, notebook.projectKey);
            }
        }
        
        // whenever the dataset is ready to be inspected, load the notebooks & analyses already on it
        $scope.$watch("datasetSmartName", nv => {
            if (!nv) return;
            $scope.usability = {};
            var parts = nv.match(/([^\.]+)\.(.+)/) || [nv, $stateParams.projectKey, nv]; // [smart, project, dataset]
            DataikuAPI.datasets.getFullInfo($stateParams.projectKey, parts[1], parts[2])
                .success(function(data) {
                    var hasSql = false;
                    ["sql", "hive", "impala", "pig", "sql99"].forEach(function(thing) {
                        $scope.usability[thing] = GlobalProjectActions.specialThingMaybePossibleFromDataset(data.dataset, thing);
                        hasSql = hasSql || $scope.usability[thing].ok;
                    });
                    $scope.usability.spark = { ok: true };
                    if (!$rootScope.appConfig.sparkEnabled) {
                        if (!$rootScope.appConfig.communityEdition) {
                            $scope.usability.spark.click = $scope.showCERestrictionModal.bind(null, 'Spark');
                        } else if (!$rootScope.addLicInfo.sparkLicensed) {
                            $scope.usability.spark.ok = false;
                            $scope.usability.spark.reason = "Spark is not licensed";
                        } else {
                            $scope.usability.spark.ok = false;
                            $scope.usability.spark.reason = "Spark is not configured";
                        }
                    }
                }).error(setErrorInScope.bind($scope));

            $scope.newAnalysisName = "Analyze " + $scope.datasetSmartName;
            
            DataikuAPI.analysis.listOnDataset($stateParams.projectKey, $scope.datasetSmartName, true)
                .success(data =>  {
                    $scope.analyses = data;
                    data.forEach(function (analysis) {
                        analysis.modelCount = analysis.mlTasks.reduce((sum, task) => sum + task.modelCount, 0);
                        analysis.icon = 'icon-dku-nav_analysis';
                        if (analysis.nbMLTasks === 1) {
                            switch(analysis.mlTasks[0].taskType) {
                                case 'PREDICTION':
                                    if (analysis.mlTasks[0].backendType === 'KERAS') {
                                        analysis.icon = 'icon-dku-deeplearning-prediction';
                                    } else {
                                        analysis.icon = 'icon-dku-automl-prediction';
                                    }
                                break;

                                case 'CLUSTERING':
                                    analysis.icon = 'icon-dku-automl-clustering';
                                break
                            }
                        }
                    });
                }).error(setErrorInScope.bind($scope));

            DataikuAPI.datasets.listNotebooks($stateParams.projectKey, nv)
                .success(data => {
                    $scope.notebooks = data;
                    data.forEach(function(nb) {
                        const lowerCaseLanguage = typeof nb.language === 'string' ? nb.language.toLowerCase() : undefined;
                        switch (nb.type) {
                            case 'JUPYTER':
                                if (lowerCaseLanguage.startsWith('python')) {
                                    nb.icon = 'python';
                                } else if (lowerCaseLanguage === 'ir' || lowerCaseLanguage === 'r'){
                                    nb.icon = 'r';
                                } else if (lowerCaseLanguage === 'julia') {
                                    nb.icon = 'julia';
                                } else if (['scala', 'toree'].includes(lowerCaseLanguage)) {
                                    nb.icon = 'spark_scala';
                                }
                                break;
                            case 'SQL': // @virtual(hive-hproxy), @virtual(hive-jdbc) => hive | @virtual(impala-jdbc) => impala | sql
                                nb.icon = (nb.connection.match(/^@virtual\((hive|impala)-\w+\)/) || [,'sql'])[1];
                                break;
                            default:
                                nb.icon = 'nav_notebook';
                        }
                    });
                }).error(setErrorInScope.bind($scope));
        });

        $scope.newNotebook = () => {
            CreateModalFromTemplate("/templates/notebooks/new-notebook-modal.html", $scope, 'NewNotebookModalController');
        };

        $scope.newNotebookFromTemplate = () => {
            CreateModalFromTemplate("/templates/notebooks/new-notebook-from-template-modal.html", $scope, 'NewNotebookFromTemplateModalController');
        };

        $scope.newNotebookFromFile = () => {
            CreateModalFromTemplate("/templates/notebooks/new-notebook-from-file-modal.html", $scope, 'NewNotebookFromFileModalController');
        };
    });


    app.controller("ProjectMassTableToDatasetController", function ($scope, Assert, CreateModalFromTemplate, $stateParams, $state, DataikuAPI, GlobalProjectActions, Fn, TopNav, ActivityIndicator, Dialogs, MonoFuture, FutureProgressModal, $timeout, $rootScope) {
        $scope.projectKey = $stateParams.projectKey;
        $scope.massImportData = null;
        $scope.uiState = {schemas:[], sourceSchema:null};

        $scope.acceptMassImport = function (zoneId) {
            $scope.candidates.hiveImportCandidates.forEach(candidate => {
                if (candidate.selectedConnectionId) {
                    candidate.selectedConnection = candidate.possibleConnections.find(pc => pc.id == candidate.selectedConnectionId)
                }
            });

            DataikuAPI.connections.massImportTableCandidates($stateParams.projectKey, $scope.candidates.sqlImportCandidates, $scope.candidates.hiveImportCandidates, zoneId).success(function (data) {
                FutureProgressModal.show($scope, data, "Importing tables").then(function (importResult) {
                    if (importResult) {
                        var allCandidates = $scope.candidates.sqlImportCandidates.concat($scope.candidates.hiveImportCandidates);
                        /* if only one item and success, go directly to it */
                        if (importResult.anyMessage && importResult.success && allCandidates.length == 1) {
                            $state.go("projects.project.datasets.dataset.explore", {
                                datasetName: allCandidates[0].datasetName
                            });
                        } else if (importResult.anyMessage) {
                            Dialogs.infoMessagesDisplayOnly($scope, "Import report", importResult).then(() => {
                                $state.go("projects.project.datasets.list", {
                                    projectKey: $scope.projectKey
                                });
                            });
                        }
                    }
                });
            }).error(setErrorInScope.bind($scope));
        };

        $scope.acceptMassImportAlation = function(tables) {
            DataikuAPI.connections.massImportSQL($stateParams.projectKey, $scope.uiState.connectionName, {'tables': tables}).success(function(data) {
                FutureProgressModal.show($scope, data, "Importing tables").then(function(importResult) {
                    if (importResult) {
                        if ($stateParams.fromExternal === "alation" && tables.length === 1 && importResult.maxSeverity === "INFO") {
                            // Fastpath when importing from Alation: skip the success message
                            $state.go("projects.project.datasets.dataset.explore", {"datasetName" : tables[0].datasetName});
                        } else if (importResult.anyMessage) {
                            Dialogs.infoMessagesDisplayOnly($scope, "Import report", importResult).then(function() {$scope.massImportData = null;});
                        } else {
                            $scope.massImportData = null;
                        }
                    }
                });
            }).error(setErrorInScope.bind($scope));
        };

        let importData = JSON.parse($stateParams.importData);

        $scope.removeOneCandidate = function(candidate) {
            $scope.tableImportCandidates.splice($scope.tableImportCandidates.indexOf(candidate), 1);

            var sqlIndex = $scope.candidates.sqlImportCandidates.indexOf(candidate);
            if (sqlIndex >=0) $scope.candidates.sqlImportCandidates.splice(sqlIndex, 1);
            var hiveIndex = $scope.candidates.hiveImportCandidates.indexOf(candidate);
            if (hiveIndex >=0) $scope.candidates.hiveImportCandidates.splice(hiveIndex, 1);
        }


        function refreshList() {
            function cb(data){
                $scope.candidates = data;
                $scope.tableImportCandidates = [];
                data.sqlImportCandidates.forEach(e => {
                    e.connectionType = 'SQL';
                    $scope.tableImportCandidates.push(e);
                });
                data.hiveImportCandidates.forEach(e => {
                    e.connectionType = 'HIVE';
                    if (e.selectedConnection) {
                        e.selectedConnectionId = e.selectedConnection.id;
                    }
                    $scope.tableImportCandidates.push(e);
                });
            }

            if (importData.workflowType == "KEYS") {
                DataikuAPI.connections.getTableImportCandidatesFromKeys(importData.tableKeys, $scope.projectKey).success(function(data){
                    FutureProgressModal.show($scope, data, "Get import data").then(cb)
                }).error(setErrorInScope.bind($scope));
            } else if (importData.workflowType == "SQL" || importData.workflowType == "HIVE") {
                DataikuAPI.connections.getTableImportCandidatesFromExplorer(importData.workflowType, importData.selectedTables, $scope.projectKey).success(function(data){
                    FutureProgressModal.show($scope, data, "Get import data").then(cb)
                }).error(setErrorInScope.bind($scope));
            } else if (importData.workflowType == "ALATION_MCC") {
                DataikuAPI.connections.getTableImportCandidatesFromAlationMCC($stateParams.projectKey, importData.alationSelection)
                    .success(cb)
                    .error(setErrorInScope.bind($scope));
            }
        }

        addDatasetUniquenessCheck($scope, DataikuAPI, $scope.projectKey);

        if ($stateParams.importData) {

            if ($stateParams.fromExternal === "alation") {
                $scope.uiState.fromExternal = "alation";
                Assert.inScope($rootScope, 'alationCatalogSelection');
                DataikuAPI.connections.listMassImportSQLFromAlation($stateParams.projectKey, $rootScope.alationCatalogSelection).success(function(data){
                    $scope.massImportData = {"tables": data};
                    $scope.uiState.connectionName = data.connectionName;
                    data.tables.forEach(function(x) { x.checked = true; });
                }).error(setErrorInScope.bind($scope));
            } else {
                refreshList();
            }

        }

    });

    app.controller("AlationOpenController", function ($scope, $stateParams, $state, DataikuAPI, GlobalProjectActions, Fn, TopNav, ActivityIndicator, Dialogs, MonoFuture, FutureProgressModal, $rootScope) {
        TopNav.setNoItem();

        $scope.importNewDataset = {}

        $scope.import = function(){
            $state.go("projects.project.tablesimport", {
                projectKey : $scope.importNewDataset.targetProjectKey,
                importData : JSON.stringify({
                    workflowType : "ALATION_MCC",
                    alationSelection: $scope.alationOpen.catalogSelection
                })
            })
        }

        DataikuAPI.connections.getAlationOpenInfo($stateParams.alationOpenId).success(function(data){
            $scope.alationOpen = data;
            if (data.connectionName) $scope.uiState.connectionName = data.connectionName;
            //data.tables.forEach(function(x) { x.checked = true; });
        }).error(setErrorInScope.bind($scope));
    });

    app.controller("ProjectsProjectMassImportController", function ($scope, CreateModalFromTemplate, $stateParams, $state, DataikuAPI, GlobalProjectActions, Fn, TopNav, ActivityIndicator, Dialogs, MonoFuture, FutureProgressModal) {
        TopNav.setLocation(TopNav.TOP_FLOW, "datasets", TopNav.TABS_NONE, null);
        TopNav.setNoItem();
    });

    app.controller("ConnectionsExplorerController", function ($scope, CreateModalFromTemplate, $stateParams, $state, DataikuAPI, GlobalProjectActions, Fn, TopNav, ActivityIndicator, Dialogs, MonoFuture, FutureProgressModal, $timeout) {
        const ANY = '_any_';
        if ($stateParams.projectKey) {
            TopNav.setLocation(TopNav.TOP_FLOW, "datasets", TopNav.TABS_NONE, null);
            TopNav.setNoItem();
            $scope.massImportTargetProjectKey = $stateParams.projectKey;
        }
        $scope.catalog = $stateParams.catalogName ? $stateParams.catalogName : ANY;
        $scope.schema = $stateParams.schemaName ? $stateParams.schemaName : ANY;

        $scope.massImportData = null;
        $scope.uiState = {schemas: [], sourceSchema: null, importConnectionName: null};
        $scope.selection = {orderReversed: false};
        $scope.isCatalogPresent = false;
        $scope.connection = null;

        $scope.importTables = function (zoneId) {
            if ($stateParams.projectKey) {
                $state.go('projects.project.tablesimport', {
                    projectKey: $stateParams.projectKey,
                    importData: JSON.stringify($scope.getImportData()),
                    zoneId
                });
            } else {
                CreateModalFromTemplate("/templates/datasets/tables-import-project-selection-modal.html", $scope,
                    "TablesImportProjectSelectionModalController");
            }
        };
        $scope.sortBy = function (columnName) {
            if ($scope.selection.orderQuery == columnName) {
                $scope.selection.orderReversed = !$scope.selection.orderReversed;
            } else {
                $scope.selection.orderQuery = columnName;
            }
        };
        $scope.isSortedBy = function (columnName, reversed) {
            if (!$scope.selection || !$scope.selection.orderQuery) return false;
            return $scope.selection.orderQuery == columnName && $scope.selection.orderReversed === reversed;
        };
        $scope.getImportData = function () {
            if ($scope.isHdfs) {
                return {
                    workflowType : "HIVE",
                    selectedTables : $scope.selection.selectedObjects
                };
            } else {
                return {
                    workflowType : "SQL",
                    selectedTables : $scope.selection.selectedObjects
                }
            }
        };

        $scope.isCatalogAware = function() {
            return $scope.connection && ($scope.connection.type === 'BigQuery' || $scope.connection.type === 'Snowflake');
        };

        function assignConnectionRelatedVariables() {
            $scope.isHdfs = $scope.connection.type === 'HDFS';
            if ($scope.isHdfs) {
                $scope.selection.orderQuery = "name";
            } else {
                $scope.selection.orderQuery = "key.name";
            }
        }

        /* HANA organizes tables and calculation views into virtual packages embedded in table names,
         * in the form of package.name/table:name:in:the:package
         * or /package.name:sometimes:with:colons/table:name:in:the:package.
         * Since it's messy for users, allow quick filtering on these virtual packages */
        function buildHANAPackagesList() {
            $scope.massImportData.hanaPackages = null;
            if ($scope.massImportData.connectionType == "SAPHANA") {
                const packagesSet = new Set($scope.massImportData.tables.map(e => {
                    let firstSlash = e.table.indexOf("/");
                    if (firstSlash == 0) {
                        firstSlash = e.table.indexOf("/", 1);
                    }
                    if (firstSlash > 0) {
                        return e.table.substring(0, firstSlash)
                    } else {
                        return null;
                    }
                }));
                packagesSet.delete(null);
                if (packagesSet.size > 0) {
                    $scope.massImportData.hanaPackages =  Array.from(packagesSet);
                }
            }
        }

        $scope.refreshList = function () {
            let monofuture;

            if ($scope.isHdfs) {
                monofuture = MonoFuture($scope).wrap(DataikuAPI.connections.listHiveMassImportTables)($scope.connection.name, $stateParams.projectKey).success(function (data) {
                    $state.go('.', {connectionName: $scope.connection.name, schemaName: null, catalogName: null}, {notify: false});
                    $scope.listFuture = null;
                    $scope.showInputScreen = false;

                    $timeout(() => {
                        $scope.massImportData = {"tables": data.result.tables};
                    });
                });
            } else {
                const catalog = $scope.catalog === ANY ? null : $scope.catalog;
                const schema = $scope.schema === ANY ? null : $scope.schema;
                monofuture = MonoFuture($scope).wrap(DataikuAPI.connections.listSQLMassImportTables)($scope.connection.name, catalog, schema, $stateParams.projectKey).success(function (data) {
                    $state.go('.', {
                        connectionName: $scope.connection.name,
                        catalogName: $scope.catalog,
                        schemaName: $scope.schema
                    }, {notify: false});
                    $scope.listFuture = null;
                    $scope.showInputScreen = false;

                    $timeout(() => {
                        $scope.massImportData = data.result;
                        $scope.isCatalogPresent = $scope.massImportData.tables.find(e => e && e.catalog);
                        $scope.isSchemaPresent = $scope.massImportData.tables.find(e => e && e.schema);
                        buildHANAPackagesList();
                    });

                });

            }
            monofuture.update(function (data) {
                $scope.listFuture = data;
            }).error(function (data, status, headers) {
                $scope.listFuture = null;
                setErrorInScope.bind($scope)(data, status, headers);
            });
        };

        $scope.indeterminateSelectionState = function() {
            if ($scope.massImportData) {
                var tables = $filter('filter')($scope.massImportData.tables, $scope.uiState.query);
                var selectedCount = tables.filter(function(table) {
                    return table.checked;
                }).length;
                var unselectedCount = tables.filter(function(table) {
                    return !table.checked;
                }).length;
                return selectedCount != tables.length && unselectedCount != tables.length;
            } else {
                return false;
            }
        };

        DataikuAPI.connections.listMassImportSources($stateParams.projectKey).success(function(data) {
            $scope.massImportSourcesResult = data;
            $scope.connections = data.sources;
            if ($stateParams.connectionName) {
                $scope.connection = $scope.connections.find(c => {
                    return c.name === $stateParams.connectionName
                });
                assignConnectionRelatedVariables();
                if ($scope.connection.type === 'HDFS' || $stateParams.schemaName) {
                    $scope.refreshList();
                } else {
                    $scope.showInputScreen = true;
                }
            } else {
                $scope.showInputScreen = true;
            }
        }).error(setErrorInScope.bind($scope));

        $scope.$watch('connection', (connection, oldVal) => {
            if (connection) {
                $scope.massImportData = { "tables": [] };
                assignConnectionRelatedVariables();

                if (!$scope.isHdfs && $scope.connection.name != $scope.connectionOfSchemas) {
                    $scope.connectionOfSchemas = null;
                    $scope.fetchedSchemas = null;
                    $scope.schemas = [{ label: 'Any', schema: ANY }];
                    $scope.catalogs = [{ label: 'Any', catalog: ANY }];
                    if (oldVal) {
                        // We are changing the connection
                        $scope.catalog = ANY;
                        $scope.schema = ANY;
                    } else {
                        // We are loading the connection for the first time
                        if ($scope.schema !== ANY) {
                            $scope.schemas = $scope.schemas.concat({ label: $scope.schema, schema: $scope.schema });
                        }
                        if ($scope.catalog !== ANY) {
                            $scope.catalogs = $scope.catalogs.concat({ label: $scope.catalog, catalog: $scope.catalog });
                        }
                    }
                }
            }
        });

        $scope.$watch('catalog', (newVal, oldVal) => {
            // Update the available schemas depending on the selected catalog
            if (newVal !== oldVal && $scope.fetchedSchemas) {
                let availableSchemas;
                if (newVal && newVal !== ANY) {
                    availableSchemas = $scope.fetchedSchemas.filter(schema => schema.catalog === newVal);
                } else {
                    availableSchemas = $scope.fetchedSchemas;
                }
                const uniqueSchemas = [...new Set(availableSchemas.map(schema => schema.schema))];
                $scope.schemas = [{ label: 'Any', schema: ANY }].concat(uniqueSchemas.map(s => ({
                    label: s,
                    schema: s
                })));
            }
        });

        $scope.fetchSchemas = function() {
            var connectionName = $scope.connection.name;
            if ($scope.isCatalogAware()) {
                DataikuAPI.connections.listSQLMassImportSchemasWithCatalogs(connectionName, $stateParams.projectKey).success(function(data) {
                    $scope.connectionOfSchemas = connectionName;
                    $scope.fetchedSchemas = data;
                    const uniqueCatalogs = [...new Set(data.map(schema => schema.catalog))];
                    const uniqueSchemas = [...new Set(data.map(schema => schema.schema))];
                    $scope.catalogs = [{ label: 'Any', catalog: ANY }].concat(uniqueCatalogs.map(c => ({
                        label: c,
                        catalog: c
                    })));
                    $scope.schemas = [{ label: 'Any', schema: ANY }].concat(uniqueSchemas.map(s => ({
                        label: s,
                        schema: s
                    })));
                    if ($scope.catalog !== ANY && !uniqueCatalogs.contains($scope.catalog)) {
                        $scope.catalog = null;
                    }
                    if ($scope.schema !== ANY && !uniqueSchemas.contains($scope.schema)) {
                        $scope.schema = null;
                    }
                }).error(setErrorInScope.bind($scope));
            } else {
                DataikuAPI.connections.listSQLMassImportSchemas(connectionName, $stateParams.projectKey).success(function(data) {
                    $scope.connectionOfSchemas = connectionName;
                    $scope.catalogs = [{ label: 'Any', catalog: ANY }];
                    $scope.schemas = [{ label: 'Any', schema: ANY }].concat(data.map(s => ({
                        label: s,
                        schema: s
                    })));
                    $scope.catalog = ANY;
                    if ($scope.schema !== ANY && !data.contains($scope.schema)) {
                        $scope.schema = null;
                    }
                }).error(setErrorInScope.bind($scope));
            }
        };
    });

})();

(function(){
'use strict';


const app = angular.module('dataiku.datasets.directives', ['dataiku.filters', 'colorpicker.module', 'colorContrast']);


    app.directive('simpleTableContent', function(DataikuAPI, $filter) {
        return {
            scope : {
                "table" : "="
            },
            replace : true,
            link : function(scope, element) {
                /* Refresh of the table content itself */
                scope.$watch("table", function(nv, ov) {
                    dispatchCustomTimelineEvent('StartSimpleTableContentUpdate');
                    if (scope.table == null) return;
                    var table = scope.table;
                    var tableData = "";//<tbody>";

                    for (var rowIdx in table.rows) {
                        tableData += "<tr>";
                        for (var cellIdx in table.rows[rowIdx].cells) {
                            var cell = table.rows[rowIdx].cells[cellIdx];
                            tableData += '<td class="cell"';
                            if (!angular.isUndefined(cell.value) && cell.value.length > 40) {
                                tableData +=' title="' + sanitize(cell.value) + '"';
                            }

                            if (cell.validSt == 'E') { // Empty
                                 tableData += '><div class="cell empty">';
                             } else {
                                 tableData += '><div class="cell filled">';
                            }
                            tableData +=  angular.isUndefined(cell.value) ? '&nbsp;' : sanitize(cell.value);
                            tableData += "</div></td>";
                        }
                        tableData += "</tr>";
                    }
                    tableData += "";//</tbody>";
                    $(element).html(tableData);
                    dispatchCustomTimelineEvent('EndSimpleTableContentUpdate');
                });
            }
        };
    });


    app.directive('simpleColumnHeader', function() {
        return {
            restrict: 'E',
            replace: true,
            templateUrl: '/templates/datasets/simple_column_header.html',
            scope: {
                columnIndex : '=',
                column : '=',
                dataset : '='
            },
            link: function(scope, element, attrs){
                if (scope.columnIndex<0) return;

                scope.schema = {};
                scope.$watch("dataset.schema", function(nv, ov) {
                    if (!nv) return;
                    scope.schema = scope.dataset.schema.columns[scope.columnIndex];
                });

                scope.column.selectedType.totalCount = (scope.column.selectedType.nbOK + scope.column.selectedType.nbNOK + scope.column.selectedType.nbEmpty);
                scope.column.okPercentage = scope.column.selectedType.nbOK * 100 / scope.column.selectedType.totalCount;
                scope.column.emptyPercentage = scope.column.selectedType.nbEmpty * 100 / scope.column.selectedType.totalCount;
                scope.column.nonemptyPercentage = (scope.column.selectedType.totalCount - scope.column.selectedType.nbEmpty) * 100 / scope.column.selectedType.totalCount;
                scope.column.nokPercentage = scope.column.selectedType.nbNOK * 100 / scope.column.selectedType.totalCount;
            }
        };
    });


    app.directive('simpleDetectionPreviewTable', function(DataikuAPI, $filter) {
        return {
            scope : {
                "headers" : "=",
                "table" : "=",
                "dataset" : "=",
                "setSchemaUserModified" : '=',
                "schemaIsUserEditable" : "="
            },
            replace : true,
            templateUrl : '/templates/datasets/fragments/simple-detection-preview-table.html',
            link : function($scope, element) {
                $scope.$watch('table', function(nv) {
                    if ($scope.table == null) {
                        return;
                    }
                    $scope.columnCount = $scope.headers.length;
                    if ($scope.columnCount > 320) {
                        $scope.tooManyColumns = true;
                        var truncateRowOrHeader = function(a, midElement) {
                            var ret = [];
                            var getWithRealIndex = function(a, idx) {
                                var o = a[idx];
                                o.realIndex = idx;
                                return o;
                            };
                            for (var i=0;i<300;i++) {ret.push(getWithRealIndex(a, i));}
                            midElement.realIndex = -1;
                            ret.push(midElement);
                            for (var i=0;i<20;i++) {ret.push(getWithRealIndex(a, a.length - 20 + i));}
                            return ret;
                        };
                        // generate truncated table
                        $scope.displayedHeaders = truncateRowOrHeader($scope.headers, {name:'... ' + ($scope.headers.length - 320) + ' columns ...', selectedType:{}});
                        $scope.displayedTable = {
                                displayedRows : $scope.table.displayedRows, // keep stats
                                totalDeletedRows : $scope.table.totalDeletedRows,
                                totalEmptyCells : $scope.table.totalEmptyCells,
                                totalFullCells : $scope.table.totalFullCells,
                                totalKeptRows : $scope.table.totalKeptRows,
                                totalRows : $scope.table.totalRows,
                                headers : $scope.displayedHeaders,
                                rows : $scope.table.rows.map(function(row) {return {origRowIdx:row.origRowIdx, cells:truncateRowOrHeader(row.cells, {value:'...'})}})
                        };
                    } else {
                        $scope.tooManyColumns = false;
                        $scope.displayedTable = $scope.table;
                        $scope.displayedHeaders = $scope.headers;
                    }
                });
            }
        };
    });


    app.directive('schemaConsistencyStatus', function() {
        return {
            templateUrl: '/templates/datasets/schema-consistency-status.html',
            scope: {
                consistency: '=',
                overwriteSchema: '=',
                clearManagedDataset:  '=',
                checkConsistency: '=',
                discardConsistencyError: '=',
                managed: '=',
                schemaJustModified: '=',
                currentSchema: '='
            },
            link: function($scope) {
            }
        };
    });


    app.directive('simpleEditableColumnHeader', function() {
        return {
            restrict: 'E',
            replace: true,
            templateUrl: '/templates/datasets/simple_editable_column_header.html',
            scope: {
                column : '=',
                columnIndex : '=',
                setSchemaUserModified : '=',
                dataset : '='
            },
            link: function(scope, element, attrs){
                if ( scope.columnIndex < 0) return;

                scope.schema = {};
                scope.$watch("dataset.schema", function(nv, ov) {
                    scope.schema = scope.dataset.schema.columns[scope.columnIndex];
                });

                scope.column.selectedType.totalCount = (scope.column.selectedType.nbOK + scope.column.selectedType.nbNOK + scope.column.selectedType.nbEmpty);
                scope.column.okPercentage = scope.column.selectedType.nbOK * 100 / scope.column.selectedType.totalCount;
                scope.column.emptyPercentage = scope.column.selectedType.nbEmpty * 100 / scope.column.selectedType.totalCount;
                scope.column.nonemptyPercentage = (scope.column.selectedType.totalCount - scope.column.selectedType.nbEmpty) * 100 / scope.column.selectedType.totalCount;
                scope.column.nokPercentage = scope.column.selectedType.nbNOK * 100 / scope.column.selectedType.totalCount;
            }
        };
    });


    app.directive('excelSheets', function(Assert) {
        return {
            template: '<div>' +
                    '<ul>' +
                        '<li ng-repeat="sheet in sheets">' +
                            '<input type="checkbox" ng-model="sheet.isSelected" /> {{sheet.name}}' +
                        '</li>' +
                    '</ul>' +
                '</div>',
            restrict :'E',
            scope :true,
            link: function(scope, element, attrs) {
                function encodeSheets(sheetNames) {
                    return '*' + sheetNames.join('\n'); // Use '*' as first character to denote a list of sheet names.
                }
                function decodeSheets(str, meta) {
                    if (!angular.isDefined(str) || str == "") {
                        return [];
                    }
                    if (str.charAt(0) === '*') {
                        return str.substring(1).split("\n"); // List of sheet names
                    } else {
                        // List of sheet indexes (for compatibility)
                        return str.split(',').map(sheetIndex => meta["sheet." + sheetIndex + ".name"]);
                    }
                }
                scope.oldMeta = null;
                scope.$watch("detectionResults", function(ov, nv) {
                    if (scope.detectionResults == null) {
                        return;
                    }
                    Assert.trueish(scope.detectionResults.format, 'no detected format');
                    if (scope.detectionResults.format == null) {
                        return;
                    }

                    const meta = scope.detectionResults.format.metadata;
                    if (angular.equals(scope.oldMeta, meta)) {
                        return;
                    }
                    if (scope.oldMeta == null) {
                        scope.oldMeta = angular.copy(meta);
                    }
                    const selectedSheetNames = decodeSheets(scope.dataset.formatParams.sheets, meta);
                    if (meta && angular.isDefined(meta.nbSheets)) {
                        scope.sheets = [];
                        for (let i = 0; i < meta.nbSheets; i++) {
                            const sheetName = meta["sheet." + i + ".name"];
                            scope.sheets.push({"name": sheetName, "isSelected": selectedSheetNames.includes(sheetName)});
                        }
                    }
                }, true);

                scope.$watch("sheets", function(ov, nv) {
                    if (scope.sheets == null) {
                        return;
                    }
                    let selectedSheetNames = [];
                    for (let i in scope.sheets) {
                        const sheet = scope.sheets[i];
                        if (sheet.isSelected) {
                            selectedSheetNames.push(sheet.name);
                        }
                    }
                    scope.dataset.formatParams.sheets = encodeSheets(selectedSheetNames);
                    scope.onFormatParamsChanged();
                }, true);
            }
        };
    });


    app.directive('possibleXpaths', function(Assert) {
        return {
            template: '<div class="xpath-tree">'
                     +'   <div ng-repeat="elem in xpaths" ng-include="\'/templates/datasets/format-xml-xpath-group.html\'" />'
                     +'</div>',
            restrict: 'E',
            scope: true,
            link: function(scope, element, attrs) {
                scope.$watch("detectionResults", function(ov, nv) {
                    if (scope.detectionResults == null) {
                        return;
                    }
                    Assert.trueish(scope.detectionResults.format, 'no detected format');
                    if (scope.detectionResults.format == null) {
                        return;
                    }
                    // a new format detection was done, so the metadata *could* have changed
                    const meta = scope.detectionResults.format.metadata;
                    if (meta && angular.isDefined(meta.possibleXPaths)) {
                        // backend sends a flat list of elements with depth and counts, frontend need to prepare for display
                        function groupRecursively(elems, treeDepth) {
                            if (!elems || !elems.length) {
                                return [];
                            }
                            elems.sort((a,b) => a.depth - b.depth);
                            // take the top level for the next grouping session
                            const minDepth = elems[0].depth;
                            const groups = elems.filter(elem => elem.depth == minDepth);
                            groups.forEach(function(group) {
                                group.treeDepth = treeDepth;
                            });
                            // split the rest in groups
                            elems.forEach(function(elem) {
                                const parent = groups.filter(function(group) {
                                    return elem.xpath.length > group.xpath.length && elem.xpath.slice(0, group.xpath.length) == group.xpath;
                                });
                                if (parent.length == 0 || parent.length > 1) {
                                    return; // not supposed to happen, by construction of the xpaths
                                }
                                elem.xpathSuffix = elem.xpath.slice(parent[0].xpath.length);
                                parent[0].xpaths = parent[0].xpaths || [];
                                parent[0].xpaths.push(elem);
                            });
                            // recurse in the groups, as needed
                            groups.forEach(function(group) {
                                if (group.xpaths !== undefined && group.xpaths.length > 0) {
                                    group.xpaths = groupRecursively(group.xpaths, treeDepth + 1);
                                }
                            });
                            groups.sort((a,b) => b.count - a.count); // sort by decreasing count
                            return groups;
                        }

                        scope.xpaths = groupRecursively(JSON.parse(meta.possibleXPaths), 0);
                    }
                }, true);

                scope.selectXpath = function(xpath) {
                    if (scope.lastFocusedXpathFieldSetter != null) {
                        scope.lastFocusedXpathFieldSetter(xpath, scope.dataset.formatParams.rootPath);
                        // force the preview to refresh
                        scope.onFormatParamsChanged();
                    }
                };
            }
        };
    });


    app.directive('xpathField', function() {
    	return {
        	restrict:'A',
        	require:'^ngModel',
            scope: true,
            link : function(scope, element, attrs, ngModel) {
            	var xpathType = attrs['xpathField'];
               	element.on('focus', function() {
                        scope.xpathFieldGotFocus(function(value, rootElementXpath) {
            			// be smarter and make the xpath appropriate to where it's set
            			if (rootElementXpath != null) {
                			if ( xpathType == 'parent') {
                				// for nodes that we know are parents of the root element, only take the attributes
                				if (rootElementXpath.startsWith(value))
                					value = value + '/@*';
                			}
                			if ( xpathType == 'child') {
                				// for nodes that we know are children of the root element, make them relative
                				if (value.startsWith(rootElementXpath))
                					value = '.' + value.substring(rootElementXpath.length);
                			}
            			}
            			// set the new value in the field and render
                		ngModel.$setViewValue(value);
                		ngModel.$render();
            		});
            	});
            }
        };
    });

    app.directive('datasetPathInput', function($timeout) {
        return {
            restrict: 'E',
            replace: true,
            templateUrl: '/templates/datasets/dataset-path-input.html',
            scope: {
                title: '@',
                path: '=',
                browseFn: '=',
                validateFn: '=',
                connection: '@',
                changeNeedsConfirm: '='
            },
            link: function(scope, element, attrs){
                scope.changeConfirmed = false;

                // -- file selection

                scope.navObj = {selectedItems: []};
                scope.canBrowse = function(item) {
                    return true;
                };

                scope.canSelect = function(item) {
                    return true;
                };

                // -- browsing

                scope.onToggleBrowse = function() {
                    scope.browseActive = !scope.browseActive;
                    if (scope.browseActive) {
                        scope.path = scope.path || '/';
                        scope.navObj.browsePath = scope.path;
                    }
                };

                scope.onOKClick = function() {
                    if (scope.navObj.selectedItems.length == 0) {
                        scope.path = scope.navObj.browsePath;
                    } else {
                        scope.path = scope.navObj.selectedItems[0].fullPath;
                    }
                    scope.browseActive = false;
                    /* Evaluate in timeout so that the nw path is correctly propagated before triggering change handlers
                     * (else, issues with digest cycles) */
                    $timeout(function() {
                        scope.validateFn();
                    });
                };

                scope.onCancelClick = function() {
                    scope.browseActive = false;
                };

                scope.$watch("connection", function(nv,ov){
                    scope.browsePath = '/';
                    scope.onCancelClick();
                })
            }
        };
    });

    app.directive('folderPathInput', ($timeout, openDkuPopin) => {
        return {
            restrict: 'E',
            replace: true,
            templateUrl: '/templates/projects-list/folder-path-input.html',
            scope: {
                title: '@',
                path: '=',
                browseFn: '=',
                validateFn: '=',
                connection: '@',
                changeNeedsConfirm: '=',
                displayItemFn: '=?',
                canSelectFn: '=?',
                folder: '=?',
                showRootFolderPath: '=?',
                cantWriteContentVerb: '@',
                searchable: '@',
                inputId: '@',
                inputEnabled: '&?',
            },
            link: (scope, element, attrs) => {
                scope.searchable = attrs.searchable ? scope.$eval(scope.searchable) : false;
                scope.changeConfirmed = false;
                const targetElement = element[0].querySelector('.browse-path-dropdown');
                const template = $(targetElement).detach();

                // -- file selection

                scope.navObj = { selectedItems: [] };
                scope.canBrowse = () => true;

                scope.canSelect = item => scope.canSelectFn ? scope.canSelectFn(item) : false;

                scope.displayItem = item => scope.displayItemFn ? scope.displayItemFn(item) : item;

                scope.inputEnabled = scope.inputEnabled ? scope.inputEnabled : () => true;

                scope.currentFolder = scope.folder;

                // -- browsing

                scope.onToggleBrowse = (event) => {
                    scope.browseActive = !scope.browseActive;

                    const isElsewhere = (tooltipElement, event) => $(event.target).parents('.browse-path-dropdown').length === 0 && $(event.target).parents('.browse-path-input').length === 0;
                    const onDismiss = () => scope.browseActive = false;

                    scope.dismissPopin = openDkuPopin(scope, event, { popinPosition: 'SMART', arrow: false, doNotCompile: true, onDismiss, isElsewhere, template });
                    if (scope.browseActive) {
                        if (scope.folder) {
                            scope.navObj.browsePath = scope.folder.id;
                        } else {
                            scope.navObj.browsePath = scope.path;
                        }
                    }
                };

                scope.onOKClick = () => {
                    const selectedItems = scope.navObj.selectedItems;

                    if (scope.folder) {
                        scope.folder = scope.currentFolder;
                    }
                    scope.path = selectedItems.length === 1 ? selectedItems[0].fullPath : scope.navObj.browsePath;
                    if (scope.path === '/') {
                        scope.path = "";
                    }
                    scope.browseActive = false;
                    scope.dismissPopin();
                };

                scope.browseDoneFn = folder => {
                    // show / if folder is root
                    if (scope.showRootFolderPath && !folder.pathElts) {
                        folder.pathElts = '/';
                    }

                    scope.currentFolder = folder;
                };

                scope.onCancelClick = () => {
                    scope.browseActive = false;
                    scope.dismissPopin();
                };
            }
        };
    });

    // This directive is much more complex than it should, because it has very specific properties
    // to not break the existing UI.
    // For instance:
    // - The model object is updated in-place (except when it's not impossible)
    // - The model is not updated if it has not been modified by the user
    //   (auto fixup is not propagated until necessary)
    // - It internally synchronizes 3 states : the model, the tree view model, and the JSON
    //
    // Notice: it's probably the worst code I ever wrote!
    app.service('ColumnTypeConstants', function(CreateModalFromTemplate, ContextualMenu, $rootScope){
        var cst = {
    		types : [
                     {name:'tinyint',label:'tinyint (8 bit)'},
                     {name:'smallint',label:'smallint (16 bit)'},
                     {name:'int',label:'int'},
                     {name:'bigint',label:'bigint (64 bit)'},
                     {name:'float',label:'float'},
                     {name:'double',label:'double'},
                     {name:'boolean',label:'boolean'},
                     {name:'string',label:'string'},
                     {name:'date',label:'date'},
                     {name:'geopoint',label:'geo point'},
                     {name:'geometry',label:'geometry'},
                     {name:'array',label:'array<...>'},
                     {name:'map',label:'map<...>'},
                     {name:'object',label:'object<...>'}
                 ],
             COMPLEX_TYPES : {
                     array:    {icon: 'icon-list'},
                     map:      {icon: 'icon-th'},
                     object:   {icon: 'icon-list-alt'},
                     geopoint: {icon: 'icon-map-marker', primitive: true}
    		}
        };
        return cst;
    });


    app.directive('complexTypeSelector', function(CreateModalFromTemplate, ContextualMenu, $rootScope, ColumnTypeConstants){
        return {
            restrict:'E',
            scope: {
                'model':'='
            },
            templateUrl : '/templates/datasets/type-editor/widget.html',
            link : function(scope, element, attrs) {
                scope.types = ColumnTypeConstants.types;
            }
        };
    });


    app.directive('complexTypeEditor', function(CreateModalFromTemplate, ContextualMenu, $rootScope, ColumnTypeConstants){
        var COMPLEX_TYPES = ColumnTypeConstants.COMPLEX_TYPES, DEFAULT_ICON = 'icon-book';
        return {
            restrict:'E',
            scope: {
                'model':'=',
                'showCommentTab': '=',
                'hideCustomFields': '='
            },
            templateUrl : '/templates/datasets/type-editor/editor.html',
            link : function(scope, element, attrs) {
                scope.appConfig = $rootScope.appConfig;

                // Foreign change
                scope.$watch('model',function(nv) {
                    if(!nv) return;
                    var currentCopy = angular.copy(scope.current);
                    scope.current = deepInplaceCopy(scope.model, scope.current);
                    fixup(scope.current, currentCopy);
                },true);

                scope.editMode = 'comment';

                function fixup(col,applyShow) {
                    if(!col) return;
                    delete col.$$hashKey;
                    if(applyShow) {
                        col.show = applyShow.show;
                        col.editing = applyShow.editing;
                        col.renaming = applyShow.renaming;
                        col.configuring = applyShow.configuring;
                        if(!col.show) {
                            delete col.show;
                        }
                        if(!col.editing) {
                            delete col.editing;
                        }
                        if(!col.renaming) {
                            delete col.renaming;
                        }
                        if(!col.configuring) {
                            delete col.configuring;
                        }
                    } else {
                        delete col.show;
                        delete col.editing;
                        delete col.renaming;
                        delete col.configuring;
                        applyShow = {};
                    }
                    if(col.type=='map') {
                        if(!(col.mapValues instanceof Object) || col.mapValues instanceof Array) {
                            col.mapValues = {"name":"","type":"string"};
                        }
                        fixup(col.mapValues,applyShow.mapValues);
                        if(!(col.mapKeys instanceof Object) || col.mapKeys instanceof Array) {
                            col.mapKeys = {"name":"","type":"string"};
                        }
                        fixup(col.mapKeys,applyShow.mapKeys);
                        delete col.mapKeys.name;
                        delete col.mapValues.name;
                        delete col.arrayContent;
                        delete col.objectFields;
                        delete col.maxLength;
                    } else if(col.type=='array' || col.mapValues instanceof Array){
                        if(!(col.arrayContent instanceof Object) || col.arrayContent instanceof Array) {
                            col.arrayContent = {"name":"","type":"string"};
                        }
                        fixup(col.arrayContent,applyShow.arrayContent);
                        delete col.arrayContent.name;
                        delete col.mapKeys;
                        delete col.mapValues ;
                        delete col.objectFields;
                        delete col.maxLength;
                    } else if(col.type == 'object') {
                        if(!(col.objectFields instanceof Array)) {
                            col.objectFields = [];
                        }
                        var flds = (applyShow.objectFields instanceof Array)?applyShow.objectFields:[];
                        var existingNames = {};
                        for(var i = 0 ; i < col.objectFields.length ; i++) {
                            var current = col.objectFields[i];
                            var currentName = current?current.name:undefined;
                            if(currentName) {
                                existingNames[currentName] = true;
                            }
                        }
                        for(var i = 0 ; i < col.objectFields.length ; i++) {
                            fixup(col.objectFields[i],flds[i]);
                            if(!col.objectFields[i].name) {
                                var newName = 'field_'+(i+1);
                                var cnt = 1;
                                while(existingNames[newName]) {
                                    newName ='field_'+(i+1)+'_'+cnt;
                                    cnt++;
                                }
                                col.objectFields[i].name= newName;
                            }
                        }
                        delete col.mapKeys;
                        delete col.mapValues;
                        delete col.arrayContent;
                        delete col.maxLength;
                    } else {
                        if(!col.type) {
                            col.type = 'string';
                        }
                        if(col.type!='string') {
                            delete col.maxLength;
                        } else {
                            if(col.maxLength==undefined) {
                                col.maxLength = 1000;
                            }
                        }
                        delete col.mapKeys;
                        delete col.mapValues;
                        delete col.arrayContent;
                        delete col.objectFields;
                        delete col.show;
                    }
                }

                // This code is NOT generic... and miss a lot of corner cases
                // It's okay for this usage only
                function deepInplaceCopy(from,to) {
                    if(!to || !(to instanceof Object)) {
                        to = {};
                    }
                    for(var k in to) {
                        if(!from[k]) {
                            delete to[k];
                        }
                    }
                    for(var k in from) {

                        var objFrom = from[k];
                        var objTo = to[k];
                        if(objFrom instanceof Array && objTo instanceof Array) {

                            for(var i = 0 ; i < objFrom.length ; i++) {
                                var itemFrom = objFrom[i];
                                var itemTo = objTo[i];
                                if(typeof itemFrom == 'string' || typeof itemFrom == 'number' || typeof itemFrom == 'boolean') {
                                    objTo[i] = itemFrom;
                                } else if(!(itemFrom instanceof Array) && itemFrom instanceof Object && itemFrom
                                    && !(itemTo instanceof Array) && itemTo instanceof Object && itemTo) {
                                    objTo[i] = deepInplaceCopy(itemFrom,itemTo);
                                } else {
                                    objTo[i] = angular.copy(itemFrom);
                                }
                            }
                            objTo.length = objFrom.length;

                        } else if(!(objFrom instanceof Array) && !(objTo instanceof Array) &&
                                objFrom instanceof Object && objTo instanceof Object && objTo!=null && objFrom!=null) {
                            to[k] = deepInplaceCopy(objFrom,objTo);
                        } else {
                            to[k] = angular.copy(objFrom);
                        }
                    }
                    return to;
                }


                function isDifferent(a,b,isRoot) {
                    if((!a && b) || (a &&!b)) return true;
                    if(a.name!=b.name) return true;
                    if(a.type!=b.type) return true;
                    if(a.timestampNoTzAsDate!=b.timestampNoTzAsDate) return true;
                    if (a.meaning != b.meaning) return true;
                    if(isRoot && a.comment && b.comment && b.comment!=a.comment) return true;
                    if(isRoot) {
                        if (!a.customFields && b.customFields) return true;
                        if (a.customFields && !b.customFields) return true;
                        if (a.customFields && b.customFields) {
                            const aKeys = Object.keys(a.customFields);
                            const bKeys = Object.keys(b.customFields);
                            if (aKeys.length!=bKeys.length) return true;
                            for (let key in a.customFields) {
                                if (!b.customFields.hasOwnProperty(key)) return true;
                                if (a.customFields[key]!=b.customFields[key]) return true;
                            }
                        }
                    }
                    if(a.type == 'string') {
                        if(a.maxLength != b.maxLength) {
                            return true;
                        }
                    }
                    if(a.type=='map') {
                        if(isDifferent(a.mapKeys,b.mapKeys)) {
                            return true;
                        }
                        if(isDifferent(a.mapValues,b.mapValues)) {
                            return true;
                        }
                    }
                    if(a.type=='array') {
                        if(isDifferent(a.arrayContent,b.arrayContent)) {
                            return true;
                        }
                    }
                    if(a.type=='object') {
                        if(a.objectFields && !b.objectFields) return true;
                        if(!a.objectFields && b.objectFields) return true;
                        if(!a.objectFields && !b.objectFields) return false;
                        if(a.objectFields.length != b.objectFields.length) {
                            return true;
                        }
                        for(var i = 0 ; i < a.objectFields.length; i++) {
                             if(isDifferent(a.objectFields[i],b.objectFields[i])) {
                                return true;
                            }
                        }
                    }
                    return false;
                }


                scope.toggleEdit = function(elm,event) {
                   if(event) {
                       event.stopPropagation();
                   }
                   scope.disableEditing();
                   elm.editing = true;
                };

                scope.toggleRenaming = function(elm,event) {
                   if(event) {
                       event.stopPropagation();
                   }
                   scope.disableEditing();
                   elm.renaming = true;
                };

                scope.toggleConfiguring = function(elm,event) {
                    if(event) {
                       event.stopPropagation();
                    }
                    scope.disableEditing();
                    elm.configuring = true;
                };

                scope.disableEditing = function() {
                    function recurse(sc) {
                        if(!sc) return;
                        delete sc.editing;
                        delete sc.configuring;
                        delete sc.renaming;
                        if(sc.mapKeys) {
                            recurse(sc.mapKeys);
                        }
                        if(sc.mapValues) {
                            recurse(sc.mapValues);
                        }
                        if(sc.objectFields) {
                            for(var k in sc.objectFields) {
                                recurse(sc.objectFields[k]);
                            }
                        }
                        if(sc.arrayContent) {
                            recurse(sc.arrayContent);
                        }
                    };
                    recurse(scope.current);
                };

                scope.ui = {};

                scope.customFieldsMap = $rootScope.appConfig.customFieldsMap['COLUMN'];

                scope.types = ColumnTypeConstants.types;

                scope.getTypeLabel = function(type) {
                    for(var k in scope.types) {
                        if(scope.types[k].name==type) {
                            return scope.types[k].label;
                        }
                    }
                    return 'Unknown type';
                };

                // UI current is the textarea (and yes, we should change that incredibly confusing naming)
                scope.$watch('ui.current',function() {
                    if(!scope.ui.current) return;
                    fixup(scope.ui.current,undefined);
                    var currentCopy = angular.copy(scope.current);
                    scope.current = deepInplaceCopy(scope.ui.current,scope.current)
                    fixup(scope.current,currentCopy);
                },true);

                // Current is the tree-view (and yes, we should change that incredibly confusing naming)
                scope.$watch('current',function(current) {
                    if(!current) return;

                    // Fix errors, keep states
                    fixup(current,current);

                    // Cleanup "show" status in textarea
                    scope.ui.current = angular.copy(current);
                    fixup(scope.ui.current,undefined);

                    // And in the model
                    var fixedModel = angular.copy(scope.model);
                    fixup(fixedModel,undefined);
                    if(isDifferent(current,fixedModel,true)) {
                        var noShowCopy = angular.copy(current);
                        fixup(noShowCopy,undefined);
                        var oldHash = scope.model.$$hashKey; // keep the hash (for angular ngRepeat tracking? otherwise https://github.com/dataiku/dip/issues/4206 )
                        scope.model = deepInplaceCopy(noShowCopy,scope.model);
                        scope.model.$$hashKey = oldHash;
                    }

                },true);

                scope.isEditable = function(elm) {
                    return elm && (elm.type == 'string' || !scope.isPrimitiveType(elm.type));
                };

                scope.getIconForType = function(t) {
                    return t in COMPLEX_TYPES ? COMPLEX_TYPES[t].icon : DEFAULT_ICON;
                };

                scope.setEditMode = function(m) {
                    scope.editMode = m;
                };

                scope.isPrimitiveType = function(t) {
                    return !(t in COMPLEX_TYPES) || COMPLEX_TYPES[t].primitive;
                }
            }
        };
    });


app.directive('dataset', function(CreateModalFromTemplate){
    return {
        link: function(scope, element, attrs){
            scope.buildDataset = function(){
                CreateModalFromTemplate("/templates/datasets/build-dataset-modal.html", scope, "BuildDatasetController", null, "build-dataset-modal");
            };

        }
    };
});


app.controller("DatasetPageRightColumnActions", function($controller, $scope, $rootScope, $stateParams, DataikuAPI, ActiveProjectKey) {

    $controller('_TaggableObjectPageRightColumnActions', {$scope: $scope});

    $scope.selection = {
        selectedObject : {
            projectKey : ActiveProjectKey.get(),
            name : $stateParams.datasetName,
            id: $stateParams.datasetName,
            nodeType : 'LOCAL_DATASET',
            interest : {}, 
        },
        confirmedItem : {
            projectKey : ActiveProjectKey.get(),
            name : $stateParams.datasetName,
            nodeType : 'LOCAL_DATASET',
        }
    };

    function updateUserInterests() {
        DataikuAPI.interests.getForObject($rootScope.appConfig.login, "DATASET", ActiveProjectKey.get(), $stateParams.datasetName).success(function(data) {
            
            $scope.selection.selectedObject.interest.watching = data.watching;
            $scope.selection.selectedObject.interest.starred = data.starred;

        }).error(setErrorInScope.bind($scope));
    }

    updateUserInterests();
    const interestsListener = $rootScope.$on('userInterestsUpdated', updateUserInterests);
    $scope.$on("$destroy", interestsListener);
});


app.controller("ForeignDatasetPageRightColumnActions", function($controller, $scope, $stateParams, DatasetUtils, DataikuAPI, $rootScope, ActiveProjectKey) {

    $controller('_TaggableObjectPageRightColumnActions', {$scope: $scope});

    const loc = DatasetUtils.getLocFromFull($stateParams.datasetFullName);
    $scope.selection = {
        selectedObject : {
            projectKey : loc.projectKey,
            name : loc.name,
            id: loc.name,
            nodeType : 'FOREIGN_DATASET',
            interest : {}, 
        },
        confirmedItem : {
            projectKey : loc.projectKey,
            name : loc.name,
            nodeType : 'FOREIGN_DATASET',
        }
    }
});


app.controller("DatasetDetailsController", function($scope, $stateParams, DataikuAPI, FutureProgressModal, DatasetUtils, StateUtils, Dialogs, ActiveProjectKey) {
    $scope.StateUtils = StateUtils;
    $scope.isLocalDataset = function() {
        return $scope.data.dataset.projectKey == ActiveProjectKey.get();
    };

    $scope.isPartitioned = function() {
        return $scope.data
            && $scope.data.dataset
            && $scope.data.dataset.partitioning
            && $scope.data.dataset.partitioning.dimensions
            && $scope.data.dataset.partitioning.dimensions.length > 0;
    }

    this.DatasetUtils = DatasetUtils;

    $scope.refreshAndGetStatus = function(datasetData, computeRecords, forceRecompute) {
        DataikuAPI.datasets.getRefreshedSummaryStatus(ActiveProjectKey.get(), datasetData.dataset.name, computeRecords, forceRecompute).success(function(data) {
            FutureProgressModal.show($scope, data, "Refresh dataset status").then(function(result){
                datasetData.status = result;
                if (result) { // undefined in case of abort
                    Dialogs.infoMessagesDisplayOnly($scope, "Computation result", result.messages);
                }
            });
        }).error(setErrorInScope.bind($scope));
    };
});


app.directive('ellipsedList', [ '$window', '$timeout', function($window, $timeout){
    return {
        link: function($scope, element, attrs) {
            $scope.menuState = {
                useFullMoreActions: true,
                hideMoreActions: false,
            };
            $scope.hideMoreActions = function() {
                $scope.menuState.hideMoreActions = true;
                element.children('[label]').show();
            };
            var resizeMoreActions = function() {
                $scope.element = element;
                var elements = element.children('[label]');
                var lineElCount = Math.floor(element.width() / elements.width());
                $scope.menuState.useFullMoreActions = (lineElCount < elements.length);
                var splitPosition = $scope.menuState.useFullMoreActions ? lineElCount - 1 : lineElCount;
                elements.slice(splitPosition, elements.length).hide();
                elements.slice(0, splitPosition).show();
            };

            var handleElementResize = function() {
                const nv = element.width();
                if (ov != nv && !$scope.menuState.hideMoreActions && nv>0) {
                    ov = nv;
                    $timeout(resizeMoreActions);
                }
            }

            var ov = -1;

            angular.element($window).bind('resize', handleElementResize);

            $scope.$on("$destroy", function () {
                angular.element($window).unbind('resize', handleElementResize);
            });
    
    
            $scope.$watch('uiState.displayMoreActions', function(nv, ov){
                if($scope.menuState.hideMoreActions){
                    return;
                }
                if (!nv || (nv && ov)) {
                    element.addClass('ellipsed-list-loading');
                }
                if (nv) {
                    showMoreActions();
                }
            });

            var showMoreActions = function(){
                $scope.menuState.hideMoreActions = false;
                $timeout(function(){
                    resizeMoreActions();
                    element.removeClass('ellipsed-list-loading');
                },50);
            };
        }
    }
}]);


app.directive('datasetRightColumnSummary', function($controller, $stateParams, $state, $timeout,
        DataikuAPI, CreateModalFromTemplate, DatasetsService, GlobalProjectActions, QuickView, FlowGraphSelection, FlowGraph,
        TaggableObjectsUtils, ActiveProjectKey, AnyLoc, ActivityIndicator, DatasetCustomFieldsService, $rootScope, SelectablePluginsService){
    return {
        templateUrl: '/templates/datasets/right-column-summary.html',
        link: function($scope, element, attrs) {

            /* Auto save when summary is modified */
            $scope.$on("objectSummaryEdited", function() {
                DataikuAPI.datasets.save($scope.dataset.projectKey, $scope.dataset, { summaryOnly: true })
                    .success(() => ActivityIndicator.success("Saved"))
                    .error(setErrorInScope.bind($scope));
            });

            /* Save custom fields */
            $scope.$on('customFieldsSummaryEdited', function(event, customFields) {
                DatasetCustomFieldsService.saveCustomFields($scope.dataset, customFields);
            });


            $controller('_TaggableObjectsMassActions', { $scope });
            $controller('_TaggableObjectsCapabilities', { $scope });

            $scope.QuickView = QuickView;

            $scope.$stateParams = $stateParams;

            var enrichSelectedObject = function (selObj, dataset) {
                selObj.tags = dataset.tags; // for apply-tagging modal
            }

            $scope.$on('taggableObjectTagsChanged', () => $scope.refreshData());

            $scope.refreshData = function() {
                $scope.uiState.displayMoreActions = false;
                // From personal home page we want details of items in projects withouth having opened then

                const loc = AnyLoc.makeLoc($scope.selection.selectedObject.projectKey, $scope.selection.selectedObject.name);
                DataikuAPI.datasets.getFullInfo(ActiveProjectKey.get(), loc.projectKey, loc.localId).success(function(data) {
                     if (!$scope.selection.selectedObject
                        || loc.localId != data.dataset.name
                        || loc.projectKey != data.dataset.projectKey) {
                        return; //too late!
                    }

                    $scope.datasetFullInfo = data;
                    $scope.dataset = data.dataset;
                    $scope.usability = GlobalProjectActions.getAllStatusForDataset(data.dataset);
                    $scope.selectablePlugins = SelectablePluginsService.listSelectablePlugins({'DATASET' : 1});

                    enrichSelectedObject($scope.selection.selectedObject, $scope.dataset);

                    if (data.dataset.projectKey == ActiveProjectKey.get()) {
                        $scope.isLocalDataset = true;
                        $scope.dataset.smartName = data.dataset.name; // TODO: could be done in backend
                    } else {
                        $scope.isLocalDataset = false;
                        $scope.dataset.smartName = data.dataset.projectKey + "." + data.dataset.name;

                    }
                    $scope.uiState.displayMoreActions = true;
                    $scope.dataset.zone = ($scope.selection.selectedObject.usedByZones || [])[0] || $scope.selection.selectedObject.ownerZone;
                }).error(setErrorInScope.bind($scope));
            };

            $scope.getCommonZone = function () {
                return $scope.dataset.zone;
            };

            $scope.getSmartNames = function() {
                return [$scope.dataset.smartName];
            };

            $scope.$watch("selection.selectedObject",function(nv) {
                $scope.datasetFullInfo = {dataset: $scope.selection.selectedObject, timeline: {}}; // display temporary (incomplete) data
                if($scope.selection.selectedObject!=$scope.selection.confirmedItem) {
                    $scope.dataset = null;
                }
                if (!nv) return;
                $scope.datasetType = nv.datasetType || nv.type;
                if (nv.nodeType === 'FOREIGN_DATASET') {
                    $scope.datasetSmartName = nv.projectKey + '.' + nv.name;
                    $scope.datasetHref = $state.href('projects.project.foreigndatasets.dataset.explore',
                        {datasetFullName: $scope.datasetSmartName, projectKey: nv.projectKey});
                } else {
                    $scope.datasetSmartName = nv.name;
                    $scope.datasetHref = $state.href('projects.project.datasets.dataset.explore',
                        {datasetName: nv.name, projectKey: nv.projectKey});
                }
            });

            $scope.$watch("selection.confirmedItem", function(nv, ov) {
                if (!nv) return;
                if (!nv.projectKey) nv.projectKey = ActiveProjectKey.get();
                $scope.refreshData();
            });

            $scope.isAllDatasets = ( () => true ); // To reuse templates with multi-object right column

            $scope.buildDataset = function() {
                DataikuAPI.datasets.get($scope.selection.selectedObject.projectKey, $scope.selection.selectedObject.name, ActiveProjectKey.get())
                .success(function(dataset) {
                    CreateModalFromTemplate("/templates/datasets/build-dataset-modal.html", $scope, "BuildDatasetController", function(newScope) {
                        newScope.dataset = dataset;
                        newScope.jobStartRedirects = (attrs.jobStartRedirects !== undefined) ;
                    }, "build-dataset-modal");
                }).error(setErrorInScope.bind($scope));
            };

            $scope.createWebAppForDataset = function(loadedWebapp, roleTarget, roleValue) {
                let defaultWebappName = loadedWebapp.desc.meta.label + ' on ' + $scope.datasetSmartName;
                $scope.showCreateVisualWebAppModal(loadedWebapp, roleTarget, roleValue, defaultWebappName);
            };

            $scope.editCustomFields = function(editingTabIndex = 0) {
                if (!$scope.selection.selectedObject) {
                    return;
                }
                DataikuAPI.datasets.getSummary($scope.selection.selectedObject.projectKey, $scope.selection.selectedObject.name).success(function(data) {
                    const dataset = data.object;
                    const modalScope = angular.extend($scope, {objectType: 'DATASET', objectName: dataset.name, objectCustomFields: dataset.customFields, editingTabIndex});
                    CreateModalFromTemplate("/templates/taggable-objects/custom-fields-edit-modal.html", modalScope).then(function(customFields) {
                        DatasetCustomFieldsService.saveCustomFields(dataset, customFields);
                    });
                }).error(setErrorInScope.bind($scope));
            };

            $scope.anyPipelineTypeEnabled = function() {
                return $rootScope.projectSummary && ($rootScope.projectSummary.sparkPipelinesEnabled || $rootScope.projectSummary.sqlPipelinesEnabled);
            };

            function showVirtualizationAction(showDeactivate) {
                return function() {
                    const virtualized = !!$scope.selection.selectedObject.virtualizable;
                    return !$state.current.name.includes('explore')
                        && $scope.isProjectAnalystRW()
                        && $scope.isLocalDataset
                        && showDeactivate === virtualized;
                }
            }
            $scope.showAllowVirtualizationAction = showVirtualizationAction(false);
            $scope.showStopVirtualizationAction = showVirtualizationAction(true);


            $scope.zoomToOtherZoneNode = function(zoneId) {
                const otherNodeId = $scope.selection.selectedObject.id.replace(/zone__.+?__/, "zone__" + zoneId + "__");
                if ($stateParams.zoneId) {
                    $state.go('projects.project.flow', Object.assign({}, $stateParams, { zoneId: zoneId, id: graphVizUnescape(otherNodeId) }));
                    return;
                }
                else {
                    $scope.zoomGraph(otherNodeId);
                    FlowGraphSelection.clearSelection();
                    FlowGraphSelection.onItemClick($scope.nodesGraph.nodes[otherNodeId]);
                }
            }

            $scope.isDatasetZoneInput = function() {
                return ($scope.selection.selectedObject.usedByZones.length && $scope.selection.selectedObject.usedByZones[0] != $scope.selection.selectedObject.ownerZone);
            }
        }
    }
});

app.controller("ConnectionDetailsController", function ($scope, $stateParams, DataikuAPI, FutureProgressModal, ConnectionUtils, StateUtils,InfoMessagesModal) {
    $scope.StateUtils = StateUtils;
    $scope.noDescription = true;

    $scope.indexConnection = function () {
        $scope.$emit('indexConnectionEvent', $scope.data.name);
    };
    $scope.showMessages = function (messages) {
        InfoMessagesModal.showIfNeeded($scope, messages, "Indexing report");
    };
    $scope.isIndexable = function (connection) {
        return ConnectionUtils.isIndexable(connection);
    };
});

app.directive('connectionRightColumnSummary', function (DataikuAPI, $stateParams, CreateModalFromTemplate, DatasetsService, GlobalProjectActions, $state, QuickView, $timeout) {
    return {
        templateUrl: '/templates/admin/connections-right-column-summary.html',
        link: function (scope, element, attrs) {
            scope.$watch("selection.selectedObject", function (nv) {
                if (!nv) return;
                scope.connectionHref = $state.href('admin.connections.edit', {connectionName: nv.name});
            });

        }
    };
});

// Cta stands for Call To Action
// Service to return a function that will decide whether we should display the error or a nicer CTA to the user when the dataset can't load itelf (used in explore and charts)
app.service('DatasetErrorCta', function() {

    function requiresDatasetBuild(error) {
        return ['USER_CONFIG_DATASET', 'USER_CONFIG_OR_BUILD'].includes(error.fixability);
    }

    return {
        getupdateUiStateFunc: function (scope) {
            return function(error) {
                scope.uiDisplayState = {
                    showError: false,
                    showBeingBuilt: false,
                    showAboutToBeBuilt: false,
                    showBuildEmptyCTA: false,
                    showBuildFailCTA: false,
                    showUI: false
                }

                const dfi = scope.datasetFullInfo;
                const managed = (dfi && dfi.dataset && dfi.dataset.managed);
                const beingBuilt = (dfi && dfi.currentBuildState && dfi.currentBuildState.beingBuilt && dfi.currentBuildState.beingBuilt.length);
                const aboutToBeBuilt = (dfi && dfi.currentBuildState && dfi.currentBuildState.aboutToBeBuilt && dfi.currentBuildState.aboutToBeBuilt.length);
                const neverBuiltBuildable = (dfi && dfi.buildable && dfi.lastBuild === undefined)
                const buildable = (dfi && dfi.buildable);

                if (beingBuilt) {
                    scope.uiDisplayState.showBeingBuilt = !error || error.errorType != 'com.dataiku.dip.exceptions.UnauthorizedException';
                }
                if (!beingBuilt && aboutToBeBuilt) {
                    scope.uiDisplayState.showAboutToBeBuilt = !error || error.errorType != 'com.dataiku.dip.exceptions.UnauthorizedException';
                }

                if (error && managed && neverBuiltBuildable) {
                    /* If there is an error, but it is a managed-buildable-never-built-dataset, then don't display the error,
                     and display the CTA instead */
                    scope.uiDisplayState.showError = false;
                    scope.uiDisplayState.showBuildEmptyCTA = !beingBuilt && !aboutToBeBuilt;
                } else if (error && managed && buildable) {
                    /* If there is an error, and it is managed-buildable, but has ever been built, then display error
                     and CTA if error requires to build dataset */
                    scope.uiDisplayState.showError = true;
                    scope.uiDisplayState.showBuildFailCTA = !beingBuilt && !aboutToBeBuilt && requiresDatasetBuild(error);
                } else {
                    /* Just an error on a non-managed-buildable dataset: just display it */
                    scope.uiDisplayState.showError = true;
                }

                /* Table is shown if: no error */
                if (!error) {
                    scope.uiDisplayState.showUI = true;
                    scope.error = null;
                } else {
                    scope.error = error;
                }
            }
        }
    };
});

})();


document.addEventListener('StartSimpleTableContentUpdate', function() {});
document.addEventListener('EndSimpleTableContentUpdate', function() {});

function dispatchCustomTimelineEvent(type, details) {
    var event = new CustomEvent(type, details);
    document.dispatchEvent(event);
}

(function(){
'use strict';

var app = angular.module('dataiku.datasets.foreign', []);

app.controller("ForeignDatasetCommonController", function($rootScope, $injector, $scope, $stateParams, DataikuAPI, WT1, TopNav, $state, DatasetsService, $timeout, GlobalProjectActions, DatasetUtils, DatasetCustomFieldsService, CreateModalFromTemplate) {
    TopNav.setItem(TopNav.ITEM_DATASET, $stateParams.datasetFullName);
    var loc = DatasetUtils.getLocFromFull($stateParams.datasetFullName);

    $scope.datasetLoc = loc;

    $scope.createAndPin = function(datasetSmartName) {
        var insight = {
            projectKey: $stateParams.projectKey,
            type: 'dataset_table',
            params: { datasetSmartName: datasetSmartName },
            name: datasetSmartName
        };
        CreateModalFromTemplate("/templates/dashboards/insights/create-and-pin-insight-modal.html", $scope, "CreateAndPinInsightModalController", function(newScope) {
            newScope.init(insight);
        });
    };

    DataikuAPI.datasets.getFullInfo($stateParams.projectKey, loc.projectKey, loc.name).success(function(data){
        //$scope.dataset = data; // Ugly must go
        $scope.datasetFullInfo = data;

        TopNav.setItem(TopNav.ITEM_DATASET, $stateParams.datasetFullName, {
            datasetType : data.dataset.type,
            name : $stateParams.datasetFullName,
            customFields: data.dataset.customFields,
            customFieldsPreview: DatasetCustomFieldsService.buildCustomFieldsPreviews(data.dataset.customFields)
        });
        $scope.editableDataset = $scope.datasetFullInfo.type == 'Inline';
    }).error(function(){
        setErrorInScope.apply($scope, arguments);
    });

    $scope.newAnalysis = function(){
        GlobalProjectActions.smartNewAnalysis($scope, $stateParams.datasetFullName);
    };

    $rootScope.$on('customFieldsSaved', function(event, item, customFields) {
        if (TopNav.sameItem(item, TopNav.getItem())) {
            let newItem = TopNav.getItem();
            newItem.data.customFields = customFields;
            newItem.data.customFieldsPreview = DatasetCustomFieldsService.buildCustomFieldsPreviews(customFields);
        }
    });
});

app.directive("foreignDatasetExplore", function($timeout, $q, Assert, DataikuAPI, WT1, TopNav, DatasetErrorCta, DatasetUtils, GraphZoomTrackerService) {
    return {
        scope: true,
        controller: function ($scope, $stateParams, $state) {
            var loc = DatasetUtils.getLocFromFull($stateParams.datasetFullName);

            /* ********************* Callbacks for shakerExploreBase ******************* */
            $scope.shakerHooks.saveForAuto = function() {
                var deferred = $q.defer();
                resetErrorInScope($scope);
                var shakerData = $scope.getShakerData();

                DataikuAPI.explores.saveScript($stateParams.projectKey, $stateParams.datasetFullName,
                    shakerData).success(function(data){
                    $scope.originalShaker = shakerData;
                    deferred.resolve();
                }).error(setErrorInScope.bind($scope));
                return deferred.promise;
            };


            /* ********************* Main ******************* */

            // Set base context and call baseInit
            Assert.inScope($scope, 'shakerHooks');

            TopNav.setLocation(TopNav.TOP_FLOW, 'datasets', TopNav.TABS_DATASET, "explore")
            GraphZoomTrackerService.setFocusItemByFullName("dataset", $stateParams.datasetFullName);

            $scope.table = null;
            $scope.scriptId = "__pristine__";
            $scope.shakerWritable = false;
            $scope.shakerReadOnlyActions = true;
            $scope.inputDatasetProjectKey = loc.projectKey;
            $scope.inputDatasetName = loc.name;
            $scope.inputDatasetSmartName = $stateParams.datasetFullName;

            WT1.event("shaker-explore-open");

            //For datasetErrorCTA directive (CTA in case of error while loading dataset sample)

            $scope.updateUiState = DatasetErrorCta.getupdateUiStateFunc($scope);

            $scope.$watch("datasetFullInfo", _ => $scope.updateUiState($scope.shakerState.runError), true);
            $scope.$watch("shakerState", _ => $scope.updateUiState($scope.shakerState.runError), true);
            $scope.$watch("table", _ => $scope.updateUiState($scope.shakerState.runError));

            // Load shaker, set the necessary stuff in scope and call the initial refresh
            DataikuAPI.explores.getScript($stateParams.projectKey, $stateParams.datasetFullName, $scope.scriptId).success(function(shaker) {
                $scope.shaker = shaker;
                $scope.shaker.origin = "DATASET_EXPLORE";
                $scope.shakerState.filtersExplicitlyAllowed = true;

                $scope.fixupShaker();
                $scope.requestedSampleId = null;
                $scope.refreshTable(false);

            }).error(setErrorInScope.bind($scope));
            // $scope.baseInit();

            $timeout(function() { $scope.$broadcast("tabSelect", "Filters") });

            // Load stuff for "edit last analysis"
            DataikuAPI.analysis.listOnDataset($stateParams.projectKey, $stateParams.datasetFullName).success(function(data) {
                data.sort(function(a, b) {
                    return b.lastModifiedOn - a.lastModifiedOn;
                });
                if (data.length) {
                    $scope.lastAnalysis = data[0];
                }
            }).error(setErrorInScope.bind($scope));
        }
    }
});

})();

(function(){
'use strict';

const app = angular.module('dataiku.managedfolder', []);


app.directive('managedFolderRightColumnSummary', function($state, $controller, $stateParams, $rootScope, FlowGraph, FlowGraphSelection,
    DataikuAPI, ComputablesService, DatasetsService, CreateModalFromTemplate, QuickView, ActiveProjectKey, ActivityIndicator, SelectablePluginsService) {
    return {
        templateUrl :'/templates/managedfolder/right-column-summary.html',

        link : function(scope, element, attrs) {

            $controller('ManagedFolderInsightPinningController', {$scope: scope});

            $controller('_TaggableObjectsMassActions', {$scope: scope});

            scope.$stateParams = $stateParams;
            scope.QuickView = QuickView;

            scope.getSmartName = function (projectKey, name) {
                if (projectKey == ActiveProjectKey.get()) {
                    return name;
                } else {
                    return projectKey + '.' + name;
                }
            }

            scope.refreshData = function() {
                let projectKey = ActiveProjectKey.get();

                DataikuAPI.managedfolder.getFullInfo(projectKey, projectKey , scope.getSmartName(scope.selection.selectedObject.projectKey, scope.selection.selectedObject.name)).success(function(data){
                    data.folder.zone = (scope.selection.selectedObject.usedByZones || [])[0] || scope.selection.selectedObject.ownerZone;
                    scope.objectFullInfo = data;
                    scope.odb = data.folder;
                    scope.isLocalFolder = scope.selection.selectedObject && scope.selection.selectedObject.projectKey == projectKey;
                    scope.folderData = data;
                }).error(setErrorInScope.bind(scope));
            };

            scope.$watch("selection.selectedObject",function() {
                if(scope.selection && scope.selection.selectedObject != scope.selection.confirmedItem) {
                    scope.odb = null;
                }
            });

            scope.$watch("selection.confirmedItem", function(nv, ov) {
                if (!nv) {
                    return;
                }
                if (!nv.projectKey) {
                    nv.projectKey = ActiveProjectKey.get();
                }
                scope.refreshData();
            });

            scope.createDatasetOnFolder = function() {
                $state.go("projects.project.datasets.new_with_type.settings", {type : 'FilesInFolder', fromOdbSmartId: scope.getSmartName(scope.odb.projectKey, scope.odb.id), zoneId: scope.odb.zone});
            };

        	scope.clearContents = function() {
                const taggableItems = [{
                    type: 'MANAGED_FOLDER',
                    projectKey: scope.odb.projectKey,
                    id: scope.odb.id,
                    displayName: scope.odb.name
                }];
                return ComputablesService.clear(scope, taggableItems);
    	    };

            scope.buildManagedFolder = function() {
                CreateModalFromTemplate("/templates/managedfolder/build-folder-modal.html", scope, "BuildManagedFolderController", function(newScope) {
                    newScope.projectKey = scope.odb.projectKey;
                    newScope.odbId = scope.odb.id;
                });
            };

            scope.selectablePlugins = SelectablePluginsService.listSelectablePlugins({'MANAGED_FOLDER' : 1});

            scope.$on("objectSummaryEdited", function() {
                DataikuAPI.managedfolder.save(scope.odb, {summaryOnly: true})
                .success(function(data) {
                    ActivityIndicator.success("Saved");
                }).error(setErrorInScope.bind(scope));
            });

            scope.saveCustomFields = function(newCustomFields) {
                let oldCustomFields = angular.copy(scope.odb.customFields);
                scope.odb.customFields = newCustomFields;
                return DataikuAPI.managedfolder.save(scope.odb, {summaryOnly: true})
                    .success(function() {
                        $rootScope.$broadcast('customFieldsSaved', TopNav.getItem(), scope.odb.customFields);
                    })
                    .error(function(a, b, c) {
                        scope.odb.customFields = oldCustomFields;
                        setErrorInScope.bind($scope)(a, b, c);
                    });
            };

            scope.editCustomFields = function() {
                DataikuAPI.managedfolder.get(scope.odb.projectKey, scope.odb.projectKey, scope.odb.id).success(function(data) {
                    let managedFolder = data;
                    if (!managedFolder) {
                        return;
                    }
                    let modalScope = angular.extend(scope, {objectType: 'MANAGED_FOLDER', objectName: managedFolder.name, objectCustomFields: managedFolder.customFields});
                    CreateModalFromTemplate("/templates/taggable-objects/custom-fields-edit-modal.html", modalScope).then(function(customFields) {
                        scope.saveCustomFields(customFields);
                    });
                }).error(setErrorInScope.bind(scope));
            };

            const customFieldsListener = $rootScope.$on('customFieldsSaved', scope.refreshData);
            scope.$on("$destroy", customFieldsListener);

            scope.zoomToOtherZoneNode = function(zoneId) {
                const otherNodeId = scope.selection.selectedObject.id.replace(/zone__.+?__managedfolder/, "zone__" + zoneId + "__managedfolder");
                if ($stateParams.zoneId) {
                    $state.go('projects.project.flow', Object.assign({}, $stateParams, { zoneId: zoneId, id: graphVizUnescape(otherNodeId) }))
                }
                else {
                    scope.zoomGraph(otherNodeId);
                    FlowGraphSelection.clearSelection();
                    FlowGraphSelection.onItemClick(scope.nodesGraph.nodes[otherNodeId]);
                }
            }

            scope.isMFZoneInput = function() {
                return scope.selection.selectedObject.usedByZones.length && scope.selection.selectedObject.usedByZones[0] != scope.selection.selectedObject.ownerZone;
            }
        }
    }
});

app.controller("ManagedFolderInsightPinningController", function($scope, $stateParams, SmartId, CreateModalFromTemplate, ActiveProjectKey) {
    $scope.createAndPinInsight = function(folder, filePath, isDirectory) {
        const insight = {
            projectKey: ActiveProjectKey.get(),
            type: 'managed-folder_content',
            params: { folderSmartId: SmartId.create(folder.id, $stateParams.sourceProjectKey ? $stateParams.sourceProjectKey : folder.projectKey), filePath:filePath, isDirectory: isDirectory},
            name: "Content of folder " + folder.name + (filePath ? filePath : '')
        };
        CreateModalFromTemplate("/templates/dashboards/insights/create-and-pin-insight-modal.html", $scope, "CreateAndPinInsightModalController", function(newScope) {
            newScope.init(insight);
        });
    }
});


app.controller("ManagedFolderBaseController", function($scope, $state, $stateParams, $q, $controller, $rootScope, WT1, TopNav, GlobalProjectActions, DataikuAPI, ComputablesService, ActiveProjectKey, SmartId, CreateModalFromTemplate, WebAppsService){

    $controller('ManagedFolderInsightPinningController', {$scope: $scope});

    $scope.createDatasetOnFolder = function() {
        $state.go("projects.project.datasets.new_with_type.settings", {type : 'FilesInFolder', fromOdbSmartId : SmartId.create($scope.baseOdb.id, $scope.baseOdb.projectKey), zoneId: $scope.baseOdb.zone})
    };

	$scope.clearContents = function() {
        const taggableItems = [{
            type: 'MANAGED_FOLDER',
            projectKey: $scope.baseOdb.projectKey,
            id: $scope.baseOdb.id,
            displayName: $scope.baseOdb.name
        }];
        return ComputablesService.clear($scope, taggableItems).then(function(){$scope.$broadcast('folder-contents-cleared')});
	};

    $scope.saveCustomFields = function(managedFolder, newCustomFields) {
        WT1.event('custom-fields-save', {objectType: 'MANAGED_FOLDER'});
        let oldCustomFields = angular.copy(managedFolder.customFields);
        managedFolder.customFields = newCustomFields;
        return DataikuAPI.managedfolder.save(managedFolder, {summaryOnly: true})
            .success(function() {
                $rootScope.$broadcast('customFieldsSaved', TopNav.getItem(), managedFolder.customFields);
            })
            .error(function(a, b, c) {
                managedFolder.customFields = oldCustomFields;
                setErrorInScope.bind($scope)(a, b, c);
            });
    };

    $scope.editCustomFields = function() {
        DataikuAPI.managedfolder.get(ActiveProjectKey.get(), ActiveProjectKey.get(), $stateParams.odbId).success(function(data) {
            let managedFolder = data;
            if (!managedFolder) {
                return;
            }
            let modalScope = angular.extend($scope, {objectType: 'MANAGED_FOLDER', objectName: managedFolder.name, objectCustomFields: managedFolder.customFields});
            CreateModalFromTemplate("/templates/taggable-objects/custom-fields-edit-modal.html", modalScope).then(function(customFields) {
                $scope.saveCustomFields(managedFolder, customFields);
            });
        }).error(setErrorInScope.bind($scope));
    };

	DataikuAPI.managedfolder.getFullInfo(ActiveProjectKey.get(), $stateParams.sourceProjectKey || ActiveProjectKey.get(), $stateParams.odbId).success(function(data) {
        $scope.baseOdb = data.folder;
        $scope.baseOdb.directAccessOnOriginal;
    }).error(setErrorInScope.bind($scope));
});

app.controller("ManagedFolderPageRightColumnActions", async function($controller, $scope, $rootScope, $stateParams, $state, DataikuAPI, ActiveProjectKey) {

    $controller('_TaggableObjectPageRightColumnActions', {$scope: $scope});

    $scope.folderData = (await DataikuAPI.managedfolder.getFullInfo(ActiveProjectKey.get(), $stateParams.sourceProjectKey || ActiveProjectKey.get(), $stateParams.odbId)).data;
    $scope.odb = $scope.folderData.folder;
    $scope.odb.description = $scope.odb.name;
    $scope.odb.name = $scope.odb.id;
    $scope.odb.nodeType = "LOCAL_MANAGED_FOLDER";
    $scope.odb.interest = $scope.folderData.interest;

    $scope.selection = {
        selectedObject : $scope.odb,
        confirmedItem : $scope.odb
    };

    function updateUserInterests() {
        DataikuAPI.interests.getForObject($rootScope.appConfig.login, "MANAGED_FOLDER", ActiveProjectKey.get(), $stateParams.odbId).success(function(data) {

            $scope.selection.selectedObject.interest.watching = data.watching;
            $scope.selection.selectedObject.interest.starred = data.starred;

        }).error(setErrorInScope.bind($scope));
    }

    updateUserInterests();
    const interestsListener = $rootScope.$on('userInterestsUpdated', updateUserInterests);
    $scope.$on("$destroy", interestsListener);

    $scope.isOnFolderObjectPage = function() {
        return $state.includes('projects.project.managedfolders.managedfolder');
    }
});


app.controller("NewManagedFolderController", function($scope, $state, DataikuAPI, WT1, $stateParams) {
    WT1.event("new-managed-folder-modal-open");

    $scope.newBox = {
        name : null,
        settings : {
            zone: $scope.getRelevantZoneId($stateParams.zoneId)
        }
    };

    function updateFolderConnection () {
        if ($scope.newBox.settings.$connection == null) return;
        $scope.newBox.settings.connectionId = $scope.newBox.settings.$connection.connectionName;
        $scope.newBox.settings.typeOptionId = $scope.newBox.settings.$connection.fsProviderTypes[0];
    }

    DataikuAPI.datasets.getManagedFolderOptionsNoContext($stateParams.projectKey).success(function(data) {
        $scope.managedDatasetOptions = data;
        $scope.managedDatasetOptions.connections = $scope.managedDatasetOptions.connections.filter(function(c) {return c.fsProviderTypes != null;});
        if (!$scope.newBox.settings.connectionId && $scope.managedDatasetOptions.connections.length) {
            $scope.newBox.settings.$connection = $scope.managedDatasetOptions.connections[0];
            updateFolderConnection();
        }
        $scope.partitioningOptions = [
            {"id" : "NP", "label" : "Not partitioned"},
        ].concat(data.projectPartitionings)

        $scope.newBox.settings.partitioningOptionId = "NP";
    }).error(setErrorInScope.bind($scope));

    $scope.$watch("newBox.settings.$connection", updateFolderConnection);

    $scope.create = function(){
        resetErrorInScope($scope);
        WT1.event("new-managed-folder-modal-create");
        DataikuAPI.datasets.newManagedFolder($stateParams.projectKey, $scope.newBox.name, $scope.newBox.settings).success(function(data) {
            $scope.dismiss();
            $state.go("projects.project.managedfolders.managedfolder.view", {odbId: data.id})
        }).error(setErrorInScope.bind($scope));
    }
});


app.controller("ManagedFolderSummaryController", function($scope, $rootScope, $stateParams, DataikuAPI, TopNav, $timeout, ActivityIndicator) {
    TopNav.setLocation(TopNav.TOP_FLOW, null, TopNav.TABS_MANAGED_FOLDER, "summary");

    DataikuAPI.managedfolder.getSummary($stateParams.projectKey, $stateParams.odbId).success(function(data) {
        $scope.odb = data.object;
        $scope.objectInterest = data.interest;
        $scope.objectTimeline = data.timeline;

        TopNav.setItem(TopNav.ITEM_MANAGED_FOLDER, $stateParams.odbId, {name: $scope.odb.name});
        TopNav.setPageTitle($scope.odb.name + " - Managed folder");
    }).error(setErrorInScope.bind($scope));

    $scope.refreshTimeline = function() {
        DataikuAPI.timelines.getForObject($stateParams.projectKey, "MANAGED_FOLDER", $stateParams.odbId).success(function(data){
            $scope.objectTimeline = data;
        }).error(setErrorInScope.bind($scope));
    };

    /* Auto save */
    function saveManagedFolder() {
        DataikuAPI.managedfolder.save($scope.odb, {summaryOnly: true}).success(function(data) {
            ActivityIndicator.success("Saved");
        }).error(setErrorInScope.bind($scope));
    }
    $scope.$watch("odb", function(nv, ov) {
        if (nv && ov) {
            saveManagedFolder();
        }
    }, true);
    $scope.$on("objectSummaryEdited", saveManagedFolder);

    $scope.$on('customFieldsSummaryEdited', function(event, customFields) {
        $scope.saveCustomFields($scope.odb, customFields);
    });
});


app.controller("ManagedFolderViewController", function($scope, DataikuAPI, $q, CreateModalFromTemplate, $state, $stateParams, TopNav, $controller, Fn, $filter){
    TopNav.setLocation(TopNav.TOP_FLOW, null, TopNav.TABS_MANAGED_FOLDER, "view");
    TopNav.setItem(TopNav.ITEM_MANAGED_FOLDER, $stateParams.odbId);

    $scope.snippetSource = 'SAVED';

    DataikuAPI.managedfolder.get($stateParams.projectKey, $stateParams.sourceProjectKey || $stateParams.projectKey, $stateParams.odbId).success(function(data) {
        $scope.odb = data;
        TopNav.setItem(TopNav.ITEM_MANAGED_FOLDER, $stateParams.odbId, {name:data.name});
    }).error(setErrorInScope.bind($scope));
});


app.controller("ManagedFolderUploadOverwriteModalController", function($scope, $stateParams, DataikuAPI) {
	$scope.selectAll = false;
	function applySelectAll() {
		if ($scope.alreadyPresent != null) {
			$scope.alreadyPresent.forEach(function(file) {file.overwrite = $scope.selectAll;});
		}
	};
	$scope.$watch("selectAll", function(nv, ov) {applySelectAll();});

	$scope.$watch("alreadyPresent", function(nv, ov) {
		if (nv == null) return;

		applySelectAll();

		$scope.cancel = function() {
			$scope.dismiss();
		};

		$scope.confirm = function() {
			if ( $scope.forceUploadFiles == undefined) return;

			const overwriteFiles = [];
			$scope.alreadyPresent.forEach(function(file) {
				if ( file.overwrite ) {
					overwriteFiles.push(file);
				}
			});
			$scope.forceUploadFiles(overwriteFiles);
			$scope.dismiss();
		};
	});
});

app.controller("MoveItemModalController", function($scope, $rootScope, $stateParams, DataikuAPI, CreateModalFromTemplate, FutureWatcher, ProgressStackMessageBuilder) {
    $scope.browse = function(path) {
        return DataikuAPI.managedfolder.browse($stateParams.sourceProjectKey || $stateParams.projectKey, $stateParams.odbId, path);
    };
    $scope.parentPath = $scope.odbListing.fullPath; // not null since there is an item to move
    $scope.canBrowse = function(item) {
        return item.directory && $scope.items.findIndex(_ => item.fullPath === _.fullPath) === -1;
    }

    $scope.canSelect = function(item) {
        return false;
    }

    $scope.confirm = function() {
        const prefix = $scope.parentPath + ($scope.parentPath.charAt($scope.parentPath.length - 1) == '/' ? '' : '/');
        const items = $scope.items.map(_ => ({
            "fromPath": _.fullPath,
            "toPath": prefix + _.name,
            "isDirectory": _.directory
        }));
        const parentScope = $scope.$parent;

        $scope.dismiss();

        DataikuAPI.managedfolder.moveItems($stateParams.sourceProjectKey || $stateParams.projectKey, $stateParams.odbId, items).success(function(initialResponse) {
            CreateModalFromTemplate("/templates/managedfolder/move-items-progress-modal.html", parentScope, null, function(progressScope) {
                progressScope.title = "Moving items...";

                progressScope.abort = function(){
                    DataikuAPI.futures.abort(initialResponse.jobId)
                        .success(() => {
                            progressScope.refreshDirectory();
                        })
                        .error(setErrorInScope.bind(progressScope));
                };

                progressScope.done = false;
                progressScope.aborted = false;
                FutureWatcher.watchJobId(initialResponse.jobId)
                    .success(function(data) {
                        progressScope.done = data.hasResult;
                        progressScope.aborted = data.aborted;
                        progressScope.futureResponse = null;
                        progressScope.finalResponse = data.result;
                        progressScope.errors = data.result.messages || [];

                        const movedItems = data.result.paths;

                        // remove items from list that were moved successfully
                        progressScope.odbListing.children = progressScope.odbListing.children.filter((_) => {
                            return !(movedItems && movedItems.find((x) => _.name === x.name));
                        });
                        progressScope.clearSelectedItemsAndPreview();

                        //check if, while moving, we created a folder in the current folder, if so we need to refresh it :(
                        let p = '';
                        const newItem = movedItems[0]; // only need to use one item to check
                        if (newItem) {
                            for (let i = 1; i < newItem.pathElts.length; i++) {
                                p += "/" + newItem.pathElts[i];
                                if (p == progressScope.odbListing.safeFullPath && i < newItem.pathElts.length - 1) {
                                    let f = newItem.pathElts[i + 1];
                                    if (progressScope.odbListing.children.filter(e => e.name == f).length == 0) {
                                        progressScope.refreshDirectory();
                                    }
                                }
                            }
                        }

                        // close immediately if no errors were found
                        if (!progressScope.errors.length) {
                            progressScope.dismiss();
                        }
                    }).update(function(data){
                        progressScope.percentage = ProgressStackMessageBuilder.getPercentage(data.progress);
                        progressScope.futureResponse = data;
                        progressScope.stateLabels = ProgressStackMessageBuilder.build(progressScope.futureResponse.progress, true);
                    }).error(function(data, status, headers) {
                        progressScope.done = true;
                        progressScope.futureResponse = null;
                        setErrorInScope.bind(progressScope)(data, status, headers);
                    });
            });
        }).error(setErrorInScope.bind($scope));
    }
});


app.controller("ManagedFolderSettingsController", function($scope, $rootScope, $stateParams, DataikuAPI, TopNav, $timeout, ActivityIndicator) {
    TopNav.setLocation(TopNav.TOP_FLOW, null, TopNav.TABS_MANAGED_FOLDER, "settings");

    $scope.uiState = {activeTab : 'storage', selectedProviderType : null};

    $scope.anyPipelineTypeEnabled = function() {
        return $rootScope.projectSummary.sparkPipelinesEnabled || $rootScope.projectSummary.sqlPipelinesEnabled;
    };

    $scope.storageBackends = [];
    DataikuAPI.datasets.listFSProviderTypes(true).success(function(data) {
    	$scope.storageBackends = data;
    });

    $scope.$watch("uiState.selectedProviderType", function() {
    	if ($scope.odb == null) return;
    	if ($scope.odb.type && $scope.uiState.selectedProviderType && $scope.odb.type != $scope.uiState.selectedProviderType) {
    	    $scope.odb.params.$resetConnection = true;
    	}
    	$scope.odb.type = $scope.uiState.selectedProviderType;
    });

    $scope.detectScheme = function() {
        return DataikuAPI.managedfolder.detectPartitioning($scope.odb);
    };

    $scope.testScheme = function() {
        return DataikuAPI.managedfolder.testPartitioning($scope.odb);
    };

    $scope.onCoreParamsChanged = function() {
        // noop
    };

    DataikuAPI.managedfolder.get($stateParams.projectKey, $stateParams.sourceProjectKey || $stateParams.projectKey, $stateParams.odbId).success(function(data) {
        $scope.odb = data;
        $scope.uiState.selectedProviderType = $scope.odb.type;
        $scope.origOdb = angular.copy(data);
        $scope.dataset = {flowOptions: $scope.odb.flowOptions}; // to reuse the same template
        TopNav.setItem(TopNav.ITEM_MANAGED_FOLDER, $stateParams.odbId, {name:data.name});
        TopNav.setPageTitle(data.name + " - Managed folder");
    }).error(setErrorInScope.bind($scope));

    $scope.settingsIsDirty = function() {
        return $scope.odb && !angular.equals($scope.odb, $scope.origOdb);
    };

    $scope.saveOdb = function() {
        DataikuAPI.managedfolder.save($scope.odb).success(function(data) {
            $scope.odb = data;
            $scope.uiState.selectedProviderType = $scope.odb.type;
            $scope.origOdb = angular.copy(data);
            $scope.dataset.flowOptions = $scope.odb.flowOptions;
            ActivityIndicator.success("Saved");
        }).error(setErrorInScope.bind($scope));
    };
});


app.controller("ManagedFolderStatusController", function($scope, $rootScope, $stateParams, DataikuAPI, TopNav, $timeout) {
    TopNav.setLocation(TopNav.TOP_FLOW, null, TopNav.TABS_MANAGED_FOLDER, "status");

    DataikuAPI.managedfolder.get($stateParams.projectKey, $stateParams.projectKey, $stateParams.odbId).success(function(data) {
        $scope.odb = data;
        $scope.dataset = {flowOptions: data.flowOptions}; // to reuse the same template
        TopNav.setItem(TopNav.ITEM_MANAGED_FOLDER, $stateParams.odbId, {name:data.name});
        TopNav.setPageTitle(data.name + " - Managed folder");
    }).error(setErrorInScope.bind($scope));

});

/*
 * stuff shared with the pinboard to present folder and/or their contents
 */
app.directive('managedFolderContentsView', function(DataikuAPI, $rootScope, $q, CreateModalFromTemplate, $state, $stateParams, TopNav, $controller, Dialogs, Fn, openDkuPopin, SmartId, $timeout, Logger, GraphZoomTrackerService, FutureWatcher, ProgressStackMessageBuilder, VirtualWebApp, WebAppsService, PluginConfigUtils) {
    return {
        restrict: 'AE',
        templateUrl: '/templates/managedfolder/fragments/contents-view.html',
        replace: true,
        scope : {
            odb : '=',
            readOnly : '=',
            canDownload : '=',
            createInsight : '=',
            subFolderStartingPoint : '<?'
        },
        link: function($scope, element, attrs){
            $scope.appConfig = $rootScope.appConfig;
            $scope.$state = $state;
            $scope.projectSummary = $rootScope.projectSummary;
            
            $scope.setErrorInThisScope = setErrorInScope.bind($scope);
            GraphZoomTrackerService.setFocusItemByName("managedfolder", $stateParams.odbId);

            /*
             * Loading folder content
             */
            if (!$scope.subFolderStartingPoint) {
                $scope.subFolderStartingPoint = "/";
            }
            $scope.odbListing = {items: null, safeFullPath: '/'};
            function refreshFolderListing (path = $scope.subFolderStartingPoint) {
                if ($scope.odb == null) return;
                if ($scope.odb.partitioning && $scope.odb.partitioning.dimensions.length > 0 && $scope.odb.selection == null) {
                    $scope.odb.selection = {partitionSelectionMethod: "ALL"};
                }
                DataikuAPI.managedfolder.browse($scope.odb.projectKey, $scope.odb.id, path).success(function(data){
                    $scope.odbListing = data;
                    $scope.odbListing.safeFullPath = $scope.odbListing.fullPath == null ? '/' : $scope.odbListing.fullPath;
                    $scope.currentDirectoryParentList = getParentDirectoryList($scope.odbListing.pathElts);
                    $scope.clearSelectedItemsAndPreview();
                    $scope.query = "";
                }).error(setErrorInScope.bind($scope));
            };

            // interactivity
            $scope.$watch('odb', function() {
                refreshFolderListing();
                if (!$scope.readOnly && $scope.odb) {
                    $scope.skins = [$scope.defaultViewSkin].concat(WebAppsService.getSkins('MANAGED_FOLDER', null, $scope.odb.contentType));
                }
            }); // shallow watch, to get the list when the folder is loaded
            $scope.$on("folder-contents-cleared", function() {
                $scope.odbListing = {items:[], safeFullPath: '/'}; // change the entire object so that the shallow watch below triggers
            });

            $scope.browseDirectory = function(fullPath) {
                refreshFolderListing(fullPath);
            };

            $scope.refreshDirectory = function() {
                refreshFolderListing($scope.odbListing.safeFullPath)
            }

            function getParentDirectoryList(pathElts) {
                let list = [];
                let fullPath = "";
                for (let i = 0; i < pathElts.length; i++) {
                    let name = pathElts[i];
                    fullPath = fullPath + "/" + name;
                    list.push({
                        name: name,
                        fullPath: fullPath
                    });
                }
                return list;
            };

            /*
             * Preview
             */
            $scope.setSelectedItems = function(selectedItems, anchorItem, lastItemAddedToSelection) {
                $scope.selectedItems = selectedItems;
                $scope.anchorItem = anchorItem; // when shift clicking, keep track of the first item selected
                $scope.lastItemAddedToSelection = lastItemAddedToSelection;
            };

            $scope.removeSelectedItem = function(item) {
                if ($scope.selectedItems.length == 1) {
                    $scope.clearSelectedItemsAndPreview()
                } else {
                    const itemIndex = $scope.selectedItems.findIndex(_ => _.fullPath === item.fullPath);
                    const anchorIndex = $scope.selectedItems.findIndex(_ => _.fullPath === $scope.anchorItem.fullPath);
                    const lastItemAddedToSelectionIndex = $scope.selectedItems.findIndex(_ => _.fullPath === $scope.lastItemAddedToSelection.fullPath);
                    const reversedOrderSelection =  anchorIndex > lastItemAddedToSelectionIndex;

                    let newSelectedItems = $scope.selectedItems.slice();
                    newSelectedItems.splice(itemIndex, 1);
                    let newAnchorItem = $scope.anchorItem;
                    let newLastItemAddedToSelection = $scope.lastItemAddedToSelection;

                    if ($scope.anchorItem && $scope.anchorItem.fullPath == item.fullPath) {
                        newAnchorItem = newSelectedItems[reversedOrderSelection ? newSelectedItems.length - 1 : 0];
                    }

                    if ($scope.lastItemAddedToSelection && $scope.lastItemAddedToSelection.fullPath == item.fullPath) {
                        newLastItemAddedToSelection = newSelectedItems[reversedOrderSelection ? 0 : newSelectedItems.length - 1];
                    }

                    $scope.setSelectedItems(newSelectedItems, newAnchorItem, newLastItemAddedToSelection);
                }
            }

            $scope.clearSelectedItemsAndPreview = function() {
                $scope.previewedItem = null;
                $scope.setSelectedItems([], null, null);
            };

            $scope.setSelectedItemAndPreview = function(item) {
                $scope.previewFile(item);
                $scope.setSelectedItems([item], item, item);
            };

            $scope.addSelectedItemAndPreview = function(item) {
                $scope.previewFile(item);
                let selectedItems = $scope.selectedItems.length > 0 ? $scope.selectedItems.concat([item]) : [item];
                let anchorItem = $scope.selectedItems.length > 0 ? $scope.anchorItem : item;
                $scope.setSelectedItems(selectedItems, anchorItem, item);
            };


            $scope.clearSelectedItemsAndPreview();

            $scope.onClickOnItem = function(e, item, items) {
                window.getSelection().removeAllRanges();
                if (e.shiftKey || e.ctrlKey || e.metaKey) {
                    $scope.updateSelectedItems(e, item, items)
                } else {
                    if (item.directory) {
                        $scope.browseDirectory(item.fullPath);
                    } else {
                        $scope.setSelectedItemAndPreview(item);
                    }
                }
            };

            $scope.updateSelectedItems = function(e, item, items) {
                if ($scope.selectedItems.length && e.shiftKey) {
                    $scope.setSelectedItems(getItemsInRange(item, items), !$scope.selectedItems || $scope.selectedItems.length === 0 ? item : $scope.anchorItem, item);
                } else {
                    toggleItemSelection(item);
                }
            }

            function toggleItemSelection(item) {
                const itemIndex = $scope.selectedItems.findIndex(_ => _.fullPath === item.fullPath);

                if (itemIndex < 0) {
                    $scope.addSelectedItemAndPreview(item);
                } else {
                    if ($scope.selectedItems.length == 1) {
                        $scope.clearSelectedItemsAndPreview()
                    } else {
                        $scope.removeSelectedItem(item);
                        if ($scope.previewedItem && $scope.previewedItem.fullPath == item.fullPath) {
                            $scope.previewedItem = null;
                        }
                    }
                }
            }

            function getItemsInRange(selectedItem, items) {
                let start = items.findIndex(_ => _.fullPath === $scope.anchorItem.fullPath);
                let end = items.findIndex(_ => _.fullPath === selectedItem.fullPath);

                // swap if second item is lower index
                if (start > end) {
                    [start, end] = [end, start];
                }

                return items.slice(start, end + 1);
            }

            $scope.isSelected = function(item) {
                return $scope.selectedItems.indexOf(item) >= 0;
            }

            $scope.previewFile = function(item) {
                $scope.skinState.itemSkins = [$scope.defaultViewItemSkin];
                $scope.skinState.itemSkin = $scope.defaultViewItemSkin;
                if (item.directory) {
                    $scope.previewedItem = {type:'DIRECTORY', itemPath:item.fullPath, name:item.name, size:item.size, directory:true};
                } else {
                    DataikuAPI.managedfolder.previewItem($stateParams.projectKey, $scope.odb.projectKey, $scope.odb.id, item.fullPath).success(function(data){
                        $scope.previewedItem = data;
                        if (!$scope.readOnly) {
                            $scope.skinState.itemSkins = [$scope.defaultViewItemSkin].concat(WebAppsService.getSkins('MANAGED_FOLDER', data.itemPath, data.contentType));
                        }
                    }).error(setErrorInScope.bind($scope));
                }
            };

            $scope.deletePreviewedItem = function(e) {
                if ($scope.previewedItem == null)
                    return;
                let item = null;
                $scope.odbListing.children.forEach(function(i) {
                    if ($scope.previewedItem.itemPath == i.fullPath) {
                        item = i;
                    }
                });
                if (item == null)
                    return;

                const index = $scope.odbListing.children.indexOf(item);
                if (index >= 0) {
                    Dialogs.confirm($scope,'File deletion','Are you sure you want to delete ' + item.name + ' ?').then(function() {
                        $scope.removeFile(item.fullPath);
                        DataikuAPI.managedfolder.deleteItems($stateParams.sourceProjectKey || $stateParams.projectKey, $scope.odb.id, [item.fullPath]).success(function(){
                            $scope.odbListing.children.splice(index, 1);
                        }).error(setErrorInScope.bind($scope));
                    });
                }
            };

            $scope.decompressPreviewedFile = function(e) {
                if ($scope.previewedItem == null)
                    return;
                let item = null;
                $scope.odbListing.children.forEach(function(i) {
                    if ($scope.previewedItem.itemPath == i.fullPath) {
                        item = i;
                    }
                });
                if (item == null) {
                    Logger.info("Could not find item to decompress", $scope.previewedItem.itemPath);
                    return;
                }

                $scope.decompressFile(item);
            };

            $scope.downloadPreviewedFile = function() {
                if ($scope.previewedItem == null)
                    return;
                downloadURL(DataikuAPI.managedfolder.getDownloadItemURL($stateParams.projectKey, $scope.odb.projectKey,  $scope.odb.id, $scope.previewedItem.itemPath));
            };

            $scope.decompressFile = function(item) {
                DataikuAPI.managedfolder.decompressItem($stateParams.sourceProjectKey || $stateParams.projectKey, $scope.odb.id, item.fullPath).success(function(data){
                    $scope.clearSelectedItemsAndPreview();
                    refreshFolderListing($scope.odbListing.safeFullPath);
                }).error(setErrorInScope.bind($scope));
            };

            $scope.removeFile = function(itemPath) {
                if ($scope.previewedItem != null && $scope.previewedItem.itemPath == itemPath) { 
                    $scope.clearSelectedItemsAndPreview();
                }
            };

            $scope.getFilesSize = function() {
                if ($scope.odbListing && $scope.odbListing.children) {
                    return $scope.odbListing.children.map(Fn.prop("size")).reduce(Fn.SUM, 0);
                }
            }

            /*
             *
             */

            $scope.saveSampling = function() {
                DataikuAPI.managedfolder.saveSampling($scope.odb.projectKey, $scope.odb.id, $scope.odb.selection).success(function(data){
                    refreshFolderListing();
                }).error(setErrorInScope.bind($scope));
            };

            $scope.getPartitionsList = function() {
                return DataikuAPI.managedfolder.listPartitionsWithName($scope.odb.projectKey, $scope.odb.id)
                    .error(setErrorInScope.bind($scope))
                    .then(function(ret) {
                        return ret.data;
                    });
            };

            /*
             * Menus
             */

            $scope.openHeaderMenu = function($event) {
                function isElsewhere() {
                    return true;
                }

                var template = '<ul id="qa_folder-action-dropdown-menu" class="dropdown-menu">'
                    +    '<li ng-if="!readOnly"><a id="qa_folder-action-publish-button" ng-click="createInsight(odb, odbListing.safeFullPath, true)">Publish...</a></li>'
                    +    '<li><a ng-click="downloadFolder(odbListing.safeFullPath)">Download</a></li>'
                    +    '<li ng-if="!readOnly"><a id="qa_folder-action-create-dataset-button" ng-click="createDatasetOnCurrentFolder()">Create a dataset...</a></li>'
                    +    '<li ng-if="!readOnly" style="border-top: 1px #eee solid;"><a onclick="$(\'#hidden-input-file\').click();">Add File...</a></li>'
                    +    '<li ng-if="!readOnly && odb.isDirectoryAware"><a id="qa_folder-action-add-folder-button" ng-click="createSubFolder()" style="border-top: 1px #eee solid;">New Folder...</a></li>'
                    +'</ul>'
                var dkuPopinOptions = {
                    template: template,
                    isElsewhere: isElsewhere
                };
                openDkuPopin($scope, $event, dkuPopinOptions);
            };

            var createDatasetOnObject = function(itemPath, isDirectory) {
                $state.go("projects.project.datasets.new_with_type.settings", {type : 'FilesInFolder', fromOdbSmartId : SmartId.create($scope.odb.id, $scope.odb.projectKey), fromOdbItemPath: itemPath, fromOdbItemDirectory: isDirectory ? "true" : "false"})
            };
            $scope.createDatasetOnCurrentFolder = function() {
                createDatasetOnObject($scope.odbListing.safeFullPath, true);
            };
            $scope.createDatasetOnItem = function(item) {
                createDatasetOnObject(item.fullPath, item.directory);
            };

            /*
             * CRUD
             */

            $scope.createSubFolder = function() {
                Dialogs.prompt($scope, 'New Folder', 'Folder Name').then(function(newName) {
                    let path = $scope.odbListing.safeFullPath;
                    path += path.endsWith("/") ? newName : "/" + newName;
                    DataikuAPI.managedfolder.createSubFolder($stateParams.sourceProjectKey || $stateParams.projectKey, $scope.odb.id, path).success(function() {
                        refreshFolderListing($scope.odbListing.safeFullPath);
                    }).error(setErrorInScope.bind($scope));
                });
            };

            $scope.deleteItems = function(items) {
                let remainingItems = $scope.odbListing.children.filter(_ => items.indexOf(_) === -1);
                if (remainingItems && remainingItems.length !== $scope.odbListing.children.length) {
                    var objectKind = items.length > 1 ? 'these ' + items.length + ' selected items' : ('this ' + (items[0].directory ? 'folder and all its contents' : 'file'));
                    Dialogs.confirm($scope, 'File deletion', 'Are you sure you want to delete ' + objectKind + '?').then(function () {
                        DataikuAPI.managedfolder.deleteItems($stateParams.sourceProjectKey || $stateParams.projectKey, $scope.odb.id, items.map(_ => _.fullPath)).success(function (initialResponse) {
                            CreateModalFromTemplate("/templates/managedfolder/move-items-progress-modal.html", $scope, null, function(progressScope) {
                                progressScope.title = "Deleting items...";

                                progressScope.abort = function(){
                                    DataikuAPI.futures.abort(initialResponse.jobId)
                                        .success(() => {
                                            progressScope.refreshDirectory();
                                        })
                                        .error(setErrorInScope.bind(progressScope));
                                };

                                progressScope.done = false;
                                progressScope.aborted = false;
                                FutureWatcher.watchJobId(initialResponse.jobId)
                                    .success(function(data) {
                                        progressScope.done = data.hasResult;
                                        progressScope.percentage = 100;
                                        progressScope.aborted = data.aborted;
                                        progressScope.futureResponse = null;
                                        progressScope.finalResponse = data.result;
                                        progressScope.errors = data.result.messages || [];
                                        let deletedItems = data.result.paths;

                                        if (!progressScope.errors.length) {
                                            progressScope.dismiss();
                                        } else {
                                            remainingItems = $scope.odbListing.children.filter(_ => deletedItems.indexOf(_.fullPath) === -1);
                                        }

                                        $scope.setChildren(remainingItems);
                                    }).update(function(data){
                                        progressScope.percentage = ProgressStackMessageBuilder.getPercentage(data.progress);
                                        progressScope.futureResponse = data;
                                        progressScope.stateLabels = ProgressStackMessageBuilder.build(progressScope.futureResponse.progress, true);
                                    }).error(function(data, status, headers) {
                                        progressScope.done = true;
                                        progressScope.futureResponse = null;
                                        setErrorInScope.bind(progressScope)(data, status, headers);
                                    });
                            });
                        }).error(setErrorInScope.bind($scope));
                    });
                }
            };

            // callback for the dropping of files or clicking on the droparea
            $scope.uploadFiles = function(files, destination = $scope.odbListing.safeFullPath) {
                // try to not send a file that's already on the server
                let alreadyPresent = [];
                let filesToUpload = [];
                for(let i = 0, len = files.length; i < len ; i++) {
                    let file = files[i];
                    let found = false;
                    if (destination == $scope.odbListing.safeFullPath) {
                        $scope.odbListing.children.forEach(function(item) {found |= item.fullPath == getPathForFileToUpload(file, destination);});
                    }
                    if ( found ) {
                        alreadyPresent.push(file);
                    } else {
                        filesToUpload.push(file);
                    }
                }

                if (alreadyPresent.length > 0) {
                    CreateModalFromTemplate("/templates/managedfolder/upload-overwrite.html", $scope, "ManagedFolderUploadOverwriteModalController", function(newScope) {
                        newScope.projectKey = $stateParams.sourceProjectKey || $stateParams.projectKey;
                        newScope.alreadyPresent = alreadyPresent;
                        newScope.forceUploadFiles = function(files) {
                            forceUploadFiles(files, destination);
                        }
                    });
                }

                filesToUpload.forEach(function(fileToUpload) {uploadOneFile(fileToUpload, destination);});
            };

            $scope.setChildren = function(items) {
                $scope.odbListing.children = items;
            }

            function getPathForFileToUpload(fileToUpload, destination) {
                let path = destination;
                path += destination.charAt(destination.length - 1) == "/" ? fileToUpload.name : "/" + fileToUpload.name;
                return path;
            }

            function uploadOneFile(fileToUpload, destination = $scope.odbListing.safeFullPath) {
                let path = getPathForFileToUpload(fileToUpload, destination);
                var file = {
                    path: path,
                    name: fileToUpload.name,
                    size: fileToUpload.size,
                    lastModified: fileToUpload.lastModified,
                    progress: 0
                };
                if (destination == $scope.odbListing.safeFullPath) {
                    $scope.odbListing.children.push(file);
                }
                DataikuAPI.managedfolder.uploadItem($stateParams.sourceProjectKey || $stateParams.projectKey, $scope.odb.id, file.path, fileToUpload, destination == $scope.odbListing.safeFullPath, function (e) {
                    if (e.lengthComputable) {
                        $scope.$apply(function () {
                            file.progress = Math.round(e.loaded * 100 / e.total);
                        });
                    }
                }).then(function (data) {
                    //success
                    if (destination == $scope.odbListing.safeFullPath) {
                        let index = $scope.odbListing.children.indexOf(file);
                        $scope.odbListing.children = $scope.odbListing.children.slice(0, index).concat([JSON.parse(data)]).concat($scope.odbListing.children.slice(index + 1));
                    }
                }, function(payload){
                    // delete faulty file
                    let index = $scope.odbListing.children.indexOf(file);
                    if (index > -1) {
                        $scope.odbListing.children.splice($scope.odbListing.children.indexOf(file), 1);
                    }
                    setErrorInScope.bind($scope)(JSON.parse(payload.response), payload.status, function(h){return payload.getResponseHeader(h)});
                });
            }

            function forceUploadFiles(filesToUpload, destination = $scope.odbListing.safeFullPath) {
                filesToUpload.forEach(function(fileToUpload) {
                    let index = -1;
                    let itemPath = getPathForFileToUpload(fileToUpload, destination);
                    $scope.odbListing.children.forEach(function(item, i) {
                        if (item.fullPath == itemPath) {
                            index = i;
                        }
                    });
                    if (index >= 0) {
                        $scope.removeFile(itemPath);
                        $scope.odbListing.children.splice(index, 1);
                        DataikuAPI.managedfolder.deleteItems($stateParams.sourceProjectKey || $stateParams.projectKey, $scope.odb.id, [itemPath]).success(function(data){
                            uploadOneFile(fileToUpload);
                        }).error(setErrorInScope.bind($scope));
                    }
                });
            };

            $scope.uploadFilesAfterDigest = function(files, element) {
                $timeout(function() {
                    $scope.uploadFiles(files);
                    if (element) {
                        $(element).val("");
                    }
                }, 0);
            };

            $scope.downloadFile = function(path) {
                downloadURL(DataikuAPI.managedfolder.getDownloadItemURL($stateParams.projectKey, $scope.odb.projectKey, $scope.odb.id, path));
            };

            $scope.downloadFolder = function(path) {
                downloadURL(DataikuAPI.managedfolder.getDownloadFolderURL($stateParams.projectKey, $scope.odb.projectKey, $scope.odb.id, path));
            };
            
            /*
             * Skins
             */
            $scope.defaultViewSkin = {id:'Default view'};
            $scope.defaultViewItemSkin = {id:'Default view'};
            $scope.skins = [$scope.defaultViewSkin];
            $scope.webAppConfig = {}
            $scope.webAppType = null;
            $scope.runningWebAppId = null;

            $scope.$watch('uiState.skin', function() {
                if ($scope.uiState.skin === $scope.defaultViewSkin) return;
                VirtualWebApp.changeSkin($scope, 'MANAGED_FOLDER', $scope.uiState.skin, $scope.uiState, 'skin-holder',
                    $scope.odb.id, null, true);
            }, true);

            /*
             * UI Utils
             */
            $scope.getNameFromPath = function(path) {
                return path.replace(/^.*[\\\/]/, '')
            }

            $scope.uiState = {
                canDrop: false,
                skin: $scope.defaultViewSkin
            }
            $scope.skinState = {
                defaultViewItemSkin: $scope.defaultViewItemSkin,
                itemSkins: [$scope.defaultViewItemSkin],
                itemSkin: $scope.defaultViewItemSkin
            }
        }
    }
});


app.directive('managedFolderContentsPreview', function(Logger, VirtualWebApp, DataikuAPI, $stateParams, $http) {
    return {
        restrict: 'AE',
        templateUrl: '/templates/managedfolder/fragments/contents-preview.html',
        replace: true,
        scope : {
            odb : '=',
            previewedItem : '=',
            readOnly : '=',
            decompressPreviewedFile : '=',
            skinState : '='
        },
        link: function($scope, element, attrs){
            Logger.info("Initialize previewing", $scope.$id);
            $scope.destroyingScope = false;
            $scope.createdSVGPreviewURL = null;  // Empty object URL to store the current SVG file preview
            function setSVGPreviewURL(data) {
                if($scope.createdSVGPreviewURL) {
                    URL.revokeObjectURL($scope.createdSVGPreviewURL);
                }
                if(data) {
                    $scope.createdSVGPreviewURL = URL.createObjectURL(data);
                }
            }
            $scope.$watch('previewedItem', function() {
                if ($scope.previewedItem == null) return;
                Logger.info("Initialize preview item", $scope.$id, $scope.previewedItem.itemPath);
                // build up the image url (won't be used unless the previewItem's type is IMAGE OR PDF)
                if ($scope.previewedItem.contentType == "image/svg+xml") {
                    // Download as Blob, convert to URL and put in image tag to prevent XSS attack
                    // (of directly serving SVG as GET with SVG MIME type & inline content disposition)
                    // see ch59676, https://digi.ninja/blog/svg_xss.php
                    $http({
                        url:  DataikuAPI.managedfolder.getDownloadItemURL($stateParams.projectKey, $scope.odb.projectKey,  $scope.odb.id, $scope.previewedItem.itemPath),
                        method: 'GET',
                        responseType: 'blob',
                        transformResponse: function(data){
                            return new Blob([data], {type: $scope.previewedItem.contentType});
                        }
                    }).then(function({data}){
                        if ($scope.destroyingScope) return;
                        setSVGPreviewURL(data);
                        $scope.previewedItem.imageURL = $scope.createdSVGPreviewURL;
                    });
                } else {
                    // XSS-safe types can use GET & proper content type
                    $scope.previewedItem.imageURL = '/dip/api/managedfolder/preview-image?projectKey=' + $scope.odb.projectKey + '&odbId=' + $scope.odb.id + '&itemPath=' + encodeURIComponent($scope.previewedItem.itemPath) + '&contentType=' + encodeURIComponent($scope.previewedItem.contentType);
                }
                $scope.webAppType = null; // reset webapp
                if ($scope.previewedItem.type == "JSON"){
                    try {
                        $scope.previewedItem.jsonValue = JSON.parse($scope.previewedItem.head);
                    } catch (e) {
                        if ($scope.previewedItem.hasMore) {
                            document.getElementById("error_box").innerHTML = "This json file is too large be fully displayed."
                        } else {
                            document.getElementById("error_box").innerHTML = e;
                        }
                        $scope.jsonParsingFailed = true;
                        $scope.previewedItem.type = "TEXT";
                    }
                }
            });

            // Revoke the SVG object URL if the scope is destroyed
            $scope.$on("$destroy", function() {
                $scope.destroyingScope = true;
                setSVGPreviewURL(null);
             });
            
            /*
             * skins for preview items
             */
            $scope.webAppConfig = {}
            $scope.webAppType = null;
            $scope.runningWebAppId = null;

            $scope.$watch('skinState.itemSkin', function() {
                if ($scope.previewedItem == null) return;
                VirtualWebApp.changeSkin($scope, 'MANAGED_FOLDER', $scope.skinState.itemSkin, $scope.skinState,
                    'item-skin-holder', $scope.odb.id, $scope.previewedItem.itemPath, true);
            }, true);

            $scope.isDefaultItemView = function() {
                return $scope.skinState.itemSkin == null || $scope.skinState.itemSkin == $scope.skinState.defaultViewItemSkin;
            }
        }
    };
});

app.directive('managedFolderPreviewHeader', function(DataikuAPI, $q, CreateModalFromTemplate, $state, $stateParams, TopNav, $controller, Dialogs, Fn, $filter, $rootScope) {
    return {
        restrict: 'AE',
        templateUrl: '/templates/managedfolder/fragments/preview-header.html',
        scope : {
            odb : '=',
            previewedItem : '=',
            canDownload : '=',
            readOnly : '=',
            deletePreviewedItem : '=',
            decompressPreviewedFile : '=',
            createInsight : '=',
            skinState : '='
        },

        link: function($scope, element, attrs){
            $scope.appConfig = $rootScope.appConfig;
            $scope.$state = $state;
            
            $scope.createInsightForItem = function(filePath) {
                $scope.createInsight($scope.odb, filePath);
            };
            $scope.$watch('previewedItem', function() {
                if ($scope.previewedItem == null) return;
                if ($scope.previewedItem.contentType == "image/svg+xml") return; // see managedFolderContentsPreview
                // build up the image url (won't be used unless the previewItem's type is IMAGE OR PDF)
                $scope.previewedItem.imageURL = '/dip/api/managedfolder/preview-image?projectKey=' + $scope.odb.projectKey + '&odbId=' + $scope.odb.id + '&itemPath=' + encodeURIComponent($scope.previewedItem.itemPath) + '&contentType=' + encodeURIComponent($scope.previewedItem.contentType);
            });
            $scope.downloadPreviewedFile = function() {
                if ($scope.previewedItem == null)
                    return;
                downloadURL(DataikuAPI.managedfolder.getDownloadItemURL($stateParams.projectKey, $scope.odb.projectKey,  $scope.odb.id, $scope.previewedItem.itemPath));
            };
        }
    };
});


app.constant('MIME_TYPE_ICONS', {
    "text/plain" : "icon-file-text",
    "text/html" : "icon-file-text",
    "text/x-python" : "icon-file-text",
    "text/x-rsrc" : "icon-file-text",
    "text/x-julia" : "icon-file-text",
    "text/x-scala" : "icon-file-text",
    "text/x-sh" : "icon-file-text",
    "text/x-sql" : "icon-file-text",
    "text/x-markdown" : "icon-file-text",
    "application/json" : "icon-file-text",
    "application/javascript" : "icon-file-text",
    "application/pdf" : "icon-file-text",
    "application/xhtml+xml" : "icon-file-text",
    "application/xml" : "icon-file-text",
    "application/xml-dtd" : "icon-file-text",
    "application/xslt+xml" : "icon-file-text",

    "application/java-archive" : "icon-archive",
    "application/x-tar" : "icon-archive",
    "application/x-bzip" : "icon-archive",
    "application/x-bzip2" : "icon-archive",
    "application/zip" : "icon-archive",
    "application/x-gzip" : "icon-archive",

    "image/bmp" : "icon-picture",
    "image/gif" : "icon-picture",
    "image/jpeg" : "icon-picture",
    "image/png" : "icon-picture",
    "image/svg+xml" : "icon-picture",
    "image/tiff" : "icon-picture",
    "image/x-icon" : "icon-picture"
});


app.filter('mimeTypeToIcon', function(MIME_TYPE_ICONS) {
    return function(mimeType) {
        if (!mimeType) return 'icon-file';
        return MIME_TYPE_ICONS[mimeType] || 'icon-file';
    };
});


app.directive('managedFolderContentsList', function(DataikuAPI, $q, CreateModalFromTemplate, $state, $stateParams, TopNav, $controller, Dialogs, openDkuPopin, $timeout, MIME_TYPE_ICONS) {
    return {
        restrict: 'AE',
        templateUrl: '/templates/managedfolder/fragments/contents-list.html',
        replace: true,
        link: function($scope, element, attrs){
            // to get the error displayed in the right context
            var setErrorInScopeToUse = $scope.setErrorInThisScope ? $scope.setErrorInThisScope : setErrorInScope.bind($scope);

            $scope.filteredOdbListing = [];
            $scope.sortMethod = {
                by: 'name',
                reversed: false
            };

            /*
             * List content
             */

            $scope.switchSortMethod = function(by) {
                if ($scope.sortMethod.by == by) {
                    $scope.sortMethod.reversed = !$scope.sortMethod.reversed;
                } else {
                    $scope.sortMethod.by = by;
                    $scope.sortMethod.reversed = false;
                }
            };

            function refreshFilteredOdbListing() {
                if (!$scope.odbListing || !$scope.odbListing.children) {
                    $scope.filteredOdbListing = [];
                    return;
                }
                if ($scope.query) {
                    var lowercaseQuery = $scope.query.toLowerCase();
                    $scope.filteredOdbListing = $scope.odbListing.children.filter(function(item) {return item.name.toLowerCase().indexOf(lowercaseQuery) >= 0;});
                } else {
                    $scope.filteredOdbListing = $scope.odbListing.children.concat();
                }
                $scope.filteredOdbListing.sort(function(a,b) {
                    let sortValue = 0;
                    function sortByIfDifferent(attr) {
                        if (a[attr] != b[attr]) {
                            sortValue = a[attr] < b[attr] ? -1 : 1;
                        }
                    }
                    switch($scope.sortMethod.by) {
                        case 'name':
                            if (a.directory != b.directory)  {
                                sortValue = a.directory ? -1 : 1;
                            } else {
                                sortValue = a.name.localeCompare(b.name);
                            }
                            break;
                        case 'lastModified':
                            sortByIfDifferent('lastModified');
                            break;
                        case 'size':
                            sortByIfDifferent('size');
                            break;
                    }
                    if ($scope.sortMethod.reversed) {
                        sortValue = -1*sortValue;
                    }
                    return sortValue;
                });
            }

            // interactivity
            $scope.$watch("odbListing", function(nv, ov) { // when listing is loaded or cleared
                if (!nv || !nv.children) return;
                refreshFilteredOdbListing();
            }, true);
            $scope.$watch("query", refreshFilteredOdbListing);
            $scope.$watch("sortMethod", refreshFilteredOdbListing, true);

            // moving in list
            var keyCodes = {
                pageup: 33,
                pagedown: 34,
                enter: 13,
                up: 38,
                down: 40
            };

            function previewOrUpdateSelection(e, item, items) {
                if (e.shiftKey || e.ctrlKey || e.metaKey) {
                    $scope.updateSelectedItems(e, item, items)
                } else {
                    $scope.setSelectedItemAndPreview(item);
                }
            }

            $scope.fileListKeyDown = function(event, callFromFatTable) {
                if ($scope.previewedItem == null) {
                    if ($scope.filteredOdbListing.length > 0) {
                        if (event.keyCode === keyCodes.up) {
                            $scope.setSelectedItemAndPreview($scope.filteredOdbListing[$scope.filteredOdbListing.length-1]);
                        } else if (event.keyCode === keyCodes.down) {
                            $scope.setSelectedItemAndPreview($scope.filteredOdbListing[0]);
                        }
                    }
                    return;
                }
                var idx = -1;

                $scope.filteredOdbListing.forEach(function(item, i) {
                    if ($scope.lastItemAddedToSelection.fullPath == item.fullPath) {
                        idx = i;
                    }
                });
                if (idx < 0) return;

                if (event.keyCode === keyCodes.up) {
                    event.preventDefault();
                    if (idx > 0) {
                        previewOrUpdateSelection(event, $scope.filteredOdbListing[idx - 1], $scope.filteredOdbListing)
                    }
                } else if (event.keyCode === keyCodes.down) {
                    event.preventDefault();
                    if (idx < $scope.filteredOdbListing.length - 1) {
                        previewOrUpdateSelection(event, $scope.filteredOdbListing[idx + 1], $scope.filteredOdbListing);
                    }
                } else if (event.keyCode === keyCodes.enter) {
                    event.preventDefault();
                    if ($scope.filteredOdbListing[idx].directory) {
                        $scope.browseDirectory($scope.filteredOdbListing[idx].fullPath);
                    }
                }
                if (callFromFatTable && (event.keyCode === keyCodes.up || event.keyCode === keyCodes.down)) {
                    $scope.$broadcast('scrollToLine', idx);
                }
            };

            /*
             * CRUD
             */

            $scope.renameItem = function(item) {
                let index = $scope.odbListing.children.indexOf(item);
                if (index >= 0) {
                    Dialogs.prompt($scope, "Rename " + item.name, 'New name', item.name).then(function(newName) {
                        DataikuAPI.managedfolder.renameItem($stateParams.sourceProjectKey || $stateParams.projectKey, $scope.odb.id, item.fullPath, item.directory, newName).success(function(data){
                            if (data.result && data.result.paths) {
                                $scope.odbListing.children[index] = data.result.paths[0];
                            }
                        }).error(setErrorInScopeToUse);
                    });
                }
            };

            $scope.moveItems = function(items) {
                CreateModalFromTemplate("/templates/managedfolder/move-item-modal.html", $scope, "MoveItemModalController", function(newScope) {
                    newScope.items = items;
                });
            }

            /*
             * Menus
             */

            $scope.openFileMenu = function(item, $event, popinPosition, items) {
                const multiMode = items && items.length > 1 && items.indexOf(item) >= 0; // if user right clicks outside of selection, show full menu
                item.hovered = true;

                function isElsewhere(elt, e) {
                    if ($(e.target).closest('#upload-link').length == 0) {
                        item.hovered = false; //kind of a hack: no callback possibility for the moment the popin get closed so we're using this...
                        return true;
                    }
                    return false;
                }

                let newScope = $scope.$new();
                newScope.item = item;
                newScope.items = items;
                newScope.uploadFilesAfterDigest = function(files) {
                    $timeout($scope.uploadFiles(files, item.fullPath), 0);
                    newScope.$destroy(); //will destroy the popin
                };

                let template = '<ul class="dropdown-menu">';

                if (!multiMode) {
                    template += `
                        <li><a ng-click="renameItem(item)">Rename...</a></li>
                        <li><a ng-click="moveItems([item])">Move to...</a></li>
                        <li><a ng-click="createInsight(odb, item.fullPath, item.directory)">Publish...</a></li>
                        <li><a ng-click="createDatasetOnItem(item)">Create a dataset...</a></li>
                        <li><a ng-click="item.directory ? downloadFolder(item.fullPath) : downloadFile(item.fullPath)">Download</a></li>
                        <li style="border-top: 1px #eee solid;" ng-if="item.directory" id="upload-link">
                        <a onclick="$(this).siblings('input[type=file]').click();$(this).parents('.dropdown-menu').hide()">Add File into...</a>
                        <input type="file" name="file" multiple style="display:none;" onchange="angular.element(this).scope().uploadFilesAfterDigest(this.files)" />
                        </li>
                        <li><a ng-click="deleteItems([item], $event)" style="border-top: 1px #eee solid;">Delete...</a></li>
                    `;
                } else {
                    template += `
                        <li><a ng-click="moveItems(items)">Move to...</a></li>
                        <li><a ng-click="deleteItems(items, $event)" style="border-top: 1px #eee solid;">Delete...</a></li>
                    `;
                }

                template += '</ul>';

                var dkuPopinOptions = {
                    template: template,
                    isElsewhere: isElsewhere,
                    popinPosition: popinPosition
                };
                openDkuPopin(newScope, $event, dkuPopinOptions);
            };

            $scope.openCurrentFolderMenu = function($event) {
                function isElsewhere(elt, e) {
                    return true;
                }

                var template = '<ul class="dropdown-menu">'
                    +    '<li ng-if="!readOnly"><a ng-click="createInsight(odb, odbListing.safeFullPath, true)">Publish...</a></li>'
                    +    '<li><a ng-click="downloadFolder(odbListing.safeFullPath)">Download</a></li>'
                    +    '<li ng-if="!readOnly" style="border-top: 1px #eee solid;"><a onclick="$(\'#hidden-input-file\').click();">Add File...</a></li>'
                    +    '<li ng-if="!readOnly"><a ng-if="odb.isDirectoryAware" ng-click="createSubFolder()">New Folder...</a></li>'
                    +    '<li ng-if="!readOnly"><a ng-click="createDatasetOnCurrentFolder()">Create a dataset...</a></li>'
                    +'</ul>';

                var dkuPopinOptions = {
                    template: template,
                    isElsewhere: isElsewhere,
                    popinPosition: 'CLICK'
                };
                openDkuPopin($scope, $event, dkuPopinOptions);
            };

            $scope.getIconClass = function(item) {
                if (!item) return '';
                if (item.directory) return 'icon-folder-close colored-folder-icon';
                if (!item.mimeType) return 'icon-file';
                return MIME_TYPE_ICONS[item.mimeType] || 'icon-file';
            };
        }
    }
});


// ngSrc doesn't work on embed. See https://github.com/angular/angular.js/issues/339
app.directive('embedSrc', function () {
    return {
        restrict: 'A',
        link: function (scope, element, attrs) {
            let current = element;
            scope.$watch(function() { return attrs.embedSrc; }, function () {
                let clone = element.clone().attr('src', attrs.embedSrc);
                current.replaceWith(clone);
                current = clone;
            });
        }
    };
});

})();

(function(){
'use strict';

const app = angular.module('dataiku.streaming-endpoints', []);

 app.controller('StreamingEndpointsListController', function($scope, $controller, $stateParams, $state, $q,
                          DatasetsService, DataikuAPI, CreateModalFromTemplate, TopNav, ComputablesService, Fn) {

        $controller('_TaggableObjectsListPageCommon', {$scope: $scope});

        TopNav.setLocation(TopNav.TOP_FLOW, "streaming-endpoints", TopNav.TABS_NONE, null);
        TopNav.setNoItem();

        $scope.showClearData = true;
        $scope.selection = $.extend({
            filterQuery: {
                userQuery: '',
                tags: [],
                interest: {
                    starred: '',
                },
            },
            filterParams: {
                userQueryTargets: ["name","type","tags"],
                propertyRules: {"tag": "tags"}
            },
            orderQuery: "-lastModifiedOn",
            orderReversed: false,
        }, $scope.selection || {});

        $scope.sortBy = [
            { value: 'id', label: 'Name' },
            { value: 'type', label: 'Type' },
            { value : '-lastModifiedOn', label : 'Last modified' }
        ];

        $scope.sortCookieKey = 'streaming-endpoints';
        $scope.maxItems = 20;

        $scope.goToItem = function(item) {
            $scope.$state.go('projects.project.streaming-endpoints.streaming-endpoint.explore', {datasetName: item.name, projectKey: $stateParams.projectKey});
        };

        $scope.list = function() {
            return DataikuAPI.streamingEndpoints.listHeads($stateParams.projectKey, {}, true).success(function (data) {
                $scope.listItems = data;
                $scope.restoreOriginalSelection();
            }).error(setErrorInScope.bind($scope));
        };

        $scope.$on('projectTagsUpdated', function (e, args) {
             if (args.refreshFlowFilters) $scope.list();
        });
        $scope.list();
    });


app.controller("NewStreamingEndpointController", function ($scope, $state, $stateParams, DataikuAPI, WT1) {
    WT1.event("streaming-endpoint-creation-modal");
    addDatasetUniquenessCheck($scope, DataikuAPI, $stateParams.projectKey);

    $scope.newStreamingEndpoint = {
        zone: $scope.getRelevantZoneId($stateParams.zoneId)
    };

    DataikuAPI.datasets.getStreamingEndpointOptionsNoContext($stateParams.projectKey).success(function(data) {
        $scope.connections = data.connections.filter(function(c) {return c.connectionType.toLowerCase() == $scope.newStreamingEndpoint.type;});
        $scope.newStreamingEndpoint.connection = $scope.connections[0];
    });

    $scope.create = function () {
        resetErrorInScope($scope);
        DataikuAPI.streamingEndpoints.create($stateParams.projectKey, $scope.newStreamingEndpoint).success(function(data){
            $state.go('projects.project.streaming-endpoints.streaming-endpoint.settings', { 
                streamingEndpointId: $scope.newStreamingEndpoint.id 
            });
            $scope.dismiss();
        }).error(setErrorInScope.bind($scope));
    };
});

app.controller("StreamingEndpointCommonController", function ($controller, $scope, $stateParams, $rootScope, DataikuAPI, TopNav, $state, DatasetsService, CreateModalFromTemplate, DatasetCustomFieldsService) {
    TopNav.setItem(TopNav.ITEM_STREAMING_ENDPOINT, $stateParams.streamingEndpointId);

    DataikuAPI.streamingEndpoints.getFullInfo($stateParams.projectKey, $stateParams.streamingEndpointId).success(function(data){
        $scope.streamingEndpointFullInfo = data;
        $scope.streamingEndpoint = data.streamingEndpoint;
        $scope.origStreamingEndpoint = angular.copy($scope.streamingEndpoint);
        
        TopNav.setItem(TopNav.ITEM_STREAMING_ENDPOINT, $stateParams.streamingEndpointId, {name:$scope.streamingEndpoint.id, type:$scope.streamingEndpoint.type});
    }).error(setErrorInScope.bind($scope));
});

app.controller("StreamingEndpointPageController", function($scope, $controller, $state, $stateParams, TopNav, DataikuAPI, WT1, LoggerProvider, FutureWatcher){
    $controller('StreamingEndpointCommonController', {$scope: $scope});
});

app.controller("StreamingEndpointSettingsController", function($scope, $controller, $state, $stateParams, TopNav, DataikuAPI, WT1, LoggerProvider, FutureWatcher){
    var Logger = LoggerProvider.getLogger('streaming-endpoints.settings');

    $scope.uiState = {
        activeTab : "basic"
    };

    TopNav.setLocation(TopNav.TOP_FLOW, "streaming-endpoints", TopNav.TABS_STREAMING_ENDPOINT, "settings");
    
    $controller('StreamingEndpointCommonController', {$scope: $scope});

    $scope.saveStreamingEndpoint = function() {
        DataikuAPI.streamingEndpoints.save($stateParams.projectKey, $scope.streamingEndpoint).success(function(data){
                        // Reset the modification detector
                        $scope.origStreamingEndpoint = angular.copy($scope.streamingEndpoint);
                        // $scope.dataset.versionTag = newVersionTag;
                        // $scope.origDataset.versionTag = newVersionTag;

            }).error(setErrorInScope.bind($scope));
    }

    $scope.streamingEndpointIsDirty = function () {
        if (!$scope.streamingEndpoint) {
            return false;
        }
        return !angular.equals($scope.streamingEndpoint, $scope.origStreamingEndpoint);
    };
    
    $scope.$watch("streamingEndpoint", function() {
        // blatantly lie and offer the streaming endpoint under the name 'dataset' in the scope, so that 
        // we can reuse the schema editor as is
        $scope.dataset = $scope.streamingEndpoint;
    });

    checkChangesBeforeLeaving($scope, function(){
        return $scope.streamingEndpointIsDirty();
    });
    
    $scope.setSchemaUserModified = function() {
        $scope.schemaJustModified = true;
        $scope.streamingEndpoint.schema.userModified = true;
    };

    $scope.trySample = function(inferStorageTypes) {
        WT1.event("streaming-sample")
        $scope.uiState.sample = null;
        DataikuAPI.streamingEndpoints.collectSample($stateParams.projectKey, $scope.streamingEndpoint, 10, 30, inferStorageTypes).success(function(data) {
            FutureWatcher.watchJobId(data.jobId).success(function(futureResult) {
                        $scope.captureFuture = null;
                        $scope.uiState.sample = futureResult.result;
                        $scope.uiState.sample.error = null;
                    }).update(function(data) {
                        $scope.captureFuture = data;
                    }).error(function (data, status, headers) {
                        $scope.captureFuture = null;
                        $scope.uiState.sample = {table:{headers:[]}};
                        $scope.uiState.sample.error = getErrorDetails(data, status, headers).detailedMessage;
                    });

        }).error(setErrorInScope.bind($scope));
    };
    
    $scope.useSchemaFromData = function() {
        WT1.event("streaming-use-schema-from-sample")
        $scope.streamingEndpoint.schema = $scope.uiState.sample.schemaDetection.detectedSchema;
        $scope.uiState.sample.schemaDetection.warningLevel = null; // now the warnings are ok
    };
    
    $scope.getAlertClassForDetection = function(dr) {
        if (!dr || !dr.schemaDetection || !dr.schemaDetection.warningLevel) return '';
        if (dr.schemaDetection.warningLevel == 'FATAL') {
            return 'alert-error';
        }
        if (dr.schemaDetection.warningLevel == 'WARN') {
            return 'alert-warning';
        }
        return 'alert-info';
    };
    
});

app.controller("StreamingEndpointAdvancedController", function($scope, $controller, $state, $stateParams, TopNav, DataikuAPI, WT1, LoggerProvider, FutureWatcher){
    var Logger = LoggerProvider.getLogger('streaming-endpoints.advanced');

    $scope.uiState = $scope.uiState || {};
    
    $scope.syncKsql = function(terminateQueries) {
        WT1.event("sync-ksql")
        $scope.uiState.syncDone = null;
        $scope.uiState.syncNotDoneReason = null;
        $scope.uiState.syncNotDoneFailure = null;
        DataikuAPI.streamingEndpoints.syncKsql($stateParams.projectKey, $scope.streamingEndpoint.id, terminateQueries).success(function(data) {
            $scope.uiState.syncDone = data.done;
            $scope.uiState.syncNotDoneReason = data.reason;
            $scope.uiState.syncNotDoneFailure = data.failure;
        }).error(setErrorInScope.bind($scope));
    };
});

app.controller("StreamingEndpointKafkaSettingsController", function($scope, $controller, $state, $stateParams, TopNav, DataikuAPI, WT1, LoggerProvider, FutureWatcher){
    var Logger = LoggerProvider.getLogger('streaming-endpoints.settings');

    $scope.uiState = $scope.uiState || {};
    
    DataikuAPI.connections.getNames('Kafka').success(function (data) {
        $scope.connections = data;
        if (!$scope.streamingEndpoint.params.connection && data.length) {
            $scope.streamingEndpoint.params.connection = data[0];
        }
    }).error(setErrorInScope.bind($scope));
    
    $scope.fetchTopics = function() {
        $scope.uiState.forceCustom = false;
        DataikuAPI.streamingEndpoints.testKafka($stateParams.projectKey, $scope.streamingEndpoint).success(function(data) {
            $scope.uiState.topicsFetched = true;
            $scope.uiState.testResults = data;            
            $scope.uiState.topics = data.topics;
        }).error(setErrorInScope.bind($scope));
    };
    
    $scope.canBeInferredFromRegistry = function(type) {
        // json format only uses the schema registry if you set the schema, so it's unlikely to happen
        return ["avro", "single"].indexOf(type) >= 0;
    };
    $scope.fetchSchemaFromRegistry = function() {
        DataikuAPI.streamingEndpoints.fetchKafkaSchema($stateParams.projectKey, $scope.streamingEndpoint).success(function(data) {
            $scope.uiState.schemaRegistrySchema = data;
        }).error(setErrorInScope.bind($scope));
    };
    
    $scope.useSchemaFromRegistry = function() {
        $scope.streamingEndpoint.schema = $scope.uiState.schemaRegistrySchema.schemaDetection.detectedSchema;
        $scope.uiState.schemaRegistrySchema.schemaDetection.warningLevel = null; // now the warnings are ok
    };
});

app.directive('kafkaFormatBlock', function($state, $controller, $stateParams, DataikuAPI, CreateModalFromTemplate) {
    return {
        restrict: 'A',
        templateUrl :'/templates/streaming-endpoints/settings/kafka-format-block.html',
        scope: {
            formatType : '=',
            formatParams : '=',
            part: '='
        },
        link: function($scope, element, attrs) {
            let fixupParams = function() {
                if ($scope.formatType == null) return;
                if ($scope.formatParams == null) return;
                if (['json', 'avro'].indexOf($scope.formatType) >= 0 && $scope.formatParams.columnNames == null) {
                    $scope.formatParams.columnNames = [];
                }
            };
            $scope.$watch("formatType", fixupParams);
            $scope.$watch("formatParams", fixupParams);
        }
    }
});

app.controller("StreamingEndpointSQSSettingsController", function($scope, $controller, $state, $stateParams, TopNav, DataikuAPI, WT1, LoggerProvider, FutureWatcher){
    var Logger = LoggerProvider.getLogger('streaming-endpoints.settings');

    $scope.uiState = $scope.uiState || {};
    
    DataikuAPI.connections.getNames('SQS').success(function (data) {
        $scope.connections = data;
        if (!$scope.streamingEndpoint.params.connection && data.length) {
            $scope.streamingEndpoint.params.connection = data[0];
        }
    }).error(setErrorInScope.bind($scope));
    
    $scope.fetchQueues = function() {
        $scope.uiState.forceCustom = false;
        DataikuAPI.streamingEndpoints.testSQS($stateParams.projectKey, $scope.streamingEndpoint).success(function(data) {
            $scope.uiState.queuesFetched = true;
            $scope.uiState.testResults = data;            
            $scope.uiState.queues = data.queues;
        }).error(setErrorInScope.bind($scope));
    };
});

app.controller("StreamingEndpointHttpSSESettingsController", function($scope, $controller, $state, $stateParams, TopNav, DataikuAPI, WT1, LoggerProvider, FutureWatcher){
    var Logger = LoggerProvider.getLogger('streaming-endpoints.settings');

    $scope.uiState = $scope.uiState || {};
    
    $scope.testParams = function() {
        DataikuAPI.streamingEndpoints.testHttpSSE($stateParams.projectKey, $scope.streamingEndpoint).success(function(data) {
            $scope.uiState.testResults = data;            
        }).error(setErrorInScope.bind($scope));
    };
});


app.controller("StreamingEndpointKDBPlusTickSettingsController", function($scope, $controller, $state, $stateParams, TopNav, DataikuAPI, WT1, LoggerProvider, FutureWatcher){
    var Logger = LoggerProvider.getLogger('streaming-endpoints.settings');

    $scope.uiState = $scope.uiState || {};

    DataikuAPI.connections.getNames('kdbplus').success(function (data) {
        $scope.connections = data;
        if (!$scope.streamingEndpoint.params.connection && data.length) {
            $scope.streamingEndpoint.params.connection = data[0];
        }
    }).error(setErrorInScope.bind($scope));
});


app.controller("StreamingEndpointExploreController", function($scope, $controller, $state, $stateParams, TopNav, DataikuAPI, WT1, LoggerProvider, FutureWatcher){
    var Logger = LoggerProvider.getLogger('streaming-endpoints.explore');

    TopNav.setLocation(TopNav.TOP_FLOW, "streaming-endpoints", TopNav.TABS_STREAMING_ENDPOINT, "explore");
    $controller('StreamingEndpointCommonController', {$scope: $scope});
});

app.controller("StreamingEndpointHistoryController", function($scope, $controller, $state, $stateParams, TopNav, DataikuAPI, WT1, LoggerProvider){
    TopNav.setLocation(TopNav.TOP_FLOW, "streaming-endpoints", TopNav.TABS_STREAMING_ENDPOINT, "history");
    $controller('StreamingEndpointCommonController', {$scope: $scope});
});

app.controller("StreamingEndpointPageRightColumnActions", async function($controller, $scope, $rootScope, $stateParams, $state, DataikuAPI, ActiveProjectKey) {

    $controller('_TaggableObjectPageRightColumnActions', {$scope: $scope});

    $scope.selection = {
        selectedObject : { "name" : $stateParams.streamingEndpointId, "projectKey" : $stateParams.projectKey},
        confirmedItem : { "name" : $stateParams.streamingEndpointId, "projectKey" : $stateParams.projectKey}
    };

    function updateUserInterests() {
        DataikuAPI.interests.getForObject($rootScope.appConfig.login, "STREAMING_ENDPOINT", ActiveProjectKey.get(), $stateParams.streamingEndpointId).success(function(data) {
            $scope.selection.selectedObject.interest = data;
        }).error(setErrorInScope.bind($scope));
    }

    updateUserInterests();
    const interestsListener = $rootScope.$on('userInterestsUpdated', updateUserInterests);
    $scope.$on("$destroy", interestsListener);

    $scope.isOnStreamingEndpointObjectPage = function() {
        return $state.includes('projects.project.streaming-endpoints.streaming-endpoint');
    }
});


app.directive('streamingEndpointRightColumnSummary', function($state, $controller, $stateParams,
    DataikuAPI, ComputablesService, DatasetsService, CreateModalFromTemplate, QuickView, GlobalProjectActions) {
    return {
        templateUrl :'/templates/streaming-endpoints/right-column-summary.html',

        link : function(scope, element, attrs) {

            $controller('_TaggableObjectsMassActions', {$scope: scope});

            scope.$stateParams = $stateParams;
            scope.QuickView = QuickView;

            function getSmartName(projectKey, name) {
                if (projectKey == $stateParams.projectKey) {
                    return name;
                } else {
                    return projectKey + '.' + name;
                }
            }

            /* Auto save when summary is modified */
            scope.$on("objectSummaryEdited", function(){
                DataikuAPI.streamingEndpoints.save($stateParams.projectKey, scope.se, {summaryOnly:true}).success(function(data) {
                    ActivityIndicator.success("Saved");
                }).error(setErrorInScope.bind(scope));
            });

            scope.refreshData = function() {
                DataikuAPI.streamingEndpoints.getFullInfo($stateParams.projectKey, getSmartName(scope.selection.selectedObject.projectKey, scope.selection.selectedObject.name)).success(function(data){
                    scope.objectFullInfo = data;
                    scope.se = data.streamingEndpoint;
                    scope.isLocalStreamingEndpoint = scope.selection.selectedObject && scope.selection.selectedObject.projectKey == $stateParams.projectKey;
                    scope.usability = GlobalProjectActions.getAllStatusForStreamingEndpoint(data.streamingEndpoint);
                    scope.se.zone = (scope.selection.selectedObject.usedByZones || [])[0] || scope.selection.selectedObject.ownerZone;
                }).error(setErrorInScope.bind(scope));

            };

            scope.$watch("selection.selectedObject",function() {
                if(scope.selection.selectedObject != scope.selection.confirmedItem) {
                    scope.se = null;
                }
            });

            scope.$watch("selection.confirmedItem", function(nv, ov) {
                if (!nv) {
                    return;
                }
                if (!nv.projectKey) {
                    nv.projectKey = $stateParams.projectKey;
                }
                scope.refreshData();
            });

            scope.buildStreamingEndpoint = function() {
                // TODO @streaming
                // CreateModalFromTemplate("/templates/managedfolder/build-folder-modal.html", scope, "BuildManagedFolderController", function(newScope) {
                //     newScope.projectKey = scope.odb.projectKey;
                //     newScope.odbId = scope.odb.id;
                // });
            };
        }
    }
});

app.controller("StreamingEndpointDetailsController", function($scope, $stateParams, DataikuAPI, FutureProgressModal, StateUtils, Dialogs, ActiveProjectKey) {
    $scope.StateUtils = StateUtils;
    $scope.isLocalStreamingEndpoint = function() {
        return $scope.data.projectKey == ActiveProjectKey.get();
    };
});


})();

(function(){
'use strict';

var app = angular.module('dataiku.meanings', []);


app.constant('UDM_TYPES', {
    'DECLARATIVE': "Declarative",
    'VALUES_LIST': "Value list",
    'VALUES_MAPPING': "Value mapping",
    'PATTERN': "Pattern"
});

app.factory("UDMUtils", function($rootScope) {
    return {
        getLabel: function(meaningId) {
            return $rootScope.appConfig.meanings.labelsMap[meaningId];
        }
    };
});

function updateAppConfig(appConfig, udm) {
    appConfig.meanings.labelsMap[udm.id] = udm.label;

    var meanings = appConfig.meanings.categories.filter(function(cat) { return cat.label === 'User-defined'; })[0].meanings;

    for (var i = 0 ; i < meanings.length ; i++) {
        if (meanings[i].id === udm.id) {
            meanings[i].label = udm.label;
            meanings[i].type = udm.type;
            return;
        }
    }

    meanings.push({id: udm.id, label: udm.label, type: udm.type});
}

function cleanBeforeSave(udm) {
    var cleanUDM = angular.extend({}, udm);

    switch(udm.type) {
        case 'DECLARATIVE':
            delete cleanUDM.values;
            delete cleanUDM.mappings;
            delete cleanUDM.pattern;
            delete cleanUDM.normalizationMode;
        break;

        case 'VALUES_MAPPING':
            cleanUDM.mappings = udm.mappings.map(function(m) { return {from: m.from, to: {value: m.to, color: m.color }}});
            delete cleanUDM.pattern;
            delete cleanUDM.values;
        break;

        case 'PATTERN':
            delete cleanUDM.values;
            delete cleanUDM.mappings;
        break;

        case 'VALUES_LIST':
            cleanUDM.entries = udm.mappings.map(function(m) { return {value: m.from, color: m.color}; });
            delete cleanUDM.mappings;
            delete cleanUDM.pattern;
        break;
    }

    return cleanUDM;
}

function defaultUDM() {
    return {
        type: 'DECLARATIVE',
        normalizationMode: 'EXACT',
        mappings:[]
    };
}


app.controller("ColumnEditUDMController", function($scope, $controller, DataikuAPI, Debounce, UDM_TYPES, $timeout){
    $scope.form = {};
    $scope.state = "search";
    $scope.udmTypes = UDM_TYPES;
    $scope.query = {queryString: ''};

    $scope.showValues = true;

    $scope.createNew = function(){
        $scope.state = "new";
        $scope.creation = true;
        $scope.udm = defaultUDM();
        $timeout(function() { $('.udm-definition-form #udmLabelInput').focus(); });
    }

    $scope.initModal = function(columnName, validationCB) {
        $scope.columnName = columnName;
        $scope.validationCB = validationCB;
    }

    DataikuAPI.meanings.listUDM().success(function(data){
        $scope.userDefinedMeanings = data;
    }).error(setErrorInScope.bind($scope));

    $scope.saveNew = function(){
        $scope.saving = true;

        DataikuAPI.meanings.createUDM(cleanBeforeSave($scope.udm)).success(function(){
            DataikuAPI.catalog.flush().success(function() {
                updateAppConfig($scope.appConfig, $scope.udm);
                $scope.saveSet($scope.udm.id);
            });
        }).error(function(data, status, headers, config) { setErrorInScope.bind($scope)(data, status, headers, config); $scope.saving = false; });
    }

    $scope.saveSet = function(id){
        $scope.validationCB(id);
        $scope.resolveModal();
    }

    $scope.$watch("query.queryString", Debounce().withDelay(100, 200).wrap(function(){
        DataikuAPI.catalog.searchMeanings($scope.query.queryString).success(function(data){
            $scope.results = data;
        }).error(setErrorInScope.bind($scope));
    }));

    $scope.blurOnEnter = function($event){
        if(event.which === 13) {
            $event.target.blur();
        }
    }

});


app.controller("EditUDMController", function($scope, $controller, DataikuAPI, Debounce, $timeout){
    $scope.form = {};
    $scope.query = "";
    $scope.checkboxes = {};
    $scope.udm = {};
    $scope.uiState = $scope.uiState || {};

    $scope.initModal = function(meaningId, callback) {
        $scope.uiState.activeTab = 'definition';
        $scope.callback = callback;

        if (meaningId === null) {
            $scope.creation = true;
            $scope.udm = defaultUDM();
            $timeout(function() { $('.udm-definition-form #udmLabelInput').focus(); });
        } else {
            $scope.creation = false;
            DataikuAPI.meanings.getUDM(meaningId).success(function(udm) {
                $scope.udm = udm;
                if (!$scope.udm.mappings) $scope.udm.mappings = [];
                if($scope.udm.type == 'VALUES_LIST') {
                    $scope.udm.mappings = $scope.udm.entries.map(function(v) { return {from:v.value, color: v.color}});
                } else if ($scope.udm.type == 'VALUES_MAPPING') {
                    $scope.udm.mappings = $scope.udm.mappings.map(function(v) { return {from:v.from, to: v.to.value, color: v.to.color}});
                }
            });
        }
    };

    $scope.removeCol = function(checked, id) {
        if (!checked) {
            if ($scope.actions.remove.indexOf(id) !== -1) return;
            $scope.actions.remove.push(id);
        } else {
            var index = $scope.actions.remove.indexOf(id);
            if (index === -1) return;
            $scope.actions.remove.splice(index, 1);
        }
    };

    $scope.save = function(){
        $scope.saving = true;

        var endpoint = $scope.creation ? 'createUDM' : 'saveUDM';

        DataikuAPI.meanings[endpoint](cleanBeforeSave($scope.udm)).success(function(){

            updateAppConfig($scope.appConfig, $scope.udm);

            var data = {};
            for (var key in $scope.checkboxes) {
                if ($scope.checkboxes[key] !== "no_change") {
                    if ($scope.checkboxes[key] === "remove") data[key] = null;
                    else if ($scope.checkboxes[key] === "add") data[key] = $scope.udm.id;
                }
            }

            DataikuAPI.explores.setColumnsMeanings(data).success(function() {
                DataikuAPI.catalog.flush().success(function() {
                     $scope.callback($scope.udm);
                     $scope.resolveModal();
                });
            }).error(function(data, status, headers, config) { setErrorInScope.bind($scope)(data, status, headers, config); $scope.saving = false; });

        }).error(function(data, status, headers, config) { setErrorInScope.bind($scope)(data, status, headers, config); $scope.saving = false; });
    };

    $scope.$watch("toggleAll", function(nv, ov) {
        if (nv === true) {
            $scope.results.hits.hits.forEach(function(column) {
                if (column._source.meaning === $scope.udm.id) {
                    $scope.checkboxes[column._id] = 'no_change';
                } else {
                    $scope.checkboxes[column._id] = 'add';
                }
            });
            $scope.updateCounts();
        } else if (nv === false) {
            $scope.results.hits.hits.forEach(function(column) {
                if (column._source.meaning !== $scope.udm.id) {
                    $scope.checkboxes[column._id] = 'no_change';
                } else {
                    $scope.checkboxes[column._id] = 'remove';
                }
            });
            $scope.updateCounts();
        }
    });

    function anyChecked() {
        for (var i = 0; i < $scope.results.hits.hits.length; i++) {
            var column = $scope.results.hits.hits[i];
            if (column._source.meaning === $scope.udm.id) {
                if ($scope.checkboxes[column._id] !== 'remove') return true;
            } else {
                if ($scope.checkboxes[column._id] === 'add') return true;
            }
        }
        return false;
    }

    function allChecked() {
        for (var i = 0; i < $scope.results.hits.hits.length; i++) {
            var column = $scope.results.hits.hits[i];
            if (column._source.meaning === $scope.udm.id) {
                if ($scope.checkboxes[column._id] === 'remove') return false;
            } else {
                if ($scope.checkboxes[column._id] !== 'add') return false;
            }
        }
        return true;
    }

    $scope.indeterminate = function() {
        return anyChecked() && !allChecked();
    };

    function search() {
        DataikuAPI.catalog.searchColumns($scope.query, {"_type": ["column"]}).success(function(results) {
            $scope.results = results;
        });
    }

    // flush the catalog first to make sure that we don't show deleted columns
    DataikuAPI.catalog.flush().success(function() {
        $scope.$watch('query', Debounce().withDelay(100, 200).wrap(search));
    });

    $scope.updateCounts = function() {
        $scope.changeCounts = {add: 0, remove: 0};
        for (var key in $scope.checkboxes) {
            if ($scope.checkboxes[key] !== "no_change") {
                if ($scope.checkboxes[key] === "remove") $scope.changeCounts.remove = $scope.changeCounts.remove+1;
                else if ($scope.checkboxes[key] === "add") $scope.changeCounts.add = $scope.changeCounts.add+1;
            }
        }
    }
});


app.controller("ColumnEditUDMRefreshController", function($scope, $controller, DataikuAPI, $state, Debounce, $stateParams, ActivityIndicator, categoricalPalette){
    $scope.$watch("results", function() {
        if ($scope.selected && $scope.selected.item) {
            for (var i = 0 ; i < $scope.results.hits.hits.length ; i++) {
                if ($scope.results.hits.hits[i]._id === $scope.selected.item._id) {
                    $scope.selected.index = i;
                    $scope.selected.item = $scope.results.hits.hits[i];
                    return;
                }
            }

            $scope.selected.index = null;
            $scope.selected.item = null;
        }
    });
});


app.controller("UDMFormController", function($scope, UDM_TYPES, NORMALIZATION_MODES){
    var count = null;

    $scope.udmTypes = UDM_TYPES;
    $scope.normalizationModes = NORMALIZATION_MODES;

    $scope.$watch("udm.type", function(nv) {
        if (nv === 'PATTERN' && $scope.udm.normalizationMode === 'NORMALIZED') {
            $scope.udm.normalizationMode = 'EXACT';
        }
    });

    if ($scope.creation) {
        $scope.$watch("udm.label", function(nv, ov) {
            if (!nv) return;
            var slug = nv.toLowerCase().replace(/\W+/g, ""),
                cur = slug,
                i = 0;
            while ($scope.appConfig.meanings.labelsMap.hasOwnProperty(cur)) {
                cur = slug + "_" + (++i);
            }
            $scope.udm.id = cur;
        });

        $scope.$watch("udm.id", function(nv, ov) {
            if (!$scope.form.UDMForm.id) return;
            if(nv && $scope.appConfig.meanings.labelsMap.hasOwnProperty(nv.toLowerCase())) {
                $scope.form.UDMForm.id.$setValidity("unique", false);
                $scope.form.invalidId = true;
            } else {
                $scope.form.UDMForm.id.$setValidity("unique", true);
                $scope.form.invalidId = false;
            }
        });
    }
    // Scroll to the bottom of the list every time a new value is added
    $scope.onListChange = function(items) {
        if (!items) return;

        if (count !== null && items.length === count+1) {
            var $el = $('.udm-definition-form .values');
            $el.scrollTop($el[0].scrollHeight)
        }

        count = items.length;
        $scope.validate();
    };

    $scope.$watch("form.UDMForm.$invalid", function(nv, ov) {
        $scope.form.$invalid = nv;
    });

    // enforce uniqueness of values / mapping keys
    $scope.validate = function(obj, itemIndex) {
        var validity = true;

        angular.forEach($scope.udm.mappings, function(v, i) {
            var container = ".editable-list__item:nth-child(" + (i+1) + ")";
            var controller = $(".udm-definition-form " + container + " div[ng-model='it.from']").data().$ngModelController;

            if (!v.from || $scope.udm.mappings.filter(function(v2) { return v.from == v2.from }).length > 1) {
                controller.$setValidity("unique", false);
                if (i === itemIndex) validity = false;
            } else {
                controller.$setValidity("unique", true);
                if (i === itemIndex) validity = true;
            }
        });

        return validity;
    };
});

})();
(function() {
'use strict';

var app = angular.module('dataiku.metrics.core', []);

/**
 * @ngdoc service
 * @name MetricsUtils
 * @description
 *   Some functions for making metrics manipulation easier, mostly on the display side
 */
app.service('MetricsUtils', function($filter, FutureProgressModal, $rootScope) {
    function getValuePointForId(currentMetric, id, displayedMetricDataList, isPartition) {
        if (currentMetric == null || id == null) return {rawValue:null, formattedValue:null};
        const currentData = displayedMetricDataList
            .find(displayedMetric => displayedMetric.metric.id === currentMetric.metric.id);
        let found = null;
        if (currentData) {
            if (isPartition && id === 'ALL') {
                // special case
                found = currentData.partitionAll;
            } else {
                const field = isPartition ? 'partition' : 'column';
                currentData.values.forEach(function (point) {
                    if (point[field] === id) {
                        found = point;
                    }
                });
            }
        }
        if (!found) {
            return {rawValue:null, formattedValue:null};
        }
        const valueType = isPartition ? currentData.valueType : found.valueType;
        const rawValue = found.value;
        const format = currentMetric.meta ? currentMetric.meta.format : null;
        const formattedValue = formatValue(rawValue, valueType, format, 'N/A', true);
        return {rawValue, formattedValue};
    }

    function formatValue(rawValue, valueType, format, undefinedString, concatenateArray) {
        if (rawValue === null) {
            return '';
        } else if (rawValue === undefined) {
            return undefinedString;
        }
        let standardTypes = ['BIGINT', 'DOUBLE', 'STRING', 'BOOLEAN', 'FLOAT', 'INT'];
        if (!concatenateArray) {
            standardTypes.push('ARRAY')
        }
        if (standardTypes.indexOf(valueType) >= 0) {
            if (format) {
                return $filter(format)(rawValue);
            } else {
                return rawValue;
            }
        } else if ('DATE' === valueType) {
            return $filter('utcDate')(rawValue, 'YYYY-MM-DD HH:mm:ss');
        } else if (concatenateArray && 'ARRAY' === valueType && rawValue.join !== undefined) {
            // backend sends an array of strings
            return '[' + rawValue.join(', ') + ']';
        } else {
            return rawValue;
        }
    }

    return {
        getMetricDisplayName: function (computedMetric) {
            if (computedMetric == null) {
                return '';
            } else {
                if (computedMetric.meta) {
                    if (computedMetric.meta.fullName) {
                        return computedMetric.meta.fullName;
                    }
                    if (computedMetric.meta.name) {
                        return computedMetric.meta.name;
                    }
                }
            }
            return null;
        },

        getMetricName: function (computedMetric) {
            if (computedMetric == null) {
                return '';
            } else {
                if (computedMetric.meta) {
                    if (computedMetric.meta.name) {
                        return computedMetric.meta.name;
                    }
                }
            }
            return null;
        },

        getFormattedValue: function (value, displayedMetric, displayedData) {
            if (!displayedData) return value;
            const format = displayedMetric.meta ? displayedMetric.meta.format : null;
            return formatValue(value, displayedData.valueType, format, 'No data', false);
        },

        getLastValue: function (displayedData) {
            if (displayedData == null) return null;
            return displayedData.lastValue;
        },

        fixupDisplayType: function (displayedData) {
            var shouldShowAverage = function (metric) {
                // don't add ["basic:SIZE", "basic:COUNT_FILES", "records:COUNT_RECORDS"] because they're additive (and won't show on the plot)
                var whiteList = ["col_stats:STDDEV", "col_stats:MEAN", "col_stats:MIN", "col_stats:MAX", "adv_col_stats:MODE", "adv_col_stats:MODE", "percentile_stats:"];
                var ok = false;
                whiteList.forEach(function (prefix) {
                    if (metric.metricId.startsWith(prefix)) {
                        ok = true;
                    }
                });
                return ok && ['BIGINT', 'DOUBLE'].indexOf(metric.dataType) >= 0;
            };
            if (displayedData == null) return null;
            displayedData.$isArray = ['ARRAY'].indexOf(displayedData.valueType) >= 0;
            displayedData.$isPlotted = displayedData.isTimePartition != false && ['BIGINT', 'DOUBLE'].indexOf(displayedData.valueType) >= 0;
            if (displayedData.partitionAll && shouldShowAverage(displayedData)) {
                displayedData.partitionAll.averageValue = displayedData.partitionAll.value;
            }
            if (displayedData.$isArray) {
                if (displayedData.metricId.startsWith('col_stats:HISTOGRAM:')) {
                    displayedData.$displayType = 'histogram';
                    displayedData.$isPlotted = true;
                } else if (displayedData.metricId.startsWith('adv_col_stats:TOP10_WITH_COUNTS:')) {
                    displayedData.$displayType = 'list-with-counts';
                } else {
                    displayedData.$displayType = 'list';
                }
            } else {
                displayedData.$displayType = 'single-value';
            }
            return displayedData;
        },

        hasData: function (displayedData) {
            if (displayedData == null) return false;
            if (displayedData.values == null) return false;
            return displayedData.values.length > 0;
        },
        getRawValueForPartition: function (displayedMetric, partition, displayedMetricByPartitionData) {
            return getValuePointForId(displayedMetric, partition, displayedMetricByPartitionData, true).rawValue;
        },
        getFormattedValueForPartition: function (displayedMetric, partition, displayedMetricByPartitionData) {
            return getValuePointForId(displayedMetric, partition, displayedMetricByPartitionData, true).formattedValue;
        },
        getRawValueForColumn: function (displayedMetric, column, displayedMetricByColumnData) {
            return getValuePointForId(displayedMetric, column, displayedMetricByColumnData, false).rawValue;
        },
        getFormattedValueForColumn: function (displayedMetric, column, displayedMetricByColumnData) {
            return getValuePointForId(displayedMetric, column, displayedMetricByColumnData, false).formattedValue;
        },

        getNiceValue: function (displayedData, value) {
            if (displayedData && displayedData.schemaColumn) {
                if (displayedData.schemaColumn.type == 'date') {
                    return $filter('utcDate')(value, 'YYYY-MM-DD HH:mm:ss');
                } else {
                    return value;
                }
            } else {
                return value;
            }
        },

        computeProgressModal: function ($scope, modalTitle) {
            return function (data) {
                FutureProgressModal.show($scope, data, modalTitle)
                    .then(function (result) {
                        $scope.lastComputeResult = result;
                        if (result) {
                            if (result.runs) {
                                $scope.hasErrors = result.runs.some(_ => _.error);
                            } else {
                                $scope.result = result;
                                $scope.hasErrors = false;
                                $scope.lastComputeResult = {
                                    startTime: null,
                                    endTime: null,
                                    allRuns: [],
                                    partitionsList: result.partitionsList || result.partitionIds
                                };
                                result.reports.forEach(function (report) {
                                    $scope.lastComputeResult.allRuns = $scope.lastComputeResult.allRuns.concat(report.runs);
                                    $scope.lastComputeResult.errorRuns = $scope.lastComputeResult.allRuns.filter(_ => !!_.error);
                                    $scope.hasErrors = $scope.lastComputeResult.errorRuns.length > 0;
                                    $scope.lastComputeResult.startTime = $scope.lastComputeResult.startTime == null ? report.startTime : Math.min($scope.lastComputeResult.startTime, report.startTime);
                                    $scope.lastComputeResult.endTime = $scope.lastComputeResult.endTime == null ? report.endTime : Math.max($scope.lastComputeResult.endTime, report.endTime);
                                });
                            }
                        }
                        $rootScope.$broadcast('metrics-refresh-displayed-data');
                    });
            }
        },

        hasAverage: function (displayedData) {
            return displayedData.partitionAll.averageValue != null;
        },

        getColoringClass: function (displayedMetric, value) {
            if (displayedMetric.metric.type == 'check') {
                return value && value.value ? ('outcome-' + value.value.toLowerCase()) : '';
            } else if (value == undefined) {
                return 'no-data-color';
            } else {
                return '';
            }
        },

        preprocessHistogram: function (value) {
            if (value == null) return null;
            var edges = [];
            value.forEach(function (row) {
                var value = null;
                var count = null;
                angular.forEach(JSON.parse(row), function (v, k) {
                    value = parseFloat(k); // only numeric values can have histogram metrics
                    count = v;
                });
                edges.push({value: value, count: count});
            });
            if (edges.length >= 2) {
                var bins = [];
                var min = edges[0].value, max = edges[edges.length - 1].value;
                var maxCount = 0;
                for (var i = 1; i < edges.length; i++) {
                    var lower = edges[i - 1].value;
                    var upper = edges[i].value;
                    var count = edges[i - 1].count;
                    maxCount = Math.max(maxCount, count);
                    bins.push([lower, upper, count]);
                }
                return {min: min, max: max, chistogram: bins, longestHistogramBar: maxCount};
            } else if (edges.length == 1) {
                return {min: edges[0].value, max: edges[0].value}
            } else {
                return null;
            }
        },

        // enlarge if tiny
        fixUpRange: function (range) {
            if (range.from == range.to) {
                var now = new Date().getTime();
                if (now > range.to) {
                    range.to = now;
                    range.from = range.from - (now - range.from);
                } else {
                    range.from = now;
                    range.to = range.to + (range.to - now);
                }
            }
            return range;
        }
    };
});

/**
 * @ngdoc directive
 * @name objectMetrics
 * @description
 *   core metrics directive, to ensure that a 'metrics' object is in the scope. Provides the
 *   metricsIsDirty() for the save button
 */
app.directive('objectMetrics', function($stateParams, CreateModalFromTemplate, $timeout, ActivityIndicator, $q, DataikuAPI, MetricsUtils, $state, WT1) {
    return {
        scope : false,
        restrict : 'A',
        link : function($scope, $element, attrs) {

            $scope.objectMetricsCtx = {
            };

            $scope.MetricsUtils = MetricsUtils;

            var autoSave = $scope.$eval(attrs.metricsAutoSave || 'true');

            var saveWatch = null;

            $scope.objectMetricsInit = function() {
                $scope.origMetricsChecks = $scope.metricsChecks == null ? null : angular.copy($scope.metricsChecks);

                if ( saveWatch != null ) {
                    saveWatch();
                }

                // init the displayState object for datasets/folders/models from old versions passed as-is to the frontend
                if ($scope.metrics && $scope.metrics.displayedState == null) {
                    $scope.metrics.displayedState = {};
                }
                if ($scope.metricsChecks && $scope.metricsChecks.displayedState == null) {
                    $scope.metricsChecks.displayedState = {};
                    $scope.origMetricsChecks.displayedState = {};
                }

                if ( $scope.metrics && $scope.metrics.displayedState && $scope.metrics.displayedState.partition == null ) {
                    $scope.metrics.displayedState.partition = $scope.metricsCallbacks.isPartitioned() ? 'ALL' : 'NP';
                }
                if ( $scope.metricsChecks && $scope.metricsChecks.displayedState && $scope.metricsChecks.displayedState.partition == null ) {
                    $scope.metricsChecks.displayedState.partition = $scope.metricsCallbacks.isPartitioned() ? 'ALL' : 'NP';
                    $scope.origMetricsChecks.displayedState.partition = $scope.metricsChecks.displayedState.partition;
                }

                $scope.refreshAllComputedMetrics();
                $scope.refreshAllComputedChecks();
            };

            $scope.metricsIsDirty = function() {
                var metricsDirty = $scope.metrics && $scope.origMetrics && !angular.equals($scope.metrics, $scope.origMetrics);
                var metricsChecksDirty = $scope.metricsChecks && $scope.origMetricsChecks && !angular.equals($scope.metricsChecks, $scope.origMetricsChecks);
                return metricsDirty || metricsChecksDirty;
            };

            $scope.allComputedMetrics = {metrics:[]};
            $scope.allComputedChecks = {checks:[]};
            var i = 0;
            $scope.refreshAllComputedMetrics = function() {
                $scope.metricsCallbacks.listComputed().success(function(data) {
                    $scope.allComputedMetrics.metrics = data.metrics;
                    $scope.allComputedMetrics.notExistingViews = data.notExistingViews;
                    $scope.allComputedMetrics.i = i++; // dirty the object, so that it gets to the modal $watch
                }).error(setErrorInScope.bind($scope));
            };
            $scope.refreshAllComputedChecks = function() {
                $scope.metricsCallbacks.listComputedChecks().success(function(data) {
                    $scope.allComputedChecks.checks = data.checks;
                    $scope.allComputedChecks.notExistingViews = data.notExistingViews;
                    $scope.allComputedChecks.i = i++; // dirty the object, so that it gets to the modal $watch
                }).error(setErrorInScope.bind($scope));
            };

            var doSaveMetrics = function(deferred) {
                // save: wt1 of which part has changed
                var metricsDisplayedStateChange = false;
                var metricsSettingsChange = false;
                var metricsEngineConfigChange = false;
                if ( $scope.metrics && $scope.origMetrics ) {
                    if ($scope.metrics.displayedState && $scope.origMetrics.displayedState) {
                        metricsDisplayedStateChange = !angular.equals($scope.origMetrics.displayedState, $scope.metrics.displayedState);
                    }
                    if ($scope.metrics.probes && $scope.origMetrics.probes) {
                        metricsSettingsChange = !angular.equals($scope.origMetrics.probes, $scope.metrics.probes);
                    }
                    if ($scope.metrics.engineConfig && $scope.origMetrics.engineConfig) {
                        metricsEngineConfigChange = !angular.equals($scope.origMetrics.engineConfig, $scope.metrics.engineConfig);
                    }
                }
                var checksDisplayedStateChange = false;
                var checksSettingsChange = false;
                var checksEngineConfigChange = false;
                if ( $scope.metricsChecks && $scope.origMetricsChecks ) {
                    if ($scope.metricsChecks.displayedState && $scope.origMetricsChecks.displayedState) {
                        checksDisplayedStateChange = !angular.equals($scope.origMetricsChecks.displayedState, $scope.metricsChecks.displayedState);
                    }
                    if ($scope.metricsChecks.probes && $scope.origMetricsChecks.probes) {
                        checksSettingsChange = !angular.equals($scope.origMetricsChecks.probes, $scope.metricsChecks.probes);
                    }
                    if ($scope.metricsChecks.runOnBuild && $scope.origMetricsChecks.runOnBuild) {
                        checksEngineConfigChange = !angular.equals($scope.origMetricsChecks.runOnBuild, $scope.metricsChecks.runOnBuild);
                    }
                }
                WT1.event("metrics-save", {metricsDisplayedState : metricsDisplayedStateChange,
                    metricsSettings : metricsSettingsChange,
                    metricsEngineConfigChange : metricsEngineConfigChange,
                    checksDisplayedState : checksDisplayedStateChange,
                    checksSettings : checksSettingsChange,
                    checksEngineConfigChange : checksEngineConfigChange});

                $scope.metricsCallbacks.save().success(function(data) {
                    $scope.origMetrics = angular.copy($scope.metrics);
                    $scope.origMetricsChecks = $scope.metricsChecks == null ? null : angular.copy($scope.metricsChecks);
                    ActivityIndicator.success("Saved");
                    if (deferred) {
                        deferred.resolve("Saved");
                    }
                }).error(function (a,b,c) {
                    setErrorInScope.bind($scope)(a,b,c);
                    if (deferred) {
                        deferred.reject("Not saved");
                    }
                });
            };
            $scope.saveMetricsNow = function() {
                var deferred = $q.defer();
                if ( !$scope.metricsIsDirty() ) {
                    deferred.resolve("Saved");
                    return deferred.promise;
                }
                doSaveMetrics(deferred);
                return deferred.promise;
            };

            function allowedTransitions(data) {
                return !(data.toState && data.toState.name && data.toState.name.indexOf("dataset.status") < 0 && data.toState.name.indexOf("managedfolder.status") < 0 && data.toState.name.indexOf("savedmodel.status") < 0);
            }
            checkChangesBeforeLeaving($scope, function(data){
                /* Not yet loaded */
                return $scope.metricsIsDirty();
            }, null, allowedTransitions);

            // hint about each engine's 'speed'
            $scope.getEngineSpeed = function(engineType) {
                if ( engineType == 'Basic' ) {
                    return 'medium';
                }
                if ( engineType == 'DSS' ) {
                    return 'slow';
                }
                if ( engineType == 'SQL_Metrics' || engineType == 'SQL_ColumnMetrics' || engineType == 'SQLQuery' ) {
                    return 'fast';
                }
                if ( engineType == 'Hive_Metrics' || engineType == 'Hive_ColumnMetrics' || engineType == 'HiveQuery' ) {
                    return 'medium fast';
                }
                if ( engineType == 'Impala_Metrics' || engineType == 'Impala_ColumnMetrics' || engineType == 'ImpalaQuery' ) {
                    return 'fast';
                }
                if ( engineType == 'Spark_Metrics' || engineType == 'Spark_ColumnMetrics' || engineType == 'SparkQuery' ) {
                    return 'fast';
                }
                if ( engineType == 'Python' ) {
                    return 'slow';
                }
                return 'N/A';
            };

            $scope.$watch('metricsCallbacks', function(nv) {
                if ( nv == null) return;
                $scope.metricsCallbacks.listAvailableMetrics().success(function(data) {
                    $scope.availableProbes = data;
                    $scope.isHive = data.isHive;
                    $scope.isSql = data.isSql;
                    $scope.regenMetricsSet();
                }).error(setErrorInScope.bind($scope));
            }, false);

            // recreate the 'metrics' object on the dataset, from what is selected in the metrics selector. This will drop
            // metrics whose definition has disappeared
            $scope.regenMetricsSet = function() {

                if ($scope.metrics == null) {
                    // wait for metrics to be loaded then rerun
                    var unbind = $scope.$watch("metrics", function(nv) {
                        if (nv == null) return;
                        $scope.regenMetricsSet();
                        unbind();
                    });
                    return;
                }

                if (!$scope.availableProbes || !$scope.availableProbes.probes) return;

                var probes = [];
                $scope.availableProbes.probes.forEach(function(availableProbe) {
                    var probe = availableProbe.probe;
                    if ( probe.type == 'verify_col' || probe.type == 'col_stats' || probe.type == 'adv_col_stats' || probe.type == 'percentile_stats') {
                        var aggregates = [];
                        availableProbe.hint.columns.forEach(function(column) {
                            column.metrics.forEach(function(metric) {
                                if (metric.active && !metric.disabled) {
                                    aggregates.push({column:column.column, aggregated:metric.aggregated});
                                }
                            });
                        });
                        probe.configuration.aggregates = aggregates;
                    }
                    if (probe.type == 'adv_col_stats') {
                        DataikuAPI.datasets.getFullSampleStatisticsConfig($stateParams.projectKey, $stateParams.projectKey, $stateParams.datasetName).success(function(sampleConfig) {
                            probe.configuration.numberTopValues = sampleConfig.numberTopValues;
                        });
                    }
                    if (probe.type == 'sql_query' || probe.type.startsWith('sql_plugin')) {
                        var columns = [];
                        availableProbe.hint.columns.forEach(function(column) {
                            column.metrics.forEach(function(metric) {
                                if (metric.active && !metric.disabled) {
                                    columns.push(column.column);
                                }
                            });
                        });
                        probe.configuration.columns = columns;
                    }
                    if (probe.type == 'cell') {
                        var columns = [];
                        availableProbe.hint.columns.forEach(function(column) {
                            if (column.active) {
                                columns.push(column.column);
                            }
                        });
                        probe.configuration.columns = columns;
                    }
                    probes.push(probe);
                });
                // swap the list (not the engine config)
                $scope.metrics.probes = probes;
                if (!$scope.origMetrics) $scope.origMetrics = angular.copy($scope.metrics);
            };
        }
    };
});

/**
 * @ngdoc directive
 * @name datasetMetricsMain
 * @description
 *   This directive is composed on the same scope as object-metrics.
 *   It is responsible for setting up the callback, fetching the dataset configuration,
 *   and actually calling the object-metrics-base initialization function
 */
app.directive('datasetMetricsMain', function(DataikuAPI, $stateParams, Dialogs, $state) {
    return {
        scope : false,
        restrict : 'A',
        link : {
            pre: function($scope, $element, attrs) {
                // metricsCallbacks needs to be on the scope before child controllers are initialized
                $scope.metricsCallbacks = {
                    save : function() {
                        return DataikuAPI.datasets.saveMetrics($stateParams.projectKey, $stateParams.datasetName, $scope.metrics, $scope.metricsChecks, false);
                    },
                    listComputed : function() {
                        return DataikuAPI.datasets.listComputedMetrics($stateParams.projectKey, $stateParams.datasetName);
                    },
                    listAvailableMetrics : function() {
                        return DataikuAPI.datasets.listAvailableMetrics($stateParams.projectKey, $stateParams.datasetName);
                    },
                    getPreparedMetricHistory : function(partitionId, metric, metricId) {
                        return DataikuAPI.datasets.getPreparedMetricHistory($stateParams.projectKey, $stateParams.datasetName, partitionId, metric, metricId);
                    },
                    getPreparedMetricHistories : function(displayedState) {
                        return DataikuAPI.datasets.getPreparedMetricHistories($stateParams.projectKey, $stateParams.datasetName, displayedState);
                    },
                    getPreparedMetricPartitions : function(displayedState) {
                        return DataikuAPI.datasets.getPreparedMetricPartitions($stateParams.projectKey, $stateParams.datasetName, displayedState);
                    },
                    getPreparedMetricColumns : function(displayedState) {
                        return DataikuAPI.datasets.getPreparedMetricColumns($stateParams.projectKey, $stateParams.datasetName, displayedState);
                    },
                    computeMetrics : function(partitionId) {
                        return DataikuAPI.datasets.computeMetrics($stateParams.projectKey, $stateParams.datasetName, partitionId, false);
                    },
                    computeColumnMetrics : function(columnName, partitionId) {
                        return DataikuAPI.datasets.computeColumnMetrics($stateParams.projectKey, $stateParams.datasetName, columnName, partitionId, false);
                    },
                    computeMetricsAll : function() {
                        return DataikuAPI.datasets.computeMetrics($stateParams.projectKey, $stateParams.datasetName, null, true);
                    },
                    computeColumnMetricsAll : function(columnName) {
                        return DataikuAPI.datasets.computeColumnMetrics($stateParams.projectKey, $stateParams.datasetName, columnName, null, true);
                    },
                    computeProbe : function(partitionId, allPartitions, metrics) {
                        return DataikuAPI.datasets.computeProbe($stateParams.projectKey, $stateParams.datasetName, partitionId, allPartitions, metrics);
                    },
                    runChecks : function(partitionId) {
                        return DataikuAPI.datasets.runChecks($stateParams.projectKey, $stateParams.datasetName, partitionId, false);
                    },
                    runChecksAll : function() {
                        return DataikuAPI.datasets.runChecks($stateParams.projectKey, $stateParams.datasetName, null, true);
                    },
                    runCheck : function(partitionId, allPartitions, metricsChecks) {
                        return DataikuAPI.datasets.runCheck($stateParams.projectKey, $stateParams.datasetName, partitionId, allPartitions, metricsChecks);
                    },
                    canComputeMetrics : function() {
                        return true;
                    },
                    canRunChecks : function() {
                        return true;
                    },
                    isPartitioned : function() {
                        return $scope.datasetFullInfo.partitioned;
                    },
                    getSelectedMetricsPartitionId : function() {
                        if ( $scope.metrics.displayedState == null || $scope.metrics.displayedState.partition == null || $scope.metrics.displayedState.partition == 'ALL' ) {
                            return $scope.metricsCallbacks.isPartitioned() ? 'ALL' : 'NP';
                        } else {
                            return $scope.metrics.displayedState.partition;
                        }
                    },
                    createMetricsDataset : function(view, partition, filter) {
                        return DataikuAPI.datasets.createMetricsDataset($stateParams.projectKey, $stateParams.datasetName, view, partition, filter);
                    },
                    computePlan : function(metrics) {
                        return DataikuAPI.datasets.computePlan($stateParams.projectKey, $stateParams.datasetName, metrics);
                    },
                    getSelectedChecksPartitionId : function() {
                        if ( $scope.metricsChecks.displayedState == null || $scope.metricsChecks.displayedState.partition == null || $scope.metricsChecks.displayedState.partition == 'ALL' ) {
                            return $scope.metricsCallbacks.isPartitioned() ? 'ALL' : 'NP';
                        } else {
                            return $scope.metricsChecks.displayedState.partition;
                        }
                    },
                    listComputedChecks : function() {
                        return DataikuAPI.datasets.listComputedChecks($stateParams.projectKey, $stateParams.datasetName);
                    },
                    getCheckHistories : function(displayedState) {
                        return DataikuAPI.datasets.getCheckHistories($stateParams.projectKey, $stateParams.datasetName, displayedState);
                    },
                    getPythonProbeStartCode : function() {
                        return "# Define here a function that returns the metric.\n"
                            + "def process(dataset, partition_id):\n"
                            + "    # dataset is a dataiku.Dataset object\n"
                            + "    return {'metric_name1' : 42, 'metric_name2' : True}\n";
                    },
                    canAddPluginProbe : function(desc, kind) {
                        return kind == 'sql' || desc.handlesDataset;
                    },
                    getHint : function(probe) {
                        return DataikuAPI.datasets.getHint($stateParams.projectKey, $stateParams.datasetName, probe);
                    },
                    hasColumnsView : function() {
                        return true;
                    },
                    getObjectType : function() {
                        return 'DATASET';
                    },
                    getObjectSmartId : function() {
                        return $stateParams.datasetName;
                    },
                    getObjectName : function() {
                        return $stateParams.datasetName;
                    },
                    clearMetrics : function() {
                        return DataikuAPI.datasets.clearMetrics($stateParams.projectKey, $stateParams.datasetName, null);
                    },
                    getPartitionListMetric : function() {
                        return DataikuAPI.datasets.getPartitionListMetric($stateParams.projectKey, $stateParams.datasetName);
                    },
                    refreshPartitionListMetric : function() {
                        return DataikuAPI.datasets.refreshPartitionListMetric($stateParams.projectKey, $stateParams.datasetName);
                    }
                };
            },
            post:function($scope, $element, attrs) {

                /// TEMPORARY TO DELETE
                $scope.getNbRecords = function() {
                    DataikuAPI.datasets.getCachedNbRecords($stateParams.projectKey, $stateParams.datasetName).success(function(data) {
                        $scope.nbRecords = data;
                    }).error(setErrorInScope.bind($scope));
                };
                $scope.updateNbRecords = function(recomputeAll) {
                    DataikuAPI.datasets.updateNbRecords($stateParams.projectKey, $stateParams.datasetName, recomputeAll).success(function(data) {
                        $scope.nbRecords2 = data;
                    }).error(setErrorInScope.bind($scope));
                };
                /// END TEMPORARY TO DELETE

                /* Dataset specific stuff: available actions on the partitions list */

                $scope.explorePartition = function(partitionId) {
                    DataikuAPI.explores.setExploreOnSinglePartition($stateParams.projectKey, $stateParams.datasetName, partitionId).success(function(data) {
                        $state.transitionTo('projects.project.datasets.dataset.explore', {projectKey : $stateParams.projectKey, datasetName : $stateParams.datasetName})
                    }).error(setErrorInScope.bind($scope));
                };

                $scope.clearPartition = function (partitionId) {
                    Dialogs.confirm($scope,'Clear partition', 'Are you sure you want to clear this partition ?').then(function(){
                        DataikuAPI.datasets.clearPartitions($stateParams.projectKey,$stateParams.datasetName,[partitionId]).success(function() {
                            $scope.$broadcast('metrics-refresh-displayed-data');
                        }).error(setErrorInScope.bind($scope));
                    });
                };

                DataikuAPI.datasets.get($stateParams.projectKey, $stateParams.datasetName, $stateParams.projectKey).success(function(data){
                    $scope.objectMetricsObjectId = $stateParams.datasetName;
                    $scope.metrics = data.metrics;
                    $scope.metricsChecks = data.metricsChecks;

                    $scope.objectMetricsInit();
                    $scope.datasetSchema = data.schema;
                }).error(setErrorInScope.bind($scope));
            }
        }
    };
});

var fixedResponseMock = function(data) {
    var response = {};
    response.success = function(callback) {callback(data); return response;};
    response.error = function(callback) {return response;};
    return response;
}

/**
 * @ngdoc directive
 * @name datasetMetrics
 * @description
 *   This directive is composed on the same scope as object-metrics-base.
 *   It is responsible for setting up the callback, waiting for the folder configuration,
 *   and actually calling the object-metrics-base initialization function
 */
app.directive('folderMetricsMain', function(DataikuAPI, $state, $stateParams, Dialogs) {
    return {
        scope : false,
        restrict : 'A',
        link : function($scope, $element, attrs) {
            $scope.metricsCallbacks = {
                save : function() {
                    return DataikuAPI.managedfolder.saveMetrics($stateParams.projectKey, $stateParams.odbId, $scope.metrics, $scope.metricsChecks, false);
                },
                listComputed : function() {
                    return DataikuAPI.managedfolder.listComputedMetrics($stateParams.projectKey, $stateParams.odbId);
                },
                listAvailableMetrics : function() {
                    return DataikuAPI.managedfolder.listAvailableMetrics($stateParams.projectKey, $stateParams.odbId);
                },
                getPreparedMetricHistory : function(partitionId, metric, metricId) {
                    return DataikuAPI.managedfolder.getPreparedMetricHistory($stateParams.projectKey, $stateParams.odbId, partitionId, metric, metricId);
                },
                getPreparedMetricHistories : function(displayedState) {
                    return DataikuAPI.managedfolder.getPreparedMetricHistories($stateParams.projectKey, $stateParams.odbId, displayedState);
                },
                computeMetrics : function(partitionId) {
                    return DataikuAPI.managedfolder.computeMetrics($stateParams.projectKey, $stateParams.odbId, partitionId, false);
                },
                computeMetricsAll : function() {
                    return DataikuAPI.managedfolder.computeMetrics($stateParams.projectKey, $stateParams.odbId, null, true);
                },
                computeProbe : function(partitionId, allPartitions, metrics) {
                    return DataikuAPI.managedfolder.computeProbe($stateParams.projectKey, $stateParams.odbId, partitionId, allPartitions, metrics);
                },
                canComputeMetrics : function() {
                    return true;
                },
                canRunChecks : function() {
                    return true;
                },
                isPartitioned : function() {
                    return $scope.odb != null && $scope.odb.partitioning != null && $scope.odb.partitioning.dimensions.length > 0;
                },
                getSelectedMetricsPartitionId : function() {
                    if ( $scope.metrics.displayedState == null || $scope.metrics.displayedState.partition == null || $scope.metrics.displayedState.partition == 'ALL' ) {
                        return $scope.metricsCallbacks.isPartitioned() ? 'ALL' : 'NP';
                    } else {
                        return $scope.metrics.displayedState.partition;
                    }
                },
                createMetricsDataset : function(view, partition, filter) {
                    return DataikuAPI.managedfolder.createMetricsDataset($stateParams.projectKey, $stateParams.odbId, view, partition, filter);
                },
                computePlan : function(metrics) {
                    return DataikuAPI.managedfolder.computePlan($stateParams.projectKey, $stateParams.odbId, metrics);
                },
                runChecks : function(partitionId) {
                    return DataikuAPI.managedfolder.runChecks($stateParams.projectKey, $stateParams.odbId, partitionId, false);
                },
                runChecksAll : function() {
                    return DataikuAPI.managedfolder.runChecks($stateParams.projectKey, $stateParams.odbId, null, true);
                },
                runCheck : function(partitionId, allPartitions, metricsChecks) {
                    return DataikuAPI.managedfolder.runCheck($stateParams.projectKey, $stateParams.odbId, partitionId, allPartitions, metricsChecks);
                },

                // no checks on this object, so just return empty objects for the generic js code
                getPreparedMetricPartitions : function(displayedState) {
                    return DataikuAPI.managedfolder.getPreparedMetricPartitions($stateParams.projectKey, $stateParams.odbId, displayedState);
                },
                getSelectedChecksPartitionId : function() {
                    if ( $scope.metricsChecks.displayedState == null || $scope.metricsChecks.displayedState.partition == null || $scope.metricsChecks.displayedState.partition == 'ALL' ) {
                        return $scope.metricsCallbacks.isPartitioned() ? 'ALL' : 'NP';
                    } else {
                        return $scope.metricsChecks.displayedState.partition;
                    }
                },
                listComputedChecks : function() {
                    return DataikuAPI.managedfolder.listComputedChecks($stateParams.projectKey, $stateParams.odbId);
                },
                getCheckHistories : function(displayedState) {
                    return DataikuAPI.managedfolder.getCheckHistories($stateParams.projectKey, $stateParams.odbId, displayedState);
                },
                getPythonProbeStartCode : function() {
                    return "# Define here a function that returns the metric.\n"
                        + "def process(folder, partition_id):\n"
                        + "    # folder is a dataiku.Folder object\n"
                        + "    return {'metric_name1' : 42, 'metric_name2' : True}\n";
                },
                canAddPluginProbe : function(desc, kind) {
                    return kind == 'python' && desc.handlesManagedFolder;
                },
                getHint : function(probe) {
                    return DataikuAPI.managedfolder.getHint($stateParams.projectKey, $stateParams.odbId, probe);
                },
                hasColumnsView : function() {
                    return false;
                },
                getObjectType : function() {
                    return 'MANAGED_FOLDER';
                },
                getObjectSmartId : function() {
                    return $scope.odb.id;
                },
                getObjectName : function() {
                    return $scope.odb.name;
                },
                clearMetrics : function() {
                    return DataikuAPI.managedfolder.clearMetrics($stateParams.projectKey, $stateParams.odbId);
                },
                getPartitionListMetric : function() {
                    return DataikuAPI.managedfolder.getPartitionListMetric($stateParams.projectKey, $stateParams.odbId);
                },
                refreshPartitionListMetric : function() {
                    return DataikuAPI.managedfolder.refreshPartitionListMetric($stateParams.projectKey, $stateParams.odbId);
                }
            };

            $scope.explorePartition = function(partitionId) {
                DataikuAPI.managedfolder.setExploreOnSinglePartition($stateParams.projectKey, $stateParams.odbId, partitionId).success(function(data) {
                    $state.transitionTo("projects.project.managedfolders.managedfolder.view", {projectKey : $stateParams.projectKey, odbId : $stateParams.odbId})
                }).error(setErrorInScope.bind($scope));
            };

            $scope.clearPartition = function (partitionId) {
                Dialogs.confirm($scope,'Clear partition', 'Are you sure you want to clear this partition ?').then(function(){
                    DataikuAPI.managedfolder.clearPartitions($stateParams.projectKey,$stateParams.odbId,[partitionId]).success(function() {
                        $scope.$broadcast('metrics-refresh-displayed-data');
                    }).error(setErrorInScope.bind($scope));
                });
            };

            /* It is already fetched by the top level controller */
            $scope.$watch("odb", function(nv){
                if (!nv) return;
                $scope.objectMetricsObjectId = $scope.odb.id;
                $scope.metrics = $scope.odb.metrics;
                $scope.metricsChecks = $scope.odb.checks;

                $scope.objectMetricsInit();
            })
        }
    };
});

/**
 * @ngdoc directive
 * @name projectMetrics
 * @description
 *   This directive is composed on the same scope as object-metrics-base.
 *   It is responsible for setting up the callback, waiting for the folder configuration,
 *   and actually calling the object-metrics-base initialization function
 */
app.directive('projectMetricsMain', function(DataikuAPI, $state, $stateParams, Dialogs) {
    return {
        scope : false,
        restrict : 'A',
        link : function($scope, $element, attrs) {
            $scope.metricsCallbacks = {
                save : function() {
                    return DataikuAPI.projects.saveMetrics($stateParams.projectKey, $scope.metrics, $scope.metricsChecks);
                },
                listComputed : function() {
                    return DataikuAPI.projects.listComputedMetrics($stateParams.projectKey);
                },
                listAvailableMetrics : function() {
                    return DataikuAPI.projects.listAvailableMetrics($stateParams.projectKey);
                },
                getPreparedMetricHistory : function(partitionId, metric, metricId) {
                    return DataikuAPI.projects.getPreparedMetricHistory($stateParams.projectKey, partitionId, metric, metricId);
                },
                getPreparedMetricHistories : function(displayedState) {
                    return DataikuAPI.projects.getPreparedMetricHistories($stateParams.projectKey, displayedState);
                },
                computeMetrics : function(partitionId) {
                    return null;
                },
                computeMetricsAll : function() {
                    return null;
                },
                computeProbe : function(partitionId, allPartitions, metrics) {
                    return null;
                },
                canComputeMetrics : function() {
                    return false;
                },
                isPartitioned : function() {
                    return false;
                },
                getSelectedMetricsPartitionId : function() {
                    return 'NP';
                },
                createMetricsDataset : function(view, partition, filter) {
                    return DataikuAPI.projects.createMetricsDataset($stateParams.projectKey, view, partition, filter);
                },
                computePlan : function(metrics) {
                    return null;
                },
                canRunChecks : function() {
                    return false;
                },
                runChecks : function(partitionId) {
                    return null;
                },
                runChecksAll : function() {
                    return null;
                },
                runCheck : function(partitionId, allPartitions, metricsChecks) {
                    return null;
                },
                getPreparedMetricPartitions : function(displayedState) {
                    return null;
                },
                getSelectedChecksPartitionId : function() {
                    return null;
                },
                listComputedChecks : function() {
                    return DataikuAPI.projects.listComputedChecks($stateParams.projectKey);
                },
                getCheckHistories : function(displayedState) {
                    return DataikuAPI.projects.getCheckHistories($stateParams.projectKey, displayedState);
                },
                getPythonProbeStartCode : function() {
                    return null;
                },
                canAddPluginProbe : function(desc, kind) {
                    return false;
                },
                getHint : function(probe) {
                    return null;
                },
                hasColumnsView : function() {
                    return false;
                },
                getObjectType : function() {
                    return 'PROJECT';
                },
                getObjectSmartId : function() {
                    return null;
                },
                getObjectName : function() {
                    return $scope.projectSummary.name;
                },
                clearMetrics : function() {
                    return DataikuAPI.projects.clearMetrics($stateParams.projectKey);
                },
                getPartitionListMetric : function() {
                    return null;
                },
                refreshPartitionListMetric : function() {
                    return null;
                },
                saveExternalMetricsValues : function(metricsData, typesData) {
                    return DataikuAPI.projects.saveExternalMetricsValues($stateParams.projectKey, metricsData, typesData);
                },
                saveExternalChecksValues : function(checksData) {
                    return DataikuAPI.projects.saveExternalChecksValues($stateParams.projectKey, checksData);
                }
            };

            $scope.explorePartition = function(partitionId) {
                // no partition on projects
            };

            $scope.clearPartition = function (partitionId) {
                // no partition on projects
            };

            /* It is already fetched by the top level controller */
            $scope.$watch("projectSummary", function(nv){
                if (!nv) return;
                $scope.objectMetricsObjectId = null;
                $scope.metrics = $scope.projectSummary.metrics;
                $scope.metricsChecks = $scope.projectSummary.metricsChecks;

                $scope.objectMetricsInit();
            })
        }
    };
});

/**
 * @ngdoc directive
 * @name modelMetricsMain
 * @description
 *   This directive is composed on the same scope as object-metrics-base.
 *   It is responsible for setting up the callback, waiting for the model settings
 *   and actually calling the object-metrics-base initialization function
 */
app.directive('modelMetricsMain', function(DataikuAPI, $stateParams) {
    return {
        scope : false,
        restrict : 'A',
        link : function($scope, $element, attrs) {
            $scope.metricsCallbacks = {
                save : function() {
                    return DataikuAPI.savedmodels.save($scope.savedModel);
                },
                listComputed : function() {
                    return DataikuAPI.savedmodels.listComputedMetrics($stateParams.projectKey, $stateParams.smId);
                },
                listAvailableMetrics : function() {
                    return fixedResponseMock({probes:[],isHive:false,isSql:false});
                },
                getPreparedMetricHistory : function(partitionId, metric, metricId) {
                    return DataikuAPI.savedmodels.getPreparedMetricHistory($stateParams.projectKey, $stateParams.smId, metric, metricId);
                },
                getPreparedMetricHistories : function(displayedState) {
                    return DataikuAPI.savedmodels.getPreparedMetricHistories($stateParams.projectKey, $stateParams.smId, displayedState);
                },
                computeMetrics : function(partitionId) {
                    return null;
                },
                computeProbe : function(partitionId, allPartitions, metrics) {
                    return null;
                },
                canRunChecks : function() {
                    return true;
                },
                runChecks : function(partitionId) {
                    return DataikuAPI.savedmodels.runChecks($stateParams.projectKey, $stateParams.smId);
                },
                runCheck : function(partitionId, allPartitions, metricsChecks) {
                    return DataikuAPI.savedmodels.runCheck($stateParams.projectKey, $stateParams.smId, metricsChecks);
                },
                canComputeMetrics : function() {
                    return false;
                },
                isPartitioned : function() {
                    return false;
                },
                getSelectedMetricsPartitionId : function() {
                    return null;
                },
                createMetricsDataset : function(view, partition, filter) {
                    return DataikuAPI.savedmodels.createMetricsDataset($stateParams.projectKey, $stateParams.smId, view, partition, filter);
                },
                computePlan : function(metrics) {
                    return null;
                },
                getPreparedMetricPartitions : function(displayedState) {
                    return DataikuAPI.savedmodels.getPreparedMetricPartitions($stateParams.projectKey, $stateParams.smId, displayedState);
                },
                getSelectedChecksPartitionId : function() {
                    return null;
                },
                listComputedChecks : function() {
                    return DataikuAPI.savedmodels.listComputedChecks($stateParams.projectKey, $stateParams.smId);
                },
                getCheckHistories : function(displayedState) {
                    return DataikuAPI.savedmodels.getCheckHistories($stateParams.projectKey, $stateParams.smId, displayedState);
                },
                getPythonProbeStartCode : function() {
                    return "# ";
                },
                canAddPluginProbe : function(desc, kind) {
                    return false;
                },
                getHint : function(probe) {
                    return DataikuAPI.savedmodels.getHint($stateParams.projectKey, $stateParams.smId, probe);
                },
                hasColumnsView : function() {
                    return false;
                },
                getObjectType : function() {
                    return 'SAVED_MODEL';
                },
                getObjectSmartId : function() {
                    return $scope.savedModel.id;
                },
                getObjectName : function() {
                    return $scope.savedModel.name;
                },
                clearMetrics : function() {
                    return DataikuAPI.savedmodels.clearMetrics($stateParams.projectKey, $stateParams.smId, null);
                },
                getPartitionListMetric : function() {
                    return null;
                },
                refreshPartitionListMetric : function() {
                    return null;
                }
            };

            /* It is already fetched by the top level controller */
            $scope.$watch("savedModel", function(nv){
                if (!nv) return;
                $scope.objectMetricsObjectId = $scope.savedModel.id;
                $scope.metrics = $scope.savedModel.metrics;
                $scope.metricsChecks = $scope.savedModel.metricsChecks;

                $scope.objectMetricsInit();
            })
        }
    };
});


/**
 * @ngdoc directive
 * @name metricsPartitionSelection
 * @description
 *   This directive is composed with dataset metrics main.
 *   It provides the ability to get the cached list of partitions from the "union of all known partitions in metrics DB"
 *   and to force a refresh of the list of partitions.
 *
 *   This list of partition is used both in the Settings (Probes and Checks) and in the "History" tabs, since
 *   there are compute buttons in the settings screen, which uses the "currently selected in history" metric
 */
 app.directive('metricsPartitionSelection', function(DataikuAPI, $timeout, $stateParams, WT1) {
    return {
        scope : false,
        restrict : 'A',
        link : function($scope, $element, attrs) {
            $scope.metricsPartitionsIds = ['ALL'];
            $scope.metricsPartitionsIdsExcludingAll = [];
            $scope.setPartitionList = function(data) {
                $scope.metricsPartitions = data.partitionsList;
                $scope.metricsPartitions.partitions = $scope.metricsPartitions.partitions || [];
                $scope.metricsPartitions.partitions.sort(function(a, b) { return a.partition < b.partition ? -1 : (a.partition > b.partition ? 1 : 0) });
                $scope.metricsPartitionsIds = data.partitionsList.partitions.map(function(p) {return p.partition;});
                $scope.metricsPartitionsIds.sort();
                if (data.partitionsList.isTimePartition) {
                    // most recent on top
                    $scope.metricsPartitionsIds = $scope.metricsPartitionsIds.reverse();
                }
                $scope.metricsPartitionsIdsExcludingAll = $scope.metricsPartitionsIds.concat();
                $scope.metricsPartitionsIds.unshift('ALL');
            };

            var initDeregister = $scope.$watch('metricsCallbacks', function(nv) {
                if (!nv) return;
                $scope.metricsCallbacks.getPartitionListMetric().success(function(data) {
                    $scope.setPartitionList({partitionsList : data});
                }).error(setErrorInScope.bind($scope));
                initDeregister();
            });

            $scope.refreshMetricsPartitions = function() {
                WT1.event("metrics-refresh-partition-list");
                $scope.metricsCallbacks.refreshPartitionListMetric().success(function(data) {
                    $scope.setPartitionListRefreshing(data);
                    $scope.refreshAllComputedMetrics();
                    $scope.refreshAllComputedChecks();
                }).error(setErrorInScope.bind($scope));
            };
            $scope.refreshing = null;
            $scope.setPartitionListRefreshing = function(data) {
                if (data && data.hasResult) {
                    $scope.metricsCallbacks.getPartitionListMetric().success(function(data) {
                        $scope.setPartitionList({partitionsList : data});
                    }).error(setErrorInScope.bind($scope));
                    $scope.refreshing = null;
                    $scope.$broadcast('metrics-refresh-partition-list', data.result);
                } else if (data && !data.hasResult) {
                    $scope.refreshing = data;
                    $timeout(function(){
                        $scope.checkIfStillRefreshing();
                    }, 5000);
                } else {
                    $scope.refreshing = null;
                }
            };
            $scope.checkIfStillRefreshing = function() {
                DataikuAPI.futures.getUpdate($scope.refreshing.jobId).success(function(data) {
                    $scope.setPartitionListRefreshing(data);
                }).error(function (a,b,c) {
                    $scope.setPartitionListRefreshing(null);
                    setErrorInScope.bind($scope)(a,b,c);
                });
            };
        }
    };
});




app.controller("EditMetricsSettingsController", function($scope) {
    $scope.engineConfig = angular.copy($scope.metrics.engineConfig);
    var origEngineConfig = angular.copy($scope.engineConfig);
    $scope.save = function() {
        $scope.metrics.engineConfig = $scope.engineConfig;
        $scope.dismiss();
    };
    $scope.isDirty = function() {
        return !angular.equals($scope.engineConfig, origEngineConfig);
    };
});


// filter to exclude metrics relevant only for the full dataset
app.filter('onlyMetricsForPartition', function() {
    return function (metrics) {
        return metrics.filter(function (metric) {
            return !metric.metric.id.startsWith("partitioning:");
        });
    };
});



})();
(function() {
'use strict';

var app = angular.module('dataiku.metrics.views', ['dataiku.metrics.core']);


app.controller("MetricsViewController", function($scope) {

    if ($scope.metricsCallbacks.isPartitioned()) {
        $scope.views = {
                values: [{name:'Partitions table', id:'Table'}, {name:'Partitions histories', id:'Partitions'}, {name:'Last value', id:'Last value'}, {name:'History', id:'History'}],
                selected: 'Table'
            };
    } else {
        $scope.views = {
                values: [{name:'Last value', id:'Last value'}, {name:'History', id:'History'}],
                selected: 'Last value'
            };
    }
    if ($scope.metricsCallbacks.hasColumnsView()) {
        $scope.views.values.push({name:'Columns', id:'Columns'});
    }

    $scope.displayedMetrics = {metrics : [], $loaded : false};
    // function is not there when the page is loaded the first time, but is there when tabs change
    if ( $scope.refreshAllComputedMetrics ) $scope.refreshAllComputedMetrics();
});

app.controller("ChecksViewController", function($scope) {
    $scope.displayedChecks = {checks : [], $loaded : false};
    // function is not there when the page is loaded the first time, but is there when tabs change
    if ( $scope.refreshAllComputedChecks ) $scope.refreshAllComputedChecks();
});

/**
 * @ngdoc directive
 * @name selectDisplayedMetrics
 * @description
 *   Directive for the selector of metrics / checks to display
 */
app.directive('displayedMetricsSelector', function(DataikuAPI, $stateParams, CreateModalFromTemplate, $timeout, $q, MetricsUtils, WT1, $filter) {
    return {
        scope : {
            choices : '=',
            selected : '=',
            refreshChoices : '=',
            onClose : '=',
            type : '@'      // either 'checks' or 'metrics'
        },
        restrict : 'A',
        replace : true,
        templateUrl : "/templates/metrics/displayed-metrics-selector.html",
        link : function($scope, $element, attrs) {
            $scope.MetricsUtils = MetricsUtils;

            $scope.openDisplayedMetricsModal = function() {
                CreateModalFromTemplate("/templates/metrics/displayed-metrics-modal.html", $scope, null, function(newScope) {
                    newScope.displayed = {items: $scope.selected[$scope.type].concat()};
                    newScope.choicesLeft = {items:[]};
                    newScope.filter = { query: ""};

                    var refreshChoicesLeft = function() {
                        newScope.choicesLeft.items.splice(0, newScope.choicesLeft.items.length);
                        $scope.choices[$scope.type].forEach(function(item) {
                            if (newScope.displayed.items.indexOf(item) < 0) {
                                newScope.choicesLeft.items.push(item);
                            }
                        });
                    };
                    refreshChoicesLeft();

                    newScope.addAll = function() {
                        var toAdd = $filter('filter')(newScope.choicesLeft.items, newScope.filter.query);
                        toAdd.forEach(function(added) {
                            var i = newScope.choicesLeft.items.indexOf(added);
                            if (i >= 0) {
                                newScope.choicesLeft.items.splice(i, 1);
                            }
                        });
                        newScope.displayed.items = newScope.displayed.items.concat(toAdd);
                    };

                    newScope.removeAll = function() {
                        newScope.displayed.items = [];
                        newScope.choicesLeft.items = $scope.choices[$scope.type].concat();
                    };

                    newScope.remove = function(item) {
                        var index = newScope.displayed.items.indexOf(item);
                        if ( index >= 0 ) {
                            newScope.displayed.items.splice(index, 1);
                            refreshChoicesLeft();
                        }
                    };

                    newScope.add = function(item) {
                        newScope.displayed.items.push(item);
                        refreshChoicesLeft();
                    };

                    $scope.$watch('choices', function(nv) {
                        if ( nv == null ) return;
                        // the list of items (metrics/checks) was refreshed
                        var newDisplayed = {items:[]};
                        newScope.displayed.items.forEach(function(item) {
                            var found = null;
                            $scope.choices[$scope.type].forEach(function(newItem) {
                                if ($scope.type == 'metrics' && item.metric.id == newItem.metric.id
                                    || $scope.type == 'checks' && item.name == newItem.name) {
                                    found = newItem;
                                }
                            });
                            if ( found != null ) {
                                newDisplayed.items.push(found);
                            }
                        });
                        newScope.displayed.items = newDisplayed.items;
                        refreshChoicesLeft();
                    }, true);

                }).then(function(newDisplayedItems) {
                    WT1.event($scope.type + "-selector-save");
                    $scope.selected[$scope.type] = newDisplayedItems;
                    if (angular.isFunction($scope.onClose)) $timeout($scope.onClose);
                });
            };

            $scope.$parent.openDisplayedMetricsModal = $scope.openDisplayedMetricsModal;
        }
    };
});

/**
 * @ngdoc directive
 * @name selectDisplayedMetrics
 * @description
 *   Directive for the selector of metrics / checks to display
 */
app.directive('displayedColumnsSelector', function(DataikuAPI, $stateParams, CreateModalFromTemplate, $timeout, $q, MetricsUtils, WT1, $filter) {
    return {
        scope : {
            datasetSchema : '=',
            selected : '=',
            refreshChoices : '=',
            onClose : '='
        },
        restrict : 'A',
        replace : true,
        templateUrl : "/templates/metrics/displayed-columns-selector.html",
        link : function($scope, $element, attrs) {
            $scope.MetricsUtils = MetricsUtils;

            $scope.openDisplayedMetricsModal = function() {
                CreateModalFromTemplate("/templates/metrics/displayed-columns-modal.html", $scope, null, function(newScope) {
                    $scope.choices = $scope.datasetSchema.columns.map(function(c) {return c.name;});
                    newScope.displayed = {items: ($scope.selected || []).concat()};
                    newScope.choicesLeft = {items:[]};
                    newScope.filter = { query: ""};

                    var refreshChoicesLeft = function() {
                        newScope.choicesLeft.items.splice(0, newScope.choicesLeft.items.length);
                        $scope.choices.forEach(function(item) {
                            if (newScope.displayed.items.indexOf(item) < 0) {
                                newScope.choicesLeft.items.push(item);
                            }
                        });
                    };
                    refreshChoicesLeft();

                    newScope.addAll = function() {
                        var toAdd = $filter('filter')(newScope.choicesLeft.items, newScope.filter.query);
                        toAdd.forEach(function(added) {
                            var i = newScope.choicesLeft.items.indexOf(added);
                            if (i >= 0) {
                                newScope.choicesLeft.items.splice(i, 1);
                            }
                        });
                        newScope.displayed.items = newScope.displayed.items.concat(toAdd);
                    };

                    newScope.removeAll = function() {
                        newScope.displayed.items = [];
                        newScope.choicesLeft.items = $scope.choices.concat();
                    };

                    newScope.remove = function(item) {
                        var index = newScope.displayed.items.indexOf(item);
                        if ( index >= 0 ) {
                            newScope.displayed.items.splice(index, 1);
                            refreshChoicesLeft();
                        }
                    };

                    newScope.add = function(item) {
                        newScope.displayed.items.push(item);
                        refreshChoicesLeft();
                    };

                    $scope.$watch('choices', function(nv) {
                        if ( nv == null ) return;
                        // the list of items (metrics/checks) was refreshed
                        var newDisplayed = {items:[]};
                        newScope.displayed.items.forEach(function(item) {
                            var found = null;
                            $scope.choices.forEach(function(newItem) {
                                if (item == newItem) {
                                    found = newItem;
                                }
                            });
                            if ( found != null ) {
                                newDisplayed.items.push(found);
                            }
                        });
                        newScope.displayed.items = newDisplayed.items;
                        refreshChoicesLeft();
                    }, true);

                }).then(function(newDisplayedItems) {
                    WT1.event("columns" + "-selector-save");
                    $scope.selected = newDisplayedItems;
                    if (angular.isFunction($scope.onClose)) $timeout($scope.onClose);
                });
            };

            $scope.$parent.openDisplayedMetricsModal = $scope.openDisplayedMetricsModal;
        }
    };
});

/**
 * @ngdoc directive
 * @name displayMetricsHistory
 * @description
 *   Directive for the pane showing the metrics' histories
 */
app.directive('displayMetrics', function(DataikuAPI, $stateParams, CreateModalFromTemplate, $timeout, $q, MetricsUtils, WT1, ActivityIndicator) {
    return {
        scope : true,
        restrict : 'A',
        templateUrl : "/templates/metrics/display-metrics.html",
        link : function($scope, $element, attrs) {
            $scope.uiState = {listMode : 'tile'};
            $scope.metricsScope = attrs.metricsScope;
            $scope.displayedMetricByTimeData = [];
            $scope.canCompute = $scope.$eval(attrs.canCompute); // if false, no 'compute' button, and only building the object can compute metrics (ie: saved models)

            $scope.$watch('metrics', function(nv, ov) {
                if ( $scope.metrics == null ) return;
                init();
            }, false);

            var init = function() {
                $scope.refreshDisplayedMetrics();
                refreshDisplayedMetricData();
            };

            $scope.refreshDisplayedMetrics = function() {
                if ( $scope.metrics == null || $scope.allComputedMetrics == null || $scope.metrics.displayedState == null) return;

                // get the ones for the selected element, either partition or full dataset
                var partitionId = $scope.metricsCallbacks.getSelectedMetricsPartitionId();
                if ( !$scope.displayedMetrics.$loaded && $scope.allComputedMetrics.metrics.length > 0 ) {
                    // select back the metrics as the persisted state says
                    $scope.displayedMetrics.metrics = $scope.allComputedMetrics.metrics.filter(function(metric) {return metric.displayedAsMetric;});
                    // re-order according to $scope.metrics.displayedState.metrics
                    $scope.displayedMetrics.metrics.forEach(function(displayedMetric) {
                        var i = $scope.metrics.displayedState.metrics.indexOf(displayedMetric.metric.id);
                        if ( i < 0 ) {
                            i = $scope.metrics.displayedState.metrics.length;
                        }
                        displayedMetric.$indexInDisplayedState = i;
                    });
                    $scope.displayedMetrics.metrics.sort(function(a, b) {return a.$indexInDisplayedState - b.$indexInDisplayedState;});
                    $scope.displayedMetrics.$loaded = true;
                }
            };

            var refreshDisplayedList = function() {
                if ( $scope.displayedMetrics == null || $scope.metrics.displayedState == null) return;

                $scope.metrics.displayedState.metrics = $scope.displayedMetrics.metrics.map(function(metric) {return metric.metric.id;});
                // don't forget to tweak the allComputedMetrics for when we switch tabs and reload the displayedMetrics list
                $scope.allComputedMetrics.metrics.forEach(function(metric) {metric.displayedAsMetric = $scope.displayedMetrics.metrics.indexOf(metric) >= 0;});
            };
            var refreshDisplayedMetricData = function() {
                if ( $scope.displayedMetrics == null || !$scope.displayedMetrics.$loaded || $scope.metrics == null || $scope.metrics.displayedState == null) return;

                // fetch the data
                $scope.metricsCallbacks.getPreparedMetricHistories($scope.metrics.displayedState).success(function(data) {
                    $scope.displayedMetricByTimeData = data.histories.map(function(displayedData) {return MetricsUtils.fixupDisplayType(displayedData);});
                    $scope.displayedMetricByTimeData.forEach(function(displayedMetric) {
                        if (displayedMetric.metric.type === "adv_col_stats") {
                            // Limit the displayed top value to 10, only configurable for the column analysis dialog
                            displayedMetric.values.forEach(function(metric){
                                metric.value = metric.value.slice(0,10);
                            });
                            displayedMetric.lastValue.value = displayedMetric.lastValue.value.slice(0,10);
                        }
                    });
                    if ( data.from > 0 ) {
                        $scope.displayedMetricsRange = MetricsUtils.fixUpRange({from: data.from, to: data.to});
                        $scope.selectedRange = angular.copy($scope.displayedMetricsRange);
                    } else {
                        $scope.displayedMetricsRange = null; // empty range
                        $scope.selectedRange = null;
                    }
                }).error(setErrorInScope.bind($scope));
            };

            $scope.$on('metrics-refresh-displayed-data', refreshDisplayedMetricData);

            $scope.brushChanged = function() {
                $scope.$digest();
            };

            $scope.$watch('displayedMetrics', function(nv, ov) {
                if ( nv == ov ) return;
                refreshDisplayedList();
                refreshDisplayedMetricData();
            }, true);

            $scope.$watch('metrics.displayedState.partition', function(nv, ov) {
                if ( nv == ov ) return;
                refreshDisplayedMetricData();
            }, false);

            $scope.$watch('allComputedMetrics', function(nv, ov) {
                if ( nv == ov ) return;
                $scope.refreshDisplayedMetrics();
            }, true);

            $scope.getDisplayedData = function(displayedMetric) {
                if ( displayedMetric == null || displayedMetric.metric == null ) return null;
                var metricId = displayedMetric.metric.id;
                var found = null;
                $scope.displayedMetricByTimeData.forEach(function(displayedMetricHistory) {
                    if ( displayedMetricHistory.metricId == metricId ) {
                        found = displayedMetricHistory;
                    }
                });
                return found;
            };

            if ($scope.metricsCallbacks.canComputeMetrics()) {
                $scope.computeNow = function() {
                    WT1.event("metrics-compute-now");
                    $scope.saveMetricsNow().then(function() {
                        var partitionId = $scope.metricsCallbacks.getSelectedMetricsPartitionId();
                        var modalTitle = "Computing all metrics" + (partitionId == null ? "" : " for partition " + partitionId) + "…";
                        $scope.metricsCallbacks.computeMetrics(partitionId)
                            .success(MetricsUtils.computeProgressModal($scope, modalTitle))
                            .error(setErrorInScope.bind($scope));
                    });
                };

                $scope.computeAll = function() {
                    WT1.event("metrics-compute-all");
                    $scope.saveMetricsNow().then(function() {
                        $scope.metricsCallbacks.computeMetricsAll()
                            .success(MetricsUtils.computeProgressModal($scope, "Computing all metrics…"))
                            .error(setErrorInScope.bind($scope));
                    });
                };

                $scope.computeAllForPartition = function(partitionId) {
                    var modalTitle = "Computing all metrics" + (partitionId == null ? "" : " for partition " + partitionId) + "…";

                    $scope.metricsCallbacks.computeMetrics(partitionId)
                        .success(MetricsUtils.computeProgressModal($scope, modalTitle))
                        .error(setErrorInScope.bind($scope));
                };

                if ($scope.metricsCallbacks.isPartitioned()) {
                    $scope.computeMetricForSelected = function(displayedMetric) {
                        var probes = $scope.metrics.probes.filter(function(probe){return probe.type == displayedMetric.computingProbe;});
                        if ( probes.length == 1 ) {
                            var metrics = angular.copy($scope.metrics);
                            metrics.probes = probes;
                            var partitionId = $scope.metricsCallbacks.getSelectedMetricsPartitionId();
                            $scope.metricsCallbacks.computeProbe(partitionId, false, metrics)
                            .success(MetricsUtils.computeProgressModal($scope, "Computing metric on " + partitionId, true))
                            .error(setErrorInScope.bind($scope));
                        }
                    };
                } else {
                    $scope.computeMetricForObject = function(displayedMetric) {
                        var probes = $scope.metrics.probes.filter(function(probe){return probe.type == displayedMetric.computingProbe;});
                        if ( probes.length == 1 ) {
                            var metrics = angular.copy($scope.metrics);
                            metrics.probes = probes;
                            var partitionId = $scope.metricsCallbacks.getSelectedMetricsPartitionId();
                            $scope.metricsCallbacks.computeProbe('NP', false, metrics)
                            .success(MetricsUtils.computeProgressModal($scope, "Computing metric", true))
                            .error(setErrorInScope.bind($scope));
                        }
                    };
                }
            } else {
                $scope.computeNow = null;
                $scope.computeAll = null;
                $scope.computeAllForPartition = null;
                $scope.computeMetricForSelected = null;
                $scope.computeMetricForObject = null;
            }

            $scope.createAndPinInsight = function(displayedMetric) {
                var insight = {
                    projectKey: $stateParams.projectKey,
                    type: 'metrics',
                    params: {
                        objectType: $scope.metricsCallbacks.getObjectType(),
                        objectSmartId: $scope.metricsCallbacks.getObjectSmartId(),
                        metricId: displayedMetric.metric.id
                    },
                    name: displayedMetric.meta.name + " of " + (displayedMetric.metric.column ? (displayedMetric.metric.column + " on ") : "") + $scope.metricsCallbacks.getObjectName()
                };
                CreateModalFromTemplate("/templates/dashboards/insights/create-and-pin-insight-modal.html", $scope, "CreateAndPinInsightModalController", function(newScope) {
                    newScope.init(insight);
                });
            };

            $scope.openMetricChartModal = function(displayedMetric) {
                WT1.event("metrics-open-metric-modal");
                CreateModalFromTemplate("/templates/metrics/metric-chart-modal.html", $scope, null, function(newScope) {
                        newScope.displayedMetric = displayedMetric;
                });
            };

            $scope.addAllMetricsDatasetInFlow = function(view, partition, filter) {
                WT1.event("metrics-add-dataset-in-flow", {all:true});
                $scope.metricsCallbacks.createMetricsDataset(view, partition, filter).success(function(data) {
                    ActivityIndicator.success("Metrics dataset created");
                    var i = $scope.allComputedMetrics.notExistingViews.indexOf(view);
                    if (i >= 0) {
                        $scope.allComputedMetrics.notExistingViews.splice(i, 1);
                    }
                }).error(setErrorInScope.bind($scope));
            };
            $scope.addOneMetricDatasetInFlow = function(computedMetric, view, partition, filter) {
                WT1.event("metrics-add-dataset-in-flow", {all:false});
                $scope.metricsCallbacks.createMetricsDataset(view, partition, filter).success(function(data) {
                    ActivityIndicator.success("Metrics dataset created");
                    var i = computedMetric.notExistingViews.indexOf(view);
                    if (i >= 0) {
                        computedMetric.notExistingViews.splice(i, 1);
                    }
                }).error(setErrorInScope.bind($scope));
            };
            $scope.clearAll  = function() {
                WT1.event("metrics-clear");
                $scope.metricsCallbacks.clearMetrics().success(function(data) {
                    ActivityIndicator.success("Metrics cleared");
                    $scope.$emit('metrics-refresh-displayed-data');
                }).error(setErrorInScope.bind($scope));
            };

            $scope.addMetricValue = function() {
                CreateModalFromTemplate("/templates/metrics/add-metric-value-modal.html", $scope, null, function(newScope) {
                    newScope.newMetric = {};
                    newScope.addMetricPoint = function(newMetric) {
                        var metricsData = {};
                        if (!isNaN(newMetric.value)) {
                            newMetric.value = parseFloat(newMetric.value);
                        } else if (moment(newMetric.value).isValid()) {
                            newMetric.value = moment(newMetric.value).toISOString();
                        }
                        metricsData[newMetric.name] = newMetric.value;
                        $scope.metricsCallbacks.saveExternalMetricsValues(metricsData, {}).success(function(data) {
                            WT1.event("metrics-metric-inserted", {objectType:$scope.metricsCallbacks.getObjectType()});
                            $scope.refreshAllComputedMetrics();
                            newScope.dismiss();
                        }).error(setErrorInScope.bind(newScope));
                    };
                });
            };
        }
    };
});


/**
 * @ngdoc directive
 * @name displayChecksHistory
 * @description
 *   Directive for the pane showing the checks' histories
 */
app.directive('displayChecks', function(DataikuAPI, $stateParams, CreateModalFromTemplate, $timeout, $filter, $q, MetricsUtils, ExportUtils, WT1, FutureProgressModal, ActivityIndicator) {
    return {
        scope : true,
        restrict : 'A',
        templateUrl : "/templates/metrics/display-checks.html",
        link : function($scope, $element, attrs) {
            $scope.uiState = {
                values: {'banner':'List', 'list':'Table'},
                listMode: 'banner'
            };
            $scope.metricsScope = attrs.metricsScope;
            $scope.displayedChecksHistories = [];
            $scope.canCompute = $scope.$eval(attrs.canCompute); // if false, no 'compute' button, and only building the object can compute checks (ie: saved models)

            $scope.$watch('metricsChecks', function(nv, ov) {
                if ( $scope.metricsChecks == null ) return;
                init();
            }, false);

            var init = function() {
                $scope.refreshDisplayedChecks();
                refreshDisplayedCheckData();
            };

            $scope.refreshDisplayedChecks = function() {
                if ( $scope.metricsChecks == null || $scope.allComputedChecks == null ) return;

                if ( !$scope.displayedChecks.$loaded && $scope.allComputedChecks.checks.length > 0 ) {
                    // select back the checks as the persisted state says
                    $scope.displayedChecks.checks = $scope.allComputedChecks.checks.filter(function(check) {return check.displayedAsCheck;});
                    $scope.displayedChecks.$loaded = true;
                }
            };

            var refreshDisplayedList = function() {
                if ( $scope.displayedChecks == null || $scope.metricsChecks.displayedState == null) return;
                $scope.metricsChecks.displayedState.checks = $scope.displayedChecks.checks.map(function(check) {return check.name;});
                // don't forget to tweak the allComputedMetrics for when we switch tabs and reload the displayedMetrics list
                $scope.allComputedChecks.checks.forEach(function(check) {check.displayedAsCheck = $scope.displayedChecks.checks.indexOf(check) >= 0;});
            };
            var refreshDisplayedCheckData = function() {
                if ( $scope.displayedChecks == null || !$scope.displayedChecks.$loaded || $scope.metricsChecks == null || $scope.metricsChecks.displayedState == null ) return;
                // fetch the data
                $scope.metricsCallbacks.getCheckHistories($scope.metricsChecks.displayedState).success(function(data) {
                    $scope.displayedChecksHistories = data.histories;
                    if ( data.from > 0 ) {
                        $scope.displayedChecksRange = {from: data.from, to: data.to};
                        $scope.selectedRange = {from: data.from, to: data.to};
                    } else {
                        $scope.displayedChecksRange = null; // empty range
                        $scope.selectedRange = null;
                    }
                }).error(setErrorInScope.bind($scope));
            };

            $scope.brushChanged = function() {
                $scope.$digest();
            };

            $scope.$watch('displayedChecks', function(nv, ov) {
                if ( nv == ov ) return;
                refreshDisplayedList();
                refreshDisplayedCheckData();
            }, true);

            $scope.$watch('metricsChecks.displayedState.partition', function(nv, ov) {
                if ( nv == ov ) return;
                refreshDisplayedCheckData();
            }, false);

            $scope.$watch('allComputedChecks', function(nv, ov) {
                if ( nv == ov ) return;
                $scope.refreshDisplayedChecks();
            }, true);

            $scope.getDisplayedData = function(displayedCheck) {
                if ( displayedCheck == null ) return null;
                var checkName = displayedCheck.name;
                var found = null;
                $scope.displayedChecksHistories.forEach(function(displayedCheckHistory) {
                    if ( displayedCheckHistory.name == checkName ) {
                        found = displayedCheckHistory;
                    }
                });
                return found;
            };

            var getNiceMetricName = function(metricId) {
                var found = metricId;
                $scope.allComputedMetrics.metrics.forEach(function(computedMetric) {
                   if ( metricId == computedMetric.metric.id ) {
                       found = MetricsUtils.getMetricDisplayName(computedMetric);
                   }
                });
                return found;
            };
            $scope.getNiceInfo = function(check) {
                if ( check.type == 'python') {
                    return "Custom check (Python)";
                } else if ( check.type == 'numericRange') {
                    var metricName = getNiceMetricName(check.metricId);
                    var strictRangeCheck = null;
                    if (check.minimumEnabled && check.maximumEnabled) {
                        strictRangeCheck = " is between " + check.minimum + " and " + check.maximum;
                    } else if (check.minimumEnabled) {
                        strictRangeCheck = " is above " + check.minimum;
                    } else if (check.maximumEnabled) {
                        strictRangeCheck = " is below " + check.maximum;
                    }
                    var softRangeCheck = null;
                    if (check.softMinimumEnabled && check.softMaximumEnabled) {
                        softRangeCheck = " is outside " + check.softMinimum + " and " + check.softMaximum;
                    } else if (check.softMinimumEnabled) {
                        softRangeCheck = " is below " + check.softMinimum;
                    } else if (check.softMaximumEnabled) {
                        softRangeCheck = " is above " + check.softMaximum;
                    }
                    if ( strictRangeCheck && softRangeCheck ) {
                        return "Check that " + metricName + strictRangeCheck + ", warn if " + metricName + softRangeCheck;
                    } else if ( strictRangeCheck ) {
                        return "Check that " + metricName + strictRangeCheck;
                    } else if ( softRangeCheck ) {
                        return "Warn if " + metricName + softRangeCheck;
                    } else {
                        return "Empty check on " + metricName;
                    }
                } else if ( check.type == 'valueSet') {
                    var metricName = getNiceMetricName(check.metricId);
                    var info = "Check that " + metricName + "is among " + check.values.length + " values";
                    return info;
                }
            };

            $scope.lastComputeResult = null;
            function setLastComputeResult(result) {
                $scope.lastComputeResult = result;
                if (result) {
                    $scope.hasErrors = result.runs && result.runs.some(_ => _.error);
                    refreshDisplayedCheckData();
                }
            }

            if ($scope.metricsCallbacks.canRunChecks()) {
                $scope.computeNow = function() {
                    WT1.event("checks-compute-now");
                    $scope.saveMetricsNow().then(function() {
                        var partitionId = $scope.metricsCallbacks.getSelectedChecksPartitionId();
                        $scope.metricsCallbacks.runChecks(partitionId).success(function(data) {
                            FutureProgressModal.show($scope, data, "Computing checks…").then(setLastComputeResult);
                        }).error(setErrorInScope.bind($scope));
                    });
                };
                $scope.computeAll = function() {
                    WT1.event("checks-compute-all");
                    $scope.saveMetricsNow().then(function() {
                        $scope.metricsCallbacks.runChecksAll()
                        .success(MetricsUtils.computeProgressModal($scope, "Computing all checks…"))
                        .error(setErrorInScope.bind($scope));
                    });
                };
            } else {
                $scope.computeNow = null;
                $scope.computeAll = null;
            }

            $scope.checkIfStillComputing = function() {
                DataikuAPI.futures.getUpdate($scope.computing.jobId).success(function(data) {
                    setComputing(data);
                }).error(function (a,b,c) {
                    setComputing(null);
                    setErrorInScope.bind($scope)(a,b,c);
                });
            };

            $scope.addAllChecksDatasetInFlow = function(view, partition, filter) {
                WT1.event("checks-add-dataset-in-flow", {all:true});
                $scope.metricsCallbacks.createMetricsDataset(view, partition, filter).success(function(data) {
                    ActivityIndicator.success("Checks dataset created");
                    var i = $scope.allComputedChecks.notExistingViews.indexOf(view);
                    if (i >= 0) {
                        $scope.allComputedChecks.notExistingViews.splice(i, 1);
                    }
                }).error(setErrorInScope.bind($scope));
            };
            $scope.addOneCheckDatasetInFlow = function(computedCheck, view, partition, filter) {
                WT1.event("checks-add-dataset-in-flow", {all:false});
                $scope.metricsCallbacks.createMetricsDataset(view, partition, filter).success(function(data) {
                    ActivityIndicator.success("Checks dataset created");
                    var i = computedCheck.notExistingViews.indexOf(view);
                    if (i >= 0) {
                        computedCheck.notExistingViews.splice(i, 1);
                    }
                }).error(setErrorInScope.bind($scope));
            };

            $scope.addCheckValue = function() {
                CreateModalFromTemplate("/templates/metrics/add-check-value-modal.html", $scope, null, function(newScope) {
                    newScope.newCheck = {};
                    newScope.addCheckPoint = function(newCheck) {
                        var checksData = {};
                        if (newCheck.message && newCheck.message.length > 0) {
                            checksData[newCheck.name] = [newCheck.value, newCheck.message];
                        } else {
                            checksData[newCheck.name] = newCheck.value;
                        }
                        $scope.metricsCallbacks.saveExternalChecksValues(checksData).success(function(data) {
                            WT1.event("metrics-check-inserted", {objectType:$scope.metricsCallbacks.getObjectType()});
                            $scope.refreshAllComputedChecks();
                            newScope.dismiss();
                        }).error(setErrorInScope.bind(newScope));
                    };
                });
            };

            $scope.exportTable = function(){
                var exportColumns = [{"name":"Checks","type":"string"},
                                     {"name":"Infos","type":"string"},
                                     {"name":"Runs","type":"string"},
                                     {"name":"Last","type":"string"},
                                     {"name":"Message","type":"string"},
                                     {"name":"Status","type":"string"}];
                var exportRows = $scope.displayedChecksHistories.map(function(r) {
                    return [r.name,
                            $scope.getNiceInfo(r.check),
                            r.values.length,
                            $filter('date')(r.lastValue.time, 'yyyy-MM-dd HH:mm'),
                            r.lastValue.message,
                            r.lastValue.outcome];
                });
                ExportUtils.exportUIData($scope, {
                    name : "Checks",
                    columns : exportColumns,
                    data : exportRows
                }, "Export checks");
            };

        }
    };
});

/**
 * @ngdoc directive
 * @name splitWidth
 * @description
 *   Directive to apply on a table or parent of a table to get a cellWidth property in some uiState field in the scope,
 *   that can then be bound to width in a style attribute. It evenly splits the table's width and then applies a min-width.
 *   That's all because min-width on th/td has an undefined behavior...
 */
app.directive('splitWidth', function($rootScope, $timeout) {
    return {
        restrict : 'A',
        scope : {
            columnCount : '=',
            minWidth : '=',
            uiState : '=dkuUiState'
        },
        link : function($scope, element, attrs) {

            var refreshWidth = function() {
                var width = $(element).innerWidth();
                if ( $scope.columnCount ) {
                    var cellWidth = (width - 18) / $scope.columnCount;
                    if ( $scope.minWidth ) {
                        cellWidth = Math.max(cellWidth, $scope.minWidth);
                    }
                    $scope.uiState.cellWidth = cellWidth;
                    // reuse the same array as much as possible, otherwise the other directives bound to it might execute before the value is flushed in the parent context
                    $scope.uiState.cellsWidth = $scope.uiState.cellsWidth || [];
                    $scope.uiState.cellsWidth.splice(0,$scope.uiState.cellsWidth.length)
                    var remainder = 0;
                    for (var i=0;i<$scope.columnCount;i++) {
                        var cellWidthNext = cellWidth + remainder;
                        var cellWidthInt = Math.floor(cellWidthNext);
                        remainder = cellWidthNext - cellWidthInt;
                        $scope.uiState.cellsWidth.push(cellWidthInt);
                    }
                    element.offsetHeight; // cheat to force a refresh of the table layout. sometimes. (how is that working??!!??)
                    $rootScope.$broadcast('reflow');
                }
            };
            $timeout(refreshWidth);

            // update cell width whenever needed
            var eventName = 'resize.table.' + $scope.$id;
            $(window).on(eventName, function() { refreshWidth();});
            $scope.$on('$destroy', function(){$(window).off(eventName)});

            $scope.$watch('columnCount', refreshWidth);
            $scope.$watch('minWidth', refreshWidth);
        }
    };
});

app.directive('displayMetricsPerPartition', function(DataikuAPI, $stateParams, CreateModalFromTemplate, $timeout, $q, $filter, Debounce, Fn, FutureProgressModal, MetricsUtils, WT1, ActivityIndicator) {
    return {
        scope : true,
        restrict : 'A',
        templateUrl : "/templates/metrics/display-metrics-per-partition.html",
        link : function($scope, $element, attrs) {
            $scope.adjustForScroll = {};
            $scope.uiState = {listMode : 'banner', partitionQuery : null};
            $scope.displayedMetricByPartitionData = [];
            $scope.canCompute = $scope.$eval(attrs.canCompute); // if false, no 'compute' button, and only building the object can compute metrics (ie: saved models)

            $scope.$watch('metrics', function(nv, ov) {
                if ( $scope.metrics == null ) return;
                init();
            }, false);

            var init = function() {
                refreshDisplayedPartitionData();
            };

            $scope.exportPartitionsTable = function() {
                $scope.$broadcast('exportPartitionsTable');
            };

            $scope.partitionSearch = function(partition) {
                if ( !$scope.uiState.partitionQuery ) return true;
                if ( partition == null || partition.partition == null) return false;
                return partition.partition.toLowerCase().indexOf($scope.uiState.partitionQuery.toLowerCase()) >= 0;
            };

            if ($scope.metricsCallbacks.canComputeMetrics()) {
                $scope.computeNow = function() {
                    $scope.saveMetricsNow().then(function() {
                        $scope.computeAllForPartition($scope.metricsCallbacks.getSelectedMetricsPartitionId());
                    });
                };

                $scope.computeAll = function() {
                    $scope.saveMetricsNow().then(function() {
                        $scope.metricsCallbacks.computeMetricsAll()
                        .success(MetricsUtils.computeProgressModal($scope, "Computing all metrics"))
                        .error(setErrorInScope.bind($scope));
                    });
                };
                $scope.computeMetricForAll = function(displayedMetric) {
                    var probes = $scope.metrics.probes.filter(function(probe){return probe.type == displayedMetric.computingProbe;});
                    if ( probes.length == 1 ) {
                        var metrics = angular.copy($scope.metrics);
                        metrics.probes = probes;
                        $scope.metricsCallbacks.computeProbe('ALL', true, metrics)
                        .success(MetricsUtils.computeProgressModal($scope, "Computing metric"))
                        .error(setErrorInScope.bind($scope));
                    }
                };

                $scope.computeAllForPartition = function(partitionId) {
                    var modalTitle = "Computing all metrics" + (partitionId == null ? "" : " for partition " + partitionId) + "…";

                    $scope.metricsCallbacks.computeMetrics(partitionId)
                    .success(MetricsUtils.computeProgressModal($scope, modalTitle))
                    .error(setErrorInScope.bind($scope));
                };
            } else {
                $scope.computeNow = null;
                $scope.computeAll = null;
                $scope.computeMetricForAll = null;
                $scope.computeAllForPartition = null;
            }

            $scope.orderByFunc = function(metricIdx) {
                if (metricIdx === '__partition__') return Fn.SELF;

                return function(partitionId) {
                    return MetricsUtils.getFormattedValueForPartition($scope.displayedMetrics.metrics[metricIdx], partitionId, $scope.displayedMetricByPartitionData);
                }
            };

            $scope.getDisplayedPartitionsData = function(displayedMetric) {
                if ( displayedMetric == null || displayedMetric.metric == null ) return null;
                var metricId = displayedMetric.metric.id;
                var found = null;
                $scope.displayedMetricByPartitionData.forEach(function(displayedMetricPartition) {
                    if ( displayedMetricPartition.metricId == metricId ) {
                        found = displayedMetricPartition;
                    }
                });
                return found;
            };

            $scope.addAllMetricsDatasetInFlow = function(view, partition, filter) {
                WT1.event("metrics-add-dataset-in-flow", {all:true});
                $scope.metricsCallbacks.createMetricsDataset(view, partition, filter).success(function(data) {
                    ActivityIndicator.success("Metrics dataset created");
                    var i = $scope.allComputedMetrics.notExistingViews.indexOf(view);
                    if (i >= 0) {
                        $scope.allComputedMetrics.notExistingViews.splice(i, 1);
                    }
                }).error(setErrorInScope.bind($scope));
            };
            $scope.clearAll  = function() {
                WT1.event("metrics-clear");
                $scope.metricsCallbacks.clearMetrics().success(function(data) {
                    ActivityIndicator.success("Metrics cleared");
                    $scope.$emit('metrics-refresh-displayed-data');
                }).error(setErrorInScope.bind($scope));
            };

            var refreshDisplayedPartitionData = function() {
                if ( $scope.displayedMetrics == null || !$scope.displayedMetrics.$loaded || $scope.metrics == null || $scope.metrics.displayedState == null ) return;
                // fetch the data
                $scope.metricsCallbacks.getPreparedMetricPartitions($scope.metrics.displayedState).success(function(data) {
                    $scope.displayedMetricByPartitionData = data.metrics.map(function(displayedData) {return MetricsUtils.fixupDisplayType(displayedData);});
                    refreshPartitionsRange();
                }).error(setErrorInScope.bind($scope));
            };

            $scope.$on('metrics-refresh-displayed-data', refreshDisplayedPartitionData);

            var refreshPartitionsRange = function() {
                if ($scope.metricsPartitions && $scope.metricsPartitions.isTimePartition) {
                    $scope.displayedPartitionsRange = {from: d3.min($scope.metricsPartitions.partitions, Fn.prop('partitionTime')), to: d3.max($scope.metricsPartitions.partitions, Fn.prop('partitionTime'))};
                    // try to keep the range
                    if ( $scope.selectedRange == null || $scope.selectedRange.from < 0 || $scope.selectedRange.from > $scope.displayedPartitionsRange.to ) {
                        $scope.selectedRange = {from : $scope.displayedPartitionsRange.from, to : $scope.displayedPartitionsRange.to};
                    } else if ( $scope.selectedRange == null || $scope.selectedRange.to < 0 || $scope.selectedRange.to < $scope.displayedPartitionsRange.from ) {
                        $scope.selectedRange = {from : $scope.displayedPartitionsRange.from, to : $scope.displayedPartitionsRange.to};
                    } else {
                        $scope.selectedRange = {from : Math.max($scope.selectedRange.from, $scope.displayedPartitionsRange.from)
                                                , to : Math.min($scope.selectedRange.to, $scope.displayedPartitionsRange.to)};
                    }
                    filterMetricsPartitions();
                }
            };

            var filterMetricsPartitions = function() {
                if (!$scope.metricsPartitions) return $scope.filteredMetricsPartitions = [];

                if ($scope.metricsPartitions.isTimePartition) {
                    $scope.filteredMetricsPartitions = $scope.metricsPartitions.partitions.filter(function(p) {
                        if ( !$scope.selectedRange || !$scope.selectedRange.from || !$scope.selectedRange.to ) {
                            // no filtering
                            return true;
                        }
                        return p.partitionTime >= $scope.selectedRange.from && p.partitionTime <= $scope.selectedRange.to;
                    }).map(Fn.prop('partition'));
                } else {
                    if ($scope.uiState.partitionQuery) {
                        $scope.filteredMetricsPartitions = $filter('filter')($scope.metricsPartitionsIds, $scope.uiState.partitionQuery);
                    } else {
                        $scope.filteredMetricsPartitions = $scope.metricsPartitionsIds.concat([]);
                    }
                }
                // remove ALL from the list
                $scope.filteredMetricsPartitions = $scope.filteredMetricsPartitions.filter(function(p) {return p != 'ALL';});
            };

            $scope.brushChanged = function() {
                $scope.$digest();
                filterMetricsPartitions();
            };

            $scope.$watch("metricsPartitionsIds", filterMetricsPartitions, true);
            $scope.$watch("metricsPartitions.partitions",  filterMetricsPartitions, true);
            $scope.$watch("uiState.partitionQuery", Debounce().withDelay(400, 400).wrap(filterMetricsPartitions));

            $scope.$on('metrics-refresh-partition-list', function(e, result) {
                $scope.lastComputeResult = result;
                $scope.hasErrors = result.runs && result.runs.some(_ => _.error);
            });

            $scope.$watch('displayedMetrics', function(nv, ov) {
                if ( nv == ov ) return;
                refreshDisplayedPartitionData();
            }, true);
            filterMetricsPartitions();
        }
    };
});

app.directive('partitionTableData', function(MetricsUtils, ExportUtils) {
    return {
        scope : false,
        restrict : 'A',
        link: function($scope, element, attrs) {
            $scope.displayedTableColumns = [];
            $scope.displayedTableRows = [];

            var refreshDisplayedColumns = function() {
                $scope.displayedTableColumns = [{isPartition:true, $sortIndex:-1}];
                if ($scope.displayedMetrics && $scope.displayedMetrics.metrics) {
                    $scope.displayedMetrics.metrics.forEach(function(displayedMetric, i) {
                        displayedMetric.$sortIndex = i;
                        $scope.displayedTableColumns.push(displayedMetric);
                    });
                }
                $scope.displayedTableColumns.push({isActions:true});
            };
            var refreshDisplayedRows = function() {
                var sortedPartitions = sortPartitionRows();
                // build rows for the fattable
                $scope.displayedTableRows = [];
                if (sortedPartitions) {
                    sortedPartitions.forEach(function(partition) {
                        var row = [{isPartition:true, partition:partition}];
                        if ($scope.displayedMetrics && $scope.displayedMetrics.metrics) {
                            $scope.displayedMetrics.metrics.forEach(function(displayedMetric) {
                                row.push({displayedMetric:displayedMetric, partition:partition});
                            });
                        }
                        row.push({isActions:true, partition:partition});
                        $scope.displayedTableRows.push(row);
                    });
                }
                {
                    var partition = 'ALL';
                    var row = [{isPartition:true, partition:partition}];
                    if ($scope.displayedMetrics && $scope.displayedMetrics.metrics) {
                        $scope.displayedMetrics.metrics.forEach(function(displayedMetric) {
                            row.push({displayedMetric:displayedMetric, partition:partition});
                        });
                    }
                    row.push({isActions:true, partition:partition});
                    $scope.displayedTableRows.push(row);
                }
            };
            var sortPartitionRows = function() {
                if ($scope.filteredMetricsPartitions && $scope.sortColumn) {
                    var sortedPartitions = $scope.filteredMetricsPartitions.concat();
                    if ($scope.sortColumn < 0) {
                        sortedPartitions.sort(function(a,b) {
                            var cmp = a.localeCompare(b);
                            return $scope.sortDescending ? -cmp : cmp;
                        });
                    } else {
                        var displayedMetric = $scope.displayedMetrics.metrics[$scope.sortColumn];
                        var values = sortedPartitions.map(function(partition) {
                            const value = MetricsUtils.getRawValueForPartition(displayedMetric, partition, $scope.displayedMetricByPartitionData);
                            return {partition, value};
                        });
                        values.sort(function(a,b) {
                            // send the null values to the bottom (regardless of descending or not)
                            if (a.value == null && b.value == null) return 0;
                            if (a.value == null && b.value != null) return 1;
                            if (a.value != null && b.value == null) return -1;
                            // then sort for real
                            var cmp = 0;
                            if ( angular.isNumber(a.value) && angular.isNumber(b.value)) {
                                cmp = a.value - b.value;
                            } else {
                                cmp = ('' + a.value).localeCompare('' + b.value);
                            }
                            return $scope.sortDescending ? -cmp : cmp;
                        });
                        sortedPartitions = values.map(function(value) {return value.partition;})
                    }
                    return sortedPartitions;
                } else {
                    return $scope.filteredMetricsPartitions.concat();
                }
            };

            $scope.$on('exportPartitionsTable', function() {
                $scope.exportTable();
            });
            $scope.exportTable = function(){
                var exportColumns = $scope.displayedTableColumns.map(function(c) {
                    if (c.isPartition) return {"name":"Partition","type":"string"};
                    if (c.isActions) return null;
                    return {"name":MetricsUtils.getMetricDisplayName(c),"type":"string"};
                }).filter(function(c) {return c != null;});
                var exportRows = $scope.displayedTableRows.map(function(r) {
                    return r.map(function(c) {
                        if (c.isPartition) return c.partition;
                        if (c.isActions) return null;
                        // don't return null if empty, because of the filter below
                        return MetricsUtils.getRawValueForPartition(c.displayedMetric, c.partition, $scope.displayedMetricByPartitionData);
                    }).filter(function(c) {return c != null;});
                });
                ExportUtils.exportUIData($scope, {
                    name : "Metrics per partition",
                    columns : exportColumns,
                    data : exportRows
                }, "Export metrics");
            };

            refreshDisplayedColumns();
            refreshDisplayedRows();

            $scope.$watch("filteredMetricsPartitions", refreshDisplayedRows, true);
            $scope.$watch("displayedMetricByPartitionData", refreshDisplayedRows);
            $scope.$watch('displayedMetrics', function(nv, ov) {
                if (angular.equals(nv, ov)) return;
                refreshDisplayedColumns();
                refreshDisplayedRows();
            }, true);
            $scope.$watch("sortColumn", refreshDisplayedRows);
            $scope.$watch("sortDescending", refreshDisplayedRows);
       }
    };
});

app.directive('displayMetricsPerColumn', function(DataikuAPI, $stateParams, CreateModalFromTemplate, $timeout, $q, $filter, Debounce, Fn, FutureProgressModal, MetricsUtils, WT1, ActivityIndicator) {
    return {
        scope : true,
        restrict : 'A',
        templateUrl : "/templates/metrics/display-metrics-per-column.html",
        link : function($scope, $element, attrs) {
            $scope.adjustForScroll = {};
            $scope.uiState = {listMode : 'banner', columnQuery : null};
            $scope.displayedMetricByColumnData = [];
            $scope.canCompute = $scope.$eval(attrs.canCompute); // if false, no 'compute' button, and only building the object can compute metrics (ie: saved models)
            $scope.metricsColumnsNames = [];

            $scope.exportColumnsTable = function() {
                $scope.$broadcast('exportColumnsTable');
            };

            $scope.$watch('metrics', function(nv, ov) {
                if ( $scope.metrics == null ) return;
                init();
            }, false);

            var init = function() {
                refreshDisplayedColumnData();
            };

            $scope.columnSearch = function(column) {
                if ( !$scope.uiState.columnQuery ) return true;
                if ( column == null || column.column == null) return false;
                return column.column.toLowerCase().indexOf($scope.uiState.columnQuery.toLowerCase()) >= 0;
            };

            $scope.computeNow = function() {
                $scope.saveMetricsNow().then(function() {
                    $scope.computeAllForPartition($scope.metricsCallbacks.getSelectedMetricsPartitionId());
                });
            };

            $scope.computeAll = function() {
                $scope.saveMetricsNow().then(function() {
                    $scope.metricsCallbacks.computeMetricsAll()
                        .success(MetricsUtils.computeProgressModal($scope, "Computing all metrics"))
                        .error(setErrorInScope.bind($scope));
                });
            };

            $scope.computeAllForPartition = function(partitionId) {
                var modalTitle = "Computing all metrics" + (partitionId == null ? "" : " for partition " + partitionId) + "…";

                $scope.metricsCallbacks.computeMetrics(partitionId)
                    .success(MetricsUtils.computeProgressModal($scope, modalTitle))
                    .error(setErrorInScope.bind($scope));
            };

            $scope.computeAllForColumn = function(columnName) {
                var modalTitle = "Computing all metrics" + (columnName == null ? "" : " for column " + columnName) + "…";

                $scope.metricsCallbacks.computeColumnMetrics(columnName, $scope.metricsCallbacks.getSelectedMetricsPartitionId())
                    .success(MetricsUtils.computeProgressModal($scope, modalTitle))
                    .error(setErrorInScope.bind($scope));
            };

            $scope.getDisplayedColumnsData = function(displayedMetric) {
                if ( displayedMetric == null || displayedMetric.metric == null ) return null;
                var metricId = displayedMetric.metric.id;
                var found = null;
                $scope.displayedMetricByColumnData.forEach(function(displayedMetricColumn) {
                    if ( displayedMetricColumn.metricId == metricId ) {
                        found = displayedMetricColumn;
                    }
                });
                return found;
            };

            $scope.addAllMetricsDatasetInFlow = function(view, partition, filter) {
                WT1.event("metrics-add-dataset-in-flow", {all:true});
                $scope.metricsCallbacks.createMetricsDataset(view, partition, filter).success(function(data) {
                    ActivityIndicator.success("Metrics dataset created");
                    var i = $scope.allComputedMetrics.notExistingViews.indexOf(view);
                    if (i >= 0) {
                        $scope.allComputedMetrics.notExistingViews.splice(i, 1);
                    }
                }).error(setErrorInScope.bind($scope));
            };
            $scope.clearAll  = function() {
                WT1.event("metrics-clear");
                $scope.metricsCallbacks.clearMetrics().success(function(data) {
                    ActivityIndicator.success("Metrics cleared");
                    $scope.$emit('metrics-refresh-displayed-data');
                }).error(setErrorInScope.bind($scope));
            };

            var refreshDisplayedColumnData = function() {
                if ( $scope.displayedMetrics == null || !$scope.displayedMetrics.$loaded || $scope.metrics == null || $scope.metrics.displayedState == null ) return;
                // fetch the data
                $scope.metricsCallbacks.getPreparedMetricColumns($scope.metrics.displayedState).success(function(data) {
                    $scope.displayedMetricByColumnData = data.metrics.map(function(displayedData) {return MetricsUtils.fixupDisplayType(displayedData);});
                    var columnNames = [];
                    data.metrics.forEach(function(metricsColumn) {
                        metricsColumn.values.forEach(function(point) {
                            if (columnNames.indexOf(point.column) < 0) {
                                columnNames.push(point.column);
                            }
                        });
                    });
                    $scope.metricsColumnsNames = columnNames;
                }).error(setErrorInScope.bind($scope));
            };

            $scope.$on('metrics-refresh-displayed-data', refreshDisplayedColumnData);

            var filterMetricsColumns = function() {
                if (!$scope.metricsColumnsNames) return $scope.filteredMetricsColumns = [];
                if ($scope.uiState.columnQuery) {
                    $scope.filteredMetricsColumns = $filter('filter')($scope.metricsColumnsNames, $scope.uiState.columnQuery);
                } else {
                    $scope.filteredMetricsColumns = $scope.metricsColumnsNames.concat([]);
                }
                // remove ALL from the list
                $scope.filteredMetricsColumns = $scope.filteredMetricsColumns.filter(function(p) {return p != 'ALL';});
            };

            $scope.brushChanged = function() {
                $scope.$digest();
                filterMetricsColumns();
            };

            $scope.$watch("metricsColumnsNames", filterMetricsColumns, true);
            $scope.$watch("metricsColumns.columns",  filterMetricsColumns, true);
            $scope.$watch("uiState.columnQuery", Debounce().withDelay(400, 400).wrap(filterMetricsColumns));

            $scope.$watch('metrics.displayedState.columns', function(nv, ov) {
                if ( nv == ov ) return;
                refreshDisplayedColumnData();
                // autosave?
            }, false);
            $scope.$watch('metrics.displayedState.partition', function(nv, ov) {
                if ( nv == ov ) return;
                refreshDisplayedColumnData();
                // autosave?
            }, false);

            $scope.$watch('displayedMetrics', function(nv, ov) {
                if ( nv == ov ) return;
                refreshDisplayedColumnData();
            }, true);
            filterMetricsColumns();
        }
    };
});

app.directive('columnTableData', function(MetricsUtils, ExportUtils) {
    return {
        scope : false,
        restrict : 'A',
        link: function($scope, element, attrs) {
            $scope.displayedTableColumns = [];
            $scope.displayedTableRows = [];

            var refreshDisplayedColumns = function() {
                $scope.displayedTableColumns = [{isColumn:true, $sortIndex:-1}];
                if ($scope.displayedMetricByColumnData) {
                    $scope.displayedMetricByColumnData.forEach(function(displayedMetric, i) {
                        displayedMetric.$sortIndex = i;
                        $scope.displayedTableColumns.push(displayedMetric);
                    });
                }
                $scope.displayedTableColumns.push({isActions:true});
            };
            var refreshDisplayedRows = function() {
                var sortedColumns = sortColumnRows();
                // build rows for the fattable
                $scope.displayedTableRows = [];
                if (sortedColumns) {
                    sortedColumns.forEach(function(column) {
                        var row = [{isColumn:true, column:column}];
                        if ($scope.displayedMetricByColumnData) {
                            $scope.displayedMetricByColumnData.forEach(function(displayedMetric) {
                                row.push({displayedMetric:displayedMetric, column:column});
                            });
                        }
                        row.push({isActions:true, column:column});
                        $scope.displayedTableRows.push(row);
                    });
                }
            };
            var sortColumnRows = function() {
                if ($scope.filteredMetricsColumns && $scope.sortColumn) {
                    var sortedColumns = $scope.filteredMetricsColumns.concat();
                    if ($scope.sortColumn < 0) {
                        sortedColumns.sort(function(a,b) {
                            var cmp = a.localeCompare(b);
                            return $scope.sortDescending ? -cmp : cmp;
                        });
                    } else {
                        var displayedMetric = $scope.displayedMetricByColumnData[$scope.sortColumn];
                        var values = sortedColumns.map(function(column) {
                            const value = MetricsUtils.getRawValueForColumn(displayedMetric, column, $scope.displayedMetricByColumnData);
                            return {column, value};
                        });
                        values.sort(function(a,b) {
                            // send the null values to the bottom (regardless of descending or not)
                            if (a.value == null && b.value == null) return 0;
                            if (a.value == null && b.value != null) return 1;
                            if (a.value != null && b.value == null) return -1;
                            // then sort for real
                            var cmp = 0;
                            if ( angular.isNumber(a.value) && angular.isNumber(b.value)) {
                                cmp = a.value - b.value;
                            } else {
                                cmp = ('' + a.value).localeCompare('' + b.value);
                            }
                            return $scope.sortDescending ? -cmp : cmp;
                        });
                        sortedColumns = values.map(function(value) {return value.column;})
                    }
                    return sortedColumns;
                } else {
                    return $scope.filteredMetricsColumns.concat();
                }
            };

            refreshDisplayedColumns();
            refreshDisplayedRows();

            $scope.$on('exportColumnsTable', function() {
                $scope.exportTable();
            });
            $scope.exportTable = function(){
                var exportColumns = $scope.displayedTableColumns.map(function(c) {
                    if (c.isColumn) return {"name":"Column","type":"string"};
                    if (c.isActions) return null;
                    return {"name":MetricsUtils.getMetricName(c),"type":"string"};
                }).filter(function(c) {return c != null;});
                var exportRows = $scope.displayedTableRows.map(function(r) {
                    return r.map(function(c) {
                        if (c.isColumn) return c.column;
                        if (c.isActions) return null;
                        // don't return null if empty, because of the filter below
                        return MetricsUtils.getFormattedValueForColumn(c.displayedMetric, c.column, $scope.displayedMetricByColumnData);
                    }).filter(function(c) {return c != null;});
                });
                ExportUtils.exportUIData($scope, {
                    name : "Metrics per column",
                    columns : exportColumns,
                    data : exportRows
                }, "Export metrics");
            };

            $scope.$watch("filteredMetricsColumns", refreshDisplayedRows, true);
            $scope.$watch("displayedMetricByColumnData", refreshDisplayedRows);
            $scope.$watch("displayedMetricByColumnData", refreshDisplayedColumns);
            $scope.$watch('displayedMetrics', function(nv, ov) {
                if ( angular.equals(nv, ov) ) return;
                refreshDisplayedColumns();
                refreshDisplayedRows();
            }, true);
            $scope.$watch("sortColumn", refreshDisplayedRows);
            $scope.$watch("sortDescending", refreshDisplayedRows);
       }
    };
});

app.controller('ListWithCountsController', function($scope) {
    $scope.$watch('point.value', function() {
        $scope.listWithCounts = [];
        if ($scope.point && $scope.point.value) {
            $scope.listWithCounts = [];
            $scope.point.value.forEach(function(row) {
                var value = null;
                var count = null;
                angular.forEach(JSON.parse(row), function(v, k) {
                    value = k;
                    count = v;
                });
                $scope.listWithCounts.push({value:value, count:count})
            });
        }
    });
});
app.controller('HistogramMetricPointController', function($scope, MetricsUtils) {
    $scope.$watch('point.value', function() {
        $scope.histogram = null;
        if ($scope.point && $scope.point.value) {
        	$scope.histogram = MetricsUtils.preprocessHistogram($scope.point.value);
        }
    });
});

// take the last value of the metric and offer it as the 'point' variable for the displaying templates
app.directive('metricLastValue', function(MetricsUtils) {
    return {
        scope : {
            displayedMetric : '=',
            displayedData : '='
        },
        restrict : 'A',
        templateUrl : "/templates/metrics/last-value.html",
        link: function($scope, element, attrs) {
            $scope.MetricsUtils = MetricsUtils;
            $scope.$watch('displayedData', function(nv) {
                if (!nv) return;
                $scope.point = MetricsUtils.getLastValue($scope.displayedData);
            })
        }
    }
});
// one tile to display the last value of a metric
app.directive('metricTile', function(MetricsUtils) {
    return {
        scope : {
            displayedMetric : '=',
            displayedData : '=',
            computeMetricForAll : '=',
            computeMetricForSelected : '=',
            computeMetricForObject : '=',
            createAndPinInsight : '='
        },
        restrict : 'A',
        templateUrl : "/templates/metrics/tile.html",
        link: function($scope, element, attrs) {
            $scope.MetricsUtils = MetricsUtils;

            $scope.$watch('displayedData', function(nv) {
                if (!nv) return;
                $scope.lastValue = MetricsUtils.getLastValue($scope.displayedData);
            })
        }
    }
});
// on banner to display the last value and the history of values
app.directive('metricBanner', function(MetricsUtils) {
    return {
        scope : {
            displayedMetric : '=',
            displayedData : '=',
            displayedRange : '=',
            displayedPartitions : '=',
            displayedPartitionsRange : '=',
            computeMetricForAll : '=',
            computeMetricForSelected : '=',
            computeMetricForObject : '=',
            createAndPinInsight : '='
        },
        replace: true,
        restrict : 'A',
        templateUrl : "/templates/metrics/banner.html",
        link: function($scope, element, attrs) {
            $scope.MetricsUtils = MetricsUtils;
            $scope.adjustForScroll = {left:0};
            element.on('scroll', function() {
                $scope.$apply(function() {$scope.adjustForScroll.left = element[0].scrollLeft;});
            });

            $scope.$watch('displayedData', function(nv) {
                if (!nv) return;
                $scope.lastValue = MetricsUtils.getLastValue($scope.displayedData);
            })
        }
    }
});
// on banner to display the values of a metric on the different partitions (no 'last value' singled out)
app.directive('partitionBanner', function(MetricsUtils) {
    return {
        scope : {
            displayedMetric : '=',
            displayedData : '=',
            displayedPartitions : '=',
            displayedPartitionsRange : '=',
            computeMetricForAll : '=',
            computeMetricForSelected : '=',
            computeMetricForObject : '='
        },
        replace: true,
        restrict : 'A',
        templateUrl : "/templates/metrics/partition-banner.html",
        link: function($scope, element, attrs) {
            $scope.MetricsUtils = MetricsUtils;
            $scope.adjustForScroll = {left:0};
            element.on('scroll', function() {
                $scope.$apply(function() {$scope.adjustForScroll.left = element[0].scrollLeft;});
            });

            $scope.$watch('displayedData', function(nv) {
                if (!nv) return;
                $scope.lastValue = MetricsUtils.getLastValue($scope.displayedData);
            });
        }
    }
});
app.directive('checkBanner', function(MetricsUtils) {
    return {
        scope : {
            displayedCheck : '=',
            displayedData : '=',
            displayedRange : '='
        },
        replace: true,
        restrict : 'A',
        templateUrl : "/templates/metrics/check-banner.html",
        link: function($scope, element, attrs) {
            $scope.MetricsUtils = MetricsUtils;
            $scope.adjustForScroll = {left:0};
            element.on('scroll', function() {
                $scope.$apply(function() {$scope.adjustForScroll.left = element[0].scrollLeft;});
            });
            $scope.pointInRange = function(point) {
                return point.time >= $scope.displayedRange.from && point.time <= $scope.displayedRange.to;
            };

            $scope.$watch('displayedData', function(nv) {
                if (!nv) return;
                $scope.lastValue = $scope.displayedData.lastValue;
            })
        }
    }
});

/*
    Displays one of:
        - the history of the given metric for the given range (if displayedRange is set)
        - the last value of the metric for the given partitions (if displayedPartitions is set)
*/
app.directive('metricHistory', function($filter, MetricsUtils, Fn, $rootScope, Debounce) {
    return {
        scope : {
            displayedMetric : '=',
            displayedData : '=',
            displayedRange : '=',
            displayedPartitions : '=',
            displayedPartitionsRange : '=',
            averageValue : '=',
            tooltipsContainer: '@'
        },
        restrict : 'A',
        templateUrl : "/templates/metrics/metric-history.html",
        link : function($scope, element, attrs) {
            $scope.MetricsUtils = MetricsUtils;

            $scope.pointFilter = function(point) {
                if ($scope.displayedRange) return point.time >= $scope.displayedRange.from && point.time <= $scope.displayedRange.to;
                if ($scope.displayedPartitionsRange) return point.partitionTime >= $scope.displayedPartitionsRange.from && point.partitionTime <= $scope.displayedPartitionsRange.to;
                if ($scope.displayedPartitions) return $scope.displayedPartitions.indexOf(point.partition) > -1;
            };

            var init = function() {
                if ($scope.displayedData == null) return;
                var chartSvg = d3.select(element[0]).select(".chart");
                chartSvg.select("*").remove(); // clear chart
                if ($scope.displayedData.$isPlotted) {
                    var coldWarm = d3.interpolateRgb('#59B3CE', d3.rgb(255,50,50));
                    var values = $scope.displayedData.values.filter(function(v) { return v.hasOwnProperty('value'); });
                    if (values && values.length > 0) {
                        /** put the time of the next point in each point **/
                        for (var i=1;i<values.length;i++) {
                            values[i-1].$nextTime = values[i].time;
                            values[i-1].$nextPartitionTime = values[i].partitionTime;
                        }

                        /** Common behavior for the bar & line charts **/
                        var chartZone = $(element);
                        var margins = {left: 0, right: 0, top: 20, bottom: 35};
                        var width, height, vizWidth, vizHeight, drawn;
                        var x, updateRanges, draw;

                        var viz = chartSvg.append("g");

                        var xAxisG = viz.append("g").attr("class", "x axis");
                        var yAxisLinesG = viz.append("g").attr("class", "y axis lines");
                        var yAxisLabelsG = viz.append("g").attr("class", "y axis labels");
                        var hiddenRectsG = viz.append("g");
                        var actionsG = viz.append("g").attr("class", "actions");

                        var xAxis = d3.svg.axis()
                            .orient('bottom')
                            .ticks(10)
                            .tickSize(-5, 0);

                        var extent;
                        if ($scope.displayedData.$displayType != 'histogram') {
                        	extent = d3.extent(values, Fn.prop('value'));
                        } else {
                        	var min = NaN, max = NaN;
                        	values.forEach(function(v) {
                        		if (v.$histogram == null) {
                        			v.$histogram = MetricsUtils.preprocessHistogram(v.value);
                        		}
                        		if (v.$histogram != null) {
                        			v.$histogram.chistogram.forEach(function(bin) {
                        				if (isNaN(min) || isNaN(max)) {
                        					min = bin[0];
                        					max = bin[1];
                        				} else {
                        					min = Math.min(min, bin[0]);
                        					max = Math.max(max, bin[1]);
                        				}
                        			});
                        		}
                        	});
                        	extent = [min, max];
                        }

                        extent[0] = Math.min(extent[0], 0);
                        if (extent[1] <= 0 && $scope.displayedRange) { margins.top += 15; margins.bottom -= 15; xAxis.orient('top'); }
                        extent[1] = Math.max(extent[1], 0);
                        var y;
                        var yIsDate;
                        if ($scope.displayedData.schemaColumn && $scope.displayedData.schemaColumn.type == 'date') {
                            y = d3.time.scale().domain(extent);
                            yIsDate = true;
                        } else {
                            y = d3.scale.linear().domain(extent);
                            yIsDate = false;
                        }

                        var yAxisLines = d3.svg.axis()
                            .scale(y)
                            .orient('right')
                            .ticks(3);

                        var yAxisLabels = d3.svg.axis()
                            .scale(y)
                            .orient('right')
                            .tickSize(10)
                            .ticks(3);

                        viz.attr("transform", "translate(" + margins.left + ", " + margins.top + ")");

                        var drawCommon = function(resize) {
                            if (resize) {
                                xAxisG.attr("transform", "translate(0, " + y(0) + ")");
                                yAxisLinesG.call(yAxisLines);
                                yAxisLabelsG.call(yAxisLabels);
                                yAxisLinesG.select('path.domain').remove();
                                yAxisLabelsG.select('path.domain').remove();
                                yAxisLabelsG.selectAll('.tick').each(function() {
                                    var tick = d3.select(this);
                                    var bbox = this.getBoundingClientRect();
                                    tick.insert('rect', ':first-child')
                                        .attr('height', bbox.height+2)
                                        .attr('width', bbox.width+10)
                                        .attr('fill', 'white')
                                        .attr('stroke', 'none')
                                        .attr('x', bbox.x - 5)
                                        .attr('y', bbox.y - 1);
                                });
                            }

                            xAxisG.call(xAxis);
                        };

                        var updateRangesCommon = function() {
                            height = chartZone.innerHeight();
                            width = chartZone.select('.metric-plot').width();
                            vizWidth = width - margins.left - margins.right;
                            vizHeight = height - margins.top - margins.bottom;
                            x.range([0, vizWidth]);
                            y.range([vizHeight, 0]);
                            yAxisLines.tickSize(vizWidth);
                        };

                        /*** Metric history line chart ***/
                        if ($scope.displayedRange && $scope.displayedData.$displayType != 'histogram') { // metric history
                            x = d3.time.scale();
                            xAxis.scale(x);

                            updateRanges = updateRangesCommon;

                            var area = d3.svg.area()
                                .x(function(d) { return x(new Date(d.time)); })
                                .y0(function(d) { return y(0); })
                                .y1(function(d) { return y(d.value); });

                            var line = d3.svg.line()
                                .x(function(d) { return x(new Date(d.time)); })
                                .y(function(d) { return y(d.value); });

                            var areaPath = actionsG.append("path")
                                .datum(values)
                                .attr("class", "points-area");

                            var linePath = actionsG.append("path")
                                .datum(values)
                                .attr("class", "points-line");

                            var points = actionsG
                                .selectAll('circle.point')
                                .data(values)
                                .enter()
                                .append('circle')
                                .attr('class', 'point')
                                .attr('r', 4);

                            var addTooltipListener = function(sel) {
                                return sel.on("mousemove", function() {
                                    points.classed('focus', function(d,i) { return i === values.length -1; });

                                    var closest, min, offset = $(chartSvg[0][0]).offset();
                                    points.each(function() {
                                        var dist = Math.pow(Math.abs(d3.event.pageX - offset.left - margins.left - this.getAttribute('cx')),2)
                                            + Math.pow(Math.abs(d3.event.pageY - offset.top - margins.top - this.getAttribute('cy')),2);

                                        if (min === undefined || dist < min) {
                                            min = dist;
                                            closest = this;
                                        }
                                    });

                                    d3.select(closest).each(function(d) {
                                        $rootScope.$broadcast('metrics-charts-focus-point', {time: d.time});
                                    });

                                }).on("mouseout", function() {
                                    $rootScope.$broadcast('metrics-charts-unfocus-point');
                                });
                            };

                            if (points.length == 1) {
                                points.call(addTooltipListener);
                            }

                            var hoverPath = actionsG.append("path")
                                .datum(values)
                                .attr("stroke-width", 10)
                                .attr("stroke", "black")
                                .attr("opacity", 0)
                                .call(addTooltipListener);

                            $scope.$on('metrics-charts-focus-point', function(event, data) {
                                points.classed("focus", function(d,i) { return i === values.length -1; });
                                points
                                    .filter(function(d) { return d.time === data.time; })
                                    .classed("focus", true)
                                    .each(function(d) {
                                        $scope.setTooltipContent(
                                            '<h4><i class="point"></i>' + sanitize(MetricsUtils.getMetricDisplayName($scope.displayedMetric)) + '</h4>'+
                                            '<span class="date">' + sanitize($filter('date')(d.time, 'yyyy-MM-dd HH:mm')) + '</span>'+
                                            '<span class="value">' + sanitize(MetricsUtils.getFormattedValue(d.value, $scope.displayedMetric, $scope.displayedData)) + '</span>'
                                        );
                                        $scope.showTooltip(parseFloat(this.getAttribute('cx')) + margins.left, parseFloat(this.getAttribute('cy')) + margins.top);
                                    })
                            });

                            $scope.$on('metrics-charts-unfocus-point', function(event, data) {
                                points.classed("focus", function(d,i) { return i === values.length -1; });
                                $scope.hideTooltip();
                            });

                            draw = function(resized) {
                                drawCommon(resized);

                                areaPath.attr("d", area);
                                linePath.attr("d", line);
                                points.attr('cx', function(d) { return x(new Date(d.time)); })
                                    .attr('cy', function(d) { return y(d.value); })
                                    .classed('focus', function(d,i) { return i === values.length -1; });
                                hoverPath.attr("d", line);

                            };

                            $scope.$watch("displayedRange", function(nv) {
                                if (!nv) return;

                                /* Add a 3% margin on both sides */
                                var range = { from: nv.from, to: nv.to };
                                var margin = (range.to - range.from)*0.03;
                                range.to += margin;
                                range.from -= margin;

                                x.domain([new Date(range.from), new Date(range.to)]);
                                draw(!drawn);
                                drawn = true;
                            }, true);
                        }

                        /*** Metric history spectrogram ***/
                        if ($scope.displayedRange && $scope.displayedData.$displayType == 'histogram') { // metric history
                            var slices;
                            x = d3.time.scale();
                            xAxis.scale(x);

                            updateRanges = updateRangesCommon;

                            draw = function(resized) {
                                drawCommon(resized);
                                actionsG.style("pointer-events", "none");
                                actionsG.selectAll('g.histogram-slice').remove(); // refresh each time since otherwise the positions are not recomputed when the x domain changes
                                slices = actionsG.selectAll('g.histogram-slice').data(values);
                                slices.enter().append('g').attr('class', 'histogram-slice')
                                .attr('transform', function(d) {
                                    var start = new Date(d.time);
                                    return 'translate(' + x(start) + ',0)';
                                })
                                .attr('cx', function(d) {return x(new Date(d.time));}) // to anchor the tooltip
                                .attr('cy', function(d) {return y(d.$histogram.max);})
                                .each(function(d) {
                                    var start = new Date(d.time);
                                    var end = d.$nextTime ? new Date(d.$nextTime) : x.domain()[1];
                                    var width = x(end) - x(start);
                                    if (d.$histogram != null && width > 0) {
                                        var unitCountOpacity = 1.0 / d.$histogram.longestHistogramBar;
                                        d3.select(this).selectAll('histogram-tile').data(d.$histogram.chistogram).enter().append('rect')
                                                       .attr('class', 'histogram-tile')
                                                       .attr('x', 0)
                                                       .attr('width', Math.max(0, width - 1))
                                                       .attr('y', function(d) {return y(d[1]) + 1;})
                                                       .attr('height', function(d) {return Math.max(0, y(d[0]) - y(d[1]));})
                                                       .style('fill', function(d) {return coldWarm(unitCountOpacity * d[2]);});
                                    }
                                });
                                slices.exit().remove();

                                hiddenRectsG.selectAll('rect.hidd').remove();
                                hiddenRects = hiddenRectsG.selectAll('rect.hidd').data(values);
                                hiddenRects.enter().append('rect')
                                    .attr('class', 'hidd')
                                    .attr('x', function(d) {return x(new Date(d.time));})
                                    .attr('width', function(d) {
                                        var start = new Date(d.time);
                                        var end = d.$nextTime ? new Date(d.$nextTime) : x.domain()[1];
                                        var width = x(end) - x(start);
                                        return d.$histogram != null && width > 0 ? width : 0;
                                    })
                                    .attr('y', y.range()[1])
                                    .attr('height', vizHeight)
                                    .on("mousemove", function(d) {
                                        $rootScope.$broadcast('metrics-charts-focus-point', {time: d.time});
                                    })
                                    .on("mouseout", function(d) {
                                        $rootScope.$broadcast('metrics-charts-unfocus-point');
                                    });
                                hiddenRects.exit().remove();

                            };

                            $scope.$watch("displayedRange", function(nv) {
                                if (!nv) return;

                                /* Add a 3% margin on both sides */
                                var range = { from: nv.from, to: nv.to };
                                var margin = (range.to - range.from)*0.03;
                                range.to += margin;
                                range.from -= margin;

                                x.domain([new Date(range.from), new Date(range.to)]);
                                draw(!drawn);
                                drawn = true;
                            }, true);

                            $scope.$on('metrics-charts-focus-point', function(event, data) {
                                slices.filter(function(d) { return d.time === data.time; })
                                    .classed("focus", true)
                                    .each(function(d) {
                                        if (d.$histogram) {
                                            var minLabel = d.$histogram.min, maxLabel = d.$histogram.max;
                                            if (yIsDate) {
                                                minLabel = $filter('date')(minLabel, 'yyyy-MM-dd HH:mm');
                                                maxLabel = $filter('date')(maxLabel, 'yyyy-MM-dd HH:mm');
                                            }
                                            $scope.setTooltipContent(
                                                    '<h4><i class="point"></i>' + sanitize(MetricsUtils.getMetricDisplayName($scope.displayedMetric)) + '</h4>'+
                                                    '<span class="date">' + sanitize($filter('date')(d.time, 'yyyy-MM-dd HH:mm')) + '</span>'+
                                                    '<span class="value">' + sanitize(minLabel) + ' to ' + sanitize(maxLabel) + '</span>'
                                            );
                                        } else {
                                            $scope.setTooltipContent(
                                                    '<h4><i class="point"></i>' + sanitize(MetricsUtils.getMetricDisplayName($scope.displayedMetric)) + '</h4>'+
                                                    '<span class="date">' + sanitize($filter('date')(d.time, 'yyyy-MM-dd HH:mm')) + '</span>'+
                                                    '<span class="value"></span>'
                                            );
                                        }
                                        $scope.showTooltip(parseFloat(this.getAttribute('cx')) + margins.left, parseFloat(this.getAttribute('cy')) + margins.top);
                                    })
                            });

                            $scope.$on('metrics-charts-unfocus-point', function(event, data) {
                                slices.classed("focus", function(d,i) { return i === values.length -1; });
                                $scope.hideTooltip();
                            });

                        }

                        /*** Partitions chart ***/
                        if ($scope.displayedPartitions) {
                            var rects, hiddenRects, barWidth, fullBarWidth, xCoord, fullXCoord, averageLine, timePeriod;
                            actionsG.style("pointer-events", "none");

                            switch ($scope.displayedData.partitionTimePeriod) {
                                case 'YEAR':
                                    timePeriod = 1000 * 60 * 60 * 24 * 365;
                                    break;
                                case 'MONTH':
                                    timePeriod = 1000 * 60 * 60 * 24 * 30;
                                    break;
                                case 'DAY':
                                    timePeriod = 1000 * 60 * 60 * 24;
                                    break;
                                case 'HOUR':
                                    timePeriod = 1000 * 60 * 60;
                                    break;
                            }

                            if ($scope.displayedPartitionsRange) { // time x-axis
                                $scope.pointFilter = function() { return true; };
                                x = d3.time.scale();
                                xCoord = function(d) { return x(d.partitionTime); };
                                fullXCoord = function(d) { return x(d.partitionTime) - (fullBarWidth-barWidth)/2; };
                                $scope.$watch("displayedPartitionsRange", function() {
                                    if (!$scope.displayedPartitionsRange) return;

                                    /* Add a 3% margin on both sides */
                                    var range = { from: $scope.displayedPartitionsRange.from, to: $scope.displayedPartitionsRange.to };
                                    range.to += 0.8*timePeriod;
                                    var margin = (range.to - range.from)*0.1;
                                    range.to += margin;
                                    range.from -= margin;

                                    x.domain([new Date(range.from), new Date(range.to)]);
                                    draw(false);
                                }, true);
                            } else {
                                x = d3.scale.ordinal();
                                xCoord = function(d) { return x(d.partition); };
                                $scope.$watch("displayedPartitions", Debounce().withDelay(0, 200).wrap(function(nv) {
                                    if (!nv) return;
                                    x.domain(nv);
                                }));
                            }

                            xAxis.scale(x);

                            updateRanges = function(resized) {
                                if ($scope.displayedPartitionsRange) {
                                    if (resized) updateRangesCommon();
                                    var scale = (x.range()[1] - x.range()[0]) / (x.domain()[1] - x.domain()[0]);
                                    fullBarWidth = scale * timePeriod;
                                    barWidth = 0.8 * fullBarWidth;
                                }
                            };

                            draw = function(resized) {

                                var drawAxis = function() {
                                    drawCommon(resized);
                                    updateRanges(resized);
                                };

                                drawAxis();

                                if ($scope.displayedData.$displayType == 'histogram') {
                                    actionsG.selectAll('g.histogram-slice').remove(); // refresh each time since otherwise the positions are not recomputed when the x domain changes
                                    var slices = actionsG.selectAll('g.histogram-slice').data(values.filter($scope.pointFilter), Fn.prop('partition'));
                                    slices.enter().append('g').attr('class', 'histogram-slice')
                                    .attr('transform', function(d) {
                                        return 'translate(' + xCoord(d) + ',0)';
                                    })
                                    .each(function(d) {
                                        var start = new Date(d.partitionTime);
                                        if (d.$histogram != null) {
                                            var unitCountOpacity = 1.0 / d.$histogram.longestHistogramBar;
                                            d3.select(this).selectAll('histogram-tile').data(d.$histogram.chistogram).enter().append('rect')
                                                           .attr('class', 'histogram-tile')
                                                           .attr('x', 0)
                                                           .attr('width', barWidth)
                                                           .attr('y', function(d) {return y(d[1]) + 1;})
                                                           .attr('height', function(d) {return Math.max(0, y(d[0]) - y(d[1]));})
                                                           .style('fill', function(d) {return coldWarm(unitCountOpacity * d[2]);});
                                        }
                                    });
                                    slices.exit().remove();
                                } else {
                                    rects = actionsG.selectAll('rect.bar').data(values.filter($scope.pointFilter), Fn.prop('partition'));
                                    rects.enter().append('rect').attr('class', 'bar');
                                    rects.exit().remove();

                                    rects.attr('x', xCoord)
                                         .attr('width', Math.max(barWidth, 1));

                                    if (resized) {
                                        rects.attr('y', function(d) { return y(d.value); })
                                             .attr('height', function(d) { return y(0) - y(d.value); });

                                        xAxisG.attr("transform", "translate(0, " + vizHeight + ")");
                                    }
                                    if ($scope.averageValue != null) {
                                        averageLine = actionsG.selectAll('line.average').data([$scope.averageValue]);
                                        averageLine.enter().append('line').attr('class', 'average');
                                        averageLine.exit().remove();
                                        averageLine.attr('x1', x.range()[0])
                                            .attr('x2', x.range()[1])
                                            .attr('y1', y($scope.averageValue))
                                            .attr('y2', y($scope.averageValue));
                                   }
                                }

                                hiddenRects = hiddenRectsG.selectAll('rect.hidd').data(values.filter($scope.pointFilter), Fn.prop('partition'));
                                hiddenRects.enter().append('rect').attr('class', 'hidd')
                                    .on("mousemove", function(d) {
                                        var offset = $(chartSvg[0][0]).offset();
                                        $rootScope.$broadcast('metrics-charts-focus-partition', {
                                            partition: d.partition,
                                            pageX: d3.event.pageX - offset.left,
                                            pageY: d3.event.pageY - offset.top
                                        });
                                    })
                                    .on("mouseout", function(d) {
                                        $rootScope.$broadcast('metrics-charts-unfocus-partition');
                                    });
                                hiddenRects.exit().remove();
                                hiddenRects
                                    .attr('x', fullXCoord)
                                    .attr('width', fullBarWidth)
                                    .attr('y', y.range()[1])
                                    .attr('height', vizHeight);

                            };

                            $scope.$on('metrics-charts-focus-partition', function(event, data) {
                                hiddenRects.filter(function(d) { return d.partition === data.partition; })
                                    .classed('active', true)
                                    .each(function(d) {
                                        if ($scope.displayedData.$displayType == 'histogram' && d.$histogram) {
                                            var minLabel = d.$histogram.min, maxLabel = d.$histogram.max;
                                            if (yIsDate) {
                                                minLabel = $filter('date')(minLabel, 'yyyy-MM-dd HH:mm');
                                                maxLabel = $filter('date')(maxLabel, 'yyyy-MM-dd HH:mm');
                                            }
                                            $scope.setTooltipContent(
                                                    '<h4><i class="point"></i>' + sanitize(MetricsUtils.getMetricDisplayName($scope.displayedMetric)) + '</h4>'+
                                                    '<span class="date">' + sanitize(d.partition) + '</span>'+
                                                    '<span class="value">' + sanitize(minLabel) + ' to ' + sanitize(maxLabel) + '</span>'+
                                                    '<div class="partition-date">Computed on ' + sanitize($filter('date')(d.time, "yyyy-MM-dd 'at' HH:mm")) + '</div>'
                                            );
                                        } else {
                                            $scope.setTooltipContent(
                                                    '<h4><i class="point"></i>' + sanitize(MetricsUtils.getMetricDisplayName($scope.displayedMetric)) + '</h4>'+
                                                    '<span class="date">' + sanitize(d.partition) + '</span>'+
                                                    '<span class="value">' + sanitize(MetricsUtils.getFormattedValue(d.value, $scope.displayedMetric, $scope.displayedData)) + '</span>'+
                                                    '<div class="partition-date">Computed on ' + sanitize($filter('date')(d.time, "yyyy-MM-dd 'at' HH:mm")) + '</div>'
                                            );
                                        }
                                    });
                                $scope.showTooltip(data.pageX - margins.left, data.pageY - margins.top);
                            });

                            $scope.$on('metrics-charts-unfocus-partition', function(event, partition) {
                                hiddenRects.classed('active', false);
                                $scope.hideTooltip();
                            })
                        }

                        /** Draw chart **/
                        updateRanges(true); //NOSONAR: will always be initialized as a function since there's no situation where we did not enter one of the 3 if blocks above.
                        draw(true); //NOSONAR: same as above.

                        /** Redraw on resize **/
                        d3.select(window).on("resize." + $scope.displayedMetric.metric.id, function() {
                            updateRanges(true);
                            draw(true);
                        });

                        $scope.$on('resize', function() {
                            updateRanges(true);
                            draw(true);
                        });

                        $scope.$on("$destroy", function() {
                            d3.select(window).on("resize." + $scope.displayedMetric.metric.id, null);
                        });
                    }
                } else {
                    if ($scope.displayedData.$isArray) {
                        $scope.maxLength = d3.max($scope.displayedData.values, Fn.prop(['value', 'length']));
                        $scope.maxArray = Array($scope.maxLength);
                    }
                }
            };

            // Reset when data changes
            $scope.$watch('displayedData', function(nv) { if (nv != null) init();});

            init();
        }
    };
});

app.directive("autoResizeText", function($sce) {
    return {
        scope: {
            content: '=',          // the text to display
            minFontSize: '@',      // in px (default: 12)
            tooltip: '=',          // boolean: whether or not to display tooltip when the text gets to small (default: true),
            tooltipPlacement: '@', // (default: bottom)
            tooltipContainer: '@'  // (default: body)
        },

        template: '<div></div> ' +
        '          <div class="mx-textellipsis" ' +
        '               toggle="tooltip" ' +
        '               title="{{content}}" ' +
        '               placement="{{tooltipPlacement || \'bottom\'}}" ' +
        '               container="{{tooltipContainer || \' body\' }}"></div>',

        link: function($scope, element, attrs) {
            var $el = $(element);
            var tooltip = $scope.tooltip != false;
            var minFontSize = $scope.minFontSize || 12;

            var showToolTip = function () {
                $el.find('div').first().hide();
                $el.find('div').last().show();
            };

            var hideToolTip = function () {
                $el.find('div').first().show();
                $el.find('div').last().hide();
            };

            var originalFontSize = parseInt($el.css('font-size'));
            $scope.$watch("content", function (nv) {
                var c = $scope.content == undefined ? '' : $scope.content.toString();
                // for hackers like clement: use text, not html
                $el.find('div').text(c);
                if (nv == undefined) return;

                // reset original settings
                $el.css('font-size', originalFontSize + 'px');
                hideToolTip();

                var fontSize = originalFontSize;
                while (element[0].scrollWidth > $(element).parent().width() || element[0].scrollHeight > $(element).parent().height()) {
                    if (fontSize - 1 < minFontSize) {
                        if (tooltip) showToolTip();
                        break;
                    }
                    $el.css('font-size', --fontSize + 'px');
                }
            });
        }
    }
});

})();

(function() {
'use strict';

var app = angular.module('dataiku.metrics.savedmodels.views', ['dataiku.metrics.views']);


app.controller("SavedModelStatusPageController", function($scope, DataikuAPI, $stateParams, TopNav, $filter){
    TopNav.setLocation(TopNav.TOP_FLOW, TopNav.ITEM_SAVED_MODEL, TopNav.TABS_SAVED_MODEL, "status");
    DataikuAPI.savedmodels.get($stateParams.projectKey, $stateParams.smId).success(function(data) {
        $scope.savedModel = data;
        TopNav.setItem(TopNav.ITEM_SAVED_MODEL, $stateParams.smId, {name: data.name, taskType: (data.miniTask || {}).taskType});

        if ($scope.savedModel.miniTask.taskType == "PREDICTION") {
            DataikuAPI.savedmodels.prediction.getStatus($stateParams.projectKey, $stateParams.smId).success(function(data){
                $scope.smStatus = data;
            }).error(setErrorInScope.bind($scope));
        } else if ($scope.savedModel.miniTask.taskType == "CLUSTERING"){
            DataikuAPI.savedmodels.clustering.getStatus($stateParams.projectKey, $stateParams.smId).success(function(data){
                $scope.smStatus = data;
            }).error(setErrorInScope.bind($scope));
        } else {
            throw new Exception("Not implemented");
        }

    }).error(setErrorInScope.bind($scope));

    $scope.getDisplayNameForVersion = function(versionId) {
        if ( !versionId || !$scope.smStatus ) return versionId;
        var version = null;
        $scope.smStatus.versions.forEach(function(v) {
            if ( v.versionId == versionId ) {
                version = v;
            }
        });
        if ( version == null || version.snippet == null || version.snippet.trainInfo == null ) {
            return versionId;
        }
        return $filter('date')(version.snippet.trainInfo.startTime, 'yyyy-MM-dd – HH:mm:ss');
    };
});

app.controller("SaveModelMetricsViewController", function($scope, Debounce, FutureProgressModal, MetricsUtils, $filter, Fn, DataikuAPI, $stateParams) {
    $scope.views = {
        selected : 'versionsTable'
    };

    var savedSettings;

    $scope.displayedMetrics = {metrics : [], $loaded : false};
    // function is not there when the page is loaded the first time, but is there when tabs change
    if ( $scope.refreshAllComputedMetrics ) $scope.refreshAllComputedMetrics();

    $scope.$watch("allComputedMetrics", function(nv, ov){
        $scope.allPartitions = [];

        var set = {}
        if (nv) {

            nv.metrics.forEach(function(metric) {
                metric.partitionsWithValue.forEach(function(p) {
                    set[p] = 1
                })
            });
        }
        $scope.allPartitions = Object.keys(set);

        filterMetricsPartitions();
        $scope.refreshDisplayedMetrics();
    }, true);

    $scope.uiState = {listMode : 'banner', partitionQuery : ''};
    $scope.displayedMetricByPartitionData = [];

    $scope.orderByFunc = function(metricIdx) {
        if (metricIdx === '__partition__') return Fn.SELF;

        return function(partitionId) {
            return MetricsUtils.getFormattedValueForPartition($scope.displayedMetrics.metrics[metricIdx], partitionId, $scope.displayedMetricByPartitionData);
        }
    };

    $scope.getDisplayedPartitionsData = function(displayedMetric) {
        var metricId = displayedMetric.metric.id;
        var found = null;
        $scope.displayedMetricByPartitionData.forEach(function(displayedMetricPartition) {
            if ( displayedMetricPartition.metricId == metricId ) {
                found = displayedMetricPartition;
            }
        });
        return found;
    };

    // TODO code duplication
    $scope.refreshDisplayedMetrics = function() {
        if ( $scope.metrics == null || $scope.allComputedMetrics == null || $scope.metrics.displayedState == null) return;

        // get the ones for the selected element, either partition or full dataset
        var partitionId = $scope.metricsCallbacks.getSelectedMetricsPartitionId();
        if ( !$scope.displayedMetrics.$loaded && $scope.allComputedMetrics.metrics.length > 0 ) {
            // select back the metrics as the persisted state says
            $scope.displayedMetrics.metrics = $scope.allComputedMetrics.metrics.filter(function(metric) {return metric.displayedAsMetric;});
            // re-order according to $scope.metrics.displayedState.metrics
            $scope.displayedMetrics.metrics.forEach(function(displayedMetric) {
                var i = $scope.metrics.displayedState.metrics.indexOf(displayedMetric.metric.id);
                if ( i < 0 ) {
                    i = $scope.metrics.displayedState.metrics.length;
                }
                displayedMetric.$indexInDisplayedState = i;
            });
            $scope.displayedMetrics.metrics.sort(function(a, b) {return a.$indexInDisplayedState - b.$indexInDisplayedState;});
            $scope.displayedMetrics.$loaded = true;
            refreshDisplayedPartitionData();
        }
    };

    var refreshDisplayedList = function() {
        if ( $scope.displayedMetrics == null || $scope.metrics.displayedState == null) return;
        $scope.metrics.displayedState.metrics = $scope.displayedMetrics.metrics.map(function(metric) {return metric.metric.id;});
        // don't forget to tweak the allComputedMetrics for when we switch tabs and reload the displayedMetrics list
        $scope.allComputedMetrics.metrics.forEach(function(metric) {metric.displayedAsMetric = $scope.displayedMetrics.metrics.indexOf(metric) >= 0;});
    };

       $scope.$watch('displayedMetrics', function(nv, ov) {
                if ( nv == ov ) return;
                refreshDisplayedList();
                refreshDisplayedPartitionData();
            }, true);

    var refreshDisplayedPartitionData = function() {
        if ( $scope.displayedMetrics == null || !$scope.displayedMetrics.$loaded || $scope.metrics == null || $scope.metrics.displayedState == null ) {
            return;
        }
        // fetch the data
        $scope.metricsCallbacks.getPreparedMetricPartitions($scope.metrics.displayedState).success(function(data) {
            $scope.displayedMetricByPartitionData = data.metrics;
            //refreshPartitionsRange();
        }).error(setErrorInScope.bind($scope));
    };
    refreshDisplayedPartitionData();

    var refreshPartitionsRange = function() {
        if ($scope.metricsPartitions && $scope.metricsPartitions.isTimePartition) {
            var extents = $scope.displayedMetricByPartitionData.map(function(d) {
                return d3.extent(d.values, Fn.prop('partitionTime'));
            });
            $scope.displayedPartitionsRange = {from: d3.min(extents, Fn.prop(0)), to: d3.max(extents, Fn.prop(1))};
            $scope.selectedRange = {from: $scope.displayedPartitionsRange.from, to: $scope.displayedPartitionsRange.to};
            filterMetricsPartitions();
        }
    };

    var filterMetricsPartitions = function() {
        if (!$scope.allPartitions) $scope.filteredPartitions = [];
        $scope.filteredPartitions = $filter('filter')($scope.allPartitions, $scope.uiState.partitionQuery);
    };

});

})();
(function() {
'use strict';

var app = angular.module('dataiku.metrics.edit', ['dataiku.metrics.core']);

app.directive('editChecksSettings', function(DataikuAPI, $stateParams, CreateModalFromTemplate, $timeout, WT1, CodeMirrorSettingService) {
    return {
        scope : true,
        restrict : 'A',
        templateUrl : "/templates/metrics/edit-checks-settings.html",
        link : function($scope, $element, attrs) {
            // python checks
            $scope.pythonEditorOptions = CodeMirrorSettingService.get("text/x-python");

            $scope.lastCheckResult = null;
            var setLastCheckResult = function(result) {
                $scope.lastCheckResult = result;
            };

            var pythonCheckStartCode = "# Define here a function that returns the outcome of the check.\n"
                                     + "def process(last_values, dataset, partition_id):\n"
                                     + "    # last_values is a dict of the last values of the metrics,\n"
                                     + "    # with the values as a dataiku.metrics.MetricDataPoint.\n"
                                     + "    # dataset is a dataiku.Dataset object\n"
                                     + "    return 'OK', 'optional message' # or 'WARNING' or 'ERROR'\n";
            $scope.addCheck = function(checkType) {
                WT1.event("checks-add-check", {checkType:checkType});
                var check = {type:checkType, meta:{}, fullDatasetMode:'PARTITION'};
                if ( checkType == 'numericRange' ) {
                    check.meta.name = 'Value in range';
                    check.metricId = null;
                    check.minimum = 0;
                    check.maximum = 0;
                    check.minimumEnabled = false;
                    check.maximumEnabled = false;
                } else if ( checkType == 'valueSet' ) {
                    check.meta.name = 'Value in set';
                    check.metricId = null;
                    check.values = [];
                } else if ( checkType == 'python' ) {
                    check.meta.name = 'Custom check';
                    check.code = pythonCheckStartCode;
                    check.envSelection = {envMode: "INHERIT"};
                }
                $scope.metricsChecks.checks.push(check);
            };

            $scope.addCustomCheck = function(loadedDesc) {
                WT1.event("metrics-add-plugin-check", {checkType:loadedDesc.checkType});
                var name = loadedDesc.desc.meta.label || loadedDesc.desc.id;
                var check = {type:loadedDesc.checkType, fullDatasetMode:'PARTITION', meta:{name:name}, config: {}};
                $scope.metricsChecks.checks.push(check);
            };

            $scope.removeCheck = function(check) {
                var i = $scope.metricsChecks.checks.indexOf(check);
                if ( i >= 0 ) {
                    $scope.metricsChecks.checks.splice(i,1);
                }
            };

            var refreshAllMetrics = function() {
                $scope.allMetrics = [];
                if ( $scope.allComputedMetrics ) {
                    // stuff with values already existing in the db
                    $scope.allComputedMetrics.metrics.forEach(function(computedMetric) {
                        $scope.allMetrics.push(computedMetric);
                    });
                }
            };
            refreshAllMetrics();
            $scope.$watch('metrics', function() {refreshAllMetrics();}, true);
            $scope.$watch('allComputedMetrics', function() {refreshAllMetrics();}, true);

            var checksRunSettings = {};
            $scope.getCheckRunSettings = function(metricsCheck) {
                var checkRunSettings = checksRunSettings[metricsCheck.name];
                if ( checkRunSettings == null ) {
                    checkRunSettings = {fullDataset : false, partition : null};
                    checksRunSettings[metricsCheck.name] = checkRunSettings;
                }
                return checkRunSettings;
            };
        }
    };
});

app.directive('editProbesSettings', function($stateParams, CreateModalFromTemplate, WT1, CodeMirrorSettingService) {
    return {
        scope : true,
        restrict : 'A',
        templateUrl : "/templates/metrics/edit-probes-settings.html",
        link : function($scope, $element, attrs) {
            // python metrics
            $scope.pythonEditorOptions = CodeMirrorSettingService.get("text/x-python");
            // sql metrics
            $scope.sqlEditorOptions = CodeMirrorSettingService.get("text/x-sql");

            $scope.dataTypes = ['STRING', 'BIGINT', 'DOUBLE', 'BOOLEAN', 'DATE'];

            var pythonProbeStartCode = $scope.metricsCallbacks.getPythonProbeStartCode();
            var sqlProbeStartCode = "-- the metrics values and names are taken from the columns of the select statement\n"
                                  + "SELECT 42 AS metric_1, 'xxx' AS metric_2 FROM ${DKU_DATASET_TABLE_NAME}\n"
                                  + "-- when partitioned, a filter for the WHERE clause can be added like:\n"
                                  + "-- WHERE ${DKU_PARTITION_FILTER} \n"
                                  + "-- when the dataset is a sql query, the select query is available as\n"
                                  + "-- ${DKU_DATASET_QUERY} and, if any, statements before and after the\n"
                                  + "-- select as ${DKU_DATASET_PRE_QUERIES} and  ${DKU_DATASET_POST_QUERIES}\n";

            $scope.cellProbeRowSelectionModes = [
                ["SINGLE_CELL_STRICT", "Single row matching the filter"],
                ["SINGLE_CELL_OR_NONE", "Single row matching the filter, or none"],
                ["FIRST_CELL_OR_NONE", "First row matching the filter"],
                ["MULTI_CELL", "All rows matching the filter"]
            ]
            $scope.cellProbeRowSelectionModesDesc = [
                "Fails if the filter returns 0 or more than 1 rows",
                "Fails if the filter returns more than 1 rows. If the filter returns 0 rows, metric has no value",
                "Takes the first row matching the filter. If the filter returns 0 rows, metric has no value",
                "All rows (creates a array-typed metric) - advanced use"
            ]


            $scope.addProbe = function(probeType) {
                WT1.event("metrics-add-probe", {probeType:probeType});
                var level = probeType == 'python' ? 8 : 9;
                var name = probeType == 'python' ? 'Python probe' : (probeType == 'cell' ? 'Cell value' : 'SQL probe');
                var probe = {type:probeType,meta:{level:level, name:name}, computeOnBuildMode:'NO', configuration:{code:''}};
                if ( probeType == 'python') {
                    probe.configuration.code = pythonProbeStartCode;
                    probe.configuration.envSelection = {envMode: "INHERIT"};
                }
                if ( probeType == 'sql_query') {
                    probe.configuration.code = sqlProbeStartCode;
                    probe.configuration.canRunOnImpala = true;
                }
                if ( probeType == 'cell') {
                    probe.configuration.filter = {enabled:true, uiData:{mode:'&&'}};
                    probe.configuration.mode = 'SINGLE_CELL_STRICT';
                    probe.enabled = true;
                }
                $scope.metricsCallbacks.getHint(probe).success(function(hint) {
                    $scope.availableProbes.probes.push({probe:probe, metrics:[], hint:hint});
                    $scope.regenMetricsSet();
                }).error(setErrorInScope.bind($scope));
            };
            $scope.addCustomProbe = function(loadedDesc) {
                WT1.event("metrics-add-plugin-probe", {probeType:loadedDesc.probeType});
                var level = 10;
                var name = loadedDesc.desc.meta.label || loadedDesc.desc.id;
                var probe = {type:loadedDesc.probeType, meta:{level:level, name:name}, computeOnBuildMode:'NO', configuration:{config:{}}};
                $scope.metricsCallbacks.getHint(probe).success(function(hint) {
                    $scope.availableProbes.probes.push({probe:probe, metrics:[], hint:hint});
                    $scope.regenMetricsSet();
                }).error(setErrorInScope.bind($scope));
            };

            $scope.removeProbe = function(probe) {
                var i = $scope.availableProbes.probes.indexOf(probe);
                if ( i >= 0 ) {
                    $scope.availableProbes.probes.splice(i,1);
                }
                $scope.regenMetricsSet();
            };

            $scope.columnQuery = null;
            $scope.columnSearch = function(metric) {
                if ( !$scope.columnQuery ) return true;
                if ( metric == null || !metric.column ) return false;
                return metric.column.toLowerCase().indexOf($scope.columnQuery.toLowerCase()) >= 0;
            };
            $scope.metricQuery = null;
            $scope.metricSearch = function(metric) {
                if ( !$scope.metricQuery ) return true;
                if ( metric == null) return false;
                var lowerCasedSearch = $scope.metricQuery.toLowerCase();
                if ( metric.name && metric.name.toLowerCase().indexOf(lowerCasedSearch) >= 0 ) {
                    return true;
                }
                if ( metric.aggregated && metric.aggregated.toLowerCase().indexOf(lowerCasedSearch) >= 0 ) {
                    return true;
                }
                return false;
            };

            var getFilteredMetrics = function() {
                var selectedMetrics = [];
                if ( !$scope.metricQuery && !$scope.columnQuery ) return selectedMetrics;
                $scope.availableProbes.probes.forEach(function(availableProbe){
                    var probe = availableProbe.probe;
                    if ( probe.type == 'verify_col' || probe.type == 'col_stats' || probe.type == 'adv_col_stats' || probe.type == 'percentile_stats') {
                        availableProbe.hint.metrics.forEach(function(metric) {
                            if ( $scope.metricSearch(metric) ) {
                                metric.columns.forEach(function(column) {
                                    if ( $scope.columnSearch(column) ) {
                                        selectedMetrics.push(column);
                                    }
                                });
                            }
                        });
                    }
                });
                return selectedMetrics;
            };

            $scope.activateFilteredMetrics = function() {
                getFilteredMetrics().forEach(function(metric) {if (!metric.disabled) metric.active=true;});
                $scope.regenMetricsSet();
            };
            $scope.deactivateFilteredMetrics = function() {
                getFilteredMetrics().forEach(function(metric) {metric.active=false;});
                $scope.regenMetricsSet();
            };

            $scope.editRunSettings = function() {
                WT1.event("metrics-edit-run-settings");
                CreateModalFromTemplate("/templates/metrics/edit-metrics-settings-modal.html", $scope, "EditMetricsSettingsController", undefined, true);
            };


            // display computation plan
            var timeout;
            var lastPlanUpdate = { metrics : null, plan : null};
            $scope.computationPlan = null;
            var doUpdatePlan = function() {
                $scope.metricsCallbacks.computePlan(lastPlanUpdate.metrics).success(function(data) {
                    lastPlanUpdate.plan = data;
                    $scope.computationPlan = data;
                    $scope.totalCost = 0;
                    $scope.totalCount = 0;
                    data.forEach(function(run) {$scope.totalCost += run.cost; $scope.totalCount += run.computations.length;})
                }).error(setErrorInScope.bind($scope));
            };
            var updatePlan = function() {
                if ( $scope.metrics == null ) return;
                var dirty = lastPlanUpdate.metrics == null;
                if ( !dirty ) {
                    // do not compare the selection of metrics to display
                    dirty = !angular.equals($scope.metrics.probes, lastPlanUpdate.metrics.probes) || !angular.equals($scope.metrics.engineConfig, lastPlanUpdate.metrics.engineConfig);
                }
                if ( !dirty ) return;

                lastPlanUpdate.metrics = angular.copy($scope.metrics);
                clearTimeout(timeout);
                timeout = setTimeout(function() {doUpdatePlan();}, 2000);
            };
            $scope.$watch('metrics', function() {
                updatePlan();
            }, true);

            $scope.getAvailableProbeName = function(availableProbe) {
                if (availableProbe.probe.type == 'partitioning') return 'Partitions list & count';
                if (availableProbe.probe.type == 'records') return 'Records count';
                if (availableProbe.probe.type  == 'basic') {
                    if ( availableProbe.hint.hasSize && availableProbe.hint.hasCountFiles && availableProbe.hint.hasCountColumns ) return 'Size, files count & columns count';
                    if ( availableProbe.hint.hasSize && availableProbe.hint.hasCountFiles && !availableProbe.hint.hasCountColumns ) return 'Size & files count';
                    if ( availableProbe.hint.hasSize && !availableProbe.hint.hasCountFiles && availableProbe.hint.hasCountColumns ) return 'Size & columns count';
                    if ( availableProbe.hint.hasSize && !availableProbe.hint.hasCountFiles && !availableProbe.hint.hasCountColumns ) return 'Size';
                    if ( !availableProbe.hint.hasSize && availableProbe.hint.hasCountFiles && availableProbe.hint.hasCountColumns ) return 'Files count & columns count';
                    if ( !availableProbe.hint.hasSize && availableProbe.hint.hasCountFiles && !availableProbe.hint.hasCountColumns ) return 'Files count';
                    if ( !availableProbe.hint.hasSize && !availableProbe.hint.hasCountFiles && availableProbe.hint.hasCountColumns ) return 'Columns count';
                }
                return availableProbe.probe.meta.name || availableProbe.probe.type;
            };
        }
    };
});

app.directive("newCustomProbeMenu", function(GlobalProjectActions, $filter){
    return {
        templateUrl : '/templates/datasets/fragments/new-custom-probe-menu.html',
        scope : true,
        link : function($scope, element, attrs) {
            $scope.title = attrs.title;

            var ret = [];

            var pluginSections = {}

            if ( $scope.appConfig.customPythonProbes ) {
                $scope.appConfig.customPythonProbes.forEach(function(x){
                    if (!$scope.metricsCallbacks.canAddPluginProbe(x.desc, "python")) {
                        return;
                    }
                    var pluginSection = pluginSections[x.ownerPluginId];
                    if (pluginSection == null) {
                        pluginSection = {
                                pluginId : x.ownerPluginId,
                                items : []
                        };
                        pluginSections[x.ownerPluginId] = pluginSection;
                    }

                    pluginSection.items.push({
                        type : x.probeType,
                        label : x.desc.meta != null && x.desc.meta.label != null ? x.desc.meta.label : x.ownerPluginId,
                                icon : x.desc.meta != null ? x.desc.meta.icon : null,
                                        desc : x
                    })
                });
            }
            if ( $scope.appConfig.customSQLProbes ) {
                $scope.appConfig.customSQLProbes.forEach(function(x){
                    if (!$scope.metricsCallbacks.canAddPluginProbe(x.desc, "sql")) {
                        return;
                    }
                    var pluginSection = pluginSections[x.ownerPluginId];
                    if (pluginSection == null) {
                        pluginSection = {
                                pluginId : x.ownerPluginId,
                                items : []
                        };
                        pluginSections[x.ownerPluginId] = pluginSection;
                    }

                    pluginSection.items.push({
                        type : x.probeType,
                        label : x.desc.meta != null && x.desc.meta.label != null ? x.desc.meta.label : x.ownerPluginId,
                                icon : x.desc.meta != null ? x.desc.meta.icon : null,
                                        desc : x
                    })
                });
            }

            $.each(pluginSections, function(pluginId, pluginData){
                var plugin = Array.dkuFindFn($scope.appConfig.loadedPlugins, function(n){
                    return n.id == pluginData.pluginId
                });
                if ( plugin == null ) return;
                pluginData.items.forEach(function(dtype){
                    if (!dtype.icon) dtype.icon = plugin.icon;
                });
                var section = {
                        isSection : true,
                        id : "plugin_" + plugin.id,
                        icon : plugin.icon,
                        label : plugin.label || plugin.id,
                        items : pluginData.items
                    };
                // add an item to point to the doc
                section.items.splice(0, 0, {isInfo : true, pluginId : plugin.id});
                ret.push(section);
            });

            $scope.create = function(item) {
                $scope.addCustomProbe(item.desc);
            };

            $scope.displayedItems = ret;
        }
    }
});

app.directive("newCustomCheckMenu", function(GlobalProjectActions, $filter){
    return {
        templateUrl : '/templates/datasets/fragments/new-custom-check-menu.html',
        scope : true,
        link : function($scope, element, attrs) {
            $scope.title = attrs.title;

            var ret = [];

            var pluginSections = {}

            if ( $scope.appConfig.customPythonChecks ) {
                $scope.appConfig.customPythonChecks.forEach(function(x){
                    var pluginSection = pluginSections[x.ownerPluginId];
                    if (pluginSection == null) {
                        pluginSection = {
                                pluginId : x.ownerPluginId,
                                items : []
                        };
                        pluginSections[x.ownerPluginId] = pluginSection;
                    }

                    pluginSection.items.push({
                        type : x.checkType,
                        label : x.desc.meta != null && x.desc.meta.label != null ? x.desc.meta.label : x.ownerPluginId,
                                icon : x.desc.meta != null ? x.desc.meta.icon : null,
                                        desc : x
                    })
                });
            }

            $.each(pluginSections, function(pluginId, pluginData){
                var plugin = Array.dkuFindFn($scope.appConfig.loadedPlugins, function(n){
                    return n.id == pluginData.pluginId
                });
                if ( plugin == null ) return;
                pluginData.items.forEach(function(dtype){
                    if (!dtype.icon) dtype.icon = plugin.icon;
                });
                var section = {
                        isSection : true,
                        id : "plugin_" + plugin.id,
                        icon : plugin.icon,
                        label : plugin.label || plugin.id,
                        items : pluginData.items
                    };
                // add an item to point to the doc
                section.items.splice(0, 0, {isInfo : true, pluginId : plugin.id});
                ret.push(section);
            });

            $scope.create = function(item) {
                $scope.addCustomCheck(item.desc);
            };

            $scope.displayedItems = ret;
        }
    }
});

app.directive('pluginProbeConfig', function($filter, PluginConfigUtils) {
    return {
        scope : false,
        restrict : 'A',
        link : function($scope, element, attrs) {
            $scope.probeType = $scope.$eval(attrs.probeType);
            $scope.probeConfig = $scope.$eval(attrs.probeConfig);

            var pythonProbe = $scope.appConfig.customPythonProbes.filter(function(x){
                return x.probeType == $scope.probeType;
            });
            var sqlProbe = $scope.appConfig.customSQLProbes.filter(function(x){
                return x.probeType == $scope.probeType;
            });
            if ( pythonProbe.length > 0 ) {
                $scope.loadedDesc = pythonProbe[0];
            } else if ( sqlProbe.length > 0 ) {
                $scope.loadedDesc = sqlProbe[0];
            }

            $scope.pluginDesc = $scope.appConfig.loadedPlugins.filter(function(x){
                return x.id == $scope.loadedDesc.ownerPluginId;
            })[0];

            if (!$scope.probeConfig.config) {
                $scope.probeConfig.config = {}
            }
            PluginConfigUtils.setDefaultValues($scope.loadedDesc.desc.params, $scope.probeConfig.config);
        }
    };
});

app.directive('pluginCheckConfig', function($filter, PluginConfigUtils) {
    return {
        scope : false,
        restrict : 'A',
        link : function($scope, element, attrs) {
            $scope.checkType = $scope.$eval(attrs.checkType);
            $scope.checkConfig = $scope.$eval(attrs.checkConfig);

            var pythonCheck = $scope.appConfig.customPythonChecks.filter(function(x){
                return x.checkType == $scope.checkType;
            });
            if ( pythonCheck.length > 0 ) {
                $scope.loadedDesc = pythonCheck[0];
            }

            $scope.pluginDesc = $scope.appConfig.loadedPlugins.filter(function(x){
                return x.id == $scope.loadedDesc.ownerPluginId;
            })[0];

            if (!$scope.checkConfig.config) {
                $scope.checkConfig.config = {}
            }
            PluginConfigUtils.setDefaultValues($scope.loadedDesc.desc.params, $scope.checkConfig.config);
        }
    };
});

app.directive('probePreview', function(FutureProgressModal, Logger, WT1) {
    return {
        scope : true,
        restrict : 'A',
        link : function($scope, element) {
            $scope.canPreview = $scope.metricsCallbacks.computeProbe != null;
            $scope.previewSettings = { mode: 'PARTITION' };

            var computeProbeForPartition = function (probe, partition) {
                if (!$scope.canPreview) {
                    Logger.error("Computation of individual probes on this object is not possible");
                } else {
                    var allPartitions = $scope.metricsCallbacks.isPartitioned() && partition == null;
                    var partitionId = partition || $scope.metricsCallbacks.getSelectedMetricsPartitionId();
                    var metrics = angular.copy($scope.metrics);
                    metrics.probes = [probe];
                    $scope.computing = true;
                    $scope.computingModalHandle = true;
                    $scope.runResult = null;
                    $scope.runPartitions = null;

                    WT1.event("metrics-preview-probe", {probeType: probe.type});
                    $scope.metricsCallbacks.computeProbe(partitionId, allPartitions, metrics).success(function (data) {
                        $scope.computing = data.jobId;

                        $scope.computingModalHandle = FutureProgressModal.reopenableModal($scope, data, "Computing probe…");
                        $scope.computingModalHandle.promise.then(function (result) {
                                $scope.computing = false;
                                $scope.computingModalHandle = null;
                                var allReports = [];
                                $scope.resultingPartitions = null;
                                $scope.resultingMetrics = null;
                                if (result) {
                                    if (allPartitions) {
                                        $scope.setPartitionListRefreshing({hasResult: true, result: result});
                                        allReports = result.reports;
                                        $scope.resultingPartitions = result.partitionsList;
                                    } else {
                                        allReports = [result];
                                        $scope.resultingMetrics = result.computed;
                                    }
                                    $scope.allRuns = [];
                                    allReports.forEach(function(report) {
                                        $scope.allRuns = $scope.allRuns.concat(report.runs);
                                    });
                                    var errorRuns = $scope.allRuns.filter(_ => !!_.error);
                                    $scope.errorRunsCount = errorRuns.length;
                                    $scope.previewErrorRun = $scope.errorRunsCount > 0 ? errorRuns[0] : null;
                                    $scope.runResult = {startTime: null, endTime: null};
                                    allReports.forEach(function(report) {
                                        $scope.runResult.startTime = $scope.runResult.startTime == null ? report.startTime : Math.min($scope.runResult.startTime, report.startTime);
                                        $scope.runResult.endTime = $scope.runResult.endTime == null ? report.endTime : Math.max($scope.runResult.endTime, report.endTime);
                                    });
                                } else {
                                    // future failed (ex: aborted)
                                    $scope.runResult = false;
                                }
                            }, function(err) {
                                setErrorInScope.bind($scope)(err.data, err.status, err.headers);
                                $scope.computing = false;
                                $scope.runResult = false;
                                $scope.computingModalHandle = null;
                            });
                        $scope.showProgressModal();
                    }).error(function(data, status, headers) {
                        setErrorInScope.bind($scope)(data, status, headers)
                        $scope.computing = false;
                        $scope.runResult = false;
                        $scope.computingModalHandle = null;
                    });
                }
            };

            $scope.computeProbe = function(probe) {
                switch($scope.previewSettings.mode) {
                    case 'ALL':
                        computeProbeForPartition(probe, 'ALL');
                        break;
                    case 'PARTITION':
                        computeProbeForPartition(probe, $scope.previewSettings.partition);
                        break;
                    case 'PARTITIONS':
                        computeProbeForPartition(probe, null);
                        break;
                }
            };

            $scope.showProgressModal = function (jobId) {
                if ($scope.computingModalHandle && $scope.computingModalHandle.open) {
                    $scope.computingModalHandle.open();
                }
            }
        }
    };
});

app.directive('checkPreview', function($filter, WT1, Logger, FutureProgressModal) {
    return {
        scope: true,
        restrict: 'A',
        link: function($scope, element) {
            $scope.canPreview = $scope.metricsCallbacks.runCheck != null;
            $scope.previewSettings = { mode: 'PARTITION' };
            $scope.checking = false;
            var checkCheckForPartition = function(check, partition) {
                if ( !$scope.canPreview ) {
                    Logger.error("Running individual checks on this object is not possible");
                } else {
                    var allPartitions = $scope.metricsCallbacks.isPartitioned() && partition == null;
                    var partitionId = partition || $scope.metricsCallbacks.getSelectedMetricsPartitionId();
                    var metricsChecks = angular.copy($scope.metricsChecks);
                    metricsChecks.checks = [check];
                    $scope.runResult = null;
                    $scope.runPartitions = null;
                    $scope.checking = true;
                    $scope.previewRun = null;
                    $scope.previewRuns = null;
                    WT1.event("checks-preview-check", {checkType: check.type});
                    $scope.metricsCallbacks.runCheck(partitionId, allPartitions, metricsChecks).success(function(data) {
                        $scope.computingModalHandle = FutureProgressModal.reopenableModal($scope, data, "Running check…");
                        $scope.computingModalHandle.promise.then(function(result) {
                                $scope.checking = false;
                                if (result) {
                                    if (allPartitions) {
                                        if (result.reports.length == 0) {
                                            $scope.previewRuns = {notRun: true};
                                        } else {
                                            $scope.previewRuns = {
                                                partitionIds: result.partitionIds,
                                                errors: result.reports.map(r => r.runs).reduce((list, results) => list.concat(results.map(_=> _.error)), [])
                                            };
                                            $scope.previewRuns.errors = $scope.previewRuns.errors.filter(e => e != null)
                                            $scope.previewResults = result.reports.map(r => r.results).reduce((list, results) => list.concat(results), []);
                                        }
                                    } else {
                                        if (!result.runs || !result.runs.length) {
                                            $scope.previewRun = {notRun: true};
                                        } else {
                                            $scope.previewRun = result.runs[0];
                                            $scope.previewResult = result.results.length > 0 ? result.results[0] : null;
                                            $scope.previewResults = result.results;
                                        }
                                    }
                                    $scope.hasCheckErrors = $scope.previewRuns && $scope.previewRuns.errors && $scope.previewRuns.errors.length > 0;
                                    $scope.hasCheckError = $scope.previewRun && $scope.previewRun.error;
                                    $scope.hasCheckErrorOrErrors = $scope.hasCheckError || $scope.hasCheckErrors;
                                    $scope.countError = 0;
                                    $scope.countWarning = 0;
                                    $scope.countOk = 0;
                                    $scope.countEmpty = 0;
                                    if ( $scope.previewResults ) {
                                        $scope.previewResults.forEach(function(result) {
                                            if (result.value.outcome == 'OK') $scope.countOk++;
                                            if (result.value.outcome == 'WARNING') $scope.countWarning++;
                                            if (result.value.outcome == 'ERROR') $scope.countError++;
                                            if (result.value.outcome == 'EMPTY') $scope.countEmpty++;
                                        });
                                    }

                                    $scope.isError = $scope.hasCheckErrorOrErrors || $scope.countError > 0;
                                    $scope.isWarning = !$scope.isError && $scope.countWarning > 0;
                                    $scope.isOk = !$scope.isError && !$scope.isWarning && $scope.countOk > 0;
                                    $scope.isEmpty = !$scope.isError && !$scope.isWarning && !$scope.isOk && $scope.countEmpty > 0;
                                    $scope.isUnknown = !$scope.isError && !$scope.isWarning && !$scope.isOk && !$scope.isEmpty;
                                } else {
                                    // future failed, probably aborted
                                }
                            });
                        $scope.showProgressModal();
                    }).error(function (a,b,c) {
                        $scope.checking = false;
                        $scope.isOk = false;
                        $scope.isError = true;
                        $scope.isWarning = false;
                        setErrorInScope.bind($scope)(a,b,c);
                    });
                }
            };

            $scope.showProgressModal = function (jobId) {
                if ($scope.computingModalHandle && $scope.computingModalHandle.open) {
                    $scope.computingModalHandle.open();
                }
            };

            $scope.checkCheck = function(check) {
                switch($scope.previewSettings.mode) {
                    case 'ALL':
                        checkCheckForPartition(check, 'ALL');
                        break;
                    case 'PARTITION':
                        checkCheckForPartition(check, $scope.previewSettings.partition);
                        break;
                    case 'PARTITIONS':
                        checkCheckForPartition(check, null);
                        break;
                }
            };

            $scope.getResultOutcome = function() {
                return $scope.countError > 0 ? 'ERROR' : ($scope.countWarning > 0 ? 'WARNING' : ($scope.countOk > 0 ? 'OK' : ($scope.countEmpty > 0 ? 'EMPTY' : null)));
            };
        }
    };
});

app.controller("MassMetricSelectionController", function($scope, $timeout) {

    $scope.aggregation = {'all':{},'some':{},'none':{},'disabled':{}};

    $scope.recomputeAggregationStates = function() {
        var cols = $scope.selection.selectedObjects;
        $scope.aggregation = {'all':{},'some':{},'none':{},'disabled':{}};

        angular.forEach(cols, function(column){
            angular.forEach(column.metrics, function(metric) {
                $scope.aggregation.all[metric.aggregated] =
                    ($scope.aggregation.all[metric.aggregated] == undefined ? true : $scope.aggregation.all[metric.aggregated])
                    && (metric.disabled ? false : metric.active);
                $scope.aggregation.some[metric.aggregated] =
                    ($scope.aggregation.some[metric.aggregated] || false)
                    || (metric.disabled ? false : metric.active);
                $scope.aggregation.disabled[metric.aggregated] =
                    ($scope.aggregation.disabled[metric.aggregated] || false)
                    || !metric.disabled;
            });
        });
        for (var agg in $scope.aggregation.all) {
            $scope.aggregation.disabled[agg] = !$scope.aggregation.disabled[agg];
            $scope.aggregation.some[agg] = $scope.aggregation.some[agg] && !$scope.aggregation.all[agg];
            $scope.aggregation.none[agg] = !$scope.aggregation.some[agg] && !$scope.aggregation.all[agg];
        };
    }

    $scope.massAction = function(metricName){
        angular.forEach($scope.selection.selectedObjects, function(col) {
            angular.forEach(col.metrics, function(metric) {
                if (metric.aggregated === metricName && !metric.disabled) {
                    metric.active = $scope.aggregation.all[metricName];
                }
            });
        });
        $scope.aggregation.some[metricName] = false;
        $scope.aggregation.none[metricName] = !$scope.aggregation.all[metricName];
        $scope.regenMetricsSet();
    }

    $timeout(function() {
        $scope.selection.allObjects.forEach(function(e){
            e.$selected = e.metrics[0].active || false;
        });
        $scope.regenSelectionStateFromFlags();
    });

    $scope.setMetricStateFromSelected = function() {
        $scope.selection.allObjects.forEach(function(e){
            e.metrics[0].active = e.$selected || false;
        });
        $scope.regenMetricsSet();
    }

});

app.controller("MassMetricColumnSelectionController", function($scope, $timeout) {

    var aggregated = 'dummy';
    $scope.aggregation = {'all':{},'some':{},'none':{},'disabled':{}};

    $scope.recomputeAggregationStates = function() {
        var cols = $scope.selection.selectedObjects;
        $scope.aggregation = {'all':{},'some':{},'none':{},'disabled':{}};

        angular.forEach(cols, function(column){
            $scope.aggregation.all[aggregated] =
                ($scope.aggregation.all[aggregated] == undefined ? true : $scope.aggregation.all[aggregated])
                && (column.disabled ? false : column.active);
            $scope.aggregation.some[aggregated] =
                ($scope.aggregation.some[aggregated] || false)
                || (column.disabled ? false : column.active);
            $scope.aggregation.disabled[aggregated] =
                ($scope.aggregation.disabled[aggregated] || false)
                || !column.disabled;
        });
        for (var agg in $scope.aggregation.all) {
            $scope.aggregation.disabled[agg] = !$scope.aggregation.disabled[agg];
            $scope.aggregation.some[agg] = $scope.aggregation.some[agg] && !$scope.aggregation.all[agg];
            $scope.aggregation.none[agg] = !$scope.aggregation.some[agg] && !$scope.aggregation.all[agg];
        };
    }

    $timeout(function() {
        $scope.selection.allObjects.forEach(function(e){
            e.$selected = e.active || false;
        });
        $scope.regenSelectionStateFromFlags();
    });

    $scope.setMetricStateFromSelected = function() {
        $scope.selection.allObjects.forEach(function(e){
            e.active = e.$selected || false;
        });
        $scope.regenMetricsSet();
    }

});

})();
(function() {

const app = angular.module('dataiku.ngXmigration', []);

// This is a wrapper on dku-bs-select because in angularJS it has to be an attribute directive on <select>
// and upgraded components cannot be attribute directives
app.directive('ng1DkuBsSelect', ['$compile', function($compile) { 
    return {
        scope: {
            params: '<',
            list: '<',
            model: '<',
            ngOptions: '<',
            modelChange: '<',
            required: '<',
            optionsDescriptions: '<',
            optionsAnnotations: '<',
            layout: '<',
            dataActionsBox: '<',
            dataLiveSearch: '<',
            dkuMultiple: '<'
        },
        // directive breaks if optionsDescriptions is empty and passed to the select
        template: '',
        link: {
            pre: function($scope, $el, attrs) {
                $scope.$watch('model', () => {
                    $scope.modelChange.emit($scope.model);
                });
                
                // 1) adding multiple and optionsDescriptions using setAttribute doesn't work properly
                // and we cannot bind to neither multiple attribute in the template (angularjs limitation w/ ng model)
                // nor can be we bind to optionsDescriptions nor optionsAnnotations (throws an error if null)
                // without using ng-show/ng-if (which gets messy with several non-bindable attributes). 
                let select = `
                    <select dku-bs-select="params" ng-model="model" ng-options="{{ngOptions}}"
                    required="{{required}}" layout="{{layout}}"
                    data-actions-box="{{dataActionsBox}}" data-live-search="{{dataLiveSearch}}"
                `

                if ($scope.optionsDescriptions) {
                    select += ' options-descriptions="{{ optionsDescriptions }}" '
                }

                if ($scope.optionsAnnotations) {
                    select += ' options-annotations="{{ optionsAnnotations }}" '
                }

                if ($scope.dkuMultiple) {
                    select += ' multiple="multiple" '
                }

                select += '></select>'

                const $select = $compile(select)($scope);

                $el.append($select);
            }
        }
    };
}]);

app.directive('ng1ContainerSelectionForm', [ function() {
    return {
        scope: {
            selection: '<',
            selectionChange: '&'
        },
        template: `<div container-selection-form="_selection" />`,
        link: function($scope) {
            $scope.$watch('selection', () => {
                $scope._selection = angular.copy($scope.selection);
            }, true);
            $scope.$watch('_selection', () => {
                if ($scope._selection && !angular.equals($scope.selection, $scope._selection)) {
                    $scope.selectionChange(angular.copy($scope._selection));
                }
            }, true);
        }
    };
}]);

app.directive('ng1DatasetSelectionOrderingDirective', [ function() {
    return {
        scope: {
            selection: '=',
            datasetSupportsReadOrdering: '<',
            shakerState: '<'
        },
        template: `<div dataset-selection-ordering-fields selection="selection"
            dataset-supports-read-ordering="datasetSupportsReadOrdering"
            shaker-state="shakerState" />`,
    };
}]);

app.directive('ng1DatasetSelectorDirective', [ function() {
    return {
        scope: {
            dataset: '<',
            datasetChange: '<',
            availableDatasets: '<',
            required: '<',
        },
        template: `<div dataset-selector="dataset" available-datasets="availableDatasets" required="{{required}}"></div>`,
        link: function($scope) {      
            $scope.$watch('dataset', () => {
                if ($scope.datasetChange) {
                    $scope.datasetChange.emit($scope.dataset)
                }
            });
        }
    };
}]);

})();
