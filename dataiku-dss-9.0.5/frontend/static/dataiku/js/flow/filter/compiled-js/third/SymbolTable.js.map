{"version":3,"file":"SymbolTable.js","sourceRoot":"","sources":["../../third/SymbolTable.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * This file is released under the MIT license.\n * Copyright (c) 2017, Mike Lischke\n *\n * See LICENSE file for more info.\n */\n\n'use strict';\n\nimport { ParserRuleContext } from 'antlr4ts';\n\nexport class DuplicateSymbolError extends Error { };\n\nexport enum MemberVisibility {\n    Invalid = -1,\n    Public = 0,\n    Protected,\n    Private,\n    Library,\n};\n\nexport enum TypeKind {\n    Integer,\n    Float,\n    String,\n    Boolean,\n    Date,\n\n    Class,\n    Array,\n    Alias,\n};\n\nexport enum ReferenceKind {\n    Irrelevant,\n    Pointer,   // Default for most languages for dynamically allocated memory (\"Type*\" in C++).\n    Reference, // \"Type&\" in C++\n    Instance,  // \"Type\" as such and default for all value types.\n}\n\n// The root type interface. Used for typed symbols and type aliases.\nexport interface Type {\n    name: string;\n\n    // The super type of this type or empty if this is a fundamental type.\n    // Also used as the target type for type aliases.\n    baseTypes: Type[];\n    kind: TypeKind;\n    reference: ReferenceKind;\n};\n\nexport interface SymbolTableOptions {\n    allowDuplicateSymbols?: boolean;\n}\n\n// A single class for all fundamental types. They are distinguished via the kind field.\nexport class FundamentalType implements Type {\n    name: string;\n\n    get baseTypes(): Type[] { return []; }\n    get kind(): TypeKind { return this.typeKind; }\n    get reference(): ReferenceKind { return this.referenceKind; }\n\n    public static readonly integerType: FundamentalType = new FundamentalType(\"int\", TypeKind.Integer, ReferenceKind.Instance);\n    public static readonly floatType: FundamentalType = new FundamentalType(\"float\", TypeKind.Float, ReferenceKind.Instance);\n    public static readonly stringType: FundamentalType = new FundamentalType(\"string\", TypeKind.String, ReferenceKind.Instance);\n    public static readonly boolType: FundamentalType = new FundamentalType(\"bool\", TypeKind.Boolean, ReferenceKind.Instance);\n    public static readonly dateType: FundamentalType = new FundamentalType(\"date\", TypeKind.Date, ReferenceKind.Instance);\n\n    constructor(name: string, typeKind: TypeKind, referenceKind: ReferenceKind) {\n        this.name = name;\n        this.typeKind = typeKind;\n        this.referenceKind = referenceKind;\n    }\n\n    private typeKind: TypeKind;\n    private referenceKind: ReferenceKind;\n}\n\n// The root of the symbol table class hierarchy: a symbol can be any managable entity (like a block), not only\n// things like variables or classes.\n// We are using a class hierarchy here, instead of an enum or similar, to allow for easy extension and certain\n// symbols can so provide additional APIs for simpler access to their sub elements, if needed.\nexport class Symbol {\n    name: string = \"\"; // The name of the scope or empty if anonymous.\n    context: ParserRuleContext | undefined; // Reference to the parse tree which contains this symbol.\n\n    protected parent: Symbol | undefined;\n\n    constructor(name: string = \"\") {\n        this.name = name;\n    }\n\n    // The parent is usually a scoped symbol as only those can have children, but we allow\n    // any symbol here for special scenarios.\n    // This is rather an internal method and should rarely be used by external code.\n    setParent(parent: Symbol | undefined) {\n        this.parent = parent;\n    }\n\n    getParent(): Symbol | undefined {\n        return this.parent;\n    }\n\n    removeFromParent() {\n        if (this.parent instanceof ScopedSymbol) {\n            (this.parent as ScopedSymbol).removeSymbol(this);\n            this.parent = undefined;\n        }\n    }\n\n    // Get the outermost entity (below the symbol table) that holds us.\n    getRoot(): Symbol | undefined {\n        let run = this.parent;\n        while (run) {\n            if (!run.parent || (run.parent instanceof SymbolTable))\n                return run;\n            run = run.parent;\n        }\n        return run;\n    }\n\n    // Returns the symbol table we belong too or undefined if we are not yet assigned.\n    getSymbolTable(): SymbolTable | undefined {\n        if (this instanceof SymbolTable) {\n            return this;\n        }\n\n        let run = this.parent;\n        while (run) {\n            if (run instanceof SymbolTable)\n                return run;\n            run = run.parent;\n        }\n        return undefined;\n    }\n\n    // Returns the next enclosing parent of the given type.\n    getParentOfType<T extends Symbol>(t: new (...args: any[]) => T): T | undefined {\n        let run = this.parent;\n        while (run) {\n            if (run instanceof t)\n                return <T>run;\n            run = run.parent;\n        }\n        return undefined;\n    }\n\n    // The list of symbols from this one up to root.\n    getSymbolPath(): Symbol[] {\n        let result: Symbol[] = [];\n        let run: Symbol = this;\n        while (run) {\n            result.push(run);\n            if (!run.parent)\n                break;\n            run = run.parent;\n        }\n        return result;\n    }\n\n    // Create a qualified identifier from this symbol and its parent.\n    // If `full` is true then all parents are traversed in addition to this instance.\n    qualifiedName(separator = \".\", full = false, includeAnonymous = false): string {\n        if (!includeAnonymous && this.name.length == 0)\n            return \"\";\n\n        let result: string = this.name.length == 0 ? \"<anonymous>\" : this.name;\n        let run = this.parent;\n        while (run) {\n            if (includeAnonymous || run.name.length > 0) {\n                result = (run.name.length == 0 ? \"<anonymous>\" : run.name) + separator + result;\n                if (!full || !run.parent)\n                    break;\n            }\n            run = run.parent;\n        }\n        return result;\n    }\n\n};\n\n// A symbol with an attached type (variables, fields etc.).\nexport class TypedSymbol extends Symbol {\n    type: Type | undefined;\n\n    constructor(name: string, type?: Type) {\n        super(name);\n        this.type = type;\n    }\n};\n\n// An alias for another type.\nexport class TypeAlias extends Symbol implements Type {\n    get baseTypes(): Type[] { return [this.targetType]; }\n    get kind(): TypeKind { return TypeKind.Alias; }\n    get reference(): ReferenceKind { return ReferenceKind.Irrelevant; }\n\n    constructor(name: string, target: Type) {\n        super(name);\n        this.targetType = target;\n    }\n\n    private targetType: Type;\n};\n\n// A symbol with a scope (so it can have child symbols).\nexport class ScopedSymbol extends Symbol {\n    constructor(name = \"\") {\n        super(name)\n    }\n\n    // Adds the given symbol to this scope. If it belongs already to a different scope\n    // it is removed from that before adding it here.\n    addSymbol(symbol: Symbol) {\n        symbol.removeFromParent();\n\n        // Check for duplicates first.\n        let symbolTable = this.getSymbolTable();\n        if (!symbolTable || !symbolTable.options.allowDuplicateSymbols) {\n            for (let child of this.children) {\n                if (child == symbol || (symbol.name.length > 0 && child.name == symbol.name)) {\n                    let name = symbol.name;\n                    if (name.length == 0)\n                        name = \"<anonymous>\";\n                    throw new DuplicateSymbolError(\"Attempt to add duplicate symbol '\" + name + \"'\");\n                }\n            }\n        }\n\n        this.children.push(symbol);\n        symbol.setParent(this);\n    }\n\n    removeSymbol(symbol: Symbol) {\n        let index = this.children.indexOf(symbol);\n        if (index > -1) {\n            this.children.splice(index, 1);\n            symbol.setParent(undefined);\n        }\n    }\n\n    // Returns direct children of a given type.\n    getSymbolsOfType<T extends Symbol>(t: new (...args: any[]) => T): T[] {\n        let result: T[] = [];\n        for (let child of this.children) {\n            if (child instanceof t)\n                result.push(<T>child);\n        }\n\n        return result;\n    }\n\n    // Returns all (nested) children of a given type. Mostly useful for tests.\n    getNestedSymbolsOfType<T extends Symbol>(t: new (...args: any[]) => T): T[] {\n        let result: T[] = [];\n\n        for (let child of this.children) {\n            if (child instanceof t)\n                result.push(child);\n            if (child instanceof ScopedSymbol)\n                result.push(...child.getNestedSymbolsOfType(t));\n        }\n\n        return result;\n    }\n\n    // Returns symbols from this and all nested scopes in the order they were defined.\n    getAllNestedSymbols(): Symbol[] {\n        let result: Symbol[] = [];\n\n        for (let child of this.children) {\n            result.push(child);\n            if (child instanceof ScopedSymbol)\n                result.push(...child.getAllNestedSymbols());\n        }\n\n        return result;\n    }\n\n    // Returns all symbols of the the given type accessible from this scope.\n    // TODO: add optional position dependency (only symbols defined before a given caret pos are viable).\n    getAllSymbols<T extends Symbol>(t: new (...args: any[]) => T, localOnly = false): Symbol[] {\n        let result: Symbol[] = [];\n\n        // Special handling for namespaces, which act like grouping symbols in this scope,\n        // so we show them as available in this scope.\n        for (let child of this.children) {\n            if (child instanceof t) {\n                result.push(child);\n            }\n            if (child instanceof NamespaceSymbol)\n                result.push(...child.getAllSymbols(t, true));\n        }\n\n        if (!localOnly) {\n            if (this.parent && this.parent instanceof ScopedSymbol)\n                result.push(...this.parent.getAllSymbols(t));\n        }\n\n        return result;\n    }\n\n    // Returns the first symbol, from top to bottom, with a given name from this scope\n    // or any of the parent scopes (conditionally).\n    resolve(name: string, localOnly = false): Symbol | undefined {\n        for (let child of this.children) {\n            if (child.name == name)\n                return child;\n        }\n\n        // Nothing found locally. Let the parent continue.\n        if (!localOnly) {\n            if (this.parent && this.parent instanceof ScopedSymbol)\n                return (this.parent as ScopedSymbol).resolve(name, false);\n        }\n\n        return undefined;\n    }\n\n    // Returns all accessible symbols that have a type assigned.\n    getTypedSymbols(localOnly = true): TypedSymbol[] {\n        let result: TypedSymbol[] = []\n\n        for (let child of this.children) {\n            if (child instanceof TypedSymbol) {\n                result.push(child);\n            }\n        }\n\n        if (!localOnly) {\n            if (this.parent instanceof ScopedSymbol) {\n                let localList = (this.parent as ScopedSymbol).getTypedSymbols(true);\n                result.push(...localList);\n            }\n        }\n\n        return result;\n    }\n\n    // The names of all accessible symbols with a type.\n    getTypedSymbolNames(localOnly = true): string[] {\n        let result: string[] = [];\n        for (let child of this.children) {\n            if (child instanceof TypedSymbol) {\n                result.push(child.name);\n            }\n        }\n\n        if (!localOnly) {\n            if (this.parent instanceof ScopedSymbol) {\n                let localList = (this.parent as ScopedSymbol).getTypedSymbolNames(true);\n                result.push(...localList);\n            }\n        }\n\n        return result;\n    }\n\n    // Returns all direct child symbols with a scope (e.g. classes in a module).\n    getDirectScopes(): ScopedSymbol[] {\n        return this.getSymbolsOfType(ScopedSymbol);\n    }\n\n    symbolFromPath(path: string, separator: string = \".\"): Symbol | undefined {\n        let elements = path.split(separator);\n        let index = 0;\n        if (elements[0] == this.name || elements[0].length == 0)\n            ++index;\n\n        let result: Symbol = this;\n        while (index < elements.length) {\n            if (!(result instanceof ScopedSymbol)) // Some parts left but found a non-scoped symbol?\n                return undefined;\n\n            let child = result.children.find(child => child.name == elements[index]);\n            if (!child)\n                return undefined;\n            result = child;\n            ++index;\n        }\n        return result;\n    }\n\n    protected children: Symbol[] = []; // All child symbols in definition order.\n};\n\nexport class NamespaceSymbol extends ScopedSymbol {\n}\n\nexport class VariableSymbol extends TypedSymbol {\n    constructor(name: string, value: any, type?: Type) {\n        super(name, type);\n        this.value = value;\n    }\n\n    value: any;\n};\n\nexport class LiteralSymbol extends TypedSymbol {\n    constructor(name: string, value: any, type?: Type) {\n        super(name, type);\n        this.value = value;\n    }\n\n    readonly value: any;\n};\n\nexport class ParameterSymbol extends VariableSymbol { };\n\n// A standalone function/procedure/rule.\nexport class RoutineSymbol extends ScopedSymbol {\n    returnType: Type | undefined; // Can be null if result is void.\n\n    constructor(name: string, returnType: Type) {\n        super(name);\n        this.returnType = returnType;\n    }\n\n    getVariables(localOnly = true): VariableSymbol[] {\n        return this.getSymbolsOfType(VariableSymbol);\n    }\n\n    getParameters(localOnly = true): ParameterSymbol[] {\n        return this.getSymbolsOfType(ParameterSymbol);\n    }\n};\n\nexport enum MethodFlags {\n    None = 0,\n    Virtual = 1,\n    Const = 2,\n    Overwritten = 4,\n    SetterOrGetter = 8, // Distinguished by the return type.\n    Explicit = 16,      // Special flag used e.g. in C++ for explicit c-tors.\n};\n\n// A routine which belongs to a class or other outer container structure.\nexport class MethodSymbol extends RoutineSymbol {\n    methodFlags = MethodFlags.None;\n    visibility = MemberVisibility.Invalid;\n\n    constructor(name: string, returnType: Type) {\n        super(name, returnType);\n    }\n};\n\nexport class FieldSymbol extends VariableSymbol {\n    visibility = MemberVisibility.Invalid;\n\n    setter: MethodSymbol | undefined;\n    getter: MethodSymbol | undefined;\n\n    constructor(name: string, type: Type) {\n        super(name, type);\n    }\n};\n\n// Classes and structs.\nexport class ClassSymbol extends ScopedSymbol implements Type {\n\n    get baseTypes(): Type[] { return this.superClasses; };\n    get kind(): TypeKind { return TypeKind.Class; }\n    get reference(): ReferenceKind { return this.referenceKind; }\n\n    isStruct = false;\n\n    // Usually only one member, unless the language supports multiple inheritance.\n    readonly superClasses: ClassSymbol[] = [];\n\n    constructor(name: string, referenceKind: ReferenceKind, ...superClass: ClassSymbol[]) {\n        super(name);\n        this.referenceKind = referenceKind;\n        this.superClasses.push(...superClass); // Standard case: a single super class.\n    }\n\n    // Returns a list of all methods.\n    getMethods(includeInherited = false): MethodSymbol[] {\n        return this.getSymbolsOfType(MethodSymbol);\n    }\n\n    // Returns all fields.\n    getFields(includeInherited = false): FieldSymbol[] {\n        return this.getSymbolsOfType(FieldSymbol);\n    }\n\n    private referenceKind: ReferenceKind;\n};\n\nexport class ArrayType extends Symbol implements Type {\n\n    get baseTypes(): Type[] { return []; };\n    get kind(): TypeKind { return TypeKind.Array; }\n    get reference(): ReferenceKind { return this.referenceKind; }\n\n    readonly elementType: Type;\n    readonly size: number; // > 0 if fixed length.\n\n    constructor(name: string, referenceKind: ReferenceKind, elemType: Type, size = 0) {\n        super(name);\n        this.referenceKind = referenceKind;\n        this.elementType = elemType;\n        this.size = size;\n    }\n\n    private referenceKind: ReferenceKind;\n};\n\n// A few more types for databases.\nexport class CatalogSymbol extends ScopedSymbol {\n};\n\nexport class SchemaSymbol extends ScopedSymbol {\n};\n\nexport class TableSymbol extends ScopedSymbol {\n};\n\nexport class ViewSymbol extends ScopedSymbol {\n};\n\nexport class EventSymbol extends ScopedSymbol {\n};\n\nexport class ColumnSymbol extends TypedSymbol {\n};\n\nexport class IndexSymbol extends Symbol { // Made of columns, but doesn't contain them. Hence not a scope.\n};\n\nexport class PrimaryKeySymbol extends Symbol { // ditto\n};\n\nexport class ForeignKeySymbol extends Symbol { // ditto\n};\n\nexport class StoredRoutineSymbol extends RoutineSymbol {\n};\n\nexport class TriggerSymbol extends ScopedSymbol {\n};\n\nexport class UdfSymbol extends Symbol { // No body nor parameter info.\n};\n\nexport class EngineSymbol extends Symbol {\n};\n\nexport class TableSpaceSymbol extends Symbol {\n};\n\nexport class LogfileGroupSymbol extends Symbol {\n};\n\nexport class CharsetSymbol extends Symbol {\n};\n\nexport class CollationSymbol extends Symbol {\n};\n\nexport class UserVariableSymbol extends VariableSymbol {\n};\n\nexport class SystemVariableSymbol extends Symbol {\n};\n\n// The main class managing all the symbols for a top level entity like a file, library or similar.\nexport class SymbolTable extends ScopedSymbol {\n    constructor(name: string, public readonly options: SymbolTableOptions) {\n        super(name);\n    }\n\n    clear() {\n        this.dependencies.clear();\n        this.children = [];\n    }\n\n    addDependencies(...tables: SymbolTable[]) {\n        tables.forEach((value, key) => {\n            this.dependencies.add(value);\n        });\n    }\n\n    removeDependency(table: SymbolTable) {\n        if (this.dependencies.has(table)) {\n            this.dependencies.delete(table);\n        }\n    }\n\n    // Instance informations, mostly relevant for unit testing.\n    getInfo() {\n        return {\n            dependencyCount: this.dependencies.size,\n            symbolCount: this.children.length\n        };\n    }\n\n    addNewSymbolOfType<T extends Symbol>(t: new (...args: any[]) => T, parent: ScopedSymbol | undefined, ...args: any[]): T {\n        let result = new t(...args);\n        if (!parent || parent == this) {\n            this.addSymbol(result);\n        } else {\n            parent.addSymbol(result);\n        }\n        return result;\n    }\n\n    // Adds a new namespace to the symbol table or the given parent. The path parameter specifies a single namespace name\n    // or a chain of namespaces (which can be e.g. \"outer.intermittant.inner.final\").\n    // If any of the parent namespaces is missing they are created implicitly. The final part must not exist however\n    // or you'll get a duplicate symbol error.\n    addNewNamespaceFromPath(parent: ScopedSymbol | undefined, path: string, delimiter = \".\"): NamespaceSymbol {\n        let parts = path.split(delimiter);\n        let i = 0;\n        let currentParent = (parent == undefined) ? this : parent;\n        while (i < parts.length - 1) {\n            let namespace = currentParent.resolve(parts[i], true) as NamespaceSymbol;\n            if (namespace == undefined) {\n                namespace = this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[i]);\n            }\n            currentParent = namespace;\n            ++i;\n        }\n        return this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[parts.length - 1]);\n    }\n\n    getAllSymbols<T extends Symbol>(t?: new (...args: any[]) => T, localOnly: boolean = false): Symbol[] {\n        let type = t ? t : Symbol;\n        let result = super.getAllSymbols(type, localOnly);\n\n        if (!localOnly) {\n            for (let dependency of this.dependencies) {\n                result.push(...dependency.getAllSymbols(t, localOnly));\n            }\n        }\n\n        return result;\n    }\n\n    resolve(name: string, localOnly = false): Symbol | undefined {\n        let result = super.resolve(name, localOnly);\n\n        if (!result && !localOnly) {\n            for (let dependency of this.dependencies) {\n                result = dependency.resolve(name, false);\n                if (result)\n                    break;\n            }\n        }\n\n        return result;\n    }\n\n    // Other symbol information available to this instance.\n    protected dependencies: Set<SymbolTable> = new Set();\n};\n"]}