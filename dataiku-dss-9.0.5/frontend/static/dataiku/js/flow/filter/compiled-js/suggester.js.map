{"version":3,"file":"suggester.js","sourceRoot":"","sources":["../suggester.ts"],"names":[],"mappings":";;;AAAA,uCAOkB;AAClB,iEAA4D;AAC5D,mEAA8D;AAC9D,oCAAoC;AAEpC,MAAa,aAAa;IAGtB,WAAW,CAAkB,UAA8B,EAAE,eAA8B,EAAE,IAAY,EAC5E,kBAA0B,EAAE,GAAW,EAAE,CAAmC;QACrG,IAAI,CAAC,cAAc,GAAG,eAAe,CAAC;IAC1C,CAAC;CACJ;AAPD,sCAOC;AAAA,CAAC;AAEF,SAAS,aAAa,CAAC,KAAa;IAChC,IAAI,WAAW,GAAG,IAAI,2BAAgB,CAAC,KAAK,CAAC,CAAC;IAC9C,IAAI,KAAK,GAAG,IAAI,iCAAe,CAAC,WAAW,CAAC,CAAC;IAC7C,IAAI,WAAW,GAAG,IAAI,4BAAiB,CAAC,KAAK,CAAC,CAAC;IAE/C,IAAI,MAAM,GAAG,IAAI,mCAAgB,CAAC,WAAW,CAAC,CAAC;IAC/C,KAAK,CAAC,oBAAoB,EAAE,CAAC;IAC7B,MAAM,CAAC,oBAAoB,EAAE,CAAC;IAC9B,IAAI,IAAI,GAAG,IAAI,EAAE,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC;IAC7C,IAAI,aAAa,GAAG,IAAI,aAAa,EAAE,CAAC;IACxC,MAAM,CAAC,gBAAgB,CAAC,aAAa,CAAC,CAAC;IACvC,IAAI,IAAI,GAAG,MAAM,CAAC,KAAK,EAAE,CAAC;IAE1B,IAAI,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC,aAAa,CAAC,cAAc,IAAI,aAAa,CAAC,cAAc,CAAC,IAAI,IAAI,gBAAK,CAAC,GAAG,CAAC,CAAC,CAAC,WAAW,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;IAElK,SAAS,iBAAiB,CAAC,UAAyB;QAChD,OAAO,UAAU;aACZ,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC;aAClB,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;aAC5C,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;aACnC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,CAAC,CAAA;IAC/B,CAAC;IAAA,CAAC;IACF,OAAO;QACH,MAAM,EAAE,iBAAiB,CAAC,WAAW,CAAC,SAAS,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;QACnE,WAAW,EAAE,iBAAiB,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC;QAC3E,cAAc,EAAE,aAAa,CAAC,cAAc,CAAC,CAAC,CAAC,aAAa,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI;KAC1F,CAAC;AACN,CAAC;AAEO,sCAAa","sourcesContent":["import {\n    ANTLRInputStream,\n    CommonTokenStream,\n    ANTLRErrorListener,\n    Recognizer,\n    Token,\n    RecognitionException\n} from 'antlr4ts';\nimport {FlowFilterLexer} from \"./generated/FlowFilterLexer\";\nimport {FlowFilterParser} from \"./generated/FlowFilterParser\";\nimport * as c3 from \"./third/index\";\n\nexport class ErrorListener implements ANTLRErrorListener<Token> {\n    public offeringSymbol: Token | undefined;\n\n    syntaxError<T extends Token>(recognizer: Recognizer<T, any>, offendingSymbol: T | undefined, line: number,\n                                 charPositionInLine: number, msg: string, e: RecognitionException | undefined) {\n        this.offeringSymbol = offendingSymbol;\n    }\n};\n\nfunction suggestTokens(input: string) {\n    let inputStream = new ANTLRInputStream(input);\n    let lexer = new FlowFilterLexer(inputStream);\n    let tokenStream = new CommonTokenStream(lexer);\n\n    let parser = new FlowFilterParser(tokenStream);\n    lexer.removeErrorListeners();\n    parser.removeErrorListeners();\n    let core = new c3.CodeCompletionCore(parser);\n    let errorListener = new ErrorListener();\n    parser.addErrorListener(errorListener);\n    let tree = parser.parse();\n\n    let candidates = core.collectCandidates(errorListener.offeringSymbol && errorListener.offeringSymbol.type != Token.EOF ? tokenStream.size - 2 : tokenStream.size);\n\n    function tokenTypesToNames(tokenTypes: Array<number>) {\n        return tokenTypes\n            .filter(e => e > 0)\n            .map(e => lexer.vocabulary.getDisplayName(e))\n            .map(e => e.replace(/^\\'|\\'$/g, \"\"))\n            .filter(e => e !== ' ')\n    };\n    return {\n        tokens: tokenTypesToNames(tokenStream.getTokens().map(e => e.type)),\n        suggestions: tokenTypesToNames(Array.from(candidates.tokens.keys()).sort()),\n        offeringSymbol: errorListener.offeringSymbol ? errorListener.offeringSymbol.text : null\n    };\n}\n\nexport {suggestTokens};"]}