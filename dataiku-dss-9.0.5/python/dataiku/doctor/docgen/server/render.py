import logging
import sys
import traceback
import json

from dataiku.base.socket_block_link import JavaLink
from dataiku.base.utils import watch_stdin, get_json_friendly_error
from dataiku.doctor.docgen.renderer.renderer import Renderer
from dataiku.doctor.docgen.common.docx_io import DocxIO
from dataiku.doctor.docgen.renderer.puppeteer_extractor import PuppeteerExtractor

# socket-based connection to backend
# the goal of this server is to replace the placeholders inside the docx by their values.
def serve(port, secret):
    link = JavaLink(port, secret)
    # initiate connection
    link.connect()
    # get work to do
    command = link.read_json()
    try:
        task = command.get("task", "")
        template_path = command.get("templatePath", "")
        resolved_result_path = command.get("resolvedResultPath", "")
        conditional_resolved_result_path = command.get("conditionalResolvedResultPath", "")
        output_file = command.get("outputFile", "")
        project_key = command.get("projectKey", "")
        print("Command received from DSS ", task, template_path, resolved_result_path, output_file, project_key)

        docx_io = DocxIO()
        document = docx_io.load(template_path)
        renderer = Renderer()


        with open(resolved_result_path) as json_file:
            # This file was generated by the java class "ResolvedResult".
            resolved_regular_placeholders = json.load(json_file)

        with open(conditional_resolved_result_path) as json_file:
            # This file was generated by the java class "ResolvedResult".
            resolved_conditional_placeholders = json.load(json_file)

        # Replace the conditional placeholders
        document = renderer.resolve_conditional_placeholder(document, resolved_conditional_placeholders)

        # And finally replace the regular placeholders
        puppeteer_extractor = PuppeteerExtractor(project_key)
        renderer.render(puppeteer_extractor, document, resolved_regular_placeholders)
        docx_io.to_folder_file(document, output_file)

        # send ack
        link.send_json({'ok': True, 'count': 0})
    except:
        link.send_string('') # mark failure
        traceback.print_exc()
        link.send_json(get_json_friendly_error())
    finally:
        # done
        link.close()


if __name__ == "__main__":
    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(levelname)s %(message)s')
    watch_stdin()
    serve(int(sys.argv[1]), sys.argv[2])
